// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: atk
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <atk/atk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.atk_text_attribute_get_type()), F: marshalTextAttribute},
		{T: externglib.Type(C.atk_text_boundary_get_type()), F: marshalTextBoundary},
		{T: externglib.Type(C.atk_text_clip_type_get_type()), F: marshalTextClipType},
		{T: externglib.Type(C.atk_text_granularity_get_type()), F: marshalTextGranularity},
		{T: externglib.Type(C.atk_text_get_type()), F: marshalTexter},
		{T: externglib.Type(C.atk_text_range_get_type()), F: marshalTextRange},
	})
}

// TextAttribute describes the text attributes supported
type TextAttribute int

const (
	// TextAttrInvalid: invalid attribute, like bad spelling or grammar.
	TextAttrInvalid TextAttribute = iota
	// TextAttrLeftMargin: pixel width of the left margin
	TextAttrLeftMargin
	// TextAttrRightMargin: pixel width of the right margin
	TextAttrRightMargin
	// TextAttrIndent: number of pixels that the text is indented
	TextAttrIndent
	// TextAttrInvisible: either "true" or "false" indicating whether text is
	// visible or not
	TextAttrInvisible
	// TextAttrEditable: either "true" or "false" indicating whether text is
	// editable or not
	TextAttrEditable
	// TextAttrPixelsAboveLines pixels of blank space to leave above each
	// newline-terminated line.
	TextAttrPixelsAboveLines
	// TextAttrPixelsBelowLines pixels of blank space to leave below each
	// newline-terminated line.
	TextAttrPixelsBelowLines
	// TextAttrPixelsInsideWrap pixels of blank space to leave between wrapped
	// lines inside the same newline-terminated line (paragraph).
	TextAttrPixelsInsideWrap
	// TextAttrBgFullHeight: "true" or "false" whether to make the background
	// color for each character the height of the highest font used on the
	// current line, or the height of the font used for the current character.
	TextAttrBgFullHeight
	// TextAttrRise: number of pixels that the characters are risen above the
	// baseline. See also ATK_TEXT_ATTR_TEXT_POSITION.
	TextAttrRise
	// TextAttrUnderline: "none", "single", "double", "low", or "error"
	TextAttrUnderline
	// TextAttrStrikethrough: "true" or "false" whether the text is
	// strikethrough
	TextAttrStrikethrough
	// TextAttrSize of the characters in points. eg: 10
	TextAttrSize
	// TextAttrScale of the characters. The value is a string representation of
	// a double
	TextAttrScale
	// TextAttrWeight of the characters.
	TextAttrWeight
	// TextAttrLanguage used
	TextAttrLanguage
	// TextAttrFamilyName: font family name
	TextAttrFamilyName
	// TextAttrBgColor: background color. The value is an RGB value of the
	// format "u,u,u"
	TextAttrBgColor
	// TextAttrFgColor: foreground color. The value is an RGB value of the
	// format "u,u,u"
	TextAttrFgColor
	// TextAttrBgStipple: "true" if a Bitmap is set for stippling the background
	// color.
	TextAttrBgStipple
	// TextAttrFgStipple: "true" if a Bitmap is set for stippling the foreground
	// color.
	TextAttrFgStipple
	// TextAttrWrapMode: wrap mode of the text, if any. Values are "none",
	// "char", "word", or "word_char".
	TextAttrWrapMode
	// TextAttrDirection of the text, if set. Values are "none", "ltr" or "rtl"
	TextAttrDirection
	// TextAttrJustification of the text, if set. Values are "left", "right",
	// "center" or "fill"
	TextAttrJustification
	// TextAttrStretch of the text, if set. Values are "ultra_condensed",
	// "extra_condensed", "condensed", "semi_condensed", "normal",
	// "semi_expanded", "expanded", "extra_expanded" or "ultra_expanded"
	TextAttrStretch
	// TextAttrVariant: capitalization variant of the text, if set. Values are
	// "normal" or "small_caps"
	TextAttrVariant
	// TextAttrStyle: slant style of the text, if set. Values are "normal",
	// "oblique" or "italic"
	TextAttrStyle
	// TextAttrTextPosition: vertical position with respect to the baseline.
	// Values are "baseline", "super", or "sub". Note that a super or sub text
	// attribute refers to position with respect to the baseline of the prior
	// character.
	TextAttrTextPosition
	// TextAttrLastDefined: not a valid text attribute, used for finding end of
	// enumeration
	TextAttrLastDefined
)

func marshalTextAttribute(p uintptr) (interface{}, error) {
	return TextAttribute(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TextAttribute.
func (t TextAttribute) String() string {
	switch t {
	case TextAttrInvalid:
		return "Invalid"
	case TextAttrLeftMargin:
		return "LeftMargin"
	case TextAttrRightMargin:
		return "RightMargin"
	case TextAttrIndent:
		return "Indent"
	case TextAttrInvisible:
		return "Invisible"
	case TextAttrEditable:
		return "Editable"
	case TextAttrPixelsAboveLines:
		return "PixelsAboveLines"
	case TextAttrPixelsBelowLines:
		return "PixelsBelowLines"
	case TextAttrPixelsInsideWrap:
		return "PixelsInsideWrap"
	case TextAttrBgFullHeight:
		return "BgFullHeight"
	case TextAttrRise:
		return "Rise"
	case TextAttrUnderline:
		return "Underline"
	case TextAttrStrikethrough:
		return "Strikethrough"
	case TextAttrSize:
		return "Size"
	case TextAttrScale:
		return "Scale"
	case TextAttrWeight:
		return "Weight"
	case TextAttrLanguage:
		return "Language"
	case TextAttrFamilyName:
		return "FamilyName"
	case TextAttrBgColor:
		return "BgColor"
	case TextAttrFgColor:
		return "FgColor"
	case TextAttrBgStipple:
		return "BgStipple"
	case TextAttrFgStipple:
		return "FgStipple"
	case TextAttrWrapMode:
		return "WrapMode"
	case TextAttrDirection:
		return "Direction"
	case TextAttrJustification:
		return "Justification"
	case TextAttrStretch:
		return "Stretch"
	case TextAttrVariant:
		return "Variant"
	case TextAttrStyle:
		return "Style"
	case TextAttrTextPosition:
		return "TextPosition"
	case TextAttrLastDefined:
		return "LastDefined"
	default:
		return fmt.Sprintf("TextAttribute(%d)", t)
	}
}

// TextAttributeForName: get the TextAttribute type corresponding to a text
// attribute name.
func TextAttributeForName(name string) TextAttribute {
	var _arg1 *C.gchar           // out
	var _cret C.AtkTextAttribute // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.atk_text_attribute_for_name(_arg1)
	runtime.KeepAlive(name)

	var _textAttribute TextAttribute // out

	_textAttribute = TextAttribute(_cret)

	return _textAttribute
}

// TextAttributeGetName gets the name corresponding to the TextAttribute
func TextAttributeGetName(attr TextAttribute) string {
	var _arg1 C.AtkTextAttribute // out
	var _cret *C.gchar           // in

	_arg1 = C.AtkTextAttribute(attr)

	_cret = C.atk_text_attribute_get_name(_arg1)
	runtime.KeepAlive(attr)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TextAttributeGetValue gets the value for the index of the TextAttribute
func TextAttributeGetValue(attr TextAttribute, index_ int) string {
	var _arg1 C.AtkTextAttribute // out
	var _arg2 C.gint             // out
	var _cret *C.gchar           // in

	_arg1 = C.AtkTextAttribute(attr)
	_arg2 = C.gint(index_)

	_cret = C.atk_text_attribute_get_value(_arg1, _arg2)
	runtime.KeepAlive(attr)
	runtime.KeepAlive(index_)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TextAttributeRegister: associate name with a new TextAttribute
func TextAttributeRegister(name string) TextAttribute {
	var _arg1 *C.gchar           // out
	var _cret C.AtkTextAttribute // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.atk_text_attribute_register(_arg1)
	runtime.KeepAlive(name)

	var _textAttribute TextAttribute // out

	_textAttribute = TextAttribute(_cret)

	return _textAttribute
}

// TextBoundary: text boundary types used for specifying boundaries for regions
// of text. This enumeration is deprecated since 2.9.4 and should not be used.
// Use AtkTextGranularity with #atk_text_get_string_at_offset instead.
type TextBoundary int

const (
	// TextBoundaryChar: boundary is the boundary between characters (including
	// non-printing characters)
	TextBoundaryChar TextBoundary = iota
	// TextBoundaryWordStart: boundary is the start (i.e. first character) of a
	// word.
	TextBoundaryWordStart
	// TextBoundaryWordEnd: boundary is the end (i.e. last character) of a word.
	TextBoundaryWordEnd
	// TextBoundarySentenceStart: boundary is the first character in a sentence.
	TextBoundarySentenceStart
	// TextBoundarySentenceEnd: boundary is the last (terminal) character in a
	// sentence; in languages which use "sentence stop" punctuation such as
	// English, the boundary is thus the '.', '?', or similar terminal
	// punctuation character.
	TextBoundarySentenceEnd
	// TextBoundaryLineStart: boundary is the initial character of the content
	// or a character immediately following a newline, linefeed, or return
	// character.
	TextBoundaryLineStart
	// TextBoundaryLineEnd: boundary is the linefeed, or return character.
	TextBoundaryLineEnd
)

func marshalTextBoundary(p uintptr) (interface{}, error) {
	return TextBoundary(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TextBoundary.
func (t TextBoundary) String() string {
	switch t {
	case TextBoundaryChar:
		return "Char"
	case TextBoundaryWordStart:
		return "WordStart"
	case TextBoundaryWordEnd:
		return "WordEnd"
	case TextBoundarySentenceStart:
		return "SentenceStart"
	case TextBoundarySentenceEnd:
		return "SentenceEnd"
	case TextBoundaryLineStart:
		return "LineStart"
	case TextBoundaryLineEnd:
		return "LineEnd"
	default:
		return fmt.Sprintf("TextBoundary(%d)", t)
	}
}

// TextClipType describes the type of clipping required.
type TextClipType int

const (
	// TextClipNone: no clipping to be done
	TextClipNone TextClipType = iota
	// TextClipMin: text clipped by min coordinate is omitted
	TextClipMin
	// TextClipMax: text clipped by max coordinate is omitted
	TextClipMax
	// TextClipBoth: only text fully within mix/max bound is retained
	TextClipBoth
)

func marshalTextClipType(p uintptr) (interface{}, error) {
	return TextClipType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TextClipType.
func (t TextClipType) String() string {
	switch t {
	case TextClipNone:
		return "None"
	case TextClipMin:
		return "Min"
	case TextClipMax:
		return "Max"
	case TextClipBoth:
		return "Both"
	default:
		return fmt.Sprintf("TextClipType(%d)", t)
	}
}

// TextGranularity: text granularity types used for specifying the granularity
// of the region of text we are interested in.
type TextGranularity int

const (
	// TextGranularityChar: granularity is defined by the boundaries between
	// characters (including non-printing characters)
	TextGranularityChar TextGranularity = iota
	// TextGranularityWord: granularity is defined by the boundaries of a word,
	// starting at the beginning of the current word and finishing at the
	// beginning of the following one, if present.
	TextGranularityWord
	// TextGranularitySentence: granularity is defined by the boundaries of a
	// sentence, starting at the beginning of the current sentence and finishing
	// at the beginning of the following one, if present.
	TextGranularitySentence
	// TextGranularityLine: granularity is defined by the boundaries of a line,
	// starting at the beginning of the current line and finishing at the
	// beginning of the following one, if present.
	TextGranularityLine
	// TextGranularityParagraph: granularity is defined by the boundaries of a
	// paragraph, starting at the beginning of the current paragraph and
	// finishing at the beginning of the following one, if present.
	TextGranularityParagraph
)

func marshalTextGranularity(p uintptr) (interface{}, error) {
	return TextGranularity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TextGranularity.
func (t TextGranularity) String() string {
	switch t {
	case TextGranularityChar:
		return "Char"
	case TextGranularityWord:
		return "Word"
	case TextGranularitySentence:
		return "Sentence"
	case TextGranularityLine:
		return "Line"
	case TextGranularityParagraph:
		return "Paragraph"
	default:
		return fmt.Sprintf("TextGranularity(%d)", t)
	}
}

// TextOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TextOverrider interface {
	// AddSelection adds a selection bounded by the specified offsets.
	AddSelection(startOffset int, endOffset int) bool
	// BoundedRanges: get the ranges of text in the specified bounding box.
	BoundedRanges(rect *TextRectangle, coordType CoordType, xClipType TextClipType, yClipType TextClipType) []*TextRange
	// CaretOffset gets the offset of the position of the caret (cursor).
	CaretOffset() int
	// CharacterAtOffset gets the specified text.
	CharacterAtOffset(offset int) uint32
	// CharacterCount gets the character count.
	CharacterCount() int
	// CharacterExtents: if the extent can not be obtained (e.g. missing
	// support), all of x, y, width, height are set to -1.
	//
	// Get the bounding box containing the glyph representing the character at a
	// particular text offset.
	CharacterExtents(offset int, coords CoordType) (x int, y int, width int, height int)
	// NSelections gets the number of selected regions.
	NSelections() int
	// OffsetAtPoint gets the offset of the character located at coordinates x
	// and y. x and y are interpreted as being relative to the screen or this
	// widget's window depending on coords.
	OffsetAtPoint(x int, y int, coords CoordType) int
	// RangeExtents: get the bounding box for text within the specified range.
	//
	// If the extents can not be obtained (e.g. or missing support), the
	// rectangle fields are set to -1.
	RangeExtents(startOffset int, endOffset int, coordType CoordType) TextRectangle
	// Selection gets the text from the specified selection.
	Selection(selectionNum int) (startOffset int, endOffset int, utf8 string)
	// StringAtOffset gets a portion of the text exposed through an Text
	// according to a given offset and a specific granularity, along with the
	// start and end offsets defining the boundaries of such a portion of text.
	//
	// If granularity is ATK_TEXT_GRANULARITY_CHAR the character at the offset
	// is returned.
	//
	// If granularity is ATK_TEXT_GRANULARITY_WORD the returned string is from
	// the word start at or before the offset to the word start after the
	// offset.
	//
	// The returned string will contain the word at the offset if the offset is
	// inside a word and will contain the word before the offset if the offset
	// is not inside a word.
	//
	// If granularity is ATK_TEXT_GRANULARITY_SENTENCE the returned string is
	// from the sentence start at or before the offset to the sentence start
	// after the offset.
	//
	// The returned string will contain the sentence at the offset if the offset
	// is inside a sentence and will contain the sentence before the offset if
	// the offset is not inside a sentence.
	//
	// If granularity is ATK_TEXT_GRANULARITY_LINE the returned string is from
	// the line start at or before the offset to the line start after the
	// offset.
	//
	// If granularity is ATK_TEXT_GRANULARITY_PARAGRAPH the returned string is
	// from the start of the paragraph at or before the offset to the start of
	// the following paragraph after the offset.
	StringAtOffset(offset int, granularity TextGranularity) (startOffset int, endOffset int, utf8 string)
	// Text gets the specified text.
	Text(startOffset int, endOffset int) string
	// TextAfterOffset gets the specified text.
	//
	// Deprecated: Please use atk_text_get_string_at_offset() instead.
	TextAfterOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextAtOffset gets the specified text.
	//
	// If the boundary_type if ATK_TEXT_BOUNDARY_CHAR the character at the
	// offset is returned.
	//
	// If the boundary_type is ATK_TEXT_BOUNDARY_WORD_START the returned string
	// is from the word start at or before the offset to the word start after
	// the offset.
	//
	// The returned string will contain the word at the offset if the offset is
	// inside a word and will contain the word before the offset if the offset
	// is not inside a word.
	//
	// If the boundary type is ATK_TEXT_BOUNDARY_SENTENCE_START the returned
	// string is from the sentence start at or before the offset to the sentence
	// start after the offset.
	//
	// The returned string will contain the sentence at the offset if the offset
	// is inside a sentence and will contain the sentence before the offset if
	// the offset is not inside a sentence.
	//
	// If the boundary type is ATK_TEXT_BOUNDARY_LINE_START the returned string
	// is from the line start at or before the offset to the line start after
	// the offset.
	//
	// Deprecated: This method is deprecated since ATK version 2.9.4. Please use
	// atk_text_get_string_at_offset() instead.
	TextAtOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextBeforeOffset gets the specified text.
	//
	// Deprecated: Please use atk_text_get_string_at_offset() instead.
	TextBeforeOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// RemoveSelection removes the specified selection.
	RemoveSelection(selectionNum int) bool
	// ScrollSubstringTo makes a substring of text visible on the screen by
	// scrolling all necessary parents.
	ScrollSubstringTo(startOffset int, endOffset int, typ ScrollType) bool
	// ScrollSubstringToPoint: move the top-left of a substring of text to a
	// given position of the screen by scrolling all necessary parents.
	ScrollSubstringToPoint(startOffset int, endOffset int, coords CoordType, x int, y int) bool
	// SetCaretOffset sets the caret (cursor) position to the specified offset.
	//
	// In the case of rich-text content, this method should either grab focus or
	// move the sequential focus navigation starting point (if the application
	// supports this concept) as if the user had clicked on the new caret
	// position. Typically, this means that the target of this operation is the
	// node containing the new caret position or one of its ancestors. In other
	// words, after this method is called, if the user advances focus, it should
	// move to the first focusable node following the new caret position.
	//
	// Calling this method should also scroll the application viewport in a way
	// that matches the behavior of the application's typical caret motion or
	// tab navigation as closely as possible. This also means that if the
	// application's caret motion or focus navigation does not trigger a scroll
	// operation, this method should not trigger one either. If the application
	// does not have a caret motion or focus navigation operation, this method
	// should try to scroll the new caret position into view while minimizing
	// unnecessary scroll motion.
	SetCaretOffset(offset int) bool
	// SetSelection changes the start and end offset of the specified selection.
	SetSelection(selectionNum int, startOffset int, endOffset int) bool
	TextAttributesChanged()
	TextCaretMoved(location int)
	TextChanged(position int, length int)
	TextSelectionChanged()
}

// Text should be implemented by Objects on behalf of widgets that have text
// content which is either attributed or otherwise non-trivial. Objects whose
// text content is simple, unattributed, and very brief may expose that content
// via #atk_object_get_name instead; however if the text is editable,
// multi-line, typically longer than three or four words, attributed,
// selectable, or if the object already uses the 'name' ATK property for other
// information, the Text interface should be used to expose the text content. In
// the case of editable text content, EditableText (a subtype of the Text
// interface) should be implemented instead.
//
//    Text provides not only traversal facilities and change
//
// notification for text content, but also caret tracking and glyph bounding box
// calculations. Note that the text strings are exposed as UTF-8, and are
// therefore potentially multi-byte, and caret-to-byte offset mapping makes no
// assumptions about the character length; also bounding box glyph-to-offset
// mapping may be complex for languages which use ligatures.
type Text struct {
	*externglib.Object
}

// Texter describes Text's abstract methods.
type Texter interface {
	externglib.Objector

	// AddSelection adds a selection bounded by the specified offsets.
	AddSelection(startOffset int, endOffset int) bool
	// BoundedRanges: get the ranges of text in the specified bounding box.
	BoundedRanges(rect *TextRectangle, coordType CoordType, xClipType TextClipType, yClipType TextClipType) []*TextRange
	// CaretOffset gets the offset of the position of the caret (cursor).
	CaretOffset() int
	// CharacterAtOffset gets the specified text.
	CharacterAtOffset(offset int) uint32
	// CharacterCount gets the character count.
	CharacterCount() int
	// CharacterExtents: if the extent can not be obtained (e.g.
	CharacterExtents(offset int, coords CoordType) (x int, y int, width int, height int)
	// NSelections gets the number of selected regions.
	NSelections() int
	// OffsetAtPoint gets the offset of the character located at coordinates x
	// and y.
	OffsetAtPoint(x int, y int, coords CoordType) int
	// RangeExtents: get the bounding box for text within the specified range.
	RangeExtents(startOffset int, endOffset int, coordType CoordType) TextRectangle
	// Selection gets the text from the specified selection.
	Selection(selectionNum int) (startOffset int, endOffset int, utf8 string)
	// StringAtOffset gets a portion of the text exposed through an Text
	// according to a given offset and a specific granularity, along with the
	// start and end offsets defining the boundaries of such a portion of text.
	StringAtOffset(offset int, granularity TextGranularity) (startOffset int, endOffset int, utf8 string)
	// Text gets the specified text.
	Text(startOffset int, endOffset int) string
	// TextAfterOffset gets the specified text.
	TextAfterOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextAtOffset gets the specified text.
	TextAtOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextBeforeOffset gets the specified text.
	TextBeforeOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// RemoveSelection removes the specified selection.
	RemoveSelection(selectionNum int) bool
	// ScrollSubstringTo makes a substring of text visible on the screen by
	// scrolling all necessary parents.
	ScrollSubstringTo(startOffset int, endOffset int, typ ScrollType) bool
	// ScrollSubstringToPoint: move the top-left of a substring of text to a
	// given position of the screen by scrolling all necessary parents.
	ScrollSubstringToPoint(startOffset int, endOffset int, coords CoordType, x int, y int) bool
	// SetCaretOffset sets the caret (cursor) position to the specified offset.
	SetCaretOffset(offset int) bool
	// SetSelection changes the start and end offset of the specified selection.
	SetSelection(selectionNum int, startOffset int, endOffset int) bool
}

var _ Texter = (*Text)(nil)

func wrapText(obj *externglib.Object) *Text {
	return &Text{
		Object: obj,
	}
}

func marshalTexter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapText(obj), nil
}

// AddSelection adds a selection bounded by the specified offsets.
func (text *Text) AddSelection(startOffset int, endOffset int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)

	_cret = C.atk_text_add_selection(_arg0, _arg1, _arg2)
	runtime.KeepAlive(text)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BoundedRanges: get the ranges of text in the specified bounding box.
func (text *Text) BoundedRanges(rect *TextRectangle, coordType CoordType, xClipType TextClipType, yClipType TextClipType) []*TextRange {
	var _arg0 *C.AtkText          // out
	var _arg1 *C.AtkTextRectangle // out
	var _arg2 C.AtkCoordType      // out
	var _arg3 C.AtkTextClipType   // out
	var _arg4 C.AtkTextClipType   // out
	var _cret **C.AtkTextRange    // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = (*C.AtkTextRectangle)(gextras.StructNative(unsafe.Pointer(rect)))
	_arg2 = C.AtkCoordType(coordType)
	_arg3 = C.AtkTextClipType(xClipType)
	_arg4 = C.AtkTextClipType(yClipType)

	_cret = C.atk_text_get_bounded_ranges(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(text)
	runtime.KeepAlive(rect)
	runtime.KeepAlive(coordType)
	runtime.KeepAlive(xClipType)
	runtime.KeepAlive(yClipType)

	var _textRanges []*TextRange // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.AtkTextRange
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_textRanges = make([]*TextRange, i)
		for i := range src {
			_textRanges[i] = (*TextRange)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_textRanges[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.free(intern.C)
				},
			)
		}
	}

	return _textRanges
}

// CaretOffset gets the offset of the position of the caret (cursor).
func (text *Text) CaretOffset() int {
	var _arg0 *C.AtkText // out
	var _cret C.gint     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))

	_cret = C.atk_text_get_caret_offset(_arg0)
	runtime.KeepAlive(text)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CharacterAtOffset gets the specified text.
func (text *Text) CharacterAtOffset(offset int) uint32 {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _cret C.gunichar // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(offset)

	_cret = C.atk_text_get_character_at_offset(_arg0, _arg1)
	runtime.KeepAlive(text)
	runtime.KeepAlive(offset)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// CharacterCount gets the character count.
func (text *Text) CharacterCount() int {
	var _arg0 *C.AtkText // out
	var _cret C.gint     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))

	_cret = C.atk_text_get_character_count(_arg0)
	runtime.KeepAlive(text)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CharacterExtents: if the extent can not be obtained (e.g. missing support),
// all of x, y, width, height are set to -1.
//
// Get the bounding box containing the glyph representing the character at a
// particular text offset.
func (text *Text) CharacterExtents(offset int, coords CoordType) (x int, y int, width int, height int) {
	var _arg0 *C.AtkText     // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // in
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in
	var _arg5 C.gint         // in
	var _arg6 C.AtkCoordType // out

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(offset)
	_arg6 = C.AtkCoordType(coords)

	C.atk_text_get_character_extents(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5, _arg6)
	runtime.KeepAlive(text)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(coords)

	var _x int      // out
	var _y int      // out
	var _width int  // out
	var _height int // out

	_x = int(_arg2)
	_y = int(_arg3)
	_width = int(_arg4)
	_height = int(_arg5)

	return _x, _y, _width, _height
}

// NSelections gets the number of selected regions.
func (text *Text) NSelections() int {
	var _arg0 *C.AtkText // out
	var _cret C.gint     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))

	_cret = C.atk_text_get_n_selections(_arg0)
	runtime.KeepAlive(text)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// OffsetAtPoint gets the offset of the character located at coordinates x and
// y. x and y are interpreted as being relative to the screen or this widget's
// window depending on coords.
func (text *Text) OffsetAtPoint(x int, y int, coords CoordType) int {
	var _arg0 *C.AtkText     // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.AtkCoordType // out
	var _cret C.gint         // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.AtkCoordType(coords)

	_cret = C.atk_text_get_offset_at_point(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(text)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(coords)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RangeExtents: get the bounding box for text within the specified range.
//
// If the extents can not be obtained (e.g. or missing support), the rectangle
// fields are set to -1.
func (text *Text) RangeExtents(startOffset int, endOffset int, coordType CoordType) TextRectangle {
	var _arg0 *C.AtkText         // out
	var _arg1 C.gint             // out
	var _arg2 C.gint             // out
	var _arg3 C.AtkCoordType     // out
	var _arg4 C.AtkTextRectangle // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	_arg3 = C.AtkCoordType(coordType)

	C.atk_text_get_range_extents(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(text)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)
	runtime.KeepAlive(coordType)

	var _rect TextRectangle // out

	_rect = *(*TextRectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg4))))

	return _rect
}

// Selection gets the text from the specified selection.
func (text *Text) Selection(selectionNum int) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // in
	var _arg3 C.gint     // in
	var _cret *C.gchar   // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(selectionNum)

	_cret = C.atk_text_get_selection(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(text)
	runtime.KeepAlive(selectionNum)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg2)
	_endOffset = int(_arg3)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

// StringAtOffset gets a portion of the text exposed through an Text according
// to a given offset and a specific granularity, along with the start and end
// offsets defining the boundaries of such a portion of text.
//
// If granularity is ATK_TEXT_GRANULARITY_CHAR the character at the offset is
// returned.
//
// If granularity is ATK_TEXT_GRANULARITY_WORD the returned string is from the
// word start at or before the offset to the word start after the offset.
//
// The returned string will contain the word at the offset if the offset is
// inside a word and will contain the word before the offset if the offset is
// not inside a word.
//
// If granularity is ATK_TEXT_GRANULARITY_SENTENCE the returned string is from
// the sentence start at or before the offset to the sentence start after the
// offset.
//
// The returned string will contain the sentence at the offset if the offset is
// inside a sentence and will contain the sentence before the offset if the
// offset is not inside a sentence.
//
// If granularity is ATK_TEXT_GRANULARITY_LINE the returned string is from the
// line start at or before the offset to the line start after the offset.
//
// If granularity is ATK_TEXT_GRANULARITY_PARAGRAPH the returned string is from
// the start of the paragraph at or before the offset to the start of the
// following paragraph after the offset.
func (text *Text) StringAtOffset(offset int, granularity TextGranularity) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText           // out
	var _arg1 C.gint               // out
	var _arg2 C.AtkTextGranularity // out
	var _arg3 C.gint               // in
	var _arg4 C.gint               // in
	var _cret *C.gchar             // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextGranularity(granularity)

	_cret = C.atk_text_get_string_at_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(text)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(granularity)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _startOffset, _endOffset, _utf8
}

// Text gets the specified text.
func (text *Text) Text(startOffset int, endOffset int) string {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _cret *C.gchar   // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)

	_cret = C.atk_text_get_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(text)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TextAfterOffset gets the specified text.
//
// Deprecated: Please use atk_text_get_string_at_offset() instead.
func (text *Text) TextAfterOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText        // out
	var _arg1 C.gint            // out
	var _arg2 C.AtkTextBoundary // out
	var _arg3 C.gint            // in
	var _arg4 C.gint            // in
	var _cret *C.gchar          // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextBoundary(boundaryType)

	_cret = C.atk_text_get_text_after_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(text)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(boundaryType)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

// TextAtOffset gets the specified text.
//
// If the boundary_type if ATK_TEXT_BOUNDARY_CHAR the character at the offset is
// returned.
//
// If the boundary_type is ATK_TEXT_BOUNDARY_WORD_START the returned string is
// from the word start at or before the offset to the word start after the
// offset.
//
// The returned string will contain the word at the offset if the offset is
// inside a word and will contain the word before the offset if the offset is
// not inside a word.
//
// If the boundary type is ATK_TEXT_BOUNDARY_SENTENCE_START the returned string
// is from the sentence start at or before the offset to the sentence start
// after the offset.
//
// The returned string will contain the sentence at the offset if the offset is
// inside a sentence and will contain the sentence before the offset if the
// offset is not inside a sentence.
//
// If the boundary type is ATK_TEXT_BOUNDARY_LINE_START the returned string is
// from the line start at or before the offset to the line start after the
// offset.
//
// Deprecated: This method is deprecated since ATK version 2.9.4. Please use
// atk_text_get_string_at_offset() instead.
func (text *Text) TextAtOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText        // out
	var _arg1 C.gint            // out
	var _arg2 C.AtkTextBoundary // out
	var _arg3 C.gint            // in
	var _arg4 C.gint            // in
	var _cret *C.gchar          // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextBoundary(boundaryType)

	_cret = C.atk_text_get_text_at_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(text)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(boundaryType)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

// TextBeforeOffset gets the specified text.
//
// Deprecated: Please use atk_text_get_string_at_offset() instead.
func (text *Text) TextBeforeOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText        // out
	var _arg1 C.gint            // out
	var _arg2 C.AtkTextBoundary // out
	var _arg3 C.gint            // in
	var _arg4 C.gint            // in
	var _cret *C.gchar          // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextBoundary(boundaryType)

	_cret = C.atk_text_get_text_before_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(text)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(boundaryType)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

// RemoveSelection removes the specified selection.
func (text *Text) RemoveSelection(selectionNum int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(selectionNum)

	_cret = C.atk_text_remove_selection(_arg0, _arg1)
	runtime.KeepAlive(text)
	runtime.KeepAlive(selectionNum)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollSubstringTo makes a substring of text visible on the screen by
// scrolling all necessary parents.
func (text *Text) ScrollSubstringTo(startOffset int, endOffset int, typ ScrollType) bool {
	var _arg0 *C.AtkText      // out
	var _arg1 C.gint          // out
	var _arg2 C.gint          // out
	var _arg3 C.AtkScrollType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	_arg3 = C.AtkScrollType(typ)

	_cret = C.atk_text_scroll_substring_to(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(text)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollSubstringToPoint: move the top-left of a substring of text to a given
// position of the screen by scrolling all necessary parents.
func (text *Text) ScrollSubstringToPoint(startOffset int, endOffset int, coords CoordType, x int, y int) bool {
	var _arg0 *C.AtkText     // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.AtkCoordType // out
	var _arg4 C.gint         // out
	var _arg5 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	_arg3 = C.AtkCoordType(coords)
	_arg4 = C.gint(x)
	_arg5 = C.gint(y)

	_cret = C.atk_text_scroll_substring_to_point(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(text)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)
	runtime.KeepAlive(coords)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCaretOffset sets the caret (cursor) position to the specified offset.
//
// In the case of rich-text content, this method should either grab focus or
// move the sequential focus navigation starting point (if the application
// supports this concept) as if the user had clicked on the new caret position.
// Typically, this means that the target of this operation is the node
// containing the new caret position or one of its ancestors. In other words,
// after this method is called, if the user advances focus, it should move to
// the first focusable node following the new caret position.
//
// Calling this method should also scroll the application viewport in a way that
// matches the behavior of the application's typical caret motion or tab
// navigation as closely as possible. This also means that if the application's
// caret motion or focus navigation does not trigger a scroll operation, this
// method should not trigger one either. If the application does not have a
// caret motion or focus navigation operation, this method should try to scroll
// the new caret position into view while minimizing unnecessary scroll motion.
func (text *Text) SetCaretOffset(offset int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(offset)

	_cret = C.atk_text_set_caret_offset(_arg0, _arg1)
	runtime.KeepAlive(text)
	runtime.KeepAlive(offset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSelection changes the start and end offset of the specified selection.
func (text *Text) SetSelection(selectionNum int, startOffset int, endOffset int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(text.Native()))
	_arg1 = C.gint(selectionNum)
	_arg2 = C.gint(startOffset)
	_arg3 = C.gint(endOffset)

	_cret = C.atk_text_set_selection(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(text)
	runtime.KeepAlive(selectionNum)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextRange: structure used to describe a text range.
//
// An instance of this type is always passed by reference.
type TextRange struct {
	*textRange
}

// textRange is the struct that's finalized.
type textRange struct {
	native *C.AtkTextRange
}

func marshalTextRange(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &TextRange{&textRange{(*C.AtkTextRange)(unsafe.Pointer(b))}}, nil
}

// Bounds: rectangle giving the bounds of the text range
func (t *TextRange) Bounds() TextRectangle {
	var v TextRectangle // out
	v = *(*TextRectangle)(gextras.NewStructNative(unsafe.Pointer((&t.native.bounds))))
	return v
}

// StartOffset: start offset of a AtkTextRange
func (t *TextRange) StartOffset() int {
	var v int // out
	v = int(t.native.start_offset)
	return v
}

// EndOffset: end offset of a AtkTextRange
func (t *TextRange) EndOffset() int {
	var v int // out
	v = int(t.native.end_offset)
	return v
}

// Content: text in the text range
func (t *TextRange) Content() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(t.native.content)))
	return v
}

// TextRectangle: structure used to store a rectangle used by AtkText.
//
// An instance of this type is always passed by reference.
type TextRectangle struct {
	*textRectangle
}

// textRectangle is the struct that's finalized.
type textRectangle struct {
	native *C.AtkTextRectangle
}

// NewTextRectangle creates a new TextRectangle instance from the given
// fields.
func NewTextRectangle(x, y, width, height int) TextRectangle {
	var f0 C.gint // out
	f0 = C.gint(x)
	var f1 C.gint // out
	f1 = C.gint(y)
	var f2 C.gint // out
	f2 = C.gint(width)
	var f3 C.gint // out
	f3 = C.gint(height)

	v := C.AtkTextRectangle{
		x:      f0,
		y:      f1,
		width:  f2,
		height: f3,
	}

	return *(*TextRectangle)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// X: horizontal coordinate of a rectangle
func (t *TextRectangle) X() int {
	var v int // out
	v = int(t.native.x)
	return v
}

// Y: vertical coordinate of a rectangle
func (t *TextRectangle) Y() int {
	var v int // out
	v = int(t.native.y)
	return v
}

// Width: width of a rectangle
func (t *TextRectangle) Width() int {
	var v int // out
	v = int(t.native.width)
	return v
}

// Height: height of a rectangle
func (t *TextRectangle) Height() int {
	var v int // out
	v = int(t.native.height)
	return v
}
