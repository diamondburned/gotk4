// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-3.0 gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gdk/gdk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_drag_cancel_reason_get_type()), F: marshalDragCancelReason},
		{T: externglib.Type(C.gdk_drag_protocol_get_type()), F: marshalDragProtocol},
		{T: externglib.Type(C.gdk_drag_action_get_type()), F: marshalDragAction},
	})
}

// DragCancelReason: used in DragContext to the reason of a cancelled DND
// operation.
type DragCancelReason int

const (
	// NoTarget: there is no suitable drop target.
	DragCancelReasonNoTarget DragCancelReason = iota
	// UserCancelled: drag cancelled by the user
	DragCancelReasonUserCancelled
	// Error: unspecified error.
	DragCancelReasonError
)

func marshalDragCancelReason(p uintptr) (interface{}, error) {
	return DragCancelReason(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragProtocol: used in DragContext to indicate the protocol according to which
// DND is done.
type DragProtocol int

const (
	// None: no protocol.
	DragProtocolNone DragProtocol = iota
	// Motif: motif DND protocol. No longer supported
	DragProtocolMotif
	// Xdnd: xdnd protocol.
	DragProtocolXdnd
	// Rootwin: extension to the Xdnd protocol for unclaimed root window drops.
	DragProtocolRootwin
	// Win32Dropfiles: simple WM_DROPFILES protocol.
	DragProtocolWin32Dropfiles
	// Ole2: complex OLE2 DND protocol (not implemented).
	DragProtocolOle2
	// Local: intra-application DND.
	DragProtocolLocal
	// Wayland: wayland DND protocol.
	DragProtocolWayland
)

func marshalDragProtocol(p uintptr) (interface{}, error) {
	return DragProtocol(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragAction: used in DragContext to indicate what the destination should do
// with the dropped data.
type DragAction int

const (
	// DragActionDefault means nothing, and should not be used.
	DragActionDefault DragAction = 0b1
	// DragActionCopy: copy the data.
	DragActionCopy DragAction = 0b10
	// DragActionMove: move the data, i.e. first copy it, then delete it from
	// the source using the DELETE target of the X selection protocol.
	DragActionMove DragAction = 0b100
	// DragActionLink: add a link to the data. Note that this is only useful if
	// source and destination agree on what it means.
	DragActionLink DragAction = 0b1000
	// DragActionPrivate: special action which tells the source that the
	// destination will do something that the source doesnâ€™t understand.
	DragActionPrivate DragAction = 0b10000
	// DragActionAsk: ask the user what to do with the data.
	DragActionAsk DragAction = 0b100000
)

func marshalDragAction(p uintptr) (interface{}, error) {
	return DragAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragAbort aborts a drag without dropping.
//
// This function is called by the drag source.
//
// This function does not need to be called in managed drag and drop operations.
// See gdk_drag_context_manage_dnd() for more information.
func DragAbort(context DragContexter, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer((context).(gextras.Nativer).Native()))
	_arg2 = C.guint32(time_)

	C.gdk_drag_abort(_arg1, _arg2)
}

// DragDrop drops on the current destination.
//
// This function is called by the drag source.
//
// This function does not need to be called in managed drag and drop operations.
// See gdk_drag_context_manage_dnd() for more information.
func DragDrop(context DragContexter, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer((context).(gextras.Nativer).Native()))
	_arg2 = C.guint32(time_)

	C.gdk_drag_drop(_arg1, _arg2)
}

// DragDropDone: inform GDK if the drop ended successfully. Passing false for
// @success may trigger a drag cancellation animation.
//
// This function is called by the drag source, and should be the last call
// before dropping the reference to the @context.
//
// The DragContext will only take the first gdk_drag_drop_done() call as
// effective, if this function is called multiple times, all subsequent calls
// will be ignored.
func DragDropDone(context DragContexter, success bool) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gboolean        // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer((context).(gextras.Nativer).Native()))
	if success {
		_arg2 = C.TRUE
	}

	C.gdk_drag_drop_done(_arg1, _arg2)
}

// DragDropSucceeded returns whether the dropped data has been successfully
// transferred. This function is intended to be used while handling a
// GDK_DROP_FINISHED event, its return value is meaningless at other times.
func DragDropSucceeded(context DragContexter) bool {
	var _arg1 *C.GdkDragContext // out
	var _cret C.gboolean        // in

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer((context).(gextras.Nativer).Native()))

	_cret = C.gdk_drag_drop_succeeded(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DragFindWindowForScreen finds the destination window and DND protocol to use
// at the given pointer position.
//
// This function is called by the drag source to obtain the @dest_window and
// @protocol parameters for gdk_drag_motion().
func DragFindWindowForScreen(context DragContexter, dragWindow Windowwer, screen Screener, xRoot int, yRoot int) (*Window, DragProtocol) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 *C.GdkWindow      // out
	var _arg3 *C.GdkScreen      // out
	var _arg4 C.gint            // out
	var _arg5 C.gint            // out
	var _arg6 *C.GdkWindow      // in
	var _arg7 C.GdkDragProtocol // in

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer((context).(gextras.Nativer).Native()))
	_arg2 = (*C.GdkWindow)(unsafe.Pointer((dragWindow).(gextras.Nativer).Native()))
	_arg3 = (*C.GdkScreen)(unsafe.Pointer((screen).(gextras.Nativer).Native()))
	_arg4 = C.gint(xRoot)
	_arg5 = C.gint(yRoot)

	C.gdk_drag_find_window_for_screen(_arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, &_arg7)

	var _destWindow *Window    // out
	var _protocol DragProtocol // out

	_destWindow = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg6)))).(*Window)
	_protocol = (DragProtocol)(_arg7)

	return _destWindow, _protocol
}

// DropFinish ends the drag operation after a drop.
//
// This function is called by the drag destination.
func DropFinish(context DragContexter, success bool, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gboolean        // out
	var _arg3 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer((context).(gextras.Nativer).Native()))
	if success {
		_arg2 = C.TRUE
	}
	_arg3 = C.guint32(time_)

	C.gdk_drop_finish(_arg1, _arg2, _arg3)
}

// DropReply accepts or rejects a drop.
//
// This function is called by the drag destination in response to a drop
// initiated by the drag source.
func DropReply(context DragContexter, accepted bool, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gboolean        // out
	var _arg3 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer((context).(gextras.Nativer).Native()))
	if accepted {
		_arg2 = C.TRUE
	}
	_arg3 = C.guint32(time_)

	C.gdk_drop_reply(_arg1, _arg2, _arg3)
}
