// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
// #include <glib-object.h>
// extern void _gotk4_gdk3_EventFunc(GdkEvent*, gpointer);
// extern void callbackDelete(gpointer);
import "C"

// GTypeCrossingMode returns the GType for the type CrossingMode.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeCrossingMode() coreglib.Type {
	gtype := coreglib.Type(C.gdk_crossing_mode_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalCrossingMode)
	return gtype
}

// GTypeEventType returns the GType for the type EventType.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeEventType() coreglib.Type {
	gtype := coreglib.Type(C.gdk_event_type_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalEventType)
	return gtype
}

// GTypeFilterReturn returns the GType for the type FilterReturn.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFilterReturn() coreglib.Type {
	gtype := coreglib.Type(C.gdk_filter_return_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalFilterReturn)
	return gtype
}

// GTypeNotifyType returns the GType for the type NotifyType.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeNotifyType() coreglib.Type {
	gtype := coreglib.Type(C.gdk_notify_type_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalNotifyType)
	return gtype
}

// GTypeOwnerChange returns the GType for the type OwnerChange.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeOwnerChange() coreglib.Type {
	gtype := coreglib.Type(C.gdk_owner_change_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalOwnerChange)
	return gtype
}

// GTypePropertyState returns the GType for the type PropertyState.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypePropertyState() coreglib.Type {
	gtype := coreglib.Type(C.gdk_property_state_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalPropertyState)
	return gtype
}

// GTypeScrollDirection returns the GType for the type ScrollDirection.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeScrollDirection() coreglib.Type {
	gtype := coreglib.Type(C.gdk_scroll_direction_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalScrollDirection)
	return gtype
}

// GTypeSettingAction returns the GType for the type SettingAction.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeSettingAction() coreglib.Type {
	gtype := coreglib.Type(C.gdk_setting_action_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalSettingAction)
	return gtype
}

// GTypeTouchpadGesturePhase returns the GType for the type TouchpadGesturePhase.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTouchpadGesturePhase() coreglib.Type {
	gtype := coreglib.Type(C.gdk_touchpad_gesture_phase_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalTouchpadGesturePhase)
	return gtype
}

// GTypeVisibilityState returns the GType for the type VisibilityState.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeVisibilityState() coreglib.Type {
	gtype := coreglib.Type(C.gdk_visibility_state_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalVisibilityState)
	return gtype
}

// GTypeWindowState returns the GType for the type WindowState.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeWindowState() coreglib.Type {
	gtype := coreglib.Type(C.gdk_window_state_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalWindowState)
	return gtype
}

// GTypeEventSequence returns the GType for the type EventSequence.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeEventSequence() coreglib.Type {
	gtype := coreglib.Type(C.gdk_event_sequence_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalEventSequence)
	return gtype
}

// GTypeEvent returns the GType for the type Event.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeEvent() coreglib.Type {
	gtype := coreglib.Type(C.gdk_event_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalEvent)
	return gtype
}

// BUTTON_MIDDLE: middle button.
const BUTTON_MIDDLE = 2

// BUTTON_PRIMARY: primary button. This is typically the left mouse button, or
// the right button in a left-handed setup.
const BUTTON_PRIMARY = 1

// BUTTON_SECONDARY: secondary button. This is typically the right mouse button,
// or the left button in a left-handed setup.
const BUTTON_SECONDARY = 3

// EVENT_PROPAGATE: use this macro as the return value for continuing the
// propagation of an event handler.
const EVENT_PROPAGATE = false

// EVENT_STOP: use this macro as the return value for stopping the propagation
// of an event handler.
const EVENT_STOP = true

// PRIORITY_REDRAW: this is the priority that the idle handler processing window
// updates is given in the [GLib Main Loop][glib-The-Main-Event-Loop].
const PRIORITY_REDRAW = 120

// CrossingMode specifies the crossing mode for EventCrossing.
type CrossingMode C.gint

const (
	// CrossingNormal: crossing because of pointer motion.
	CrossingNormal CrossingMode = iota
	// CrossingGrab: crossing because a grab is activated.
	CrossingGrab
	// CrossingUngrab: crossing because a grab is deactivated.
	CrossingUngrab
	// CrossingGTKGrab: crossing because a GTK+ grab is activated.
	CrossingGTKGrab
	// CrossingGTKUngrab: crossing because a GTK+ grab is deactivated.
	CrossingGTKUngrab
	// CrossingStateChanged: crossing because a GTK+ widget changed state (e.g.
	// sensitivity).
	CrossingStateChanged
	// CrossingTouchBegin: crossing because a touch sequence has begun, this
	// event is synthetic as the pointer might have not left the window.
	CrossingTouchBegin
	// CrossingTouchEnd: crossing because a touch sequence has ended, this event
	// is synthetic as the pointer might have not left the window.
	CrossingTouchEnd
	// CrossingDeviceSwitch: crossing because of a device switch (i.e. a mouse
	// taking control of the pointer after a touch device), this event is
	// synthetic as the pointer didnâ€™t leave the window.
	CrossingDeviceSwitch
)

func marshalCrossingMode(p uintptr) (interface{}, error) {
	return CrossingMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CrossingMode.
func (c CrossingMode) String() string {
	switch c {
	case CrossingNormal:
		return "Normal"
	case CrossingGrab:
		return "Grab"
	case CrossingUngrab:
		return "Ungrab"
	case CrossingGTKGrab:
		return "GTKGrab"
	case CrossingGTKUngrab:
		return "GTKUngrab"
	case CrossingStateChanged:
		return "StateChanged"
	case CrossingTouchBegin:
		return "TouchBegin"
	case CrossingTouchEnd:
		return "TouchEnd"
	case CrossingDeviceSwitch:
		return "DeviceSwitch"
	default:
		return fmt.Sprintf("CrossingMode(%d)", c)
	}
}

// EventType specifies the type of the event.
//
// Do not confuse these events with the signals that GTK+ widgets emit. Although
// many of these events result in corresponding signals being emitted, the
// events are often transformed or filtered along the way.
//
// In some language bindings, the values GDK_2BUTTON_PRESS and GDK_3BUTTON_PRESS
// would translate into something syntactically invalid (eg
// Gdk.EventType.2ButtonPress, where a symbol is not allowed to start with a
// number). In that case, the aliases GDK_DOUBLE_BUTTON_PRESS and
// GDK_TRIPLE_BUTTON_PRESS can be used instead.
type EventType C.gint

const (
	// NothingType: special code to indicate a null event.
	NothingType EventType = -1
	// DeleteType: window manager has requested that the toplevel window be
	// hidden or destroyed, usually when the user clicks on a special icon in
	// the title bar.
	DeleteType EventType = 0
	// DestroyType: window has been destroyed.
	DestroyType EventType = 1
	// ExposeType: all or part of the window has become visible and needs to be
	// redrawn.
	ExposeType EventType = 2
	// MotionNotifyType: pointer (usually a mouse) has moved.
	MotionNotifyType EventType = 3
	// ButtonPressType: mouse button has been pressed.
	ButtonPressType EventType = 4
	// TwoButtonPressType: mouse button has been double-clicked (clicked twice
	// within a short period of time). Note that each click also generates a
	// GDK_BUTTON_PRESS event.
	TwoButtonPressType EventType = 5
	// DoubleButtonPressType alias for GDK_2BUTTON_PRESS, added in 3.6.
	DoubleButtonPressType EventType = 5
	// ThreeButtonPressType: mouse button has been clicked 3 times in a short
	// period of time. Note that each click also generates a GDK_BUTTON_PRESS
	// event.
	ThreeButtonPressType EventType = 6
	// TripleButtonPressType alias for GDK_3BUTTON_PRESS, added in 3.6.
	TripleButtonPressType EventType = 6
	// ButtonReleaseType: mouse button has been released.
	ButtonReleaseType EventType = 7
	// KeyPressType: key has been pressed.
	KeyPressType EventType = 8
	// KeyReleaseType: key has been released.
	KeyReleaseType EventType = 9
	// EnterNotifyType: pointer has entered the window.
	EnterNotifyType EventType = 10
	// LeaveNotifyType: pointer has left the window.
	LeaveNotifyType EventType = 11
	// FocusChangeType: keyboard focus has entered or left the window.
	FocusChangeType EventType = 12
	// ConfigureType: size, position or stacking order of the window has
	// changed. Note that GTK+ discards these events for GDK_WINDOW_CHILD
	// windows.
	ConfigureType EventType = 13
	// MapType: window has been mapped.
	MapType EventType = 14
	// UnmapType: window has been unmapped.
	UnmapType EventType = 15
	// PropertyNotifyType: property on the window has been changed or deleted.
	PropertyNotifyType EventType = 16
	// SelectionClearType: application has lost ownership of a selection.
	SelectionClearType EventType = 17
	// SelectionRequestType: another application has requested a selection.
	SelectionRequestType EventType = 18
	// SelectionNotifyType: selection has been received.
	SelectionNotifyType EventType = 19
	// ProximityInType: input device has moved into contact with a sensing
	// surface (e.g. a touchscreen or graphics tablet).
	ProximityInType EventType = 20
	// ProximityOutType: input device has moved out of contact with a sensing
	// surface.
	ProximityOutType EventType = 21
	// DragEnterType: mouse has entered the window while a drag is in progress.
	DragEnterType EventType = 22
	// DragLeaveType: mouse has left the window while a drag is in progress.
	DragLeaveType EventType = 23
	// DragMotionType: mouse has moved in the window while a drag is in
	// progress.
	DragMotionType EventType = 24
	// DragStatusType status of the drag operation initiated by the window has
	// changed.
	DragStatusType EventType = 25
	// DropStartType: drop operation onto the window has started.
	DropStartType EventType = 26
	// DropFinishedType: drop operation initiated by the window has completed.
	DropFinishedType EventType = 27
	// ClientEventType: message has been received from another application.
	ClientEventType EventType = 28
	// VisibilityNotifyType: window visibility status has changed.
	VisibilityNotifyType EventType = 29
	// ScrollType: scroll wheel was turned.
	ScrollType EventType = 31
	// WindowStateType: state of a window has changed. See WindowState for the
	// possible window states.
	WindowStateType EventType = 32
	// SettingType: setting has been modified.
	SettingType EventType = 33
	// OwnerChangeType: owner of a selection has changed. This event type was
	// added in 2.6.
	OwnerChangeType EventType = 34
	// GrabBrokenType: pointer or keyboard grab was broken. This event type was
	// added in 2.8.
	GrabBrokenType EventType = 35
	// DamageType: content of the window has been changed. This event type was
	// added in 2.14.
	DamageType EventType = 36
	// TouchBeginType: new touch event sequence has just started. This event
	// type was added in 3.4.
	TouchBeginType EventType = 37
	// TouchUpdateType: touch event sequence has been updated. This event type
	// was added in 3.4.
	TouchUpdateType EventType = 38
	// TouchEndType: touch event sequence has finished. This event type was
	// added in 3.4.
	TouchEndType EventType = 39
	// TouchCancelType: touch event sequence has been canceled. This event type
	// was added in 3.4.
	TouchCancelType EventType = 40
	// TouchpadSwipeType: touchpad swipe gesture event, the current state is
	// determined by its phase field. This event type was added in 3.18.
	TouchpadSwipeType EventType = 41
	// TouchpadPinchType: touchpad pinch gesture event, the current state is
	// determined by its phase field. This event type was added in 3.18.
	TouchpadPinchType EventType = 42
	// PadButtonPressType: tablet pad button press event. This event type was
	// added in 3.22.
	PadButtonPressType EventType = 43
	// PadButtonReleaseType: tablet pad button release event. This event type
	// was added in 3.22.
	PadButtonReleaseType EventType = 44
	// PadRingType: tablet pad axis event from a "ring". This event type was
	// added in 3.22.
	PadRingType EventType = 45
	// PadStripType: tablet pad axis event from a "strip". This event type was
	// added in 3.22.
	PadStripType EventType = 46
	// PadGroupModeType: tablet pad group mode change. This event type was added
	// in 3.22.
	PadGroupModeType EventType = 47
	// EventLastType marks the end of the GdkEventType enumeration. Added in
	// 2.18.
	EventLastType EventType = 48
)

func marshalEventType(p uintptr) (interface{}, error) {
	return EventType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EventType.
func (e EventType) String() string {
	switch e {
	case NothingType:
		return "Nothing"
	case DeleteType:
		return "Delete"
	case DestroyType:
		return "Destroy"
	case ExposeType:
		return "Expose"
	case MotionNotifyType:
		return "MotionNotify"
	case ButtonPressType:
		return "ButtonPress"
	case TwoButtonPressType:
		return "2ButtonPress"
	case ThreeButtonPressType:
		return "3ButtonPress"
	case ButtonReleaseType:
		return "ButtonRelease"
	case KeyPressType:
		return "KeyPress"
	case KeyReleaseType:
		return "KeyRelease"
	case EnterNotifyType:
		return "EnterNotify"
	case LeaveNotifyType:
		return "LeaveNotify"
	case FocusChangeType:
		return "FocusChange"
	case ConfigureType:
		return "Configure"
	case MapType:
		return "Map"
	case UnmapType:
		return "Unmap"
	case PropertyNotifyType:
		return "PropertyNotify"
	case SelectionClearType:
		return "SelectionClear"
	case SelectionRequestType:
		return "SelectionRequest"
	case SelectionNotifyType:
		return "SelectionNotify"
	case ProximityInType:
		return "ProximityIn"
	case ProximityOutType:
		return "ProximityOut"
	case DragEnterType:
		return "DragEnter"
	case DragLeaveType:
		return "DragLeave"
	case DragMotionType:
		return "DragMotion"
	case DragStatusType:
		return "DragStatus"
	case DropStartType:
		return "DropStart"
	case DropFinishedType:
		return "DropFinished"
	case ClientEventType:
		return "ClientEvent"
	case VisibilityNotifyType:
		return "VisibilityNotify"
	case ScrollType:
		return "Scroll"
	case WindowStateType:
		return "WindowState"
	case SettingType:
		return "Setting"
	case OwnerChangeType:
		return "OwnerChange"
	case GrabBrokenType:
		return "GrabBroken"
	case DamageType:
		return "Damage"
	case TouchBeginType:
		return "TouchBegin"
	case TouchUpdateType:
		return "TouchUpdate"
	case TouchEndType:
		return "TouchEnd"
	case TouchCancelType:
		return "TouchCancel"
	case TouchpadSwipeType:
		return "TouchpadSwipe"
	case TouchpadPinchType:
		return "TouchpadPinch"
	case PadButtonPressType:
		return "PadButtonPress"
	case PadButtonReleaseType:
		return "PadButtonRelease"
	case PadRingType:
		return "PadRing"
	case PadStripType:
		return "PadStrip"
	case PadGroupModeType:
		return "PadGroupMode"
	case EventLastType:
		return "EventLast"
	default:
		return fmt.Sprintf("EventType(%d)", e)
	}
}

// FilterReturn specifies the result of applying a FilterFunc to a native event.
type FilterReturn C.gint

const (
	// FilterContinue: event not handled, continue processing.
	FilterContinue FilterReturn = iota
	// FilterTranslate: native event translated into a GDK event and stored in
	// the event structure that was passed in.
	FilterTranslate
	// FilterRemove: event handled, terminate processing.
	FilterRemove
)

func marshalFilterReturn(p uintptr) (interface{}, error) {
	return FilterReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FilterReturn.
func (f FilterReturn) String() string {
	switch f {
	case FilterContinue:
		return "Continue"
	case FilterTranslate:
		return "Translate"
	case FilterRemove:
		return "Remove"
	default:
		return fmt.Sprintf("FilterReturn(%d)", f)
	}
}

// NotifyType specifies the kind of crossing for EventCrossing.
//
// See the X11 protocol specification of LeaveNotify for full details of
// crossing event generation.
type NotifyType C.gint

const (
	// NotifyAncestor: window is entered from an ancestor or left towards an
	// ancestor.
	NotifyAncestor NotifyType = iota
	// NotifyVirtual: pointer moves between an ancestor and an inferior of the
	// window.
	NotifyVirtual
	// NotifyInferior: window is entered from an inferior or left towards an
	// inferior.
	NotifyInferior
	// NotifyNonlinear: window is entered from or left towards a window which is
	// neither an ancestor nor an inferior.
	NotifyNonlinear
	// NotifyNonlinearVirtual: pointer moves between two windows which are not
	// ancestors of each other and the window is part of the ancestor chain
	// between one of these windows and their least common ancestor.
	NotifyNonlinearVirtual
	// NotifyUnknown: unknown type of enter/leave event occurred.
	NotifyUnknown
)

func marshalNotifyType(p uintptr) (interface{}, error) {
	return NotifyType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NotifyType.
func (n NotifyType) String() string {
	switch n {
	case NotifyAncestor:
		return "Ancestor"
	case NotifyVirtual:
		return "Virtual"
	case NotifyInferior:
		return "Inferior"
	case NotifyNonlinear:
		return "Nonlinear"
	case NotifyNonlinearVirtual:
		return "NonlinearVirtual"
	case NotifyUnknown:
		return "Unknown"
	default:
		return fmt.Sprintf("NotifyType(%d)", n)
	}
}

// OwnerChange specifies why a selection ownership was changed.
type OwnerChange C.gint

const (
	// OwnerChangeNewOwner: some other app claimed the ownership.
	OwnerChangeNewOwner OwnerChange = iota
	// OwnerChangeDestroy: window was destroyed.
	OwnerChangeDestroy
	// OwnerChangeClose: client was closed.
	OwnerChangeClose
)

func marshalOwnerChange(p uintptr) (interface{}, error) {
	return OwnerChange(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for OwnerChange.
func (o OwnerChange) String() string {
	switch o {
	case OwnerChangeNewOwner:
		return "NewOwner"
	case OwnerChangeDestroy:
		return "Destroy"
	case OwnerChangeClose:
		return "Close"
	default:
		return fmt.Sprintf("OwnerChange(%d)", o)
	}
}

// PropertyState specifies the type of a property change for a EventProperty.
type PropertyState C.gint

const (
	// PropertyNewValue: property value was changed.
	PropertyNewValue PropertyState = iota
	// PropertyDelete: property was deleted.
	PropertyDelete
)

func marshalPropertyState(p uintptr) (interface{}, error) {
	return PropertyState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PropertyState.
func (p PropertyState) String() string {
	switch p {
	case PropertyNewValue:
		return "NewValue"
	case PropertyDelete:
		return "Delete"
	default:
		return fmt.Sprintf("PropertyState(%d)", p)
	}
}

// ScrollDirection specifies the direction for EventScroll.
type ScrollDirection C.gint

const (
	// ScrollUp: window is scrolled up.
	ScrollUp ScrollDirection = iota
	// ScrollDown: window is scrolled down.
	ScrollDown
	// ScrollLeft: window is scrolled to the left.
	ScrollLeft
	// ScrollRight: window is scrolled to the right.
	ScrollRight
	// ScrollSmooth: scrolling is determined by the delta values in EventScroll.
	// See gdk_event_get_scroll_deltas(). Since: 3.4.
	ScrollSmooth
)

func marshalScrollDirection(p uintptr) (interface{}, error) {
	return ScrollDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollDirection.
func (s ScrollDirection) String() string {
	switch s {
	case ScrollUp:
		return "Up"
	case ScrollDown:
		return "Down"
	case ScrollLeft:
		return "Left"
	case ScrollRight:
		return "Right"
	case ScrollSmooth:
		return "Smooth"
	default:
		return fmt.Sprintf("ScrollDirection(%d)", s)
	}
}

// SettingAction specifies the kind of modification applied to a setting in a
// EventSetting.
type SettingAction C.gint

const (
	// NewSettingAction: setting was added.
	NewSettingAction SettingAction = iota
	// SettingActionChanged: setting was changed.
	SettingActionChanged
	// SettingActionDeleted: setting was deleted.
	SettingActionDeleted
)

func marshalSettingAction(p uintptr) (interface{}, error) {
	return SettingAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SettingAction.
func (s SettingAction) String() string {
	switch s {
	case NewSettingAction:
		return "New"
	case SettingActionChanged:
		return "Changed"
	case SettingActionDeleted:
		return "Deleted"
	default:
		return fmt.Sprintf("SettingAction(%d)", s)
	}
}

// TouchpadGesturePhase specifies the current state of a touchpad gesture. All
// gestures are guaranteed to begin with an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_BEGIN, followed by 0 or several events with phase
// GDK_TOUCHPAD_GESTURE_PHASE_UPDATE.
//
// A finished gesture may have 2 possible outcomes, an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is considered
// successful, this should be used as the hint to perform any permanent changes.
//
// Cancelled gestures may be so for a variety of reasons, due to hardware or the
// compositor, or due to the gesture recognition layers hinting the gesture did
// not finish resolutely (eg. a 3rd finger being added during a pinch gesture).
// In these cases, the last event will report the phase
// GDK_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint to undo any
// visible/permanent changes that were done throughout the progress of the
// gesture.
//
// See also EventTouchpadSwipe and EventTouchpadPinch.
type TouchpadGesturePhase C.gint

const (
	// TouchpadGesturePhaseBegin: gesture has begun.
	TouchpadGesturePhaseBegin TouchpadGesturePhase = iota
	// TouchpadGesturePhaseUpdate: gesture has been updated.
	TouchpadGesturePhaseUpdate
	// TouchpadGesturePhaseEnd: gesture was finished, changes should be
	// permanently applied.
	TouchpadGesturePhaseEnd
	// TouchpadGesturePhaseCancel: gesture was cancelled, all changes should be
	// undone.
	TouchpadGesturePhaseCancel
)

func marshalTouchpadGesturePhase(p uintptr) (interface{}, error) {
	return TouchpadGesturePhase(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TouchpadGesturePhase.
func (t TouchpadGesturePhase) String() string {
	switch t {
	case TouchpadGesturePhaseBegin:
		return "Begin"
	case TouchpadGesturePhaseUpdate:
		return "Update"
	case TouchpadGesturePhaseEnd:
		return "End"
	case TouchpadGesturePhaseCancel:
		return "Cancel"
	default:
		return fmt.Sprintf("TouchpadGesturePhase(%d)", t)
	}
}

// VisibilityState specifies the visiblity status of a window for a
// EventVisibility.
type VisibilityState C.gint

const (
	// VisibilityUnobscured: window is completely visible.
	VisibilityUnobscured VisibilityState = iota
	// VisibilityPartial: window is partially visible.
	VisibilityPartial
	// VisibilityFullyObscured: window is not visible at all.
	VisibilityFullyObscured
)

func marshalVisibilityState(p uintptr) (interface{}, error) {
	return VisibilityState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VisibilityState.
func (v VisibilityState) String() string {
	switch v {
	case VisibilityUnobscured:
		return "Unobscured"
	case VisibilityPartial:
		return "Partial"
	case VisibilityFullyObscured:
		return "FullyObscured"
	default:
		return fmt.Sprintf("VisibilityState(%d)", v)
	}
}

// WindowState specifies the state of a toplevel window.
type WindowState C.guint

const (
	// WindowStateWithdrawn: window is not shown.
	WindowStateWithdrawn WindowState = 0b1
	// WindowStateIconified: window is minimized.
	WindowStateIconified WindowState = 0b10
	// WindowStateMaximized: window is maximized.
	WindowStateMaximized WindowState = 0b100
	// WindowStateSticky: window is sticky.
	WindowStateSticky WindowState = 0b1000
	// WindowStateFullscreen: window is maximized without decorations.
	WindowStateFullscreen WindowState = 0b10000
	// WindowStateAbove: window is kept above other windows.
	WindowStateAbove WindowState = 0b100000
	// WindowStateBelow: window is kept below other windows.
	WindowStateBelow WindowState = 0b1000000
	// WindowStateFocused: window is presented as focused (with active
	// decorations).
	WindowStateFocused WindowState = 0b10000000
	// WindowStateTiled: window is in a tiled state, Since 3.10. Since 3.22.23,
	// this is deprecated in favor of per-edge information.
	WindowStateTiled WindowState = 0b100000000
	// WindowStateTopTiled: whether the top edge is tiled, Since 3.22.23.
	WindowStateTopTiled WindowState = 0b1000000000
	// WindowStateTopResizable: whether the top edge is resizable, Since
	// 3.22.23.
	WindowStateTopResizable WindowState = 0b10000000000
	// WindowStateRightTiled: whether the right edge is tiled, Since 3.22.23.
	WindowStateRightTiled WindowState = 0b100000000000
	// WindowStateRightResizable: whether the right edge is resizable, Since
	// 3.22.23.
	WindowStateRightResizable WindowState = 0b1000000000000
	// WindowStateBottomTiled: whether the bottom edge is tiled, Since 3.22.23.
	WindowStateBottomTiled WindowState = 0b10000000000000
	// WindowStateBottomResizable: whether the bottom edge is resizable, Since
	// 3.22.23.
	WindowStateBottomResizable WindowState = 0b100000000000000
	// WindowStateLeftTiled: whether the left edge is tiled, Since 3.22.23.
	WindowStateLeftTiled WindowState = 0b1000000000000000
	// WindowStateLeftResizable: whether the left edge is resizable, Since
	// 3.22.23.
	WindowStateLeftResizable WindowState = 0b10000000000000000
)

func marshalWindowState(p uintptr) (interface{}, error) {
	return WindowState(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for WindowState.
func (w WindowState) String() string {
	if w == 0 {
		return "WindowState(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for w != 0 {
		next := w & (w - 1)
		bit := w - next

		switch bit {
		case WindowStateWithdrawn:
			builder.WriteString("Withdrawn|")
		case WindowStateIconified:
			builder.WriteString("Iconified|")
		case WindowStateMaximized:
			builder.WriteString("Maximized|")
		case WindowStateSticky:
			builder.WriteString("Sticky|")
		case WindowStateFullscreen:
			builder.WriteString("Fullscreen|")
		case WindowStateAbove:
			builder.WriteString("Above|")
		case WindowStateBelow:
			builder.WriteString("Below|")
		case WindowStateFocused:
			builder.WriteString("Focused|")
		case WindowStateTiled:
			builder.WriteString("Tiled|")
		case WindowStateTopTiled:
			builder.WriteString("TopTiled|")
		case WindowStateTopResizable:
			builder.WriteString("TopResizable|")
		case WindowStateRightTiled:
			builder.WriteString("RightTiled|")
		case WindowStateRightResizable:
			builder.WriteString("RightResizable|")
		case WindowStateBottomTiled:
			builder.WriteString("BottomTiled|")
		case WindowStateBottomResizable:
			builder.WriteString("BottomResizable|")
		case WindowStateLeftTiled:
			builder.WriteString("LeftTiled|")
		case WindowStateLeftResizable:
			builder.WriteString("LeftResizable|")
		default:
			builder.WriteString(fmt.Sprintf("WindowState(0b%b)|", bit))
		}

		w = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if w contains other.
func (w WindowState) Has(other WindowState) bool {
	return (w & other) == other
}

// EventFunc specifies the type of function passed to gdk_event_handler_set() to
// handle all GDK events.
type EventFunc func(event *Event)

//export _gotk4_gdk3_EventFunc
func _gotk4_gdk3_EventFunc(arg1 *C.GdkEvent, arg2 C.gpointer) {
	var fn EventFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(EventFunc)
	}

	var _event *Event // out

	{
		v := (*Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		v = CopyEventer(v)
		_event = v
	}

	fn(_event)
}

// EventsGetAngle: if both events contain X/Y information, this function will
// return TRUE and return in angle the relative angle from event1 to event2. The
// rotation direction for positive angles is from the positive X axis towards
// the positive Y axis.
//
// The function takes the following parameters:
//
//    - event1: first Event.
//    - event2: second Event.
//
// The function returns the following values:
//
//    - angle: return location for the relative angle between both events.
//    - ok: TRUE if the angle could be calculated.
//
func EventsGetAngle(event1, event2 *Event) (float64, bool) {
	var _arg1 *C.GdkEvent // out
	var _arg2 *C.GdkEvent // out
	var _arg3 C.gdouble   // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event1)))
	_arg2 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event2)))

	_cret = C.gdk_events_get_angle(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(event1)
	runtime.KeepAlive(event2)

	var _angle float64 // out
	var _ok bool       // out

	_angle = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _angle, _ok
}

// EventsGetCenter: if both events contain X/Y information, the center of both
// coordinates will be returned in x and y.
//
// The function takes the following parameters:
//
//    - event1: first Event.
//    - event2: second Event.
//
// The function returns the following values:
//
//    - x: return location for the X coordinate of the center.
//    - y: return location for the Y coordinate of the center.
//    - ok: TRUE if the center could be calculated.
//
func EventsGetCenter(event1, event2 *Event) (x, y float64, ok bool) {
	var _arg1 *C.GdkEvent // out
	var _arg2 *C.GdkEvent // out
	var _arg3 C.gdouble   // in
	var _arg4 C.gdouble   // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event1)))
	_arg2 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event2)))

	_cret = C.gdk_events_get_center(_arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(event1)
	runtime.KeepAlive(event2)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg3)
	_y = float64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// EventsGetDistance: if both events have X/Y information, the distance between
// both coordinates (as in a straight line going from event1 to event2) will be
// returned.
//
// The function takes the following parameters:
//
//    - event1: first Event.
//    - event2: second Event.
//
// The function returns the following values:
//
//    - distance: return location for the distance.
//    - ok: TRUE if the distance could be calculated.
//
func EventsGetDistance(event1, event2 *Event) (float64, bool) {
	var _arg1 *C.GdkEvent // out
	var _arg2 *C.GdkEvent // out
	var _arg3 C.gdouble   // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event1)))
	_arg2 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event2)))

	_cret = C.gdk_events_get_distance(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(event1)
	runtime.KeepAlive(event2)

	var _distance float64 // out
	var _ok bool          // out

	_distance = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _distance, _ok
}

// EventsPending checks if any events are ready to be processed for any display.
//
// The function returns the following values:
//
//    - ok: TRUE if any events are pending.
//
func EventsPending() bool {
	var _cret C.gboolean // in

	_cret = C.gdk_events_pending()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetShowEvents gets whether event debugging output is enabled.
//
// The function returns the following values:
//
//    - ok: TRUE if event debugging output is enabled.
//
func GetShowEvents() bool {
	var _cret C.gboolean // in

	_cret = C.gdk_get_show_events()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetShowEvents sets whether a trace of received events is output. Note that
// GTK+ must be compiled with debugging (that is, configured using the
// --enable-debug option) to use this option.
//
// The function takes the following parameters:
//
//    - showEvents: TRUE to output event debugging information.
//
func SetShowEvents(showEvents bool) {
	var _arg1 C.gboolean // out

	if showEvents {
		_arg1 = C.TRUE
	}

	C.gdk_set_show_events(_arg1)
	runtime.KeepAlive(showEvents)
}

// SettingGet obtains a desktop-wide setting, such as the double-click time, for
// the default screen. See gdk_screen_get_setting().
//
// The function takes the following parameters:
//
//    - name of the setting.
//    - value: location to store the value of the setting.
//
// The function returns the following values:
//
//    - ok: TRUE if the setting existed and a value was stored in value, FALSE
//      otherwise.
//
func SettingGet(name string, value *coreglib.Value) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gdk_setting_get(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EventAny contains the fields which are common to all event structs. Any event
// pointer can safely be cast to a pointer to a EventAny to access these fields.
//
// An instance of this type is always passed by reference.
type EventAny struct {
	*eventAny
}

// eventAny is the struct that's finalized.
type eventAny struct {
	native *C.GdkEventAny
}

// Type: type of the event.
func (e *EventAny) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventAny) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventAny) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventAny) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// EventButton: used for button press and button release events. The type field
// will be one of GDK_BUTTON_PRESS, GDK_2BUTTON_PRESS, GDK_3BUTTON_PRESS or
// GDK_BUTTON_RELEASE,
//
// Double and triple-clicks result in a sequence of events being received. For
// double-clicks the order of events will be:
//
// - GDK_BUTTON_PRESS
//
// - GDK_BUTTON_RELEASE
//
// - GDK_BUTTON_PRESS
//
// - GDK_2BUTTON_PRESS
//
// - GDK_BUTTON_RELEASE
//
// Note that the first click is received just like a normal button press, while
// the second click results in a GDK_2BUTTON_PRESS being received just after the
// GDK_BUTTON_PRESS.
//
// Triple-clicks are very similar to double-clicks, except that
// GDK_3BUTTON_PRESS is inserted after the third click. The order of the events
// is:
//
// - GDK_BUTTON_PRESS
//
// - GDK_BUTTON_RELEASE
//
// - GDK_BUTTON_PRESS
//
// - GDK_2BUTTON_PRESS
//
// - GDK_BUTTON_RELEASE
//
// - GDK_BUTTON_PRESS
//
// - GDK_3BUTTON_PRESS
//
// - GDK_BUTTON_RELEASE
//
// For a double click to occur, the second button press must occur within 1/4 of
// a second of the first. For a triple click to occur, the third button press
// must also occur within 1/2 second of the first button press.
//
// An instance of this type is always passed by reference.
type EventButton struct {
	*eventButton
}

// eventButton is the struct that's finalized.
type eventButton struct {
	native *C.GdkEventButton
}

// Type: type of the event (GDK_BUTTON_PRESS, GDK_2BUTTON_PRESS,
// GDK_3BUTTON_PRESS or GDK_BUTTON_RELEASE).
func (e *EventButton) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventButton) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventButton) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventButton) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// X: x coordinate of the pointer relative to the window.
func (e *EventButton) X() float64 {
	valptr := &e.native.x
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventButton) Y() float64 {
	valptr := &e.native.y
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Axes: x, y translated to the axes of device, or NULL if device is the mouse.
func (e *EventButton) Axes() *float64 {
	valptr := &e.native.axes
	var v *float64 // out
	v = (*float64)(unsafe.Pointer(*valptr))
	return v
}

// State: bit-mask representing the state of the modifier keys (e.g. Control,
// Shift and Alt) and the pointer buttons. See ModifierType.
func (e *EventButton) State() ModifierType {
	valptr := &e.native.state
	var v ModifierType // out
	v = ModifierType(*valptr)
	return v
}

// Button: button which was pressed or released, numbered from 1 to 5. Normally
// button 1 is the left mouse button, 2 is the middle button, and 3 is the right
// button. On 2-button mice, the middle button can often be simulated by
// pressing both mouse buttons together.
func (e *EventButton) Button() uint32 {
	valptr := &e.native.button
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Device: master device that the event originated from. Use
// gdk_event_get_source_device() to get the slave device.
func (e *EventButton) Device() Devicer {
	valptr := &e.native.device
	var v Devicer // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Devicer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Devicer)
			return ok
		})
		rv, ok := casted.(Devicer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
		}
		v = rv
	}
	return v
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventButton) XRoot() float64 {
	valptr := &e.native.x_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventButton) YRoot() float64 {
	valptr := &e.native.y_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventButton) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventButton) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// X: x coordinate of the pointer relative to the window.
func (e *EventButton) SetX(x float64) {
	valptr := &e.native.x
	*valptr = C.gdouble(x)
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventButton) SetY(y float64) {
	valptr := &e.native.y
	*valptr = C.gdouble(y)
}

// Button: button which was pressed or released, numbered from 1 to 5. Normally
// button 1 is the left mouse button, 2 is the middle button, and 3 is the right
// button. On 2-button mice, the middle button can often be simulated by
// pressing both mouse buttons together.
func (e *EventButton) SetButton(button uint32) {
	valptr := &e.native.button
	*valptr = C.guint(button)
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventButton) SetXRoot(xRoot float64) {
	valptr := &e.native.x_root
	*valptr = C.gdouble(xRoot)
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventButton) SetYRoot(yRoot float64) {
	valptr := &e.native.y_root
	*valptr = C.gdouble(yRoot)
}

// EventConfigure: generated when a window size or position has changed.
//
// An instance of this type is always passed by reference.
type EventConfigure struct {
	*eventConfigure
}

// eventConfigure is the struct that's finalized.
type eventConfigure struct {
	native *C.GdkEventConfigure
}

// Type: type of the event (GDK_CONFIGURE).
func (e *EventConfigure) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventConfigure) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventConfigure) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// X: new x coordinate of the window, relative to its parent.
func (e *EventConfigure) X() int32 {
	valptr := &e.native.x
	var v int32 // out
	v = int32(*valptr)
	return v
}

// Y: new y coordinate of the window, relative to its parent.
func (e *EventConfigure) Y() int32 {
	valptr := &e.native.y
	var v int32 // out
	v = int32(*valptr)
	return v
}

// Width: new width of the window.
func (e *EventConfigure) Width() int32 {
	valptr := &e.native.width
	var v int32 // out
	v = int32(*valptr)
	return v
}

// Height: new height of the window.
func (e *EventConfigure) Height() int32 {
	valptr := &e.native.height
	var v int32 // out
	v = int32(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventConfigure) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// X: new x coordinate of the window, relative to its parent.
func (e *EventConfigure) SetX(x int32) {
	valptr := &e.native.x
	*valptr = C.gint(x)
}

// Y: new y coordinate of the window, relative to its parent.
func (e *EventConfigure) SetY(y int32) {
	valptr := &e.native.y
	*valptr = C.gint(y)
}

// Width: new width of the window.
func (e *EventConfigure) SetWidth(width int32) {
	valptr := &e.native.width
	*valptr = C.gint(width)
}

// Height: new height of the window.
func (e *EventConfigure) SetHeight(height int32) {
	valptr := &e.native.height
	*valptr = C.gint(height)
}

// EventCrossing: generated when the pointer enters or leaves a window.
//
// An instance of this type is always passed by reference.
type EventCrossing struct {
	*eventCrossing
}

// eventCrossing is the struct that's finalized.
type eventCrossing struct {
	native *C.GdkEventCrossing
}

// Type: type of the event (GDK_ENTER_NOTIFY or GDK_LEAVE_NOTIFY).
func (e *EventCrossing) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventCrossing) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventCrossing) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Subwindow: window that was entered or left.
func (e *EventCrossing) Subwindow() Windower {
	valptr := &e.native.subwindow
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// Time: time of the event in milliseconds.
func (e *EventCrossing) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// X: x coordinate of the pointer relative to the window.
func (e *EventCrossing) X() float64 {
	valptr := &e.native.x
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventCrossing) Y() float64 {
	valptr := &e.native.y
	var v float64 // out
	v = float64(*valptr)
	return v
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventCrossing) XRoot() float64 {
	valptr := &e.native.x_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventCrossing) YRoot() float64 {
	valptr := &e.native.y_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Mode: crossing mode (GDK_CROSSING_NORMAL, GDK_CROSSING_GRAB,
// GDK_CROSSING_UNGRAB, GDK_CROSSING_GTK_GRAB, GDK_CROSSING_GTK_UNGRAB or
// GDK_CROSSING_STATE_CHANGED). GDK_CROSSING_GTK_GRAB, GDK_CROSSING_GTK_UNGRAB,
// and GDK_CROSSING_STATE_CHANGED were added in 2.14 and are always synthesized,
// never native.
func (e *EventCrossing) Mode() CrossingMode {
	valptr := &e.native.mode
	var v CrossingMode // out
	v = CrossingMode(*valptr)
	return v
}

// Detail: kind of crossing that happened (GDK_NOTIFY_INFERIOR,
// GDK_NOTIFY_ANCESTOR, GDK_NOTIFY_VIRTUAL, GDK_NOTIFY_NONLINEAR or
// GDK_NOTIFY_NONLINEAR_VIRTUAL).
func (e *EventCrossing) Detail() NotifyType {
	valptr := &e.native.detail
	var v NotifyType // out
	v = NotifyType(*valptr)
	return v
}

// Focus: TRUE if window is the focus window or an inferior.
func (e *EventCrossing) Focus() bool {
	valptr := &e.native.focus
	var v bool // out
	if *valptr != 0 {
		v = true
	}
	return v
}

// State: bit-mask representing the state of the modifier keys (e.g. Control,
// Shift and Alt) and the pointer buttons. See ModifierType.
func (e *EventCrossing) State() ModifierType {
	valptr := &e.native.state
	var v ModifierType // out
	v = ModifierType(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventCrossing) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventCrossing) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// X: x coordinate of the pointer relative to the window.
func (e *EventCrossing) SetX(x float64) {
	valptr := &e.native.x
	*valptr = C.gdouble(x)
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventCrossing) SetY(y float64) {
	valptr := &e.native.y
	*valptr = C.gdouble(y)
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventCrossing) SetXRoot(xRoot float64) {
	valptr := &e.native.x_root
	*valptr = C.gdouble(xRoot)
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventCrossing) SetYRoot(yRoot float64) {
	valptr := &e.native.y_root
	*valptr = C.gdouble(yRoot)
}

// Focus: TRUE if window is the focus window or an inferior.
func (e *EventCrossing) SetFocus(focus bool) {
	valptr := &e.native.focus
	if focus {
		*valptr = C.TRUE
	}
}

// EventDND: generated during DND operations.
//
// An instance of this type is always passed by reference.
type EventDND struct {
	*eventDND
}

// eventDND is the struct that's finalized.
type eventDND struct {
	native *C.GdkEventDND
}

// Type: type of the event (GDK_DRAG_ENTER, GDK_DRAG_LEAVE, GDK_DRAG_MOTION,
// GDK_DRAG_STATUS, GDK_DROP_START or GDK_DROP_FINISHED).
func (e *EventDND) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventDND) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventDND) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Context for the current DND operation.
func (e *EventDND) Context() *DragContext {
	valptr := &e.native.context
	var v *DragContext // out
	v = wrapDragContext(coreglib.Take(unsafe.Pointer(*valptr)))
	return v
}

// Time: time of the event in milliseconds.
func (e *EventDND) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// XRoot: x coordinate of the pointer relative to the root of the screen, only
// set for GDK_DRAG_MOTION and GDK_DROP_START.
func (e *EventDND) XRoot() int16 {
	valptr := &e.native.x_root
	var v int16 // out
	v = int16(*valptr)
	return v
}

// YRoot: y coordinate of the pointer relative to the root of the screen, only
// set for GDK_DRAG_MOTION and GDK_DROP_START.
func (e *EventDND) YRoot() int16 {
	valptr := &e.native.y_root
	var v int16 // out
	v = int16(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventDND) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventDND) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// XRoot: x coordinate of the pointer relative to the root of the screen, only
// set for GDK_DRAG_MOTION and GDK_DROP_START.
func (e *EventDND) SetXRoot(xRoot int16) {
	valptr := &e.native.x_root
	*valptr = C.gshort(xRoot)
}

// YRoot: y coordinate of the pointer relative to the root of the screen, only
// set for GDK_DRAG_MOTION and GDK_DROP_START.
func (e *EventDND) SetYRoot(yRoot int16) {
	valptr := &e.native.y_root
	*valptr = C.gshort(yRoot)
}

// EventExpose: generated when all or part of a window becomes visible and needs
// to be redrawn.
//
// An instance of this type is always passed by reference.
type EventExpose struct {
	*eventExpose
}

// eventExpose is the struct that's finalized.
type eventExpose struct {
	native *C.GdkEventExpose
}

// Type: type of the event (GDK_EXPOSE or GDK_DAMAGE).
func (e *EventExpose) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventExpose) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventExpose) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Area: bounding box of region.
func (e *EventExpose) Area() *Rectangle {
	valptr := &e.native.area
	var v *Rectangle // out
	v = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&*valptr))))
	return v
}

// Region: region that needs to be redrawn.
func (e *EventExpose) Region() *cairo.Region {
	valptr := &e.native.region
	var v *cairo.Region // out
	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(*valptr)}
		v = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	C.cairo_region_reference(*valptr)
	runtime.SetFinalizer(v, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
	})
	return v
}

// Count: number of contiguous GDK_EXPOSE events following this one. The only
// use for this is â€œexposure compressionâ€, i.e. handling all contiguous
// GDK_EXPOSE events in one go, though GDK performs some exposure compression so
// this is not normally needed.
func (e *EventExpose) Count() int32 {
	valptr := &e.native.count
	var v int32 // out
	v = int32(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventExpose) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Count: number of contiguous GDK_EXPOSE events following this one. The only
// use for this is â€œexposure compressionâ€, i.e. handling all contiguous
// GDK_EXPOSE events in one go, though GDK performs some exposure compression so
// this is not normally needed.
func (e *EventExpose) SetCount(count int32) {
	valptr := &e.native.count
	*valptr = C.gint(count)
}

// EventFocus describes a change of keyboard focus.
//
// An instance of this type is always passed by reference.
type EventFocus struct {
	*eventFocus
}

// eventFocus is the struct that's finalized.
type eventFocus struct {
	native *C.GdkEventFocus
}

// Type: type of the event (GDK_FOCUS_CHANGE).
func (e *EventFocus) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventFocus) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventFocus) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// In: TRUE if the window has gained the keyboard focus, FALSE if it has lost
// the focus.
func (e *EventFocus) In() int16 {
	valptr := &e.native.in
	var v int16 // out
	v = int16(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventFocus) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// In: TRUE if the window has gained the keyboard focus, FALSE if it has lost
// the focus.
func (e *EventFocus) SetIn(in int16) {
	valptr := &e.native.in
	*valptr = C.gint16(in)
}

// EventGrabBroken: generated when a pointer or keyboard grab is broken. On X11,
// this happens when the grab window becomes unviewable (i.e. it or one of its
// ancestors is unmapped), or if the same application grabs the pointer or
// keyboard again. Note that implicit grabs (which are initiated by button
// presses) can also cause EventGrabBroken events.
//
// An instance of this type is always passed by reference.
type EventGrabBroken struct {
	*eventGrabBroken
}

// eventGrabBroken is the struct that's finalized.
type eventGrabBroken struct {
	native *C.GdkEventGrabBroken
}

// Type: type of the event (GDK_GRAB_BROKEN).
func (e *EventGrabBroken) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event, i.e. the window that previously
// owned the grab.
func (e *EventGrabBroken) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventGrabBroken) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Keyboard: TRUE if a keyboard grab was broken, FALSE if a pointer grab was
// broken.
func (e *EventGrabBroken) Keyboard() bool {
	valptr := &e.native.keyboard
	var v bool // out
	if *valptr != 0 {
		v = true
	}
	return v
}

// Implicit: TRUE if the broken grab was implicit.
func (e *EventGrabBroken) Implicit() bool {
	valptr := &e.native.implicit
	var v bool // out
	if *valptr != 0 {
		v = true
	}
	return v
}

// GrabWindow: if this event is caused by another grab in the same application,
// grab_window contains the new grab window. Otherwise grab_window is NULL.
func (e *EventGrabBroken) GrabWindow() Windower {
	valptr := &e.native.grab_window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventGrabBroken) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Keyboard: TRUE if a keyboard grab was broken, FALSE if a pointer grab was
// broken.
func (e *EventGrabBroken) SetKeyboard(keyboard bool) {
	valptr := &e.native.keyboard
	if keyboard {
		*valptr = C.TRUE
	}
}

// Implicit: TRUE if the broken grab was implicit.
func (e *EventGrabBroken) SetImplicit(implicit bool) {
	valptr := &e.native.implicit
	if implicit {
		*valptr = C.TRUE
	}
}

// EventKey describes a key press or key release event.
//
// An instance of this type is always passed by reference.
type EventKey struct {
	*eventKey
}

// eventKey is the struct that's finalized.
type eventKey struct {
	native *C.GdkEventKey
}

// Type: type of the event (GDK_KEY_PRESS or GDK_KEY_RELEASE).
func (e *EventKey) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventKey) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventKey) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventKey) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// State: bit-mask representing the state of the modifier keys (e.g. Control,
// Shift and Alt) and the pointer buttons. See ModifierType.
func (e *EventKey) State() ModifierType {
	valptr := &e.native.state
	var v ModifierType // out
	v = ModifierType(*valptr)
	return v
}

// Keyval: key that was pressed or released. See the gdk/gdkkeysyms.h header
// file for a complete list of GDK key codes.
func (e *EventKey) Keyval() uint32 {
	valptr := &e.native.keyval
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Length: length of string.
func (e *EventKey) Length() int32 {
	valptr := &e.native.length
	var v int32 // out
	v = int32(*valptr)
	return v
}

// String: string containing an approximation of the text that would result from
// this keypress. The only correct way to handle text input of text is using
// input methods (see IMContext), so this field is deprecated and should never
// be used. (gdk_unicode_to_keyval() provides a non-deprecated way of getting an
// approximate translation for a key.) The string is encoded in the encoding of
// the current locale (Note: this for backwards compatibility: strings in GTK+
// and GDK are typically in UTF-8.) and NUL-terminated. In some cases, the
// translation of the key code will be a single NUL byte, in which case looking
// at length is necessary to distinguish it from the an empty translation.
func (e *EventKey) String() string {
	valptr := &e.native.string
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return v
}

// HardwareKeycode: raw code of the key that was pressed or released.
func (e *EventKey) HardwareKeycode() uint16 {
	valptr := &e.native.hardware_keycode
	var v uint16 // out
	v = uint16(*valptr)
	return v
}

// Group: keyboard group.
func (e *EventKey) Group() byte {
	valptr := &e.native.group
	var v byte // out
	v = byte(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventKey) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventKey) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// Keyval: key that was pressed or released. See the gdk/gdkkeysyms.h header
// file for a complete list of GDK key codes.
func (e *EventKey) SetKeyval(keyval uint32) {
	valptr := &e.native.keyval
	*valptr = C.guint(keyval)
}

// Length: length of string.
func (e *EventKey) SetLength(length int32) {
	valptr := &e.native.length
	*valptr = C.gint(length)
}

// HardwareKeycode: raw code of the key that was pressed or released.
func (e *EventKey) SetHardwareKeycode(hardwareKeycode uint16) {
	valptr := &e.native.hardware_keycode
	*valptr = C.guint16(hardwareKeycode)
}

// Group: keyboard group.
func (e *EventKey) SetGroup(group byte) {
	valptr := &e.native.group
	*valptr = C.guint8(group)
}

// EventMotion: generated when the pointer moves.
//
// An instance of this type is always passed by reference.
type EventMotion struct {
	*eventMotion
}

// eventMotion is the struct that's finalized.
type eventMotion struct {
	native *C.GdkEventMotion
}

// Type: type of the event.
func (e *EventMotion) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventMotion) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventMotion) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventMotion) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// X: x coordinate of the pointer relative to the window.
func (e *EventMotion) X() float64 {
	valptr := &e.native.x
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventMotion) Y() float64 {
	valptr := &e.native.y
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Axes: x, y translated to the axes of device, or NULL if device is the mouse.
func (e *EventMotion) Axes() *float64 {
	valptr := &e.native.axes
	var v *float64 // out
	v = (*float64)(unsafe.Pointer(*valptr))
	return v
}

// State: bit-mask representing the state of the modifier keys (e.g. Control,
// Shift and Alt) and the pointer buttons. See ModifierType.
func (e *EventMotion) State() ModifierType {
	valptr := &e.native.state
	var v ModifierType // out
	v = ModifierType(*valptr)
	return v
}

// IsHint: set to 1 if this event is just a hint, see the
// GDK_POINTER_MOTION_HINT_MASK value of EventMask.
func (e *EventMotion) IsHint() int16 {
	valptr := &e.native.is_hint
	var v int16 // out
	v = int16(*valptr)
	return v
}

// Device: master device that the event originated from. Use
// gdk_event_get_source_device() to get the slave device.
func (e *EventMotion) Device() Devicer {
	valptr := &e.native.device
	var v Devicer // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Devicer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Devicer)
			return ok
		})
		rv, ok := casted.(Devicer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
		}
		v = rv
	}
	return v
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventMotion) XRoot() float64 {
	valptr := &e.native.x_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventMotion) YRoot() float64 {
	valptr := &e.native.y_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventMotion) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventMotion) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// X: x coordinate of the pointer relative to the window.
func (e *EventMotion) SetX(x float64) {
	valptr := &e.native.x
	*valptr = C.gdouble(x)
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventMotion) SetY(y float64) {
	valptr := &e.native.y
	*valptr = C.gdouble(y)
}

// IsHint: set to 1 if this event is just a hint, see the
// GDK_POINTER_MOTION_HINT_MASK value of EventMask.
func (e *EventMotion) SetIsHint(isHint int16) {
	valptr := &e.native.is_hint
	*valptr = C.gint16(isHint)
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventMotion) SetXRoot(xRoot float64) {
	valptr := &e.native.x_root
	*valptr = C.gdouble(xRoot)
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventMotion) SetYRoot(yRoot float64) {
	valptr := &e.native.y_root
	*valptr = C.gdouble(yRoot)
}

// EventOwnerChange: generated when the owner of a selection changes. On X11,
// this information is only available if the X server supports the XFIXES
// extension.
//
// An instance of this type is always passed by reference.
type EventOwnerChange struct {
	*eventOwnerChange
}

// eventOwnerChange is the struct that's finalized.
type eventOwnerChange struct {
	native *C.GdkEventOwnerChange
}

// EventPadAxis: generated during GDK_SOURCE_TABLET_PAD interaction with tactile
// sensors.
//
// An instance of this type is always passed by reference.
type EventPadAxis struct {
	*eventPadAxis
}

// eventPadAxis is the struct that's finalized.
type eventPadAxis struct {
	native *C.GdkEventPadAxis
}

// Type: type of the event (GDK_PAD_RING or GDK_PAD_STRIP).
func (e *EventPadAxis) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventPadAxis) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventPadAxis) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventPadAxis) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Group: pad group the ring/strip belongs to. A GDK_SOURCE_TABLET_PAD device
// may have one or more groups containing a set of buttons/rings/strips each.
func (e *EventPadAxis) Group() uint32 {
	valptr := &e.native.group
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Index: number of strip/ring that was interacted. This number is 0-indexed.
func (e *EventPadAxis) Index() uint32 {
	valptr := &e.native.index
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Mode: current mode of group. Different groups in a GDK_SOURCE_TABLET_PAD
// device may have different current modes.
func (e *EventPadAxis) Mode() uint32 {
	valptr := &e.native.mode
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Value: current value for the given axis.
func (e *EventPadAxis) Value() float64 {
	valptr := &e.native.value
	var v float64 // out
	v = float64(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventPadAxis) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventPadAxis) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// Group: pad group the ring/strip belongs to. A GDK_SOURCE_TABLET_PAD device
// may have one or more groups containing a set of buttons/rings/strips each.
func (e *EventPadAxis) SetGroup(group uint32) {
	valptr := &e.native.group
	*valptr = C.guint(group)
}

// Index: number of strip/ring that was interacted. This number is 0-indexed.
func (e *EventPadAxis) SetIndex(index uint32) {
	valptr := &e.native.index
	*valptr = C.guint(index)
}

// Mode: current mode of group. Different groups in a GDK_SOURCE_TABLET_PAD
// device may have different current modes.
func (e *EventPadAxis) SetMode(mode uint32) {
	valptr := &e.native.mode
	*valptr = C.guint(mode)
}

// Value: current value for the given axis.
func (e *EventPadAxis) SetValue(value float64) {
	valptr := &e.native.value
	*valptr = C.gdouble(value)
}

// EventPadButton: generated during GDK_SOURCE_TABLET_PAD button presses and
// releases.
//
// An instance of this type is always passed by reference.
type EventPadButton struct {
	*eventPadButton
}

// eventPadButton is the struct that's finalized.
type eventPadButton struct {
	native *C.GdkEventPadButton
}

// Type: type of the event (GDK_PAD_BUTTON_PRESS or GDK_PAD_BUTTON_RELEASE).
func (e *EventPadButton) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventPadButton) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventPadButton) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventPadButton) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Group: pad group the button belongs to. A GDK_SOURCE_TABLET_PAD device may
// have one or more groups containing a set of buttons/rings/strips each.
func (e *EventPadButton) Group() uint32 {
	valptr := &e.native.group
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Button: pad button that was pressed.
func (e *EventPadButton) Button() uint32 {
	valptr := &e.native.button
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Mode: current mode of group. Different groups in a GDK_SOURCE_TABLET_PAD
// device may have different current modes.
func (e *EventPadButton) Mode() uint32 {
	valptr := &e.native.mode
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventPadButton) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventPadButton) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// Group: pad group the button belongs to. A GDK_SOURCE_TABLET_PAD device may
// have one or more groups containing a set of buttons/rings/strips each.
func (e *EventPadButton) SetGroup(group uint32) {
	valptr := &e.native.group
	*valptr = C.guint(group)
}

// Button: pad button that was pressed.
func (e *EventPadButton) SetButton(button uint32) {
	valptr := &e.native.button
	*valptr = C.guint(button)
}

// Mode: current mode of group. Different groups in a GDK_SOURCE_TABLET_PAD
// device may have different current modes.
func (e *EventPadButton) SetMode(mode uint32) {
	valptr := &e.native.mode
	*valptr = C.guint(mode)
}

// EventPadGroupMode: generated during GDK_SOURCE_TABLET_PAD mode switches in a
// group.
//
// An instance of this type is always passed by reference.
type EventPadGroupMode struct {
	*eventPadGroupMode
}

// eventPadGroupMode is the struct that's finalized.
type eventPadGroupMode struct {
	native *C.GdkEventPadGroupMode
}

// Type: type of the event (GDK_PAD_GROUP_MODE).
func (e *EventPadGroupMode) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventPadGroupMode) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventPadGroupMode) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventPadGroupMode) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Group: pad group that is switching mode. A GDK_SOURCE_TABLET_PAD device may
// have one or more groups containing a set of buttons/rings/strips each.
func (e *EventPadGroupMode) Group() uint32 {
	valptr := &e.native.group
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Mode: new mode of group. Different groups in a GDK_SOURCE_TABLET_PAD device
// may have different current modes.
func (e *EventPadGroupMode) Mode() uint32 {
	valptr := &e.native.mode
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventPadGroupMode) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventPadGroupMode) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// Group: pad group that is switching mode. A GDK_SOURCE_TABLET_PAD device may
// have one or more groups containing a set of buttons/rings/strips each.
func (e *EventPadGroupMode) SetGroup(group uint32) {
	valptr := &e.native.group
	*valptr = C.guint(group)
}

// Mode: new mode of group. Different groups in a GDK_SOURCE_TABLET_PAD device
// may have different current modes.
func (e *EventPadGroupMode) SetMode(mode uint32) {
	valptr := &e.native.mode
	*valptr = C.guint(mode)
}

// EventProperty describes a property change on a window.
//
// An instance of this type is always passed by reference.
type EventProperty struct {
	*eventProperty
}

// eventProperty is the struct that's finalized.
type eventProperty struct {
	native *C.GdkEventProperty
}

// EventProximity: proximity events are generated when using GDKâ€™s wrapper for
// the XInput extension. The XInput extension is an add-on for standard X that
// allows you to use nonstandard devices such as graphics tablets. A proximity
// event indicates that the stylus has moved in or out of contact with the
// tablet, or perhaps that the userâ€™s finger has moved in or out of contact with
// a touch screen.
//
// This event type will be used pretty rarely. It only is important for XInput
// aware programs that are drawing their own cursor.
//
// An instance of this type is always passed by reference.
type EventProximity struct {
	*eventProximity
}

// eventProximity is the struct that's finalized.
type eventProximity struct {
	native *C.GdkEventProximity
}

// Type: type of the event (GDK_PROXIMITY_IN or GDK_PROXIMITY_OUT).
func (e *EventProximity) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventProximity) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventProximity) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventProximity) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// Device: master device that the event originated from. Use
// gdk_event_get_source_device() to get the slave device.
func (e *EventProximity) Device() Devicer {
	valptr := &e.native.device
	var v Devicer // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Devicer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Devicer)
			return ok
		})
		rv, ok := casted.(Devicer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventProximity) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventProximity) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// EventScroll: generated from button presses for the buttons 4 to 7. Wheel mice
// are usually configured to generate button press events for buttons 4 and 5
// when the wheel is turned.
//
// Some GDK backends can also generate â€œsmoothâ€ scroll events, which can be
// recognized by the GDK_SCROLL_SMOOTH scroll direction. For these, the scroll
// deltas can be obtained with gdk_event_get_scroll_deltas().
//
// An instance of this type is always passed by reference.
type EventScroll struct {
	*eventScroll
}

// eventScroll is the struct that's finalized.
type eventScroll struct {
	native *C.GdkEventScroll
}

// Type: type of the event (GDK_SCROLL).
func (e *EventScroll) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventScroll) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventScroll) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventScroll) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// X: x coordinate of the pointer relative to the window.
func (e *EventScroll) X() float64 {
	valptr := &e.native.x
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventScroll) Y() float64 {
	valptr := &e.native.y
	var v float64 // out
	v = float64(*valptr)
	return v
}

// State: bit-mask representing the state of the modifier keys (e.g. Control,
// Shift and Alt) and the pointer buttons. See ModifierType.
func (e *EventScroll) State() ModifierType {
	valptr := &e.native.state
	var v ModifierType // out
	v = ModifierType(*valptr)
	return v
}

// Direction: direction to scroll to (one of GDK_SCROLL_UP, GDK_SCROLL_DOWN,
// GDK_SCROLL_LEFT, GDK_SCROLL_RIGHT or GDK_SCROLL_SMOOTH).
func (e *EventScroll) Direction() ScrollDirection {
	valptr := &e.native.direction
	var v ScrollDirection // out
	v = ScrollDirection(*valptr)
	return v
}

// Device: master device that the event originated from. Use
// gdk_event_get_source_device() to get the slave device.
func (e *EventScroll) Device() Devicer {
	valptr := &e.native.device
	var v Devicer // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Devicer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Devicer)
			return ok
		})
		rv, ok := casted.(Devicer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
		}
		v = rv
	}
	return v
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventScroll) XRoot() float64 {
	valptr := &e.native.x_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventScroll) YRoot() float64 {
	valptr := &e.native.y_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// DeltaX: x coordinate of the scroll delta.
func (e *EventScroll) DeltaX() float64 {
	valptr := &e.native.delta_x
	var v float64 // out
	v = float64(*valptr)
	return v
}

// DeltaY: y coordinate of the scroll delta.
func (e *EventScroll) DeltaY() float64 {
	valptr := &e.native.delta_y
	var v float64 // out
	v = float64(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventScroll) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventScroll) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// X: x coordinate of the pointer relative to the window.
func (e *EventScroll) SetX(x float64) {
	valptr := &e.native.x
	*valptr = C.gdouble(x)
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventScroll) SetY(y float64) {
	valptr := &e.native.y
	*valptr = C.gdouble(y)
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventScroll) SetXRoot(xRoot float64) {
	valptr := &e.native.x_root
	*valptr = C.gdouble(xRoot)
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventScroll) SetYRoot(yRoot float64) {
	valptr := &e.native.y_root
	*valptr = C.gdouble(yRoot)
}

// DeltaX: x coordinate of the scroll delta.
func (e *EventScroll) SetDeltaX(deltaX float64) {
	valptr := &e.native.delta_x
	*valptr = C.gdouble(deltaX)
}

// DeltaY: y coordinate of the scroll delta.
func (e *EventScroll) SetDeltaY(deltaY float64) {
	valptr := &e.native.delta_y
	*valptr = C.gdouble(deltaY)
}

// EventSelection: generated when a selection is requested or ownership of a
// selection is taken over by another client application.
//
// An instance of this type is always passed by reference.
type EventSelection struct {
	*eventSelection
}

// eventSelection is the struct that's finalized.
type eventSelection struct {
	native *C.GdkEventSelection
}

// EventSequence: instance of this type is always passed by reference.
type EventSequence struct {
	*eventSequence
}

// eventSequence is the struct that's finalized.
type eventSequence struct {
	native *C.GdkEventSequence
}

func marshalEventSequence(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &EventSequence{&eventSequence{(*C.GdkEventSequence)(b)}}, nil
}

// EventSetting: generated when a setting is modified.
//
// An instance of this type is always passed by reference.
type EventSetting struct {
	*eventSetting
}

// eventSetting is the struct that's finalized.
type eventSetting struct {
	native *C.GdkEventSetting
}

// Type: type of the event (GDK_SETTING).
func (e *EventSetting) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventSetting) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventSetting) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Action: what happened to the setting (GDK_SETTING_ACTION_NEW,
// GDK_SETTING_ACTION_CHANGED or GDK_SETTING_ACTION_DELETED).
func (e *EventSetting) Action() SettingAction {
	valptr := &e.native.action
	var v SettingAction // out
	v = SettingAction(*valptr)
	return v
}

// Name: name of the setting.
func (e *EventSetting) Name() string {
	valptr := &e.native.name
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventSetting) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// EventTouch: used for touch events. type field will be one of GDK_TOUCH_BEGIN,
// GDK_TOUCH_UPDATE, GDK_TOUCH_END or GDK_TOUCH_CANCEL.
//
// Touch events are grouped into sequences by means of the sequence field, which
// can also be obtained with gdk_event_get_event_sequence(). Each sequence
// begins with a GDK_TOUCH_BEGIN event, followed by any number of
// GDK_TOUCH_UPDATE events, and ends with a GDK_TOUCH_END (or GDK_TOUCH_CANCEL)
// event. With multitouch devices, there may be several active sequences at the
// same time.
//
// An instance of this type is always passed by reference.
type EventTouch struct {
	*eventTouch
}

// eventTouch is the struct that's finalized.
type eventTouch struct {
	native *C.GdkEventTouch
}

// Type: type of the event (GDK_TOUCH_BEGIN, GDK_TOUCH_UPDATE, GDK_TOUCH_END,
// GDK_TOUCH_CANCEL).
func (e *EventTouch) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventTouch) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventTouch) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventTouch) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// X: x coordinate of the pointer relative to the window.
func (e *EventTouch) X() float64 {
	valptr := &e.native.x
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventTouch) Y() float64 {
	valptr := &e.native.y
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Axes: x, y translated to the axes of device, or NULL if device is the mouse.
func (e *EventTouch) Axes() *float64 {
	valptr := &e.native.axes
	var v *float64 // out
	v = (*float64)(unsafe.Pointer(*valptr))
	return v
}

// State: bit-mask representing the state of the modifier keys (e.g. Control,
// Shift and Alt) and the pointer buttons. See ModifierType.
func (e *EventTouch) State() ModifierType {
	valptr := &e.native.state
	var v ModifierType // out
	v = ModifierType(*valptr)
	return v
}

// Sequence: event sequence that the event belongs to.
func (e *EventTouch) Sequence() *EventSequence {
	valptr := &e.native.sequence
	var v *EventSequence // out
	v = (*EventSequence)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return v
}

// EmulatingPointer: whether the event should be used for emulating pointer
// event.
func (e *EventTouch) EmulatingPointer() bool {
	valptr := &e.native.emulating_pointer
	var v bool // out
	if *valptr != 0 {
		v = true
	}
	return v
}

// Device: master device that the event originated from. Use
// gdk_event_get_source_device() to get the slave device.
func (e *EventTouch) Device() Devicer {
	valptr := &e.native.device
	var v Devicer // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Devicer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Devicer)
			return ok
		})
		rv, ok := casted.(Devicer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
		}
		v = rv
	}
	return v
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventTouch) XRoot() float64 {
	valptr := &e.native.x_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventTouch) YRoot() float64 {
	valptr := &e.native.y_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventTouch) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Time: time of the event in milliseconds.
func (e *EventTouch) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// X: x coordinate of the pointer relative to the window.
func (e *EventTouch) SetX(x float64) {
	valptr := &e.native.x
	*valptr = C.gdouble(x)
}

// Y: y coordinate of the pointer relative to the window.
func (e *EventTouch) SetY(y float64) {
	valptr := &e.native.y
	*valptr = C.gdouble(y)
}

// EmulatingPointer: whether the event should be used for emulating pointer
// event.
func (e *EventTouch) SetEmulatingPointer(emulatingPointer bool) {
	valptr := &e.native.emulating_pointer
	if emulatingPointer {
		*valptr = C.TRUE
	}
}

// XRoot: x coordinate of the pointer relative to the root of the screen.
func (e *EventTouch) SetXRoot(xRoot float64) {
	valptr := &e.native.x_root
	*valptr = C.gdouble(xRoot)
}

// YRoot: y coordinate of the pointer relative to the root of the screen.
func (e *EventTouch) SetYRoot(yRoot float64) {
	valptr := &e.native.y_root
	*valptr = C.gdouble(yRoot)
}

// EventTouchpadPinch: generated during touchpad swipe gestures.
//
// An instance of this type is always passed by reference.
type EventTouchpadPinch struct {
	*eventTouchpadPinch
}

// eventTouchpadPinch is the struct that's finalized.
type eventTouchpadPinch struct {
	native *C.GdkEventTouchpadPinch
}

// Type: type of the event (GDK_TOUCHPAD_PINCH).
func (e *EventTouchpadPinch) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventTouchpadPinch) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventTouchpadPinch) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Phase: current phase of the gesture.
func (e *EventTouchpadPinch) Phase() int8 {
	valptr := &e.native.phase
	var v int8 // out
	v = int8(*valptr)
	return v
}

// NFingers: number of fingers triggering the pinch.
func (e *EventTouchpadPinch) NFingers() int8 {
	valptr := &e.native.n_fingers
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventTouchpadPinch) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// X coordinate of the pointer.
func (e *EventTouchpadPinch) X() float64 {
	valptr := &e.native.x
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Y coordinate of the pointer.
func (e *EventTouchpadPinch) Y() float64 {
	valptr := &e.native.y
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Dx: movement delta in the X axis of the swipe focal point.
func (e *EventTouchpadPinch) Dx() float64 {
	valptr := &e.native.dx
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Dy: movement delta in the Y axis of the swipe focal point.
func (e *EventTouchpadPinch) Dy() float64 {
	valptr := &e.native.dy
	var v float64 // out
	v = float64(*valptr)
	return v
}

// AngleDelta: angle change in radians, negative angles denote counter-clockwise
// movements.
func (e *EventTouchpadPinch) AngleDelta() float64 {
	valptr := &e.native.angle_delta
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Scale: current scale, relative to that at the time of the corresponding
// GDK_TOUCHPAD_GESTURE_PHASE_BEGIN event.
func (e *EventTouchpadPinch) Scale() float64 {
	valptr := &e.native.scale
	var v float64 // out
	v = float64(*valptr)
	return v
}

// XRoot: x coordinate of the pointer, relative to the root of the screen.
func (e *EventTouchpadPinch) XRoot() float64 {
	valptr := &e.native.x_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// YRoot: y coordinate of the pointer, relative to the root of the screen.
func (e *EventTouchpadPinch) YRoot() float64 {
	valptr := &e.native.y_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// State: bit-mask representing the state of the modifier keys (e.g. Control,
// Shift and Alt) and the pointer buttons. See ModifierType.
func (e *EventTouchpadPinch) State() ModifierType {
	valptr := &e.native.state
	var v ModifierType // out
	v = ModifierType(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventTouchpadPinch) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Phase: current phase of the gesture.
func (e *EventTouchpadPinch) SetPhase(phase int8) {
	valptr := &e.native.phase
	*valptr = C.gint8(phase)
}

// NFingers: number of fingers triggering the pinch.
func (e *EventTouchpadPinch) SetNFingers(nFingers int8) {
	valptr := &e.native.n_fingers
	*valptr = C.gint8(nFingers)
}

// Time: time of the event in milliseconds.
func (e *EventTouchpadPinch) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// X coordinate of the pointer.
func (e *EventTouchpadPinch) SetX(x float64) {
	valptr := &e.native.x
	*valptr = C.gdouble(x)
}

// Y coordinate of the pointer.
func (e *EventTouchpadPinch) SetY(y float64) {
	valptr := &e.native.y
	*valptr = C.gdouble(y)
}

// Dx: movement delta in the X axis of the swipe focal point.
func (e *EventTouchpadPinch) SetDx(dx float64) {
	valptr := &e.native.dx
	*valptr = C.gdouble(dx)
}

// Dy: movement delta in the Y axis of the swipe focal point.
func (e *EventTouchpadPinch) SetDy(dy float64) {
	valptr := &e.native.dy
	*valptr = C.gdouble(dy)
}

// AngleDelta: angle change in radians, negative angles denote counter-clockwise
// movements.
func (e *EventTouchpadPinch) SetAngleDelta(angleDelta float64) {
	valptr := &e.native.angle_delta
	*valptr = C.gdouble(angleDelta)
}

// Scale: current scale, relative to that at the time of the corresponding
// GDK_TOUCHPAD_GESTURE_PHASE_BEGIN event.
func (e *EventTouchpadPinch) SetScale(scale float64) {
	valptr := &e.native.scale
	*valptr = C.gdouble(scale)
}

// XRoot: x coordinate of the pointer, relative to the root of the screen.
func (e *EventTouchpadPinch) SetXRoot(xRoot float64) {
	valptr := &e.native.x_root
	*valptr = C.gdouble(xRoot)
}

// YRoot: y coordinate of the pointer, relative to the root of the screen.
func (e *EventTouchpadPinch) SetYRoot(yRoot float64) {
	valptr := &e.native.y_root
	*valptr = C.gdouble(yRoot)
}

// EventTouchpadSwipe: generated during touchpad swipe gestures.
//
// An instance of this type is always passed by reference.
type EventTouchpadSwipe struct {
	*eventTouchpadSwipe
}

// eventTouchpadSwipe is the struct that's finalized.
type eventTouchpadSwipe struct {
	native *C.GdkEventTouchpadSwipe
}

// Type: type of the event (GDK_TOUCHPAD_SWIPE).
func (e *EventTouchpadSwipe) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventTouchpadSwipe) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventTouchpadSwipe) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Phase: current phase of the gesture.
func (e *EventTouchpadSwipe) Phase() int8 {
	valptr := &e.native.phase
	var v int8 // out
	v = int8(*valptr)
	return v
}

// NFingers: number of fingers triggering the swipe.
func (e *EventTouchpadSwipe) NFingers() int8 {
	valptr := &e.native.n_fingers
	var v int8 // out
	v = int8(*valptr)
	return v
}

// Time: time of the event in milliseconds.
func (e *EventTouchpadSwipe) Time() uint32 {
	valptr := &e.native.time
	var v uint32 // out
	v = uint32(*valptr)
	return v
}

// X coordinate of the pointer.
func (e *EventTouchpadSwipe) X() float64 {
	valptr := &e.native.x
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Y coordinate of the pointer.
func (e *EventTouchpadSwipe) Y() float64 {
	valptr := &e.native.y
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Dx: movement delta in the X axis of the swipe focal point.
func (e *EventTouchpadSwipe) Dx() float64 {
	valptr := &e.native.dx
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Dy: movement delta in the Y axis of the swipe focal point.
func (e *EventTouchpadSwipe) Dy() float64 {
	valptr := &e.native.dy
	var v float64 // out
	v = float64(*valptr)
	return v
}

// XRoot: x coordinate of the pointer, relative to the root of the screen.
func (e *EventTouchpadSwipe) XRoot() float64 {
	valptr := &e.native.x_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// YRoot: y coordinate of the pointer, relative to the root of the screen.
func (e *EventTouchpadSwipe) YRoot() float64 {
	valptr := &e.native.y_root
	var v float64 // out
	v = float64(*valptr)
	return v
}

// State: bit-mask representing the state of the modifier keys (e.g. Control,
// Shift and Alt) and the pointer buttons. See ModifierType.
func (e *EventTouchpadSwipe) State() ModifierType {
	valptr := &e.native.state
	var v ModifierType // out
	v = ModifierType(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventTouchpadSwipe) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Phase: current phase of the gesture.
func (e *EventTouchpadSwipe) SetPhase(phase int8) {
	valptr := &e.native.phase
	*valptr = C.gint8(phase)
}

// NFingers: number of fingers triggering the swipe.
func (e *EventTouchpadSwipe) SetNFingers(nFingers int8) {
	valptr := &e.native.n_fingers
	*valptr = C.gint8(nFingers)
}

// Time: time of the event in milliseconds.
func (e *EventTouchpadSwipe) SetTime(time uint32) {
	valptr := &e.native.time
	*valptr = C.guint32(time)
}

// X coordinate of the pointer.
func (e *EventTouchpadSwipe) SetX(x float64) {
	valptr := &e.native.x
	*valptr = C.gdouble(x)
}

// Y coordinate of the pointer.
func (e *EventTouchpadSwipe) SetY(y float64) {
	valptr := &e.native.y
	*valptr = C.gdouble(y)
}

// Dx: movement delta in the X axis of the swipe focal point.
func (e *EventTouchpadSwipe) SetDx(dx float64) {
	valptr := &e.native.dx
	*valptr = C.gdouble(dx)
}

// Dy: movement delta in the Y axis of the swipe focal point.
func (e *EventTouchpadSwipe) SetDy(dy float64) {
	valptr := &e.native.dy
	*valptr = C.gdouble(dy)
}

// XRoot: x coordinate of the pointer, relative to the root of the screen.
func (e *EventTouchpadSwipe) SetXRoot(xRoot float64) {
	valptr := &e.native.x_root
	*valptr = C.gdouble(xRoot)
}

// YRoot: y coordinate of the pointer, relative to the root of the screen.
func (e *EventTouchpadSwipe) SetYRoot(yRoot float64) {
	valptr := &e.native.y_root
	*valptr = C.gdouble(yRoot)
}

// EventVisibility: generated when the window visibility status has changed.
//
// Deprecated: Modern composited windowing systems with pervasive transparency
// make it impossible to track the visibility of a window reliably, so this
// event can not be guaranteed to provide useful information.
//
// An instance of this type is always passed by reference.
type EventVisibility struct {
	*eventVisibility
}

// eventVisibility is the struct that's finalized.
type eventVisibility struct {
	native *C.GdkEventVisibility
}

// Type: type of the event (GDK_VISIBILITY_NOTIFY).
func (e *EventVisibility) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventVisibility) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventVisibility) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// State: new visibility state (GDK_VISIBILITY_FULLY_OBSCURED,
// GDK_VISIBILITY_PARTIAL or GDK_VISIBILITY_UNOBSCURED).
func (e *EventVisibility) State() VisibilityState {
	valptr := &e.native.state
	var v VisibilityState // out
	v = VisibilityState(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventVisibility) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// EventWindowState: generated when the state of a toplevel window changes.
//
// An instance of this type is always passed by reference.
type EventWindowState struct {
	*eventWindowState
}

// eventWindowState is the struct that's finalized.
type eventWindowState struct {
	native *C.GdkEventWindowState
}

// Type: type of the event (GDK_WINDOW_STATE).
func (e *EventWindowState) Type() EventType {
	valptr := &e.native._type
	var v EventType // out
	v = EventType(*valptr)
	return v
}

// Window: window which received the event.
func (e *EventWindowState) Window() Windower {
	valptr := &e.native.window
	var v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		v = rv
	}
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventWindowState) SendEvent() int8 {
	valptr := &e.native.send_event
	var v int8 // out
	v = int8(*valptr)
	return v
}

// ChangedMask: mask specifying what flags have changed.
func (e *EventWindowState) ChangedMask() WindowState {
	valptr := &e.native.changed_mask
	var v WindowState // out
	v = WindowState(*valptr)
	return v
}

// NewWindowState: new window state, a combination of WindowState bits.
func (e *EventWindowState) NewWindowState() WindowState {
	valptr := &e.native.new_window_state
	var v WindowState // out
	v = WindowState(*valptr)
	return v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventWindowState) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Event contains a union of all of the event types, and allows access to the
// data fields in a number of ways.
//
// The event type is always the first field in all of the event types, and can
// always be accessed with the following code, no matter what type of event it
// is:
//
//      GdkEvent *event;
//      gdouble x;
//
//      x = event->button.x;.
type Event struct {
	*event
}

// event has the finalizer attached to it.
type event struct {
	native *C.GdkEvent
}

// Eventer is used for all functions that accept any kind of Event.
type Eventer interface {
	// Implementing types:
	//
	//    *EventAny
	//    *EventExpose
	//    *EventVisibility
	//    *EventMotion
	//    *EventButton
	//    *EventTouch
	//    *EventScroll
	//    *EventKey
	//    *EventCrossing
	//    *EventFocus
	//    *EventConfigure
	//    *EventProperty
	//    *EventSelection
	//    *EventOwnerChange
	//    *EventProximity
	//    *EventDND
	//    *EventWindowState
	//    *EventSetting
	//    *EventGrabBroken
	//    *EventTouchpadSwipe
	//    *EventTouchpadPinch
	//    *EventPadButton
	//    *EventPadAxis
	//    *EventPadGroupMode
	//

	underlyingEvent() unsafe.Pointer
}

// CopyEventer copies any type that belongs to a Event union
// into a new Event instance. To see supported types, refer to
// Eventer's documentation.
func CopyEventer(e Eventer) *Event {
	original := (*C.GdkEvent)(e.underlyingEvent())
	copied := C.gdk_event_copy(original)
	dst := (*Event)(gextras.NewStructNative(unsafe.Pointer(copied)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	return dst
}

func marshalEvent(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Event{&event{(*C.GdkEvent)(b)}}, nil
}

func (v *Event) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsType returns a copy of e as the struct EventType.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsType() EventType {
	cpy := e.event.native
	var dst EventType
	dst = *(*EventType)(unsafe.Pointer(cpy))
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventAny) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsAny returns a copy of e as the struct *EventAny.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsAny() *EventAny {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventAny
	dst = (*EventAny)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventExpose) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsExpose returns a copy of e as the struct *EventExpose.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsExpose() *EventExpose {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventExpose
	dst = (*EventExpose)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventVisibility) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsVisibility returns a copy of e as the struct *EventVisibility.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsVisibility() *EventVisibility {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventVisibility
	dst = (*EventVisibility)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventMotion) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsMotion returns a copy of e as the struct *EventMotion.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsMotion() *EventMotion {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventMotion
	dst = (*EventMotion)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventButton) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsButton returns a copy of e as the struct *EventButton.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsButton() *EventButton {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventButton
	dst = (*EventButton)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventTouch) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsTouch returns a copy of e as the struct *EventTouch.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsTouch() *EventTouch {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventTouch
	dst = (*EventTouch)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventScroll) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsScroll returns a copy of e as the struct *EventScroll.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsScroll() *EventScroll {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventScroll
	dst = (*EventScroll)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventKey) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsKey returns a copy of e as the struct *EventKey.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsKey() *EventKey {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventKey
	dst = (*EventKey)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventCrossing) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsCrossing returns a copy of e as the struct *EventCrossing.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsCrossing() *EventCrossing {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventCrossing
	dst = (*EventCrossing)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventFocus) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsFocusChange returns a copy of e as the struct *EventFocus.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsFocusChange() *EventFocus {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventFocus
	dst = (*EventFocus)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventConfigure) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsConfigure returns a copy of e as the struct *EventConfigure.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsConfigure() *EventConfigure {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventConfigure
	dst = (*EventConfigure)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventProperty) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsProperty returns a copy of e as the struct *EventProperty.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsProperty() *EventProperty {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventProperty
	dst = (*EventProperty)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventSelection) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsSelection returns a copy of e as the struct *EventSelection.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsSelection() *EventSelection {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventSelection
	dst = (*EventSelection)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventOwnerChange) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsOwnerChange returns a copy of e as the struct *EventOwnerChange.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsOwnerChange() *EventOwnerChange {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventOwnerChange
	dst = (*EventOwnerChange)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventProximity) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsProximity returns a copy of e as the struct *EventProximity.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsProximity() *EventProximity {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventProximity
	dst = (*EventProximity)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventDND) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsDND returns a copy of e as the struct *EventDND.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsDND() *EventDND {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventDND
	dst = (*EventDND)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventWindowState) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsWindowState returns a copy of e as the struct *EventWindowState.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsWindowState() *EventWindowState {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventWindowState
	dst = (*EventWindowState)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventSetting) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsSetting returns a copy of e as the struct *EventSetting.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsSetting() *EventSetting {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventSetting
	dst = (*EventSetting)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventGrabBroken) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsGrabBroken returns a copy of e as the struct *EventGrabBroken.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsGrabBroken() *EventGrabBroken {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventGrabBroken
	dst = (*EventGrabBroken)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventTouchpadSwipe) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsTouchpadSwipe returns a copy of e as the struct *EventTouchpadSwipe.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsTouchpadSwipe() *EventTouchpadSwipe {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventTouchpadSwipe
	dst = (*EventTouchpadSwipe)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventTouchpadPinch) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsTouchpadPinch returns a copy of e as the struct *EventTouchpadPinch.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsTouchpadPinch() *EventTouchpadPinch {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventTouchpadPinch
	dst = (*EventTouchpadPinch)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventPadButton) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsPadButton returns a copy of e as the struct *EventPadButton.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsPadButton() *EventPadButton {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventPadButton
	dst = (*EventPadButton)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventPadAxis) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsPadAxis returns a copy of e as the struct *EventPadAxis.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsPadAxis() *EventPadAxis {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventPadAxis
	dst = (*EventPadAxis)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// underlyingEvent marks the struct for Eventer.
func (v *EventPadGroupMode) underlyingEvent() unsafe.Pointer {
	return unsafe.Pointer(v.native)
}

// AsPadGroupMode returns a copy of e as the struct *EventPadGroupMode.
// It does this without any knowledge on the actual type of the value, so
// the caller must take care of type-checking beforehand.
func (e *Event) AsPadGroupMode() *EventPadGroupMode {
	cpy := (*C.GdkEvent)(C.gdk_event_copy(e.event.native))
	var dst *EventPadGroupMode
	dst = (*EventPadGroupMode)(gextras.NewStructNative(unsafe.Pointer(cpy)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(dst)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_event_free((*C.GdkEvent)(intern.C))
		},
	)
	runtime.KeepAlive(e.event)
	return dst
}

// EventGet checks all open displays for a Event to process,to be processed on,
// fetching events from the windowing system if necessary. See
// gdk_display_get_event().
//
// The function returns the following values:
//
//    - event (optional): next Event to be processed, or NULL if no events are
//      pending. The returned Event should be freed with gdk_event_free().
//
func EventGet() *Event {
	var _cret *C.GdkEvent // in

	_cret = C.gdk_event_get()

	var _event *Event // out

	if _cret != nil {
		{
			v := (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
			_event = v
		}
	}

	return _event
}

// EventHandlerSet sets the function to call to handle all events from GDK.
//
// Note that GTK+ uses this to install its own event handler, so it is usually
// not useful for GTK+ applications. (Although an application can call this
// function then call gtk_main_do_event() to pass events to GTK+.).
//
// The function takes the following parameters:
//
//    - fn: function to call to handle events from GDK.
//
func EventHandlerSet(fn EventFunc) {
	var _arg1 C.GdkEventFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg1 = (*[0]byte)(C._gotk4_gdk3_EventFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gdk_event_handler_set(_arg1, _arg2, _arg3)
	runtime.KeepAlive(fn)
}

// EventPeek: if there is an event waiting in the event queue of some open
// display, returns a copy of it. See gdk_display_peek_event().
//
// The function returns the following values:
//
//    - event (optional): copy of the first Event on some event queue, or NULL if
//      no events are in any queues. The returned Event should be freed with
//      gdk_event_free().
//
func EventPeek() *Event {
	var _cret *C.GdkEvent // in

	_cret = C.gdk_event_peek()

	var _event *Event // out

	if _cret != nil {
		{
			v := (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
			_event = v
		}
	}

	return _event
}

// EventRequestMotions: request more motion notifies if event is a motion notify
// hint event.
//
// This function should be used instead of gdk_window_get_pointer() to request
// further motion notifies, because it also works for extension events where
// motion notifies are provided for devices other than the core pointer.
// Coordinate extraction, processing and requesting more motion events from a
// GDK_MOTION_NOTIFY event usually works like this:
//
//    {
//      // motion_event handler
//      x = motion_event->x;
//      y = motion_event->y;
//      // handle (x,y) motion
//      gdk_event_request_motions (motion_event); // handles is_hint events
//    }.
//
// The function takes the following parameters:
//
//    - event: valid Event.
//
func EventRequestMotions(event *EventMotion) {
	var _arg1 *C.GdkEventMotion // out

	_arg1 = (*C.GdkEventMotion)(gextras.StructNative(unsafe.Pointer(event)))

	C.gdk_event_request_motions(_arg1)
	runtime.KeepAlive(event)
}
