// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
// #include <glib-object.h>
// extern void _gotk4_gdk3_FrameClock_ConnectUpdate(gpointer, guintptr);
// extern void _gotk4_gdk3_FrameClock_ConnectResumeEvents(gpointer, guintptr);
// extern void _gotk4_gdk3_FrameClock_ConnectPaint(gpointer, guintptr);
// extern void _gotk4_gdk3_FrameClock_ConnectLayout(gpointer, guintptr);
// extern void _gotk4_gdk3_FrameClock_ConnectFlushEvents(gpointer, guintptr);
// extern void _gotk4_gdk3_FrameClock_ConnectBeforePaint(gpointer, guintptr);
// extern void _gotk4_gdk3_FrameClock_ConnectAfterPaint(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeFrameClock = coreglib.Type(C.gdk_frame_clock_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFrameClock, F: marshalFrameClock},
	})
}

// FrameClock tells the application when to update and repaint a window. This
// may be synced to the vertical refresh rate of the monitor, for example. Even
// when the frame clock uses a simple timer rather than a hardware-based
// vertical sync, the frame clock helps because it ensures everything paints at
// the same time (reducing the total number of frames). The frame clock can also
// automatically stop painting when it knows the frames will not be visible, or
// scale back animation framerates.
//
// FrameClock is designed to be compatible with an OpenGL-based implementation
// or with mozRequestAnimationFrame in Firefox, for example.
//
// A frame clock is idle until someone requests a frame with
// gdk_frame_clock_request_phase(). At some later point that makes sense for the
// synchronization being implemented, the clock will process a frame and emit
// signals for each phase that has been requested. (See the signals of the
// FrameClock class for documentation of the phases.
// GDK_FRAME_CLOCK_PHASE_UPDATE and the FrameClock::update signal are most
// interesting for application writers, and are used to update the animations,
// using the frame time given by gdk_frame_clock_get_frame_time().
//
// The frame time is reported in microseconds and generally in the same
// timescale as g_get_monotonic_time(), however, it is not the same as
// g_get_monotonic_time(). The frame time does not advance during the time a
// frame is being painted, and outside of a frame, an attempt is made so that
// all calls to gdk_frame_clock_get_frame_time() that are called at a “similar”
// time get the same value. This means that if different animations are timed by
// looking at the difference in time between an initial value from
// gdk_frame_clock_get_frame_time() and the value inside the FrameClock::update
// signal of the clock, they will stay exactly synchronized.
type FrameClock struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FrameClock)(nil)
)

// FrameClocker describes types inherited from class FrameClock.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FrameClocker interface {
	coreglib.Objector
	baseFrameClock() *FrameClock
}

var _ FrameClocker = (*FrameClock)(nil)

func wrapFrameClock(obj *coreglib.Object) *FrameClock {
	return &FrameClock{
		Object: obj,
	}
}

func marshalFrameClock(p uintptr) (interface{}, error) {
	return wrapFrameClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (frameClock *FrameClock) baseFrameClock() *FrameClock {
	return frameClock
}

// BaseFrameClock returns the underlying base object.
func BaseFrameClock(obj FrameClocker) *FrameClock {
	return obj.baseFrameClock()
}

// ConnectAfterPaint: this signal ends processing of the frame. Applications
// should generally not handle this signal.
func (frameClock *FrameClock) ConnectAfterPaint(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "after-paint", false, unsafe.Pointer(C._gotk4_gdk3_FrameClock_ConnectAfterPaint), f)
}

// ConnectBeforePaint: this signal begins processing of the frame. Applications
// should generally not handle this signal.
func (frameClock *FrameClock) ConnectBeforePaint(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "before-paint", false, unsafe.Pointer(C._gotk4_gdk3_FrameClock_ConnectBeforePaint), f)
}

// ConnectFlushEvents: this signal is used to flush pending motion events that
// are being batched up and compressed together. Applications should not handle
// this signal.
func (frameClock *FrameClock) ConnectFlushEvents(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "flush-events", false, unsafe.Pointer(C._gotk4_gdk3_FrameClock_ConnectFlushEvents), f)
}

// ConnectLayout: this signal is emitted as the second step of toolkit and
// application processing of the frame. Any work to update sizes and positions
// of application elements should be performed. GTK+ normally handles this
// internally.
func (frameClock *FrameClock) ConnectLayout(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "layout", false, unsafe.Pointer(C._gotk4_gdk3_FrameClock_ConnectLayout), f)
}

// ConnectPaint: this signal is emitted as the third step of toolkit and
// application processing of the frame. The frame is repainted. GDK normally
// handles this internally and produces expose events, which are turned into
// GTK+ Widget::draw signals.
func (frameClock *FrameClock) ConnectPaint(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "paint", false, unsafe.Pointer(C._gotk4_gdk3_FrameClock_ConnectPaint), f)
}

// ConnectResumeEvents: this signal is emitted after processing of the frame is
// finished, and is handled internally by GTK+ to resume normal event
// processing. Applications should not handle this signal.
func (frameClock *FrameClock) ConnectResumeEvents(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "resume-events", false, unsafe.Pointer(C._gotk4_gdk3_FrameClock_ConnectResumeEvents), f)
}

// ConnectUpdate: this signal is emitted as the first step of toolkit and
// application processing of the frame. Animations should be updated using
// gdk_frame_clock_get_frame_time(). Applications can connect directly to this
// signal, or use gtk_widget_add_tick_callback() as a more convenient interface.
func (frameClock *FrameClock) ConnectUpdate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "update", false, unsafe.Pointer(C._gotk4_gdk3_FrameClock_ConnectUpdate), f)
}
