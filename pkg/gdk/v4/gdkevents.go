// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GTypeCrossingMode returns the GType for the type CrossingMode.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeCrossingMode() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "CrossingMode").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalCrossingMode)
	return gtype
}

// GTypeEventType returns the GType for the type EventType.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeEventType() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "EventType").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalEventType)
	return gtype
}

// GTypeKeyMatch returns the GType for the type KeyMatch.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeKeyMatch() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "KeyMatch").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalKeyMatch)
	return gtype
}

// GTypeNotifyType returns the GType for the type NotifyType.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeNotifyType() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "NotifyType").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalNotifyType)
	return gtype
}

// GTypeScrollDirection returns the GType for the type ScrollDirection.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeScrollDirection() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "ScrollDirection").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalScrollDirection)
	return gtype
}

// GTypeTouchpadGesturePhase returns the GType for the type TouchpadGesturePhase.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTouchpadGesturePhase() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "TouchpadGesturePhase").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTouchpadGesturePhase)
	return gtype
}

// GTypeButtonEvent returns the GType for the type ButtonEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeButtonEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "ButtonEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalButtonEvent)
	return gtype
}

// GTypeCrossingEvent returns the GType for the type CrossingEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeCrossingEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "CrossingEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalCrossingEvent)
	return gtype
}

// GTypeDNDEvent returns the GType for the type DNDEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeDNDEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "DNDEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalDNDEvent)
	return gtype
}

// GTypeDeleteEvent returns the GType for the type DeleteEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeDeleteEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "DeleteEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalDeleteEvent)
	return gtype
}

// GTypeEvent returns the GType for the type Event.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "Event").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalEvent)
	return gtype
}

// GTypeFocusEvent returns the GType for the type FocusEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFocusEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "FocusEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalFocusEvent)
	return gtype
}

// GTypeGrabBrokenEvent returns the GType for the type GrabBrokenEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeGrabBrokenEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "GrabBrokenEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalGrabBrokenEvent)
	return gtype
}

// GTypeKeyEvent returns the GType for the type KeyEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeKeyEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "KeyEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalKeyEvent)
	return gtype
}

// GTypeMotionEvent returns the GType for the type MotionEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeMotionEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "MotionEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalMotionEvent)
	return gtype
}

// GTypePadEvent returns the GType for the type PadEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypePadEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "PadEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalPadEvent)
	return gtype
}

// GTypeProximityEvent returns the GType for the type ProximityEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeProximityEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "ProximityEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalProximityEvent)
	return gtype
}

// GTypeScrollEvent returns the GType for the type ScrollEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeScrollEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "ScrollEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalScrollEvent)
	return gtype
}

// GTypeTouchEvent returns the GType for the type TouchEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTouchEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "TouchEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTouchEvent)
	return gtype
}

// GTypeTouchpadEvent returns the GType for the type TouchpadEvent.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTouchpadEvent() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "TouchpadEvent").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTouchpadEvent)
	return gtype
}

// GTypeEventSequence returns the GType for the type EventSequence.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeEventSequence() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "EventSequence").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalEventSequence)
	return gtype
}

// BUTTON_MIDDLE: middle button.
const BUTTON_MIDDLE = 2

// BUTTON_PRIMARY: primary button. This is typically the left mouse button, or
// the right button in a left-handed setup.
const BUTTON_PRIMARY = 1

// BUTTON_SECONDARY: secondary button. This is typically the right mouse button,
// or the left button in a left-handed setup.
const BUTTON_SECONDARY = 3

// EVENT_PROPAGATE: use this macro as the return value for continuing the
// propagation of an event handler.
const EVENT_PROPAGATE = false

// EVENT_STOP: use this macro as the return value for stopping the propagation
// of an event handler.
const EVENT_STOP = true

// PRIORITY_REDRAW: this is the priority that the idle handler processing
// surface updates is given in the main loop.
const PRIORITY_REDRAW = 120

// CrossingMode specifies the crossing mode for enter and leave events.
type CrossingMode C.gint

const (
	// CrossingNormal: crossing because of pointer motion.
	CrossingNormal CrossingMode = iota
	// CrossingGrab: crossing because a grab is activated.
	CrossingGrab
	// CrossingUngrab: crossing because a grab is deactivated.
	CrossingUngrab
	// CrossingGTKGrab: crossing because a GTK grab is activated.
	CrossingGTKGrab
	// CrossingGTKUngrab: crossing because a GTK grab is deactivated.
	CrossingGTKUngrab
	// CrossingStateChanged: crossing because a GTK widget changed state (e.g.
	// sensitivity).
	CrossingStateChanged
	// CrossingTouchBegin: crossing because a touch sequence has begun, this
	// event is synthetic as the pointer might have not left the surface.
	CrossingTouchBegin
	// CrossingTouchEnd: crossing because a touch sequence has ended, this event
	// is synthetic as the pointer might have not left the surface.
	CrossingTouchEnd
	// CrossingDeviceSwitch: crossing because of a device switch (i.e. a mouse
	// taking control of the pointer after a touch device), this event is
	// synthetic as the pointer didnâ€™t leave the surface.
	CrossingDeviceSwitch
)

func marshalCrossingMode(p uintptr) (interface{}, error) {
	return CrossingMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CrossingMode.
func (c CrossingMode) String() string {
	switch c {
	case CrossingNormal:
		return "Normal"
	case CrossingGrab:
		return "Grab"
	case CrossingUngrab:
		return "Ungrab"
	case CrossingGTKGrab:
		return "GTKGrab"
	case CrossingGTKUngrab:
		return "GTKUngrab"
	case CrossingStateChanged:
		return "StateChanged"
	case CrossingTouchBegin:
		return "TouchBegin"
	case CrossingTouchEnd:
		return "TouchEnd"
	case CrossingDeviceSwitch:
		return "DeviceSwitch"
	default:
		return fmt.Sprintf("CrossingMode(%d)", c)
	}
}

// EventType specifies the type of the event.
type EventType C.gint

const (
	// Delete: window manager has requested that the toplevel surface be hidden
	// or destroyed, usually when the user clicks on a special icon in the title
	// bar.
	Delete EventType = iota
	// MotionNotify: pointer (usually a mouse) has moved.
	MotionNotify
	// ButtonPress: mouse button has been pressed.
	ButtonPress
	// ButtonRelease: mouse button has been released.
	ButtonRelease
	// KeyPress: key has been pressed.
	KeyPress
	// KeyRelease: key has been released.
	KeyRelease
	// EnterNotify: pointer has entered the surface.
	EnterNotify
	// LeaveNotify: pointer has left the surface.
	LeaveNotify
	// FocusChange: keyboard focus has entered or left the surface.
	FocusChange
	// ProximityIn: input device has moved into contact with a sensing surface
	// (e.g. a touchscreen or graphics tablet).
	ProximityIn
	// ProximityOut: input device has moved out of contact with a sensing
	// surface.
	ProximityOut
	// DragEnter: mouse has entered the surface while a drag is in progress.
	DragEnter
	// DragLeave: mouse has left the surface while a drag is in progress.
	DragLeave
	// DragMotion: mouse has moved in the surface while a drag is in progress.
	DragMotion
	// DropStart: drop operation onto the surface has started.
	DropStart
	// Scroll: scroll wheel was turned.
	Scroll
	// GrabBroken: pointer or keyboard grab was broken.
	GrabBroken
	// TouchBegin: new touch event sequence has just started.
	TouchBegin
	// TouchUpdate: touch event sequence has been updated.
	TouchUpdate
	// TouchEnd: touch event sequence has finished.
	TouchEnd
	// TouchCancel: touch event sequence has been canceled.
	TouchCancel
	// TouchpadSwipe: touchpad swipe gesture event, the current state is
	// determined by its phase field.
	TouchpadSwipe
	// TouchpadPinch: touchpad pinch gesture event, the current state is
	// determined by its phase field.
	TouchpadPinch
	// PadButtonPress: tablet pad button press event.
	PadButtonPress
	// PadButtonRelease: tablet pad button release event.
	PadButtonRelease
	// PadRing: tablet pad axis event from a "ring".
	PadRing
	// PadStrip: tablet pad axis event from a "strip".
	PadStrip
	// PadGroupMode: tablet pad group mode change.
	PadGroupMode
	// EventLast marks the end of the GdkEventType enumeration.
	EventLast
)

func marshalEventType(p uintptr) (interface{}, error) {
	return EventType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EventType.
func (e EventType) String() string {
	switch e {
	case Delete:
		return "Delete"
	case MotionNotify:
		return "MotionNotify"
	case ButtonPress:
		return "ButtonPress"
	case ButtonRelease:
		return "ButtonRelease"
	case KeyPress:
		return "KeyPress"
	case KeyRelease:
		return "KeyRelease"
	case EnterNotify:
		return "EnterNotify"
	case LeaveNotify:
		return "LeaveNotify"
	case FocusChange:
		return "FocusChange"
	case ProximityIn:
		return "ProximityIn"
	case ProximityOut:
		return "ProximityOut"
	case DragEnter:
		return "DragEnter"
	case DragLeave:
		return "DragLeave"
	case DragMotion:
		return "DragMotion"
	case DropStart:
		return "DropStart"
	case Scroll:
		return "Scroll"
	case GrabBroken:
		return "GrabBroken"
	case TouchBegin:
		return "TouchBegin"
	case TouchUpdate:
		return "TouchUpdate"
	case TouchEnd:
		return "TouchEnd"
	case TouchCancel:
		return "TouchCancel"
	case TouchpadSwipe:
		return "TouchpadSwipe"
	case TouchpadPinch:
		return "TouchpadPinch"
	case PadButtonPress:
		return "PadButtonPress"
	case PadButtonRelease:
		return "PadButtonRelease"
	case PadRing:
		return "PadRing"
	case PadStrip:
		return "PadStrip"
	case PadGroupMode:
		return "PadGroupMode"
	case EventLast:
		return "EventLast"
	default:
		return fmt.Sprintf("EventType(%d)", e)
	}
}

// KeyMatch describes how well an event matches a given keyval and modifiers.
//
// GdkKeyMatch values are returned by gdk.KeyEvent.Matches().
type KeyMatch C.gint

const (
	// KeyMatchNone: key event does not match.
	KeyMatchNone KeyMatch = iota
	// KeyMatchPartial: key event matches if keyboard state (specifically, the
	// currently active group) is ignored.
	KeyMatchPartial
	// KeyMatchExact: key event matches.
	KeyMatchExact
)

func marshalKeyMatch(p uintptr) (interface{}, error) {
	return KeyMatch(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for KeyMatch.
func (k KeyMatch) String() string {
	switch k {
	case KeyMatchNone:
		return "None"
	case KeyMatchPartial:
		return "Partial"
	case KeyMatchExact:
		return "Exact"
	default:
		return fmt.Sprintf("KeyMatch(%d)", k)
	}
}

// NotifyType specifies the kind of crossing for enter and leave events.
//
// See the X11 protocol specification of LeaveNotify for full details of
// crossing event generation.
type NotifyType C.gint

const (
	// NotifyAncestor: surface is entered from an ancestor or left towards an
	// ancestor.
	NotifyAncestor NotifyType = iota
	// NotifyVirtual: pointer moves between an ancestor and an inferior of the
	// surface.
	NotifyVirtual
	// NotifyInferior: surface is entered from an inferior or left towards an
	// inferior.
	NotifyInferior
	// NotifyNonlinear: surface is entered from or left towards a surface which
	// is neither an ancestor nor an inferior.
	NotifyNonlinear
	// NotifyNonlinearVirtual: pointer moves between two surfaces which are not
	// ancestors of each other and the surface is part of the ancestor chain
	// between one of these surfaces and their least common ancestor.
	NotifyNonlinearVirtual
	// NotifyUnknown: unknown type of enter/leave event occurred.
	NotifyUnknown
)

func marshalNotifyType(p uintptr) (interface{}, error) {
	return NotifyType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NotifyType.
func (n NotifyType) String() string {
	switch n {
	case NotifyAncestor:
		return "Ancestor"
	case NotifyVirtual:
		return "Virtual"
	case NotifyInferior:
		return "Inferior"
	case NotifyNonlinear:
		return "Nonlinear"
	case NotifyNonlinearVirtual:
		return "NonlinearVirtual"
	case NotifyUnknown:
		return "Unknown"
	default:
		return fmt.Sprintf("NotifyType(%d)", n)
	}
}

// ScrollDirection specifies the direction for scroll events.
type ScrollDirection C.gint

const (
	// ScrollUp: surface is scrolled up.
	ScrollUp ScrollDirection = iota
	// ScrollDown: surface is scrolled down.
	ScrollDown
	// ScrollLeft: surface is scrolled to the left.
	ScrollLeft
	// ScrollRight: surface is scrolled to the right.
	ScrollRight
	// ScrollSmooth: scrolling is determined by the delta values in scroll
	// events. See gdk_scroll_event_get_deltas().
	ScrollSmooth
)

func marshalScrollDirection(p uintptr) (interface{}, error) {
	return ScrollDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollDirection.
func (s ScrollDirection) String() string {
	switch s {
	case ScrollUp:
		return "Up"
	case ScrollDown:
		return "Down"
	case ScrollLeft:
		return "Left"
	case ScrollRight:
		return "Right"
	case ScrollSmooth:
		return "Smooth"
	default:
		return fmt.Sprintf("ScrollDirection(%d)", s)
	}
}

// TouchpadGesturePhase specifies the current state of a touchpad gesture.
//
// All gestures are guaranteed to begin with an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_BEGIN, followed by 0 or several events with phase
// GDK_TOUCHPAD_GESTURE_PHASE_UPDATE.
//
// A finished gesture may have 2 possible outcomes, an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is considered
// successful, this should be used as the hint to perform any permanent changes.
//
// Cancelled gestures may be so for a variety of reasons, due to hardware or the
// compositor, or due to the gesture recognition layers hinting the gesture did
// not finish resolutely (eg. a 3rd finger being added during a pinch gesture).
// In these cases, the last event will report the phase
// GDK_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint to undo any
// visible/permanent changes that were done throughout the progress of the
// gesture.
type TouchpadGesturePhase C.gint

const (
	// TouchpadGesturePhaseBegin: gesture has begun.
	TouchpadGesturePhaseBegin TouchpadGesturePhase = iota
	// TouchpadGesturePhaseUpdate: gesture has been updated.
	TouchpadGesturePhaseUpdate
	// TouchpadGesturePhaseEnd: gesture was finished, changes should be
	// permanently applied.
	TouchpadGesturePhaseEnd
	// TouchpadGesturePhaseCancel: gesture was cancelled, all changes should be
	// undone.
	TouchpadGesturePhaseCancel
)

func marshalTouchpadGesturePhase(p uintptr) (interface{}, error) {
	return TouchpadGesturePhase(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TouchpadGesturePhase.
func (t TouchpadGesturePhase) String() string {
	switch t {
	case TouchpadGesturePhaseBegin:
		return "Begin"
	case TouchpadGesturePhaseUpdate:
		return "Update"
	case TouchpadGesturePhaseEnd:
		return "End"
	case TouchpadGesturePhaseCancel:
		return "Cancel"
	default:
		return fmt.Sprintf("TouchpadGesturePhase(%d)", t)
	}
}

// EventsGetAngle returns the relative angle from event1 to event2.
//
// The relative angle is the angle between the X axis and the line through both
// events' positions. The rotation direction for positive angles is from the
// positive X axis towards the positive Y axis.
//
// This assumes that both events have X/Y information. If not, this function
// returns FALSE.
//
// The function takes the following parameters:
//
//    - event1: first GdkEvent.
//    - event2: second GdkEvent.
//
// The function returns the following values:
//
//    - angle: return location for the relative angle between both events.
//    - ok: TRUE if the angle could be calculated.
//
func EventsGetAngle(event1, event2 Eventer) (float64, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event1).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event2).Native()))

	_gret := girepository.MustFind("Gdk", "events_get_angle").Invoke(_args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event1)
	runtime.KeepAlive(event2)

	var _angle float64 // out
	var _ok bool       // out

	_angle = *(*float64)(unsafe.Pointer(_outs[0]))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _angle, _ok
}

// EventsGetCenter returns the point halfway between the events' positions.
//
// This assumes that both events have X/Y information. If not, this function
// returns FALSE.
//
// The function takes the following parameters:
//
//    - event1: first GdkEvent.
//    - event2: second GdkEvent.
//
// The function returns the following values:
//
//    - x: return location for the X coordinate of the center.
//    - y: return location for the Y coordinate of the center.
//    - ok: TRUE if the center could be calculated.
//
func EventsGetCenter(event1, event2 Eventer) (x, y float64, ok bool) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event1).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event2).Native()))

	_gret := girepository.MustFind("Gdk", "events_get_center").Invoke(_args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event1)
	runtime.KeepAlive(event2)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = *(*float64)(unsafe.Pointer(_outs[0]))
	_y = *(*float64)(unsafe.Pointer(_outs[1]))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// EventsGetDistance returns the distance between the event locations.
//
// This assumes that both events have X/Y information. If not, this function
// returns FALSE.
//
// The function takes the following parameters:
//
//    - event1: first GdkEvent.
//    - event2: second GdkEvent.
//
// The function returns the following values:
//
//    - distance: return location for the distance.
//    - ok: TRUE if the distance could be calculated.
//
func EventsGetDistance(event1, event2 Eventer) (float64, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event1).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event2).Native()))

	_gret := girepository.MustFind("Gdk", "events_get_distance").Invoke(_args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event1)
	runtime.KeepAlive(event2)

	var _distance float64 // out
	var _ok bool          // out

	_distance = *(*float64)(unsafe.Pointer(_outs[0]))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _distance, _ok
}

// ButtonEvent: event related to a button on a pointer device.
type ButtonEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*ButtonEvent)(nil)
)

func wrapButtonEvent(obj *coreglib.Object) *ButtonEvent {
	return &ButtonEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalButtonEvent(p uintptr) (interface{}, error) {
	return wrapButtonEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Button: extract the button number from a button event.
//
// The function returns the following values:
//
//    - guint: button of event.
//
func (event *ButtonEvent) Button() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "ButtonEvent").InvokeMethod("get_button", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// CrossingEvent: event caused by a pointing device moving between surfaces.
type CrossingEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*CrossingEvent)(nil)
)

func wrapCrossingEvent(obj *coreglib.Object) *CrossingEvent {
	return &CrossingEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalCrossingEvent(p uintptr) (interface{}, error) {
	return wrapCrossingEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Focus checks if the event surface is the focus surface.
//
// The function returns the following values:
//
//    - ok: TRUE if the surface is the focus surface.
//
func (event *CrossingEvent) Focus() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "CrossingEvent").InvokeMethod("get_focus", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DNDEvent: event related to drag and drop operations.
type DNDEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*DNDEvent)(nil)
)

func wrapDNDEvent(obj *coreglib.Object) *DNDEvent {
	return &DNDEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalDNDEvent(p uintptr) (interface{}, error) {
	return wrapDNDEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Drop gets the GdkDrop object from a DND event.
//
// The function returns the following values:
//
//    - drop (optional): drop.
//
func (event *DNDEvent) Drop() Dropper {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "DNDEvent").InvokeMethod("get_drop", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _drop Dropper // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Dropper)
				return ok
			})
			rv, ok := casted.(Dropper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Dropper")
			}
			_drop = rv
		}
	}

	return _drop
}

// DeleteEvent: event related to closing a top-level surface.
type DeleteEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*DeleteEvent)(nil)
)

func wrapDeleteEvent(obj *coreglib.Object) *DeleteEvent {
	return &DeleteEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalDeleteEvent(p uintptr) (interface{}, error) {
	return wrapDeleteEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Event GdkEvents are immutable data structures, created by GDK to represent
// windowing system events.
//
// In GTK applications the events are handled automatically by toplevel widgets
// and passed on to the event controllers of appropriate widgets, so using
// GdkEvent and its related API is rarely needed.
type Event struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Event)(nil)
)

// Eventer describes types inherited from class Event.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Eventer interface {
	coreglib.Objector
	baseEvent() *Event
}

var _ Eventer = (*Event)(nil)

func wrapEvent(obj *coreglib.Object) *Event {
	return &Event{
		Object: obj,
	}
}

func marshalEvent(p uintptr) (interface{}, error) {
	return wrapEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (event *Event) baseEvent() *Event {
	return event
}

// BaseEvent returns the underlying base object.
func BaseEvent(obj Eventer) *Event {
	return obj.baseEvent()
}

// Axes extracts all axis values from an event.
//
// The function returns the following values:
//
//    - axes: array of values for all axes.
//    - ok: TRUE on success, otherwise FALSE.
//
func (event *Event) Axes() ([]float64, bool) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_axes", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _axes []float64 // out
	var _ok bool        // out

	_axes = make([]float64, _outs[1])
	copy(_axes, unsafe.Slice((*float64)(unsafe.Pointer(_outs[0])), _outs[1]))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _axes, _ok
}

// Device returns the device of an event.
//
// The function returns the following values:
//
//    - device (optional): Device.
//
func (event *Event) Device() Devicer {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_device", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _device Devicer // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// DeviceTool returns a GdkDeviceTool representing the tool that caused the
// event.
//
// If the was not generated by a device that supports different tools (such as a
// tablet), this function will return NULL.
//
// Note: the GdkDeviceTool will be constant during the application lifetime, if
// settings must be stored persistently across runs, see
// gdk.DeviceTool.GetSerial().
//
// The function returns the following values:
//
//    - deviceTool (optional): current device tool, or NULL.
//
func (event *Event) DeviceTool() *DeviceTool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_device_tool", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _deviceTool *DeviceTool // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_deviceTool = wrapDeviceTool(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _deviceTool
}

// Display retrieves the display associated to the event.
//
// The function returns the following values:
//
//    - display (optional): Display.
//
func (event *Event) Display() *Display {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_display", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _display *Display // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// EventSequence retuns the event sequence to which the event belongs.
//
// Related touch events are connected in a sequence. Other events typically
// don't have event sequence information.
//
// The function returns the following values:
//
//    - eventSequence: event sequence that the event belongs to.
//
func (event *Event) EventSequence() *EventSequence {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_event_sequence", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _eventSequence *EventSequence // out

	_eventSequence = (*EventSequence)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _eventSequence
}

// PointerEmulated returns whether this event is an 'emulated' pointer event.
//
// Emulated pointer events typically originate from a touch events.
//
// The function returns the following values:
//
//    - ok: TRUE if this event is emulated.
//
func (event *Event) PointerEmulated() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_pointer_emulated", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Position: extract the event surface relative x/y coordinates from an event.
//
// The function returns the following values:
//
//    - x: location to put event surface x coordinate.
//    - y: location to put event surface y coordinate.
//    - ok
//
func (event *Event) Position() (x, y float64, ok bool) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_position", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = *(*float64)(unsafe.Pointer(_outs[0]))
	_y = *(*float64)(unsafe.Pointer(_outs[1]))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// Seat returns the seat that originated the event.
//
// The function returns the following values:
//
//    - seat (optional): Seat.
//
func (event *Event) Seat() Seater {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_seat", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _seat Seater // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Seater)
				return ok
			})
			rv, ok := casted.(Seater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Seater")
			}
			_seat = rv
		}
	}

	return _seat
}

// Surface extracts the surface associated with an event.
//
// The function returns the following values:
//
//    - surface associated with the event.
//
func (event *Event) Surface() Surfacer {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_surface", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _surface Surfacer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Surfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Surfacer)
			return ok
		})
		rv, ok := casted.(Surfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
		}
		_surface = rv
	}

	return _surface
}

// Time returns the timestamp of event.
//
// Not all events have timestamps. In that case, this function returns
// GDK_CURRENT_TIME.
//
// The function returns the following values:
//
//    - guint32: timestamp field from event.
//
func (event *Event) Time() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("get_time", _args[:], nil)
	_cret = *(*C.guint32)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _guint32 uint32 // out

	_guint32 = uint32(*(*C.guint32)(unsafe.Pointer(&_cret)))

	return _guint32
}

// TriggersContextMenu returns whether a GdkEvent should trigger a context menu,
// according to platform conventions.
//
// The right mouse button typically triggers context menus.
//
// This function should always be used instead of simply checking for
// event->button == GDK_BUTTON_SECONDARY.
//
// The function returns the following values:
//
//    - ok: TRUE if the event should trigger a context menu.
//
func (event *Event) TriggersContextMenu() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "Event").InvokeMethod("triggers_context_menu", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// FocusEvent: event related to a keyboard focus change.
type FocusEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*FocusEvent)(nil)
)

func wrapFocusEvent(obj *coreglib.Object) *FocusEvent {
	return &FocusEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalFocusEvent(p uintptr) (interface{}, error) {
	return wrapFocusEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// In extracts whether this event is about focus entering or leaving the
// surface.
//
// The function returns the following values:
//
//    - ok: TRUE of the focus is entering.
//
func (event *FocusEvent) In() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "FocusEvent").InvokeMethod("get_in", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// GrabBrokenEvent: event related to a broken windowing system grab.
type GrabBrokenEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*GrabBrokenEvent)(nil)
)

func wrapGrabBrokenEvent(obj *coreglib.Object) *GrabBrokenEvent {
	return &GrabBrokenEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalGrabBrokenEvent(p uintptr) (interface{}, error) {
	return wrapGrabBrokenEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GrabSurface extracts the grab surface from a grab broken event.
//
// The function returns the following values:
//
//    - surface: grab surface of event.
//
func (event *GrabBrokenEvent) GrabSurface() Surfacer {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "GrabBrokenEvent").InvokeMethod("get_grab_surface", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _surface Surfacer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Surfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Surfacer)
			return ok
		})
		rv, ok := casted.(Surfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
		}
		_surface = rv
	}

	return _surface
}

// Implicit checks whether the grab broken event is for an implicit grab.
//
// The function returns the following values:
//
//    - ok: TRUE if the an implicit grab was broken.
//
func (event *GrabBrokenEvent) Implicit() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "GrabBrokenEvent").InvokeMethod("get_implicit", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// KeyEvent: event related to a key-based device.
type KeyEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*KeyEvent)(nil)
)

func wrapKeyEvent(obj *coreglib.Object) *KeyEvent {
	return &KeyEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalKeyEvent(p uintptr) (interface{}, error) {
	return wrapKeyEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Keycode extracts the keycode from a key event.
//
// The function returns the following values:
//
//    - guint: keycode of event.
//
func (event *KeyEvent) Keycode() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "KeyEvent").InvokeMethod("get_keycode", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Keyval extracts the keyval from a key event.
//
// The function returns the following values:
//
//    - guint: keyval of event.
//
func (event *KeyEvent) Keyval() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "KeyEvent").InvokeMethod("get_keyval", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Layout extracts the layout from a key event.
//
// The function returns the following values:
//
//    - guint: layout of event.
//
func (event *KeyEvent) Layout() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "KeyEvent").InvokeMethod("get_layout", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Level extracts the shift level from a key event.
//
// The function returns the following values:
//
//    - guint: shift level of event.
//
func (event *KeyEvent) Level() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "KeyEvent").InvokeMethod("get_level", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Match gets a keyval and modifier combination that will match the event.
//
// See gdk.KeyEvent.Matches().
//
// The function returns the following values:
//
//    - keyval: return location for a keyval.
//    - modifiers: return location for modifiers.
//    - ok: TRUE on success.
//
func (event *KeyEvent) Match() (uint32, ModifierType, bool) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "KeyEvent").InvokeMethod("get_match", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _keyval uint32          // out
	var _modifiers ModifierType // out
	var _ok bool                // out

	_keyval = *(*uint32)(unsafe.Pointer(_outs[0]))
	_modifiers = *(*ModifierType)(unsafe.Pointer(_outs[1]))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _keyval, _modifiers, _ok
}

// IsModifier extracts whether the key event is for a modifier key.
//
// The function returns the following values:
//
//    - ok: TRUE if the event is for a modifier key.
//
func (event *KeyEvent) IsModifier() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "KeyEvent").InvokeMethod("is_modifier", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// MotionEvent: event related to a pointer or touch device motion.
type MotionEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*MotionEvent)(nil)
)

func wrapMotionEvent(obj *coreglib.Object) *MotionEvent {
	return &MotionEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalMotionEvent(p uintptr) (interface{}, error) {
	return wrapMotionEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// PadEvent: event related to a pad-based device.
type PadEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*PadEvent)(nil)
)

func wrapPadEvent(obj *coreglib.Object) *PadEvent {
	return &PadEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalPadEvent(p uintptr) (interface{}, error) {
	return wrapPadEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AxisValue extracts the information from a pad strip or ring event.
//
// The function returns the following values:
//
//    - index: return location for the axis index.
//    - value: return location for the axis value.
//
func (event *PadEvent) AxisValue() (uint32, float64) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	girepository.MustFind("Gdk", "PadEvent").InvokeMethod("get_axis_value", _args[:], _outs[:])

	runtime.KeepAlive(event)

	var _index uint32  // out
	var _value float64 // out

	_index = *(*uint32)(unsafe.Pointer(_outs[0]))
	_value = *(*float64)(unsafe.Pointer(_outs[1]))

	return _index, _value
}

// Button extracts information about the pressed button from a pad event.
//
// The function returns the following values:
//
//    - guint: button of event.
//
func (event *PadEvent) Button() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "PadEvent").InvokeMethod("get_button", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// GroupMode extracts group and mode information from a pad event.
//
// The function returns the following values:
//
//    - group: return location for the group.
//    - mode: return location for the mode.
//
func (event *PadEvent) GroupMode() (group, mode uint32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	girepository.MustFind("Gdk", "PadEvent").InvokeMethod("get_group_mode", _args[:], _outs[:])

	runtime.KeepAlive(event)

	var _group uint32 // out
	var _mode uint32  // out

	_group = *(*uint32)(unsafe.Pointer(_outs[0]))
	_mode = *(*uint32)(unsafe.Pointer(_outs[1]))

	return _group, _mode
}

// ProximityEvent: event related to the proximity of a tool to a device.
type ProximityEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*ProximityEvent)(nil)
)

func wrapProximityEvent(obj *coreglib.Object) *ProximityEvent {
	return &ProximityEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalProximityEvent(p uintptr) (interface{}, error) {
	return wrapProximityEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ScrollEvent: event related to a scrolling motion.
type ScrollEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*ScrollEvent)(nil)
)

func wrapScrollEvent(obj *coreglib.Object) *ScrollEvent {
	return &ScrollEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalScrollEvent(p uintptr) (interface{}, error) {
	return wrapScrollEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Deltas extracts the scroll deltas of a scroll event.
//
// The deltas will be zero unless the scroll direction is GDK_SCROLL_SMOOTH.
//
// The function returns the following values:
//
//    - deltaX: return location for x scroll delta.
//    - deltaY: return location for y scroll delta.
//
func (event *ScrollEvent) Deltas() (deltaX, deltaY float64) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	girepository.MustFind("Gdk", "ScrollEvent").InvokeMethod("get_deltas", _args[:], _outs[:])

	runtime.KeepAlive(event)

	var _deltaX float64 // out
	var _deltaY float64 // out

	_deltaX = *(*float64)(unsafe.Pointer(_outs[0]))
	_deltaY = *(*float64)(unsafe.Pointer(_outs[1]))

	return _deltaX, _deltaY
}

// IsStop: check whether a scroll event is a stop scroll event.
//
// Scroll sequences with smooth scroll information may provide a stop scroll
// event once the interaction with the device finishes, e.g. by lifting a
// finger. This stop scroll event is the signal that a widget may trigger
// kinetic scrolling based on the current velocity.
//
// Stop scroll events always have a delta of 0/0.
//
// The function returns the following values:
//
//    - ok: TRUE if the event is a scroll stop event.
//
func (event *ScrollEvent) IsStop() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "ScrollEvent").InvokeMethod("is_stop", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// TouchEvent: event related to a touch-based device.
type TouchEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*TouchEvent)(nil)
)

func wrapTouchEvent(obj *coreglib.Object) *TouchEvent {
	return &TouchEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalTouchEvent(p uintptr) (interface{}, error) {
	return wrapTouchEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// EmulatingPointer extracts whether a touch event is emulating a pointer event.
//
// The function returns the following values:
//
//    - ok: TRUE if event is emulating.
//
func (event *TouchEvent) EmulatingPointer() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "TouchEvent").InvokeMethod("get_emulating_pointer", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// TouchpadEvent: event related to a gesture on a touchpad device.
//
// Unlike touchscreens, where the windowing system sends basic sequences of
// begin, update, end events, and leaves gesture recognition to the clients,
// touchpad gestures are typically processed by the system, resulting in these
// events.
type TouchpadEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*TouchpadEvent)(nil)
)

func wrapTouchpadEvent(obj *coreglib.Object) *TouchpadEvent {
	return &TouchpadEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalTouchpadEvent(p uintptr) (interface{}, error) {
	return wrapTouchpadEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Deltas extracts delta information from a touchpad event.
//
// The function returns the following values:
//
//    - dx: return location for x.
//    - dy: return location for y.
//
func (event *TouchpadEvent) Deltas() (dx, dy float64) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	girepository.MustFind("Gdk", "TouchpadEvent").InvokeMethod("get_deltas", _args[:], _outs[:])

	runtime.KeepAlive(event)

	var _dx float64 // out
	var _dy float64 // out

	_dx = *(*float64)(unsafe.Pointer(_outs[0]))
	_dy = *(*float64)(unsafe.Pointer(_outs[1]))

	return _dx, _dy
}

// NFingers extracts the number of fingers from a touchpad event.
//
// The function returns the following values:
//
//    - guint: number of fingers for event.
//
func (event *TouchpadEvent) NFingers() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "TouchpadEvent").InvokeMethod("get_n_fingers", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// PinchAngleDelta extracts the angle delta from a touchpad pinch event.
//
// The function returns the following values:
//
//    - gdouble: angle delta of event.
//
func (event *TouchpadEvent) PinchAngleDelta() float64 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "TouchpadEvent").InvokeMethod("get_pinch_angle_delta", _args[:], nil)
	_cret = *(*C.double)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _gdouble float64 // out

	_gdouble = float64(*(*C.double)(unsafe.Pointer(&_cret)))

	return _gdouble
}

// PinchScale extracts the scale from a touchpad pinch event.
//
// The function returns the following values:
//
//    - gdouble: scale of event.
//
func (event *TouchpadEvent) PinchScale() float64 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_gret := girepository.MustFind("Gdk", "TouchpadEvent").InvokeMethod("get_pinch_scale", _args[:], nil)
	_cret = *(*C.double)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(event)

	var _gdouble float64 // out

	_gdouble = float64(*(*C.double)(unsafe.Pointer(&_cret)))

	return _gdouble
}

// EventSequence: GdkEventSequence is an opaque type representing a sequence of
// related touch events.
//
// An instance of this type is always passed by reference.
type EventSequence struct {
	*eventSequence
}

// eventSequence is the struct that's finalized.
type eventSequence struct {
	native unsafe.Pointer
}

func marshalEventSequence(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &EventSequence{&eventSequence{(unsafe.Pointer)(b)}}, nil
}
