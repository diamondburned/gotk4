// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/glib"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.g_bus_type_get_type()), F: marshalBusType},
		{T: externglib.Type(C.g_converter_result_get_type()), F: marshalConverterResult},
		{T: externglib.Type(C.g_credentials_type_get_type()), F: marshalCredentialsType},
		{T: externglib.Type(C.g_dbus_error_get_type()), F: marshalDBusError},
		{T: externglib.Type(C.g_dbus_message_byte_order_get_type()), F: marshalDBusMessageByteOrder},
		{T: externglib.Type(C.g_dbus_message_header_field_get_type()), F: marshalDBusMessageHeaderField},
		{T: externglib.Type(C.g_dbus_message_type_get_type()), F: marshalDBusMessageType},
		{T: externglib.Type(C.g_data_stream_byte_order_get_type()), F: marshalDataStreamByteOrder},
		{T: externglib.Type(C.g_data_stream_newline_type_get_type()), F: marshalDataStreamNewlineType},
		{T: externglib.Type(C.g_drive_start_stop_type_get_type()), F: marshalDriveStartStopType},
		{T: externglib.Type(C.g_emblem_origin_get_type()), F: marshalEmblemOrigin},
		{T: externglib.Type(C.g_file_attribute_status_get_type()), F: marshalFileAttributeStatus},
		{T: externglib.Type(C.g_file_attribute_type_get_type()), F: marshalFileAttributeType},
		{T: externglib.Type(C.g_file_monitor_event_get_type()), F: marshalFileMonitorEvent},
		{T: externglib.Type(C.g_file_type_get_type()), F: marshalFileType},
		{T: externglib.Type(C.g_filesystem_preview_type_get_type()), F: marshalFilesystemPreviewType},
		{T: externglib.Type(C.g_io_error_enum_get_type()), F: marshalIOErrorEnum},
		{T: externglib.Type(C.g_io_module_scope_flags_get_type()), F: marshalIOModuleScopeFlags},
		{T: externglib.Type(C.g_memory_monitor_warning_level_get_type()), F: marshalMemoryMonitorWarningLevel},
		{T: externglib.Type(C.g_mount_operation_result_get_type()), F: marshalMountOperationResult},
		{T: externglib.Type(C.g_network_connectivity_get_type()), F: marshalNetworkConnectivity},
		{T: externglib.Type(C.g_notification_priority_get_type()), F: marshalNotificationPriority},
		{T: externglib.Type(C.g_password_save_get_type()), F: marshalPasswordSave},
		{T: externglib.Type(C.g_pollable_return_get_type()), F: marshalPollableReturn},
		{T: externglib.Type(C.g_resolver_error_get_type()), F: marshalResolverError},
		{T: externglib.Type(C.g_resolver_record_type_get_type()), F: marshalResolverRecordType},
		{T: externglib.Type(C.g_resource_error_get_type()), F: marshalResourceError},
		{T: externglib.Type(C.g_socket_client_event_get_type()), F: marshalSocketClientEvent},
		{T: externglib.Type(C.g_socket_family_get_type()), F: marshalSocketFamily},
		{T: externglib.Type(C.g_socket_listener_event_get_type()), F: marshalSocketListenerEvent},
		{T: externglib.Type(C.g_socket_protocol_get_type()), F: marshalSocketProtocol},
		{T: externglib.Type(C.g_socket_type_get_type()), F: marshalSocketType},
		{T: externglib.Type(C.g_tls_authentication_mode_get_type()), F: marshalTlsAuthenticationMode},
		{T: externglib.Type(C.g_tls_certificate_request_flags_get_type()), F: marshalTlsCertificateRequestFlags},
		{T: externglib.Type(C.g_tls_channel_binding_error_get_type()), F: marshalTlsChannelBindingError},
		{T: externglib.Type(C.g_tls_channel_binding_type_get_type()), F: marshalTlsChannelBindingType},
		{T: externglib.Type(C.g_tls_database_lookup_flags_get_type()), F: marshalTlsDatabaseLookupFlags},
		{T: externglib.Type(C.g_tls_error_get_type()), F: marshalTlsError},
		{T: externglib.Type(C.g_tls_interaction_result_get_type()), F: marshalTlsInteractionResult},
		{T: externglib.Type(C.g_tls_rehandshake_mode_get_type()), F: marshalTlsRehandshakeMode},
		{T: externglib.Type(C.g_unix_socket_address_type_get_type()), F: marshalUnixSocketAddressType},
		{T: externglib.Type(C.g_zlib_compressor_format_get_type()), F: marshalZlibCompressorFormat},

		// Records
		// Skipped ActionEntry.
		// Skipped ActionGroupInterface.
		// Skipped ActionInterface.
		// Skipped ActionMapInterface.
		// Skipped AppInfoIface.
		// Skipped AppLaunchContextClass.
		// Skipped AppLaunchContextPrivate.
		// Skipped ApplicationClass.
		// Skipped ApplicationCommandLineClass.
		// Skipped ApplicationCommandLinePrivate.
		// Skipped ApplicationPrivate.
		// Skipped AsyncInitableIface.
		// Skipped AsyncResultIface.
		// Skipped BufferedInputStreamClass.
		// Skipped BufferedInputStreamPrivate.
		// Skipped BufferedOutputStreamClass.
		// Skipped BufferedOutputStreamPrivate.
		// Skipped CancellableClass.
		// Skipped CancellablePrivate.
		// Skipped CharsetConverterClass.
		// Skipped ConverterIface.
		// Skipped ConverterInputStreamClass.
		// Skipped ConverterInputStreamPrivate.
		// Skipped ConverterOutputStreamClass.
		// Skipped ConverterOutputStreamPrivate.
		// Skipped CredentialsClass.
		{T: externglib.Type(C.g_dbus_annotation_info_get_type()), F: marshalDBusAnnotationInfo},
		{T: externglib.Type(C.g_dbus_arg_info_get_type()), F: marshalDBusArgInfo},
		// Skipped DBusErrorEntry.
		// Skipped DBusInterfaceIface.
		{T: externglib.Type(C.g_dbus_interface_info_get_type()), F: marshalDBusInterfaceInfo},
		// Skipped DBusInterfaceSkeletonClass.
		// Skipped DBusInterfaceSkeletonPrivate.
		// Skipped DBusInterfaceVTable.
		{T: externglib.Type(C.g_dbus_method_info_get_type()), F: marshalDBusMethodInfo},
		{T: externglib.Type(C.g_dbus_node_info_get_type()), F: marshalDBusNodeInfo},
		// Skipped DBusObjectIface.
		// Skipped DBusObjectManagerClientClass.
		// Skipped DBusObjectManagerClientPrivate.
		// Skipped DBusObjectManagerIface.
		// Skipped DBusObjectManagerServerClass.
		// Skipped DBusObjectManagerServerPrivate.
		// Skipped DBusObjectProxyClass.
		// Skipped DBusObjectProxyPrivate.
		// Skipped DBusObjectSkeletonClass.
		// Skipped DBusObjectSkeletonPrivate.
		{T: externglib.Type(C.g_dbus_property_info_get_type()), F: marshalDBusPropertyInfo},
		// Skipped DBusProxyClass.
		// Skipped DBusProxyPrivate.
		{T: externglib.Type(C.g_dbus_signal_info_get_type()), F: marshalDBusSignalInfo},
		// Skipped DBusSubtreeVTable.
		// Skipped DataInputStreamClass.
		// Skipped DataInputStreamPrivate.
		// Skipped DataOutputStreamClass.
		// Skipped DataOutputStreamPrivate.
		// Skipped DatagramBasedInterface.
		// Skipped DesktopAppInfoClass.
		// Skipped DesktopAppInfoLookupIface.
		// Skipped DriveIface.
		// Skipped DtlsClientConnectionInterface.
		// Skipped DtlsConnectionInterface.
		// Skipped DtlsServerConnectionInterface.
		// Skipped EmblemClass.
		// Skipped EmblemedIconClass.
		// Skipped EmblemedIconPrivate.
		// Skipped FileAttributeInfo.
		{T: externglib.Type(C.g_file_attribute_info_list_get_type()), F: marshalFileAttributeInfoList},
		{T: externglib.Type(C.g_file_attribute_matcher_get_type()), F: marshalFileAttributeMatcher},
		// Skipped FileDescriptorBasedIface.
		// Skipped FileEnumeratorClass.
		// Skipped FileEnumeratorPrivate.
		// Skipped FileIOStreamClass.
		// Skipped FileIOStreamPrivate.
		// Skipped FileIconClass.
		// Skipped FileIface.
		// Skipped FileInfoClass.
		// Skipped FileInputStreamClass.
		// Skipped FileInputStreamPrivate.
		// Skipped FileMonitorClass.
		// Skipped FileMonitorPrivate.
		// Skipped FileOutputStreamClass.
		// Skipped FileOutputStreamPrivate.
		// Skipped FilenameCompleterClass.
		// Skipped FilterInputStreamClass.
		// Skipped FilterOutputStreamClass.
		// Skipped IOExtension.
		// Skipped IOExtensionPoint.
		// Skipped IOModuleClass.
		// Skipped IOModuleScope.
		// Skipped IOSchedulerJob.
		// Skipped IOStreamAdapter.
		// Skipped IOStreamClass.
		// Skipped IOStreamPrivate.
		// Skipped IconIface.
		// Skipped InetAddressClass.
		// Skipped InetAddressMaskClass.
		// Skipped InetAddressMaskPrivate.
		// Skipped InetAddressPrivate.
		// Skipped InetSocketAddressClass.
		// Skipped InetSocketAddressPrivate.
		// Skipped InitableIface.
		// Skipped InputMessage.
		// Skipped InputStreamClass.
		// Skipped InputStreamPrivate.
		// Skipped InputVector.
		// Skipped ListModelInterface.
		// Skipped ListStoreClass.
		// Skipped LoadableIconIface.
		// Skipped MemoryInputStreamClass.
		// Skipped MemoryInputStreamPrivate.
		// Skipped MemoryMonitorInterface.
		// Skipped MemoryOutputStreamClass.
		// Skipped MemoryOutputStreamPrivate.
		// Skipped MenuAttributeIterClass.
		// Skipped MenuAttributeIterPrivate.
		// Skipped MenuLinkIterClass.
		// Skipped MenuLinkIterPrivate.
		// Skipped MenuModelClass.
		// Skipped MenuModelPrivate.
		// Skipped MountIface.
		// Skipped MountOperationClass.
		// Skipped MountOperationPrivate.
		// Skipped NativeSocketAddressClass.
		// Skipped NativeSocketAddressPrivate.
		// Skipped NativeVolumeMonitorClass.
		// Skipped NetworkAddressClass.
		// Skipped NetworkAddressPrivate.
		// Skipped NetworkMonitorInterface.
		// Skipped NetworkServiceClass.
		// Skipped NetworkServicePrivate.
		// Skipped OutputMessage.
		// Skipped OutputStreamClass.
		// Skipped OutputStreamPrivate.
		// Skipped OutputVector.
		// Skipped PermissionClass.
		// Skipped PermissionPrivate.
		// Skipped PollableInputStreamInterface.
		// Skipped PollableOutputStreamInterface.
		// Skipped ProxyAddressClass.
		// Skipped ProxyAddressEnumeratorClass.
		// Skipped ProxyAddressEnumeratorPrivate.
		// Skipped ProxyAddressPrivate.
		// Skipped ProxyInterface.
		// Skipped ProxyResolverInterface.
		// Skipped RemoteActionGroupInterface.
		// Skipped ResolverClass.
		// Skipped ResolverPrivate.
		{T: externglib.Type(C.g_resource_get_type()), F: marshalResource},
		// Skipped SeekableIface.
		// Skipped SettingsBackendClass.
		// Skipped SettingsBackendPrivate.
		// Skipped SettingsClass.
		// Skipped SettingsPrivate.
		{T: externglib.Type(C.g_settings_schema_get_type()), F: marshalSettingsSchema},
		{T: externglib.Type(C.g_settings_schema_key_get_type()), F: marshalSettingsSchemaKey},
		{T: externglib.Type(C.g_settings_schema_source_get_type()), F: marshalSettingsSchemaSource},
		// Skipped SimpleActionGroupClass.
		// Skipped SimpleActionGroupPrivate.
		// Skipped SimpleAsyncResultClass.
		// Skipped SimpleProxyResolverClass.
		// Skipped SimpleProxyResolverPrivate.
		// Skipped SocketAddressClass.
		// Skipped SocketAddressEnumeratorClass.
		// Skipped SocketClass.
		// Skipped SocketClientClass.
		// Skipped SocketClientPrivate.
		// Skipped SocketConnectableIface.
		// Skipped SocketConnectionClass.
		// Skipped SocketConnectionPrivate.
		// Skipped SocketControlMessageClass.
		// Skipped SocketControlMessagePrivate.
		// Skipped SocketListenerClass.
		// Skipped SocketListenerPrivate.
		// Skipped SocketPrivate.
		// Skipped SocketServiceClass.
		// Skipped SocketServicePrivate.
		{T: externglib.Type(C.g_srv_target_get_type()), F: marshalSrvTarget},
		// Skipped StaticResource.
		// Skipped TaskClass.
		// Skipped TcpConnectionClass.
		// Skipped TcpConnectionPrivate.
		// Skipped TcpWrapperConnectionClass.
		// Skipped TcpWrapperConnectionPrivate.
		// Skipped ThemedIconClass.
		// Skipped ThreadedSocketServiceClass.
		// Skipped ThreadedSocketServicePrivate.
		// Skipped TlsBackendInterface.
		// Skipped TlsCertificateClass.
		// Skipped TlsCertificatePrivate.
		// Skipped TlsClientConnectionInterface.
		// Skipped TlsConnectionClass.
		// Skipped TlsConnectionPrivate.
		// Skipped TlsDatabaseClass.
		// Skipped TlsDatabasePrivate.
		// Skipped TlsFileDatabaseInterface.
		// Skipped TlsInteractionClass.
		// Skipped TlsInteractionPrivate.
		// Skipped TlsPasswordClass.
		// Skipped TlsPasswordPrivate.
		// Skipped TlsServerConnectionInterface.
		// Skipped UnixConnectionClass.
		// Skipped UnixConnectionPrivate.
		// Skipped UnixCredentialsMessageClass.
		// Skipped UnixCredentialsMessagePrivate.
		// Skipped UnixFDListClass.
		// Skipped UnixFDListPrivate.
		// Skipped UnixFDMessageClass.
		// Skipped UnixFDMessagePrivate.
		// Skipped UnixInputStreamClass.
		// Skipped UnixInputStreamPrivate.
		{T: externglib.Type(C.g_unix_mount_entry_get_type()), F: marshalUnixMountEntry},
		// Skipped UnixMountMonitorClass.
		{T: externglib.Type(C.g_unix_mount_point_get_type()), F: marshalUnixMountPoint},
		// Skipped UnixOutputStreamClass.
		// Skipped UnixOutputStreamPrivate.
		// Skipped UnixSocketAddressClass.
		// Skipped UnixSocketAddressPrivate.
		// Skipped VfsClass.
		// Skipped VolumeIface.
		// Skipped VolumeMonitorClass.
		// Skipped ZlibCompressorClass.
		// Skipped ZlibDecompressorClass.

		// Classes
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
		{T: externglib.Type(C.g_app_launch_context_get_type()), F: marshalAppLaunchContext},
		{T: externglib.Type(C.g_application_get_type()), F: marshalApplication},
		{T: externglib.Type(C.g_application_command_line_get_type()), F: marshalApplicationCommandLine},
		{T: externglib.Type(C.g_buffered_input_stream_get_type()), F: marshalBufferedInputStream},
		{T: externglib.Type(C.g_buffered_output_stream_get_type()), F: marshalBufferedOutputStream},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIcon},
		{T: externglib.Type(C.g_cancellable_get_type()), F: marshalCancellable},
		{T: externglib.Type(C.g_charset_converter_get_type()), F: marshalCharsetConverter},
		{T: externglib.Type(C.g_converter_input_stream_get_type()), F: marshalConverterInputStream},
		{T: externglib.Type(C.g_converter_output_stream_get_type()), F: marshalConverterOutputStream},
		{T: externglib.Type(C.g_credentials_get_type()), F: marshalCredentials},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
		{T: externglib.Type(C.g_dbus_interface_skeleton_get_type()), F: marshalDBusInterfaceSkeleton},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
		{T: externglib.Type(C.g_dbus_object_manager_client_get_type()), F: marshalDBusObjectManagerClient},
		{T: externglib.Type(C.g_dbus_object_manager_server_get_type()), F: marshalDBusObjectManagerServer},
		{T: externglib.Type(C.g_dbus_object_proxy_get_type()), F: marshalDBusObjectProxy},
		{T: externglib.Type(C.g_dbus_object_skeleton_get_type()), F: marshalDBusObjectSkeleton},
		{T: externglib.Type(C.g_dbus_proxy_get_type()), F: marshalDBusProxy},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
		{T: externglib.Type(C.g_data_input_stream_get_type()), F: marshalDataInputStream},
		{T: externglib.Type(C.g_data_output_stream_get_type()), F: marshalDataOutputStream},
		{T: externglib.Type(C.g_desktop_app_info_get_type()), F: marshalDesktopAppInfo},
		{T: externglib.Type(C.g_emblem_get_type()), F: marshalEmblem},
		{T: externglib.Type(C.g_emblemed_icon_get_type()), F: marshalEmblemedIcon},
		{T: externglib.Type(C.g_file_enumerator_get_type()), F: marshalFileEnumerator},
		{T: externglib.Type(C.g_file_io_stream_get_type()), F: marshalFileIOStream},
		{T: externglib.Type(C.g_file_icon_get_type()), F: marshalFileIcon},
		{T: externglib.Type(C.g_file_info_get_type()), F: marshalFileInfo},
		{T: externglib.Type(C.g_file_input_stream_get_type()), F: marshalFileInputStream},
		{T: externglib.Type(C.g_file_monitor_get_type()), F: marshalFileMonitor},
		{T: externglib.Type(C.g_file_output_stream_get_type()), F: marshalFileOutputStream},
		{T: externglib.Type(C.g_filename_completer_get_type()), F: marshalFilenameCompleter},
		{T: externglib.Type(C.g_filter_input_stream_get_type()), F: marshalFilterInputStream},
		{T: externglib.Type(C.g_filter_output_stream_get_type()), F: marshalFilterOutputStream},
		// Skipped IOModule.
		{T: externglib.Type(C.g_io_stream_get_type()), F: marshalIOStream},
		{T: externglib.Type(C.g_inet_address_get_type()), F: marshalInetAddress},
		{T: externglib.Type(C.g_inet_address_mask_get_type()), F: marshalInetAddressMask},
		{T: externglib.Type(C.g_inet_socket_address_get_type()), F: marshalInetSocketAddress},
		{T: externglib.Type(C.g_input_stream_get_type()), F: marshalInputStream},
		{T: externglib.Type(C.g_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.g_memory_input_stream_get_type()), F: marshalMemoryInputStream},
		{T: externglib.Type(C.g_memory_output_stream_get_type()), F: marshalMemoryOutputStream},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.g_menu_attribute_iter_get_type()), F: marshalMenuAttributeIter},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.g_menu_link_iter_get_type()), F: marshalMenuLinkIter},
		{T: externglib.Type(C.g_menu_model_get_type()), F: marshalMenuModel},
		{T: externglib.Type(C.g_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.g_native_socket_address_get_type()), F: marshalNativeSocketAddress},
		{T: externglib.Type(C.g_native_volume_monitor_get_type()), F: marshalNativeVolumeMonitor},
		{T: externglib.Type(C.g_network_address_get_type()), F: marshalNetworkAddress},
		{T: externglib.Type(C.g_network_service_get_type()), F: marshalNetworkService},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
		{T: externglib.Type(C.g_output_stream_get_type()), F: marshalOutputStream},
		{T: externglib.Type(C.g_permission_get_type()), F: marshalPermission},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
		{T: externglib.Type(C.g_proxy_address_get_type()), F: marshalProxyAddress},
		{T: externglib.Type(C.g_proxy_address_enumerator_get_type()), F: marshalProxyAddressEnumerator},
		{T: externglib.Type(C.g_resolver_get_type()), F: marshalResolver},
		{T: externglib.Type(C.g_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.g_settings_backend_get_type()), F: marshalSettingsBackend},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
		{T: externglib.Type(C.g_simple_action_group_get_type()), F: marshalSimpleActionGroup},
		{T: externglib.Type(C.g_simple_async_result_get_type()), F: marshalSimpleAsyncResult},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
		{T: externglib.Type(C.g_simple_proxy_resolver_get_type()), F: marshalSimpleProxyResolver},
		{T: externglib.Type(C.g_socket_get_type()), F: marshalSocket},
		{T: externglib.Type(C.g_socket_address_get_type()), F: marshalSocketAddress},
		{T: externglib.Type(C.g_socket_address_enumerator_get_type()), F: marshalSocketAddressEnumerator},
		{T: externglib.Type(C.g_socket_client_get_type()), F: marshalSocketClient},
		{T: externglib.Type(C.g_socket_connection_get_type()), F: marshalSocketConnection},
		{T: externglib.Type(C.g_socket_control_message_get_type()), F: marshalSocketControlMessage},
		{T: externglib.Type(C.g_socket_listener_get_type()), F: marshalSocketListener},
		{T: externglib.Type(C.g_socket_service_get_type()), F: marshalSocketService},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
		{T: externglib.Type(C.g_task_get_type()), F: marshalTask},
		{T: externglib.Type(C.g_tcp_connection_get_type()), F: marshalTcpConnection},
		{T: externglib.Type(C.g_tcp_wrapper_connection_get_type()), F: marshalTcpWrapperConnection},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
		{T: externglib.Type(C.g_themed_icon_get_type()), F: marshalThemedIcon},
		{T: externglib.Type(C.g_threaded_socket_service_get_type()), F: marshalThreadedSocketService},
		{T: externglib.Type(C.g_tls_certificate_get_type()), F: marshalTlsCertificate},
		{T: externglib.Type(C.g_tls_connection_get_type()), F: marshalTlsConnection},
		{T: externglib.Type(C.g_tls_database_get_type()), F: marshalTlsDatabase},
		{T: externglib.Type(C.g_tls_interaction_get_type()), F: marshalTlsInteraction},
		{T: externglib.Type(C.g_tls_password_get_type()), F: marshalTlsPassword},
		{T: externglib.Type(C.g_unix_connection_get_type()), F: marshalUnixConnection},
		{T: externglib.Type(C.g_unix_credentials_message_get_type()), F: marshalUnixCredentialsMessage},
		{T: externglib.Type(C.g_unix_fd_list_get_type()), F: marshalUnixFDList},
		{T: externglib.Type(C.g_unix_fd_message_get_type()), F: marshalUnixFDMessage},
		{T: externglib.Type(C.g_unix_input_stream_get_type()), F: marshalUnixInputStream},
		{T: externglib.Type(C.g_unix_mount_monitor_get_type()), F: marshalUnixMountMonitor},
		{T: externglib.Type(C.g_unix_output_stream_get_type()), F: marshalUnixOutputStream},
		{T: externglib.Type(C.g_unix_socket_address_get_type()), F: marshalUnixSocketAddress},
		{T: externglib.Type(C.g_vfs_get_type()), F: marshalVfs},
		{T: externglib.Type(C.g_volume_monitor_get_type()), F: marshalVolumeMonitor},
		{T: externglib.Type(C.g_zlib_compressor_get_type()), F: marshalZlibCompressor},
		{T: externglib.Type(C.g_zlib_decompressor_get_type()), F: marshalZlibDecompressor},
	})
}

// BusType: an enumeration for well-known message buses.
type BusType int

const (
	// BusTypeStarter: an alias for the message bus that activated the process,
	// if any.
	BusTypeStarter BusType = -1
	// BusTypeNone: not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem: the system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession: the login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p uintptr) (interface{}, error) {
	return BusType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterResult: results returned from g_converter_convert().
type ConverterResult int

const (
	// ConverterResultError: there was an error during conversion.
	ConverterResultError ConverterResult = 0
	// ConverterResultConverted: some data was consumed or produced
	ConverterResultConverted ConverterResult = 1
	// ConverterResultFinished: the conversion is finished
	ConverterResultFinished ConverterResult = 2
	// ConverterResultFlushed: flushing is finished
	ConverterResultFlushed ConverterResult = 3
)

func marshalConverterResult(p uintptr) (interface{}, error) {
	return ConverterResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CredentialsType: enumeration describing different kinds of native credential
// types.
type CredentialsType int

const (
	// CredentialsTypeInvalid: indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = 0
	// CredentialsTypeLinuxUcred: the native credentials type is a `struct
	// ucred`.
	CredentialsTypeLinuxUcred CredentialsType = 1
	// CredentialsTypeFreebsdCmsgcred: the native credentials type is a `struct
	// cmsgcred`.
	CredentialsTypeFreebsdCmsgcred CredentialsType = 2
	// CredentialsTypeOpenbsdSockpeercred: the native credentials type is a
	// `struct sockpeercred`. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred CredentialsType = 3
	// CredentialsTypeSolarisUcred: the native credentials type is a `ucred_t`.
	// Added in 2.40.
	CredentialsTypeSolarisUcred CredentialsType = 4
	// CredentialsTypeNetbsdUnpcbid: the native credentials type is a `struct
	// unpcbid`. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid CredentialsType = 5
	// CredentialsTypeAppleXucred: the native credentials type is a `struct
	// xucred`. Added in 2.66.
	CredentialsTypeAppleXucred CredentialsType = 6
)

func marshalCredentialsType(p uintptr) (interface{}, error) {
	return CredentialsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusError: error codes for the G_DBUS_ERROR error domain.
type DBusError int

const (
	// DBusErrorFailed: a generic error; "something went wrong" - see the error
	// message for more.
	DBusErrorFailed DBusError = 0
	// DBusErrorNoMemory: there was not enough memory to complete an operation.
	DBusErrorNoMemory DBusError = 1
	// DBusErrorServiceUnknown: the bus doesn't know how to launch a service to
	// supply the bus name you wanted.
	DBusErrorServiceUnknown DBusError = 2
	// DBusErrorNameHasNoOwner: the bus name you referenced doesn't exist (i.e.
	// no application owns it).
	DBusErrorNameHasNoOwner DBusError = 3
	// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
	DBusErrorNoReply DBusError = 4
	// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
	DBusErrorIOError DBusError = 5
	// DBusErrorBadAddress: a D-Bus bus address was malformed.
	DBusErrorBadAddress DBusError = 6
	// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
	DBusErrorNotSupported DBusError = 7
	// DBusErrorLimitsExceeded: some limited resource is exhausted.
	DBusErrorLimitsExceeded DBusError = 8
	// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
	DBusErrorAccessDenied DBusError = 9
	// DBusErrorAuthFailed: authentication didn't work.
	DBusErrorAuthFailed DBusError = 10
	// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
	DBusErrorNoServer DBusError = 11
	// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimeout DBusError = 12
	// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
	DBusErrorNoNetwork DBusError = 13
	// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
	DBusErrorAddressInUse DBusError = 14
	// DBusErrorDisconnected: the connection is disconnected and you're trying
	// to use it.
	DBusErrorDisconnected DBusError = 15
	// DBusErrorInvalidArgs: invalid arguments passed to a method call.
	DBusErrorInvalidArgs DBusError = 16
	// DBusErrorFileNotFound: missing file.
	DBusErrorFileNotFound DBusError = 17
	// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
	DBusErrorFileExists DBusError = 18
	// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
	DBusErrorUnknownMethod DBusError = 19
	// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimedOut DBusError = 20
	// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
	DBusErrorMatchRuleNotFound DBusError = 21
	// DBusErrorMatchRuleInvalid: the match rule isn't syntactically valid.
	DBusErrorMatchRuleInvalid DBusError = 22
	// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
	DBusErrorSpawnExecFailed DBusError = 23
	// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
	DBusErrorSpawnForkFailed DBusError = 24
	// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
	DBusErrorSpawnChildExited DBusError = 25
	// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
	DBusErrorSpawnChildSignaled DBusError = 26
	// DBusErrorSpawnFailed: while starting a new process, something went wrong.
	DBusErrorSpawnFailed DBusError = 27
	// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
	DBusErrorSpawnSetupFailed DBusError = 28
	// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
	DBusErrorSpawnConfigInvalid DBusError = 29
	// DBusErrorSpawnServiceInvalid: bus name was not valid.
	DBusErrorSpawnServiceInvalid DBusError = 30
	// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
	DBusErrorSpawnServiceNotFound DBusError = 31
	// DBusErrorSpawnPermissionsInvalid: permissions are incorrect on the setuid
	// helper.
	DBusErrorSpawnPermissionsInvalid DBusError = 32
	// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
	DBusErrorSpawnFileInvalid DBusError = 33
	// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
	DBusErrorSpawnNoMemory DBusError = 34
	// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
	DBusErrorUnixProcessIDUnknown DBusError = 35
	// DBusErrorInvalidSignature: a type signature is not valid.
	DBusErrorInvalidSignature DBusError = 36
	// DBusErrorInvalidFileContent: a file contains invalid syntax or is
	// otherwise broken.
	DBusErrorInvalidFileContent DBusError = 37
	// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
	DBusErrorSelinuxSecurityContextUnknown DBusError = 38
	// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
	DBusErrorAdtAuditDataUnknown DBusError = 39
	// DBusErrorObjectPathInUse: there's already an object with the requested
	// object path.
	DBusErrorObjectPathInUse DBusError = 40
	// DBusErrorUnknownObject: object you invoked a method on isn't known. Since
	// 2.42
	DBusErrorUnknownObject DBusError = 41
	// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42
	DBusErrorUnknownInterface DBusError = 42
	// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42
	DBusErrorUnknownProperty DBusError = 43
	// DBusErrorPropertyReadOnly: property you tried to set is read-only. Since
	// 2.42
	DBusErrorPropertyReadOnly DBusError = 44
)

func marshalDBusError(p uintptr) (interface{}, error) {
	return DBusError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
type DBusMessageByteOrder int

const (
	// DBusMessageByteOrderBigEndian: the byte order is big endian.
	DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
	// DBusMessageByteOrderLittleEndian: the byte order is little endian.
	DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
)

func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
	return DBusMessageByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageHeaderField: header fields used in BusMessage.
type DBusMessageHeaderField int

const (
	// DBusMessageHeaderFieldInvalid: not a valid header field.
	DBusMessageHeaderFieldInvalid DBusMessageHeaderField = 0
	// DBusMessageHeaderFieldPath: the object path.
	DBusMessageHeaderFieldPath DBusMessageHeaderField = 1
	// DBusMessageHeaderFieldInterface: the interface name.
	DBusMessageHeaderFieldInterface DBusMessageHeaderField = 2
	// DBusMessageHeaderFieldMember: the method or signal name.
	DBusMessageHeaderFieldMember DBusMessageHeaderField = 3
	// DBusMessageHeaderFieldErrorName: the name of the error that occurred.
	DBusMessageHeaderFieldErrorName DBusMessageHeaderField = 4
	// DBusMessageHeaderFieldReplySerial: the serial number the message is a
	// reply to.
	DBusMessageHeaderFieldReplySerial DBusMessageHeaderField = 5
	// DBusMessageHeaderFieldDestination: the name the message is intended for.
	DBusMessageHeaderFieldDestination DBusMessageHeaderField = 6
	// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
	DBusMessageHeaderFieldSender DBusMessageHeaderField = 7
	// DBusMessageHeaderFieldSignature: the signature of the message body.
	DBusMessageHeaderFieldSignature DBusMessageHeaderField = 8
	// DBusMessageHeaderFieldNumUnixFds: the number of UNIX file descriptors
	// that accompany the message.
	DBusMessageHeaderFieldNumUnixFds DBusMessageHeaderField = 9
)

func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
	return DBusMessageHeaderField(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageType: message types used in BusMessage.
type DBusMessageType int

const (
	// DBusMessageTypeInvalid: message is of invalid type.
	DBusMessageTypeInvalid DBusMessageType = 0
	// DBusMessageTypeMethodCall: method call.
	DBusMessageTypeMethodCall DBusMessageType = 1
	// DBusMessageTypeMethodReturn: method reply.
	DBusMessageTypeMethodReturn DBusMessageType = 2
	// DBusMessageTypeError: error reply.
	DBusMessageTypeError DBusMessageType = 3
	// DBusMessageTypeSignal: signal emission.
	DBusMessageTypeSignal DBusMessageType = 4
)

func marshalDBusMessageType(p uintptr) (interface{}, error) {
	return DBusMessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamByteOrder is used to ensure proper endianness of streaming data
// sources across various machine architectures.
type DataStreamByteOrder int

const (
	// DataStreamByteOrderBigEndian: selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = 0
	// DataStreamByteOrderLittleEndian: selects Little Endian byte order.
	DataStreamByteOrderLittleEndian DataStreamByteOrder = 1
	// DataStreamByteOrderHostEndian: selects endianness based on host machine's
	// architecture.
	DataStreamByteOrderHostEndian DataStreamByteOrder = 2
)

func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
	return DataStreamByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamNewlineType is used when checking for or setting the line endings
// for a given file.
type DataStreamNewlineType int

const (
	// DataStreamNewlineTypeLf: selects "LF" line endings, common on most modern
	// UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = 0
	// DataStreamNewlineTypeCr: selects "CR" line endings.
	DataStreamNewlineTypeCr DataStreamNewlineType = 1
	// DataStreamNewlineTypeCrLf: selects "CR, LF" line ending, common on
	// Microsoft Windows.
	DataStreamNewlineTypeCrLf DataStreamNewlineType = 2
	// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
	DataStreamNewlineTypeAny DataStreamNewlineType = 3
)

func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
	return DataStreamNewlineType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
type DriveStartStopType int

const (
	// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = 0
	// DriveStartStopTypeShutdown: the stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
	DriveStartStopTypeShutdown DriveStartStopType = 1
	// DriveStartStopTypeNetwork: the start/stop methods are used for
	// connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork DriveStartStopType = 2
	// DriveStartStopTypeMultidisk: the start/stop methods will
	// assemble/disassemble a virtual drive from several physical drives.
	DriveStartStopTypeMultidisk DriveStartStopType = 3
	// DriveStartStopTypePassword: the start/stop methods will unlock/lock the
	// disk (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command)
	DriveStartStopTypePassword DriveStartStopType = 4
)

func marshalDriveStartStopType(p uintptr) (interface{}, error) {
	return DriveStartStopType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EmblemOrigin: GEmblemOrigin is used to add information about the origin of
// the emblem to #GEmblem.
type EmblemOrigin int

const (
	// EmblemOriginUnknown: emblem of unknown origin
	EmblemOriginUnknown EmblemOrigin = 0
	// EmblemOriginDevice: emblem adds device-specific information
	EmblemOriginDevice EmblemOrigin = 1
	// EmblemOriginLivemetadata: emblem depicts live metadata, such as
	// "readonly"
	EmblemOriginLivemetadata EmblemOrigin = 2
	// EmblemOriginTag: emblem comes from a user-defined tag, e.g. set by
	// nautilus (in the future)
	EmblemOriginTag EmblemOrigin = 3
)

func marshalEmblemOrigin(p uintptr) (interface{}, error) {
	return EmblemOrigin(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
type FileAttributeStatus int

const (
	// FileAttributeStatusUnset: attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = 0
	// FileAttributeStatusSet: attribute value is set.
	FileAttributeStatusSet FileAttributeStatus = 1
	// FileAttributeStatusErrorSetting: indicates an error in setting the value.
	FileAttributeStatusErrorSetting FileAttributeStatus = 2
)

func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
	return FileAttributeStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeType: the data types for file attributes.
type FileAttributeType int

const (
	// FileAttributeTypeInvalid: indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = 0
	// FileAttributeTypeString: a null terminated UTF8 string.
	FileAttributeTypeString FileAttributeType = 1
	// FileAttributeTypeByteString: a zero terminated string of non-zero bytes.
	FileAttributeTypeByteString FileAttributeType = 2
	// FileAttributeTypeBoolean: a boolean value.
	FileAttributeTypeBoolean FileAttributeType = 3
	// FileAttributeTypeUint32: an unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32 FileAttributeType = 4
	// FileAttributeTypeInt32: a signed 4-byte/32-bit integer.
	FileAttributeTypeInt32 FileAttributeType = 5
	// FileAttributeTypeUint64: an unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64 FileAttributeType = 6
	// FileAttributeTypeInt64: a signed 8-byte/64-bit integer.
	FileAttributeTypeInt64 FileAttributeType = 7
	// FileAttributeTypeObject: a #GObject.
	FileAttributeTypeObject FileAttributeType = 8
	// FileAttributeTypeStringv: a nil terminated char **. Since 2.22
	FileAttributeTypeStringv FileAttributeType = 9
)

func marshalFileAttributeType(p uintptr) (interface{}, error) {
	return FileAttributeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorEvent: specifies what type of event a monitor event is.
type FileMonitorEvent int

const (
	// FileMonitorEventChanged: a file changed.
	FileMonitorEventChanged FileMonitorEvent = 0
	// FileMonitorEventChangesDoneHint: a hint that this was probably the last
	// change in a set of changes.
	FileMonitorEventChangesDoneHint FileMonitorEvent = 1
	// FileMonitorEventDeleted: a file was deleted.
	FileMonitorEventDeleted FileMonitorEvent = 2
	// FileMonitorEventCreated: a file was created.
	FileMonitorEventCreated FileMonitorEvent = 3
	// FileMonitorEventAttributeChanged: a file attribute was changed.
	FileMonitorEventAttributeChanged FileMonitorEvent = 4
	// FileMonitorEventPreUnmount: the file location will soon be unmounted.
	FileMonitorEventPreUnmount FileMonitorEvent = 5
	// FileMonitorEventUnmounted: the file location was unmounted.
	FileMonitorEventUnmounted FileMonitorEvent = 6
	// FileMonitorEventMoved: the file was moved -- only sent if the
	// (deprecated) G_FILE_MONITOR_SEND_MOVED flag is set
	FileMonitorEventMoved FileMonitorEvent = 7
	// FileMonitorEventRenamed: the file was renamed within the current
	// directory -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set.
	// Since: 2.46.
	FileMonitorEventRenamed FileMonitorEvent = 8
	// FileMonitorEventMovedIn: the file was moved into the monitored directory
	// from another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
	FileMonitorEventMovedIn FileMonitorEvent = 9
	// FileMonitorEventMovedOut: the file was moved out of the monitored
	// directory to another location -- only sent if the
	// G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46
	FileMonitorEventMovedOut FileMonitorEvent = 10
)

func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
	return FileMonitorEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileType: indicates the file's on-disk type.
//
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type; use
// Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a file is
// a symlink or not. This is due to the fact that NTFS does not have a single
// filesystem object type for symbolic links - it has files that symlink to
// files, and directories that symlink to directories. Type enumeration cannot
// precisely represent this important distinction, which is why all Windows
// symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
type FileType int

const (
	// FileTypeUnknown: file's type is unknown.
	FileTypeUnknown FileType = 0
	// FileTypeRegular: file handle represents a regular file.
	FileTypeRegular FileType = 1
	// FileTypeDirectory: file handle represents a directory.
	FileTypeDirectory FileType = 2
	// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
	FileTypeSymbolicLink FileType = 3
	// FileTypeSpecial: file is a "special" file, such as a socket, fifo, block
	// device, or character device.
	FileTypeSpecial FileType = 4
	// FileTypeShortcut: file is a shortcut (Windows systems).
	FileTypeShortcut FileType = 5
	// FileTypeMountable: file is a mountable location.
	FileTypeMountable FileType = 6
)

func marshalFileType(p uintptr) (interface{}, error) {
	return FileType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilesystemPreviewType: indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType int

const (
	// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = 0
	// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
	FilesystemPreviewTypeIfLocal FilesystemPreviewType = 1
	// FilesystemPreviewTypeNever: never preview files.
	FilesystemPreviewTypeNever FilesystemPreviewType = 2
)

func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
	return FilesystemPreviewType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOErrorEnum: error codes returned by GIO functions.
//
// Note that this domain may be extended in future GLib releases. In general,
// new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before. You
// should therefore avoid writing code like |[<!-- language="C" --> if
// (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED)) { // Assume that
// this is EPRINTERONFIRE ... } ]| but should instead treat all unrecognized
// error codes the same as IO_ERROR_FAILED.
//
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
type IOErrorEnum int

const (
	// IOErrorEnumFailed: generic error condition for when an operation fails
	// and no more specific OErrorEnum value is defined.
	IOErrorEnumFailed IOErrorEnum = 0
	// IOErrorEnumNotFound: file not found.
	IOErrorEnumNotFound IOErrorEnum = 1
	// IOErrorEnumExists: file already exists.
	IOErrorEnumExists IOErrorEnum = 2
	// IOErrorEnumIsDirectory: file is a directory.
	IOErrorEnumIsDirectory IOErrorEnum = 3
	// IOErrorEnumNotDirectory: file is not a directory.
	IOErrorEnumNotDirectory IOErrorEnum = 4
	// IOErrorEnumNotEmpty: file is a directory that isn't empty.
	IOErrorEnumNotEmpty IOErrorEnum = 5
	// IOErrorEnumNotRegularFile: file is not a regular file.
	IOErrorEnumNotRegularFile IOErrorEnum = 6
	// IOErrorEnumNotSymbolicLink: file is not a symbolic link.
	IOErrorEnumNotSymbolicLink IOErrorEnum = 7
	// IOErrorEnumNotMountableFile: file cannot be mounted.
	IOErrorEnumNotMountableFile IOErrorEnum = 8
	// IOErrorEnumFilenameTooLong: filename is too many characters.
	IOErrorEnumFilenameTooLong IOErrorEnum = 9
	// IOErrorEnumInvalidFilename: filename is invalid or contains invalid
	// characters.
	IOErrorEnumInvalidFilename IOErrorEnum = 10
	// IOErrorEnumTooManyLinks: file contains too many symbolic links.
	IOErrorEnumTooManyLinks IOErrorEnum = 11
	// IOErrorEnumNoSpace: no space left on drive.
	IOErrorEnumNoSpace IOErrorEnum = 12
	// IOErrorEnumInvalidArgument: invalid argument.
	IOErrorEnumInvalidArgument IOErrorEnum = 13
	// IOErrorEnumPermissionDenied: permission denied.
	IOErrorEnumPermissionDenied IOErrorEnum = 14
	// IOErrorEnumNotSupported: operation (or one of its parameters) not
	// supported
	IOErrorEnumNotSupported IOErrorEnum = 15
	// IOErrorEnumNotMounted: file isn't mounted.
	IOErrorEnumNotMounted IOErrorEnum = 16
	// IOErrorEnumAlreadyMounted: file is already mounted.
	IOErrorEnumAlreadyMounted IOErrorEnum = 17
	// IOErrorEnumClosed: file was closed.
	IOErrorEnumClosed IOErrorEnum = 18
	// IOErrorEnumCancelled: operation was cancelled. See #GCancellable.
	IOErrorEnumCancelled IOErrorEnum = 19
	// IOErrorEnumPending: operations are still pending.
	IOErrorEnumPending IOErrorEnum = 20
	// IOErrorEnumReadOnly: file is read only.
	IOErrorEnumReadOnly IOErrorEnum = 21
	// IOErrorEnumCantCreateBackup: backup couldn't be created.
	IOErrorEnumCantCreateBackup IOErrorEnum = 22
	// IOErrorEnumWrongEtag: file's Entity Tag was incorrect.
	IOErrorEnumWrongEtag IOErrorEnum = 23
	// IOErrorEnumTimedOut: operation timed out.
	IOErrorEnumTimedOut IOErrorEnum = 24
	// IOErrorEnumWouldRecurse: operation would be recursive.
	IOErrorEnumWouldRecurse IOErrorEnum = 25
	// IOErrorEnumBusy: file is busy.
	IOErrorEnumBusy IOErrorEnum = 26
	// IOErrorEnumWouldBlock: operation would block.
	IOErrorEnumWouldBlock IOErrorEnum = 27
	// IOErrorEnumHostNotFound: host couldn't be found (remote operations).
	IOErrorEnumHostNotFound IOErrorEnum = 28
	// IOErrorEnumWouldMerge: operation would merge files.
	IOErrorEnumWouldMerge IOErrorEnum = 29
	// IOErrorEnumFailedHandled: operation failed and a helper program has
	// already interacted with the user. Do not display any error dialog.
	IOErrorEnumFailedHandled IOErrorEnum = 30
	// IOErrorEnumTooManyOpenFiles: the current process has too many files open
	// and can't open any more. Duplicate descriptors do count toward this
	// limit. Since 2.20
	IOErrorEnumTooManyOpenFiles IOErrorEnum = 31
	// IOErrorEnumNotInitialized: the object has not been initialized. Since
	// 2.22
	IOErrorEnumNotInitialized IOErrorEnum = 32
	// IOErrorEnumAddressInUse: the requested address is already in use. Since
	// 2.22
	IOErrorEnumAddressInUse IOErrorEnum = 33
	// IOErrorEnumPartialInput: need more input to finish operation. Since 2.24
	IOErrorEnumPartialInput IOErrorEnum = 34
	// IOErrorEnumInvalidData: the input data was invalid. Since 2.24
	IOErrorEnumInvalidData IOErrorEnum = 35
	// IOErrorEnumDbusError: a remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
	IOErrorEnumDbusError IOErrorEnum = 36
	// IOErrorEnumHostUnreachable: host unreachable. Since 2.26
	IOErrorEnumHostUnreachable IOErrorEnum = 37
	// IOErrorEnumNetworkUnreachable: network unreachable. Since 2.26
	IOErrorEnumNetworkUnreachable IOErrorEnum = 38
	// IOErrorEnumConnectionRefused: connection refused. Since 2.26
	IOErrorEnumConnectionRefused IOErrorEnum = 39
	// IOErrorEnumProxyFailed: connection to proxy server failed. Since 2.26
	IOErrorEnumProxyFailed IOErrorEnum = 40
	// IOErrorEnumProxyAuthFailed: proxy authentication failed. Since 2.26
	IOErrorEnumProxyAuthFailed IOErrorEnum = 41
	// IOErrorEnumProxyNeedAuth: proxy server needs authentication. Since 2.26
	IOErrorEnumProxyNeedAuth IOErrorEnum = 42
	// IOErrorEnumProxyNotAllowed: proxy connection is not allowed by ruleset.
	// Since 2.26
	IOErrorEnumProxyNotAllowed IOErrorEnum = 43
	// IOErrorEnumBrokenPipe: broken pipe. Since 2.36
	IOErrorEnumBrokenPipe IOErrorEnum = 44
	// IOErrorEnumConnectionClosed: connection closed by peer. Note that this is
	// the same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection
	// closed" errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
	IOErrorEnumConnectionClosed IOErrorEnum = 44
	// IOErrorEnumNotConnected: transport endpoint is not connected. Since 2.44
	IOErrorEnumNotConnected IOErrorEnum = 45
	// IOErrorEnumMessageTooLarge: message too large. Since 2.48.
	IOErrorEnumMessageTooLarge IOErrorEnum = 46
)

func marshalIOErrorEnum(p uintptr) (interface{}, error) {
	return IOErrorEnum(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOModuleScopeFlags: flags for use with g_io_module_scope_new().
type IOModuleScopeFlags int

const (
	// IOModuleScopeFlagsNone: no module scan flags
	IOModuleScopeFlagsNone IOModuleScopeFlags = 0
	// IOModuleScopeFlagsBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
	IOModuleScopeFlagsBlockDuplicates IOModuleScopeFlags = 1
)

func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
	return IOModuleScopeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MemoryMonitorWarningLevel: memory availability warning levels.
//
//    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//      drop_caches ();
type MemoryMonitorWarningLevel int

const (
	// MemoryMonitorWarningLevelLow: memory on the device is low, processes
	// should free up unneeded resources (for example, in-memory caches) so they
	// can be used elsewhere.
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium: same as
	// @G_MEMORY_MONITOR_WARNING_LEVEL_LOW but the device has even less free
	// memory, so processes should try harder to free up unneeded resources. If
	// your process does not need to stay running, it is a good time for it to
	// quit.
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical: the system will soon start terminating
	// processes to reclaim memory, including background processes.
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p uintptr) (interface{}, error) {
	return MemoryMonitorWarningLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountOperationResult is returned as a result when a request for information
// is send by the mounting operation.
type MountOperationResult int

const (
	// MountOperationResultHandled: the request was fulfilled and the user
	// specified data is now available
	MountOperationResultHandled MountOperationResult = 0
	// MountOperationResultAborted: the user requested the mount operation to be
	// aborted
	MountOperationResultAborted MountOperationResult = 1
	// MountOperationResultUnhandled: the request was unhandled (i.e. not
	// implemented)
	MountOperationResultUnhandled MountOperationResult = 2
)

func marshalMountOperationResult(p uintptr) (interface{}, error) {
	return MountOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NetworkConnectivity: the host's network connectivity state, as reported by
// Monitor.
type NetworkConnectivity int

const (
	// NetworkConnectivityLocal: the host is not configured with a route to the
	// Internet; it may or may not be connected to a local network.
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited: the host is connected to a network, but does
	// not appear to be able to reach the full Internet, perhaps due to upstream
	// network problems.
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal: the host is behind a captive portal and cannot
	// reach the full Internet.
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull: the host is connected to a network, and appears
	// to be able to reach the full Internet.
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p uintptr) (interface{}, error) {
	return NetworkConnectivity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotificationPriority: priority levels for #GNotifications.
type NotificationPriority int

const (
	// NotificationPriorityNormal: the default priority, to be used for the
	// majority of notifications (for example email messages, software updates,
	// completed download/sync operations)
	NotificationPriorityNormal NotificationPriority = 0
	// NotificationPriorityLow: for notifications that do not require immediate
	// attention - typically used for contextual background information, such as
	// contact birthdays or local weather
	NotificationPriorityLow NotificationPriority = 1
	// NotificationPriorityHigh: for events that require more attention, usually
	// because responses are time-sensitive (for example chat and SMS messages
	// or alarms)
	NotificationPriorityHigh NotificationPriority = 2
	// NotificationPriorityUrgent: for urgent notifications, or notifications
	// that require a response in a short space of time (for example phone calls
	// or emergency warnings)
	NotificationPriorityUrgent NotificationPriority = 3
)

func marshalNotificationPriority(p uintptr) (interface{}, error) {
	return NotificationPriority(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PasswordSave is used to indicate the lifespan of a saved password.
//
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to, and
// later retrieves it again from there
type PasswordSave int

const (
	// PasswordSaveNever: never save a password.
	PasswordSaveNever PasswordSave = 0
	// PasswordSaveForSession: save a password for the session.
	PasswordSaveForSession PasswordSave = 1
	// PasswordSavePermanently: save a password permanently.
	PasswordSavePermanently PasswordSave = 2
)

func marshalPasswordSave(p uintptr) (interface{}, error) {
	return PasswordSave(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PollableReturn: return value for various IO operations that signal errors via
// the return value and not necessarily via a #GError.
//
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for regularly
// happening errors like G_IO_ERROR_WOULD_BLOCK.
//
// In case of G_POLLABLE_RETURN_FAILED a #GError should be set for the operation
// to give details about the error that happened.
type PollableReturn int

const (
	// PollableReturnFailed: generic error condition for when an operation
	// fails.
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOk: the operation was successfully finished.
	PollableReturnOk PollableReturn = 1
	// PollableReturnWouldBlock: the operation would block.
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p uintptr) (interface{}, error) {
	return PollableReturn(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverError: an error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError int

const (
	// ResolverErrorNotFound: the requested name/address/service was not found
	ResolverErrorNotFound ResolverError = 0
	// ResolverErrorTemporaryFailure: the requested information could not be
	// looked up due to a network error or similar problem
	ResolverErrorTemporaryFailure ResolverError = 1
	// ResolverErrorInternal: unknown error
	ResolverErrorInternal ResolverError = 2
)

func marshalResolverError(p uintptr) (interface{}, error) {
	return ResolverError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverRecordType: the type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
//
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
// weight, a `guint16` with the port, and a string of the hostname.
//
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// `(qs)`, representing a `guint16` with the preference, and a string containing
// the mail exchanger hostname.
//
// G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// `(as)`, representing an array of the strings in the text record. Note: Most
// TXT records only contain a single string, but [RFC
// 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record
// to contain multiple strings. The RFC which defines the interpretation of a
// specific TXT record will likely require concatenation of multiple strings if
// they are present, as with [RFC
// 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
//
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// `(ssuuuuu)`, representing a string containing the primary name server, a
// string containing the administrator, the serial as a `guint32`, the refresh
// interval as a `guint32`, the retry interval as a `guint32`, the expire
// timeout as a `guint32`, and the TTL as a `guint32`.
//
// G_RESOLVER_RECORD_NS records are returned as variants with the signature
// `(s)`, representing a string of the hostname of the name server.
type ResolverRecordType int

const (
	// ResolverRecordTypeSrv: look up DNS SRV records for a domain
	ResolverRecordTypeSrv ResolverRecordType = 1
	// ResolverRecordTypeMx: look up DNS MX records for a domain
	ResolverRecordTypeMx ResolverRecordType = 2
	// ResolverRecordTypeTxt: look up DNS TXT records for a name
	ResolverRecordTypeTxt ResolverRecordType = 3
	// ResolverRecordTypeSoa: look up DNS SOA records for a zone
	ResolverRecordTypeSoa ResolverRecordType = 4
	// ResolverRecordTypeNs: look up DNS NS records for a domain
	ResolverRecordTypeNs ResolverRecordType = 5
)

func marshalResolverRecordType(p uintptr) (interface{}, error) {
	return ResolverRecordType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceError: an error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError int

const (
	// ResourceErrorNotFound: no file was found at the requested path
	ResourceErrorNotFound ResourceError = 0
	// ResourceErrorInternal: unknown error
	ResourceErrorInternal ResourceError = 1
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketClientEvent: describes an event occurring on a Client. See the
// Client::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketClientEvent int

const (
	// SocketClientEventResolving: the client is doing a DNS lookup.
	SocketClientEventResolving SocketClientEvent = 0
	// SocketClientEventResolved: the client has completed a DNS lookup.
	SocketClientEventResolved SocketClientEvent = 1
	// SocketClientEventConnecting: the client is connecting to a remote host
	// (either a proxy or the destination server).
	SocketClientEventConnecting SocketClientEvent = 2
	// SocketClientEventConnected: the client has connected to a remote host.
	SocketClientEventConnected SocketClientEvent = 3
	// SocketClientEventProxyNegotiating: the client is negotiating with a proxy
	// to connect to the destination server.
	SocketClientEventProxyNegotiating SocketClientEvent = 4
	// SocketClientEventProxyNegotiated: the client has negotiated with the
	// proxy server.
	SocketClientEventProxyNegotiated SocketClientEvent = 5
	// SocketClientEventTlsHandshaking: the client is performing a TLS
	// handshake.
	SocketClientEventTlsHandshaking SocketClientEvent = 6
	// SocketClientEventTlsHandshaked: the client has performed a TLS handshake.
	SocketClientEventTlsHandshaked SocketClientEvent = 7
	// SocketClientEventComplete: the client is done with a particular
	// Connectable.
	SocketClientEventComplete SocketClientEvent = 8
)

func marshalSocketClientEvent(p uintptr) (interface{}, error) {
	return SocketClientEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketFamily: the protocol family of a Address. (These values are identical
// to the system defines AF_INET, AF_INET6 and AF_UNIX, if available.)
type SocketFamily int

const (
	// SocketFamilyInvalid: no address family
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyUnix: the UNIX domain family
	SocketFamilyUnix SocketFamily = 1
	// SocketFamilyIpv4: the IPv4 family
	SocketFamilyIpv4 SocketFamily = 2
	// SocketFamilyIpv6: the IPv6 family
	SocketFamilyIpv6 SocketFamily = 10
)

func marshalSocketFamily(p uintptr) (interface{}, error) {
	return SocketFamily(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketListenerEvent: describes an event occurring on a Listener. See the
// Listener::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketListenerEvent int

const (
	// SocketListenerEventBinding: the listener is about to bind a socket.
	SocketListenerEventBinding SocketListenerEvent = 0
	// SocketListenerEventBound: the listener has bound a socket.
	SocketListenerEventBound SocketListenerEvent = 1
	// SocketListenerEventListening: the listener is about to start listening on
	// this socket.
	SocketListenerEventListening SocketListenerEvent = 2
	// SocketListenerEventListened: the listener is now listening on this
	// socket.
	SocketListenerEventListened SocketListenerEvent = 3
)

func marshalSocketListenerEvent(p uintptr) (interface{}, error) {
	return SocketListenerEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketProtocol: a protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
//
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
type SocketProtocol int

const (
	// SocketProtocolUnknown: the protocol type is unknown
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault: the default protocol for the family/type
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTcp: TCP over IP
	SocketProtocolTcp SocketProtocol = 6
	// SocketProtocolUdp: UDP over IP
	SocketProtocolUdp SocketProtocol = 17
	// SocketProtocolSctp: SCTP over IP
	SocketProtocolSctp SocketProtocol = 132
)

func marshalSocketProtocol(p uintptr) (interface{}, error) {
	return SocketProtocol(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketType: flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
type SocketType int

const (
	// SocketTypeInvalid: type unknown or wrong
	SocketTypeInvalid SocketType = 0
	// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream SocketType = 1
	// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP)
	SocketTypeDatagram SocketType = 2
	// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket SocketType = 3
)

func marshalSocketType(p uintptr) (interface{}, error) {
	return SocketType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsAuthenticationMode: the client authentication mode for a ServerConnection.
type TlsAuthenticationMode int

const (
	// TlsAuthenticationModeNone: client authentication not required
	TlsAuthenticationModeNone TlsAuthenticationMode = 0
	// TlsAuthenticationModeRequested: client authentication is requested
	TlsAuthenticationModeRequested TlsAuthenticationMode = 1
	// TlsAuthenticationModeRequired: client authentication is required
	TlsAuthenticationModeRequired TlsAuthenticationMode = 2
)

func marshalTlsAuthenticationMode(p uintptr) (interface{}, error) {
	return TlsAuthenticationMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsCertificateRequestFlags: flags for
// g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
type TlsCertificateRequestFlags int

const (
	// TlsCertificateRequestFlagsNone: no flags
	TlsCertificateRequestFlagsNone TlsCertificateRequestFlags = 0
)

func marshalTlsCertificateRequestFlags(p uintptr) (interface{}, error) {
	return TlsCertificateRequestFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsChannelBindingError: an error code used with G_TLS_CHANNEL_BINDING_ERROR
// in a #GError to indicate a TLS channel binding retrieval error.
type TlsChannelBindingError int

const (
	// TlsChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
	TlsChannelBindingErrorNotImplemented TlsChannelBindingError = 0
	// TlsChannelBindingErrorInvalidState: the handshake is not yet complete on
	// the connection which is a strong requirement for any existing binding
	// type.
	TlsChannelBindingErrorInvalidState TlsChannelBindingError = 1
	// TlsChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
	TlsChannelBindingErrorNotAvailable TlsChannelBindingError = 2
	// TlsChannelBindingErrorNotSupported: binding type is not supported on the
	// current connection. This error could be triggered when requesting
	// `tls-server-end-point` binding data for a certificate which has no hash
	// function or uses multiple hash functions.
	TlsChannelBindingErrorNotSupported TlsChannelBindingError = 3
	// TlsChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
	TlsChannelBindingErrorGeneralError TlsChannelBindingError = 4
)

func marshalTlsChannelBindingError(p uintptr) (interface{}, error) {
	return TlsChannelBindingError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsChannelBindingType: the type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929. The
// [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
// binding type is not currently implemented.
type TlsChannelBindingType int

const (
	// TlsChannelBindingTypeUnique:
	// [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
	// type
	TlsChannelBindingTypeUnique TlsChannelBindingType = 0
	// TlsChannelBindingTypeServerEndPoint:
	// [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
	// binding type
	TlsChannelBindingTypeServerEndPoint TlsChannelBindingType = 1
)

func marshalTlsChannelBindingType(p uintptr) (interface{}, error) {
	return TlsChannelBindingType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsDatabaseLookupFlags: flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
type TlsDatabaseLookupFlags int

const (
	// TlsDatabaseLookupFlagsNone: no lookup flags
	TlsDatabaseLookupFlagsNone TlsDatabaseLookupFlags = 0
	// TlsDatabaseLookupFlagsKeypair: restrict lookup to certificates that have
	// a private key.
	TlsDatabaseLookupFlagsKeypair TlsDatabaseLookupFlags = 1
)

func marshalTlsDatabaseLookupFlags(p uintptr) (interface{}, error) {
	return TlsDatabaseLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsError: an error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TlsError int

const (
	// TlsErrorUnavailable: no TLS provider is available
	TlsErrorUnavailable TlsError = 0
	// TlsErrorMisc: miscellaneous TLS error
	TlsErrorMisc TlsError = 1
	// TlsErrorBadCertificate: the certificate presented could not be parsed or
	// failed validation.
	TlsErrorBadCertificate TlsError = 2
	// TlsErrorNotTls: the TLS handshake failed because the peer does not seem
	// to be a TLS server.
	TlsErrorNotTls TlsError = 3
	// TlsErrorHandshake: the TLS handshake failed because the peer's
	// certificate was not acceptable.
	TlsErrorHandshake TlsError = 4
	// TlsErrorCertificateRequired: the TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
	TlsErrorCertificateRequired TlsError = 5
	// TlsErrorEOF: the TLS connection was closed without proper notice, which
	// may indicate an attack. See g_tls_connection_set_require_close_notify().
	TlsErrorEOF TlsError = 6
	// TlsErrorInappropriateFallback: the TLS handshake failed because the
	// client sent the fallback SCSV, indicating a protocol downgrade attack.
	// Since: 2.60
	TlsErrorInappropriateFallback TlsError = 7
)

func marshalTlsError(p uintptr) (interface{}, error) {
	return TlsError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsInteractionResult is returned by various functions in Interaction when
// finishing an interaction request.
type TlsInteractionResult int

const (
	// TlsInteractionResultUnhandled: the interaction was unhandled (i.e. not
	// implemented).
	TlsInteractionResultUnhandled TlsInteractionResult = 0
	// TlsInteractionResultHandled: the interaction completed, and resulting
	// data is available.
	TlsInteractionResultHandled TlsInteractionResult = 1
	// TlsInteractionResultFailed: the interaction has failed, or was cancelled.
	// and the operation should be aborted.
	TlsInteractionResultFailed TlsInteractionResult = 2
)

func marshalTlsInteractionResult(p uintptr) (interface{}, error) {
	return TlsInteractionResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
type TlsRehandshakeMode int

const (
	// TlsRehandshakeModeNever: never allow rehandshaking
	TlsRehandshakeModeNever TlsRehandshakeMode = 0
	// TlsRehandshakeModeSafely: allow safe rehandshaking only
	TlsRehandshakeModeSafely TlsRehandshakeMode = 1
	// TlsRehandshakeModeUnsafely: allow unsafe rehandshaking
	TlsRehandshakeModeUnsafely TlsRehandshakeMode = 2
)

func marshalTlsRehandshakeMode(p uintptr) (interface{}, error) {
	return TlsRehandshakeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UnixSocketAddressType: the type of name used by a SocketAddress.
// G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain socket bound
// to a filesystem path. G_UNIX_SOCKET_ADDRESS_ANONYMOUS indicates a socket not
// bound to any name (eg, a client-side socket, or a socket created with
// socketpair()).
//
// For abstract sockets, there are two incompatible ways of naming them; the man
// pages suggest using the entire `struct sockaddr_un` as the name, padding the
// unused parts of the sun_path field with zeroes; this corresponds to
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED. However, many programs instead just
// use a portion of sun_path, and pass an appropriate smaller length to bind()
// or connect(). This is G_UNIX_SOCKET_ADDRESS_ABSTRACT.
type UnixSocketAddressType int

const (
	// UnixSocketAddressTypeInvalid: invalid
	UnixSocketAddressTypeInvalid UnixSocketAddressType = 0
	// UnixSocketAddressTypeAnonymous: anonymous
	UnixSocketAddressTypeAnonymous UnixSocketAddressType = 1
	// UnixSocketAddressTypePath: a filesystem path
	UnixSocketAddressTypePath UnixSocketAddressType = 2
	// UnixSocketAddressTypeAbstract: an abstract name
	UnixSocketAddressTypeAbstract UnixSocketAddressType = 3
	// UnixSocketAddressTypeAbstractPadded: an abstract name, 0-padded to the
	// full length of a unix socket name
	UnixSocketAddressTypeAbstractPadded UnixSocketAddressType = 4
)

func marshalUnixSocketAddressType(p uintptr) (interface{}, error) {
	return UnixSocketAddressType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ZlibCompressorFormat: used to select the type of data format to use for
// Decompressor and Compressor.
type ZlibCompressorFormat int

const (
	// ZlibCompressorFormatZlib: deflate compression with zlib header
	ZlibCompressorFormatZlib ZlibCompressorFormat = 0
	// ZlibCompressorFormatGzip: gzip file format
	ZlibCompressorFormatGzip ZlibCompressorFormat = 1
	// ZlibCompressorFormatRaw: deflate compression with no header
	ZlibCompressorFormatRaw ZlibCompressorFormat = 2
)

func marshalZlibCompressorFormat(p uintptr) (interface{}, error) {
	return ZlibCompressorFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppInfoCreateFlags: flags used when creating a Info.
type AppInfoCreateFlags int

const (
	// AppInfoCreateFlagsNone: no flags.
	AppInfoCreateFlagsNone AppInfoCreateFlags = 0b0
	// AppInfoCreateFlagsNeedsTerminal: application opens in a terminal window.
	AppInfoCreateFlagsNeedsTerminal AppInfoCreateFlags = 0b1
	// AppInfoCreateFlagsSupportsUris: application supports URI arguments.
	AppInfoCreateFlagsSupportsUris AppInfoCreateFlags = 0b10
	// AppInfoCreateFlagsSupportsStartupNotification: application supports
	// startup notification. Since 2.26
	AppInfoCreateFlagsSupportsStartupNotification AppInfoCreateFlags = 0b100
)

func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
	return AppInfoCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationFlags: flags used to define the behaviour of a #GApplication.
type ApplicationFlags int

const (
	// ApplicationFlagsFlagsNone: default
	ApplicationFlagsFlagsNone ApplicationFlags = 0b0
	// ApplicationFlagsIsService: run as a service. In this mode, registration
	// fails if the service is already running, and the application will
	// initially wait up to 10 seconds for an initial activation message to
	// arrive.
	ApplicationFlagsIsService ApplicationFlags = 0b1
	// ApplicationFlagsIsLauncher: don't try to become the primary instance.
	ApplicationFlagsIsLauncher ApplicationFlags = 0b10
	// ApplicationFlagsHandlesOpen: this application handles opening files (in
	// the primary instance). Note that this flag only affects the default
	// implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
	ApplicationFlagsHandlesOpen ApplicationFlags = 0b100
	// ApplicationFlagsHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
	ApplicationFlagsHandlesCommandLine ApplicationFlags = 0b1000
	// ApplicationFlagsSendEnvironment: send the environment of the launching
	// process to the primary instance. Set this flag if your application is
	// expected to behave differently depending on certain environment
	// variables. For instance, an editor might be expected to use the
	// `GIT_COMMITTER_NAME` environment variable when editing a git commit
	// message. The environment is available to the #GApplication::command-line
	// signal handler, via g_application_command_line_getenv().
	ApplicationFlagsSendEnvironment ApplicationFlags = 0b10000
	// ApplicationFlagsNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID is
	// given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
	ApplicationFlagsNonUnique ApplicationFlags = 0b100000
	// ApplicationFlagsCanOverrideAppID: allow users to override the application
	// ID from the command line with `--gapplication-app-id`. Since: 2.48
	ApplicationFlagsCanOverrideAppID ApplicationFlags = 0b1000000
	// ApplicationFlagsAllowReplacement: allow another instance to take over the
	// bus name. Since: 2.60
	ApplicationFlagsAllowReplacement ApplicationFlags = 0b10000000
	// ApplicationFlagsReplace: take over from another instance. This flag is
	// usually set by passing `--gapplication-replace` on the commandline.
	// Since: 2.60
	ApplicationFlagsReplace ApplicationFlags = 0b100000000
)

func marshalApplicationFlags(p uintptr) (interface{}, error) {
	return ApplicationFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AskPasswordFlags: passwordFlags are used to request specific information from
// the user, or to notify the user of their choices in an authentication
// situation.
type AskPasswordFlags int

const (
	// AskPasswordFlagsNeedPassword: operation requires a password.
	AskPasswordFlagsNeedPassword AskPasswordFlags = 0b1
	// AskPasswordFlagsNeedUsername: operation requires a username.
	AskPasswordFlagsNeedUsername AskPasswordFlags = 0b10
	// AskPasswordFlagsNeedDomain: operation requires a domain.
	AskPasswordFlagsNeedDomain AskPasswordFlags = 0b100
	// AskPasswordFlagsSavingSupported: operation supports saving settings.
	AskPasswordFlagsSavingSupported AskPasswordFlags = 0b1000
	// AskPasswordFlagsAnonymousSupported: operation supports anonymous users.
	AskPasswordFlagsAnonymousSupported AskPasswordFlags = 0b10000
	// AskPasswordFlagsTcrypt: operation takes TCRYPT parameters (Since: 2.58)
	AskPasswordFlagsTcrypt AskPasswordFlags = 0b100000
)

func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
	return AskPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameOwnerFlags: flags used in g_bus_own_name().
type BusNameOwnerFlags int

const (
	// BusNameOwnerFlagsNone: no flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0b0
	// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 0b1
	// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the
	// name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 0b10
	// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns the
	// name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54)
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 0b100
)

func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
	return BusNameOwnerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameWatcherFlags: flags used in g_bus_watch_name().
type BusNameWatcherFlags int

const (
	// BusNameWatcherFlagsNone: no flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0b0
	// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 0b1
)

func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
	return BusNameWatcherFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterFlags: flags used when calling a g_converter_convert().
type ConverterFlags int

const (
	// ConverterFlagsNone: no flags.
	ConverterFlagsNone ConverterFlags = 0b0
	// ConverterFlagsInputAtEnd: at end of input data
	ConverterFlagsInputAtEnd ConverterFlags = 0b1
	// ConverterFlagsFlush: flush data
	ConverterFlagsFlush ConverterFlags = 0b10
)

func marshalConverterFlags(p uintptr) (interface{}, error) {
	return ConverterFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCallFlags: flags used in g_dbus_connection_call() and similar APIs.
type DBusCallFlags int

const (
	// DBusCallFlagsNone: no flags set.
	DBusCallFlagsNone DBusCallFlags = 0b0
	// DBusCallFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this method invocation.
	DBusCallFlagsNoAutoStart DBusCallFlags = 0b1
	// DBusCallFlagsAllowInteractiveAuthorization: the caller is prepared to
	// wait for interactive authorization. Since 2.46.
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 0b10
)

func marshalDBusCallFlags(p uintptr) (interface{}, error) {
	return DBusCallFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCapabilityFlags: capabilities negotiated with the remote peer.
type DBusCapabilityFlags int

const (
	// DBusCapabilityFlagsNone: no flags set.
	DBusCapabilityFlagsNone DBusCapabilityFlags = 0b0
	// DBusCapabilityFlagsUnixFdPassing: the connection supports exchanging UNIX
	// file descriptors with the remote peer.
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 0b1
)

func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
	return DBusCapabilityFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusConnectionFlags: flags used when creating a new BusConnection.
type DBusConnectionFlags int

const (
	// DBusConnectionFlagsNone: no flags set.
	DBusConnectionFlagsNone DBusConnectionFlags = 0b0
	// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
	DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 0b1
	// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
	DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 0b10
	// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 0b100
	// DBusConnectionFlagsMessageBusConnection: pass this flag if connecting to
	// a peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
	DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 0b1000
	// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
	DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 0b10000
)

func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
	return DBusConnectionFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusInterfaceSkeletonFlags: flags describing the behavior of a
// BusInterfaceSkeleton instance.
type DBusInterfaceSkeletonFlags int

const (
	// DBusInterfaceSkeletonFlagsNone: no flags set.
	DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0b0
	// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 0b1
)

func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
	return DBusInterfaceSkeletonFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageFlags: message flags used in BusMessage.
type DBusMessageFlags int

const (
	// DBusMessageFlagsNone: no flags set.
	DBusMessageFlagsNone DBusMessageFlags = 0b0
	// DBusMessageFlagsNoReplyExpected: a reply is not expected.
	DBusMessageFlagsNoReplyExpected DBusMessageFlags = 0b1
	// DBusMessageFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this message.
	DBusMessageFlagsNoAutoStart DBusMessageFlags = 0b10
	// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 0b100
)

func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
	return DBusMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusObjectManagerClientFlags: flags used when constructing a
// BusObjectManagerClient.
type DBusObjectManagerClientFlags int

const (
	// DBusObjectManagerClientFlagsNone: no flags set.
	DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0b0
	// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager is
	// for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 0b1
)

func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
	return DBusObjectManagerClientFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusPropertyInfoFlags: flags describing the access control of a D-Bus
// property.
type DBusPropertyInfoFlags int

const (
	// DBusPropertyInfoFlagsNone: no flags set.
	DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0b0
	// DBusPropertyInfoFlagsReadable: property is readable.
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 0b1
	// DBusPropertyInfoFlagsWritable: property is writable.
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 0b10
)

func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
	return DBusPropertyInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusProxyFlags: flags used when constructing an instance of a BusProxy
// derived class.
type DBusProxyFlags int

const (
	// DBusProxyFlagsNone: no flags set.
	DBusProxyFlagsNone DBusProxyFlags = 0b0
	// DBusProxyFlagsDoNotLoadProperties: don't load properties.
	DBusProxyFlagsDoNotLoadProperties DBusProxyFlags = 0b1
	// DBusProxyFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
	DBusProxyFlagsDoNotConnectSignals DBusProxyFlags = 0b10
	// DBusProxyFlagsDoNotAutoStart: if the proxy is for a well-known name, do
	// not ask the bus to launch an owner during proxy initialization or a
	// method call. This flag is only meaningful in proxies for well-known
	// names.
	DBusProxyFlagsDoNotAutoStart DBusProxyFlags = 0b100
	// DBusProxyFlagsGetInvalidatedProperties: if set, the property value for
	// any __invalidated property__ will be (asynchronously) retrieved upon
	// receiving the
	// [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
	DBusProxyFlagsGetInvalidatedProperties DBusProxyFlags = 0b1000
	// DBusProxyFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call. This
	// flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
	DBusProxyFlagsDoNotAutoStartAtConstruction DBusProxyFlags = 0b10000
)

func marshalDBusProxyFlags(p uintptr) (interface{}, error) {
	return DBusProxyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSendMessageFlags: flags used when sending BusMessages on a BusConnection.
type DBusSendMessageFlags int

const (
	// DBusSendMessageFlagsNone: no flags set.
	DBusSendMessageFlagsNone DBusSendMessageFlags = 0b0
	// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 0b1
)

func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
	return DBusSendMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusServerFlags: flags used when creating a BusServer.
type DBusServerFlags int

const (
	// DBusServerFlagsNone: no flags set.
	DBusServerFlagsNone DBusServerFlags = 0b0
	// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
	DBusServerFlagsRunInThread DBusServerFlags = 0b1
	// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 0b10
)

func marshalDBusServerFlags(p uintptr) (interface{}, error) {
	return DBusServerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSignalFlags: flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
type DBusSignalFlags int

const (
	// DBusSignalFlagsNone: no flags set.
	DBusSignalFlagsNone DBusSignalFlags = 0b0
	// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
	DBusSignalFlagsNoMatchRule DBusSignalFlags = 0b1
	// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 0b10
	// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
	DBusSignalFlagsMatchArg0Path DBusSignalFlags = 0b100
)

func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
	return DBusSignalFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSubtreeFlags: flags passed to g_dbus_connection_register_subtree().
type DBusSubtreeFlags int

const (
	// DBusSubtreeFlagsNone: no flags set.
	DBusSubtreeFlagsNone DBusSubtreeFlags = 0b0
	// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 0b1
)

func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
	return DBusSubtreeFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartFlags: flags used when starting a drive.
type DriveStartFlags int

const (
	// DriveStartFlagsNone: no flags set.
	DriveStartFlagsNone DriveStartFlags = 0b0
)

func marshalDriveStartFlags(p uintptr) (interface{}, error) {
	return DriveStartFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeInfoFlags: flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags int

const (
	// FileAttributeInfoFlagsNone: no flags set.
	FileAttributeInfoFlagsNone FileAttributeInfoFlags = 0b0
	// FileAttributeInfoFlagsCopyWithFile: copy the attribute values when the
	// file is copied.
	FileAttributeInfoFlagsCopyWithFile FileAttributeInfoFlags = 0b1
	// FileAttributeInfoFlagsCopyWhenMoved: copy the attribute values when the
	// file is moved.
	FileAttributeInfoFlagsCopyWhenMoved FileAttributeInfoFlags = 0b10
)

func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
	return FileAttributeInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCopyFlags: flags used when copying or moving files.
type FileCopyFlags int

const (
	// FileCopyFlagsNone: no flags set.
	FileCopyFlagsNone FileCopyFlags = 0b0
	// FileCopyFlagsOverwrite: overwrite any existing files
	FileCopyFlagsOverwrite FileCopyFlags = 0b1
	// FileCopyFlagsBackup: make a backup of any existing files.
	FileCopyFlagsBackup FileCopyFlags = 0b10
	// FileCopyFlagsNofollowSymlinks: don't follow symlinks.
	FileCopyFlagsNofollowSymlinks FileCopyFlags = 0b100
	// FileCopyFlagsAllMetadata: copy all file metadata instead of just default
	// set used for copy (see Info).
	FileCopyFlagsAllMetadata FileCopyFlags = 0b1000
	// FileCopyFlagsNoFallbackForMove: don't use copy and delete fallback if
	// native move not supported.
	FileCopyFlagsNoFallbackForMove FileCopyFlags = 0b10000
	// FileCopyFlagsTargetDefaultPerms: leaves target file with default perms,
	// instead of setting the source file perms.
	FileCopyFlagsTargetDefaultPerms FileCopyFlags = 0b100000
)

func marshalFileCopyFlags(p uintptr) (interface{}, error) {
	return FileCopyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCreateFlags: flags used when an operation may create a file.
type FileCreateFlags int

const (
	// FileCreateFlagsNone: no flags set.
	FileCreateFlagsNone FileCreateFlags = 0b0
	// FileCreateFlagsPrivate: create a file that can only be accessed by the
	// current user.
	FileCreateFlagsPrivate FileCreateFlags = 0b1
	// FileCreateFlagsReplaceDestination: replace the destination as if it
	// didn't exist before. Don't try to keep any old permissions, replace
	// instead of following links. This is generally useful if you're doing a
	// "copy over" rather than a "save new version of" replace operation. You
	// can think of it as "unlink destination" before writing to it, although
	// the implementation may not be exactly like that. This flag can only be
	// used with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20
	FileCreateFlagsReplaceDestination FileCreateFlags = 0b10
)

func marshalFileCreateFlags(p uintptr) (interface{}, error) {
	return FileCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMeasureFlags: flags that can be used with g_file_measure_disk_usage().
type FileMeasureFlags int

const (
	// FileMeasureFlagsNone: no flags set.
	FileMeasureFlagsNone FileMeasureFlags = 0b0
	// FileMeasureFlagsReportAnyError: report any error encountered while
	// traversing the directory tree. Normally errors are only reported for the
	// toplevel file.
	FileMeasureFlagsReportAnyError FileMeasureFlags = 0b10
	// FileMeasureFlagsApparentSize: tally usage based on apparent file sizes.
	// Normally, the block-size is used, if available, as this is a more
	// accurate representation of disk space used. Compare with `du
	// --apparent-size`.
	FileMeasureFlagsApparentSize FileMeasureFlags = 0b100
	// FileMeasureFlagsNoXdev: do not cross mount point boundaries. Compare with
	// `du -x`.
	FileMeasureFlagsNoXdev FileMeasureFlags = 0b1000
)

func marshalFileMeasureFlags(p uintptr) (interface{}, error) {
	return FileMeasureFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorFlags: flags used to set what a Monitor will watch for.
type FileMonitorFlags int

const (
	// FileMonitorFlagsNone: no flags set.
	FileMonitorFlagsNone FileMonitorFlags = 0b0
	// FileMonitorFlagsWatchMounts: watch for mount events.
	FileMonitorFlagsWatchMounts FileMonitorFlags = 0b1
	// FileMonitorFlagsSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorFlagsSendMoved FileMonitorFlags = 0b10
	// FileMonitorFlagsWatchHardLinks: watch for changes to the file made via
	// another hard link. Since 2.36.
	FileMonitorFlagsWatchHardLinks FileMonitorFlags = 0b100
	// FileMonitorFlagsWatchMoves: watch for rename operations on a monitored
	// directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
	FileMonitorFlagsWatchMoves FileMonitorFlags = 0b1000
)

func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
	return FileMonitorFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileQueryInfoFlags: flags used when querying a Info.
type FileQueryInfoFlags int

const (
	// FileQueryInfoFlagsNone: no flags set.
	FileQueryInfoFlagsNone FileQueryInfoFlags = 0b0
	// FileQueryInfoFlagsNofollowSymlinks: don't follow symlinks.
	FileQueryInfoFlagsNofollowSymlinks FileQueryInfoFlags = 0b1
)

func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
	return FileQueryInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOStreamSpliceFlags: GIOStreamSpliceFlags determine how streams should be
// spliced.
type IOStreamSpliceFlags int

const (
	// IOStreamSpliceFlagsNone: do not close either stream.
	IOStreamSpliceFlagsNone IOStreamSpliceFlags = 0b0
	// IOStreamSpliceFlagsCloseStream1: close the first stream after the splice.
	IOStreamSpliceFlagsCloseStream1 IOStreamSpliceFlags = 0b1
	// IOStreamSpliceFlagsCloseStream2: close the second stream after the
	// splice.
	IOStreamSpliceFlagsCloseStream2 IOStreamSpliceFlags = 0b10
	// IOStreamSpliceFlagsWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
	IOStreamSpliceFlagsWaitForBoth IOStreamSpliceFlags = 0b100
)

func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
	return IOStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountMountFlags: flags used when mounting a mount.
type MountMountFlags int

const (
	// MountMountFlagsNone: no flags set.
	MountMountFlagsNone MountMountFlags = 0b0
)

func marshalMountMountFlags(p uintptr) (interface{}, error) {
	return MountMountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountUnmountFlags: flags used when an unmounting a mount.
type MountUnmountFlags int

const (
	// MountUnmountFlagsNone: no flags set.
	MountUnmountFlagsNone MountUnmountFlags = 0b0
	// MountUnmountFlagsForce: unmount even if there are outstanding file
	// operations on the mount.
	MountUnmountFlagsForce MountUnmountFlags = 0b1
)

func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
	return MountUnmountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// OutputStreamSpliceFlags: GOutputStreamSpliceFlags determine how streams
// should be spliced.
type OutputStreamSpliceFlags int

const (
	// OutputStreamSpliceFlagsNone: do not close either stream.
	OutputStreamSpliceFlagsNone OutputStreamSpliceFlags = 0b0
	// OutputStreamSpliceFlagsCloseSource: close the source stream after the
	// splice.
	OutputStreamSpliceFlagsCloseSource OutputStreamSpliceFlags = 0b1
	// OutputStreamSpliceFlagsCloseTarget: close the target stream after the
	// splice.
	OutputStreamSpliceFlagsCloseTarget OutputStreamSpliceFlags = 0b10
)

func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
	return OutputStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverNameLookupFlags: flags to modify lookup behavior.
type ResolverNameLookupFlags int

const (
	// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name())
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0b0
	// ResolverNameLookupFlagsIpv4Only: only resolve ipv4 addresses
	ResolverNameLookupFlagsIpv4Only ResolverNameLookupFlags = 0b1
	// ResolverNameLookupFlagsIpv6Only: only resolve ipv6 addresses
	ResolverNameLookupFlagsIpv6Only ResolverNameLookupFlags = 0b10
)

func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
	return ResolverNameLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceFlags: GResourceFlags give information about a particular file inside
// a resource bundle.
type ResourceFlags int

const (
	// ResourceFlagsNone: no flags set.
	ResourceFlagsNone ResourceFlags = 0b0
	// ResourceFlagsCompressed: the file is compressed.
	ResourceFlagsCompressed ResourceFlags = 0b1
)

func marshalResourceFlags(p uintptr) (interface{}, error) {
	return ResourceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceLookupFlags: GResourceLookupFlags determine how resource path lookups
// are handled.
type ResourceLookupFlags int

const (
	// ResourceLookupFlagsNone: no flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0b0
)

func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
	return ResourceLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SettingsBindFlags: flags used when creating a binding. These flags determine
// in which direction the binding works. The default is to synchronize in both
// directions.
type SettingsBindFlags int

const (
	// SettingsBindFlagsDefault: equivalent to
	// `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
	SettingsBindFlagsDefault SettingsBindFlags = 0b0
	// SettingsBindFlagsGet: update the #GObject property when the setting
	// changes. It is an error to use this flag if the property is not writable.
	SettingsBindFlagsGet SettingsBindFlags = 0b1
	// SettingsBindFlagsSet: update the setting when the #GObject property
	// changes. It is an error to use this flag if the property is not readable.
	SettingsBindFlagsSet SettingsBindFlags = 0b10
	// SettingsBindFlagsNoSensitivity: do not try to bind a "sensitivity"
	// property to the writability of the setting
	SettingsBindFlagsNoSensitivity SettingsBindFlags = 0b100
	// SettingsBindFlagsGetNoChanges: when set in addition to SETTINGS_BIND_GET,
	// set the #GObject property value initially from the setting, but do not
	// listen for changes of the setting
	SettingsBindFlagsGetNoChanges SettingsBindFlags = 0b1000
	// SettingsBindFlagsInvertBoolean: when passed to g_settings_bind(), uses a
	// pair of mapping functions that invert the boolean value when mapping
	// between the setting and the property. The setting and property must both
	// be booleans. You cannot pass this flag to g_settings_bind_with_mapping().
	SettingsBindFlagsInvertBoolean SettingsBindFlags = 0b10000
)

func marshalSettingsBindFlags(p uintptr) (interface{}, error) {
	return SettingsBindFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketMsgFlags: flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
type SocketMsgFlags int

const (
	// SocketMsgFlagsNone: no flags.
	SocketMsgFlagsNone SocketMsgFlags = 0b0
	// SocketMsgFlagsOob: request to send/receive out of band data.
	SocketMsgFlagsOob SocketMsgFlags = 0b1
	// SocketMsgFlagsPeek: read data from the socket without removing it from
	// the queue.
	SocketMsgFlagsPeek SocketMsgFlags = 0b10
	// SocketMsgFlagsDontroute: don't use a gateway to send out the packet, only
	// send to hosts on directly connected networks.
	SocketMsgFlagsDontroute SocketMsgFlags = 0b100
)

func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
	return SocketMsgFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubprocessFlags: flags to define the behaviour of a #GSubprocess.
//
// Note that the default for stdin is to redirect from `/dev/null`. For stdout
// and stderr the default are for them to inherit the corresponding descriptor
// from the calling process.
//
// Note that it is a programmer error to mix 'incompatible' flags. For example,
// you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
type SubprocessFlags int

const (
	// SubprocessFlagsNone: no flags.
	SubprocessFlagsNone SubprocessFlags = 0b0
	// SubprocessFlagsStdinPipe: create a pipe for the stdin of the spawned
	// process that can be accessed with g_subprocess_get_stdin_pipe().
	SubprocessFlagsStdinPipe SubprocessFlags = 0b1
	// SubprocessFlagsStdinInherit: stdin is inherited from the calling process.
	SubprocessFlagsStdinInherit SubprocessFlags = 0b10
	// SubprocessFlagsStdoutPipe: create a pipe for the stdout of the spawned
	// process that can be accessed with g_subprocess_get_stdout_pipe().
	SubprocessFlagsStdoutPipe SubprocessFlags = 0b100
	// SubprocessFlagsStdoutSilence: silence the stdout of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStdoutSilence SubprocessFlags = 0b1000
	// SubprocessFlagsStderrPipe: create a pipe for the stderr of the spawned
	// process that can be accessed with g_subprocess_get_stderr_pipe().
	SubprocessFlagsStderrPipe SubprocessFlags = 0b10000
	// SubprocessFlagsStderrSilence: silence the stderr of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStderrSilence SubprocessFlags = 0b100000
	// SubprocessFlagsStderrMerge: merge the stderr of the spawned process with
	// whatever the stdout happens to be. This is a good way of directing both
	// streams to a common log file, for example.
	SubprocessFlagsStderrMerge SubprocessFlags = 0b1000000
	// SubprocessFlagsInheritFds: spawned processes will inherit the file
	// descriptors of their parent, unless those descriptors have been
	// explicitly marked as close-on-exec. This flag has no effect over the
	// "standard" file descriptors (stdin, stdout, stderr).
	SubprocessFlagsInheritFds SubprocessFlags = 0b10000000
)

func marshalSubprocessFlags(p uintptr) (interface{}, error) {
	return SubprocessFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TestDBusFlags: flags to define future DBus behaviour.
type TestDBusFlags int

const (
	// TestDBusFlagsNone: no flags.
	TestDBusFlagsNone TestDBusFlags = 0b0
)

func marshalTestDBusFlags(p uintptr) (interface{}, error) {
	return TestDBusFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsCertificateFlags: a set of flags describing TLS certification validation.
// This can be used to set which validation steps to perform (eg, with
// g_tls_client_connection_set_validation_flags()), or to describe why a
// particular certificate was rejected (eg, in Connection::accept-certificate).
type TlsCertificateFlags int

const (
	// TlsCertificateFlagsUnknownCa: the signing certificate authority is not
	// known.
	TlsCertificateFlagsUnknownCa TlsCertificateFlags = 0b1
	// TlsCertificateFlagsBadIdentity: the certificate does not match the
	// expected identity of the site that it was retrieved from.
	TlsCertificateFlagsBadIdentity TlsCertificateFlags = 0b10
	// TlsCertificateFlagsNotActivated: the certificate's activation time is
	// still in the future
	TlsCertificateFlagsNotActivated TlsCertificateFlags = 0b100
	// TlsCertificateFlagsExpired: the certificate has expired
	TlsCertificateFlagsExpired TlsCertificateFlags = 0b1000
	// TlsCertificateFlagsRevoked: the certificate has been revoked according to
	// the Connection's certificate revocation list.
	TlsCertificateFlagsRevoked TlsCertificateFlags = 0b10000
	// TlsCertificateFlagsInsecure: the certificate's algorithm is considered
	// insecure.
	TlsCertificateFlagsInsecure TlsCertificateFlags = 0b100000
	// TlsCertificateFlagsGenericError: some other error occurred validating the
	// certificate
	TlsCertificateFlagsGenericError TlsCertificateFlags = 0b1000000
	// TlsCertificateFlagsValidateAll: the combination of all of the above flags
	TlsCertificateFlagsValidateAll TlsCertificateFlags = 0b1111111
)

func marshalTlsCertificateFlags(p uintptr) (interface{}, error) {
	return TlsCertificateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsDatabaseVerifyFlags: flags for g_tls_database_verify_chain().
type TlsDatabaseVerifyFlags int

const (
	// TlsDatabaseVerifyFlagsNone: no verification flags
	TlsDatabaseVerifyFlagsNone TlsDatabaseVerifyFlags = 0b0
)

func marshalTlsDatabaseVerifyFlags(p uintptr) (interface{}, error) {
	return TlsDatabaseVerifyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsPasswordFlags: various flags for the password.
type TlsPasswordFlags int

const (
	// TlsPasswordFlagsNone: no flags
	TlsPasswordFlagsNone TlsPasswordFlags = 0b0
	// TlsPasswordFlagsRetry: the password was wrong, and the user should retry.
	TlsPasswordFlagsRetry TlsPasswordFlags = 0b10
	// TlsPasswordFlagsManyTries: hint to the user that the password has been
	// wrong many times, and the user may not have many chances left.
	TlsPasswordFlagsManyTries TlsPasswordFlags = 0b100
	// TlsPasswordFlagsFinalTry: hint to the user that this is the last try to
	// get this password right.
	TlsPasswordFlagsFinalTry TlsPasswordFlags = 0b1000
)

func marshalTlsPasswordFlags(p uintptr) (interface{}, error) {
	return TlsPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ActionNameIsValid: checks if @action_name is valid.
//
// @action_name is valid if it consists only of alphanumeric characters, plus
// '-' and '.'. The empty string is not a valid action name.
//
// It is an error to call this function with a non-utf8 @action_name.
// @action_name must not be nil.
func ActionNameIsValid(actionName string) bool

// ActionParseDetailedName: parses a detailed action name into its separate name
// and target components.
//
// Detailed action names can have three formats.
//
// The first format is used to represent an action name with no target value and
// consists of just an action name containing no whitespace nor the characters
// ':', '(' or ')'. For example: "app.action".
//
// The second format is used to represent an action with a target value that is
// a non-empty string consisting only of alphanumerics, plus '-' and '.'. In
// that case, the action name and target value are separated by a double colon
// ("::"). For example: "app.action::target".
//
// The third format is used to represent an action with any type of target
// value, including strings. The target value follows the action name,
// surrounded in parens. For example: "app.action(42)". The target value is
// parsed using g_variant_parse(). If a tuple-typed value is desired, it must be
// specified in the same way, resulting in two sets of parens, for example:
// "app.action((1,2,3))". A string target can be specified this way as well:
// "app.action('target')". For strings, this third format must be used if *
// target value is empty or contains characters other than alphanumerics, '-'
// and '.'.
func ActionParseDetailedName(detailedName string) (string, *glib.Variant, bool)

// ActionPrintDetailedName: formats a detailed action name from @action_name and
// @target_value.
//
// It is an error to call this function with an invalid action name.
//
// This function is the opposite of g_action_parse_detailed_name(). It will
// produce a string that can be parsed back to the @action_name and
// @target_value by that function.
//
// See that function for the types of strings that will be printed by this
// function.
func ActionPrintDetailedName(actionName string, targetValue *glib.Variant) string

// AppInfoCreateFromCommandline: creates a new Info from the given information.
//
// Note that for @commandline, the quoting rules of the Exec key of the
// [freedesktop.org Desktop Entry
// Specification](http://freedesktop.org/Standards/desktop-entry-spec) are
// applied. For example, if the @commandline contains percent-encoded URIs, the
// percent-character must be doubled in order to prevent it from being swallowed
// by Exec key unquoting. See the specification for exact quoting rules.
func AppInfoCreateFromCommandline(commandline string, applicationName string, flags AppInfoCreateFlags) AppInfo

// AppInfoGetAll: gets a list of all of the applications currently registered on
// this system.
//
// For desktop files, this includes applications that have `NoDisplay=true` set
// or are excluded from display by means of `OnlyShowIn` or `NotShowIn`. See
// g_app_info_should_show(). The returned list does not include applications
// which have the `Hidden` key set.
func AppInfoGetAll() *glib.List

// AppInfoGetAllForType: gets a list of all Infos for a given content type,
// including the recommended and fallback Infos. See
// g_app_info_get_recommended_for_type() and g_app_info_get_fallback_for_type().
func AppInfoGetAllForType(contentType string) *glib.List

// AppInfoGetDefaultForType: gets the default Info for a given content type.
func AppInfoGetDefaultForType(contentType string, mustSupportUris bool) AppInfo

// AppInfoGetDefaultForURIScheme: gets the default application for handling URIs
// with the given URI scheme. A URI scheme is the initial part of the URI, up to
// but not including the ':', e.g. "http", "ftp" or "sip".
func AppInfoGetDefaultForURIScheme(uriScheme string) AppInfo

// AppInfoGetFallbackForType: gets a list of fallback Infos for a given content
// type, i.e. those applications which claim to support the given content type
// by MIME type subclassing and not directly.
func AppInfoGetFallbackForType(contentType string) *glib.List

// AppInfoGetRecommendedForType: gets a list of recommended Infos for a given
// content type, i.e. those applications which claim to support the given
// content type exactly, and not by MIME type subclassing. Note that the first
// application of the list is the last used one, i.e. the last one for which
// g_app_info_set_as_last_used_for_type() has been called.
func AppInfoGetRecommendedForType(contentType string) *glib.List

// AppInfoLaunchDefaultForURI: utility function that launches the default
// application registered to handle the specified uri. Synchronous I/O is done
// on the uri to detect the type of the file if required.
//
// The D-Busactivated applications don't have to be started if your application
// terminates too soon after this function. To prevent this, use
// g_app_info_launch_default_for_uri_async() instead.
func AppInfoLaunchDefaultForURI(uri string, context *AppLaunchContext) bool

// AppInfoLaunchDefaultForURIAsync: async version of
// g_app_info_launch_default_for_uri().
//
// This version is useful if you are interested in receiving error information
// in the case where the application is sandboxed and the portal may present an
// application chooser dialog to the user.
//
// This is also useful if you want to be sure that the D-Busactivated
// applications are really started before termination and if you are interested
// in receiving error information from their activation.
func AppInfoLaunchDefaultForURIAsync(uri string, context *AppLaunchContext, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)

// AppInfoLaunchDefaultForURIFinish: finishes an asynchronous
// launch-default-for-uri operation.
func AppInfoLaunchDefaultForURIFinish(result AsyncResult) bool

// AppInfoResetTypeAssociations: removes all changes to the type associations
// done by g_app_info_set_as_default_for_type(),
// g_app_info_set_as_default_for_extension(), g_app_info_add_supports_type() or
// g_app_info_remove_supports_type().
func AppInfoResetTypeAssociations(contentType string)

// BusGet: asynchronously connects to the message bus specified by @bus_type.
//
// When the operation is finished, @callback will be invoked. You can then call
// g_bus_get_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See g_bus_get_sync() for the
// synchronous version.
func BusGet(busType BusType, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)

// BusGetFinish: finishes an operation started with g_bus_get().
//
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
func BusGetFinish(res AsyncResult) *DBusConnection

// BusGetSync: synchronously connects to the message bus specified by @bus_type.
// Note that the returned object may shared with other callers, e.g. if two
// separate parts of a process calls this function with the same @bus_type, they
// will share the same object.
//
// This is a synchronous failable function. See g_bus_get() and
// g_bus_get_finish() for the asynchronous version.
//
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
func BusGetSync(busType BusType, cancellable *Cancellable) *DBusConnection

// BusOwnName: starts acquiring @name on the bus specified by @bus_type and
// calls @name_acquired_handler and @name_lost_handler when the name is acquired
// respectively lost. Callbacks will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this function from.
//
// You are guaranteed that one of the @name_acquired_handler and
// @name_lost_handler callbacks will be invoked after calling this function -
// there are three possible cases:
//
// - @name_lost_handler with a nil connection (if a connection to the bus can't
// be made).
//
// - @bus_acquired_handler then @name_lost_handler (if the name can't be
// obtained)
//
// - @bus_acquired_handler then @name_acquired_handler (if the name was
// obtained).
//
// When you are done owning the name, just call g_bus_unown_name() with the
// owner id this function returns.
//
// If the name is acquired or lost (for example another application could
// acquire the name if you allow replacement or the application currently owning
// the name exits), the handlers are also invoked. If the BusConnection that is
// used for attempting to own the name closes, then @name_lost_handler is
// invoked since it is no longer possible for other processes to access the
// process.
//
// You cannot use g_bus_own_name() several times for the same name (unless
// interleaved with calls to g_bus_unown_name()) - only the first call will
// work.
//
// Another guarantee is that invocations of @name_acquired_handler and
// @name_lost_handler are guaranteed to alternate; that is, if
// @name_acquired_handler is invoked then you are guaranteed that the next time
// one of the handlers is invoked, it will be @name_lost_handler. The reverse is
// also true.
//
// If you plan on exporting objects (using e.g.
// g_dbus_connection_register_object()), note that it is generally too late to
// export the objects in @name_acquired_handler. Instead, you can do this in
// @bus_acquired_handler since you are guaranteed that this will run before
// @name is requested from the bus.
//
// This behavior makes it very simple to write applications that wants to [own
// names][gdbus-owning-names] and export objects. Simply register objects to be
// exported in @bus_acquired_handler and unregister the objects (if any) in
// @name_lost_handler.
func BusOwnName(busType BusType, name string, flags BusNameOwnerFlags, busAcquiredHandler BusAcquiredCallback, nameAcquiredHandler BusNameAcquiredCallback, nameLostHandler BusNameLostCallback, userData unsafe.Pointer, userDataFreeFunc unsafe.Pointer) uint

// BusOwnNameOnConnection: like g_bus_own_name() but takes a BusConnection
// instead of a Type.
func BusOwnNameOnConnection(connection *DBusConnection, name string, flags BusNameOwnerFlags, nameAcquiredHandler BusNameAcquiredCallback, nameLostHandler BusNameLostCallback, userData unsafe.Pointer, userDataFreeFunc unsafe.Pointer) uint

// BusOwnNameOnConnectionWithClosures: version of g_bus_own_name_on_connection()
// using closures instead of callbacks for easier binding in other languages.
func BusOwnNameOnConnectionWithClosures(connection *DBusConnection, name string, flags BusNameOwnerFlags, nameAcquiredClosure *externglib.Closure, nameLostClosure *externglib.Closure) uint

// BusOwnNameWithClosures: version of g_bus_own_name() using closures instead of
// callbacks for easier binding in other languages.
func BusOwnNameWithClosures(busType BusType, name string, flags BusNameOwnerFlags, busAcquiredClosure *externglib.Closure, nameAcquiredClosure *externglib.Closure, nameLostClosure *externglib.Closure) uint

// BusUnownName: stops owning a name.
//
// Note that there may still be D-Bus traffic to process (relating to owning and
// unowning the name) in the current thread-default Context after this function
// has returned. You should continue to iterate the Context until the Notify
// function passed to g_bus_own_name() is called, in order to avoid memory leaks
// through callbacks queued on the Context after its stopped being iterated.
func BusUnownName(ownerID uint)

// BusUnwatchName: stops watching a name.
//
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_bus_watch_name() is called, in order to avoid
// memory leaks through callbacks queued on the Context after its stopped being
// iterated.
func BusUnwatchName(watcherID uint)

// BusWatchName: starts watching @name on the bus specified by @bus_type and
// calls @name_appeared_handler and @name_vanished_handler when the name is
// known to have an owner respectively known to lose its owner. Callbacks will
// be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this function from.
//
// You are guaranteed that one of the handlers will be invoked after calling
// this function. When you are done watching the name, just call
// g_bus_unwatch_name() with the watcher id this function returns.
//
// If the name vanishes or appears (for example the application owning the name
// could restart), the handlers are also invoked. If the BusConnection that is
// used for watching the name disconnects, then @name_vanished_handler is
// invoked since it is no longer possible to access the name.
//
// Another guarantee is that invocations of @name_appeared_handler and
// @name_vanished_handler are guaranteed to alternate; that is, if
// @name_appeared_handler is invoked then you are guaranteed that the next time
// one of the handlers is invoked, it will be @name_vanished_handler. The
// reverse is also true.
//
// This behavior makes it very simple to write applications that want to take
// action when a certain [name exists][gdbus-watching-names]. Basically, the
// application should create object proxies in @name_appeared_handler and
// destroy them again (if any) in @name_vanished_handler.
func BusWatchName(busType BusType, name string, flags BusNameWatcherFlags, nameAppearedHandler BusNameAppearedCallback, nameVanishedHandler BusNameVanishedCallback, userData unsafe.Pointer, userDataFreeFunc unsafe.Pointer) uint

// BusWatchNameOnConnection: like g_bus_watch_name() but takes a BusConnection
// instead of a Type.
func BusWatchNameOnConnection(connection *DBusConnection, name string, flags BusNameWatcherFlags, nameAppearedHandler BusNameAppearedCallback, nameVanishedHandler BusNameVanishedCallback, userData unsafe.Pointer, userDataFreeFunc unsafe.Pointer) uint

// BusWatchNameOnConnectionWithClosures: version of
// g_bus_watch_name_on_connection() using closures instead of callbacks for
// easier binding in other languages.
func BusWatchNameOnConnectionWithClosures(connection *DBusConnection, name string, flags BusNameWatcherFlags, nameAppearedClosure *externglib.Closure, nameVanishedClosure *externglib.Closure) uint

// BusWatchNameWithClosures: version of g_bus_watch_name() using closures
// instead of callbacks for easier binding in other languages.
func BusWatchNameWithClosures(busType BusType, name string, flags BusNameWatcherFlags, nameAppearedClosure *externglib.Closure, nameVanishedClosure *externglib.Closure) uint

// ContentTypeCanBeExecutable: checks if a content type can be executable. Note
// that for instance things like text files can be executables (i.e. scripts and
// batch files).
func ContentTypeCanBeExecutable(_type string) bool

// ContentTypeEquals: compares two content types for equality.
func ContentTypeEquals(type1 string, type2 string) bool

// ContentTypeFromMimeType: tries to find a content type based on the mime type
// name.
func ContentTypeFromMimeType(mimeType string) string

// ContentTypeGetDescription: gets the human readable description of the content
// type.
func ContentTypeGetDescription(_type string) string

// ContentTypeGetGenericIconName: gets the generic icon name for a content type.
//
// See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on the generic icon name.
func ContentTypeGetGenericIconName(_type string) string

// ContentTypeGetIcon: gets the icon for a content type.
func ContentTypeGetIcon(_type string) Icon

// ContentTypeGetMimeDirs: get the list of directories which MIME data is loaded
// from. See g_content_type_set_mime_dirs() for details.
func ContentTypeGetMimeDirs() []string

// ContentTypeGetMimeType: gets the mime type for the content type, if one is
// registered.
func ContentTypeGetMimeType(_type string) string

// ContentTypeGetSymbolicIcon: gets the symbolic icon for a content type.
func ContentTypeGetSymbolicIcon(_type string) Icon

// ContentTypeGuess: guesses the content type based on example data. If the
// function is uncertain, @result_uncertain will be set to true. Either
// @filename or @data may be nil, in which case the guess will be based solely
// on the other argument.
func ContentTypeGuess(filename string, data []uint8, dataSize uint) (bool, string)

// ContentTypeGuessForTree: tries to guess the type of the tree with root @root,
// by looking at the files it contains. The result is an array of content types,
// with the best guess coming first.
//
// The types returned all have the form x-content/foo, e.g. x-content/audio-cdda
// (for audio CDs) or x-content/image-dcf (for a camera memory card). See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This function is useful in the implementation of
// g_mount_guess_content_type().
func ContentTypeGuessForTree(root File) []string

// ContentTypeIsA: determines if @type is a subset of @supertype.
func ContentTypeIsA(_type string, supertype string) bool

// ContentTypeIsMimeType: determines if @type is a subset of @mime_type.
// Convenience wrapper around g_content_type_is_a().
func ContentTypeIsMimeType(_type string, mimeType string) bool

// ContentTypeIsUnknown: checks if the content type is the generic "unknown"
// type. On UNIX this is the "application/octet-stream" mimetype, while on win32
// it is "*" and on OSX it is a dynamic type or octet-stream.
func ContentTypeIsUnknown(_type string) bool

// ContentTypeSetMimeDirs: set the list of directories used by GIO to load the
// MIME database. If @dirs is nil, the directories used are the default:
//
// - the `mime` subdirectory of the directory in `$XDG_DATA_HOME` - the `mime`
// subdirectory of every directory in `$XDG_DATA_DIRS`
//
// This function is intended to be used when writing tests that depend on
// information stored in the MIME database, in order to control the data.
//
// Typically, in case your tests use G_TEST_OPTION_ISOLATE_DIRS, but they depend
// on the systems MIME database, you should call this function with @dirs set
// to nil before calling g_test_init(), for instance:
//
//      // Load MIME data from the system
//      g_content_type_set_mime_dirs (NULL);
//      // Isolate the environment
//      g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
//
//      
//
//      return g_test_run ();
//
func ContentTypeSetMimeDirs(dirs []string)

// ContentTypesGetRegistered: gets a list of strings containing all the
// registered content types known to the system. The list and its data should be
// freed using `g_list_free_full (list, g_free)`.
func ContentTypesGetRegistered() *glib.List

// DbusAddressEscapeValue: escape @string so it can appear in a D-Bus address as
// the value part of a key-value pair.
//
// For instance, if @string is `/run/bus-for-:0`, this function would return
// `/run/bus-for-3A0`, which could be used in a D-Bus address like
// `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-3A0`.
func DbusAddressEscapeValue(string string) string

// DbusAddressGetForBusSync: synchronously looks up the D-Bus address for the
// well-known message bus instance specified by @bus_type. This may involve
// using various platform specific mechanisms.
//
// The returned address will be in the [D-Bus address
// format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DbusAddressGetForBusSync(busType BusType, cancellable *Cancellable) string

// DbusAddressGetStream: asynchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// [D-Bus address
// format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// When the operation is finished, @callback will be invoked. You can then call
// g_dbus_address_get_stream_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See
// g_dbus_address_get_stream_sync() for the synchronous version.
func DbusAddressGetStream(address string, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)

// DbusAddressGetStreamFinish: finishes an operation started with
// g_dbus_address_get_stream().
func DbusAddressGetStreamFinish(res AsyncResult) (string, *IOStream)

// DbusAddressGetStreamSync: synchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// [D-Bus address
// format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This is a synchronous failable function. See g_dbus_address_get_stream() for
// the asynchronous version.
func DbusAddressGetStreamSync(address string, cancellable *Cancellable) (string, *IOStream)

// DbusAnnotationInfoLookup: looks up the value of an annotation.
//
// The cost of this function is O(n) in number of annotations.
func DbusAnnotationInfoLookup(annotations []*DBusAnnotationInfo, name string) string

// DbusErrorEncodeGerror: creates a D-Bus error name to use for @error. If
// @error matches a registered error (cf. g_dbus_error_register_error()), the
// corresponding D-Bus error name will be returned.
//
// Otherwise the a name of the form
// `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE` will
// be used. This allows other GDBus applications to map the error on the wire
// back to a #GError using g_dbus_error_new_for_dbus_error().
//
// This function is typically only used in object mappings to put a #GError on
// the wire. Regular applications should not use it.
func DbusErrorEncodeGerror(error *glib.Error) string

// DbusErrorGetRemoteError: gets the D-Bus error name used for @error, if any.
//
// This function is guaranteed to return a D-Bus error name for all #GErrors
// returned from functions handling remote method calls (e.g.
// g_dbus_connection_call_finish()) unless g_dbus_error_strip_remote_error() has
// been used on @error.
func DbusErrorGetRemoteError(error *glib.Error) string

// DbusErrorIsRemoteError: checks if @error represents an error received via
// D-Bus from a remote peer. If so, use g_dbus_error_get_remote_error() to get
// the name of the error.
func DbusErrorIsRemoteError(error *glib.Error) bool

// DbusErrorNewForDbusError: creates a #GError based on the contents of
// @dbus_error_name and @dbus_error_message.
//
// Errors registered with g_dbus_error_register_error() will be looked up using
// @dbus_error_name and if a match is found, the error domain and code is used.
// Applications can use g_dbus_error_get_remote_error() to recover
// @dbus_error_name.
//
// If a match against a registered error is not found and the D-Bus error name
// is in a form as returned by g_dbus_error_encode_gerror() the error domain and
// code encoded in the name is used to create the #GError. Also,
// @dbus_error_name is added to the error message such that it can be recovered
// with g_dbus_error_get_remote_error().
//
// Otherwise, a #GError with the error code G_IO_ERROR_DBUS_ERROR in the
// IO_ERROR error domain is returned. Also, @dbus_error_name is added to the
// error message such that it can be recovered with
// g_dbus_error_get_remote_error().
//
// In all three cases, @dbus_error_name can always be recovered from the
// returned #GError using the g_dbus_error_get_remote_error() function (unless
// g_dbus_error_strip_remote_error() hasn't been used on the returned error).
//
// This function is typically only used in object mappings to prepare #GError
// instances for applications. Regular applications should not use it.
func DbusErrorNewForDbusError(dbusErrorName string, dbusErrorMessage string) *glib.Error

func DbusErrorQuark() glib.Quark

// DbusErrorRegisterError: creates an association to map between
// @dbus_error_name and #GErrors specified by @error_domain and @error_code.
//
// This is typically done in the routine that returns the #GQuark for an error
// domain.
func DbusErrorRegisterError(errorDomain glib.Quark, errorCode int, dbusErrorName string) bool

// DbusErrorRegisterErrorDomain: helper function for associating a #GError error
// domain with D-Bus error names.
func DbusErrorRegisterErrorDomain(errorDomainQuarkName string, quarkVolatile uint, entries []DBusErrorEntry, numEntries uint)

// DbusErrorStripRemoteError: looks for extra information in the error message
// used to recover the D-Bus error name and strips it if found. If stripped, the
// message field in @error will correspond exactly to what was received on the
// wire.
//
// This is typically used when presenting errors to the end user.
func DbusErrorStripRemoteError(error *glib.Error) bool

// DbusErrorUnregisterError: destroys an association previously set up with
// g_dbus_error_register_error().
func DbusErrorUnregisterError(errorDomain glib.Quark, errorCode int, dbusErrorName string) bool

// DbusGenerateGuid: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DbusGenerateGuid() string

// DbusGvalueToGvariant: converts a #GValue to a #GVariant of the type indicated
// by the @type parameter.
//
// The conversion is using the following rules:
//
// - TYPE_STRING: 's', 'o', 'g' or 'ay' - TYPE_STRV: 'as', 'ao' or 'aay' -
// TYPE_BOOLEAN: 'b' - TYPE_UCHAR: 'y' - TYPE_INT: 'i', 'n' - TYPE_UINT: 'u',
// 'q' - TYPE_INT64 'x' - TYPE_UINT64: 't' - TYPE_DOUBLE: 'd' - TYPE_VARIANT:
// Any Type
//
// This can fail if e.g. @gvalue is of type TYPE_STRING and @type is
// ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType (including
// e.g. TYPE_OBJECT and TYPE_BOXED derived-types) not in the table above.
//
// Note that if @gvalue is of type TYPE_VARIANT and its value is nil, the empty
// #GVariant instance (never nil) for @type is returned (e.g. 0 for scalar
// types, the empty string for string types, '/' for object path types, the
// empty array for any array type and so on).
//
// See the g_dbus_gvariant_to_gvalue() function for how to convert a #GVariant
// to a #GValue.
func DbusGvalueToGvariant(gvalue *externglib.Value, _type *glib.VariantType) *glib.Variant

// DbusGvariantToGvalue: converts a #GVariant to a #GValue. If @value is
// floating, it is consumed.
//
// The rules specified in the g_dbus_gvalue_to_gvariant() function are used -
// this function is essentially its reverse form. So, a #GVariant containing any
// basic or string array type will be converted to a #GValue containing a basic
// value or string array. Any other #GVariant (handle, variant, tuple, dict
// entry) will be converted to a #GValue containing that #GVariant.
//
// The conversion never fails - a valid #GValue is always returned in
// @out_gvalue.
func DbusGvariantToGvalue(value *glib.Variant) externglib.Value

// DbusIsAddress: checks if @string is a [D-Bus
// address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This doesn't check if @string is actually supported by BusServer or
// BusConnection - use g_dbus_is_supported_address() to do more checks.
func DbusIsAddress(string string) bool

// DbusIsGuid: checks if @string is a D-Bus GUID.
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DbusIsGuid(string string) bool

// DbusIsInterfaceName: checks if @string is a valid D-Bus interface name.
func DbusIsInterfaceName(string string) bool

// DbusIsMemberName: checks if @string is a valid D-Bus member (e.g. signal or
// method) name.
func DbusIsMemberName(string string) bool

// DbusIsName: checks if @string is a valid D-Bus bus name (either unique or
// well-known).
func DbusIsName(string string) bool

// DbusIsSupportedAddress: like g_dbus_is_address() but also checks if the
// library supports the transports in @string and that key/value pairs for each
// transport are valid. See the specification of the [D-Bus address
// format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DbusIsSupportedAddress(string string) bool

// DbusIsUniqueName: checks if @string is a valid D-Bus unique bus name.
func DbusIsUniqueName(string string) bool

// NewDtlsClientConnection: creates a new ClientConnection wrapping @base_socket
// which is assumed to communicate with the server identified by
// @server_identity.
func NewDtlsClientConnection(baseSocket DtlsClientConnection, serverIdentity SocketConnectable) DtlsClientConnection

// NewDtlsServerConnection: creates a new ServerConnection wrapping
// @base_socket.
func NewDtlsServerConnection(baseSocket DtlsClientConnection, certificate *TlsCertificate) DtlsClientConnection

// FileNewForCommandlineArg: creates a #GFile with the given argument from the
// command line. The value of @arg can be either a URI, an absolute path or a
// relative path resolved relative to the current working directory. This
// operation never fails, but the returned object might not support any I/O
// operation if @arg points to a malformed path.
//
// Note that on Windows, this function expects its argument to be in UTF-8 --
// not the system code page. This means that you should not use this function
// with string from argv as it is passed to main(). g_win32_get_command_line()
// will return a UTF-8 version of the commandline. #GApplication also uses UTF-8
// but g_application_command_line_create_file_for_arg() may be more useful for
// you there. It is also always possible to use this function with Context
// arguments of type G_OPTION_ARG_FILENAME.
func FileNewForCommandlineArg(arg string) File

// FileNewForCommandlineArgAndCwd: creates a #GFile with the given argument from
// the command line.
//
// This function is similar to g_file_new_for_commandline_arg() except that it
// allows for passing the current working directory as an argument instead of
// using the current working directory of the process.
//
// This is useful if the commandline argument was given in a context other than
// the invocation of the current process.
//
// See also g_application_command_line_create_file_for_arg().
func FileNewForCommandlineArgAndCwd(arg string, cwd string) File

// FileNewForPath: constructs a #GFile for a given path. This operation never
// fails, but the returned object might not support any I/O operation if @path
// is malformed.
func FileNewForPath(path string) File

// FileNewForURI: constructs a #GFile for a given URI. This operation never
// fails, but the returned object might not support any I/O operation if @uri is
// malformed or if the uri type is not supported.
func FileNewForURI(uri string) File

// FileNewTmp: opens a file in the preferred directory for temporary files (as
// returned by g_get_tmp_dir()) and returns a #GFile and IOStream pointing to
// it.
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, and containing no directory components. If it is nil,
// a default template is used.
//
// Unlike the other #GFile constructors, this will return nil if a temporary
// file could not be created.
func FileNewTmp(tmpl string) (*FileIOStream, File)

// FileParseName: constructs a #GFile with the given @parse_name (i.e. something
// given by g_file_get_parse_name()). This operation never fails, but the
// returned object might not support any I/O operation if the @parse_name cannot
// be parsed.
func FileParseName(parseName string) File

// IconDeserialize: deserializes a #GIcon previously serialized using
// g_icon_serialize().
func IconDeserialize(value *glib.Variant) Icon

// IconHash: gets a hash for an icon.
func IconHash(icon unsafe.Pointer) uint

// IconNewForString: generate a #GIcon instance from @str. This function can
// fail if @str is not valid - see g_icon_to_string() for discussion.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that each #GType is registered with the type system prior
// to calling g_icon_new_for_string().
func IconNewForString(str string) Icon

// IOErrorFromErrno: converts errno.h error codes into GIO error codes. The
// fallback value G_IO_ERROR_FAILED is returned for error codes not currently
// handled (but note that future GLib releases may return a more specific value
// instead).
//
// As errno is global and may be modified by intermediate function calls, you
// should save its value as soon as the call which sets it
func IOErrorFromErrno(errNo int) IOErrorEnum

// IOErrorQuark: gets the GIO Error Quark.
func IOErrorQuark() glib.Quark

// IOExtensionPointImplement: registers @type as extension for the extension
// point with name @extension_point_name.
//
// If @type has already been registered as an extension for this extension
// point, the existing OExtension object is returned.
func IOExtensionPointImplement(extensionPointName string, _type externglib.Type, extensionName string, priority int) *IOExtension

// IOExtensionPointLookup: looks up an existing extension point.
func IOExtensionPointLookup(name string) *IOExtensionPoint

// IOExtensionPointRegister: registers an extension point.
func IOExtensionPointRegister(name string) *IOExtensionPoint

// IOModulesLoadAllInDirectory: loads all the modules in the specified
// directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectory(dirname string) *glib.List

// IOModulesLoadAllInDirectoryWithScope: loads all the modules in the specified
// directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectoryWithScope(dirname string, scope *IOModuleScope) *glib.List

// IOModulesScanAllInDirectory: scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectory(dirname string)

// IOModulesScanAllInDirectoryWithScope: scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope)

// IOSchedulerCancelAllJobs: cancels all cancellable I/O jobs.
//
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
func IOSchedulerCancelAllJobs()

// IOSchedulerPushJob: schedules the I/O job to run in another thread.
//
// @notify will be called on @user_data after @job_func has returned, regardless
// whether the job was cancelled or has run to completion.
//
// If @cancellable is not nil, it can be used to cancel the I/O job by calling
// g_cancellable_cancel() or by calling g_io_scheduler_cancel_all_jobs().
func IOSchedulerPushJob(jobFunc IOSchedulerJobFunc, userData unsafe.Pointer, notify unsafe.Pointer, ioPriority int, cancellable *Cancellable)

// NewKeyfileSettingsBackend: creates a keyfile-backed Backend.
//
// The filename of the keyfile to use is given by @filename.
//
// All settings read to or written from the backend must fall under the path
// given in @root_path (which must start and end with a slash and not contain
// two consecutive slashes). @root_path may be "/".
//
// If @root_group is non-nil then it specifies the name of the keyfile group
// used for keys that are written directly below @root_path. For example, if
// @root_path is "/apps/example/" and @root_group is "toplevel", then settings
// the key "/apps/example/enabled" to a value of true will cause the following
// to appear in the keyfile:
//
//
//      [toplevel]
//      enabled=true
//
// If @root_group is nil then it is not permitted to store keys directly below
// the @root_path.
//
// For keys not stored directly below @root_path (ie: in a sub-path), the name
// of the subpath (with the final slash stripped) is used as the name of the
// keyfile group. To continue the example, if
// "/apps/example/profiles/default/font-size" were set to 12 then the following
// would appear in the keyfile:
//
//
//      [profiles/default]
//      font-size=12
//
// The backend will refuse writes (and return writability as being false) for
// keys outside of @root_path and, in the event that @root_group is nil, also
// for keys directly under @root_path. Writes will also be refused if the
// backend detects that it has the inability to rewrite the keyfile (ie: the
// containing directory is not writable).
//
// There is no checking done for your key namespace clashing with the syntax of
// the key file format. For example, if you have '[' or ']' characters in your
// path names or '=' in your key names you may be in trouble.
//
// The backend reads default values from a keyfile called `defaults` in the
// directory specified by the SettingsBackend:defaults-dir property, and a list
// of locked keys from a text file with the name `locks` in the same location.
func NewKeyfileSettingsBackend(filename string, rootPath string, rootGroup string) *SettingsBackend

// MemoryMonitorDupDefault: gets a reference to the default Monitor for the
// system.
func MemoryMonitorDupDefault() MemoryMonitor

// NewMemorySettingsBackend: creates a memory-backed Backend.
//
// This backend allows changes to settings, but does not write them to any
// backing storage, so the next time you run your application, the memory
// backend will start out with the default values again.
func NewMemorySettingsBackend() *SettingsBackend

// NetworkMonitorGetDefault: gets the default Monitor for the system.
func NetworkMonitorGetDefault() NetworkMonitor

// NetworkingInit: initializes the platform networking libraries (eg, on
// Windows, this calls WSAStartup()). GLib will call this itself if it is
// needed, so you only need to call it if you directly call system networking
// functions (without calling any GLib networking functions first).
func NetworkingInit()

// NewNullSettingsBackend: creates a readonly Backend.
//
// This backend does not allow changes to settings, so all settings will always
// have their default values.
func NewNullSettingsBackend() *SettingsBackend

// NewPollableSource: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource that expects a callback of type
// SourceFunc. The new source does not actually do anything on its own; use
// g_source_add_child_source() to add other sources to it to cause it to
// trigger.
func NewPollableSource(pollableStream *externglib.Object) *glib.Source

// PollableSourceNewFull: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource, as with g_pollable_source_new(), but
// also attaching @child_source (with a dummy callback), and @cancellable, if
// they are non-nil.
func PollableSourceNewFull(pollableStream unsafe.Pointer, childSource *glib.Source, cancellable *Cancellable) *glib.Source

// PollableStreamRead: tries to read from @stream, as with g_input_stream_read()
// (if @blocking is true) or g_pollable_input_stream_read_nonblocking() (if
// @blocking is false). This can be used to more easily share code between
// blocking and non-blocking implementations of a method.
//
// If @blocking is false, then @stream must be a InputStream for which
// g_pollable_input_stream_can_poll() returns true, or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// InputStream.
func PollableStreamRead(stream *InputStream, buffer []uint8, count uint, blocking bool, cancellable *Cancellable) int

// PollableStreamWrite: tries to write to @stream, as with
// g_output_stream_write() (if @blocking is true) or
// g_pollable_output_stream_write_nonblocking() (if @blocking is false). This
// can be used to more easily share code between blocking and non-blocking
// implementations of a method.
//
// If @blocking is false, then @stream must be a OutputStream for which
// g_pollable_output_stream_can_poll() returns true or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// OutputStream.
func PollableStreamWrite(stream *OutputStream, buffer []uint8, count uint, blocking bool, cancellable *Cancellable) int

// PollableStreamWriteAll: tries to write @count bytes to @stream, as with
// g_output_stream_write_all(), but using g_pollable_stream_write() rather than
// g_output_stream_write().
//
// On a successful write of @count bytes, true is returned, and @bytes_written
// is set to @count.
//
// If there is an error during the operation (including G_IO_ERROR_WOULD_BLOCK
// in the non-blocking case), false is returned and @error is set to indicate
// the error status, @bytes_written is updated to contain the number of bytes
// written into the stream before the error occurred.
//
// As with g_pollable_stream_write(), if @blocking is false, then @stream must
// be a OutputStream for which g_pollable_output_stream_can_poll() returns true
// or else the behavior is undefined. If @blocking is true, then @stream does
// not need to be a OutputStream.
func PollableStreamWriteAll(stream *OutputStream, buffer []uint8, count uint, blocking bool, cancellable *Cancellable) (uint, bool)

// ProxyGetDefaultForProtocol: find the `gio-proxy` extension point for a proxy
// implementation that supports the specified protocol.
func ProxyGetDefaultForProtocol(protocol string) Proxy

// ProxyResolverGetDefault: gets the default Resolver for the system.
func ProxyResolverGetDefault() ProxyResolver

// ResolverErrorQuark: gets the #GResolver Error Quark.
func ResolverErrorQuark() glib.Quark

// ResourceErrorQuark: gets the #GResource Error Quark.
func ResourceErrorQuark() glib.Quark

// ResourceLoad: loads a binary resource bundle and creates a #GResource
// representation of it, allowing you to query it for data.
//
// If you want to use this resource in the global resource namespace you need to
// register it with g_resources_register().
//
// If @filename is empty or the data in it is corrupt, G_RESOURCE_ERROR_INTERNAL
// will be returned. If @filename doesnt exist, or there is an error in reading
// it, an error from g_mapped_file_new() will be returned.
func ResourceLoad(filename string) *Resource

// ResourcesEnumerateChildren: returns all the names of children at the
// specified @path in the set of globally registered resources. The return
// result is a nil terminated list of strings which should be released with
// g_strfreev().
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) []string

// ResourcesGetInfo: looks for a file at the specified @path in the set of
// globally registered resources and if found returns information about it.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (uint, uint32, bool)

// ResourcesLookupData: looks for a file at the specified @path in the set of
// globally registered resources and returns a #GBytes that lets you directly
// access the data in memory.
//
// The data is always followed by a zero byte, so you can safely use the data as
// a C string. However, that byte is not included in the size of the GBytes.
//
// For uncompressed resource files this is a pointer directly into the resource
// bundle, which is typically in some readonly data section in the program
// binary. For compressed files we allocate memory on the heap and automatically
// uncompress the data.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesLookupData(path string, lookupFlags ResourceLookupFlags) *glib.Bytes

// ResourcesOpenStream: looks for a file at the specified @path in the set of
// globally registered resources and returns a Stream that lets you read the
// data.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) *InputStream

// ResourcesRegister: registers the resource with the process-global set of
// resources. Once a resource is registered the files in it can be accessed with
// the global resource lookup functions like g_resources_lookup_data().
func ResourcesRegister(resource *Resource)

// ResourcesUnregister: unregisters the resource from the process-global set of
// resources.
func ResourcesUnregister(resource *Resource)

// SettingsSchemaSourceGetDefault: gets the default system schema source.
//
// This function is not required for normal uses of #GSettings but it may be
// useful to authors of plugin management systems or to those who want to
// introspect the content of schemas.
//
// If no schemas are installed, nil will be returned.
//
// The returned source may actually consist of multiple schema sources from
// different directories, depending on which directories were given in
// `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all lookups
// performed against the default source should probably be done recursively.
func SettingsSchemaSourceGetDefault() *SettingsSchemaSource

// SimpleAsyncReportGerrorInIdle: reports an error in an idle function. Similar
// to g_simple_async_report_error_in_idle(), but takes a #GError rather than
// building a new one.
func SimpleAsyncReportGerrorInIdle(object *externglib.Object, callback AsyncReadyCallback, userData unsafe.Pointer, error *glib.Error)

// SimpleAsyncReportTakeGerrorInIdle: reports an error in an idle function.
// Similar to g_simple_async_report_gerror_in_idle(), but takes over the
// caller's ownership of @error, so the caller does not have to free it any
// more.
func SimpleAsyncReportTakeGerrorInIdle(object *externglib.Object, callback AsyncReadyCallback, userData unsafe.Pointer, error *glib.Error)

// SrvTargetListSort: sorts @targets in place according to the algorithm in RFC
// 2782.
func SrvTargetListSort(targets *glib.List) *glib.List

// TlsBackendGetDefault: gets the default Backend for the system.
func TlsBackendGetDefault() TlsBackend

// TlsChannelBindingErrorQuark: gets the TLS channel binding error quark.
func TlsChannelBindingErrorQuark() glib.Quark

// NewTlsClientConnection: creates a new ClientConnection wrapping
// @base_io_stream (which must have pollable input and output streams) which is
// assumed to communicate with the server identified by @server_identity.
//
// See the documentation for Connection:base-io-stream for restrictions on when
// application code can run operations on the @base_io_stream after this
// function has returned.
func NewTlsClientConnection(baseIOStream *IOStream, serverIdentity SocketConnectable) *IOStream

// TlsErrorQuark: gets the TLS error quark.
func TlsErrorQuark() glib.Quark

// NewTlsFileDatabase: creates a new FileDatabase which uses anchor certificate
// authorities in @anchors to verify certificate chains.
//
// The certificates in @anchors must be PEM encoded.
func NewTlsFileDatabase(anchors string) TlsFileDatabase

// NewTlsServerConnection: creates a new ServerConnection wrapping
// @base_io_stream (which must have pollable input and output streams).
//
// See the documentation for Connection:base-io-stream for restrictions on when
// application code can run operations on the @base_io_stream after this
// function has returned.
func NewTlsServerConnection(baseIOStream *IOStream, certificate *TlsCertificate) *IOStream

// UnixIsMountPathSystemInternal: determines if @mount_path is considered an
// implementation of the OS. This is primarily used for hiding mountable and
// mounted volumes that only are used in the OS and has little to no relevance
// to the casual user.
func UnixIsMountPathSystemInternal(mountPath string) bool

// UnixIsSystemDevicePath: determines if @device_path is considered a block
// device path which is only used in implementation of the OS. This is primarily
// used for hiding mounted volumes that are intended as APIs for programs to
// read, and system administrators at a shell; rather than something that
// should, for example, appear in a GUI. For example, the Linux `/proc`
// filesystem.
//
// The list of device paths considered system ones may change over time.
func UnixIsSystemDevicePath(devicePath string) bool

// UnixIsSystemFsType: determines if @fs_type is considered a type of file
// system which is only used in implementation of the OS. This is primarily used
// for hiding mounted volumes that are intended as APIs for programs to read,
// and system administrators at a shell; rather than something that should, for
// example, appear in a GUI. For example, the Linux `/proc` filesystem.
//
// The list of file system types considered system ones may change over time.
func UnixIsSystemFsType(fsType string) bool

// UnixMountAt: gets a MountEntry for a given mount path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountAt(mountPath string) (uint64, *UnixMountEntry)

// UnixMountCompare: compares two unix mounts.
func UnixMountCompare(mount1 *UnixMountEntry, mount2 *UnixMountEntry) int

// UnixMountCopy: makes a copy of @mount_entry.
func UnixMountCopy(mountEntry *UnixMountEntry) *UnixMountEntry

// UnixMountFor: gets a MountEntry for a given file path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountFor(filePath string) (uint64, *UnixMountEntry)

// UnixMountFree: frees a unix mount.
func UnixMountFree(mountEntry *UnixMountEntry)

// UnixMountGetDevicePath: gets the device path for a unix mount.
func UnixMountGetDevicePath(mountEntry *UnixMountEntry) string

// UnixMountGetFsType: gets the filesystem type for the unix mount.
func UnixMountGetFsType(mountEntry *UnixMountEntry) string

// UnixMountGetMountPath: gets the mount path for a unix mount.
func UnixMountGetMountPath(mountEntry *UnixMountEntry) string

// UnixMountGetOptions: gets a comma-separated list of mount options for the
// unix mount. For example, `rw,relatime,seclabel,data=ordered`.
//
// This is similar to g_unix_mount_point_get_options(), but it takes a
// MountEntry as an argument.
func UnixMountGetOptions(mountEntry *UnixMountEntry) string

// UnixMountGetRootPath: gets the root of the mount within the filesystem. This
// is useful e.g. for mounts created by bind operation, or btrfs subvolumes.
//
// For example, the root path is equal to "/" for mount created by "mount
// /dev/sda1 /mnt/foo" and "/bar" for "mount --bind /mnt/foo/bar /mnt/bar".
func UnixMountGetRootPath(mountEntry *UnixMountEntry) string

// UnixMountGuessCanEject: guesses whether a Unix mount can be ejected.
func UnixMountGuessCanEject(mountEntry *UnixMountEntry) bool

// UnixMountGuessIcon: guesses the icon of a Unix mount.
func UnixMountGuessIcon(mountEntry *UnixMountEntry) Icon

// UnixMountGuessName: guesses the name of a Unix mount. The result is a
// translated string.
func UnixMountGuessName(mountEntry *UnixMountEntry) string

// UnixMountGuessShouldDisplay: guesses whether a Unix mount should be displayed
// in the UI.
func UnixMountGuessShouldDisplay(mountEntry *UnixMountEntry) bool

// UnixMountGuessSymbolicIcon: guesses the symbolic icon of a Unix mount.
func UnixMountGuessSymbolicIcon(mountEntry *UnixMountEntry) Icon

// UnixMountIsReadonly: checks if a unix mount is mounted read only.
func UnixMountIsReadonly(mountEntry *UnixMountEntry) bool

// UnixMountIsSystemInternal: checks if a Unix mount is a system mount. This is
// the Boolean OR of g_unix_is_system_fs_type(), g_unix_is_system_device_path()
// and g_unix_is_mount_path_system_internal() on @mount_entrys properties.
//
// The definition of what a system mount entry is may change over time as new
// file system types and device paths are ignored.
func UnixMountIsSystemInternal(mountEntry *UnixMountEntry) bool

// UnixMountPointAt: gets a MountPoint for a given mount path. If @time_read is
// set, it will be filled with a unix timestamp for checking if the mount points
// have changed since with g_unix_mount_points_changed_since().
//
// If more mount points have the same mount path, the last matching mount point
// is returned.
func UnixMountPointAt(mountPath string) (uint64, *UnixMountPoint)

// UnixMountPointsChangedSince: checks if the unix mount points have changed
// since a given unix time.
func UnixMountPointsChangedSince(time uint64) bool

// UnixMountPointsGet: gets a #GList of MountPoint containing the unix mount
// points. If @time_read is set, it will be filled with the mount timestamp,
// allowing for checking if the mounts have changed with
// g_unix_mount_points_changed_since().
func UnixMountPointsGet() (uint64, *glib.List)

// UnixMountsChangedSince: checks if the unix mounts have changed since a given
// unix time.
func UnixMountsChangedSince(time uint64) bool

// UnixMountsGet: gets a #GList of MountEntry containing the unix mounts. If
// @time_read is set, it will be filled with the mount timestamp, allowing for
// checking if the mounts have changed with g_unix_mounts_changed_since().
func UnixMountsGet() (uint64, *glib.List)

// #GAction represents a single named action
//
// The main interface to an action is that it can be activated with
// g_action_activate(). This results in the 'activate' signal being emitted. An
// activation has a #GVariant parameter (which may be nil). The correct type for
// the parameter is determined by a static parameter type (which is given at
// construction time).
//
// An action may optionally have a state, in which case the state may be set
// with g_action_change_state(). This call takes a #GVariant. The correct type
// for the state is determined by a static state type (which is given at
// construction time).
//
// The state may have a hint associated with it, specifying its valid range.
//
// #GAction is merely the interface to the concept of an action, as described
// above. Various implementations of actions exist, including Action
//
// In all cases, the implementing class is responsible for storing the name of
// the action, the parameter type, the enabled state, the optional state type
// and the state and emitting the appropriate signals when these change. The
// implementor is responsible for filtering calls to g_action_activate() and
// g_action_change_state() for type safety and for the state being enabled.
//
// Probably the only useful thing to do with a #GAction is to put it inside of a
// ActionGroup.
type Action interface {
	Activate(parameter *glib.Variant)
	ChangeState(value *glib.Variant)
	GetEnabled() bool
	GetName() string
	GetParameterType() *glib.VariantType
	GetState() *glib.Variant
	GetStateHint() *glib.Variant
	GetStateType() *glib.VariantType
}

// ActionGroup: group represents a group of actions. Actions can be used to
// expose functionality in a structured way, either from one part of a program
// to another, or to the outside world. Action groups are often used together
// with a Model that provides additional representation data for displaying the
// actions to the user, e.g. in a menu.
//
// The main way to interact with the actions in a GActionGroup is to activate
// them with g_action_group_activate_action(). Activating an action may require
// a #GVariant parameter. The required type of the parameter can be inquired
// with g_action_group_get_action_parameter_type(). Actions may be disabled, see
// g_action_group_get_action_enabled(). Activating a disabled action has no
// effect.
//
// Actions may optionally have a state in the form of a #GVariant. The current
// state of an action can be inquired with g_action_group_get_action_state().
// Activating a stateful action may change its state, but it is also possible to
// set the state by calling g_action_group_change_action_state().
//
// As typical example, consider a text editing application which has an option
// to change the current font to 'bold'. A good way to represent this would be a
// stateful action, with a boolean state. Activating the action would toggle the
// state.
//
// Each action in the group has a unique name (which is a string). All method
// calls, except g_action_group_list_actions() take the name of an action as an
// argument.
//
// The Group API is meant to be the 'public' API to the action group. The calls
// here are exactly the interaction that 'external forces' (eg: UI, incoming
// D-Bus messages, etc.) are supposed to have with actions. 'Internal' APIs (ie:
// ones meant only to be accessed by the action group implementation) are found
// on subclasses. This is why you will find - for example -
// g_action_group_get_action_enabled() but not an equivalent set() call.
//
// Signals are emitted on the action group in response to state changes on
// individual actions.
//
// Implementations of Group should provide implementations for the virtual
// functions g_action_group_list_actions() and g_action_group_query_action().
// The other virtual functions should not be implemented - their "wrappers" are
// actually implemented with calls to g_action_group_query_action().
type ActionGroup interface {
	ActionAdded(actionName string)
	ActionEnabledChanged(actionName string, enabled bool)
	ActionRemoved(actionName string)
	ActionStateChanged(actionName string, state *glib.Variant)
	ActivateAction(actionName string, parameter *glib.Variant)
	ChangeActionState(actionName string, value *glib.Variant)
	GetActionEnabled(actionName string) bool
	GetActionParameterType(actionName string) *glib.VariantType
	GetActionState(actionName string) *glib.Variant
	GetActionStateHint(actionName string) *glib.Variant
	GetActionStateType(actionName string) *glib.VariantType
	HasAction(actionName string) bool
	ListActions() []string
	QueryAction(actionName string) (bool, *glib.VariantType, *glib.VariantType, *glib.Variant, *glib.Variant, bool)
}

// ActionMap: the GActionMap interface is implemented by Group implementations
// that operate by containing a number of named #GAction instances, such as
// ActionGroup.
//
// One useful application of this interface is to map the names of actions from
// various action groups to unique, prefixed names (e.g. by prepending "app." or
// "win."). This is the motivation for the 'Map' part of the interface name.
type ActionMap interface {
	AddAction(action Action)
	AddActionEntries(entries []ActionEntry, nEntries int, userData unsafe.Pointer)
	LookupAction(actionName string) Action
	RemoveAction(actionName string)
}

// AppInfo: info and LaunchContext are used for describing and launching
// applications installed on the system.
//
// As of GLib 2.20, URIs will always be converted to POSIX paths (using
// g_file_get_path()) when using g_app_info_launch() even if the application
// requested an URI and not a POSIX path. For example for a desktop-file based
// application with Exec key `totem U` and a single URI, `sftp://foo/file.avi`,
// then `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only
// work if a set of suitable GIO extensions (such as gvfs 2.26 compiled with
// FUSE support), is available and operational; if this is not the case, the URI
// will be passed unmodified to the application. Some URIs, such as `mailto:`,
// of course cannot be mapped to a POSIX path (in gvfs there's no FUSE mount for
// it); such URIs will be passed unmodified to the application.
//
// Specifically for gvfs 2.26 and later, the POSIX URI will be mapped back to
// the GIO URI in the #GFile constructors (since gvfs implements the #GVfs
// extension point). As such, if the application needs to examine the URI, it
// needs to use g_file_get_uri() or similar on #GFile. In other words, an
// application cannot assume that the URI passed to e.g.
// g_file_new_for_commandline_arg() is equal to the result of g_file_get_uri().
// The following snippet illustrates this:
//
//
//    GFile *f;
//    char *uri;
//
//    file = g_file_new_for_commandline_arg (uri_from_commandline);
//
//    uri = g_file_get_uri (file);
//    strcmp (uri, uri_from_commandline) == 0;
//    g_free (uri);
//
//    if (g_file_has_uri_scheme (file, "cdda"))
//      {
//        // do something special with uri
//      }
//    g_object_unref (file);
//
//
// This code will work when both `cdda://sr0/Track 1.wav` and
// `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the application. It
// should be noted that it's generally not safe for applications to rely on the
// format of a particular URIs. Different launcher applications (e.g. file
// managers) may have different ideas of what a given URI means.
type AppInfo interface {
	AddSupportsType(contentType string) bool
	CanDelete() bool
	CanRemoveSupportsType() bool
	Delete() bool
	Dup() AppInfo
	Equal(appinfo2 AppInfo) bool
	GetCommandline() string
	GetDescription() string
	GetDisplayName() string
	GetExecutable() string
	GetIcon() Icon
	GetID() string
	GetName() string
	GetSupportedTypes() []string
	Launch(files *glib.List, context *AppLaunchContext) bool
	LaunchUris(uris *glib.List, context *AppLaunchContext) bool
	LaunchUrisAsync(uris *glib.List, context *AppLaunchContext, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	LaunchUrisFinish(result AsyncResult) bool
	RemoveSupportsType(contentType string) bool
	SetAsDefaultForExtension(extension string) bool
	SetAsDefaultForType(contentType string) bool
	SetAsLastUsedForType(contentType string) bool
	ShouldShow() bool
	SupportsFiles() bool
	SupportsUris() bool
}

// AsyncInitable: this is the asynchronous version of #GInitable; it behaves the
// same in all ways except that initialization is asynchronous. For more details
// see the descriptions on #GInitable.
//
// A class may implement both the #GInitable and Initable interfaces.
//
// Users of objects implementing this are not intended to use the interface
// method directly; instead it will be used automatically in various ways. For C
// applications you generally just call g_async_initable_new_async() directly,
// or indirectly via a foo_thing_new_async() wrapper. This will call
// g_async_initable_init_async() under the cover, calling back with nil and a
// set GError on failure.
//
// A typical implementation might look something like this:
//
//    enum {
//       NOT_INITIALIZED,
//       INITIALIZING,
//       INITIALIZED
//    };
//
//    static void
//    _foo_ready_cb (Foo *self)
//    {
//      GList *l;
//
//      self->priv->state = INITIALIZED;
//
//      for (l = self->priv->init_results; l != NULL; l = l->next)
//        {
//          GTask *task = l->data;
//
//          if (self->priv->success)
//            g_task_return_boolean (task, TRUE);
//          else
//            g_task_return_new_error (task, ...);
//          g_object_unref (task);
//        }
//
//      g_list_free (self->priv->init_results);
//      self->priv->init_results = NULL;
//    }
//
//    static void
//    foo_init_async (GAsyncInitable       *initable,
//                    int                   io_priority,
//                    GCancellable         *cancellable,
//                    GAsyncReadyCallback   callback,
//                    gpointer              user_data)
//    {
//      Foo *self = FOO (initable);
//      GTask *task;
//
//      task = g_task_new (initable, cancellable, callback, user_data);
//      g_task_set_name (task, G_STRFUNC);
//
//      switch (self->priv->state)
//        {
//          case NOT_INITIALIZED:
//            _foo_get_ready (self);
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            self->priv->state = INITIALIZING;
//            break;
//          case INITIALIZING:
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            break;
//          case INITIALIZED:
//            if (!self->priv->success)
//              g_task_return_new_error (task, ...);
//            else
//              g_task_return_boolean (task, TRUE);
//            g_object_unref (task);
//            break;
//        }
//    }
//
//    static gboolean
//    foo_init_finish (GAsyncInitable       *initable,
//                     GAsyncResult         *result,
//                     GError              **error)
//    {
//      g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
//
//      return g_task_propagate_boolean (G_TASK (result), error);
//    }
//
//    static void
//    foo_async_initable_iface_init (gpointer g_iface,
//                                   gpointer data)
//    {
//      GAsyncInitableIface *iface = g_iface;
//
//      iface->init_async = foo_init_async;
//      iface->init_finish = foo_init_finish;
//    }
//
type AsyncInitable interface {
	InitAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	InitFinish(res AsyncResult) bool
	NewFinish(res AsyncResult) *externglib.Object
}

// AsyncResult: provides a base class for implementing asynchronous function
// results.
//
// Asynchronous operations are broken up into two separate operations which are
// chained together by a ReadyCallback. To begin an asynchronous operation,
// provide a ReadyCallback to the asynchronous function. This callback will be
// triggered when the operation has completed, and must be run in a later
// iteration of the [thread-default main
// context][g-main-context-push-thread-default] from where the operation was
// initiated. It will be passed a Result instance filled with the details of the
// operation's success or failure, the object the asynchronous function was
// started for and any error codes returned. The asynchronous callback function
// is then expected to call the corresponding "_finish()" function, passing the
// object the function was called for, the Result instance, and (optionally) an
// @error to grab any error conditions that may have occurred.
//
// The "_finish()" function for an operation takes the generic result (of type
// Result) and returns the specific result that the operation in question yields
// (e.g. a Enumerator for a "enumerate children" operation). If the result or
// error status of the operation is not needed, there is no need to call the
// "_finish()" function; GIO will take care of cleaning up the result and error
// information after the ReadyCallback returns. You can pass nil for the
// ReadyCallback if you don't need to take any action at all after the operation
// completes. Applications may also take a reference to the Result and call
// "_finish()" later; however, the "_finish()" function may be called at most
// once.
//
// Example of a typical asynchronous operation flow: |[<!-- language="C" -->
// void _theoretical_frobnitz_async (Theoretical *t, GCancellable *c,
// GAsyncReadyCallback cb, gpointer u);
//
// gboolean _theoretical_frobnitz_finish (Theoretical *t, GAsyncResult *res,
// GError **e);
//
// static void frobnitz_result_func (GObject *source_object, GAsyncResult *res,
// gpointer user_data) { gboolean success = FALSE;
//
// success = _theoretical_frobnitz_finish (source_object, res, NULL);
//
// if (success) g_printf ("Hurray!\n"); else g_printf ("Uh oh!\n");
//
// ...
//
// }
//
// int main (int argc, void *argv[]) { ...
//
// _theoretical_frobnitz_async (theoretical_data, NULL, frobnitz_result_func,
// NULL);
//
//       ...
//    }
//
//
//    The callback for an asynchronous operation is called only once, and is
//    always called, even in the case of a cancelled operation. On cancellation
//    the result is a G_IO_ERROR_CANCELLED error.
//
//    ## I/O Priority # {#io-priority}
//
//    Many I/O-related asynchronous operations have a priority parameter,
//    which is used in certain cases to determine the order in which
//    operations are executed. They are not used to determine system-wide
//    I/O scheduling. Priorities are integers, with lower numbers indicating
//    higher priority. It is recommended to choose priorities between
//    G_PRIORITY_LOW and G_PRIORITY_HIGH, with G_PRIORITY_DEFAULT
//    as a default.
type AsyncResult interface {
	GetSourceObject() *externglib.Object
	GetUserData() unsafe.Pointer
	IsTagged(sourceTag unsafe.Pointer) bool
	LegacyPropagateError() bool
}

// Converter is implemented by objects that convert binary data in various ways.
// The conversion can be stateful and may fail at any place.
//
// Some example conversions are: character set conversion, compression,
// decompression and regular expression replace.
type Converter interface {
	Convert(inbuf []uint8, inbufSize uint, outbuf []uint8, outbufSize uint, flags ConverterFlags) (uint, uint, ConverterResult)
	Reset()
}

// DBusInterface: the BusInterface type is the base type for D-Bus interfaces
// both on the service side (see BusInterfaceSkeleton) and client side (see
// BusProxy).
type DBusInterface interface {
	DupObject() DBusObject
	GetInfo() *DBusInterfaceInfo
	GetObject() DBusObject
	SetObject(object DBusObject)
}

// DBusObject: the BusObject type is the base type for D-Bus objects on both the
// service side (see BusObjectSkeleton) and the client side (see
// BusObjectProxy). It is essentially just a container of interfaces.
type DBusObject interface {
	GetInterface(interfaceName string) DBusInterface
	GetInterfaces() *glib.List
	GetObjectPath() string
}

// DBusObjectManager: the BusObjectManager type is the base type for service-
// and client-side implementations of the standardized
// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface.
//
// See BusObjectManagerClient for the client-side implementation and
// BusObjectManagerServer for the service-side implementation.
type DBusObjectManager interface {
	GetInterface(objectPath string, interfaceName string) DBusInterface
	GetObject(objectPath string) DBusObject
	GetObjectPath() string
	GetObjects() *glib.List
}

// DatagramBased: a Based is a networking interface for representing
// datagram-based communications. It is a more or less direct mapping of the
// core parts of the BSD socket API in a portable GObject interface. It is
// implemented by #GSocket, which wraps the UNIX socket API on UNIX and winsock2
// on Windows.
//
// Based is entirely platform independent, and is intended to be used alongside
// higher-level networking APIs such as OStream.
//
// It uses vectored scatter/gather I/O by default, allowing for many messages to
// be sent or received in a single call. Where possible, implementations of the
// interface should take advantage of vectored I/O to minimise processing or
// system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
// possible. Callers should take advantage of scatter/gather I/O (the use of
// multiple buffers per message) to avoid unnecessary copying of data to
// assemble or disassemble a message.
//
// Each Based operation has a timeout parameter which may be negative for
// blocking behaviour, zero for non-blocking behaviour, or positive for timeout
// behaviour. A blocking operation blocks until finished or there is an error. A
// non-blocking operation will return immediately with a G_IO_ERROR_WOULD_BLOCK
// error if it cannot make progress. A timeout operation will block until the
// operation is complete or the timeout expires; if the timeout expires it will
// return what progress it made, or G_IO_ERROR_TIMED_OUT if no progress was
// made. To know when a call would successfully run you can call
// g_datagram_based_condition_check() or g_datagram_based_condition_wait(). You
// can also use g_datagram_based_create_source() and attach it to a Context to
// get callbacks when I/O is possible.
//
// When running a non-blocking operation applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// As with #GSocket, Baseds can be either connection oriented (for example,
// SCTP) or connectionless (for example, UDP). Baseds must be datagram-based,
// not stream-based. The interface does not cover connection establishment  use
// methods on the underlying type to establish a connection before sending and
// receiving data through the Based API. For connectionless socket types the
// target/source address is specified or received in each I/O operation.
//
// Like most other APIs in GLib, Based is not inherently thread safe. To use a
// Based concurrently from multiple threads, you must implement your own
// locking.
type DatagramBased interface {
	ConditionCheck(condition glib.IOCondition) glib.IOCondition
	ConditionWait(condition glib.IOCondition, timeout int64, cancellable *Cancellable) bool
	CreateSource(condition glib.IOCondition, cancellable *Cancellable) *glib.Source
	ReceiveMessages(messages []InputMessage, numMessages uint, flags int, timeout int64, cancellable *Cancellable) int
	SendMessages(messages []OutputMessage, numMessages uint, flags int, timeout int64, cancellable *Cancellable) int
}

// DesktopAppInfoLookup is an opaque data structure and can only be accessed
// using the following functions.
type DesktopAppInfoLookup interface {
	GetDefaultForURIScheme(uriScheme string) AppInfo
}

// #GDrive - this represent a piece of hardware connected to the machine. It's
// generally only created for removable hardware or hardware with removable
// media
//
// #GDrive is a container class for #GVolume objects that stem from the same
// piece of media. As such, #GDrive abstracts a drive with (or without)
// removable media and provides operations for querying whether media is
// available, determining whether media change is automatically detected and
// ejecting the media
//
// If the #GDrive reports that media isn't automatically detected, one can poll
// for media; typically one should not do this periodically as a poll for media
// operation is potentially expensive and may spin up the drive creating noise.
//
// #GDrive supports starting and stopping drives with authentication support for
// the former. This can be used to support a diverse set of use cases including
// connecting/disconnecting iSCSI devices, powering down external disk
// enclosures and starting/stopping multi-disk devices such as RAID devices.
// Note that the actual semantics and side-effects of starting/stopping a
// #GDrive may vary according to implementation. To choose the correct verbs in
// e.g. a file manager, use g_drive_get_start_stop_type()
//
// For porting from GnomeVFS note that there is no equivalent of #GDrive in that
// API.
type Drive interface {
	CanEject() bool
	CanPollForMedia() bool
	CanStart() bool
	CanStartDegraded() bool
	CanStop() bool
	Eject(flags MountUnmountFlags, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	EjectFinish(result AsyncResult) bool
	EjectWithOperation(flags MountUnmountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	EjectWithOperationFinish(result AsyncResult) bool
	EnumerateIdentifiers() []string
	GetIcon() Icon
	GetIdentifier(kind string) string
	GetName() string
	GetSortKey() string
	GetStartStopType() DriveStartStopType
	GetSymbolicIcon() Icon
	GetVolumes() *glib.List
	HasMedia() bool
	HasVolumes() bool
	IsMediaCheckAutomatic() bool
	IsMediaRemovable() bool
	IsRemovable() bool
	PollForMedia(cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	PollForMediaFinish(result AsyncResult) bool
	Start(flags DriveStartFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	StartFinish(result AsyncResult) bool
	Stop(flags MountUnmountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	StopFinish(result AsyncResult) bool
}

// DtlsClientConnection is the client-side subclass of Connection, representing
// a client-side DTLS connection.
type DtlsClientConnection interface {
	GetAcceptedCas() *glib.List
	GetServerIdentity() SocketConnectable
	GetValidationFlags() TlsCertificateFlags
	SetServerIdentity(identity SocketConnectable)
	SetValidationFlags(flags TlsCertificateFlags)
}

// DtlsConnection is the base DTLS connection class type, which wraps a Based
// and provides DTLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side DTLS,
// respectively.
//
// For TLS support, see Connection.
//
// As DTLS is datagram based, Connection implements Based, presenting a
// datagram-socket-like API for the encrypted connection. This operates over a
// base datagram connection, which is also a Based (Connection:base-socket).
//
// To close a DTLS connection, use g_dtls_connection_close().
//
// Neither ServerConnection or ClientConnection set the peer address on their
// base Based if it is a #GSocket  it is up to the caller to do that if they
// wish. If they do not, and g_socket_close() is called on the base socket, the
// Connection will not raise a G_IO_ERROR_NOT_CONNECTED error on further I/O.
type DtlsConnection interface {
	Close(cancellable *Cancellable) bool
	CloseAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	CloseFinish(result AsyncResult) bool
	EmitAcceptCertificate(peerCert *TlsCertificate, errors TlsCertificateFlags) bool
	GetCertificate() *TlsCertificate
	GetChannelBindingData(_type TlsChannelBindingType) ([]uint8, bool)
	GetDatabase() TlsFileDatabase
	GetInteraction() *TlsInteraction
	GetNegotiatedProtocol() string
	GetPeerCertificate() *TlsCertificate
	GetPeerCertificateErrors() TlsCertificateFlags
	GetRehandshakeMode() TlsRehandshakeMode
	GetRequireCloseNotify() bool
	Handshake(cancellable *Cancellable) bool
	HandshakeAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	HandshakeFinish(result AsyncResult) bool
	SetAdvertisedProtocols(protocols []string)
	SetCertificate(certificate *TlsCertificate)
	SetDatabase(database TlsFileDatabase)
	SetInteraction(interaction *TlsInteraction)
	SetRehandshakeMode(mode TlsRehandshakeMode)
	SetRequireCloseNotify(requireCloseNotify bool)
	Shutdown(shutdownRead bool, shutdownWrite bool, cancellable *Cancellable) bool
	ShutdownAsync(shutdownRead bool, shutdownWrite bool, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	ShutdownFinish(result AsyncResult) bool
}

// File is a high level abstraction for manipulating files on a virtual file
// system. #GFiles are lightweight, immutable objects that do no I/O upon
// creation. It is necessary to understand that #GFile objects do not represent
// files, merely an identifier for a file. All file content I/O is implemented
// as streaming operations (see Stream and Stream).
//
// To construct a #GFile, you can use: - g_file_new_for_path() if you have a
// path. - g_file_new_for_uri() if you have a URI. -
// g_file_new_for_commandline_arg() for a command line argument. -
// g_file_new_tmp() to create a temporary file from a template. -
// g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
// - g_file_new_build_filename() to create a file from path elements.
//
// One way to think of a #GFile is as an abstraction of a pathname. For normal
// files the system pathname is what is stored internally, but as #GFiles are
// extensible it could also be something else that corresponds to a pathname in
// a userspace implementation of a filesystem.
//
// #GFiles make up hierarchies of directories and files that correspond to the
// files on a filesystem. You can move through the file system with #GFile using
// g_file_get_parent() to get an identifier for the parent directory,
// g_file_get_child() to get a child within a directory,
// g_file_resolve_relative_path() to resolve a relative path between two
// #GFiles. There can be multiple hierarchies, so you may not end up at the same
// root if you repeatedly call g_file_get_parent() on two different files
//
// All #GFiles have a basename (get with g_file_get_basename()). These names are
// byte strings that are used to identify the file on the filesystem (relative
// to its parent directory) and there is no guarantees that they have any
// particular charset encoding or even make any sense at all. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info(). This is guaranteed to be in UTF-8 and can be used in a
// user interface. But always store the real basename or the #GFile to use to
// actually access the file, because there is no way to go from a display name
// to the actual name.
//
// Using #GFile as an identifier has the same weaknesses as using a path in that
// there may be multiple aliases for the same file. For instance, hard or soft
// links may cause two different #GFiles to refer to the same file. Other
// possible causes for aliases are: case insensitive filesystems, short and long
// names on FAT/NTFS, or bind mounts in Linux. If you want to check if two
// #GFiles point to the same file you can query for the G_FILE_ATTRIBUTE_ID_FILE
// attribute. Note that #GFile does some trivial canonicalization of pathnames
// passed in, so that trivial differences in the path string used at creation
// (duplicated slashes, slash at end of path, "." or ".." path segments, etc)
// does not create different #GFiles.
//
// Many #GFile operations have both synchronous and asynchronous versions to
// suit your application. Asynchronous versions of synchronous functions simply
// have _async() appended to their function names. The asynchronous I/O
// functions call a ReadyCallback which is then used to finalize the operation,
// producing a GAsyncResult which is then passed to the function's matching
// _finish() operation.
//
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section][async-programming] for
// more.
//
// Some #GFile operations almost always take a noticeable amount of time, and so
// do not have synchronous analogs. Notable cases include: -
// g_file_mount_mountable() to mount a mountable file. -
// g_file_unmount_mountable_with_operation() to unmount a mountable file. -
// g_file_eject_mountable_with_operation() to eject a mountable file.
//
// Entity Tags {#gfile-etag}
//
// One notable feature of #GFiles are entity tags, or "etags" for short. Entity
// tags are somewhat like a more abstract version of the traditional mtime, and
// can be used to quickly determine if the file has been modified from the
// version on the file system. See the HTTP 1.1
// [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) for
// HTTP Etag headers, which are a very similar concept.
type File interface {
	AppendTo(flags FileCreateFlags, cancellable *Cancellable) *FileOutputStream
	AppendToAsync(flags FileCreateFlags, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	AppendToFinish(res AsyncResult) *FileOutputStream
	Copy(destination File, flags FileCopyFlags, cancellable *Cancellable, progressCallback FileProgressCallback, progressCallbackData unsafe.Pointer) bool
	CopyAsync(destination File, flags FileCopyFlags, ioPriority int, cancellable *Cancellable, progressCallback FileProgressCallback, progressCallbackData unsafe.Pointer, callback AsyncReadyCallback, userData unsafe.Pointer)
	CopyAttributes(destination File, flags FileCopyFlags, cancellable *Cancellable) bool
	CopyFinish(res AsyncResult) bool
	Create(flags FileCreateFlags, cancellable *Cancellable) *FileOutputStream
	CreateAsync(flags FileCreateFlags, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	CreateFinish(res AsyncResult) *FileOutputStream
	CreateReadwrite(flags FileCreateFlags, cancellable *Cancellable) *FileIOStream
	CreateReadwriteAsync(flags FileCreateFlags, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	CreateReadwriteFinish(res AsyncResult) *FileIOStream
	Delete(cancellable *Cancellable) bool
	DeleteAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	DeleteFinish(result AsyncResult) bool
	Dup() File
	EjectMountable(flags MountUnmountFlags, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	EjectMountableFinish(result AsyncResult) bool
	EjectMountableWithOperation(flags MountUnmountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	EjectMountableWithOperationFinish(result AsyncResult) bool
	EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable *Cancellable) *FileEnumerator
	EnumerateChildrenAsync(attributes string, flags FileQueryInfoFlags, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	EnumerateChildrenFinish(res AsyncResult) *FileEnumerator
	Equal(file2 File) bool
	FindEnclosingMount(cancellable *Cancellable) Mount
	FindEnclosingMountAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	FindEnclosingMountFinish(res AsyncResult) Mount
	GetBasename() string
	GetChild(name string) File
	GetChildForDisplayName(displayName string) File
	GetParent() File
	GetParseName() string
	GetPath() string
	GetRelativePath(descendant File) string
	GetURI() string
	GetURIScheme() string
	HasParent(parent File) bool
	HasPrefix(prefix File) bool
	HasURIScheme(uriScheme string) bool
	Hash() uint
	IsNative() bool
	LoadBytes(cancellable *Cancellable) (string, *glib.Bytes)
	LoadBytesAsync(cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	LoadBytesFinish(result AsyncResult) (string, *glib.Bytes)
	LoadContents(cancellable *Cancellable) ([]uint8, uint, string, bool)
	LoadContentsAsync(cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	LoadContentsFinish(res AsyncResult) ([]uint8, uint, string, bool)
	LoadPartialContentsAsync(cancellable *Cancellable, readMoreCallback FileReadMoreCallback, callback AsyncReadyCallback, userData unsafe.Pointer)
	LoadPartialContentsFinish(res AsyncResult) ([]uint8, uint, string, bool)
	MakeDirectory(cancellable *Cancellable) bool
	MakeDirectoryAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	MakeDirectoryFinish(result AsyncResult) bool
	MakeDirectoryWithParents(cancellable *Cancellable) bool
	MakeSymbolicLink(symlinkValue string, cancellable *Cancellable) bool
	MeasureDiskUsage(flags FileMeasureFlags, cancellable *Cancellable, progressCallback FileMeasureProgressCallback, progressData unsafe.Pointer) (uint64, uint64, uint64, bool)
	MeasureDiskUsageAsync(flags FileMeasureFlags, ioPriority int, cancellable *Cancellable, progressCallback FileMeasureProgressCallback, progressData unsafe.Pointer, callback AsyncReadyCallback, userData unsafe.Pointer)
	MeasureDiskUsageFinish(result AsyncResult) (uint64, uint64, uint64, bool)
	Monitor(flags FileMonitorFlags, cancellable *Cancellable) *FileMonitor
	MonitorDirectory(flags FileMonitorFlags, cancellable *Cancellable) *FileMonitor
	MonitorFile(flags FileMonitorFlags, cancellable *Cancellable) *FileMonitor
	MountEnclosingVolume(flags MountMountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	MountEnclosingVolumeFinish(result AsyncResult) bool
	MountMountable(flags MountMountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	MountMountableFinish(result AsyncResult) File
	Move(destination File, flags FileCopyFlags, cancellable *Cancellable, progressCallback FileProgressCallback, progressCallbackData unsafe.Pointer) bool
	OpenReadwrite(cancellable *Cancellable) *FileIOStream
	OpenReadwriteAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	OpenReadwriteFinish(res AsyncResult) *FileIOStream
	PeekPath() string
	PollMountable(cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	PollMountableFinish(result AsyncResult) bool
	QueryDefaultHandler(cancellable *Cancellable) AppInfo
	QueryDefaultHandlerAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	QueryDefaultHandlerFinish(result AsyncResult) AppInfo
	QueryExists(cancellable *Cancellable) bool
	QueryFileType(flags FileQueryInfoFlags, cancellable *Cancellable) FileType
	QueryFilesystemInfo(attributes string, cancellable *Cancellable) *FileInfo
	QueryFilesystemInfoAsync(attributes string, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	QueryFilesystemInfoFinish(res AsyncResult) *FileInfo
	QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable *Cancellable) *FileInfo
	QueryInfoAsync(attributes string, flags FileQueryInfoFlags, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	QueryInfoFinish(res AsyncResult) *FileInfo
	QuerySettableAttributes(cancellable *Cancellable) *FileAttributeInfoList
	QueryWritableNamespaces(cancellable *Cancellable) *FileAttributeInfoList
	Read(cancellable *Cancellable) *FileInputStream
	ReadAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	ReadFinish(res AsyncResult) *FileInputStream
	Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable *Cancellable) *FileOutputStream
	ReplaceAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	ReplaceContents(contents []uint8, length uint, etag string, makeBackup bool, flags FileCreateFlags, cancellable *Cancellable) (string, bool)
	ReplaceContentsAsync(contents []uint8, length uint, etag string, makeBackup bool, flags FileCreateFlags, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	ReplaceContentsBytesAsync(contents *glib.Bytes, etag string, makeBackup bool, flags FileCreateFlags, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	ReplaceContentsFinish(res AsyncResult) (string, bool)
	ReplaceFinish(res AsyncResult) *FileOutputStream
	ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable *Cancellable) *FileIOStream
	ReplaceReadwriteAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	ReplaceReadwriteFinish(res AsyncResult) *FileIOStream
	ResolveRelativePath(relativePath string) File
	SetAttribute(attribute string, _type FileAttributeType, valueP unsafe.Pointer, flags FileQueryInfoFlags, cancellable *Cancellable) bool
	SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable *Cancellable) bool
	SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable *Cancellable) bool
	SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable *Cancellable) bool
	SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable *Cancellable) bool
	SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable *Cancellable) bool
	SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable *Cancellable) bool
	SetAttributesAsync(info *FileInfo, flags FileQueryInfoFlags, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	SetAttributesFinish(result AsyncResult) (*FileInfo, bool)
	SetAttributesFromInfo(info *FileInfo, flags FileQueryInfoFlags, cancellable *Cancellable) bool
	SetDisplayName(displayName string, cancellable *Cancellable) File
	SetDisplayNameAsync(displayName string, ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	SetDisplayNameFinish(res AsyncResult) File
	StartMountable(flags DriveStartFlags, startOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	StartMountableFinish(result AsyncResult) bool
	StopMountable(flags MountUnmountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	StopMountableFinish(result AsyncResult) bool
	SupportsThreadContexts() bool
	Trash(cancellable *Cancellable) bool
	TrashAsync(ioPriority int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	TrashFinish(result AsyncResult) bool
	UnmountMountable(flags MountUnmountFlags, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	UnmountMountableFinish(result AsyncResult) bool
	UnmountMountableWithOperation(flags MountUnmountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	UnmountMountableWithOperationFinish(result AsyncResult) bool
}

// FileDescriptorBased is implemented by streams (implementations of Stream or
// Stream) that are based on file descriptors.
//
// Note that `<gio/gfiledescriptorbased.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type FileDescriptorBased interface {
	GetFd() int
}

// Icon is a very minimal interface for icons. It provides functions for
// checking the equality of two icons, hashing of icons and serializing an icon
// to and from strings.
//
// #GIcon does not provide the actual pixmap for the icon as this is out of
// GIO's scope, however implementations of #GIcon may contain the name of an
// icon (see Icon), or the path to an icon (see Icon)
//
// To obtain a hash of a #GIcon, see g_icon_hash().
//
// To check if two #GIcons are equal, see g_icon_equal().
//
// For serializing a #GIcon, use g_icon_serialize() and g_icon_deserialize().
//
// If you want to consume #GIcon (for example, in a toolkit) you must be
// prepared to handle at least the three following cases: Icon, Icon and Icon.
// It may also make sense to have fast-paths for other cases (like handling
// Pixbuf directly, for example) but all compliant #GIcon implementations
// outside of GIO must implement Icon.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that your new implementation also implements Icon.
// Additionally, you must provide an implementation of g_icon_serialize() that
// gives a result that is understood by g_icon_deserialize(), yielding one of
// the built-in icon types.
type Icon interface {
	Equal(icon2 Icon) bool
	Serialize() *glib.Variant
	ToString() string
}

// Initable is implemented by objects that can fail during initialization. If an
// object implements this interface then it must be initialized as the first
// thing after construction, either via g_initable_init() or
// g_async_initable_init_async() (the latter is only available if it also
// implements Initable).
//
// If the object is not initialized, or initialization returns with an error,
// then all operations on the object except g_object_ref() and g_object_unref()
// are considered to be invalid, and have undefined behaviour. They will often
// fail with g_critical() or g_warning(), but this must not be relied on.
//
// Users of objects implementing this are not intended to use the interface
// method directly, instead it will be used automatically in various ways. For C
// applications you generally just call g_initable_new() directly, or indirectly
// via a foo_thing_new() wrapper. This will call g_initable_init() under the
// cover, returning nil and setting a #GError on failure (at which point the
// instance is unreferenced).
//
// For bindings in languages where the native constructor supports exceptions
// the binding could check for objects implementing GInitable during normal
// construction and automatically initialize them, throwing an exception on
// failure.
type Initable interface {
	Init(cancellable *Cancellable) bool
}

// ListModel is an interface that represents a mutable list of #GObjects. Its
// main intention is as a model for various widgets in user interfaces, such as
// list views, but it can also be used as a convenient method of returning lists
// of data, with support for updates.
//
// Each object in the list may also report changes in itself via some mechanism
// (normally the #GObject::notify signal). Taken together with the
// Model::items-changed signal, this provides for a list that can change its
// membership, and in which the members can change their individual properties.
//
// A good example would be the list of visible wireless network access points,
// where each access point can report dynamic properties such as signal
// strength.
//
// It is important to note that the Model itself does not report changes to the
// individual items. It only reports changes to the list membership. If you want
// to observe changes to the objects themselves then you need to connect signals
// to the objects that you are interested in.
//
// All items in a Model are of (or derived from) the same type.
// g_list_model_get_item_type() returns that type. The type may be an interface,
// in which case all objects in the list must implement it.
//
// The semantics are close to that of an array: g_list_model_get_n_items()
// returns the number of items in the list and g_list_model_get_item() returns
// an item at a (0-based) position. In order to allow implementations to
// calculate the list length lazily, you can also iterate over items: starting
// from 0, repeatedly call g_list_model_get_item() until it returns nil.
//
// An implementation may create objects lazily, but must take care to return the
// same object for a given position until all references to it are gone.
//
// On the other side, a consumer is expected only to hold references on objects
// that are currently "user visible", in order to facilitate the maximum level
// of laziness in the implementation of the list and to reduce the required
// number of signal connections at a given time.
//
// This interface is intended only to be used from a single thread. The thread
// in which it is appropriate to use it depends on the particular
// implementation, but typically it will be from the thread that owns the
// [thread-default main context][g-main-context-push-thread-default] in effect
// at the time that the model was created.
type ListModel interface {
	GetItem(position uint) unsafe.Pointer
	GetItemType() externglib.Type
	GetNItems() uint
	GetObject(position uint) *externglib.Object
	ItemsChanged(position uint, removed uint, added uint)
}

// LoadableIcon: extends the #GIcon interface and adds the ability to load icons
// from streams.
type LoadableIcon interface {
	Load(size int, cancellable *Cancellable) (string, *InputStream)
	LoadAsync(size int, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	LoadFinish(res AsyncResult) (string, *InputStream)
}

// Mount: the #GMount interface represents user-visible mounts. Note, when
// porting from GnomeVFS, #GMount is the moral equivalent of VFSVolume.
//
// #GMount is a "mounted" filesystem that you can access. Mounted is in quotes
// because it's not the same as a unix mount, it might be a gvfs mount, but you
// can still access the files on it if you use GIO. Might or might not be
// related to a volume object
//
// Unmounting a #GMount instance is an asynchronous operation. For more
// information about asynchronous operations, see Result and #GTask. To unmount
// a #GMount instance, first call g_mount_unmount_with_operation() with (at
// least) the #GMount instance and a ReadyCallback. The callback will be fired
// when the operation has resolved (either with success or failure), and a
// Result structure will be passed to the callback. That callback should then
// call g_mount_unmount_with_operation_finish() with the #GMount and the Result
// data to see if the operation was completed successfully. If an @error is
// present when g_mount_unmount_with_operation_finish() is called, then it will
// be filled with any error information.
type Mount interface {
	CanEject() bool
	CanUnmount() bool
	Eject(flags MountUnmountFlags, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	EjectFinish(result AsyncResult) bool
	EjectWithOperation(flags MountUnmountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	EjectWithOperationFinish(result AsyncResult) bool
	GetDefaultLocation() File
	GetDrive() Drive
	GetIcon() Icon
	GetName() string
	GetRoot() File
	GetSortKey() string
	GetSymbolicIcon() Icon
	GetUuid() string
	GetVolume() Volume
	GuessContentType(forceRescan bool, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	GuessContentTypeFinish(result AsyncResult) []string
	GuessContentTypeSync(forceRescan bool, cancellable *Cancellable) []string
	IsShadowed() bool
	Remount(flags MountMountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	RemountFinish(result AsyncResult) bool
	Shadow()
	Unmount(flags MountUnmountFlags, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	UnmountFinish(result AsyncResult) bool
	UnmountWithOperation(flags MountUnmountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	UnmountWithOperationFinish(result AsyncResult) bool
	Unshadow()
}

// NetworkMonitor: monitor provides an easy-to-use cross-platform API for
// monitoring network connectivity. On Linux, the available implementations are
// based on the kernel's netlink interface and on NetworkManager.
//
// There is also an implementation for use inside Flatpak sandboxes.
type NetworkMonitor interface {
	CanReach(connectable SocketConnectable, cancellable *Cancellable) bool
	CanReachAsync(connectable SocketConnectable, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	CanReachFinish(result AsyncResult) bool
	GetConnectivity() NetworkConnectivity
	GetNetworkAvailable() bool
	GetNetworkMetered() bool
}

// PollableInputStream is implemented by Streams that can be polled for
// readiness to read. This can be used when interfacing with a non-GIO API that
// expects UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
type PollableInputStream interface {
	CanPoll() bool
	CreateSource(cancellable *Cancellable) *glib.Source
	IsReadable() bool
	ReadNonblocking(buffer []uint8, count uint, cancellable *Cancellable) int
}

// PollableOutputStream is implemented by Streams that can be polled for
// readiness to write. This can be used when interfacing with a non-GIO API that
// expects UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
type PollableOutputStream interface {
	CanPoll() bool
	CreateSource(cancellable *Cancellable) *glib.Source
	IsWritable() bool
	WriteNonblocking(buffer []uint8, count uint, cancellable *Cancellable) int
	WritevNonblocking(vectors []OutputVector, nVectors uint, cancellable *Cancellable) (uint, PollableReturn)
}

// Proxy: a #GProxy handles connecting to a remote host via a given type of
// proxy server. It is implemented by the 'gio-proxy' extension point. The
// extensions are named after their proxy protocol name. As an example, a SOCKS5
// proxy implementation can be retrieved with the name 'socks5' using the
// function g_io_extension_point_get_extension_by_name().
type Proxy interface {
	Connect(connection *IOStream, proxyAddress *ProxyAddress, cancellable *Cancellable) *IOStream
	ConnectAsync(connection *IOStream, proxyAddress *ProxyAddress, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	ConnectFinish(result AsyncResult) *IOStream
	SupportsHostname() bool
}

// ProxyResolver: resolver provides synchronous and asynchronous network proxy
// resolution. Resolver is used within Client through the method
// g_socket_connectable_proxy_enumerate().
//
// Implementations of Resolver based on libproxy and GNOME settings can be found
// in glib-networking. GIO comes with an implementation for use inside Flatpak
// portals.
type ProxyResolver interface {
	IsSupported() bool
	Lookup(uri string, cancellable *Cancellable) []string
	LookupAsync(uri string, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	LookupFinish(result AsyncResult) []string
}

// RemoteActionGroup: the GRemoteActionGroup interface is implemented by Group
// instances that either transmit action invocations to other processes or
// receive action invocations in the local process from other processes.
//
// The interface has `_full` variants of the two methods on Group used to
// activate actions: g_action_group_activate_action() and
// g_action_group_change_action_state(). These variants allow a "platform data"
// #GVariant to be specified: a dictionary providing context for the action
// invocation (for example: timestamps, startup notification IDs, etc).
//
// BusActionGroup implements ActionGroup. This provides a mechanism to send
// platform data for action invocations over D-Bus.
//
// Additionally, g_dbus_connection_export_action_group() will check if the
// exported Group implements ActionGroup and use the `_full` variants of the
// calls if available. This provides a mechanism by which to receive platform
// data for action invocations that arrive by way of D-Bus.
type RemoteActionGroup interface {
	ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant)
	ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant)
}

// Seekable is implemented by streams (implementations of Stream or Stream) that
// support seeking.
//
// Seekable streams largely fall into two categories: resizable and fixed-size.
//
// #GSeekable on fixed-sized streams is approximately the same as POSIX lseek()
// on a block device (for example: attempting to seek past the end of the device
// is an error). Fixed streams typically cannot be truncated
//
// #GSeekable on resizable streams is approximately the same as POSIX lseek() on
// a normal file. Seeking past the end and writing data will usually cause the
// stream to resize by introducing zero bytes
type Seekable interface {
	CanSeek() bool
	CanTruncate() bool
	Seek(offset int64, _type glib.SeekType, cancellable *Cancellable) bool
	Tell() int64
	Truncate(offset int64, cancellable *Cancellable) bool
}

// SocketConnectable: objects that describe one or more potential socket
// endpoints implement Connectable. Callers can then use
// g_socket_connectable_enumerate() to get a AddressEnumerator to try out each
// socket address in turn until one succeeds, as shown in the sample code below.
//
//    MyConnectionType *
//    connect_to_host (const char    *hostname,
//                     guint16        port,
//                     GCancellable  *cancellable,
//                     GError       **error)
//    {
//      MyConnection *conn = NULL;
//      GSocketConnectable *addr;
//      GSocketAddressEnumerator *enumerator;
//      GSocketAddress *sockaddr;
//      GError *conn_error = NULL;
//
//      addr = g_network_address_new (hostname, port);
//      enumerator = g_socket_connectable_enumerate (addr);
//      g_object_unref (addr);
//
//      // Try each sockaddr until we succeed. Record the first connection error,
//      // but not any further ones (since they'll probably be basically the same
//      // as the first).
//      while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
//        {
//          conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
//          g_object_unref (sockaddr);
//        }
//      g_object_unref (enumerator);
//
//      if (conn)
//        {
//          if (conn_error)
//            {
//              // We couldn't connect to the first address, but we succeeded
//              // in connecting to a later address.
//              g_error_free (conn_error);
//            }
//          return conn;
//        }
//      else if (error)
//        {
//          /// Either initial lookup failed, or else the caller cancelled us.
//          if (conn_error)
//            g_error_free (conn_error);
//          return NULL;
//        }
//      else
//        {
//          g_error_propagate (error, conn_error);
//          return NULL;
//        }
//    }
//
type SocketConnectable interface {
	Enumerate() *SocketAddressEnumerator
	ProxyEnumerate() *SocketAddressEnumerator
	ToString() string
}

// TlsBackend: TLS (Transport Layer Security, aka SSL) and DTLS backend.
type TlsBackend interface {
	GetCertificateType() externglib.Type
	GetClientConnectionType() externglib.Type
	GetDefaultDatabase() TlsFileDatabase
	GetDtlsClientConnectionType() externglib.Type
	GetDtlsServerConnectionType() externglib.Type
	GetFileDatabaseType() externglib.Type
	GetServerConnectionType() externglib.Type
	SetDefaultDatabase(database TlsFileDatabase)
	SupportsDtls() bool
	SupportsTls() bool
}

// TlsClientConnection is the client-side subclass of Connection, representing a
// client-side TLS connection.
type TlsClientConnection interface {
	CopySessionState(source TlsClientConnection)
	GetAcceptedCas() *glib.List
	GetServerIdentity() SocketConnectable
	GetUseSsl3() bool
	GetValidationFlags() TlsCertificateFlags
	SetServerIdentity(identity SocketConnectable)
	SetUseSsl3(useSsl3 bool)
	SetValidationFlags(flags TlsCertificateFlags)
}

// Volume: the #GVolume interface represents user-visible objects that can be
// mounted. Note, when porting from GnomeVFS, #GVolume is the moral equivalent
// of VFSDrive.
//
// Mounting a #GVolume instance is an asynchronous operation. For more
// information about asynchronous operations, see Result and #GTask. To mount a
// #GVolume, first call g_volume_mount() with (at least) the #GVolume instance,
// optionally a Operation object and a ReadyCallback.
//
// Typically, one will only want to pass nil for the Operation if automounting
// all volumes when a desktop session starts since it's not desirable to put up
// a lot of dialogs asking for credentials.
//
// The callback will be fired when the operation has resolved (either with
// success or failure), and a Result instance will be passed to the callback.
// That callback should then call g_volume_mount_finish() with the #GVolume
// instance and the Result data to see if the operation was completed
// successfully. If an @error is present when g_volume_mount_finish() is called,
// then it will be filled with any error information.
//
// Volume Identifiers {#volume-identifier}
//
// It is sometimes necessary to directly access the underlying operating system
// object behind a volume (e.g. for passing a volume to an application via the
// commandline). For this purpose, GIO allows to obtain an 'identifier' for the
// volume. There can be different kinds of identifiers, such as Hal UDIs,
// filesystem labels, traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO
// uses predefined strings as names for the different kinds of identifiers:
// VOLUME_IDENTIFIER_KIND_UUID, VOLUME_IDENTIFIER_KIND_LABEL, etc. Use
// g_volume_get_identifier() to obtain an identifier for a volume.
//
// Note that VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available when the gvfs
// hal volume monitor is in use. Other volume monitors will generally be able to
// provide the VOLUME_IDENTIFIER_KIND_UNIX_DEVICE identifier, which can be used
// to obtain a hal device by means of libhal_manager_find_device_string_match().
type Volume interface {
	CanEject() bool
	CanMount() bool
	Eject(flags MountUnmountFlags, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	EjectFinish(result AsyncResult) bool
	EjectWithOperation(flags MountUnmountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	EjectWithOperationFinish(result AsyncResult) bool
	EnumerateIdentifiers() []string
	GetActivationRoot() File
	GetDrive() Drive
	GetIcon() Icon
	GetIdentifier(kind string) string
	GetMount() Mount
	GetName() string
	GetSortKey() string
	GetSymbolicIcon() Icon
	GetUuid() string
	Mount(flags MountMountFlags, mountOperation *MountOperation, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)
	MountFinish(result AsyncResult) bool
	ShouldAutomount() bool
}

// ActionEntry: this struct defines a single action. It is for use with
// g_action_map_add_action_entries().
//
// The order of the items in the structure are intended to reflect frequency of
// use. It is permissible to use an incomplete initialiser in order to leave
// some of the later values as nil. All values after @name are optional.
// Additional optional fields may be added in the future.
//
// See g_action_map_add_action_entries() for an example.
type ActionEntry struct {
	// Name: the name of the action
	Name string
	// ParameterType: the type of the parameter that must be passed to the
	// activate function for this action, given as a single GVariant type string
	// (or nil for no parameter)
	ParameterType string
	// State: the initial state for this action, given in [GVariant text
	// format][gvariant-text]. The state is parsed with no extra type
	// information, so type tags must be added to the string if they are
	// necessary. Stateless actions should give nil here.
	State string

	native *C.GActionEntry
}

func wrapActionEntry(p *C.GActionEntry) *ActionEntry {
	v := ActionEntry{native: p}

	v.Name = C.GoString(p.name)
	v.ParameterType = C.GoString(p.parameter_type)
	v.State = C.GoString(p.state)

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*ActionEntry).free)

	return &v
}

func marshalActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GActionEntry)(unsafe.Pointer(b))

	return wrapActionEntry(c)
}

func (a *ActionEntry) free() {}

// Native returns the pointer to *C.GActionEntry. The caller is expected to
// cast.
func (a *ActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(a.native)
}

// DBusAnnotationInfo: information about an annotation.
type DBusAnnotationInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Key: the name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
	Key string
	// Value: the value of the annotation.
	Value string
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusAnnotationInfo
}

func wrapDBusAnnotationInfo(p *C.GDBusAnnotationInfo) *DBusAnnotationInfo {
	var v DBusAnnotationInfo

	v.RefCount = int(p.ref_count)
	v.Key = C.GoString(p.key)
	v.Value = C.GoString(p.value)

	return &v
}

func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusAnnotationInfo)(unsafe.Pointer(b))

	return wrapDBusAnnotationInfo(c)
}

// Native returns the pointer to *C.GDBusAnnotationInfo. The caller is expected to
// cast.
func (d *DBusAnnotationInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusArgInfo: information about an argument for a method or a signal.
type DBusArgInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: name of the argument, e.g. @unix_user_id.
	Name string
	// Signature: d-Bus signature of the argument (a single complete type).
	Signature string
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusArgInfo
}

func wrapDBusArgInfo(p *C.GDBusArgInfo) *DBusArgInfo {
	var v DBusArgInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)
	v.Signature = C.GoString(p.signature)

	return &v
}

func marshalDBusArgInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusArgInfo)(unsafe.Pointer(b))

	return wrapDBusArgInfo(c)
}

// Native returns the pointer to *C.GDBusArgInfo. The caller is expected to
// cast.
func (d *DBusArgInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusErrorEntry: struct used in g_dbus_error_register_error_domain().
type DBusErrorEntry struct {
	// ErrorCode: an error code.
	ErrorCode int
	// DbusErrorName: the D-Bus error name to associate with @error_code.
	DbusErrorName string

	native *C.GDBusErrorEntry
}

func wrapDBusErrorEntry(p *C.GDBusErrorEntry) *DBusErrorEntry {
	var v DBusErrorEntry

	v.ErrorCode = int(p.error_code)
	v.DbusErrorName = C.GoString(p.dbus_error_name)

	return &v
}

func marshalDBusErrorEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusErrorEntry)(unsafe.Pointer(b))

	return wrapDBusErrorEntry(c)
}

// Native returns the pointer to *C.GDBusErrorEntry. The caller is expected to
// cast.
func (d *DBusErrorEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusInterfaceInfo: information about a D-Bus interface.
type DBusInterfaceInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus interface, e.g.
	// "org.freedesktop.DBus.Properties".
	Name string
	// Methods: a pointer to a nil-terminated array of pointers to BusMethodInfo
	// structures or nil if there are no methods.
	Methods []*DBusMethodInfo
	// Signals: a pointer to a nil-terminated array of pointers to BusSignalInfo
	// structures or nil if there are no signals.
	Signals []*DBusSignalInfo
	// Properties: a pointer to a nil-terminated array of pointers to
	// BusPropertyInfo structures or nil if there are no properties.
	Properties []*DBusPropertyInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusInterfaceInfo
}

func wrapDBusInterfaceInfo(p *C.GDBusInterfaceInfo) *DBusInterfaceInfo {
	var v DBusInterfaceInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)

	return &v
}

func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusInterfaceInfo)(unsafe.Pointer(b))

	return wrapDBusInterfaceInfo(c)
}

// Native returns the pointer to *C.GDBusInterfaceInfo. The caller is expected to
// cast.
func (d *DBusInterfaceInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusInterfaceVTable: virtual table for handling properties and method calls
// for a D-Bus interface.
//
// Since 2.38, if you want to handle getting/setting D-Bus properties
// asynchronously, give nil as your get_property() or set_property() function.
// The D-Bus call will be directed to your @method_call function, with the
// provided @interface_name set to "org.freedesktop.DBus.Properties".
//
// Ownership of the BusMethodInvocation object passed to the method_call()
// function is transferred to your handler; you must call one of the methods of
// BusMethodInvocation to return a reply (possibly empty), or an error. These
// functions also take ownership of the passed-in invocation object, so unless
// the invocation object has otherwise been referenced, it will be then be
// freed. Calling one of these functions may be done within your method_call()
// implementation but it also can be done at a later point to handle the method
// asynchronously.
//
// The usual checks on the validity of the calls is performed. For `Get` calls,
// an error is automatically returned if the property does not exist or the
// permissions do not allow access. The same checks are performed for `Set`
// calls, and the provided value is also checked for being the correct type.
//
// For both `Get` and `Set` calls, the BusMethodInvocation passed to the
// @method_call handler can be queried with
// g_dbus_method_invocation_get_property_info() to get a pointer to the
// BusPropertyInfo of the property.
//
// If you have readable properties specified in your interface info, you must
// ensure that you either provide a non-nil @get_property() function or provide
// implementations of both the `Get` and `GetAll` methods on
// org.freedesktop.DBus.Properties interface in your @method_call function. Note
// that the required return type of the `Get` call is `(v)`, not the type of the
// property. `GetAll` expects a return value of type `a{sv}`.
//
// If you have writable properties specified in your interface info, you must
// ensure that you either provide a non-nil @set_property() function or provide
// an implementation of the `Set` call. If implementing the call, you must
// return the value of type G_VARIANT_TYPE_UNIT.
type DBusInterfaceVTable struct {
	// MethodCall: function for handling incoming method calls.
	MethodCall DBusInterfaceMethodCallFunc
	// GetProperty: function for getting a property.
	GetProperty DBusInterfaceGetPropertyFunc
	// SetProperty: function for setting a property.
	SetProperty DBusInterfaceSetPropertyFunc

	native *C.GDBusInterfaceVTable
}

func wrapDBusInterfaceVTable(p *C.GDBusInterfaceVTable) *DBusInterfaceVTable {
	v := DBusInterfaceVTable{native: p}

	v.MethodCall = wrapDBusInterfaceMethodCallFunc(p.method_call)
	v.GetProperty = wrapDBusInterfaceGetPropertyFunc(p.get_property)
	v.SetProperty = wrapDBusInterfaceSetPropertyFunc(p.set_property)

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*DBusInterfaceVTable).free)

	return &v
}

func marshalDBusInterfaceVTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusInterfaceVTable)(unsafe.Pointer(b))

	return wrapDBusInterfaceVTable(c)
}

func (d *DBusInterfaceVTable) free() {}

// Native returns the pointer to *C.GDBusInterfaceVTable. The caller is expected to
// cast.
func (d *DBusInterfaceVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusMethodInfo: information about a method on an D-Bus interface.
type DBusMethodInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus method, e.g. @RequestName.
	Name string
	// InArgs: a pointer to a nil-terminated array of pointers to BusArgInfo
	// structures or nil if there are no in arguments.
	InArgs []*DBusArgInfo
	// OutArgs: a pointer to a nil-terminated array of pointers to BusArgInfo
	// structures or nil if there are no out arguments.
	OutArgs []*DBusArgInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusMethodInfo
}

func wrapDBusMethodInfo(p *C.GDBusMethodInfo) *DBusMethodInfo {
	var v DBusMethodInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)

	return &v
}

func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusMethodInfo)(unsafe.Pointer(b))

	return wrapDBusMethodInfo(c)
}

// Native returns the pointer to *C.GDBusMethodInfo. The caller is expected to
// cast.
func (d *DBusMethodInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusNodeInfo: information about nodes in a remote object hierarchy.
type DBusNodeInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Path: the path of the node or nil if omitted. Note that this may be a
	// relative path. See the D-Bus specification for more details.
	Path string
	// Interfaces: a pointer to a nil-terminated array of pointers to
	// BusInterfaceInfo structures or nil if there are no interfaces.
	Interfaces []*DBusInterfaceInfo
	// Nodes: a pointer to a nil-terminated array of pointers to BusNodeInfo
	// structures or nil if there are no nodes.
	Nodes []*DBusNodeInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusNodeInfo
}

func wrapDBusNodeInfo(p *C.GDBusNodeInfo) *DBusNodeInfo {
	var v DBusNodeInfo

	v.RefCount = int(p.ref_count)
	v.Path = C.GoString(p.path)

	return &v
}

func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusNodeInfo)(unsafe.Pointer(b))

	return wrapDBusNodeInfo(c)
}

// Native returns the pointer to *C.GDBusNodeInfo. The caller is expected to
// cast.
func (d *DBusNodeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

func NewDBusNodeInfo(xmlData string) *DBusNodeInfo

// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
type DBusPropertyInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus property, e.g. "SupportedFilesystems".
	Name string
	// Signature: the D-Bus signature of the property (a single complete type).
	Signature string
	// Flags: access control flags for the property.
	Flags DBusPropertyInfoFlags
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusPropertyInfo
}

func wrapDBusPropertyInfo(p *C.GDBusPropertyInfo) *DBusPropertyInfo {
	var v DBusPropertyInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)
	v.Signature = C.GoString(p.signature)
	v.Flags = DBusPropertyInfoFlags(p.flags)

	return &v
}

func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusPropertyInfo)(unsafe.Pointer(b))

	return wrapDBusPropertyInfo(c)
}

// Native returns the pointer to *C.GDBusPropertyInfo. The caller is expected to
// cast.
func (d *DBusPropertyInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusSignalInfo: information about a signal on a D-Bus interface.
type DBusSignalInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus signal, e.g. "NameOwnerChanged".
	Name string
	// Args: a pointer to a nil-terminated array of pointers to BusArgInfo
	// structures or nil if there are no arguments.
	Args []*DBusArgInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusSignalInfo
}

func wrapDBusSignalInfo(p *C.GDBusSignalInfo) *DBusSignalInfo {
	var v DBusSignalInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)

	return &v
}

func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusSignalInfo)(unsafe.Pointer(b))

	return wrapDBusSignalInfo(c)
}

// Native returns the pointer to *C.GDBusSignalInfo. The caller is expected to
// cast.
func (d *DBusSignalInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusSubtreeVTable: virtual table for handling subtrees registered with
// g_dbus_connection_register_subtree().
type DBusSubtreeVTable struct {
	// Enumerate: function for enumerating child nodes.
	Enumerate DBusSubtreeEnumerateFunc
	// Introspect: function for introspecting a child node.
	Introspect DBusSubtreeIntrospectFunc
	// Dispatch: function for dispatching a remote call on a child node.
	Dispatch DBusSubtreeDispatchFunc

	native *C.GDBusSubtreeVTable
}

func wrapDBusSubtreeVTable(p *C.GDBusSubtreeVTable) *DBusSubtreeVTable {
	v := DBusSubtreeVTable{native: p}

	v.Enumerate = wrapDBusSubtreeEnumerateFunc(p.enumerate)
	v.Introspect = wrapDBusSubtreeIntrospectFunc(p.introspect)
	v.Dispatch = wrapDBusSubtreeDispatchFunc(p.dispatch)

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*DBusSubtreeVTable).free)

	return &v
}

func marshalDBusSubtreeVTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusSubtreeVTable)(unsafe.Pointer(b))

	return wrapDBusSubtreeVTable(c)
}

func (d *DBusSubtreeVTable) free() {}

// Native returns the pointer to *C.GDBusSubtreeVTable. The caller is expected to
// cast.
func (d *DBusSubtreeVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// FileAttributeInfo: information about a specific attribute.
type FileAttributeInfo struct {
	// Name: the name of the attribute.
	Name string
	// Type: the AttributeType type of the attribute.
	Type FileAttributeType
	// Flags: a set of AttributeInfoFlags.
	Flags FileAttributeInfoFlags

	native *C.GFileAttributeInfo
}

func wrapFileAttributeInfo(p *C.GFileAttributeInfo) *FileAttributeInfo {
	var v FileAttributeInfo

	v.Name = C.GoString(p.name)
	v.Type = FileAttributeType(p._type)
	v.Flags = FileAttributeInfoFlags(p.flags)

	return &v
}

func marshalFileAttributeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GFileAttributeInfo)(unsafe.Pointer(b))

	return wrapFileAttributeInfo(c)
}

// Native returns the pointer to *C.GFileAttributeInfo. The caller is expected to
// cast.
func (f *FileAttributeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

// FileAttributeInfoList: acts as a lightweight registry for possible valid file
// attributes. The registry stores Key-Value pair formats as AttributeInfos.
type FileAttributeInfoList struct {
	// Infos: an array of AttributeInfos.
	Infos *FileAttributeInfo
	// NInfos: the number of values in the array.
	NInfos int

	native *C.GFileAttributeInfoList
}

func wrapFileAttributeInfoList(p *C.GFileAttributeInfoList) *FileAttributeInfoList {
	var v FileAttributeInfoList

	v.Infos = wrap * FileAttributeInfo(p.infos)
	v.NInfos = int(p.n_infos)

	return &v
}

func marshalFileAttributeInfoList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GFileAttributeInfoList)(unsafe.Pointer(b))

	return wrapFileAttributeInfoList(c)
}

// Native returns the pointer to *C.GFileAttributeInfoList. The caller is expected to
// cast.
func (f *FileAttributeInfoList) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

func NewFileAttributeInfoList() *FileAttributeInfoList

// FileAttributeMatcher: determines if a string matches a file attribute.
type FileAttributeMatcher struct {
	native *C.GFileAttributeMatcher
}

func wrapFileAttributeMatcher(p *C.GFileAttributeMatcher) *FileAttributeMatcher {
	v := FileAttributeMatcher{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*FileAttributeMatcher).free)

	return &v
}

func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GFileAttributeMatcher)(unsafe.Pointer(b))

	return wrapFileAttributeMatcher(c)
}

func (f *FileAttributeMatcher) free() {}

// Native returns the pointer to *C.GFileAttributeMatcher. The caller is expected to
// cast.
func (f *FileAttributeMatcher) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher

// InputMessage: structure used for scatter/gather data input when receiving
// multiple messages or packets in one go. You generally pass in an array of
// empty Vectors and the operation will use all the buffers as if they were one
// buffer, and will set @bytes_received to the total number of bytes received
// across all Vectors.
//
// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from the
// POSIX sockets API (see `man 2 recvmmsg`).
//
// If @address is non-nil then it is set to the source address the message was
// received from, and the caller must free it afterwards.
//
// If @control_messages is non-nil then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. @num_control_messages is set to the number of elements in this
// array, which may be zero.
//
// Flags relevant to this message will be returned in @flags. For example,
// `MSG_EOR` or `MSG_TRUNC`.
type InputMessage struct {
	// Address: return location for a Address, or nil
	Address **SocketAddress
	// Vectors: pointer to an array of input vectors
	Vectors []InputVector
	// NumVectors: the number of input vectors pointed to by @vectors
	NumVectors uint
	// BytesReceived: will be set to the number of bytes that have been received
	BytesReceived uint
	// Flags: collection of MsgFlags for the received message, outputted by the
	// call
	Flags int
	// ControlMessages: return location for a caller-allocated array of
	// ControlMessages, or nil
	ControlMessages []**SocketControlMessage
	// NumControlMessages: return location for the number of elements in
	// @control_messages
	NumControlMessages uint

	native *C.GInputMessage
}

func wrapInputMessage(p *C.GInputMessage) *InputMessage {
	var v InputMessage

	v.Address = wrap * *SocketAddress(p.address)

	v.NumVectors = uint(p.num_vectors)
	v.BytesReceived = uint(p.bytes_received)
	v.Flags = int(p.flags)

	v.NumControlMessages = uint(p.num_control_messages)

	return &v
}

func marshalInputMessage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GInputMessage)(unsafe.Pointer(b))

	return wrapInputMessage(c)
}

// Native returns the pointer to *C.GInputMessage. The caller is expected to
// cast.
func (i *InputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(i.native)
}

// InputVector: structure used for scatter/gather data input. You generally pass
// in an array of Vectors and the operation will store the read data starting in
// the first buffer, switching to the next as needed.
type InputVector struct {
	// Buffer: pointer to a buffer where data will be written.
	Buffer unsafe.Pointer
	// Size: the available size in @buffer.
	Size uint

	native *C.GInputVector
}

func wrapInputVector(p *C.GInputVector) *InputVector {
	var v InputVector

	v.Buffer = unsafe.Pointer(p.buffer)
	v.Size = uint(p.size)

	return &v
}

func marshalInputVector(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GInputVector)(unsafe.Pointer(b))

	return wrapInputVector(c)
}

// Native returns the pointer to *C.GInputVector. The caller is expected to
// cast.
func (i *InputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(i.native)
}

// OutputMessage: structure used for scatter/gather data output when sending
// multiple messages or packets in one go. You generally pass in an array of
// Vectors and the operation will use all the buffers as if they were one
// buffer.
//
// If @address is nil then the message is sent to the default receiver (as
// previously set by g_socket_connect()).
type OutputMessage struct {
	// Address: a Address, or nil
	Address *SocketAddress
	// Vectors: pointer to an array of output vectors
	Vectors *OutputVector
	// NumVectors: the number of output vectors pointed to by @vectors.
	NumVectors uint
	// BytesSent: initialize to 0. Will be set to the number of bytes that have
	// been sent
	BytesSent uint
	// ControlMessages: a pointer to an array of ControlMessages, or nil.
	ControlMessages []*SocketControlMessage
	// NumControlMessages: number of elements in @control_messages.
	NumControlMessages uint

	native *C.GOutputMessage
}

func wrapOutputMessage(p *C.GOutputMessage) *OutputMessage {
	var v OutputMessage

	v.Address = wrap * SocketAddress(p.address)
	v.Vectors = wrap * OutputVector(p.vectors)
	v.NumVectors = uint(p.num_vectors)
	v.BytesSent = uint(p.bytes_sent)

	v.NumControlMessages = uint(p.num_control_messages)

	return &v
}

func marshalOutputMessage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GOutputMessage)(unsafe.Pointer(b))

	return wrapOutputMessage(c)
}

// Native returns the pointer to *C.GOutputMessage. The caller is expected to
// cast.
func (o *OutputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(o.native)
}

// OutputVector: structure used for scatter/gather data output. You generally
// pass in an array of Vectors and the operation will use all the buffers as if
// they were one buffer.
type OutputVector struct {
	// Buffer: pointer to a buffer of data to read.
	Buffer unsafe.Pointer
	// Size: the size of @buffer.
	Size uint

	native *C.GOutputVector
}

func wrapOutputVector(p *C.GOutputVector) *OutputVector {
	var v OutputVector

	v.Buffer = unsafe.Pointer(p.buffer)
	v.Size = uint(p.size)

	return &v
}

func marshalOutputVector(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GOutputVector)(unsafe.Pointer(b))

	return wrapOutputVector(c)
}

// Native returns the pointer to *C.GOutputVector. The caller is expected to
// cast.
func (o *OutputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(o.native)
}

// Resource: applications and libraries often contain binary or textual data
// that is really part of the application, rather than user data. For instance
// Builder .ui files, splashscreen images, GMenu markup XML, CSS files, icons,
// etc. These are often shipped as files in `$datadir/appname`, or manually
// included as literal strings in the code.
//
// The #GResource API and the [glib-compile-resources][glib-compile-resources]
// program provide a convenient and efficient alternative to this which has some
// nice properties. You maintain the files as normal files, so its easy to edit
// them, but during the build the files are combined into a binary bundle that
// is linked into the executable. This means that loading the resource files are
// efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in
// the filesystem). It also makes it easier to create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included
// in the resource bundle in a compressed form, but will be automatically
// uncompressed when the resource is used. This is very useful e.g. for larger
// text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of
// the `preprocess` attribute to a comma-separated list of preprocessing
// options. The only options currently supported are:
//
// `xml-stripblanks` which will use the xmllint command to strip ignorable
// whitespace from the XML file. For this to work, the `XMLLINT` environment
// variable must be set to the full path to the xmllint executable, or xmllint
// must be in the `PATH`; otherwise the preprocessing step is skipped.
//
// `to-pixdata` which will use the gdk-pixbuf-pixdata command to convert images
// to the GdkPixdata format, which allows you to create pixbufs directly using
// the data inside the resource file, rather than an (uncompressed) copy of it.
// For this, the gdk-pixbuf-pixdata program must be in the PATH, or the
// `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
// gdk-pixbuf-pixdata executable; otherwise the resource compiler will abort.
//
// `json-stripblanks` which will use the `json-glib-format` command to strip
// ignorable whitespace from the JSON file. For this to work, the
// `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
// `json-glib-format` executable, or it must be in the `PATH`; otherwise the
// preprocessing step is skipped. In addition, at least version 1.6 of
// `json-glib-format` is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given `prefix` and the filename from the `file` element.
// The `alias` attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the
// [glib-compile-resources][glib-compile-resources] program which takes an XML
// file that describes the bundle, and a set of files that the XML references.
// These are combined into a binary resource bundle.
//
//
//    <?xml version="1.0" encoding="UTF-8"?>
//    <gresources>
//      <gresource prefix="/org/gtk/Example">
//        <file>data/splashscreen.png</file>
//        <file compressed="true">dialog.ui</file>
//        <file preprocess="xml-stripblanks">menumarkup.xml</file>
//        <file alias="example.css">data/example.css</file>
//      </gresource>
//    </gresources>
//
//
//    /org/gtk/Example/data/splashscreen.png
//    /org/gtk/Example/dialog.ui
//    /org/gtk/Example/menumarkup.xml
//    /org/gtk/Example/example.css
//
// Note that all resources in the process share the same namespace, so use
// Java-style path prefixes (like in the above example) to avoid conflicts.
//
// You can then use [glib-compile-resources][glib-compile-resources] to compile
// the XML to a binary bundle that you can load with g_resource_load(). However,
// its more common to use the --generate-source and --generate-header arguments
// to create a source file and header to link directly into your application.
// This will generate `get_resource()`, `register_resource()` and
// `unregister_resource()` functions, prefixed by the `--c-name` argument passed
// to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
// the generated #GResource object. The register and unregister functions
// register the resource so its files can be accessed using
// g_resources_lookup_data().
//
// Once a #GResource has been created and registered all the data in it can be
// accessed globally in the process by using API calls like
// g_resources_open_stream() to stream the data or g_resources_lookup_data() to
// get a direct pointer to the data. You can also use URIs like
// "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access the
// resource data.
//
// Some higher-level APIs, such as Application, will automatically load
// resources from certain well-known paths in the resource namespace as a
// convenience. See the documentation for those APIs for details.
//
// There are two forms of the generated source, the default version uses the
// compiler support for constructor and destructor functions (where available)
// to automatically create and register the #GResource on startup or library
// load time. If you pass `--manual-register`, two functions to
// register/unregister the resource are created instead. This requires an
// explicit initialization call in your application/library, but it works on all
// platforms, even on the minor ones where constructors are not supported.
// (Constructor support is available for at least Win32, Mac OS and Linux.)
//
// Note that resource data can point directly into the data segment of e.g. a
// library, so if you are unloading libraries during runtime you need to be very
// careful with keeping around pointers to data from a resource, as this goes
// away when the library is unloaded. However, in practice this is not generally
// a problem, since most resource accesses are for your own resources, and
// resource data is often used once, during parsing, and then released.
//
// When debugging a program or testing a change to an installed version, it is
// often useful to be able to replace resources in the program or library,
// without recompiling, for debugging or quick hacking and testing purposes.
// Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment
// variable to selectively overlay resources with replacements from the
// filesystem. It is a G_SEARCHPATH_SEPARATOR-separated list of substitutions to
// perform during resource lookups.
//
// A substitution has the form
//
//
//       /org/gtk/libgtk=/home/desrt/gtk-overlay
//
// The part before the `=` is the resource subpath for which the overlay
// applies. The part after is a filesystem path which contains files and
// subdirectories as you would like to be loaded as resources with the
// equivalent names.
//
// In the example above, if an application tried to load a resource with the
// resource path `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check
// the filesystem path `/home/desrt/gtk-overlay/ui/gtkdialog.ui`. If a file was
// found there, it would be used instead. This is an overlay, not an outright
// replacement, which means that if a file is not found at that path, the
// built-in version will be used instead. Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash
// before the '='. The path after the slash should ideally be absolute, but this
// is not strictly required. It is possible to overlay the location of a single
// resource with an individual file.
type Resource struct {
	native *C.GResource
}

func wrapResource(p *C.GResource) *Resource {
	v := Resource{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*Resource).free)

	return &v
}

func marshalResource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GResource)(unsafe.Pointer(b))

	return wrapResource(c)
}

func (r *Resource) free() {}

// Native returns the pointer to *C.GResource. The caller is expected to
// cast.
func (r *Resource) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

func NewResource(data *glib.Bytes) *Resource

// SettingsSchema: the SchemaSource and Schema APIs provide a mechanism for
// advanced control over the loading of schemas and a mechanism for
// introspecting their content.
//
// Plugin loading systems that wish to provide plugins a way to access settings
// face the problem of how to make the schemas for these settings visible to
// GSettings. Typically, a plugin will want to ship the schema along with itself
// and it won't be installed into the standard system directories for schemas.
//
// SchemaSource provides a mechanism for dealing with this by allowing the
// creation of a new 'schema source' from which schemas can be acquired. This
// schema source can then become part of the metadata associated with the plugin
// and queried whenever the plugin requires access to some settings.
//
// Consider the following example:
//
//    typedef struct
//    {
//       ...
//       GSettingsSchemaSource *schema_source;
//       ...
//    } Plugin;
//
//    Plugin *
//    initialise_plugin (const gchar *dir)
//    {
//      Plugin *plugin;
//
//      ...
//
//      plugin->schema_source =
//        g_settings_schema_source_new_from_directory (dir,
//          g_settings_schema_source_get_default (), FALSE, NULL);
//
//      ...
//
//      return plugin;
//    }
//
//    ...
//
//    GSettings *
//    plugin_get_settings (Plugin      *plugin,
//                         const gchar *schema_id)
//    {
//      GSettingsSchema *schema;
//
//      if (schema_id == NULL)
//        schema_id = plugin->identifier;
//
//      schema = g_settings_schema_source_lookup (plugin->schema_source,
//                                                schema_id, FALSE);
//
//      if (schema == NULL)
//        {
//          ... disable the plugin or abort, etc ...
//        }
//
//      return g_settings_new_full (schema, NULL, NULL);
//    }
//
//
// The code above shows how hooks should be added to the code that initialises
// (or enables) the plugin to create the schema source and how an API can be
// added to the plugin system to provide a convenient way for the plugin to
// access its settings, using the schemas that it ships.
//
// From the standpoint of the plugin, it would need to ensure that it ships a
// gschemas.compiled file as part of itself, and then simply do the following:
//
//    {
//      GSettings *settings;
//      gint some_value;
//
//      settings = plugin_get_settings (self, NULL);
//      some_value = g_settings_get_int (settings, "some-value");
//      ...
//    }
//
//
// It's also possible that the plugin system expects the schema source files
// (ie: .gschema.xml files) instead of a gschemas.compiled file. In that case,
// the plugin loading system must compile the schemas for itself before
// attempting to create the settings source.
type SettingsSchema struct {
	native *C.GSettingsSchema
}

func wrapSettingsSchema(p *C.GSettingsSchema) *SettingsSchema {
	v := SettingsSchema{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*SettingsSchema).free)

	return &v
}

func marshalSettingsSchema(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GSettingsSchema)(unsafe.Pointer(b))

	return wrapSettingsSchema(c)
}

func (s *SettingsSchema) free() {}

// Native returns the pointer to *C.GSettingsSchema. The caller is expected to
// cast.
func (s *SettingsSchema) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// SettingsSchemaKey is an opaque data structure and can only be accessed using
// the following functions.
type SettingsSchemaKey struct {
	native *C.GSettingsSchemaKey
}

func wrapSettingsSchemaKey(p *C.GSettingsSchemaKey) *SettingsSchemaKey {
	v := SettingsSchemaKey{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*SettingsSchemaKey).free)

	return &v
}

func marshalSettingsSchemaKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GSettingsSchemaKey)(unsafe.Pointer(b))

	return wrapSettingsSchemaKey(c)
}

func (s *SettingsSchemaKey) free() {}

// Native returns the pointer to *C.GSettingsSchemaKey. The caller is expected to
// cast.
func (s *SettingsSchemaKey) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// SettingsSchemaSource: this is an opaque structure type. You may not access it
// directly.
type SettingsSchemaSource struct {
	native *C.GSettingsSchemaSource
}

func wrapSettingsSchemaSource(p *C.GSettingsSchemaSource) *SettingsSchemaSource {
	v := SettingsSchemaSource{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*SettingsSchemaSource).free)

	return &v
}

func marshalSettingsSchemaSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GSettingsSchemaSource)(unsafe.Pointer(b))

	return wrapSettingsSchemaSource(c)
}

func (s *SettingsSchemaSource) free() {}

// Native returns the pointer to *C.GSettingsSchemaSource. The caller is expected to
// cast.
func (s *SettingsSchemaSource) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

func NewSettingsSchemaSource(directory string, parent *SettingsSchemaSource, trusted bool) *SettingsSchemaSource

// SrvTarget: SRV (service) records are used by some network protocols to
// provide service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain; rather than
// connecting directly to "example.com" or assuming a specific server hostname
// like "xmpp.example.com", an XMPP client would look up the "xmpp-client" SRV
// record for "example.com", and then connect to whatever host was pointed to by
// that record.
//
// You can use g_resolver_lookup_service() or g_resolver_lookup_service_async()
// to find the Targets for a given service. However, if you are simply planning
// to connect to the remote service, you can use Service's Connectable interface
// and not need to worry about Target at all.
type SrvTarget struct {
	native *C.GSrvTarget
}

func wrapSrvTarget(p *C.GSrvTarget) *SrvTarget {
	v := SrvTarget{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*SrvTarget).free)

	return &v
}

func marshalSrvTarget(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GSrvTarget)(unsafe.Pointer(b))

	return wrapSrvTarget(c)
}

func (s *SrvTarget) free() {}

// Native returns the pointer to *C.GSrvTarget. The caller is expected to
// cast.
func (s *SrvTarget) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget

// StaticResource is an opaque data structure and can only be accessed using the
// following functions.
type StaticResource struct {
	native *C.GStaticResource
}

func wrapStaticResource(p *C.GStaticResource) *StaticResource {
	v := StaticResource{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*StaticResource).free)

	return &v
}

func marshalStaticResource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GStaticResource)(unsafe.Pointer(b))

	return wrapStaticResource(c)
}

func (s *StaticResource) free() {}

// Native returns the pointer to *C.GStaticResource. The caller is expected to
// cast.
func (s *StaticResource) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// UnixMountEntry: defines a Unix mount entry (e.g.
// <filename>/media/cdrom</filename>). This corresponds roughly to a mtab entry.
type UnixMountEntry struct {
	native *C.GUnixMountEntry
}

func wrapUnixMountEntry(p *C.GUnixMountEntry) *UnixMountEntry {
	v := UnixMountEntry{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*UnixMountEntry).free)

	return &v
}

func marshalUnixMountEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GUnixMountEntry)(unsafe.Pointer(b))

	return wrapUnixMountEntry(c)
}

func (u *UnixMountEntry) free() {}

// Native returns the pointer to *C.GUnixMountEntry. The caller is expected to
// cast.
func (u *UnixMountEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(u.native)
}

// UnixMountPoint: defines a Unix mount point (e.g. <filename>/dev</filename>).
// This corresponds roughly to a fstab entry.
type UnixMountPoint struct {
	native *C.GUnixMountPoint
}

func wrapUnixMountPoint(p *C.GUnixMountPoint) *UnixMountPoint {
	v := UnixMountPoint{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*UnixMountPoint).free)

	return &v
}

func marshalUnixMountPoint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GUnixMountPoint)(unsafe.Pointer(b))

	return wrapUnixMountPoint(c)
}

func (u *UnixMountPoint) free() {}

// Native returns the pointer to *C.GUnixMountPoint. The caller is expected to
// cast.
func (u *UnixMountPoint) Native() unsafe.Pointer {
	return unsafe.Pointer(u.native)
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor struct {
	*externglib.Object
}

func wrapAppInfoMonitor(obj *externglib.Object) *AppInfoMonitor {
	return &AppInfoMonitor{*externglib.Object{obj}}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
type AppLaunchContext struct {
	*externglib.Object
}

func wrapAppLaunchContext(obj *externglib.Object) *AppLaunchContext {
	return &AppLaunchContext{*externglib.Object{obj}}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAppLaunchContext() *AppLaunchContext

// Application: a #GApplication is the foundation of an application. It wraps
// some low-level platform-specific services and is intended to act as the
// foundation for higher-level application classes such as Application or
// Application. In general, you should not use this class outside of a higher
// level framework.
//
// GApplication provides convenient life cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using g_application_hold() and g_application_release(). If it drops to zero,
// the application exits. Higher-level classes such as Application employ the
// use count to ensure that the application stays alive as long as it has any
// opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent, but
// corresponds roughly to a graphical desktop login. When your application is
// launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
//
// The use of #GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a #GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling g_application_run(). All checks for uniqueness are
// done internally. If the application is the primary instance then the startup
// signal is emitted and the mainloop runs. If the application is not the
// primary instance then a signal is sent to the primary instance and
// g_application_run() promptly returns. See the code examples below.
//
// If used, the expected form of an application identifier is the same as that
// of of a [D-Bus well-known bus
// name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: `com.example.MyApp`,
// `org.example.internal_apps.Calculator`, `org._7_zip.Archiver`. For details on
// valid application identifiers, see g_application_id_is_valid().
//
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application is
// scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with the
// shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is not
// running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in g_application_register()).
// Unfortunately, this means that you cannot use g_application_get_is_remote()
// to decide if you want to register object paths.
//
// GApplication also implements the Group and Map interfaces and lets you easily
// export actions by adding them with g_action_map_add_action(). When invoking
// an action by calling g_action_group_activate_action() on the application, it
// is always invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the BusActionGroup wrapper to conveniently
// access them remotely. GIO provides a BusMenuModel wrapper for remote access
// to exported Models.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the application,
// GApplication passes some platform data from the launching instance to the
// primary instance, in the form of a #GVariant dictionary mapping strings to
// variants. To use platform data, override the @before_emit or @after_emit
// virtual functions in your #GApplication subclass. When dealing with
// CommandLine objects, the platform data is directly available via
// g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
//
// As the name indicates, the platform data may vary depending on the operating
// system, but it always includes the current directory (key "cwd"), and
// optionally the environment (ie the set of environment variables and their
// values) of the calling process (key "environ"). The environment is only added
// to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// #GApplication subclasses can add their own platform data by overriding the
// @add_platform_data virtual function. For instance, Application adds startup
// notification data in this way.
//
// To parse commandline arguments you may handle the #GApplication::command-line
// signal or override the local_command_line() vfunc, to parse them in either
// the primary instance or the local instance, respectively.
//
// For an example of opening files with a GApplication, see
// [gapplication-example-open.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication, see
// [gapplication-example-actions.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with GApplication, see
// [gapplication-example-dbushooks.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).
type Application struct {
	*externglib.Object
}

func wrapApplication(obj *externglib.Object) *Application {
	return &Application{*externglib.Object{obj}}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewApplication(applicationID string, flags ApplicationFlags) *Application

// ApplicationCommandLine: commandLine represents a command-line invocation of
// an application. It is created by #GApplication and emitted in the
// #GApplication::command-line signal and virtual function.
//
// The class contains the list of arguments that the program was invoked with.
// It is also possible to query if the commandline invocation was local (ie: the
// current process is running in direct response to the invocation) or remote
// (ie: some other process forwarded the commandline to this process).
//
// The GApplicationCommandLine object can provide the @argc and @argv parameters
// for use with the Context command-line parsing API, with the
// g_application_command_line_get_arguments() function. See
// [gapplication-example-cmdline3.c][gapplication-example-cmdline3] for an
// example.
//
// The exit status of the originally-invoked process may be set and messages can
// be printed to stdout or stderr of that process. The lifecycle of the
// originally-invoked process is tied to the lifecycle of this object (ie: the
// process exits when the last reference is dropped).
//
// The main use for CommandLine (and the #GApplication::command-line signal) is
// 'Emacs server' like use cases: You can set the `EDITOR` environment variable
// to have e.g. git use your favourite editor to edit commit messages, and if
// you already have an instance of the editor running, the editing will happen
// in the running instance, instead of opening a new one. An important aspect of
// this use case is that the process that gets started by git does not return
// until the editing is done.
//
// Normally, the commandline is completely handled in the
// #GApplication::command-line handler. The launching instance exits once the
// signal handler in the primary instance has returned, and the return value of
// the signal handler becomes the exit status of the launching instance. |[<!--
// language="C" --> static int command_line (GApplication *application,
// GApplicationCommandLine *cmdline) { gchar **argv; gint argc; gint i;
//
// argv = g_application_command_line_get_arguments (cmdline, &argc);
//
// g_application_command_line_print (cmdline, "This text is written back\n" "to
// stdout of the caller\n");
//
// for (i = 0; i < argc; i++) g_print ("argument d: s\n", i, argv[i]);
//
// g_strfreev (argv);
//
// return 0; } ]| The complete example can be found here:
// [gapplication-example-cmdline.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline.c)
//
// In more complicated cases, the handling of the comandline can be split
// between the launcher and the primary instance. |[<!-- language="C" --> static
// gboolean test_local_cmdline (GApplication *application, gchar ***arguments,
// gint *exit_status) { gint i, j; gchar **argv;
//
// argv = *arguments;
//
// i = 1; while (argv[i]) { if (g_str_has_prefix (argv[i], "--local-")) {
// g_print ("handling argument s locally\n", argv[i]); g_free (argv[i]); for (j
// = i; argv[j]; j++) argv[j] = argv[j + 1]; } else { g_print ("not handling
// argument s locally\n", argv[i]); i++; } }
//
// *exit_status = 0;
//
// return FALSE; }
//
// static void test_application_class_init (TestApplicationClass *class) {
// G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;
//
// ... } ]| In this example of split commandline handling, options that start
// with `--local-` are handled locally, all other options are passed to the
// #GApplication::command-line handler which runs in the primary instance.
//
// The complete example can be found here:
// [gapplication-example-cmdline2.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline2.c)
//
// If handling the commandline requires a lot of work, it may be better to defer
// it. |[<!-- language="C" --> static gboolean my_cmdline_handler (gpointer
// data) { GApplicationCommandLine *cmdline = data;
//
// // do the heavy lifting in an idle
//
// g_application_command_line_set_exit_status (cmdline, 0); g_object_unref
// (cmdline); // this releases the application
//
// return G_SOURCE_REMOVE; }
//
// static int command_line (GApplication *application, GApplicationCommandLine
// *cmdline) { // keep the application running until we are done with this
// commandline g_application_hold (application);
//
// g_object_set_data_full (G_OBJECT (cmdline), "application", application,
// (GDestroyNotify)g_application_release);
//
// g_object_ref (cmdline); g_idle_add (my_cmdline_handler, cmdline);
//
// return 0; } ]| In this example the commandline is not completely handled
// before the #GApplication::command-line handler returns. Instead, we keep a
// reference to the CommandLine object and handle it later (in this example, in
// an idle). Note that it is necessary to hold the application until you are
// done with the commandline.
//
// The complete example can be found here:
// [gapplication-example-cmdline3.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline3.c)
type ApplicationCommandLine struct {
	*externglib.Object
}

func wrapApplicationCommandLine(obj *externglib.Object) *ApplicationCommandLine {
	return &ApplicationCommandLine{*externglib.Object{obj}}
}

func marshalApplicationCommandLine(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// BufferedInputStream: buffered input stream implements InputStream and
// provides for buffered reads.
//
// By default, InputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered input stream, use g_buffered_input_stream_new(), or
// g_buffered_input_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_input_stream_get_buffer_size(). To change the size of a buffered
// input stream's buffer, use g_buffered_input_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedInputStream struct {
	FilterInputStream
}

func wrapBufferedInputStream(obj *externglib.Object) *BufferedInputStream {
	return &BufferedInputStream{FilterInputStream{InputStream{*externglib.Object{obj}}}}
}

func marshalBufferedInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBufferedInputStream(baseStream *InputStream) *BufferedInputStream

func NewBufferedInputStream(baseStream *InputStream, size uint) *BufferedInputStream

// BufferedOutputStream: buffered output stream implements OutputStream and
// provides for buffered writes.
//
// By default, OutputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered output stream, use g_buffered_output_stream_new(), or
// g_buffered_output_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_output_stream_get_buffer_size(). To change the size of a buffered
// output stream's buffer, use g_buffered_output_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedOutputStream struct {
	FilterOutputStream
}

func wrapBufferedOutputStream(obj *externglib.Object) *BufferedOutputStream {
	return &BufferedOutputStream{FilterOutputStream{OutputStream{*externglib.Object{obj}}}}
}

func marshalBufferedOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBufferedOutputStream(baseStream *OutputStream) *BufferedOutputStream

func NewBufferedOutputStream(baseStream *OutputStream, size uint) *BufferedOutputStream

// BytesIcon: icon specifies an image held in memory in a common format (usually
// png) to be used as icon.
type BytesIcon struct {
	*externglib.Object
}

func wrapBytesIcon(obj *externglib.Object) *BytesIcon {
	return &BytesIcon{*externglib.Object{obj}}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBytesIcon(bytes *glib.Bytes) *BytesIcon

// Cancellable: GCancellable is a thread-safe operation cancellation stack used
// throughout GIO to allow for cancellation of synchronous and asynchronous
// operations.
type Cancellable struct {
	*externglib.Object
}

func wrapCancellable(obj *externglib.Object) *Cancellable {
	return &Cancellable{*externglib.Object{obj}}
}

func marshalCancellable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCancellable() *Cancellable

// CharsetConverter is an implementation of #GConverter based on GIConv.
type CharsetConverter struct {
	*externglib.Object
}

func wrapCharsetConverter(obj *externglib.Object) *CharsetConverter {
	return &CharsetConverter{*externglib.Object{obj}}
}

func marshalCharsetConverter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCharsetConverter(toCharset string, fromCharset string) *CharsetConverter

// ConverterInputStream: converter input stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, InputStream implements InputStream.
type ConverterInputStream struct {
	FilterInputStream
}

func wrapConverterInputStream(obj *externglib.Object) *ConverterInputStream {
	return &ConverterInputStream{FilterInputStream{InputStream{*externglib.Object{obj}}}}
}

func marshalConverterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewConverterInputStream(baseStream *InputStream, converter Converter) *ConverterInputStream

// ConverterOutputStream: converter output stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, OutputStream implements OutputStream.
type ConverterOutputStream struct {
	FilterOutputStream
}

func wrapConverterOutputStream(obj *externglib.Object) *ConverterOutputStream {
	return &ConverterOutputStream{FilterOutputStream{OutputStream{*externglib.Object{obj}}}}
}

func marshalConverterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewConverterOutputStream(baseStream *OutputStream, converter Converter) *ConverterOutputStream

// Credentials: the #GCredentials type is a reference-counted wrapper for native
// credentials. This information is typically used for identifying,
// authenticating and authorizing other processes.
//
// Some operating systems supports looking up the credentials of the remote peer
// of a communication endpoint - see e.g. g_socket_get_credentials().
//
// Some operating systems supports securely sending and receiving credentials
// over a Unix Domain Socket, see CredentialsMessage,
// g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials() for details.
//
// On Linux, the native credential type is a `struct ucred` - see the unix(7)
// man page for details. This corresponds to G_CREDENTIALS_TYPE_LINUX_UCRED.
//
// On Apple operating systems (including iOS, tvOS, and macOS), the native
// credential type is a `struct xucred`. This corresponds to
// G_CREDENTIALS_TYPE_APPLE_XUCRED.
//
// On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is
// a `struct cmsgcred`. This corresponds to G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
//
// On NetBSD, the native credential type is a `struct unpcbid`. This corresponds
// to G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
//
// On OpenBSD, the native credential type is a `struct sockpeercred`. This
// corresponds to G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
//
// On Solaris (including OpenSolaris and its derivatives), the native credential
// type is a `ucred_t`. This corresponds to G_CREDENTIALS_TYPE_SOLARIS_UCRED.
type Credentials struct {
	*externglib.Object
}

func wrapCredentials(obj *externglib.Object) *Credentials {
	return &Credentials{*externglib.Object{obj}}
}

func marshalCredentials(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCredentials() *Credentials

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup struct {
	*externglib.Object
}

func wrapDBusActionGroup(obj *externglib.Object) *DBusActionGroup {
	return &DBusActionGroup{*externglib.Object{obj}}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_allow_mechanism (GDBusAuthObserver *observer,
//                        const gchar       *mechanism,
//                        gpointer           user_data)
//    {
//      if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
//        {
//          return TRUE;
//        }
//
//      return FALSE;
//    }
//
//
// Controlling Authorization {#auth-observer}
//
// By default, a BusServer or server-side BusConnection will accept connections
// from any successfully authenticated user (but not from anonymous connections
// using the `ANONYMOUS` mechanism). If you only want to allow D-Bus connections
// from processes owned by the same uid as the server, you would use a signal
// handler like the following:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
//
type DBusAuthObserver struct {
	*externglib.Object
}

func wrapDBusAuthObserver(obj *externglib.Object) *DBusAuthObserver {
	return &DBusAuthObserver{*externglib.Object{obj}}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDBusAuthObserver() *DBusAuthObserver

// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
// An example D-Bus server {#gdbus-server}
//
// Here is an example for a D-Bus server:
// [gdbus-example-server.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
// An example for exporting a subtree {#gdbus-subtree-server}
//
// Here is an example for exporting a subtree:
// [gdbus-example-subtree.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
// An example for file descriptor passing {#gdbus-unix-fd-client}
//
// Here is an example for passing UNIX file descriptors:
// [gdbus-unix-fd-client.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
// An example for exporting a GObject {#gdbus-export}
//
// Here is an example for exporting a #GObject:
// [gdbus-example-export.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection struct {
	*externglib.Object
}

func wrapDBusConnection(obj *externglib.Object) *DBusConnection {
	return &DBusConnection{*externglib.Object{obj}}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDBusConnection(res AsyncResult) *DBusConnection

func NewDBusConnection(res AsyncResult) *DBusConnection

func NewDBusConnection(address string, flags DBusConnectionFlags, observer *DBusAuthObserver, cancellable *Cancellable) *DBusConnection

func NewDBusConnection(stream *IOStream, guid string, flags DBusConnectionFlags, observer *DBusAuthObserver, cancellable *Cancellable) *DBusConnection

// DBusInterfaceSkeleton: abstract base class for D-Bus interfaces on the
// service side.
type DBusInterfaceSkeleton struct {
	*externglib.Object
}

func wrapDBusInterfaceSkeleton(obj *externglib.Object) *DBusInterfaceSkeleton {
	return &DBusInterfaceSkeleton{*externglib.Object{obj}}
}

func marshalDBusInterfaceSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel struct {
	MenuModel
}

func wrapDBusMenuModel(obj *externglib.Object) *DBusMenuModel {
	return &DBusMenuModel{MenuModel{*externglib.Object{obj}}}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusMessage: a type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage struct {
	*externglib.Object
}

func wrapDBusMessage(obj *externglib.Object) *DBusMessage {
	return &DBusMessage{*externglib.Object{obj}}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDBusMessage() *DBusMessage

func NewDBusMessage(blob []uint8, blobLen uint, capabilities DBusCapabilityFlags) *DBusMessage

func NewDBusMessage(name string, path string, interface_ string, method string) *DBusMessage

func NewDBusMessage(path string, interface_ string, signal string) *DBusMessage

// DBusMethodInvocation: instances of the BusMethodInvocation class are used
// when handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation struct {
	*externglib.Object
}

func wrapDBusMethodInvocation(obj *externglib.Object) *DBusMethodInvocation {
	return &DBusMethodInvocation{*externglib.Object{obj}}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusObjectManagerClient is used to create, monitor and delete object proxies
// for remote objects exported by a BusObjectManagerServer (or any code
// implementing the
// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
//
// Once an instance of this type has been created, you can connect to the
// BusObjectManager::object-added and BusObjectManager::object-removed signals
// and inspect the BusObjectProxy objects returned by
// g_dbus_object_manager_get_objects().
//
// If the name for a BusObjectManagerClient is not owned by anyone at object
// construction time, the default behavior is to request the message bus to
// launch an owner for the name. This behavior can be disabled using the
// G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START flag. It's also worth
// noting that this only works if the name of interest is activatable in the
// first place. E.g. in some cases it is not possible to launch an owner for the
// requested name. In this case, BusObjectManagerClient object construction
// still succeeds but there will be no object proxies (e.g.
// g_dbus_object_manager_get_objects() returns the empty list) and the
// BusObjectManagerClient:name-owner property is nil.
//
// The owner of the requested name can come and go (for example consider a
// system service being restarted)  BusObjectManagerClient handles this case
// too; simply connect to the #GObject::notify signal to watch for changes on
// the BusObjectManagerClient:name-owner property. When the name owner vanishes,
// the behavior is that BusObjectManagerClient:name-owner is set to nil (this
// includes emission of the #GObject::notify signal) and then
// BusObjectManager::object-removed signals are synthesized for all currently
// existing object proxies. Since BusObjectManagerClient:name-owner is nil when
// this happens, you can use this information to disambiguate a synthesized
// signal from a genuine signal caused by object removal on the remote
// BusObjectManager. Similarly, when a new name owner appears,
// BusObjectManager::object-added signals are synthesized while
// BusObjectManagerClient:name-owner is still nil. Only when all object proxies
// have been added, the BusObjectManagerClient:name-owner is set to the new name
// owner (this includes emission of the #GObject::notify signal). Furthermore,
// you are guaranteed that BusObjectManagerClient:name-owner will alternate
// between a name owner (e.g. `:1.42`) and nil even in the case where the name
// of interest is atomically replaced
//
// Ultimately, BusObjectManagerClient is used to obtain BusProxy instances. All
// signals (including the org.freedesktop.DBus.Properties::PropertiesChanged
// signal) delivered to BusProxy instances are guaranteed to originate from the
// name owner. This guarantee along with the behavior described above, means
// that certain race conditions including the "half the proxy is from the old
// owner and the other half is from the new owner" problem cannot happen.
//
// To avoid having the application connect to signals on the returned
// BusObjectProxy and BusProxy objects, the BusObject::interface-added,
// BusObject::interface-removed, BusProxy::g-properties-changed and
// BusProxy::g-signal signals are also emitted on the BusObjectManagerClient
// instance managing these objects. The signals emitted are
// BusObjectManager::interface-added, BusObjectManager::interface-removed,
// BusObjectManagerClient::interface-proxy-properties-changed and
// BusObjectManagerClient::interface-proxy-signal.
//
// Note that all callbacks and signals are emitted in the [thread-default main
// context][g-main-context-push-thread-default] that the BusObjectManagerClient
// object was constructed in. Additionally, the BusObjectProxy and BusProxy
// objects originating from the BusObjectManagerClient object will be created in
// the same context and, consequently, will deliver signals in the same main
// loop.
type DBusObjectManagerClient struct {
	*externglib.Object
}

func wrapDBusObjectManagerClient(obj *externglib.Object) *DBusObjectManagerClient {
	return &DBusObjectManagerClient{*externglib.Object{obj}}
}

func marshalDBusObjectManagerClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDBusObjectManagerClient(res AsyncResult) *DBusObjectManagerClient

func NewDBusObjectManagerClient(res AsyncResult) *DBusObjectManagerClient

func NewDBusObjectManagerClient(busType BusType, flags DBusObjectManagerClientFlags, name string, objectPath string, getProxyTypeFunc DBusProxyTypeFunc, getProxyTypeUserData unsafe.Pointer, getProxyTypeDestroyNotify unsafe.Pointer, cancellable *Cancellable) *DBusObjectManagerClient

func NewDBusObjectManagerClient(connection *DBusConnection, flags DBusObjectManagerClientFlags, name string, objectPath string, getProxyTypeFunc DBusProxyTypeFunc, getProxyTypeUserData unsafe.Pointer, getProxyTypeDestroyNotify unsafe.Pointer, cancellable *Cancellable) *DBusObjectManagerClient

// DBusObjectManagerServer is used to export BusObject instances using the
// standardized
// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface. For example, remote D-Bus clients can get all objects and
// properties in a single call. Additionally, any change in the object hierarchy
// is broadcast using signals. This means that D-Bus clients can keep caches up
// to date by only listening to D-Bus signals.
//
// The recommended path to export an object manager at is the path form of the
// well-known name of a D-Bus service, or below. For example, if a D-Bus service
// is available at the well-known name `net.example.ExampleService1`, the object
// manager should typically be exported at `/net/example/ExampleService1`, or
// below (to allow for multiple object managers in a service).
//
// It is supported, but not recommended, to export an object manager at the root
// path, `/`.
//
// See BusObjectManagerClient for the client-side code that is intended to be
// used with BusObjectManagerServer or any D-Bus object implementing the
// org.freedesktop.DBus.ObjectManager interface.
type DBusObjectManagerServer struct {
	*externglib.Object
}

func wrapDBusObjectManagerServer(obj *externglib.Object) *DBusObjectManagerServer {
	return &DBusObjectManagerServer{*externglib.Object{obj}}
}

func marshalDBusObjectManagerServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDBusObjectManagerServer(objectPath string) *DBusObjectManagerServer

// DBusObjectProxy: a BusObjectProxy is an object used to represent a remote
// object with one or more D-Bus interfaces. Normally, you don't instantiate a
// BusObjectProxy yourself - typically BusObjectManagerClient is used to obtain
// it.
type DBusObjectProxy struct {
	*externglib.Object
}

func wrapDBusObjectProxy(obj *externglib.Object) *DBusObjectProxy {
	return &DBusObjectProxy{*externglib.Object{obj}}
}

func marshalDBusObjectProxy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDBusObjectProxy(connection *DBusConnection, objectPath string) *DBusObjectProxy

// DBusObjectSkeleton: a BusObjectSkeleton instance is essentially a group of
// D-Bus interfaces. The set of exported interfaces on the object may be dynamic
// and change at runtime.
//
// This type is intended to be used with BusObjectManager.
type DBusObjectSkeleton struct {
	*externglib.Object
}

func wrapDBusObjectSkeleton(obj *externglib.Object) *DBusObjectSkeleton {
	return &DBusObjectSkeleton{*externglib.Object{obj}}
}

func marshalDBusObjectSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDBusObjectSkeleton(objectPath string) *DBusObjectSkeleton

// DBusProxy is a base class used for proxies to access a D-Bus interface on a
// remote object. A BusProxy can be constructed for both well-known and unique
// names.
//
// By default, BusProxy will cache all properties (and listen to changes) of the
// remote object, and proxy all signals that get emitted. This behaviour can be
// changed by passing suitable BusProxyFlags when the proxy is created. If the
// proxy is for a well-known name, the property cache is flushed when the name
// owner vanishes and reloaded when a name owner appears.
//
// The unique name owner of the proxy's name is tracked and can be read from
// BusProxy:g-name-owner. Connect to the #GObject::notify signal to get notified
// of changes. Additionally, only signals and property changes emitted from the
// current name owner are considered and calls are always sent to the current
// name owner. This avoids a number of race conditions when the name is lost by
// one owner and claimed by another. However, if no name owner currently exists,
// then calls will be sent to the well-known name which may result in the
// message bus launching an owner (unless G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// is set).
//
// The generic BusProxy::g-properties-changed and BusProxy::g-signal signals are
// not very convenient to work with. Therefore, the recommended way of working
// with proxies is to subclass BusProxy, and have more natural properties and
// signals in your derived class. This [example][gdbus-example-gdbus-codegen]
// shows how this can easily be done using the [gdbus-codegen][gdbus-codegen]
// tool.
//
// A BusProxy instance can be used from multiple threads but note that all
// signals (e.g. BusProxy::g-signal, BusProxy::g-properties-changed and
// #GObject::notify) are emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread where the instance
// was constructed.
//
// An example using a proxy for a well-known name can be found in
// [gdbus-example-watch-proxy.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c)
type DBusProxy struct {
	*externglib.Object
}

func wrapDBusProxy(obj *externglib.Object) *DBusProxy {
	return &DBusProxy{*externglib.Object{obj}}
}

func marshalDBusProxy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDBusProxy(res AsyncResult) *DBusProxy

func NewDBusProxy(res AsyncResult) *DBusProxy

func NewDBusProxy(busType BusType, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable *Cancellable) *DBusProxy

func NewDBusProxy(connection *DBusConnection, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable *Cancellable) *DBusProxy

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with G-DBus can be found in
// [gdbus-example-peer.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer.
type DBusServer struct {
	*externglib.Object
}

func wrapDBusServer(obj *externglib.Object) *DBusServer {
	return &DBusServer{*externglib.Object{obj}}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDBusServer(address string, flags DBusServerFlags, guid string, observer *DBusAuthObserver, cancellable *Cancellable) *DBusServer

// DataInputStream: data input stream implements Stream and includes functions
// for reading structured data directly from a binary input stream.
type DataInputStream struct {
	BufferedInputStream
}

func wrapDataInputStream(obj *externglib.Object) *DataInputStream {
	return &DataInputStream{BufferedInputStream{FilterInputStream{InputStream{*externglib.Object{obj}}}}}
}

func marshalDataInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDataInputStream(baseStream *InputStream) *DataInputStream

// DataOutputStream: data output stream implements Stream and includes functions
// for writing data directly to an output stream.
type DataOutputStream struct {
	FilterOutputStream
}

func wrapDataOutputStream(obj *externglib.Object) *DataOutputStream {
	return &DataOutputStream{FilterOutputStream{OutputStream{*externglib.Object{obj}}}}
}

func marshalDataOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDataOutputStream(baseStream *OutputStream) *DataOutputStream

// DesktopAppInfo is an implementation of Info based on desktop files.
//
// Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type DesktopAppInfo struct {
	*externglib.Object
}

func wrapDesktopAppInfo(obj *externglib.Object) *DesktopAppInfo {
	return &DesktopAppInfo{*externglib.Object{obj}}
}

func marshalDesktopAppInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDesktopAppInfo(desktopID string) *DesktopAppInfo

func NewDesktopAppInfo(filename string) *DesktopAppInfo

func NewDesktopAppInfo(keyFile *glib.KeyFile) *DesktopAppInfo

// Emblem is an implementation of #GIcon that supports having an emblem, which
// is an icon with additional properties. It can than be added to a Icon.
//
// Currently, only metainformation about the emblem's origin is supported. More
// may be added in the future.
type Emblem struct {
	*externglib.Object
}

func wrapEmblem(obj *externglib.Object) *Emblem {
	return &Emblem{*externglib.Object{obj}}
}

func marshalEmblem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEmblem(icon Icon) *Emblem

func NewEmblem(icon Icon, origin EmblemOrigin) *Emblem

// EmblemedIcon is an implementation of #GIcon that supports adding an emblem to
// an icon. Adding multiple emblems to an icon is ensured via
// g_emblemed_icon_add_emblem().
//
// Note that Icon allows no control over the position of the emblems. See also
// #GEmblem for more information.
type EmblemedIcon struct {
	*externglib.Object
}

func wrapEmblemedIcon(obj *externglib.Object) *EmblemedIcon {
	return &EmblemedIcon{*externglib.Object{obj}}
}

func marshalEmblemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEmblemedIcon(icon Icon, emblem *Emblem) *EmblemedIcon

// FileEnumerator: enumerator allows you to operate on a set of #GFiles,
// returning a Info structure for each file enumerated (e.g.
// g_file_enumerate_children() will return a Enumerator for each of the children
// within a directory).
//
// To get the next file's information from a Enumerator, use
// g_file_enumerator_next_file() or its asynchronous version,
// g_file_enumerator_next_files_async(). Note that the asynchronous version will
// return a list of Infos, whereas the synchronous will only return the next
// file in the enumerator.
//
// The ordering of returned files is unspecified for non-Unix platforms; for
// more information, see g_dir_read_name(). On Unix, when operating on local
// files, returned files will be sorted by inode number. Effectively you can
// assume that the ordering of returned files will be stable between successive
// calls (and applications) assuming the directory is unchanged.
//
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your application code.
//
// To close a Enumerator, use g_file_enumerator_close(), or its asynchronous
// version, g_file_enumerator_close_async(). Once a Enumerator is closed, no
// further actions may be performed on it, and it should be freed with
// g_object_unref().
type FileEnumerator struct {
	*externglib.Object
}

func wrapFileEnumerator(obj *externglib.Object) *FileEnumerator {
	return &FileEnumerator{*externglib.Object{obj}}
}

func marshalFileEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileIOStream: GFileIOStream provides io streams that both read and write to
// the same file handle.
//
// GFileIOStream implements #GSeekable, which allows the io stream to jump to
// arbitrary positions in the file and to truncate the file, provided the
// filesystem of the file supports these operations.
//
// To find the position of a file io stream, use g_seekable_tell().
//
// To find out if a file io stream supports seeking, use g_seekable_can_seek().
// To position a file io stream, use g_seekable_seek(). To find out if a file io
// stream supports truncating, use g_seekable_can_truncate(). To truncate a file
// io stream, use g_seekable_truncate().
//
// The default implementation of all the IOStream operations and the
// implementation of #GSeekable just call into the same operations on the output
// stream.
type FileIOStream struct {
	IOStream
}

func wrapFileIOStream(obj *externglib.Object) *FileIOStream {
	return &FileIOStream{IOStream{*externglib.Object{obj}}}
}

func marshalFileIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileIcon: icon specifies an icon by pointing to an image file to be used as
// icon.
type FileIcon struct {
	*externglib.Object
}

func wrapFileIcon(obj *externglib.Object) *FileIcon {
	return &FileIcon{*externglib.Object{obj}}
}

func marshalFileIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFileIcon(file File) *FileIcon

// FileInfo: functionality for manipulating basic metadata for files. Info
// implements methods for getting information that all files should contain, and
// allows for manipulation of extended attributes.
//
// See [GFileAttribute][gio-GFileAttribute] for more information on how GIO
// handles file attributes.
//
// To obtain a Info for a #GFile, use g_file_query_info() (or its async
// variant). To obtain a Info for a file input or output stream, use
// g_file_input_stream_query_info() or g_file_output_stream_query_info() (or
// their async variants).
//
// To change the actual attributes of a file, you should then set the attribute
// in the Info and call g_file_set_attributes_from_info() or
// g_file_set_attributes_async() on a GFile.
//
// However, not all attributes can be changed in the file. For instance, the
// actual size of a file cannot be changed via g_file_info_set_size(). You may
// call g_file_query_settable_attributes() and
// g_file_query_writable_namespaces() to discover the settable attributes of a
// particular file at runtime.
//
// AttributeMatcher allows for searching through a Info for attributes.
type FileInfo struct {
	*externglib.Object
}

func wrapFileInfo(obj *externglib.Object) *FileInfo {
	return &FileInfo{*externglib.Object{obj}}
}

func marshalFileInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFileInfo() *FileInfo

// FileInputStream: GFileInputStream provides input streams that take their
// content from a file.
//
// GFileInputStream implements #GSeekable, which allows the input stream to jump
// to arbitrary positions in the file, provided the filesystem of the file
// allows it. To find the position of a file input stream, use
// g_seekable_tell(). To find out if a file input stream supports seeking, use
// g_seekable_can_seek(). To position a file input stream, use
// g_seekable_seek().
type FileInputStream struct {
	InputStream
}

func wrapFileInputStream(obj *externglib.Object) *FileInputStream {
	return &FileInputStream{InputStream{*externglib.Object{obj}}}
}

func marshalFileInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileMonitor: monitors a file or directory for changes.
//
// To obtain a Monitor for a file or directory, use g_file_monitor(),
// g_file_monitor_file(), or g_file_monitor_directory().
//
// To get informed about changes to the file or directory you are monitoring,
// connect to the Monitor::changed signal. The signal will be emitted in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that the monitor was created in (though if the global default main
// context is blocked, this may cause notifications to be blocked even if the
// thread-default context is still running).
type FileMonitor struct {
	*externglib.Object
}

func wrapFileMonitor(obj *externglib.Object) *FileMonitor {
	return &FileMonitor{*externglib.Object{obj}}
}

func marshalFileMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileOutputStream: GFileOutputStream provides output streams that write their
// content to a file.
//
// GFileOutputStream implements #GSeekable, which allows the output stream to
// jump to arbitrary positions in the file and to truncate the file, provided
// the filesystem of the file supports these operations.
//
// To find the position of a file output stream, use g_seekable_tell(). To find
// out if a file output stream supports seeking, use g_seekable_can_seek().To
// position a file output stream, use g_seekable_seek(). To find out if a file
// output stream supports truncating, use g_seekable_can_truncate(). To truncate
// a file output stream, use g_seekable_truncate().
type FileOutputStream struct {
	OutputStream
}

func wrapFileOutputStream(obj *externglib.Object) *FileOutputStream {
	return &FileOutputStream{OutputStream{*externglib.Object{obj}}}
}

func marshalFileOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FilenameCompleter: completes partial file and directory names given a partial
// string by looking in the file system for clues. Can return a list of possible
// completion strings for widget implementations.
type FilenameCompleter struct {
	*externglib.Object
}

func wrapFilenameCompleter(obj *externglib.Object) *FilenameCompleter {
	return &FilenameCompleter{*externglib.Object{obj}}
}

func marshalFilenameCompleter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFilenameCompleter() *FilenameCompleter

// FilterInputStream: base class for input stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterInputStream struct {
	InputStream
}

func wrapFilterInputStream(obj *externglib.Object) *FilterInputStream {
	return &FilterInputStream{InputStream{*externglib.Object{obj}}}
}

func marshalFilterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FilterOutputStream: base class for output stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterOutputStream struct {
	OutputStream
}

func wrapFilterOutputStream(obj *externglib.Object) *FilterOutputStream {
	return &FilterOutputStream{OutputStream{*externglib.Object{obj}}}
}

func marshalFilterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// IOStream: GIOStream represents an object that has both read and write
// streams. Generally the two streams act as separate input and output streams,
// but they share some common resources and state. For instance, for seekable
// streams, both streams may use the same position.
//
// Examples of OStream objects are Connection, which represents a two-way
// network connection; and IOStream, which represents a file handle opened in
// read-write mode.
//
// To do the actual reading and writing you need to get the substreams with
// g_io_stream_get_input_stream() and g_io_stream_get_output_stream().
//
// The OStream object owns the input and the output streams, not the other way
// around, so keeping the substreams alive will not keep the OStream object
// alive. If the OStream object is freed it will be closed, thus closing the
// substreams, so even if the substreams stay alive they will always return
// G_IO_ERROR_CLOSED for all operations.
//
// To close a stream use g_io_stream_close() which will close the common stream
// object and also the individual substreams. You can also close the substreams
// themselves. In most cases this only marks the substream as closed, so further
// I/O on it fails but common state in the OStream may still be open. However,
// some streams may support "half-closed" states where one direction of the
// stream is actually shut down.
//
// Operations on OStreams cannot be started while another operation on the
// OStream or its substreams is in progress. Specifically, an application can
// read from the Stream and write to the Stream simultaneously (either in
// separate threads, or as asynchronous operations in the same thread), but an
// application cannot start any OStream operation while there is a OStream,
// Stream or Stream operation in progress, and an application cant start any
// Stream or Stream operation while there is a OStream operation in progress.
//
// This is a product of individual stream operations being associated with a
// given Context (the thread-default context at the time the operation was
// started), rather than entire streams being associated with a single Context.
//
// GIO may run operations on OStreams from other (worker) threads, and this may
// be exposed to application code in the behaviour of wrapper streams, such as
// InputStream or Connection. With such wrapper APIs, application code may only
// run operations on the base (wrapped) stream when the wrapper stream is idle.
// Note that the semantics of such operations may not be well-defined due to the
// state the wrapper stream leaves the base stream in (though they are
// guaranteed not to crash).
type IOStream struct {
	*externglib.Object
}

func wrapIOStream(obj *externglib.Object) *IOStream {
	return &IOStream{*externglib.Object{obj}}
}

func marshalIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// InetAddress: address represents an IPv4 or IPv6 internet address. Use
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to look up
// the Address for a hostname. Use g_resolver_lookup_by_address() or
// g_resolver_lookup_by_address_async() to look up the hostname for a Address.
//
// To actually connect to a remote host, you will need a SocketAddress (which
// includes a Address as well as a port number).
type InetAddress struct {
	*externglib.Object
}

func wrapInetAddress(obj *externglib.Object) *InetAddress {
	return &InetAddress{*externglib.Object{obj}}
}

func marshalInetAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewInetAddress(family SocketFamily) *InetAddress

func NewInetAddress(bytes []uint8, family SocketFamily) *InetAddress

func NewInetAddress(string string) *InetAddress

func NewInetAddress(family SocketFamily) *InetAddress

// InetAddressMask: addressMask represents a range of IPv4 or IPv6 addresses
// described by a base address and a length indicating how many bits of the base
// address are relevant for matching purposes. These are often given in string
// form. Eg, "10.0.0.0/8", or "fe80::/10".
type InetAddressMask struct {
	*externglib.Object
}

func wrapInetAddressMask(obj *externglib.Object) *InetAddressMask {
	return &InetAddressMask{*externglib.Object{obj}}
}

func marshalInetAddressMask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewInetAddressMask(addr *InetAddress, length uint) *InetAddressMask

func NewInetAddressMask(maskString string) *InetAddressMask

// InetSocketAddress: an IPv4 or IPv6 socket address; that is, the combination
// of a Address and a port number.
type InetSocketAddress struct {
	SocketAddress
}

func wrapInetSocketAddress(obj *externglib.Object) *InetSocketAddress {
	return &InetSocketAddress{SocketAddress{*externglib.Object{obj}}}
}

func marshalInetSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewInetSocketAddress(address *InetAddress, port uint16) *InetSocketAddress

func NewInetSocketAddress(address string, port uint) *InetSocketAddress

// InputStream: stream has functions to read from a stream
// (g_input_stream_read()), to close a stream (g_input_stream_close()) and to
// skip some content (g_input_stream_skip()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type InputStream struct {
	*externglib.Object
}

func wrapInputStream(obj *externglib.Object) *InputStream {
	return &InputStream{*externglib.Object{obj}}
}

func marshalInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ListStore is a simple implementation of Model that stores all items in
// memory.
//
// It provides insertions, deletions, and lookups in logarithmic time with a
// fast path for the common case of iterating the list linearly.
type ListStore struct {
	*externglib.Object
}

func wrapListStore(obj *externglib.Object) *ListStore {
	return &ListStore{*externglib.Object{obj}}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewListStore(itemType externglib.Type) *ListStore

// MemoryInputStream is a class for using arbitrary memory chunks as input for
// GIO streaming input operations.
//
// As of GLib 2.34, InputStream implements InputStream.
type MemoryInputStream struct {
	InputStream
}

func wrapMemoryInputStream(obj *externglib.Object) *MemoryInputStream {
	return &MemoryInputStream{InputStream{*externglib.Object{obj}}}
}

func marshalMemoryInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMemoryInputStream() *MemoryInputStream

func NewMemoryInputStream(bytes *glib.Bytes) *MemoryInputStream

func NewMemoryInputStream(data []uint8, len int, destroy unsafe.Pointer) *MemoryInputStream

// MemoryOutputStream is a class for using arbitrary memory chunks as output for
// GIO streaming output operations.
//
// As of GLib 2.34, OutputStream trivially implements OutputStream: it always
// polls as ready.
type MemoryOutputStream struct {
	OutputStream
}

func wrapMemoryOutputStream(obj *externglib.Object) *MemoryOutputStream {
	return &MemoryOutputStream{OutputStream{*externglib.Object{obj}}}
}

func marshalMemoryOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMemoryOutputStream(data unsafe.Pointer, size uint, reallocFunction ReallocFunc, destroyFunction unsafe.Pointer) *MemoryOutputStream

func NewMemoryOutputStream() *MemoryOutputStream

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu struct {
	MenuModel
}

func wrapMenu(obj *externglib.Object) *Menu {
	return &Menu{MenuModel{*externglib.Object{obj}}}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMenu() *Menu

// MenuAttributeIter is an opaque structure type. You must access it using the
// functions below.
type MenuAttributeIter struct {
	*externglib.Object
}

func wrapMenuAttributeIter(obj *externglib.Object) *MenuAttributeIter {
	return &MenuAttributeIter{*externglib.Object{obj}}
}

func marshalMenuAttributeIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem struct {
	*externglib.Object
}

func wrapMenuItem(obj *externglib.Object) *MenuItem {
	return &MenuItem{*externglib.Object{obj}}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMenuItem(label string, detailedAction string) *MenuItem

func NewMenuItem(model *MenuModel, itemIndex int) *MenuItem

func NewMenuItem(label string, section *MenuModel) *MenuItem

func NewMenuItem(label string, submenu *MenuModel) *MenuItem

// MenuLinkIter is an opaque structure type. You must access it using the
// functions below.
type MenuLinkIter struct {
	*externglib.Object
}

func wrapMenuLinkIter(obj *externglib.Object) *MenuLinkIter {
	return &MenuLinkIter{*externglib.Object{obj}}
}

func marshalMenuLinkIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MenuModel: model represents the contents of a menu -- an ordered list of menu
// items. The items are associated with actions, which can be activated through
// them. Items can be grouped in sections, and may have submenus associated with
// them. Both items and sections usually have some representation data, such as
// labels or icons. The type of the associated action (ie whether it is
// stateful, and what kind of state it has) can influence the representation of
// the item.
//
// The conceptual model of menus in Model is hierarchical: sections and submenus
// are again represented by Models. Menus themselves do not define their own
// roles. Rather, the role of a particular Model is defined by the item that
// references it (or, in the case of the 'root' menu, is defined by the context
// in which it is used).
//
// As an example, consider the visible portions of this menu:
//
// An example menu {#menu-example}
//
// ![](menu-example.png)
//
// There are 8 "menus" visible in the screenshot: one menubar, two submenus and
// 5 sections:
//
// - the toplevel menubar (containing 4 items) - the View submenu (containing 3
// sections) - the first section of the View submenu (containing 2 items) - the
// second section of the View submenu (containing 1 item) - the final section of
// the View submenu (containing 1 item) - the Highlight Mode submenu (containing
// 2 sections) - the Sources section (containing 2 items) - the Markup section
// (containing 2 items)
//
// The [example][menu-model] illustrates the conceptual connection between these
// 8 menus. Each large block in the figure represents a menu and the smaller
// blocks within the large block represent items in that menu. Some items
// contain references to other menus.
//
// A menu example {#menu-model}
//
// ![](menu-model.png)
//
// Notice that the separators visible in the [example][menu-example] appear
// nowhere in the [menu model][menu-model]. This is because separators are not
// explicitly represented in the menu model. Instead, a separator is inserted
// between any two non-empty sections of a menu. Section items can have labels
// just like any other item. In that case, a display system may show a section
// header instead of a separator.
//
// The motivation for this abstract model of application controls is that modern
// user interfaces tend to make these controls available outside the
// application. Examples include global menus, jumplists, dash boards, etc. To
// support such uses, it is necessary to 'export' information about actions and
// their representation in menus, which is exactly what the [GActionGroup
// exporter][gio-GActionGroup-exporter] and the [GMenuModel
// exporter][gio-GMenuModel-exporter] do for Group and Model. The client-side
// counterparts to make use of the exported information are BusActionGroup and
// BusMenuModel.
//
// The API of Model is very generic, with iterators for the attributes and links
// of an item, see g_menu_model_iterate_item_attributes() and
// g_menu_model_iterate_item_links(). The 'standard' attributes and link types
// have predefined names: G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, G_MENU_LINK_SECTION and G_MENU_LINK_SUBMENU.
//
// Items in a Model represent active controls if they refer to an action that
// can get activated when the user interacts with the menu item. The reference
// to the action is encoded by the string id in the G_MENU_ATTRIBUTE_ACTION
// attribute. An action id uniquely identifies an action in an action group.
// Which action group(s) provide actions depends on the context in which the
// menu model is used. E.g. when the model is exported as the application menu
// of a Application, actions can be application-wide or window-specific (and
// thus come from two different action groups). By convention, the
// application-wide actions have names that start with "app.", while the names
// of window-specific actions start with "win.".
//
// While a wide variety of stateful actions is possible, the following is the
// minimum that is expected to be supported by all users of exported menu
// information: - an action with no parameter type and no state - an action with
// no parameter type and boolean state - an action with string parameter type
// and string state
//
//
// Stateless
//
// A stateless action typically corresponds to an ordinary menu item.
//
// Selecting such a menu item will activate the action (with no parameter).
//
//
// Boolean State
//
// An action with a boolean state will most typically be used with a "toggle" or
// "switch" menu item. The state can be set directly, but activating the action
// (with no parameter) results in the state being toggled.
//
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as "checked" when the state is true.
//
//
// String Parameter and State
//
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of radio
// menu items. Activating the action with a string parameter is equivalent to
// setting that parameter as the state.
//
// Radio menu items, in addition to being associated with the action, will have
// a target value. Selecting that menu item will result in activation of the
// action with the target value as the parameter. The menu item should be
// rendered as "selected" when the state of the action is equal to the target
// value of the menu item.
type MenuModel struct {
	*externglib.Object
}

func wrapMenuModel(obj *externglib.Object) *MenuModel {
	return &MenuModel{*externglib.Object{obj}}
}

func marshalMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MountOperation: operation provides a mechanism for interacting with the user.
// It can be used for authenticating mountable operations, such as loop mounting
// files, hard drive partitions or server locations. It can also be used to ask
// the user questions or show a list of applications preventing unmount or eject
// operations from completing.
//
// Note that Operation is used for more than just #GMount objects  for example
// it is also used in g_drive_start() and g_drive_stop().
//
// Users should instantiate a subclass of this that implements all the various
// callbacks to show the required dialogs, such as MountOperation. If no user
// interaction is desired (for example when automounting filesystems at login
// time), usually nil can be passed, see each method taking a Operation for
// details.
//
// The term TCRYPT is used to mean compatible with TrueCrypt and VeraCrypt.
// [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system
// for encrypting file containers, partitions or whole disks, typically used
// with Windows. [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of
// TrueCrypt with various improvements and auditing fixes.
type MountOperation struct {
	*externglib.Object
}

func wrapMountOperation(obj *externglib.Object) *MountOperation {
	return &MountOperation{*externglib.Object{obj}}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMountOperation() *MountOperation

// NativeSocketAddress: a socket address of some unknown native type.
type NativeSocketAddress struct {
	SocketAddress
}

func wrapNativeSocketAddress(obj *externglib.Object) *NativeSocketAddress {
	return &NativeSocketAddress{SocketAddress{*externglib.Object{obj}}}
}

func marshalNativeSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewNativeSocketAddress(native unsafe.Pointer, len uint) *NativeSocketAddress

type NativeVolumeMonitor struct {
	VolumeMonitor
}

func wrapNativeVolumeMonitor(obj *externglib.Object) *NativeVolumeMonitor {
	return &NativeVolumeMonitor{VolumeMonitor{*externglib.Object{obj}}}
}

func marshalNativeVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// NetworkAddress: address provides an easy way to resolve a hostname and then
// attempt to connect to that host, handling the possibility of multiple IP
// addresses and multiple address families.
//
// The enumeration results of resolved addresses *may* be cached as long as this
// object is kept alive which may have unexpected results if alive for too long.
//
// See Connectable for an example of using the connectable interface.
type NetworkAddress struct {
	*externglib.Object
}

func wrapNetworkAddress(obj *externglib.Object) *NetworkAddress {
	return &NetworkAddress{*externglib.Object{obj}}
}

func marshalNetworkAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewNetworkAddress(hostname string, port uint16) *NetworkAddress

func NewNetworkAddress(port uint16) *NetworkAddress

// NetworkService: like Address does with hostnames, Service provides an easy
// way to resolve a SRV record, and then attempt to connect to one of the hosts
// that implements that service, handling service priority/weighting, multiple
// IP addresses, and multiple address families.
//
// See Target for more information about SRV records, and see Connectable for an
// example of using the connectable interface.
type NetworkService struct {
	*externglib.Object
}

func wrapNetworkService(obj *externglib.Object) *NetworkService {
	return &NetworkService{*externglib.Object{obj}}
}

func marshalNetworkService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewNetworkService(service string, protocol string, domain string) *NetworkService

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification struct {
	*externglib.Object
}

func wrapNotification(obj *externglib.Object) *Notification {
	return &Notification{*externglib.Object{obj}}
}

func marshalNotification(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewNotification(title string) *Notification

// OutputStream: stream has functions to write to a stream
// (g_output_stream_write()), to close a stream (g_output_stream_close()) and to
// flush pending writes (g_output_stream_flush()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type OutputStream struct {
	*externglib.Object
}

func wrapOutputStream(obj *externglib.Object) *OutputStream {
	return &OutputStream{*externglib.Object{obj}}
}

func marshalOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Permission: a #GPermission represents the status of the caller's permission
// to perform a certain action.
//
// You can query if the action is currently allowed and if it is possible to
// acquire the permission so that the action will be allowed in the future.
//
// There is also an API to actually acquire the permission and one to release
// it.
//
// As an example, a #GPermission might represent the ability for the user to
// write to a #GSettings object. This #GPermission object could then be used to
// decide if it is appropriate to show a "Click here to unlock" button in a
// dialog and to provide the mechanism to invoke when that button is clicked.
type Permission struct {
	*externglib.Object
}

func wrapPermission(obj *externglib.Object) *Permission {
	return &Permission{*externglib.Object{obj}}
}

func marshalPermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// PropertyAction: a Action is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction struct {
	*externglib.Object
}

func wrapPropertyAction(obj *externglib.Object) *PropertyAction {
	return &PropertyAction{*externglib.Object{obj}}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPropertyAction(name string, object unsafe.Pointer, propertyName string) *PropertyAction

// ProxyAddress: support for proxied SocketAddress.
type ProxyAddress struct {
	InetSocketAddress
}

func wrapProxyAddress(obj *externglib.Object) *ProxyAddress {
	return &ProxyAddress{InetSocketAddress{SocketAddress{*externglib.Object{obj}}}}
}

func marshalProxyAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewProxyAddress(inetaddr *InetAddress, port uint16, protocol string, destHostname string, destPort uint16, username string, password string) *ProxyAddress

// ProxyAddressEnumerator is a wrapper around AddressEnumerator which takes the
// Address instances returned by the AddressEnumerator and wraps them in Address
// instances, using the given AddressEnumerator:proxy-resolver.
//
// This enumerator will be returned (for example, by
// g_socket_connectable_enumerate()) as appropriate when a proxy is configured;
// there should be no need to manually wrap a AddressEnumerator instance with
// one.
type ProxyAddressEnumerator struct {
	SocketAddressEnumerator
}

func wrapProxyAddressEnumerator(obj *externglib.Object) *ProxyAddressEnumerator {
	return &ProxyAddressEnumerator{SocketAddressEnumerator{*externglib.Object{obj}}}
}

func marshalProxyAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// #GResolver provides cancellable synchronous and asynchronous DNS resolution,
// for hostnames (g_resolver_lookup_by_address(), g_resolver_lookup_by_name()
// and their async variants) and SRV (service) records
// (g_resolver_lookup_service())
//
// Address and Service provide wrappers around #GResolver functionality that
// also implement Connectable, making it easy to connect to a remote
// host/service.
type Resolver struct {
	*externglib.Object
}

func wrapResolver(obj *externglib.Object) *Resolver {
	return &Resolver{*externglib.Object{obj}}
}

func marshalResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Settings: the #GSettings class provides a convenient API for storing and
// retrieving application settings.
//
// Reads and writes can be considered to be non-blocking. Reading settings with
// #GSettings is typically extremely fast: on approximately the same order of
// magnitude (but slower than) a Table lookup. Writing settings is also
// extremely fast in terms of time to return to your application, but can be
// extremely expensive for other threads and other processes. Many settings
// backends (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings a lot of
// work can be avoided. For dconf, the D-Bus service doesn't even need to be
// started in this case. For this reason, you should only ever modify #GSettings
// keys in response to explicit user action. Particular care should be paid to
// ensure that modifications are not made during startup -- for example, when
// setting the initial value of preferences widgets. The built-in
// g_settings_bind() functionality is careful not to write settings in response
// to notify signals as a result of modifications that it makes to widgets.
//
// When creating a GSettings instance, you have to specify a schema that
// describes the keys in your settings and their types and default values, as
// well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings are
// stored in the conceptual global tree of settings. However, schemas can also
// be '[relocatable][gsettings-relocatable]', i.e. not equipped with a fixed
// path. This is useful e.g. when the schema describes an 'account', and you
// want to be able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character ('/') and must
// not contain two sequential slash characters. Paths should be chosen based on
// a domain name associated with the program or library to which the settings
// belong. Examples of paths are "/org/gtk/settings/file-chooser/" and
// "/ca/desrt/dconf-editor/". Paths should not start with "/apps/", "/desktop/"
// or "/system/" as they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not restrict
// keys to basic types like strings and numbers. GSettings stores values as
// #GVariant, and allows any Type for keys. Key names are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be localized,
// but the localized values are stored in gettext catalogs and looked up with
// the domain that is specified in the `gettext-domain` attribute of the
// <schemalist> or <schema> elements and the category that is specified in the
// `l10n` attribute of the <default> element. The string which is translated
// includes all text in the <default> element, including any surrounding
// quotation marks.
//
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the <default> element  it is recommended to
// add these comments to aid translators understand the meaning and implications
// of the default value. An optional translation `context` attribute can be set
// on the <default> element to disambiguate multiple defaults which use the same
// string.
//
//
//     <!-- Translators: A list of words which are not allowed to be typed, in
//          GVariant serialization syntax.
//          See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
//     <default l10n='messages' context='Banned words'>['bad', 'words']</default>
//
// Translations of default values must remain syntactically valid serialized
// #GVariants (e.g. retaining any surrounding quotation marks) or runtime errors
// will occur.
//
// GSettings uses schemas in a compact binary form that is created by the
// [glib-compile-schemas][glib-compile-schemas] utility. The input is a schema
// description in an XML format.
//
// A DTD for the gschema XML format can be found here:
// [gschema.dtd](https://git.gnome.org/browse/glib/tree/gio/gschema.dtd)
//
// The [glib-compile-schemas][glib-compile-schemas] tool expects schema files to
// have the extension `.gschema.xml`.
//
// At runtime, schemas are identified by their id (as specified in the id
// attribute of the <schema> element). The convention for schema ids is to use a
// dotted name, similar in style to a D-Bus bus name, e.g.
// "org.gnome.SessionManager". In particular, if the settings are for a specific
// service that owns a D-Bus bus name, the D-Bus bus name and schema id should
// match. For schemas which deal with settings not associated with one named
// application, the id should not use StudlyCaps, e.g.
// "org.gnome.font-rendering".
//
// In addition to #GVariant types, keys can have types that have enumerated
// types. These can be described by a <choice>, <enum> or <flags> element, as
// seen in the [example][schema-enumerated]. The underlying type of such a key
// is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
// g_settings_get_flags(), g_settings_set_flags() access the numeric values
// corresponding to the string value of enum and flags keys.
//
// An example for default value: |[ <schemalist> <schema id="org.gtk.Test"
// path="/org/gtk/Test/" gettext-domain="test">
//
// <key name="greeting" type="s"> <default l10n="messages">"Hello,
// earthlings"</default> <summary>A greeting</summary> <description> Greeting of
// the invading martians </description> </key>
//
// <key name="box" type="(ii)"> <default>(20,30)</default> </key>
//
// <key name="empty-string" type="s"> <default>""</default> <summary>Empty
// strings have to be provided in GVariant form</summary> </key>
//
//      </schema>
//    </schemalist>
//
//
//
//    <schemalist>
//
//      <enum id="org.gtk.Test.myenum">
//        <value nick="first" value="1"/>
//        <value nick="second" value="2"/>
//      </enum>
//
//      <flags id="org.gtk.Test.myflags">
//        <value nick="flag1" value="1"/>
//        <value nick="flag2" value="2"/>
//        <value nick="flag3" value="4"/>
//      </flags>
//
//      <schema id="org.gtk.Test">
//
//        <key name="key-with-range" type="i">
//          <range min="1" max="100"/>
//          <default>10</default>
//        </key>
//
//        <key name="key-with-choices" type="s">
//          <choices>
//            <choice value='Elisabeth'/>
//            <choice value='Annabeth'/>
//            <choice value='Joe'/>
//          </choices>
//          <aliases>
//            <alias value='Anna' target='Annabeth'/>
//            <alias value='Beth' target='Elisabeth'/>
//          </aliases>
//          <default>'Joe'</default>
//        </key>
//
//        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
//          <default>'first'</default>
//        </key>
//
//        <key name='flags-key' flags='org.gtk.Test.myflags'>
//          <default>["flag1","flag2"]</default>
//        </key>
//      </schema>
//    </schemalist>
//
//
// Vendor overrides
//
//
//        [org.gtk.Example]
//        key1='string'
//        key2=1.5
//
// glib-compile-schemas expects schema files to have the extension
// `.gschema.override`.
//
//
// Binding
//
// A very convenient feature of GSettings lets you bind #GObject properties
// directly to settings, using g_settings_bind(). Once a GObject property has
// been bound to a setting, changes on either side are automatically propagated
// to the other side. GSettings handles details like mapping between GObject and
// GVariant types, and preventing infinite cycles.
//
// This makes it very easy to hook up a preferences dialog to the underlying
// settings. To make this even more convenient, GSettings looks for a boolean
// property with the name "sensitivity" and automatically binds it to the
// writability of the bound setting. If this 'magic' gets in the way, it can be
// suppressed with the SETTINGS_BIND_NO_SENSITIVITY flag.
//
// Relocatable schemas {#gsettings-relocatable}
//
// A relocatable schema is one with no `path` attribute specified on its
// <schema> element. By using g_settings_new_with_path(), a #GSettings object
// can be instantiated for a relocatable schema, assigning a path to the
// instance. Paths passed to g_settings_new_with_path() will typically be
// constructed dynamically from a constant prefix plus some form of instance
// identifier; but they must still be valid GSettings paths. Paths could also be
// constant and used with a globally installed schema originating from a
// dependency library.
//
//
//    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
//      <child name="main" schema="org.foo.MyApp.Window"/>
//    </schema>
//
// Build system integration {#gsettings-build-system}
//
//
//    GLIB_GSETTINGS
//
// In the appropriate `Makefile.am`, use the following snippet to compile and
// install the named schema: |[ gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
// EXTRA_DIST = $(gsettings_SCHEMAS)
//
//    @GSETTINGS_RULES@
//
//
//
//    data/org.foo.MyApp.gschema.xml
//
//
//    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
//
// GSettings will use gettext to look up translations for the <summary> and
// <description> elements, and also any <default> elements which have a `l10n`
// attribute set. Translations must not be included in the `.gschema.xml` file
// by the build system, for example by using intltool XML rules with a
// `.gschema.xml.in` template.
//
//
//    gsettings_ENUM_NAMESPACE = org.foo.MyApp
//    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
//
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
type Settings struct {
	*externglib.Object
}

func wrapSettings(obj *externglib.Object) *Settings {
	return &Settings{*externglib.Object{obj}}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSettings(schemaID string) *Settings

func NewSettings(schema *SettingsSchema, backend *SettingsBackend, path string) *Settings

func NewSettings(schemaID string, backend *SettingsBackend) *Settings

func NewSettings(schemaID string, backend *SettingsBackend, path string) *Settings

func NewSettings(schemaID string, path string) *Settings

// SettingsBackend: the Backend interface defines a generic interface for
// non-strictly-typed data that is stored in a hierarchy. To implement an
// alternative storage backend for #GSettings, you need to implement the Backend
// interface and then make it implement the extension point
// SETTINGS_BACKEND_EXTENSION_POINT_NAME.
//
// The interface defines methods for reading and writing values, a method for
// determining if writing of certain values will fail (lockdown) and a change
// notification mechanism.
//
// The semantics of the interface are very precisely defined and implementations
// must carefully adhere to the expectations of callers that are documented on
// each of the interface methods.
//
// Some of the Backend functions accept or return a #GTree. These trees always
// have strings as keys and #GVariant as values.
// g_settings_backend_create_tree() is a convenience function to create suitable
// trees.
//
// The Backend API is exported to allow third-party implementations, but does
// not carry the same stability guarantees as the public GIO API. For this
// reason, you have to define the C preprocessor symbol
// G_SETTINGS_ENABLE_BACKEND before including `gio/gsettingsbackend.h`.
type SettingsBackend struct {
	*externglib.Object
}

func wrapSettingsBackend(obj *externglib.Object) *SettingsBackend {
	return &SettingsBackend{*externglib.Object{obj}}
}

func marshalSettingsBackend(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SimpleAction: a Action is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of adding
// it to a ActionGroup.
//
// See also Action.
type SimpleAction struct {
	*externglib.Object
}

func wrapSimpleAction(obj *externglib.Object) *SimpleAction {
	return &SimpleAction{*externglib.Object{obj}}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSimpleAction(name string, parameterType *glib.VariantType) *SimpleAction

func NewSimpleAction(name string, parameterType *glib.VariantType, state *glib.Variant) *SimpleAction

// SimpleActionGroup is a hash table filled with #GAction objects, implementing
// the Group and Map interfaces.
type SimpleActionGroup struct {
	*externglib.Object
}

func wrapSimpleActionGroup(obj *externglib.Object) *SimpleActionGroup {
	return &SimpleActionGroup{*externglib.Object{obj}}
}

func marshalSimpleActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSimpleActionGroup() *SimpleActionGroup

// SimpleAsyncResult: as of GLib 2.46, AsyncResult is deprecated in favor of
// #GTask, which provides a simpler API.
//
// AsyncResult implements Result.
//
// GSimpleAsyncResult handles ReadyCallbacks, error reporting, operation
// cancellation and the final state of an operation, completely transparent to
// the application. Results can be returned as a pointer e.g. for functions that
// return data that is collected asynchronously, a boolean value for checking
// the success or failure of an operation, or a #gssize for operations which
// return the number of bytes modified by the operation; all of the simple
// return cases are covered.
//
// Most of the time, an application will not need to know of the details of this
// API; it is handled transparently, and any necessary operations are handled by
// Result's interface. However, if implementing a new GIO module, for writing
// language bindings, or for complex applications that need better control of
// how asynchronous operations are completed, it is important to understand this
// functionality.
//
// GSimpleAsyncResults are tagged with the calling function to ensure that
// asynchronous functions and their finishing functions are used together
// correctly.
//
// To create a new AsyncResult, call g_simple_async_result_new(). If the result
// needs to be created for a #GError, use g_simple_async_result_new_from_error()
// or g_simple_async_result_new_take_error(). If a #GError is not available
// (e.g. the asynchronous operation's doesn't take a #GError argument), but the
// result still needs to be created for an error condition, use
// g_simple_async_result_new_error() (or g_simple_async_result_set_error_va() if
// your application or binding requires passing a variable argument list
// directly), and the error can then be propagated through the use of
// g_simple_async_result_propagate_error().
//
// An asynchronous operation can be made to ignore a cancellation event by
// calling g_simple_async_result_set_handle_cancellation() with a AsyncResult
// for the operation and false. This is useful for operations that are dangerous
// to cancel, such as close (which would cause a leak if cancelled before being
// run).
//
// GSimpleAsyncResult can integrate into GLib's event loop, Loop, or it can use
// #GThreads. g_simple_async_result_complete() will finish an I/O task directly
// from the point where it is called. g_simple_async_result_complete_in_idle()
// will finish it from an idle handler in the [thread-default main
// context][g-main-context-push-thread-default] where the AsyncResult was
// created. g_simple_async_result_run_in_thread() will run the job in a separate
// thread and then use g_simple_async_result_complete_in_idle() to deliver the
// result.
//
// To set the results of an asynchronous function,
// g_simple_async_result_set_op_res_gpointer(),
// g_simple_async_result_set_op_res_gboolean(), and
// g_simple_async_result_set_op_res_gssize() are provided, setting the
// operation's result to a gpointer, gboolean, or gssize, respectively.
//
// Likewise, to get the result of an asynchronous function,
// g_simple_async_result_get_op_res_gpointer(),
// g_simple_async_result_get_op_res_gboolean(), and
// g_simple_async_result_get_op_res_gssize() are provided, getting the
// operation's result as a gpointer, gboolean, and gssize, respectively.
//
// For the details of the requirements implementations must respect, see Result.
// A typical implementation of an asynchronous operation using
// GSimpleAsyncResult looks something like this:
//
//    static void
//    baked_cb (Cake    *cake,
//              gpointer user_data)
//    {
//      // In this example, this callback is not given a reference to the cake,
//      // so the GSimpleAsyncResult has to take a reference to it.
//      GSimpleAsyncResult *result = user_data;
//
//      if (cake == NULL)
//        g_simple_async_result_set_error (result,
//                                         BAKER_ERRORS,
//                                         BAKER_ERROR_NO_FLOUR,
//                                         "Go to the supermarket");
//      else
//        g_simple_async_result_set_op_res_gpointer (result,
//                                                   g_object_ref (cake),
//                                                   g_object_unref);
//
//
//      // In this example, we assume that baked_cb is called as a callback from
//      // the mainloop, so it's safe to complete the operation synchronously here.
//      // If, however, _baker_prepare_cake () might call its callback without
//      // first returning to the mainloop  inadvisable, but some APIs do so 
//      // we would need to use g_simple_async_result_complete_in_idle().
//      g_simple_async_result_complete (result);
//      g_object_unref (result);
//    }
//
//    void
//    baker_bake_cake_async (Baker              *self,
//                           guint               radius,
//                           GAsyncReadyCallback callback,
//                           gpointer            user_data)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      if (radius < 3)
//        {
//          g_simple_async_report_error_in_idle (G_OBJECT (self),
//                                               callback,
//                                               user_data,
//                                               BAKER_ERRORS,
//                                               BAKER_ERROR_TOO_SMALL,
//                                               "ucm radius cakes are silly",
//                                               radius);
//          return;
//        }
//
//      simple = g_simple_async_result_new (G_OBJECT (self),
//                                          callback,
//                                          user_data,
//                                          baker_bake_cake_async);
//      cake = _baker_get_cached_cake (self, radius);
//
//      if (cake != NULL)
//        {
//          g_simple_async_result_set_op_res_gpointer (simple,
//                                                     g_object_ref (cake),
//                                                     g_object_unref);
//          g_simple_async_result_complete_in_idle (simple);
//          g_object_unref (simple);
//          // Drop the reference returned by _baker_get_cached_cake();
//          // the GSimpleAsyncResult has taken its own reference.
//          g_object_unref (cake);
//          return;
//        }
//
//      _baker_prepare_cake (self, radius, baked_cb, simple);
//    }
//
//    Cake *
//    baker_bake_cake_finish (Baker        *self,
//                            GAsyncResult *result,
//                            GError      **error)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      g_return_val_if_fail (g_simple_async_result_is_valid (result,
//                                                            G_OBJECT (self),
//                                                            baker_bake_cake_async),
//                            NULL);
//
//      simple = (GSimpleAsyncResult *) result;
//
//      if (g_simple_async_result_propagate_error (simple, error))
//        return NULL;
//
//      cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//      return g_object_ref (cake);
//    }
//
type SimpleAsyncResult struct {
	*externglib.Object
}

func wrapSimpleAsyncResult(obj *externglib.Object) *SimpleAsyncResult {
	return &SimpleAsyncResult{*externglib.Object{obj}}
}

func marshalSimpleAsyncResult(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSimpleAsyncResult(sourceObject *externglib.Object, callback AsyncReadyCallback, userData unsafe.Pointer, sourceTag unsafe.Pointer) *SimpleAsyncResult

func NewSimpleAsyncResult(sourceObject *externglib.Object, callback AsyncReadyCallback, userData unsafe.Pointer, error *glib.Error) *SimpleAsyncResult

func NewSimpleAsyncResult(sourceObject *externglib.Object, callback AsyncReadyCallback, userData unsafe.Pointer, error *glib.Error) *SimpleAsyncResult

// SimpleIOStream: GSimpleIOStream creates a OStream from an arbitrary Stream
// and Stream. This allows any pair of input and output streams to be used with
// OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream struct {
	IOStream
}

func wrapSimpleIOStream(obj *externglib.Object) *SimpleIOStream {
	return &SimpleIOStream{IOStream{*externglib.Object{obj}}}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSimpleIOStream(inputStream *InputStream, outputStream *OutputStream) *SimpleIOStream

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission struct {
	Permission
}

func wrapSimplePermission(obj *externglib.Object) *SimplePermission {
	return &SimplePermission{Permission{*externglib.Object{obj}}}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSimplePermission(allowed bool) *SimplePermission

// SimpleProxyResolver is a simple Resolver implementation that handles a single
// default proxy, multiple URI-scheme-specific proxies, and a list of hosts that
// proxies should not be used for.
//
// ProxyResolver is never the default proxy resolver, but it can be used as the
// base class for another proxy resolver implementation, or it can be created
// and used manually, such as with g_socket_client_set_proxy_resolver().
type SimpleProxyResolver struct {
	*externglib.Object
}

func wrapSimpleProxyResolver(obj *externglib.Object) *SimpleProxyResolver {
	return &SimpleProxyResolver{*externglib.Object{obj}}
}

func marshalSimpleProxyResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Socket: a #GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API. It
// supports both the UNIX socket implementations and winsock2 on Windows.
//
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful
//
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return nil
//
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which dont take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
type Socket struct {
	*externglib.Object
}

func wrapSocket(obj *externglib.Object) *Socket {
	return &Socket{*externglib.Object{obj}}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSocket(family SocketFamily, _type SocketType, protocol SocketProtocol) *Socket

func NewSocket(fd int) *Socket

// SocketAddress is the equivalent of struct sockaddr in the BSD sockets API.
// This is an abstract class; use SocketAddress for internet sockets, or
// SocketAddress for UNIX domain sockets.
type SocketAddress struct {
	*externglib.Object
}

func wrapSocketAddress(obj *externglib.Object) *SocketAddress {
	return &SocketAddress{*externglib.Object{obj}}
}

func marshalSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSocketAddress(native unsafe.Pointer, len uint) *SocketAddress

// SocketAddressEnumerator is an enumerator type for Address instances. It is
// returned by enumeration functions such as g_socket_connectable_enumerate(),
// which returns a AddressEnumerator to list each Address which could be used to
// connect to that Connectable.
//
// Enumeration is typically a blocking operation, so the asynchronous methods
// g_socket_address_enumerator_next_async() and
// g_socket_address_enumerator_next_finish() should be used where possible.
//
// Each AddressEnumerator can only be enumerated once. Once
// g_socket_address_enumerator_next() has returned nil, further enumeration with
// that AddressEnumerator is not possible, and it can be unreffed.
type SocketAddressEnumerator struct {
	*externglib.Object
}

func wrapSocketAddressEnumerator(obj *externglib.Object) *SocketAddressEnumerator {
	return &SocketAddressEnumerator{*externglib.Object{obj}}
}

func marshalSocketAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketClient is a lightweight high-level utility class for connecting to a
// network host using a connection oriented socket type.
//
// You create a Client object, set any options you want, and then call a sync or
// async connect operation, which returns a Connection subclass on success.
//
// The type of the Connection object returned depends on the type of the
// underlying socket that is in use. For instance, for a TCP/IP connection it
// will be a Connection.
//
// As Client is a lightweight object, you don't need to cache it. You can just
// create a new one any time you need one.
type SocketClient struct {
	*externglib.Object
}

func wrapSocketClient(obj *externglib.Object) *SocketClient {
	return &SocketClient{*externglib.Object{obj}}
}

func marshalSocketClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSocketClient() *SocketClient

// SocketConnection is a OStream for a connected socket. They can be created
// either by Client when connecting to a host, or by Listener when accepting a
// new client.
//
// The type of the Connection object returned from these calls depends on the
// type of the underlying socket that is in use. For instance, for a TCP/IP
// connection it will be a Connection.
//
// Choosing what type of object to construct is done with the socket connection
// factory, and it is possible for 3rd parties to register custom socket
// connection types for specific combination of socket family/type/protocol
// using g_socket_connection_factory_register_type().
//
// To close a Connection, use g_io_stream_close(). Closing both substreams of
// the OStream separately will not close the underlying #GSocket.
type SocketConnection struct {
	IOStream
}

func wrapSocketConnection(obj *externglib.Object) *SocketConnection {
	return &SocketConnection{IOStream{*externglib.Object{obj}}}
}

func marshalSocketConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketControlMessage: a ControlMessage is a special-purpose utility message
// that can be sent to or received from a #GSocket. These types of messages are
// often called "ancillary data".
//
// The message can represent some sort of special instruction to or information
// from the socket or can represent a special kind of transfer to the peer (for
// example, sending a file descriptor over a UNIX socket).
//
// These messages are sent with g_socket_send_message() and received with
// g_socket_receive_message().
//
// To extend the set of control message that can be sent, subclass this class
// and override the get_size, get_level, get_type and serialize methods.
//
// To extend the set of control messages that can be received, subclass this
// class and implement the deserialize method. Also, make sure your class is
// registered with the GType typesystem before calling
// g_socket_receive_message() to read such a message.
type SocketControlMessage struct {
	*externglib.Object
}

func wrapSocketControlMessage(obj *externglib.Object) *SocketControlMessage {
	return &SocketControlMessage{*externglib.Object{obj}}
}

func marshalSocketControlMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketListener: a Listener is an object that keeps track of a set of server
// sockets and helps you accept sockets from any of the socket, either sync or
// async.
//
// Add addresses and ports to listen on using g_socket_listener_add_address()
// and g_socket_listener_add_inet_port(). These will be listened on until
// g_socket_listener_close() is called. Dropping your final reference to the
// Listener will not cause g_socket_listener_close() to be called implicitly, as
// some references to the Listener may be held internally.
//
// If you want to implement a network server, also look at Service and
// SocketService which are subclasses of Listener that make this even easier.
type SocketListener struct {
	*externglib.Object
}

func wrapSocketListener(obj *externglib.Object) *SocketListener {
	return &SocketListener{*externglib.Object{obj}}
}

func marshalSocketListener(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSocketListener() *SocketListener

// SocketService: a Service is an object that represents a service that is
// provided to the network or over local sockets. When a new connection is made
// to the service the Service::incoming signal is emitted.
//
// A Service is a subclass of Listener and you need to add the addresses you
// want to accept connections on with the Listener APIs.
//
// There are two options for implementing a network service based on Service.
// The first is to create the service using g_socket_service_new() and to
// connect to the Service::incoming signal. The second is to subclass Service
// and override the default signal handler implementation.
//
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested in
// writing connection handlers that contain blocking code then see
// SocketService.
//
// The socket service runs on the main loop of the [thread-default
// context][g-main-context-push-thread-default-context] of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
type SocketService struct {
	SocketListener
}

func wrapSocketService(obj *externglib.Object) *SocketService {
	return &SocketService{SocketListener{*externglib.Object{obj}}}
}

func marshalSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSocketService() *SocketService

// #GSubprocess allows the creation of and interaction with child processes
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified)
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc)
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess struct {
	*externglib.Object
}

func wrapSubprocess(obj *externglib.Object) *Subprocess {
	return &Subprocess{*externglib.Object{obj}}
}

func marshalSubprocess(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSubprocess(argv []string, flags SubprocessFlags) *Subprocess

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher struct {
	*externglib.Object
}

func wrapSubprocessLauncher(obj *externglib.Object) *SubprocessLauncher {
	return &SubprocessLauncher{*externglib.Object{obj}}
}

func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSubprocessLauncher(flags SubprocessFlags) *SubprocessLauncher

// Task: a #GTask represents and manages a cancellable "task".
//
//
// Asynchronous operations
//
// The most common usage of #GTask is as a Result, to manage data during an
// asynchronous operation. You call g_task_new() in the "start" method, followed
// by g_task_set_task_data() and the like if you need to keep some additional
// data associated with the task, and then pass the task object around through
// your asynchronous operation. Eventually, you will call a method such as
// g_task_return_pointer() or g_task_return_error(), which will save the value
// you give it and then invoke the task's callback function in the
// [thread-default main context][g-main-context-push-thread-default] where it
// was created (waiting until the next iteration of the main loop first, if
// necessary). The caller will pass the #GTask back to the operation's finish
// function (as a Result), and you can use g_task_propagate_pointer() or the
// like to extract the return value.
//
// Here is an example for using GTask as a GAsyncResult: |[<!-- language="C" -->
// typedef struct { CakeFrostingType frosting; char *message; } DecorationData;
//
// static void decoration_data_free (DecorationData *decoration) { g_free
// (decoration->message); g_slice_free (DecorationData, decoration); }
//
// static void baked_cb (Cake *cake, gpointer user_data) { GTask *task =
// user_data; DecorationData *decoration = g_task_get_task_data (task); GError
// *error = NULL;
//
// if (cake == NULL) { g_task_return_new_error (task, BAKER_ERROR,
// BAKER_ERROR_NO_FLOUR, "Go to the supermarket"); g_object_unref (task);
// return; }
//
// if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
// { g_object_unref (cake); // g_task_return_error() takes ownership of error
// g_task_return_error (task, error); g_object_unref (task); return; }
//
// g_task_return_pointer (task, cake, g_object_unref); g_object_unref (task); }
//
// void baker_bake_cake_async (Baker *self, guint radius, CakeFlavor flavor,
// CakeFrostingType frosting, const char *message, GCancellable *cancellable,
// GAsyncReadyCallback callback, gpointer user_data) { GTask *task;
// DecorationData *decoration; Cake *cake;
//
// task = g_task_new (self, cancellable, callback, user_data); if (radius < 3) {
// g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL, "ucm
// radius cakes are silly", radius); g_object_unref (task); return; }
//
// cake = _baker_get_cached_cake (self, radius, flavor, frosting, message); if
// (cake != NULL) { // _baker_get_cached_cake() returns a reffed cake
// g_task_return_pointer (task, cake, g_object_unref); g_object_unref (task);
// return; }
//
// decoration = g_slice_new (DecorationData); decoration->frosting = frosting;
// decoration->message = g_strdup (message); g_task_set_task_data (task,
// decoration, (GDestroyNotify) decoration_data_free);
//
// _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task); }
//
// Cake * baker_bake_cake_finish (Baker *self, GAsyncResult *result, GError
// **error) { g_return_val_if_fail (g_task_is_valid (result, self), NULL);
//
//          return g_task_propagate_pointer (G_TASK (result), error);
//        }
//
//
//    ## Chained asynchronous operations
//
//    #GTask also tries to simplify asynchronous operations that
//    internally chain together several smaller asynchronous
//    operations. g_task_get_cancellable(), g_task_get_context(),
//    and g_task_get_priority() allow you to get back the task's
//    #GCancellable, Context, and [I/O priority][io-priority]
//    when starting a new subtask, so you don't have to keep track
//    of them yourself. g_task_attach_source() simplifies the case
//    of waiting for a source to fire (automatically using the correct
//    Context and priority).
//
//        typedef struct {
//          Cake *cake;
//          CakeFrostingType frosting;
//          char *message;
//        } BakingData;
//
//        static void
//        decoration_data_free (BakingData *bd)
//        {
//          if (bd->cake)
//            g_object_unref (bd->cake);
//          g_free (bd->message);
//          g_slice_free (BakingData, bd);
//        }
//
//        static void
//        decorated_cb (Cake         *cake,
//                      GAsyncResult *result,
//                      gpointer      user_data)
//        {
//          GTask *task = user_data;
//          GError *error = NULL;
//
//          if (!cake_decorate_finish (cake, result, &error))
//            {
//              g_object_unref (cake);
//              g_task_return_error (task, error);
//              g_object_unref (task);
//              return;
//            }
//
//          // baking_data_free() will drop its ref on the cake, so we have to
//          // take another here to give to the caller.
//          g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
//          g_object_unref (task);
//        }
//
//        static gboolean
//        decorator_ready (gpointer user_data)
//        {
//          GTask *task = user_data;
//          BakingData *bd = g_task_get_task_data (task);
//
//          cake_decorate_async (bd->cake, bd->frosting, bd->message,
//                               g_task_get_cancellable (task),
//                               decorated_cb, task);
//
//          return G_SOURCE_REMOVE;
//        }
//
//        static void
//        baked_cb (Cake     *cake,
//                  gpointer  user_data)
//        {
//          GTask *task = user_data;
//          BakingData *bd = g_task_get_task_data (task);
//          GError *error = NULL;
//
//          if (cake == NULL)
//            {
//              g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
//                                       "Go to the supermarket");
//              g_object_unref (task);
//              return;
//            }
//
//          bd->cake = cake;
//
//          // Bail out now if the user has already cancelled
//          if (g_task_return_error_if_cancelled (task))
//            {
//              g_object_unref (task);
//              return;
//            }
//
//          if (cake_decorator_available (cake))
//            decorator_ready (task);
//          else
//            {
//              GSource *source;
//
//              source = cake_decorator_wait_source_new (cake);
//              // Attach @source to @task's GMainContext and have it call
//              // decorator_ready() when it is ready.
//              g_task_attach_source (task, source, decorator_ready);
//              g_source_unref (source);
//            }
//        }
//
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               gint                 priority,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          GTask *task;
//          BakingData *bd;
//
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_priority (task, priority);
//
//          bd = g_slice_new0 (BakingData);
//          bd->frosting = frosting;
//          bd->message = g_strdup (message);
//          g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);
//
//          _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
//        }
//
//        Cake *
//        baker_bake_cake_finish (Baker         *self,
//                                GAsyncResult  *result,
//                                GError       **error)
//        {
//          g_return_val_if_fail (g_task_is_valid (result, self), NULL);
//
//          return g_task_propagate_pointer (G_TASK (result), error);
//        }
//
//
//
// Asynchronous operations from synchronous ones
//
// You can use g_task_run_in_thread() to turn a synchronous operation into an
// asynchronous one, by running it in a thread. When it completes, the result
// will be dispatched to the [thread-default main
// context][g-main-context-push-thread-default] where the #GTask was created.
//
// Running a task in a thread: |[<!-- language="C" --> typedef struct { guint
// radius; CakeFlavor flavor; CakeFrostingType frosting; char *message; }
// CakeData;
//
// static void cake_data_free (CakeData *cake_data) { g_free
// (cake_data->message); g_slice_free (CakeData, cake_data); }
//
// static void bake_cake_thread (GTask *task, gpointer source_object, gpointer
// task_data, GCancellable *cancellable) { Baker *self = source_object; CakeData
// *cake_data = task_data; Cake *cake; GError *error = NULL;
//
// cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
// cake_data->frosting, cake_data->message, cancellable, &error); if (cake)
// g_task_return_pointer (task, cake, g_object_unref); else g_task_return_error
// (task, error); }
//
// void baker_bake_cake_async (Baker *self, guint radius, CakeFlavor flavor,
// CakeFrostingType frosting, const char *message, GCancellable *cancellable,
// GAsyncReadyCallback callback, gpointer user_data) { CakeData *cake_data;
// GTask *task;
//
// cake_data = g_slice_new (CakeData); cake_data->radius = radius;
// cake_data->flavor = flavor; cake_data->frosting = frosting;
// cake_data->message = g_strdup (message); task = g_task_new (self,
// cancellable, callback, user_data); g_task_set_task_data (task, cake_data,
// (GDestroyNotify) cake_data_free); g_task_run_in_thread (task,
// bake_cake_thread); g_object_unref (task); }
//
// Cake * baker_bake_cake_finish (Baker *self, GAsyncResult *result, GError
// **error) { g_return_val_if_fail (g_task_is_valid (result, self), NULL);
//
//          return g_task_propagate_pointer (G_TASK (result), error);
//        }
//
//
//    ## Adding cancellability to uncancellable tasks
//
//    Finally, g_task_run_in_thread() and g_task_run_in_thread_sync()
//    can be used to turn an uncancellable operation into a
//    cancellable one. If you call g_task_set_return_on_cancel(),
//    passing true, then if the task's #GCancellable is cancelled,
//    it will return control back to the caller immediately, while
//    allowing the task thread to continue running in the background
//    (and simply discarding its result when it finally does finish).
//    Provided that the task thread is careful about how it uses
//    locks and other externally-visible resources, this allows you
//    to make "GLib-friendly" asynchronous and cancellable
//    synchronous variants of blocking APIs.
//
//        static void
//        bake_cake_thread (GTask         *task,
//                          gpointer       source_object,
//                          gpointer       task_data,
//                          GCancellable  *cancellable)
//        {
//          Baker *self = source_object;
//          CakeData *cake_data = task_data;
//          Cake *cake;
//          GError *error = NULL;
//
//          cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//                            cake_data->frosting, cake_data->message,
//                            &error);
//          if (error)
//            {
//              g_task_return_error (task, error);
//              return;
//            }
//
//          // If the task has already been cancelled, then we don't want to add
//          // the cake to the cake cache. Likewise, we don't  want to have the
//          // task get cancelled in the middle of updating the cache.
//          // g_task_set_return_on_cancel() will return true here if it managed
//          // to disable return-on-cancel, or false if the task was cancelled
//          // before it could.
//          if (g_task_set_return_on_cancel (task, FALSE))
//            {
//              // If the caller cancels at this point, their
//              // GAsyncReadyCallback won't be invoked until we return,
//              // so we don't have to worry that this code will run at
//              // the same time as that code does. But if there were
//              // other functions that might look at the cake cache,
//              // then we'd probably need a GMutex here as well.
//              baker_add_cake_to_cache (baker, cake);
//              g_task_return_pointer (task, cake, g_object_unref);
//            }
//        }
//
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          CakeData *cake_data;
//          GTask *task;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread (task, bake_cake_thread);
//        }
//
//        Cake *
//        baker_bake_cake_sync (Baker               *self,
//                              guint                radius,
//                              CakeFlavor           flavor,
//                              CakeFrostingType     frosting,
//                              const char          *message,
//                              GCancellable        *cancellable,
//                              GError             **error)
//        {
//          CakeData *cake_data;
//          GTask *task;
//          Cake *cake;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, NULL, NULL);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread_sync (task, bake_cake_thread);
//
//          cake = g_task_propagate_pointer (task, error);
//          g_object_unref (task);
//          return cake;
//        }
//
//
//
// Porting from GSimpleAsyncResult
//
// #GTask's API attempts to be simpler than AsyncResult's in several ways: - You
// can save task-specific data with g_task_set_task_data(), and
//
//    retrieve it later with g_task_get_task_data(). This replaces the
//    abuse of g_simple_async_result_set_op_res_gpointer() for the same
//    purpose with AsyncResult.
//
// - In addition to the task data, #GTask also keeps track of the
//
//    [priority][io-priority], #GCancellable, and
//    Context associated with the task, so tasks that consist of
//    a chain of simpler asynchronous operations will have easy access
//    to those values when starting each sub-task.
//
// - g_task_return_error_if_cancelled() provides simplified
//
//    handling for cancellation. In addition, cancellation
//    overrides any other #GTask return value by default, like
//    AsyncResult does when
//    g_simple_async_result_set_check_cancellable() is called.
//    (You can use g_task_set_check_cancellable() to turn off that
//    behavior.) On the other hand, g_task_run_in_thread()
//    guarantees that it will always run your
//    `task_func`, even if the task's #GCancellable
//    is already cancelled before the task gets a chance to run;
//    you can start your `task_func` with a
//    g_task_return_error_if_cancelled() check if you need the
//    old behavior.
//
// - The "return" methods (eg, g_task_return_pointer())
//
//    automatically cause the task to be "completed" as well, and
//    there is no need to worry about the "complete" vs "complete
//    in idle" distinction. (#GTask automatically figures out
//    whether the task's callback can be invoked directly, or
//    if it needs to be sent to another Context, or delayed
//    until the next iteration of the current Context.)
//
// - The "finish" functions for #GTask based operations are generally
//
//    much simpler than AsyncResult ones, normally consisting
//    of only a single call to g_task_propagate_pointer() or the like.
//    Since g_task_propagate_pointer() "steals" the return value from
//    the #GTask, it is not necessary to juggle pointers around to
//    prevent it from being freed twice.
//
// - With AsyncResult, it was common to call
//
//    g_simple_async_result_propagate_error() from the
//    `_finish()` wrapper function, and have
//    virtual method implementations only deal with successful
//    returns. This behavior is deprecated, because it makes it
//    difficult for a subclass to chain to a parent class's async
//    methods. Instead, the wrapper function should just be a
//    simple wrapper, and the virtual method should call an
//    appropriate `g_task_propagate_` function.
//    Note that wrapper methods can now use
//    g_async_result_legacy_propagate_error() to do old-style
//    AsyncResult error-returning behavior, and
//    g_async_result_is_tagged() to check if a result is tagged as
//    having come from the `_async()` wrapper
//    function (for "short-circuit" results, such as when passing
//    0 to g_input_stream_read_async())
type Task struct {
	*externglib.Object
}

func wrapTask(obj *externglib.Object) *Task {
	return &Task{*externglib.Object{obj}}
}

func marshalTask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTask(sourceObject unsafe.Pointer, cancellable *Cancellable, callback AsyncReadyCallback, callbackData unsafe.Pointer) *Task

// TcpConnection: this is the subclass of Connection that is created for TCP/IP
// sockets.
type TcpConnection struct {
	SocketConnection
}

func wrapTcpConnection(obj *externglib.Object) *TcpConnection {
	return &TcpConnection{SocketConnection{IOStream{*externglib.Object{obj}}}}
}

func marshalTcpConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TcpWrapperConnection: a WrapperConnection can be used to wrap a OStream that
// is based on a #GSocket, but which is not actually a Connection. This is used
// by Client so that it can always return a Connection, even when the connection
// it has actually created is not directly a Connection.
type TcpWrapperConnection struct {
	TcpConnection
}

func wrapTcpWrapperConnection(obj *externglib.Object) *TcpWrapperConnection {
	return &TcpWrapperConnection{TcpConnection{SocketConnection{IOStream{*externglib.Object{obj}}}}}
}

func marshalTcpWrapperConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTcpWrapperConnection(baseIOStream *IOStream, socket *Socket) *TcpWrapperConnection

// TestDBus: a helper class for testing code which uses D-Bus without touching
// the user's session bus.
//
// Note that DBus modifies the users environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure. |[ [D-BUS Service]
// Name=org.gtk.GDBus.Examples.ObjectManager
// Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server ]| You
// will also need to indicate this service directory in your test fixtures, so
// you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as: |[
// -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\" ]| Once you have a
// service definition file which is local to your source tree, you can proceed
// to set up a GTest fixture using the DBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found here:
// [gdbus-test-fixture.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your
// schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas: |[ all-am: $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
//
type TestDBus struct {
	*externglib.Object
}

func wrapTestDBus(obj *externglib.Object) *TestDBus {
	return &TestDBus{*externglib.Object{obj}}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTestDBus(flags TestDBusFlags) *TestDBus

// ThemedIcon is an implementation of #GIcon that supports icon themes. Icon
// contains a list of all of the icons present in an icon theme, so that icons
// can be looked up quickly. Icon does not provide actual pixmaps for icons,
// just the icon names. Ideally something like gtk_icon_theme_choose_icon()
// should be used to resolve the list of names so that fallback icons work
// nicely with themes that inherit other themes.
type ThemedIcon struct {
	*externglib.Object
}

func wrapThemedIcon(obj *externglib.Object) *ThemedIcon {
	return &ThemedIcon{*externglib.Object{obj}}
}

func marshalThemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewThemedIcon(iconname string) *ThemedIcon

func NewThemedIcon(iconnames []string, len int) *ThemedIcon

func NewThemedIcon(iconname string) *ThemedIcon

// ThreadedSocketService: a SocketService is a simple subclass of Service that
// handles incoming connections by creating a worker thread and dispatching the
// connection to it by emitting the SocketService::run signal in the new thread.
//
// The signal handler may perform blocking IO and need not return until the
// connection is closed.
//
// The service is implemented using a thread pool, so there is a limited amount
// of threads available to serve incoming requests. The service automatically
// stops the Service from accepting new connections when all threads are busy.
//
// As with Service, you may connect to SocketService::run, or subclass and
// override the default handler.
type ThreadedSocketService struct {
	SocketService
}

func wrapThreadedSocketService(obj *externglib.Object) *ThreadedSocketService {
	return &ThreadedSocketService{SocketService{SocketListener{*externglib.Object{obj}}}}
}

func marshalThreadedSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewThreadedSocketService(maxThreads int) *ThreadedSocketService

// TlsCertificate: a certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate received by
// a client from a server), or the combination of a certificate and a private
// key (which is needed when acting as a ServerConnection).
type TlsCertificate struct {
	*externglib.Object
}

func wrapTlsCertificate(obj *externglib.Object) *TlsCertificate {
	return &TlsCertificate{*externglib.Object{obj}}
}

func marshalTlsCertificate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTlsCertificate(file string) *TlsCertificate

func NewTlsCertificate(certFile string, keyFile string) *TlsCertificate

func NewTlsCertificate(data string, length int) *TlsCertificate

// TlsConnection is the base TLS connection class type, which wraps a OStream
// and provides TLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side TLS,
// respectively.
//
// For DTLS (Datagram TLS) support, see Connection.
type TlsConnection struct {
	IOStream
}

func wrapTlsConnection(obj *externglib.Object) *TlsConnection {
	return &TlsConnection{IOStream{*externglib.Object{obj}}}
}

func marshalTlsConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TlsDatabase is used to look up certificates and other information from a
// certificate or key store. It is an abstract base class which TLS library
// specific subtypes override.
//
// A Database may be accessed from multiple threads by the TLS backend. All
// implementations are required to be fully thread-safe.
//
// Most common client applications will not directly interact with Database. It
// is used internally by Connection.
type TlsDatabase struct {
	*externglib.Object
}

func wrapTlsDatabase(obj *externglib.Object) *TlsDatabase {
	return &TlsDatabase{*externglib.Object{obj}}
}

func marshalTlsDatabase(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TlsInteraction: interaction provides a mechanism for the TLS connection and
// database code to interact with the user. It can be used to ask the user for
// passwords.
//
// To use a Interaction with a TLS connection use
// g_tls_connection_set_interaction().
//
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
//
// Callers should use the 'invoke' functions like
// g_tls_interaction_invoke_ask_password() to run interaction methods. These
// functions make sure that the interaction is invoked in the main loop and not
// in the current thread, if the current thread is not running the main loop.
//
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
// it must also implement the corresponding finish method.
type TlsInteraction struct {
	*externglib.Object
}

func wrapTlsInteraction(obj *externglib.Object) *TlsInteraction {
	return &TlsInteraction{*externglib.Object{obj}}
}

func marshalTlsInteraction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TlsPassword: holds a password used in TLS.
type TlsPassword struct {
	*externglib.Object
}

func wrapTlsPassword(obj *externglib.Object) *TlsPassword {
	return &TlsPassword{*externglib.Object{obj}}
}

func marshalTlsPassword(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTlsPassword(flags TlsPasswordFlags, description string) *TlsPassword

// UnixConnection: this is the subclass of Connection that is created for UNIX
// domain sockets.
//
// It contains functions to do some of the UNIX socket specific functionality
// like passing file descriptors.
//
// Note that `<gio/gunixconnection.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixConnection struct {
	SocketConnection
}

func wrapUnixConnection(obj *externglib.Object) *UnixConnection {
	return &UnixConnection{SocketConnection{IOStream{*externglib.Object{obj}}}}
}

func marshalUnixConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// UnixCredentialsMessage: this ControlMessage contains a #GCredentials
// instance. It may be sent using g_socket_send_message() and received using
// g_socket_receive_message() over UNIX sockets (ie: sockets in the
// G_SOCKET_FAMILY_UNIX family).
//
// For an easier way to send and receive credentials over stream-oriented UNIX
// sockets, see g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials(). To receive credentials of a foreign
// process connected to a socket, use g_socket_get_credentials().
type UnixCredentialsMessage struct {
	SocketControlMessage
}

func wrapUnixCredentialsMessage(obj *externglib.Object) *UnixCredentialsMessage {
	return &UnixCredentialsMessage{SocketControlMessage{*externglib.Object{obj}}}
}

func marshalUnixCredentialsMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewUnixCredentialsMessage() *UnixCredentialsMessage

func NewUnixCredentialsMessage(credentials *Credentials) *UnixCredentialsMessage

// UnixFDList: a FDList contains a list of file descriptors. It owns the file
// descriptors that it contains, closing them when finalized.
//
// It may be wrapped in a FDMessage and sent over a #GSocket in the
// G_SOCKET_FAMILY_UNIX family by using g_socket_send_message() and received
// using g_socket_receive_message().
//
// Note that `<gio/gunixfdlist.h>` belongs to the UNIX-specific GIO interfaces,
// thus you have to use the `gio-unix-2.0.pc` pkg-config file when using it.
type UnixFDList struct {
	*externglib.Object
}

func wrapUnixFDList(obj *externglib.Object) *UnixFDList {
	return &UnixFDList{*externglib.Object{obj}}
}

func marshalUnixFDList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewUnixFDList() *UnixFDList

func NewUnixFDList(fds []int, nFds int) *UnixFDList

// UnixFDMessage: this ControlMessage contains a FDList. It may be sent using
// g_socket_send_message() and received using g_socket_receive_message() over
// UNIX sockets (ie: sockets in the G_SOCKET_FAMILY_UNIX family). The file
// descriptors are copied between processes by the kernel.
//
// For an easier way to send and receive file descriptors over stream-oriented
// UNIX sockets, see g_unix_connection_send_fd() and
// g_unix_connection_receive_fd().
//
// Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixFDMessage struct {
	SocketControlMessage
}

func wrapUnixFDMessage(obj *externglib.Object) *UnixFDMessage {
	return &UnixFDMessage{SocketControlMessage{*externglib.Object{obj}}}
}

func marshalUnixFDMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewUnixFDMessage() *UnixFDMessage

func NewUnixFDMessage(fdList *UnixFDList) *UnixFDMessage

// UnixInputStream: inputStream implements Stream for reading from a UNIX file
// descriptor, including asynchronous operations. (If the file descriptor refers
// to a socket or pipe, this will use poll() to do asynchronous I/O. If it
// refers to a regular file, it will fall back to doing asynchronous I/O in
// another thread.)
//
// Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixInputStream struct {
	InputStream
}

func wrapUnixInputStream(obj *externglib.Object) *UnixInputStream {
	return &UnixInputStream{InputStream{*externglib.Object{obj}}}
}

func marshalUnixInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewUnixInputStream(fd int, closeFd bool) *UnixInputStream

// UnixMountMonitor: watches Mounts for changes.
type UnixMountMonitor struct {
	*externglib.Object
}

func wrapUnixMountMonitor(obj *externglib.Object) *UnixMountMonitor {
	return &UnixMountMonitor{*externglib.Object{obj}}
}

func marshalUnixMountMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewUnixMountMonitor() *UnixMountMonitor

// UnixOutputStream: outputStream implements Stream for writing to a UNIX file
// descriptor, including asynchronous operations. (If the file descriptor refers
// to a socket or pipe, this will use poll() to do asynchronous I/O. If it
// refers to a regular file, it will fall back to doing asynchronous I/O in
// another thread.)
//
// Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixOutputStream struct {
	OutputStream
}

func wrapUnixOutputStream(obj *externglib.Object) *UnixOutputStream {
	return &UnixOutputStream{OutputStream{*externglib.Object{obj}}}
}

func marshalUnixOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewUnixOutputStream(fd int, closeFd bool) *UnixOutputStream

// UnixSocketAddress: support for UNIX-domain (also known as local) sockets.
//
// UNIX domain sockets are generally visible in the filesystem. However, some
// systems support abstract socket names which are not visible in the filesystem
// and not affected by the filesystem permissions, visibility, etc. Currently
// this is only supported under Linux. If you attempt to use abstract sockets on
// other systems, function calls may return G_IO_ERROR_NOT_SUPPORTED errors. You
// can use g_unix_socket_address_abstract_names_supported() to see if abstract
// names are supported.
//
// Note that `<gio/gunixsocketaddress.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixSocketAddress struct {
	SocketAddress
}

func wrapUnixSocketAddress(obj *externglib.Object) *UnixSocketAddress {
	return &UnixSocketAddress{SocketAddress{*externglib.Object{obj}}}
}

func marshalUnixSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewUnixSocketAddress(path string) *UnixSocketAddress

func NewUnixSocketAddress(path []byte, pathLen int) *UnixSocketAddress

func NewUnixSocketAddress(path []byte, pathLen int, _type UnixSocketAddressType) *UnixSocketAddress

// Vfs: entry point for using GIO functionality.
type Vfs struct {
	*externglib.Object
}

func wrapVfs(obj *externglib.Object) *Vfs {
	return &Vfs{*externglib.Object{obj}}
}

func marshalVfs(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// VolumeMonitor is for listing the user interesting devices and volumes on the
// computer. In other words, what a file selector or file manager would show in
// a sidebar.
//
// Monitor is not [thread-default-context
// aware][g-main-context-push-thread-default], and so should not be used other
// than from the main thread, with no thread-default-context active.
//
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor struct {
	*externglib.Object
}

func wrapVolumeMonitor(obj *externglib.Object) *VolumeMonitor {
	return &VolumeMonitor{*externglib.Object{obj}}
}

func marshalVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ZlibCompressor: zlib decompression
type ZlibCompressor struct {
	*externglib.Object
}

func wrapZlibCompressor(obj *externglib.Object) *ZlibCompressor {
	return &ZlibCompressor{*externglib.Object{obj}}
}

func marshalZlibCompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewZlibCompressor(format ZlibCompressorFormat, level int) *ZlibCompressor

// ZlibDecompressor: zlib decompression
type ZlibDecompressor struct {
	*externglib.Object
}

func wrapZlibDecompressor(obj *externglib.Object) *ZlibDecompressor {
	return &ZlibDecompressor{*externglib.Object{obj}}
}

func marshalZlibDecompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewZlibDecompressor(format ZlibCompressorFormat) *ZlibDecompressor
