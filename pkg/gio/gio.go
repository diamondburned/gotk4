// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/glib"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.g_bus_type_get_type()), F: marshalBusType},
		{T: externglib.Type(C.g_converter_result_get_type()), F: marshalConverterResult},
		{T: externglib.Type(C.g_credentials_type_get_type()), F: marshalCredentialsType},
		{T: externglib.Type(C.g_dbus_error_get_type()), F: marshalDBusError},
		{T: externglib.Type(C.g_dbus_message_byte_order_get_type()), F: marshalDBusMessageByteOrder},
		{T: externglib.Type(C.g_dbus_message_header_field_get_type()), F: marshalDBusMessageHeaderField},
		{T: externglib.Type(C.g_dbus_message_type_get_type()), F: marshalDBusMessageType},
		{T: externglib.Type(C.g_data_stream_byte_order_get_type()), F: marshalDataStreamByteOrder},
		{T: externglib.Type(C.g_data_stream_newline_type_get_type()), F: marshalDataStreamNewlineType},
		{T: externglib.Type(C.g_drive_start_stop_type_get_type()), F: marshalDriveStartStopType},
		{T: externglib.Type(C.g_emblem_origin_get_type()), F: marshalEmblemOrigin},
		{T: externglib.Type(C.g_file_attribute_status_get_type()), F: marshalFileAttributeStatus},
		{T: externglib.Type(C.g_file_attribute_type_get_type()), F: marshalFileAttributeType},
		{T: externglib.Type(C.g_file_monitor_event_get_type()), F: marshalFileMonitorEvent},
		{T: externglib.Type(C.g_file_type_get_type()), F: marshalFileType},
		{T: externglib.Type(C.g_filesystem_preview_type_get_type()), F: marshalFilesystemPreviewType},
		{T: externglib.Type(C.g_io_error_enum_get_type()), F: marshalIOErrorEnum},
		{T: externglib.Type(C.g_io_module_scope_flags_get_type()), F: marshalIOModuleScopeFlags},
		{T: externglib.Type(C.g_memory_monitor_warning_level_get_type()), F: marshalMemoryMonitorWarningLevel},
		{T: externglib.Type(C.g_mount_operation_result_get_type()), F: marshalMountOperationResult},
		{T: externglib.Type(C.g_network_connectivity_get_type()), F: marshalNetworkConnectivity},
		{T: externglib.Type(C.g_notification_priority_get_type()), F: marshalNotificationPriority},
		{T: externglib.Type(C.g_password_save_get_type()), F: marshalPasswordSave},
		{T: externglib.Type(C.g_pollable_return_get_type()), F: marshalPollableReturn},
		{T: externglib.Type(C.g_resolver_error_get_type()), F: marshalResolverError},
		{T: externglib.Type(C.g_resolver_record_type_get_type()), F: marshalResolverRecordType},
		{T: externglib.Type(C.g_resource_error_get_type()), F: marshalResourceError},
		{T: externglib.Type(C.g_socket_client_event_get_type()), F: marshalSocketClientEvent},
		{T: externglib.Type(C.g_socket_family_get_type()), F: marshalSocketFamily},
		{T: externglib.Type(C.g_socket_listener_event_get_type()), F: marshalSocketListenerEvent},
		{T: externglib.Type(C.g_socket_protocol_get_type()), F: marshalSocketProtocol},
		{T: externglib.Type(C.g_socket_type_get_type()), F: marshalSocketType},
		{T: externglib.Type(C.g_tls_authentication_mode_get_type()), F: marshalTlsAuthenticationMode},
		{T: externglib.Type(C.g_tls_certificate_request_flags_get_type()), F: marshalTlsCertificateRequestFlags},
		{T: externglib.Type(C.g_tls_channel_binding_error_get_type()), F: marshalTlsChannelBindingError},
		{T: externglib.Type(C.g_tls_channel_binding_type_get_type()), F: marshalTlsChannelBindingType},
		{T: externglib.Type(C.g_tls_database_lookup_flags_get_type()), F: marshalTlsDatabaseLookupFlags},
		{T: externglib.Type(C.g_tls_error_get_type()), F: marshalTlsError},
		{T: externglib.Type(C.g_tls_interaction_result_get_type()), F: marshalTlsInteractionResult},
		{T: externglib.Type(C.g_tls_rehandshake_mode_get_type()), F: marshalTlsRehandshakeMode},
		{T: externglib.Type(C.g_unix_socket_address_type_get_type()), F: marshalUnixSocketAddressType},
		{T: externglib.Type(C.g_zlib_compressor_format_get_type()), F: marshalZlibCompressorFormat},

		// Records
		// Skipped ActionEntry.
		// Skipped ActionGroupInterface.
		// Skipped ActionInterface.
		// Skipped ActionMapInterface.
		// Skipped AppInfoIface.
		// Skipped AppLaunchContextClass.
		// Skipped AppLaunchContextPrivate.
		// Skipped ApplicationClass.
		// Skipped ApplicationCommandLineClass.
		// Skipped ApplicationCommandLinePrivate.
		// Skipped ApplicationPrivate.
		// Skipped AsyncInitableIface.
		// Skipped AsyncResultIface.
		// Skipped BufferedInputStreamClass.
		// Skipped BufferedInputStreamPrivate.
		// Skipped BufferedOutputStreamClass.
		// Skipped BufferedOutputStreamPrivate.
		// Skipped CancellableClass.
		// Skipped CancellablePrivate.
		// Skipped CharsetConverterClass.
		// Skipped ConverterIface.
		// Skipped ConverterInputStreamClass.
		// Skipped ConverterInputStreamPrivate.
		// Skipped ConverterOutputStreamClass.
		// Skipped ConverterOutputStreamPrivate.
		// Skipped CredentialsClass.
		{T: externglib.Type(C.g_dbus_annotation_info_get_type()), F: marshalDBusAnnotationInfo},
		{T: externglib.Type(C.g_dbus_arg_info_get_type()), F: marshalDBusArgInfo},
		// Skipped DBusErrorEntry.
		// Skipped DBusInterfaceIface.
		{T: externglib.Type(C.g_dbus_interface_info_get_type()), F: marshalDBusInterfaceInfo},
		// Skipped DBusInterfaceSkeletonClass.
		// Skipped DBusInterfaceSkeletonPrivate.
		// Skipped DBusInterfaceVTable.
		{T: externglib.Type(C.g_dbus_method_info_get_type()), F: marshalDBusMethodInfo},
		{T: externglib.Type(C.g_dbus_node_info_get_type()), F: marshalDBusNodeInfo},
		// Skipped DBusObjectIface.
		// Skipped DBusObjectManagerClientClass.
		// Skipped DBusObjectManagerClientPrivate.
		// Skipped DBusObjectManagerIface.
		// Skipped DBusObjectManagerServerClass.
		// Skipped DBusObjectManagerServerPrivate.
		// Skipped DBusObjectProxyClass.
		// Skipped DBusObjectProxyPrivate.
		// Skipped DBusObjectSkeletonClass.
		// Skipped DBusObjectSkeletonPrivate.
		{T: externglib.Type(C.g_dbus_property_info_get_type()), F: marshalDBusPropertyInfo},
		// Skipped DBusProxyClass.
		// Skipped DBusProxyPrivate.
		{T: externglib.Type(C.g_dbus_signal_info_get_type()), F: marshalDBusSignalInfo},
		// Skipped DBusSubtreeVTable.
		// Skipped DataInputStreamClass.
		// Skipped DataInputStreamPrivate.
		// Skipped DataOutputStreamClass.
		// Skipped DataOutputStreamPrivate.
		// Skipped DatagramBasedInterface.
		// Skipped DesktopAppInfoClass.
		// Skipped DesktopAppInfoLookupIface.
		// Skipped DriveIface.
		// Skipped DtlsClientConnectionInterface.
		// Skipped DtlsConnectionInterface.
		// Skipped DtlsServerConnectionInterface.
		// Skipped EmblemClass.
		// Skipped EmblemedIconClass.
		// Skipped EmblemedIconPrivate.
		// Skipped FileAttributeInfo.
		{T: externglib.Type(C.g_file_attribute_info_list_get_type()), F: marshalFileAttributeInfoList},
		{T: externglib.Type(C.g_file_attribute_matcher_get_type()), F: marshalFileAttributeMatcher},
		// Skipped FileDescriptorBasedIface.
		// Skipped FileEnumeratorClass.
		// Skipped FileEnumeratorPrivate.
		// Skipped FileIOStreamClass.
		// Skipped FileIOStreamPrivate.
		// Skipped FileIconClass.
		// Skipped FileIface.
		// Skipped FileInfoClass.
		// Skipped FileInputStreamClass.
		// Skipped FileInputStreamPrivate.
		// Skipped FileMonitorClass.
		// Skipped FileMonitorPrivate.
		// Skipped FileOutputStreamClass.
		// Skipped FileOutputStreamPrivate.
		// Skipped FilenameCompleterClass.
		// Skipped FilterInputStreamClass.
		// Skipped FilterOutputStreamClass.
		// Skipped IOExtension.
		// Skipped IOExtensionPoint.
		// Skipped IOModuleClass.
		// Skipped IOModuleScope.
		// Skipped IOSchedulerJob.
		// Skipped IOStreamAdapter.
		// Skipped IOStreamClass.
		// Skipped IOStreamPrivate.
		// Skipped IconIface.
		// Skipped InetAddressClass.
		// Skipped InetAddressMaskClass.
		// Skipped InetAddressMaskPrivate.
		// Skipped InetAddressPrivate.
		// Skipped InetSocketAddressClass.
		// Skipped InetSocketAddressPrivate.
		// Skipped InitableIface.
		// Skipped InputMessage.
		// Skipped InputStreamClass.
		// Skipped InputStreamPrivate.
		// Skipped InputVector.
		// Skipped ListModelInterface.
		// Skipped ListStoreClass.
		// Skipped LoadableIconIface.
		// Skipped MemoryInputStreamClass.
		// Skipped MemoryInputStreamPrivate.
		// Skipped MemoryMonitorInterface.
		// Skipped MemoryOutputStreamClass.
		// Skipped MemoryOutputStreamPrivate.
		// Skipped MenuAttributeIterClass.
		// Skipped MenuAttributeIterPrivate.
		// Skipped MenuLinkIterClass.
		// Skipped MenuLinkIterPrivate.
		// Skipped MenuModelClass.
		// Skipped MenuModelPrivate.
		// Skipped MountIface.
		// Skipped MountOperationClass.
		// Skipped MountOperationPrivate.
		// Skipped NativeSocketAddressClass.
		// Skipped NativeSocketAddressPrivate.
		// Skipped NativeVolumeMonitorClass.
		// Skipped NetworkAddressClass.
		// Skipped NetworkAddressPrivate.
		// Skipped NetworkMonitorInterface.
		// Skipped NetworkServiceClass.
		// Skipped NetworkServicePrivate.
		// Skipped OutputMessage.
		// Skipped OutputStreamClass.
		// Skipped OutputStreamPrivate.
		// Skipped OutputVector.
		// Skipped PermissionClass.
		// Skipped PermissionPrivate.
		// Skipped PollableInputStreamInterface.
		// Skipped PollableOutputStreamInterface.
		// Skipped ProxyAddressClass.
		// Skipped ProxyAddressEnumeratorClass.
		// Skipped ProxyAddressEnumeratorPrivate.
		// Skipped ProxyAddressPrivate.
		// Skipped ProxyInterface.
		// Skipped ProxyResolverInterface.
		// Skipped RemoteActionGroupInterface.
		// Skipped ResolverClass.
		// Skipped ResolverPrivate.
		{T: externglib.Type(C.g_resource_get_type()), F: marshalResource},
		// Skipped SeekableIface.
		// Skipped SettingsBackendClass.
		// Skipped SettingsBackendPrivate.
		// Skipped SettingsClass.
		// Skipped SettingsPrivate.
		{T: externglib.Type(C.g_settings_schema_get_type()), F: marshalSettingsSchema},
		{T: externglib.Type(C.g_settings_schema_key_get_type()), F: marshalSettingsSchemaKey},
		{T: externglib.Type(C.g_settings_schema_source_get_type()), F: marshalSettingsSchemaSource},
		// Skipped SimpleActionGroupClass.
		// Skipped SimpleActionGroupPrivate.
		// Skipped SimpleAsyncResultClass.
		// Skipped SimpleProxyResolverClass.
		// Skipped SimpleProxyResolverPrivate.
		// Skipped SocketAddressClass.
		// Skipped SocketAddressEnumeratorClass.
		// Skipped SocketClass.
		// Skipped SocketClientClass.
		// Skipped SocketClientPrivate.
		// Skipped SocketConnectableIface.
		// Skipped SocketConnectionClass.
		// Skipped SocketConnectionPrivate.
		// Skipped SocketControlMessageClass.
		// Skipped SocketControlMessagePrivate.
		// Skipped SocketListenerClass.
		// Skipped SocketListenerPrivate.
		// Skipped SocketPrivate.
		// Skipped SocketServiceClass.
		// Skipped SocketServicePrivate.
		{T: externglib.Type(C.g_srv_target_get_type()), F: marshalSrvTarget},
		// Skipped StaticResource.
		// Skipped TaskClass.
		// Skipped TcpConnectionClass.
		// Skipped TcpConnectionPrivate.
		// Skipped TcpWrapperConnectionClass.
		// Skipped TcpWrapperConnectionPrivate.
		// Skipped ThemedIconClass.
		// Skipped ThreadedSocketServiceClass.
		// Skipped ThreadedSocketServicePrivate.
		// Skipped TlsBackendInterface.
		// Skipped TlsCertificateClass.
		// Skipped TlsCertificatePrivate.
		// Skipped TlsClientConnectionInterface.
		// Skipped TlsConnectionClass.
		// Skipped TlsConnectionPrivate.
		// Skipped TlsDatabaseClass.
		// Skipped TlsDatabasePrivate.
		// Skipped TlsFileDatabaseInterface.
		// Skipped TlsInteractionClass.
		// Skipped TlsInteractionPrivate.
		// Skipped TlsPasswordClass.
		// Skipped TlsPasswordPrivate.
		// Skipped TlsServerConnectionInterface.
		// Skipped UnixConnectionClass.
		// Skipped UnixConnectionPrivate.
		// Skipped UnixCredentialsMessageClass.
		// Skipped UnixCredentialsMessagePrivate.
		// Skipped UnixFDListClass.
		// Skipped UnixFDListPrivate.
		// Skipped UnixFDMessageClass.
		// Skipped UnixFDMessagePrivate.
		// Skipped UnixInputStreamClass.
		// Skipped UnixInputStreamPrivate.
		{T: externglib.Type(C.g_unix_mount_entry_get_type()), F: marshalUnixMountEntry},
		// Skipped UnixMountMonitorClass.
		{T: externglib.Type(C.g_unix_mount_point_get_type()), F: marshalUnixMountPoint},
		// Skipped UnixOutputStreamClass.
		// Skipped UnixOutputStreamPrivate.
		// Skipped UnixSocketAddressClass.
		// Skipped UnixSocketAddressPrivate.
		// Skipped VfsClass.
		// Skipped VolumeIface.
		// Skipped VolumeMonitorClass.
		// Skipped ZlibCompressorClass.
		// Skipped ZlibDecompressorClass.

		// Classes
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
		{T: externglib.Type(C.g_app_launch_context_get_type()), F: marshalAppLaunchContext},
		{T: externglib.Type(C.g_application_get_type()), F: marshalApplication},
		{T: externglib.Type(C.g_application_command_line_get_type()), F: marshalApplicationCommandLine},
		{T: externglib.Type(C.g_buffered_input_stream_get_type()), F: marshalBufferedInputStream},
		{T: externglib.Type(C.g_buffered_output_stream_get_type()), F: marshalBufferedOutputStream},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIcon},
		{T: externglib.Type(C.g_cancellable_get_type()), F: marshalCancellable},
		{T: externglib.Type(C.g_charset_converter_get_type()), F: marshalCharsetConverter},
		{T: externglib.Type(C.g_converter_input_stream_get_type()), F: marshalConverterInputStream},
		{T: externglib.Type(C.g_converter_output_stream_get_type()), F: marshalConverterOutputStream},
		{T: externglib.Type(C.g_credentials_get_type()), F: marshalCredentials},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
		{T: externglib.Type(C.g_dbus_interface_skeleton_get_type()), F: marshalDBusInterfaceSkeleton},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
		{T: externglib.Type(C.g_dbus_object_manager_client_get_type()), F: marshalDBusObjectManagerClient},
		{T: externglib.Type(C.g_dbus_object_manager_server_get_type()), F: marshalDBusObjectManagerServer},
		{T: externglib.Type(C.g_dbus_object_proxy_get_type()), F: marshalDBusObjectProxy},
		{T: externglib.Type(C.g_dbus_object_skeleton_get_type()), F: marshalDBusObjectSkeleton},
		{T: externglib.Type(C.g_dbus_proxy_get_type()), F: marshalDBusProxy},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
		{T: externglib.Type(C.g_data_input_stream_get_type()), F: marshalDataInputStream},
		{T: externglib.Type(C.g_data_output_stream_get_type()), F: marshalDataOutputStream},
		{T: externglib.Type(C.g_desktop_app_info_get_type()), F: marshalDesktopAppInfo},
		{T: externglib.Type(C.g_emblem_get_type()), F: marshalEmblem},
		{T: externglib.Type(C.g_emblemed_icon_get_type()), F: marshalEmblemedIcon},
		{T: externglib.Type(C.g_file_enumerator_get_type()), F: marshalFileEnumerator},
		{T: externglib.Type(C.g_file_io_stream_get_type()), F: marshalFileIOStream},
		{T: externglib.Type(C.g_file_icon_get_type()), F: marshalFileIcon},
		{T: externglib.Type(C.g_file_info_get_type()), F: marshalFileInfo},
		{T: externglib.Type(C.g_file_input_stream_get_type()), F: marshalFileInputStream},
		{T: externglib.Type(C.g_file_monitor_get_type()), F: marshalFileMonitor},
		{T: externglib.Type(C.g_file_output_stream_get_type()), F: marshalFileOutputStream},
		{T: externglib.Type(C.g_filename_completer_get_type()), F: marshalFilenameCompleter},
		{T: externglib.Type(C.g_filter_input_stream_get_type()), F: marshalFilterInputStream},
		{T: externglib.Type(C.g_filter_output_stream_get_type()), F: marshalFilterOutputStream},
		// Skipped IOModule.
		{T: externglib.Type(C.g_io_stream_get_type()), F: marshalIOStream},
		{T: externglib.Type(C.g_inet_address_get_type()), F: marshalInetAddress},
		{T: externglib.Type(C.g_inet_address_mask_get_type()), F: marshalInetAddressMask},
		{T: externglib.Type(C.g_inet_socket_address_get_type()), F: marshalInetSocketAddress},
		{T: externglib.Type(C.g_input_stream_get_type()), F: marshalInputStream},
		{T: externglib.Type(C.g_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.g_memory_input_stream_get_type()), F: marshalMemoryInputStream},
		{T: externglib.Type(C.g_memory_output_stream_get_type()), F: marshalMemoryOutputStream},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.g_menu_attribute_iter_get_type()), F: marshalMenuAttributeIter},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.g_menu_link_iter_get_type()), F: marshalMenuLinkIter},
		{T: externglib.Type(C.g_menu_model_get_type()), F: marshalMenuModel},
		{T: externglib.Type(C.g_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.g_native_socket_address_get_type()), F: marshalNativeSocketAddress},
		{T: externglib.Type(C.g_native_volume_monitor_get_type()), F: marshalNativeVolumeMonitor},
		{T: externglib.Type(C.g_network_address_get_type()), F: marshalNetworkAddress},
		{T: externglib.Type(C.g_network_service_get_type()), F: marshalNetworkService},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
		{T: externglib.Type(C.g_output_stream_get_type()), F: marshalOutputStream},
		{T: externglib.Type(C.g_permission_get_type()), F: marshalPermission},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
		{T: externglib.Type(C.g_proxy_address_get_type()), F: marshalProxyAddress},
		{T: externglib.Type(C.g_proxy_address_enumerator_get_type()), F: marshalProxyAddressEnumerator},
		{T: externglib.Type(C.g_resolver_get_type()), F: marshalResolver},
		{T: externglib.Type(C.g_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.g_settings_backend_get_type()), F: marshalSettingsBackend},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
		{T: externglib.Type(C.g_simple_action_group_get_type()), F: marshalSimpleActionGroup},
		{T: externglib.Type(C.g_simple_async_result_get_type()), F: marshalSimpleAsyncResult},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
		{T: externglib.Type(C.g_simple_proxy_resolver_get_type()), F: marshalSimpleProxyResolver},
		{T: externglib.Type(C.g_socket_get_type()), F: marshalSocket},
		{T: externglib.Type(C.g_socket_address_get_type()), F: marshalSocketAddress},
		{T: externglib.Type(C.g_socket_address_enumerator_get_type()), F: marshalSocketAddressEnumerator},
		{T: externglib.Type(C.g_socket_client_get_type()), F: marshalSocketClient},
		{T: externglib.Type(C.g_socket_connection_get_type()), F: marshalSocketConnection},
		{T: externglib.Type(C.g_socket_control_message_get_type()), F: marshalSocketControlMessage},
		{T: externglib.Type(C.g_socket_listener_get_type()), F: marshalSocketListener},
		{T: externglib.Type(C.g_socket_service_get_type()), F: marshalSocketService},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
		{T: externglib.Type(C.g_task_get_type()), F: marshalTask},
		{T: externglib.Type(C.g_tcp_connection_get_type()), F: marshalTcpConnection},
		{T: externglib.Type(C.g_tcp_wrapper_connection_get_type()), F: marshalTcpWrapperConnection},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
		{T: externglib.Type(C.g_themed_icon_get_type()), F: marshalThemedIcon},
		{T: externglib.Type(C.g_threaded_socket_service_get_type()), F: marshalThreadedSocketService},
		{T: externglib.Type(C.g_tls_certificate_get_type()), F: marshalTlsCertificate},
		{T: externglib.Type(C.g_tls_connection_get_type()), F: marshalTlsConnection},
		{T: externglib.Type(C.g_tls_database_get_type()), F: marshalTlsDatabase},
		{T: externglib.Type(C.g_tls_interaction_get_type()), F: marshalTlsInteraction},
		{T: externglib.Type(C.g_tls_password_get_type()), F: marshalTlsPassword},
		{T: externglib.Type(C.g_unix_connection_get_type()), F: marshalUnixConnection},
		{T: externglib.Type(C.g_unix_credentials_message_get_type()), F: marshalUnixCredentialsMessage},
		{T: externglib.Type(C.g_unix_fd_list_get_type()), F: marshalUnixFDList},
		{T: externglib.Type(C.g_unix_fd_message_get_type()), F: marshalUnixFDMessage},
		{T: externglib.Type(C.g_unix_input_stream_get_type()), F: marshalUnixInputStream},
		{T: externglib.Type(C.g_unix_mount_monitor_get_type()), F: marshalUnixMountMonitor},
		{T: externglib.Type(C.g_unix_output_stream_get_type()), F: marshalUnixOutputStream},
		{T: externglib.Type(C.g_unix_socket_address_get_type()), F: marshalUnixSocketAddress},
		{T: externglib.Type(C.g_vfs_get_type()), F: marshalVfs},
		{T: externglib.Type(C.g_volume_monitor_get_type()), F: marshalVolumeMonitor},
		{T: externglib.Type(C.g_zlib_compressor_get_type()), F: marshalZlibCompressor},
		{T: externglib.Type(C.g_zlib_decompressor_get_type()), F: marshalZlibDecompressor},
	})
}

// BusType: an enumeration for well-known message buses.
type BusType int

const (
	// BusTypeStarter: an alias for the message bus that activated the process,
	// if any.
	BusTypeStarter BusType = -1
	// BusTypeNone: not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem: the system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession: the login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p uintptr) (interface{}, error) {
	return BusType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterResult: results returned from g_converter_convert().
type ConverterResult int

const (
	// ConverterResultError: there was an error during conversion.
	ConverterResultError ConverterResult = 0
	// ConverterResultConverted: some data was consumed or produced
	ConverterResultConverted ConverterResult = 1
	// ConverterResultFinished: the conversion is finished
	ConverterResultFinished ConverterResult = 2
	// ConverterResultFlushed: flushing is finished
	ConverterResultFlushed ConverterResult = 3
)

func marshalConverterResult(p uintptr) (interface{}, error) {
	return ConverterResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CredentialsType: enumeration describing different kinds of native credential
// types.
type CredentialsType int

const (
	// CredentialsTypeInvalid: indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = 0
	// CredentialsTypeLinuxUcred: the native credentials type is a `struct
	// ucred`.
	CredentialsTypeLinuxUcred CredentialsType = 1
	// CredentialsTypeFreebsdCmsgcred: the native credentials type is a `struct
	// cmsgcred`.
	CredentialsTypeFreebsdCmsgcred CredentialsType = 2
	// CredentialsTypeOpenbsdSockpeercred: the native credentials type is a
	// `struct sockpeercred`. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred CredentialsType = 3
	// CredentialsTypeSolarisUcred: the native credentials type is a `ucred_t`.
	// Added in 2.40.
	CredentialsTypeSolarisUcred CredentialsType = 4
	// CredentialsTypeNetbsdUnpcbid: the native credentials type is a `struct
	// unpcbid`. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid CredentialsType = 5
	// CredentialsTypeAppleXucred: the native credentials type is a `struct
	// xucred`. Added in 2.66.
	CredentialsTypeAppleXucred CredentialsType = 6
)

func marshalCredentialsType(p uintptr) (interface{}, error) {
	return CredentialsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusError: error codes for the G_DBUS_ERROR error domain.
type DBusError int

const (
	// DBusErrorFailed: a generic error; "something went wrong" - see the error
	// message for more.
	DBusErrorFailed DBusError = 0
	// DBusErrorNoMemory: there was not enough memory to complete an operation.
	DBusErrorNoMemory DBusError = 1
	// DBusErrorServiceUnknown: the bus doesn't know how to launch a service to
	// supply the bus name you wanted.
	DBusErrorServiceUnknown DBusError = 2
	// DBusErrorNameHasNoOwner: the bus name you referenced doesn't exist (i.e.
	// no application owns it).
	DBusErrorNameHasNoOwner DBusError = 3
	// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
	DBusErrorNoReply DBusError = 4
	// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
	DBusErrorIOError DBusError = 5
	// DBusErrorBadAddress: a D-Bus bus address was malformed.
	DBusErrorBadAddress DBusError = 6
	// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
	DBusErrorNotSupported DBusError = 7
	// DBusErrorLimitsExceeded: some limited resource is exhausted.
	DBusErrorLimitsExceeded DBusError = 8
	// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
	DBusErrorAccessDenied DBusError = 9
	// DBusErrorAuthFailed: authentication didn't work.
	DBusErrorAuthFailed DBusError = 10
	// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
	DBusErrorNoServer DBusError = 11
	// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimeout DBusError = 12
	// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
	DBusErrorNoNetwork DBusError = 13
	// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
	DBusErrorAddressInUse DBusError = 14
	// DBusErrorDisconnected: the connection is disconnected and you're trying
	// to use it.
	DBusErrorDisconnected DBusError = 15
	// DBusErrorInvalidArgs: invalid arguments passed to a method call.
	DBusErrorInvalidArgs DBusError = 16
	// DBusErrorFileNotFound: missing file.
	DBusErrorFileNotFound DBusError = 17
	// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
	DBusErrorFileExists DBusError = 18
	// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
	DBusErrorUnknownMethod DBusError = 19
	// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimedOut DBusError = 20
	// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
	DBusErrorMatchRuleNotFound DBusError = 21
	// DBusErrorMatchRuleInvalid: the match rule isn't syntactically valid.
	DBusErrorMatchRuleInvalid DBusError = 22
	// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
	DBusErrorSpawnExecFailed DBusError = 23
	// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
	DBusErrorSpawnForkFailed DBusError = 24
	// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
	DBusErrorSpawnChildExited DBusError = 25
	// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
	DBusErrorSpawnChildSignaled DBusError = 26
	// DBusErrorSpawnFailed: while starting a new process, something went wrong.
	DBusErrorSpawnFailed DBusError = 27
	// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
	DBusErrorSpawnSetupFailed DBusError = 28
	// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
	DBusErrorSpawnConfigInvalid DBusError = 29
	// DBusErrorSpawnServiceInvalid: bus name was not valid.
	DBusErrorSpawnServiceInvalid DBusError = 30
	// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
	DBusErrorSpawnServiceNotFound DBusError = 31
	// DBusErrorSpawnPermissionsInvalid: permissions are incorrect on the setuid
	// helper.
	DBusErrorSpawnPermissionsInvalid DBusError = 32
	// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
	DBusErrorSpawnFileInvalid DBusError = 33
	// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
	DBusErrorSpawnNoMemory DBusError = 34
	// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
	DBusErrorUnixProcessIDUnknown DBusError = 35
	// DBusErrorInvalidSignature: a type signature is not valid.
	DBusErrorInvalidSignature DBusError = 36
	// DBusErrorInvalidFileContent: a file contains invalid syntax or is
	// otherwise broken.
	DBusErrorInvalidFileContent DBusError = 37
	// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
	DBusErrorSelinuxSecurityContextUnknown DBusError = 38
	// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
	DBusErrorAdtAuditDataUnknown DBusError = 39
	// DBusErrorObjectPathInUse: there's already an object with the requested
	// object path.
	DBusErrorObjectPathInUse DBusError = 40
	// DBusErrorUnknownObject: object you invoked a method on isn't known. Since
	// 2.42
	DBusErrorUnknownObject DBusError = 41
	// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42
	DBusErrorUnknownInterface DBusError = 42
	// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42
	DBusErrorUnknownProperty DBusError = 43
	// DBusErrorPropertyReadOnly: property you tried to set is read-only. Since
	// 2.42
	DBusErrorPropertyReadOnly DBusError = 44
)

func marshalDBusError(p uintptr) (interface{}, error) {
	return DBusError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
type DBusMessageByteOrder int

const (
	// DBusMessageByteOrderBigEndian: the byte order is big endian.
	DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
	// DBusMessageByteOrderLittleEndian: the byte order is little endian.
	DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
)

func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
	return DBusMessageByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageHeaderField: header fields used in BusMessage.
type DBusMessageHeaderField int

const (
	// DBusMessageHeaderFieldInvalid: not a valid header field.
	DBusMessageHeaderFieldInvalid DBusMessageHeaderField = 0
	// DBusMessageHeaderFieldPath: the object path.
	DBusMessageHeaderFieldPath DBusMessageHeaderField = 1
	// DBusMessageHeaderFieldInterface: the interface name.
	DBusMessageHeaderFieldInterface DBusMessageHeaderField = 2
	// DBusMessageHeaderFieldMember: the method or signal name.
	DBusMessageHeaderFieldMember DBusMessageHeaderField = 3
	// DBusMessageHeaderFieldErrorName: the name of the error that occurred.
	DBusMessageHeaderFieldErrorName DBusMessageHeaderField = 4
	// DBusMessageHeaderFieldReplySerial: the serial number the message is a
	// reply to.
	DBusMessageHeaderFieldReplySerial DBusMessageHeaderField = 5
	// DBusMessageHeaderFieldDestination: the name the message is intended for.
	DBusMessageHeaderFieldDestination DBusMessageHeaderField = 6
	// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
	DBusMessageHeaderFieldSender DBusMessageHeaderField = 7
	// DBusMessageHeaderFieldSignature: the signature of the message body.
	DBusMessageHeaderFieldSignature DBusMessageHeaderField = 8
	// DBusMessageHeaderFieldNumUnixFds: the number of UNIX file descriptors
	// that accompany the message.
	DBusMessageHeaderFieldNumUnixFds DBusMessageHeaderField = 9
)

func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
	return DBusMessageHeaderField(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageType: message types used in BusMessage.
type DBusMessageType int

const (
	// DBusMessageTypeInvalid: message is of invalid type.
	DBusMessageTypeInvalid DBusMessageType = 0
	// DBusMessageTypeMethodCall: method call.
	DBusMessageTypeMethodCall DBusMessageType = 1
	// DBusMessageTypeMethodReturn: method reply.
	DBusMessageTypeMethodReturn DBusMessageType = 2
	// DBusMessageTypeError: error reply.
	DBusMessageTypeError DBusMessageType = 3
	// DBusMessageTypeSignal: signal emission.
	DBusMessageTypeSignal DBusMessageType = 4
)

func marshalDBusMessageType(p uintptr) (interface{}, error) {
	return DBusMessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamByteOrder: GDataStreamByteOrder is used to ensure proper endianness
// of streaming data sources across various machine architectures.
type DataStreamByteOrder int

const (
	// DataStreamByteOrderBigEndian: selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = 0
	// DataStreamByteOrderLittleEndian: selects Little Endian byte order.
	DataStreamByteOrderLittleEndian DataStreamByteOrder = 1
	// DataStreamByteOrderHostEndian: selects endianness based on host machine's
	// architecture.
	DataStreamByteOrderHostEndian DataStreamByteOrder = 2
)

func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
	return DataStreamByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamNewlineType: GDataStreamNewlineType is used when checking for or
// setting the line endings for a given file.
type DataStreamNewlineType int

const (
	// DataStreamNewlineTypeLf: selects "LF" line endings, common on most modern
	// UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = 0
	// DataStreamNewlineTypeCr: selects "CR" line endings.
	DataStreamNewlineTypeCr DataStreamNewlineType = 1
	// DataStreamNewlineTypeCrLf: selects "CR, LF" line ending, common on
	// Microsoft Windows.
	DataStreamNewlineTypeCrLf DataStreamNewlineType = 2
	// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
	DataStreamNewlineTypeAny DataStreamNewlineType = 3
)

func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
	return DataStreamNewlineType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
type DriveStartStopType int

const (
	// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = 0
	// DriveStartStopTypeShutdown: the stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
	DriveStartStopTypeShutdown DriveStartStopType = 1
	// DriveStartStopTypeNetwork: the start/stop methods are used for
	// connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork DriveStartStopType = 2
	// DriveStartStopTypeMultidisk: the start/stop methods will
	// assemble/disassemble a virtual drive from several physical drives.
	DriveStartStopTypeMultidisk DriveStartStopType = 3
	// DriveStartStopTypePassword: the start/stop methods will unlock/lock the
	// disk (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command)
	DriveStartStopTypePassword DriveStartStopType = 4
)

func marshalDriveStartStopType(p uintptr) (interface{}, error) {
	return DriveStartStopType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EmblemOrigin: GEmblemOrigin is used to add information about the origin of
// the emblem to #GEmblem.
type EmblemOrigin int

const (
	// EmblemOriginUnknown: emblem of unknown origin
	EmblemOriginUnknown EmblemOrigin = 0
	// EmblemOriginDevice: emblem adds device-specific information
	EmblemOriginDevice EmblemOrigin = 1
	// EmblemOriginLivemetadata: emblem depicts live metadata, such as
	// "readonly"
	EmblemOriginLivemetadata EmblemOrigin = 2
	// EmblemOriginTag: emblem comes from a user-defined tag, e.g. set by
	// nautilus (in the future)
	EmblemOriginTag EmblemOrigin = 3
)

func marshalEmblemOrigin(p uintptr) (interface{}, error) {
	return EmblemOrigin(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
type FileAttributeStatus int

const (
	// FileAttributeStatusUnset: attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = 0
	// FileAttributeStatusSet: attribute value is set.
	FileAttributeStatusSet FileAttributeStatus = 1
	// FileAttributeStatusErrorSetting: indicates an error in setting the value.
	FileAttributeStatusErrorSetting FileAttributeStatus = 2
)

func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
	return FileAttributeStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeType: the data types for file attributes.
type FileAttributeType int

const (
	// FileAttributeTypeInvalid: indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = 0
	// FileAttributeTypeString: a null terminated UTF8 string.
	FileAttributeTypeString FileAttributeType = 1
	// FileAttributeTypeByteString: a zero terminated string of non-zero bytes.
	FileAttributeTypeByteString FileAttributeType = 2
	// FileAttributeTypeBoolean: a boolean value.
	FileAttributeTypeBoolean FileAttributeType = 3
	// FileAttributeTypeUint32: an unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32 FileAttributeType = 4
	// FileAttributeTypeInt32: a signed 4-byte/32-bit integer.
	FileAttributeTypeInt32 FileAttributeType = 5
	// FileAttributeTypeUint64: an unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64 FileAttributeType = 6
	// FileAttributeTypeInt64: a signed 8-byte/64-bit integer.
	FileAttributeTypeInt64 FileAttributeType = 7
	// FileAttributeTypeObject: a #GObject.
	FileAttributeTypeObject FileAttributeType = 8
	// FileAttributeTypeStringv: a nil terminated char **. Since 2.22
	FileAttributeTypeStringv FileAttributeType = 9
)

func marshalFileAttributeType(p uintptr) (interface{}, error) {
	return FileAttributeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorEvent: specifies what type of event a monitor event is.
type FileMonitorEvent int

const (
	// FileMonitorEventChanged: a file changed.
	FileMonitorEventChanged FileMonitorEvent = 0
	// FileMonitorEventChangesDoneHint: a hint that this was probably the last
	// change in a set of changes.
	FileMonitorEventChangesDoneHint FileMonitorEvent = 1
	// FileMonitorEventDeleted: a file was deleted.
	FileMonitorEventDeleted FileMonitorEvent = 2
	// FileMonitorEventCreated: a file was created.
	FileMonitorEventCreated FileMonitorEvent = 3
	// FileMonitorEventAttributeChanged: a file attribute was changed.
	FileMonitorEventAttributeChanged FileMonitorEvent = 4
	// FileMonitorEventPreUnmount: the file location will soon be unmounted.
	FileMonitorEventPreUnmount FileMonitorEvent = 5
	// FileMonitorEventUnmounted: the file location was unmounted.
	FileMonitorEventUnmounted FileMonitorEvent = 6
	// FileMonitorEventMoved: the file was moved -- only sent if the
	// (deprecated) G_FILE_MONITOR_SEND_MOVED flag is set
	FileMonitorEventMoved FileMonitorEvent = 7
	// FileMonitorEventRenamed: the file was renamed within the current
	// directory -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set.
	// Since: 2.46.
	FileMonitorEventRenamed FileMonitorEvent = 8
	// FileMonitorEventMovedIn: the file was moved into the monitored directory
	// from another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
	FileMonitorEventMovedIn FileMonitorEvent = 9
	// FileMonitorEventMovedOut: the file was moved out of the monitored
	// directory to another location -- only sent if the
	// G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46
	FileMonitorEventMovedOut FileMonitorEvent = 10
)

func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
	return FileMonitorEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileType: indicates the file's on-disk type.
//
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type; use
// Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a file is
// a symlink or not. This is due to the fact that NTFS does not have a single
// filesystem object type for symbolic links - it has files that symlink to
// files, and directories that symlink to directories. Type enumeration cannot
// precisely represent this important distinction, which is why all Windows
// symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
type FileType int

const (
	// FileTypeUnknown: file's type is unknown.
	FileTypeUnknown FileType = 0
	// FileTypeRegular: file handle represents a regular file.
	FileTypeRegular FileType = 1
	// FileTypeDirectory: file handle represents a directory.
	FileTypeDirectory FileType = 2
	// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
	FileTypeSymbolicLink FileType = 3
	// FileTypeSpecial: file is a "special" file, such as a socket, fifo, block
	// device, or character device.
	FileTypeSpecial FileType = 4
	// FileTypeShortcut: file is a shortcut (Windows systems).
	FileTypeShortcut FileType = 5
	// FileTypeMountable: file is a mountable location.
	FileTypeMountable FileType = 6
)

func marshalFileType(p uintptr) (interface{}, error) {
	return FileType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilesystemPreviewType: indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType int

const (
	// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = 0
	// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
	FilesystemPreviewTypeIfLocal FilesystemPreviewType = 1
	// FilesystemPreviewTypeNever: never preview files.
	FilesystemPreviewTypeNever FilesystemPreviewType = 2
)

func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
	return FilesystemPreviewType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOErrorEnum: error codes returned by GIO functions.
//
// Note that this domain may be extended in future GLib releases. In general,
// new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before. You
// should therefore avoid writing code like |[<!-- language="C" --> if
// (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED)) { // Assume that
// this is EPRINTERONFIRE ... } ]| but should instead treat all unrecognized
// error codes the same as IO_ERROR_FAILED.
//
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
type IOErrorEnum int

const (
	// IOErrorEnumFailed: generic error condition for when an operation fails
	// and no more specific OErrorEnum value is defined.
	IOErrorEnumFailed IOErrorEnum = 0
	// IOErrorEnumNotFound: file not found.
	IOErrorEnumNotFound IOErrorEnum = 1
	// IOErrorEnumExists: file already exists.
	IOErrorEnumExists IOErrorEnum = 2
	// IOErrorEnumIsDirectory: file is a directory.
	IOErrorEnumIsDirectory IOErrorEnum = 3
	// IOErrorEnumNotDirectory: file is not a directory.
	IOErrorEnumNotDirectory IOErrorEnum = 4
	// IOErrorEnumNotEmpty: file is a directory that isn't empty.
	IOErrorEnumNotEmpty IOErrorEnum = 5
	// IOErrorEnumNotRegularFile: file is not a regular file.
	IOErrorEnumNotRegularFile IOErrorEnum = 6
	// IOErrorEnumNotSymbolicLink: file is not a symbolic link.
	IOErrorEnumNotSymbolicLink IOErrorEnum = 7
	// IOErrorEnumNotMountableFile: file cannot be mounted.
	IOErrorEnumNotMountableFile IOErrorEnum = 8
	// IOErrorEnumFilenameTooLong: filename is too many characters.
	IOErrorEnumFilenameTooLong IOErrorEnum = 9
	// IOErrorEnumInvalidFilename: filename is invalid or contains invalid
	// characters.
	IOErrorEnumInvalidFilename IOErrorEnum = 10
	// IOErrorEnumTooManyLinks: file contains too many symbolic links.
	IOErrorEnumTooManyLinks IOErrorEnum = 11
	// IOErrorEnumNoSpace: no space left on drive.
	IOErrorEnumNoSpace IOErrorEnum = 12
	// IOErrorEnumInvalidArgument: invalid argument.
	IOErrorEnumInvalidArgument IOErrorEnum = 13
	// IOErrorEnumPermissionDenied: permission denied.
	IOErrorEnumPermissionDenied IOErrorEnum = 14
	// IOErrorEnumNotSupported: operation (or one of its parameters) not
	// supported
	IOErrorEnumNotSupported IOErrorEnum = 15
	// IOErrorEnumNotMounted: file isn't mounted.
	IOErrorEnumNotMounted IOErrorEnum = 16
	// IOErrorEnumAlreadyMounted: file is already mounted.
	IOErrorEnumAlreadyMounted IOErrorEnum = 17
	// IOErrorEnumClosed: file was closed.
	IOErrorEnumClosed IOErrorEnum = 18
	// IOErrorEnumCancelled: operation was cancelled. See #GCancellable.
	IOErrorEnumCancelled IOErrorEnum = 19
	// IOErrorEnumPending: operations are still pending.
	IOErrorEnumPending IOErrorEnum = 20
	// IOErrorEnumReadOnly: file is read only.
	IOErrorEnumReadOnly IOErrorEnum = 21
	// IOErrorEnumCantCreateBackup: backup couldn't be created.
	IOErrorEnumCantCreateBackup IOErrorEnum = 22
	// IOErrorEnumWrongEtag: file's Entity Tag was incorrect.
	IOErrorEnumWrongEtag IOErrorEnum = 23
	// IOErrorEnumTimedOut: operation timed out.
	IOErrorEnumTimedOut IOErrorEnum = 24
	// IOErrorEnumWouldRecurse: operation would be recursive.
	IOErrorEnumWouldRecurse IOErrorEnum = 25
	// IOErrorEnumBusy: file is busy.
	IOErrorEnumBusy IOErrorEnum = 26
	// IOErrorEnumWouldBlock: operation would block.
	IOErrorEnumWouldBlock IOErrorEnum = 27
	// IOErrorEnumHostNotFound: host couldn't be found (remote operations).
	IOErrorEnumHostNotFound IOErrorEnum = 28
	// IOErrorEnumWouldMerge: operation would merge files.
	IOErrorEnumWouldMerge IOErrorEnum = 29
	// IOErrorEnumFailedHandled: operation failed and a helper program has
	// already interacted with the user. Do not display any error dialog.
	IOErrorEnumFailedHandled IOErrorEnum = 30
	// IOErrorEnumTooManyOpenFiles: the current process has too many files open
	// and can't open any more. Duplicate descriptors do count toward this
	// limit. Since 2.20
	IOErrorEnumTooManyOpenFiles IOErrorEnum = 31
	// IOErrorEnumNotInitialized: the object has not been initialized. Since
	// 2.22
	IOErrorEnumNotInitialized IOErrorEnum = 32
	// IOErrorEnumAddressInUse: the requested address is already in use. Since
	// 2.22
	IOErrorEnumAddressInUse IOErrorEnum = 33
	// IOErrorEnumPartialInput: need more input to finish operation. Since 2.24
	IOErrorEnumPartialInput IOErrorEnum = 34
	// IOErrorEnumInvalidData: the input data was invalid. Since 2.24
	IOErrorEnumInvalidData IOErrorEnum = 35
	// IOErrorEnumDbusError: a remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
	IOErrorEnumDbusError IOErrorEnum = 36
	// IOErrorEnumHostUnreachable: host unreachable. Since 2.26
	IOErrorEnumHostUnreachable IOErrorEnum = 37
	// IOErrorEnumNetworkUnreachable: network unreachable. Since 2.26
	IOErrorEnumNetworkUnreachable IOErrorEnum = 38
	// IOErrorEnumConnectionRefused: connection refused. Since 2.26
	IOErrorEnumConnectionRefused IOErrorEnum = 39
	// IOErrorEnumProxyFailed: connection to proxy server failed. Since 2.26
	IOErrorEnumProxyFailed IOErrorEnum = 40
	// IOErrorEnumProxyAuthFailed: proxy authentication failed. Since 2.26
	IOErrorEnumProxyAuthFailed IOErrorEnum = 41
	// IOErrorEnumProxyNeedAuth: proxy server needs authentication. Since 2.26
	IOErrorEnumProxyNeedAuth IOErrorEnum = 42
	// IOErrorEnumProxyNotAllowed: proxy connection is not allowed by ruleset.
	// Since 2.26
	IOErrorEnumProxyNotAllowed IOErrorEnum = 43
	// IOErrorEnumBrokenPipe: broken pipe. Since 2.36
	IOErrorEnumBrokenPipe IOErrorEnum = 44
	// IOErrorEnumConnectionClosed: connection closed by peer. Note that this is
	// the same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection
	// closed" errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
	IOErrorEnumConnectionClosed IOErrorEnum = 44
	// IOErrorEnumNotConnected: transport endpoint is not connected. Since 2.44
	IOErrorEnumNotConnected IOErrorEnum = 45
	// IOErrorEnumMessageTooLarge: message too large. Since 2.48.
	IOErrorEnumMessageTooLarge IOErrorEnum = 46
)

func marshalIOErrorEnum(p uintptr) (interface{}, error) {
	return IOErrorEnum(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOModuleScopeFlags: flags for use with g_io_module_scope_new().
type IOModuleScopeFlags int

const (
	// IOModuleScopeFlagsNone: no module scan flags
	IOModuleScopeFlagsNone IOModuleScopeFlags = 0
	// IOModuleScopeFlagsBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
	IOModuleScopeFlagsBlockDuplicates IOModuleScopeFlags = 1
)

func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
	return IOModuleScopeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MemoryMonitorWarningLevel: memory availability warning levels.
//
//    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//      drop_caches ();
type MemoryMonitorWarningLevel int

const (
	// MemoryMonitorWarningLevelLow: memory on the device is low, processes
	// should free up unneeded resources (for example, in-memory caches) so they
	// can be used elsewhere.
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium: same as
	// @G_MEMORY_MONITOR_WARNING_LEVEL_LOW but the device has even less free
	// memory, so processes should try harder to free up unneeded resources. If
	// your process does not need to stay running, it is a good time for it to
	// quit.
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical: the system will soon start terminating
	// processes to reclaim memory, including background processes.
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p uintptr) (interface{}, error) {
	return MemoryMonitorWarningLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountOperationResult: GMountOperationResult is returned as a result when a
// request for information is send by the mounting operation.
type MountOperationResult int

const (
	// MountOperationResultHandled: the request was fulfilled and the user
	// specified data is now available
	MountOperationResultHandled MountOperationResult = 0
	// MountOperationResultAborted: the user requested the mount operation to be
	// aborted
	MountOperationResultAborted MountOperationResult = 1
	// MountOperationResultUnhandled: the request was unhandled (i.e. not
	// implemented)
	MountOperationResultUnhandled MountOperationResult = 2
)

func marshalMountOperationResult(p uintptr) (interface{}, error) {
	return MountOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NetworkConnectivity: the host's network connectivity state, as reported by
// Monitor.
type NetworkConnectivity int

const (
	// NetworkConnectivityLocal: the host is not configured with a route to the
	// Internet; it may or may not be connected to a local network.
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited: the host is connected to a network, but does
	// not appear to be able to reach the full Internet, perhaps due to upstream
	// network problems.
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal: the host is behind a captive portal and cannot
	// reach the full Internet.
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull: the host is connected to a network, and appears
	// to be able to reach the full Internet.
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p uintptr) (interface{}, error) {
	return NetworkConnectivity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotificationPriority: priority levels for #GNotifications.
type NotificationPriority int

const (
	// NotificationPriorityNormal: the default priority, to be used for the
	// majority of notifications (for example email messages, software updates,
	// completed download/sync operations)
	NotificationPriorityNormal NotificationPriority = 0
	// NotificationPriorityLow: for notifications that do not require immediate
	// attention - typically used for contextual background information, such as
	// contact birthdays or local weather
	NotificationPriorityLow NotificationPriority = 1
	// NotificationPriorityHigh: for events that require more attention, usually
	// because responses are time-sensitive (for example chat and SMS messages
	// or alarms)
	NotificationPriorityHigh NotificationPriority = 2
	// NotificationPriorityUrgent: for urgent notifications, or notifications
	// that require a response in a short space of time (for example phone calls
	// or emergency warnings)
	NotificationPriorityUrgent NotificationPriority = 3
)

func marshalNotificationPriority(p uintptr) (interface{}, error) {
	return NotificationPriority(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PasswordSave: GPasswordSave is used to indicate the lifespan of a saved
// password.
//
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to, and
// later retrieves it again from there
type PasswordSave int

const (
	// PasswordSaveNever: never save a password.
	PasswordSaveNever PasswordSave = 0
	// PasswordSaveForSession: save a password for the session.
	PasswordSaveForSession PasswordSave = 1
	// PasswordSavePermanently: save a password permanently.
	PasswordSavePermanently PasswordSave = 2
)

func marshalPasswordSave(p uintptr) (interface{}, error) {
	return PasswordSave(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PollableReturn: return value for various IO operations that signal errors via
// the return value and not necessarily via a #GError.
//
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for regularly
// happening errors like G_IO_ERROR_WOULD_BLOCK.
//
// In case of G_POLLABLE_RETURN_FAILED a #GError should be set for the operation
// to give details about the error that happened.
type PollableReturn int

const (
	// PollableReturnFailed: generic error condition for when an operation
	// fails.
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOk: the operation was successfully finished.
	PollableReturnOk PollableReturn = 1
	// PollableReturnWouldBlock: the operation would block.
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p uintptr) (interface{}, error) {
	return PollableReturn(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverError: an error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError int

const (
	// ResolverErrorNotFound: the requested name/address/service was not found
	ResolverErrorNotFound ResolverError = 0
	// ResolverErrorTemporaryFailure: the requested information could not be
	// looked up due to a network error or similar problem
	ResolverErrorTemporaryFailure ResolverError = 1
	// ResolverErrorInternal: unknown error
	ResolverErrorInternal ResolverError = 2
)

func marshalResolverError(p uintptr) (interface{}, error) {
	return ResolverError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverRecordType: the type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
//
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
// weight, a `guint16` with the port, and a string of the hostname.
//
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// `(qs)`, representing a `guint16` with the preference, and a string containing
// the mail exchanger hostname.
//
// G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// `(as)`, representing an array of the strings in the text record. Note: Most
// TXT records only contain a single string, but [RFC
// 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record
// to contain multiple strings. The RFC which defines the interpretation of a
// specific TXT record will likely require concatenation of multiple strings if
// they are present, as with [RFC
// 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
//
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// `(ssuuuuu)`, representing a string containing the primary name server, a
// string containing the administrator, the serial as a `guint32`, the refresh
// interval as a `guint32`, the retry interval as a `guint32`, the expire
// timeout as a `guint32`, and the TTL as a `guint32`.
//
// G_RESOLVER_RECORD_NS records are returned as variants with the signature
// `(s)`, representing a string of the hostname of the name server.
type ResolverRecordType int

const (
	// ResolverRecordTypeSrv: look up DNS SRV records for a domain
	ResolverRecordTypeSrv ResolverRecordType = 1
	// ResolverRecordTypeMx: look up DNS MX records for a domain
	ResolverRecordTypeMx ResolverRecordType = 2
	// ResolverRecordTypeTxt: look up DNS TXT records for a name
	ResolverRecordTypeTxt ResolverRecordType = 3
	// ResolverRecordTypeSoa: look up DNS SOA records for a zone
	ResolverRecordTypeSoa ResolverRecordType = 4
	// ResolverRecordTypeNs: look up DNS NS records for a domain
	ResolverRecordTypeNs ResolverRecordType = 5
)

func marshalResolverRecordType(p uintptr) (interface{}, error) {
	return ResolverRecordType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceError: an error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError int

const (
	// ResourceErrorNotFound: no file was found at the requested path
	ResourceErrorNotFound ResourceError = 0
	// ResourceErrorInternal: unknown error
	ResourceErrorInternal ResourceError = 1
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketClientEvent: describes an event occurring on a Client. See the
// Client::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketClientEvent int

const (
	// SocketClientEventResolving: the client is doing a DNS lookup.
	SocketClientEventResolving SocketClientEvent = 0
	// SocketClientEventResolved: the client has completed a DNS lookup.
	SocketClientEventResolved SocketClientEvent = 1
	// SocketClientEventConnecting: the client is connecting to a remote host
	// (either a proxy or the destination server).
	SocketClientEventConnecting SocketClientEvent = 2
	// SocketClientEventConnected: the client has connected to a remote host.
	SocketClientEventConnected SocketClientEvent = 3
	// SocketClientEventProxyNegotiating: the client is negotiating with a proxy
	// to connect to the destination server.
	SocketClientEventProxyNegotiating SocketClientEvent = 4
	// SocketClientEventProxyNegotiated: the client has negotiated with the
	// proxy server.
	SocketClientEventProxyNegotiated SocketClientEvent = 5
	// SocketClientEventTlsHandshaking: the client is performing a TLS
	// handshake.
	SocketClientEventTlsHandshaking SocketClientEvent = 6
	// SocketClientEventTlsHandshaked: the client has performed a TLS handshake.
	SocketClientEventTlsHandshaked SocketClientEvent = 7
	// SocketClientEventComplete: the client is done with a particular
	// Connectable.
	SocketClientEventComplete SocketClientEvent = 8
)

func marshalSocketClientEvent(p uintptr) (interface{}, error) {
	return SocketClientEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketFamily: the protocol family of a Address. (These values are identical
// to the system defines AF_INET, AF_INET6 and AF_UNIX, if available.)
type SocketFamily int

const (
	// SocketFamilyInvalid: no address family
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyUnix: the UNIX domain family
	SocketFamilyUnix SocketFamily = 1
	// SocketFamilyIpv4: the IPv4 family
	SocketFamilyIpv4 SocketFamily = 2
	// SocketFamilyIpv6: the IPv6 family
	SocketFamilyIpv6 SocketFamily = 10
)

func marshalSocketFamily(p uintptr) (interface{}, error) {
	return SocketFamily(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketListenerEvent: describes an event occurring on a Listener. See the
// Listener::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketListenerEvent int

const (
	// SocketListenerEventBinding: the listener is about to bind a socket.
	SocketListenerEventBinding SocketListenerEvent = 0
	// SocketListenerEventBound: the listener has bound a socket.
	SocketListenerEventBound SocketListenerEvent = 1
	// SocketListenerEventListening: the listener is about to start listening on
	// this socket.
	SocketListenerEventListening SocketListenerEvent = 2
	// SocketListenerEventListened: the listener is now listening on this
	// socket.
	SocketListenerEventListened SocketListenerEvent = 3
)

func marshalSocketListenerEvent(p uintptr) (interface{}, error) {
	return SocketListenerEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketProtocol: a protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
//
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
type SocketProtocol int

const (
	// SocketProtocolUnknown: the protocol type is unknown
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault: the default protocol for the family/type
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTcp: TCP over IP
	SocketProtocolTcp SocketProtocol = 6
	// SocketProtocolUdp: UDP over IP
	SocketProtocolUdp SocketProtocol = 17
	// SocketProtocolSctp: SCTP over IP
	SocketProtocolSctp SocketProtocol = 132
)

func marshalSocketProtocol(p uintptr) (interface{}, error) {
	return SocketProtocol(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketType: flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
type SocketType int

const (
	// SocketTypeInvalid: type unknown or wrong
	SocketTypeInvalid SocketType = 0
	// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream SocketType = 1
	// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP)
	SocketTypeDatagram SocketType = 2
	// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket SocketType = 3
)

func marshalSocketType(p uintptr) (interface{}, error) {
	return SocketType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsAuthenticationMode: the client authentication mode for a ServerConnection.
type TlsAuthenticationMode int

const (
	// TlsAuthenticationModeNone: client authentication not required
	TlsAuthenticationModeNone TlsAuthenticationMode = 0
	// TlsAuthenticationModeRequested: client authentication is requested
	TlsAuthenticationModeRequested TlsAuthenticationMode = 1
	// TlsAuthenticationModeRequired: client authentication is required
	TlsAuthenticationModeRequired TlsAuthenticationMode = 2
)

func marshalTlsAuthenticationMode(p uintptr) (interface{}, error) {
	return TlsAuthenticationMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsCertificateRequestFlags: flags for
// g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
type TlsCertificateRequestFlags int

const (
	// TlsCertificateRequestFlagsNone: no flags
	TlsCertificateRequestFlagsNone TlsCertificateRequestFlags = 0
)

func marshalTlsCertificateRequestFlags(p uintptr) (interface{}, error) {
	return TlsCertificateRequestFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsChannelBindingError: an error code used with G_TLS_CHANNEL_BINDING_ERROR
// in a #GError to indicate a TLS channel binding retrieval error.
type TlsChannelBindingError int

const (
	// TlsChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
	TlsChannelBindingErrorNotImplemented TlsChannelBindingError = 0
	// TlsChannelBindingErrorInvalidState: the handshake is not yet complete on
	// the connection which is a strong requirement for any existing binding
	// type.
	TlsChannelBindingErrorInvalidState TlsChannelBindingError = 1
	// TlsChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
	TlsChannelBindingErrorNotAvailable TlsChannelBindingError = 2
	// TlsChannelBindingErrorNotSupported: binding type is not supported on the
	// current connection. This error could be triggered when requesting
	// `tls-server-end-point` binding data for a certificate which has no hash
	// function or uses multiple hash functions.
	TlsChannelBindingErrorNotSupported TlsChannelBindingError = 3
	// TlsChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
	TlsChannelBindingErrorGeneralError TlsChannelBindingError = 4
)

func marshalTlsChannelBindingError(p uintptr) (interface{}, error) {
	return TlsChannelBindingError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsChannelBindingType: the type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929. The
// [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
// binding type is not currently implemented.
type TlsChannelBindingType int

const (
	// TlsChannelBindingTypeUnique:
	// [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
	// type
	TlsChannelBindingTypeUnique TlsChannelBindingType = 0
	// TlsChannelBindingTypeServerEndPoint:
	// [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
	// binding type
	TlsChannelBindingTypeServerEndPoint TlsChannelBindingType = 1
)

func marshalTlsChannelBindingType(p uintptr) (interface{}, error) {
	return TlsChannelBindingType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsDatabaseLookupFlags: flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
type TlsDatabaseLookupFlags int

const (
	// TlsDatabaseLookupFlagsNone: no lookup flags
	TlsDatabaseLookupFlagsNone TlsDatabaseLookupFlags = 0
	// TlsDatabaseLookupFlagsKeypair: restrict lookup to certificates that have
	// a private key.
	TlsDatabaseLookupFlagsKeypair TlsDatabaseLookupFlags = 1
)

func marshalTlsDatabaseLookupFlags(p uintptr) (interface{}, error) {
	return TlsDatabaseLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsError: an error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TlsError int

const (
	// TlsErrorUnavailable: no TLS provider is available
	TlsErrorUnavailable TlsError = 0
	// TlsErrorMisc: miscellaneous TLS error
	TlsErrorMisc TlsError = 1
	// TlsErrorBadCertificate: the certificate presented could not be parsed or
	// failed validation.
	TlsErrorBadCertificate TlsError = 2
	// TlsErrorNotTls: the TLS handshake failed because the peer does not seem
	// to be a TLS server.
	TlsErrorNotTls TlsError = 3
	// TlsErrorHandshake: the TLS handshake failed because the peer's
	// certificate was not acceptable.
	TlsErrorHandshake TlsError = 4
	// TlsErrorCertificateRequired: the TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
	TlsErrorCertificateRequired TlsError = 5
	// TlsErrorEOF: the TLS connection was closed without proper notice, which
	// may indicate an attack. See g_tls_connection_set_require_close_notify().
	TlsErrorEOF TlsError = 6
	// TlsErrorInappropriateFallback: the TLS handshake failed because the
	// client sent the fallback SCSV, indicating a protocol downgrade attack.
	// Since: 2.60
	TlsErrorInappropriateFallback TlsError = 7
)

func marshalTlsError(p uintptr) (interface{}, error) {
	return TlsError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsInteractionResult: GTlsInteractionResult is returned by various functions
// in Interaction when finishing an interaction request.
type TlsInteractionResult int

const (
	// TlsInteractionResultUnhandled: the interaction was unhandled (i.e. not
	// implemented).
	TlsInteractionResultUnhandled TlsInteractionResult = 0
	// TlsInteractionResultHandled: the interaction completed, and resulting
	// data is available.
	TlsInteractionResultHandled TlsInteractionResult = 1
	// TlsInteractionResultFailed: the interaction has failed, or was cancelled.
	// and the operation should be aborted.
	TlsInteractionResultFailed TlsInteractionResult = 2
)

func marshalTlsInteractionResult(p uintptr) (interface{}, error) {
	return TlsInteractionResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
type TlsRehandshakeMode int

const (
	// TlsRehandshakeModeNever: never allow rehandshaking
	TlsRehandshakeModeNever TlsRehandshakeMode = 0
	// TlsRehandshakeModeSafely: allow safe rehandshaking only
	TlsRehandshakeModeSafely TlsRehandshakeMode = 1
	// TlsRehandshakeModeUnsafely: allow unsafe rehandshaking
	TlsRehandshakeModeUnsafely TlsRehandshakeMode = 2
)

func marshalTlsRehandshakeMode(p uintptr) (interface{}, error) {
	return TlsRehandshakeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UnixSocketAddressType: the type of name used by a SocketAddress.
// G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain socket bound
// to a filesystem path. G_UNIX_SOCKET_ADDRESS_ANONYMOUS indicates a socket not
// bound to any name (eg, a client-side socket, or a socket created with
// socketpair()).
//
// For abstract sockets, there are two incompatible ways of naming them; the man
// pages suggest using the entire `struct sockaddr_un` as the name, padding the
// unused parts of the sun_path field with zeroes; this corresponds to
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED. However, many programs instead just
// use a portion of sun_path, and pass an appropriate smaller length to bind()
// or connect(). This is G_UNIX_SOCKET_ADDRESS_ABSTRACT.
type UnixSocketAddressType int

const (
	// UnixSocketAddressTypeInvalid: invalid
	UnixSocketAddressTypeInvalid UnixSocketAddressType = 0
	// UnixSocketAddressTypeAnonymous: anonymous
	UnixSocketAddressTypeAnonymous UnixSocketAddressType = 1
	// UnixSocketAddressTypePath: a filesystem path
	UnixSocketAddressTypePath UnixSocketAddressType = 2
	// UnixSocketAddressTypeAbstract: an abstract name
	UnixSocketAddressTypeAbstract UnixSocketAddressType = 3
	// UnixSocketAddressTypeAbstractPadded: an abstract name, 0-padded to the
	// full length of a unix socket name
	UnixSocketAddressTypeAbstractPadded UnixSocketAddressType = 4
)

func marshalUnixSocketAddressType(p uintptr) (interface{}, error) {
	return UnixSocketAddressType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ZlibCompressorFormat: used to select the type of data format to use for
// Decompressor and Compressor.
type ZlibCompressorFormat int

const (
	// ZlibCompressorFormatZlib: deflate compression with zlib header
	ZlibCompressorFormatZlib ZlibCompressorFormat = 0
	// ZlibCompressorFormatGzip: gzip file format
	ZlibCompressorFormatGzip ZlibCompressorFormat = 1
	// ZlibCompressorFormatRaw: deflate compression with no header
	ZlibCompressorFormatRaw ZlibCompressorFormat = 2
)

func marshalZlibCompressorFormat(p uintptr) (interface{}, error) {
	return ZlibCompressorFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppInfoCreateFlags: flags used when creating a Info.
type AppInfoCreateFlags int

const (
	// AppInfoCreateFlagsNone: no flags.
	AppInfoCreateFlagsNone AppInfoCreateFlags = 0b0
	// AppInfoCreateFlagsNeedsTerminal: application opens in a terminal window.
	AppInfoCreateFlagsNeedsTerminal AppInfoCreateFlags = 0b1
	// AppInfoCreateFlagsSupportsUris: application supports URI arguments.
	AppInfoCreateFlagsSupportsUris AppInfoCreateFlags = 0b10
	// AppInfoCreateFlagsSupportsStartupNotification: application supports
	// startup notification. Since 2.26
	AppInfoCreateFlagsSupportsStartupNotification AppInfoCreateFlags = 0b100
)

func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
	return AppInfoCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationFlags: flags used to define the behaviour of a #GApplication.
type ApplicationFlags int

const (
	// ApplicationFlagsFlagsNone: default
	ApplicationFlagsFlagsNone ApplicationFlags = 0b0
	// ApplicationFlagsIsService: run as a service. In this mode, registration
	// fails if the service is already running, and the application will
	// initially wait up to 10 seconds for an initial activation message to
	// arrive.
	ApplicationFlagsIsService ApplicationFlags = 0b1
	// ApplicationFlagsIsLauncher: don't try to become the primary instance.
	ApplicationFlagsIsLauncher ApplicationFlags = 0b10
	// ApplicationFlagsHandlesOpen: this application handles opening files (in
	// the primary instance). Note that this flag only affects the default
	// implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
	ApplicationFlagsHandlesOpen ApplicationFlags = 0b100
	// ApplicationFlagsHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
	ApplicationFlagsHandlesCommandLine ApplicationFlags = 0b1000
	// ApplicationFlagsSendEnvironment: send the environment of the launching
	// process to the primary instance. Set this flag if your application is
	// expected to behave differently depending on certain environment
	// variables. For instance, an editor might be expected to use the
	// `GIT_COMMITTER_NAME` environment variable when editing a git commit
	// message. The environment is available to the #GApplication::command-line
	// signal handler, via g_application_command_line_getenv().
	ApplicationFlagsSendEnvironment ApplicationFlags = 0b10000
	// ApplicationFlagsNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID is
	// given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
	ApplicationFlagsNonUnique ApplicationFlags = 0b100000
	// ApplicationFlagsCanOverrideAppID: allow users to override the application
	// ID from the command line with `--gapplication-app-id`. Since: 2.48
	ApplicationFlagsCanOverrideAppID ApplicationFlags = 0b1000000
	// ApplicationFlagsAllowReplacement: allow another instance to take over the
	// bus name. Since: 2.60
	ApplicationFlagsAllowReplacement ApplicationFlags = 0b10000000
	// ApplicationFlagsReplace: take over from another instance. This flag is
	// usually set by passing `--gapplication-replace` on the commandline.
	// Since: 2.60
	ApplicationFlagsReplace ApplicationFlags = 0b100000000
)

func marshalApplicationFlags(p uintptr) (interface{}, error) {
	return ApplicationFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AskPasswordFlags: GAskPasswordFlags are used to request specific information
// from the user, or to notify the user of their choices in an authentication
// situation.
type AskPasswordFlags int

const (
	// AskPasswordFlagsNeedPassword: operation requires a password.
	AskPasswordFlagsNeedPassword AskPasswordFlags = 0b1
	// AskPasswordFlagsNeedUsername: operation requires a username.
	AskPasswordFlagsNeedUsername AskPasswordFlags = 0b10
	// AskPasswordFlagsNeedDomain: operation requires a domain.
	AskPasswordFlagsNeedDomain AskPasswordFlags = 0b100
	// AskPasswordFlagsSavingSupported: operation supports saving settings.
	AskPasswordFlagsSavingSupported AskPasswordFlags = 0b1000
	// AskPasswordFlagsAnonymousSupported: operation supports anonymous users.
	AskPasswordFlagsAnonymousSupported AskPasswordFlags = 0b10000
	// AskPasswordFlagsTcrypt: operation takes TCRYPT parameters (Since: 2.58)
	AskPasswordFlagsTcrypt AskPasswordFlags = 0b100000
)

func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
	return AskPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameOwnerFlags: flags used in g_bus_own_name().
type BusNameOwnerFlags int

const (
	// BusNameOwnerFlagsNone: no flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0b0
	// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 0b1
	// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the
	// name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 0b10
	// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns the
	// name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54)
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 0b100
)

func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
	return BusNameOwnerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameWatcherFlags: flags used in g_bus_watch_name().
type BusNameWatcherFlags int

const (
	// BusNameWatcherFlagsNone: no flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0b0
	// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 0b1
)

func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
	return BusNameWatcherFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterFlags: flags used when calling a g_converter_convert().
type ConverterFlags int

const (
	// ConverterFlagsNone: no flags.
	ConverterFlagsNone ConverterFlags = 0b0
	// ConverterFlagsInputAtEnd: at end of input data
	ConverterFlagsInputAtEnd ConverterFlags = 0b1
	// ConverterFlagsFlush: flush data
	ConverterFlagsFlush ConverterFlags = 0b10
)

func marshalConverterFlags(p uintptr) (interface{}, error) {
	return ConverterFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCallFlags: flags used in g_dbus_connection_call() and similar APIs.
type DBusCallFlags int

const (
	// DBusCallFlagsNone: no flags set.
	DBusCallFlagsNone DBusCallFlags = 0b0
	// DBusCallFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this method invocation.
	DBusCallFlagsNoAutoStart DBusCallFlags = 0b1
	// DBusCallFlagsAllowInteractiveAuthorization: the caller is prepared to
	// wait for interactive authorization. Since 2.46.
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 0b10
)

func marshalDBusCallFlags(p uintptr) (interface{}, error) {
	return DBusCallFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCapabilityFlags: capabilities negotiated with the remote peer.
type DBusCapabilityFlags int

const (
	// DBusCapabilityFlagsNone: no flags set.
	DBusCapabilityFlagsNone DBusCapabilityFlags = 0b0
	// DBusCapabilityFlagsUnixFdPassing: the connection supports exchanging UNIX
	// file descriptors with the remote peer.
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 0b1
)

func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
	return DBusCapabilityFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusConnectionFlags: flags used when creating a new BusConnection.
type DBusConnectionFlags int

const (
	// DBusConnectionFlagsNone: no flags set.
	DBusConnectionFlagsNone DBusConnectionFlags = 0b0
	// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
	DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 0b1
	// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
	DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 0b10
	// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 0b100
	// DBusConnectionFlagsMessageBusConnection: pass this flag if connecting to
	// a peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
	DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 0b1000
	// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
	DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 0b10000
)

func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
	return DBusConnectionFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusInterfaceSkeletonFlags: flags describing the behavior of a
// BusInterfaceSkeleton instance.
type DBusInterfaceSkeletonFlags int

const (
	// DBusInterfaceSkeletonFlagsNone: no flags set.
	DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0b0
	// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 0b1
)

func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
	return DBusInterfaceSkeletonFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageFlags: message flags used in BusMessage.
type DBusMessageFlags int

const (
	// DBusMessageFlagsNone: no flags set.
	DBusMessageFlagsNone DBusMessageFlags = 0b0
	// DBusMessageFlagsNoReplyExpected: a reply is not expected.
	DBusMessageFlagsNoReplyExpected DBusMessageFlags = 0b1
	// DBusMessageFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this message.
	DBusMessageFlagsNoAutoStart DBusMessageFlags = 0b10
	// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 0b100
)

func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
	return DBusMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusObjectManagerClientFlags: flags used when constructing a
// BusObjectManagerClient.
type DBusObjectManagerClientFlags int

const (
	// DBusObjectManagerClientFlagsNone: no flags set.
	DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0b0
	// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager is
	// for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 0b1
)

func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
	return DBusObjectManagerClientFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusPropertyInfoFlags: flags describing the access control of a D-Bus
// property.
type DBusPropertyInfoFlags int

const (
	// DBusPropertyInfoFlagsNone: no flags set.
	DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0b0
	// DBusPropertyInfoFlagsReadable: property is readable.
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 0b1
	// DBusPropertyInfoFlagsWritable: property is writable.
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 0b10
)

func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
	return DBusPropertyInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusProxyFlags: flags used when constructing an instance of a BusProxy
// derived class.
type DBusProxyFlags int

const (
	// DBusProxyFlagsNone: no flags set.
	DBusProxyFlagsNone DBusProxyFlags = 0b0
	// DBusProxyFlagsDoNotLoadProperties: don't load properties.
	DBusProxyFlagsDoNotLoadProperties DBusProxyFlags = 0b1
	// DBusProxyFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
	DBusProxyFlagsDoNotConnectSignals DBusProxyFlags = 0b10
	// DBusProxyFlagsDoNotAutoStart: if the proxy is for a well-known name, do
	// not ask the bus to launch an owner during proxy initialization or a
	// method call. This flag is only meaningful in proxies for well-known
	// names.
	DBusProxyFlagsDoNotAutoStart DBusProxyFlags = 0b100
	// DBusProxyFlagsGetInvalidatedProperties: if set, the property value for
	// any __invalidated property__ will be (asynchronously) retrieved upon
	// receiving the
	// [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
	DBusProxyFlagsGetInvalidatedProperties DBusProxyFlags = 0b1000
	// DBusProxyFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call. This
	// flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
	DBusProxyFlagsDoNotAutoStartAtConstruction DBusProxyFlags = 0b10000
)

func marshalDBusProxyFlags(p uintptr) (interface{}, error) {
	return DBusProxyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSendMessageFlags: flags used when sending BusMessages on a BusConnection.
type DBusSendMessageFlags int

const (
	// DBusSendMessageFlagsNone: no flags set.
	DBusSendMessageFlagsNone DBusSendMessageFlags = 0b0
	// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 0b1
)

func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
	return DBusSendMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusServerFlags: flags used when creating a BusServer.
type DBusServerFlags int

const (
	// DBusServerFlagsNone: no flags set.
	DBusServerFlagsNone DBusServerFlags = 0b0
	// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
	DBusServerFlagsRunInThread DBusServerFlags = 0b1
	// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 0b10
)

func marshalDBusServerFlags(p uintptr) (interface{}, error) {
	return DBusServerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSignalFlags: flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
type DBusSignalFlags int

const (
	// DBusSignalFlagsNone: no flags set.
	DBusSignalFlagsNone DBusSignalFlags = 0b0
	// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
	DBusSignalFlagsNoMatchRule DBusSignalFlags = 0b1
	// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 0b10
	// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
	DBusSignalFlagsMatchArg0Path DBusSignalFlags = 0b100
)

func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
	return DBusSignalFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSubtreeFlags: flags passed to g_dbus_connection_register_subtree().
type DBusSubtreeFlags int

const (
	// DBusSubtreeFlagsNone: no flags set.
	DBusSubtreeFlagsNone DBusSubtreeFlags = 0b0
	// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 0b1
)

func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
	return DBusSubtreeFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartFlags: flags used when starting a drive.
type DriveStartFlags int

const (
	// DriveStartFlagsNone: no flags set.
	DriveStartFlagsNone DriveStartFlags = 0b0
)

func marshalDriveStartFlags(p uintptr) (interface{}, error) {
	return DriveStartFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeInfoFlags: flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags int

const (
	// FileAttributeInfoFlagsNone: no flags set.
	FileAttributeInfoFlagsNone FileAttributeInfoFlags = 0b0
	// FileAttributeInfoFlagsCopyWithFile: copy the attribute values when the
	// file is copied.
	FileAttributeInfoFlagsCopyWithFile FileAttributeInfoFlags = 0b1
	// FileAttributeInfoFlagsCopyWhenMoved: copy the attribute values when the
	// file is moved.
	FileAttributeInfoFlagsCopyWhenMoved FileAttributeInfoFlags = 0b10
)

func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
	return FileAttributeInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCopyFlags: flags used when copying or moving files.
type FileCopyFlags int

const (
	// FileCopyFlagsNone: no flags set.
	FileCopyFlagsNone FileCopyFlags = 0b0
	// FileCopyFlagsOverwrite: overwrite any existing files
	FileCopyFlagsOverwrite FileCopyFlags = 0b1
	// FileCopyFlagsBackup: make a backup of any existing files.
	FileCopyFlagsBackup FileCopyFlags = 0b10
	// FileCopyFlagsNofollowSymlinks: don't follow symlinks.
	FileCopyFlagsNofollowSymlinks FileCopyFlags = 0b100
	// FileCopyFlagsAllMetadata: copy all file metadata instead of just default
	// set used for copy (see Info).
	FileCopyFlagsAllMetadata FileCopyFlags = 0b1000
	// FileCopyFlagsNoFallbackForMove: don't use copy and delete fallback if
	// native move not supported.
	FileCopyFlagsNoFallbackForMove FileCopyFlags = 0b10000
	// FileCopyFlagsTargetDefaultPerms: leaves target file with default perms,
	// instead of setting the source file perms.
	FileCopyFlagsTargetDefaultPerms FileCopyFlags = 0b100000
)

func marshalFileCopyFlags(p uintptr) (interface{}, error) {
	return FileCopyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCreateFlags: flags used when an operation may create a file.
type FileCreateFlags int

const (
	// FileCreateFlagsNone: no flags set.
	FileCreateFlagsNone FileCreateFlags = 0b0
	// FileCreateFlagsPrivate: create a file that can only be accessed by the
	// current user.
	FileCreateFlagsPrivate FileCreateFlags = 0b1
	// FileCreateFlagsReplaceDestination: replace the destination as if it
	// didn't exist before. Don't try to keep any old permissions, replace
	// instead of following links. This is generally useful if you're doing a
	// "copy over" rather than a "save new version of" replace operation. You
	// can think of it as "unlink destination" before writing to it, although
	// the implementation may not be exactly like that. This flag can only be
	// used with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20
	FileCreateFlagsReplaceDestination FileCreateFlags = 0b10
)

func marshalFileCreateFlags(p uintptr) (interface{}, error) {
	return FileCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMeasureFlags: flags that can be used with g_file_measure_disk_usage().
type FileMeasureFlags int

const (
	// FileMeasureFlagsNone: no flags set.
	FileMeasureFlagsNone FileMeasureFlags = 0b0
	// FileMeasureFlagsReportAnyError: report any error encountered while
	// traversing the directory tree. Normally errors are only reported for the
	// toplevel file.
	FileMeasureFlagsReportAnyError FileMeasureFlags = 0b10
	// FileMeasureFlagsApparentSize: tally usage based on apparent file sizes.
	// Normally, the block-size is used, if available, as this is a more
	// accurate representation of disk space used. Compare with `du
	// --apparent-size`.
	FileMeasureFlagsApparentSize FileMeasureFlags = 0b100
	// FileMeasureFlagsNoXdev: do not cross mount point boundaries. Compare with
	// `du -x`.
	FileMeasureFlagsNoXdev FileMeasureFlags = 0b1000
)

func marshalFileMeasureFlags(p uintptr) (interface{}, error) {
	return FileMeasureFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorFlags: flags used to set what a Monitor will watch for.
type FileMonitorFlags int

const (
	// FileMonitorFlagsNone: no flags set.
	FileMonitorFlagsNone FileMonitorFlags = 0b0
	// FileMonitorFlagsWatchMounts: watch for mount events.
	FileMonitorFlagsWatchMounts FileMonitorFlags = 0b1
	// FileMonitorFlagsSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorFlagsSendMoved FileMonitorFlags = 0b10
	// FileMonitorFlagsWatchHardLinks: watch for changes to the file made via
	// another hard link. Since 2.36.
	FileMonitorFlagsWatchHardLinks FileMonitorFlags = 0b100
	// FileMonitorFlagsWatchMoves: watch for rename operations on a monitored
	// directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
	FileMonitorFlagsWatchMoves FileMonitorFlags = 0b1000
)

func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
	return FileMonitorFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileQueryInfoFlags: flags used when querying a Info.
type FileQueryInfoFlags int

const (
	// FileQueryInfoFlagsNone: no flags set.
	FileQueryInfoFlagsNone FileQueryInfoFlags = 0b0
	// FileQueryInfoFlagsNofollowSymlinks: don't follow symlinks.
	FileQueryInfoFlagsNofollowSymlinks FileQueryInfoFlags = 0b1
)

func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
	return FileQueryInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOStreamSpliceFlags: GIOStreamSpliceFlags determine how streams should be
// spliced.
type IOStreamSpliceFlags int

const (
	// IOStreamSpliceFlagsNone: do not close either stream.
	IOStreamSpliceFlagsNone IOStreamSpliceFlags = 0b0
	// IOStreamSpliceFlagsCloseStream1: close the first stream after the splice.
	IOStreamSpliceFlagsCloseStream1 IOStreamSpliceFlags = 0b1
	// IOStreamSpliceFlagsCloseStream2: close the second stream after the
	// splice.
	IOStreamSpliceFlagsCloseStream2 IOStreamSpliceFlags = 0b10
	// IOStreamSpliceFlagsWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
	IOStreamSpliceFlagsWaitForBoth IOStreamSpliceFlags = 0b100
)

func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
	return IOStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountMountFlags: flags used when mounting a mount.
type MountMountFlags int

const (
	// MountMountFlagsNone: no flags set.
	MountMountFlagsNone MountMountFlags = 0b0
)

func marshalMountMountFlags(p uintptr) (interface{}, error) {
	return MountMountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountUnmountFlags: flags used when an unmounting a mount.
type MountUnmountFlags int

const (
	// MountUnmountFlagsNone: no flags set.
	MountUnmountFlagsNone MountUnmountFlags = 0b0
	// MountUnmountFlagsForce: unmount even if there are outstanding file
	// operations on the mount.
	MountUnmountFlagsForce MountUnmountFlags = 0b1
)

func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
	return MountUnmountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// OutputStreamSpliceFlags: GOutputStreamSpliceFlags determine how streams
// should be spliced.
type OutputStreamSpliceFlags int

const (
	// OutputStreamSpliceFlagsNone: do not close either stream.
	OutputStreamSpliceFlagsNone OutputStreamSpliceFlags = 0b0
	// OutputStreamSpliceFlagsCloseSource: close the source stream after the
	// splice.
	OutputStreamSpliceFlagsCloseSource OutputStreamSpliceFlags = 0b1
	// OutputStreamSpliceFlagsCloseTarget: close the target stream after the
	// splice.
	OutputStreamSpliceFlagsCloseTarget OutputStreamSpliceFlags = 0b10
)

func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
	return OutputStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverNameLookupFlags: flags to modify lookup behavior.
type ResolverNameLookupFlags int

const (
	// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name())
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0b0
	// ResolverNameLookupFlagsIpv4Only: only resolve ipv4 addresses
	ResolverNameLookupFlagsIpv4Only ResolverNameLookupFlags = 0b1
	// ResolverNameLookupFlagsIpv6Only: only resolve ipv6 addresses
	ResolverNameLookupFlagsIpv6Only ResolverNameLookupFlags = 0b10
)

func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
	return ResolverNameLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceFlags: GResourceFlags give information about a particular file inside
// a resource bundle.
type ResourceFlags int

const (
	// ResourceFlagsNone: no flags set.
	ResourceFlagsNone ResourceFlags = 0b0
	// ResourceFlagsCompressed: the file is compressed.
	ResourceFlagsCompressed ResourceFlags = 0b1
)

func marshalResourceFlags(p uintptr) (interface{}, error) {
	return ResourceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceLookupFlags: GResourceLookupFlags determine how resource path lookups
// are handled.
type ResourceLookupFlags int

const (
	// ResourceLookupFlagsNone: no flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0b0
)

func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
	return ResourceLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SettingsBindFlags: flags used when creating a binding. These flags determine
// in which direction the binding works. The default is to synchronize in both
// directions.
type SettingsBindFlags int

const (
	// SettingsBindFlagsDefault: equivalent to
	// `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
	SettingsBindFlagsDefault SettingsBindFlags = 0b0
	// SettingsBindFlagsGet: update the #GObject property when the setting
	// changes. It is an error to use this flag if the property is not writable.
	SettingsBindFlagsGet SettingsBindFlags = 0b1
	// SettingsBindFlagsSet: update the setting when the #GObject property
	// changes. It is an error to use this flag if the property is not readable.
	SettingsBindFlagsSet SettingsBindFlags = 0b10
	// SettingsBindFlagsNoSensitivity: do not try to bind a "sensitivity"
	// property to the writability of the setting
	SettingsBindFlagsNoSensitivity SettingsBindFlags = 0b100
	// SettingsBindFlagsGetNoChanges: when set in addition to SETTINGS_BIND_GET,
	// set the #GObject property value initially from the setting, but do not
	// listen for changes of the setting
	SettingsBindFlagsGetNoChanges SettingsBindFlags = 0b1000
	// SettingsBindFlagsInvertBoolean: when passed to g_settings_bind(), uses a
	// pair of mapping functions that invert the boolean value when mapping
	// between the setting and the property. The setting and property must both
	// be booleans. You cannot pass this flag to g_settings_bind_with_mapping().
	SettingsBindFlagsInvertBoolean SettingsBindFlags = 0b10000
)

func marshalSettingsBindFlags(p uintptr) (interface{}, error) {
	return SettingsBindFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketMsgFlags: flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
type SocketMsgFlags int

const (
	// SocketMsgFlagsNone: no flags.
	SocketMsgFlagsNone SocketMsgFlags = 0b0
	// SocketMsgFlagsOob: request to send/receive out of band data.
	SocketMsgFlagsOob SocketMsgFlags = 0b1
	// SocketMsgFlagsPeek: read data from the socket without removing it from
	// the queue.
	SocketMsgFlagsPeek SocketMsgFlags = 0b10
	// SocketMsgFlagsDontroute: don't use a gateway to send out the packet, only
	// send to hosts on directly connected networks.
	SocketMsgFlagsDontroute SocketMsgFlags = 0b100
)

func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
	return SocketMsgFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubprocessFlags: flags to define the behaviour of a #GSubprocess.
//
// Note that the default for stdin is to redirect from `/dev/null`. For stdout
// and stderr the default are for them to inherit the corresponding descriptor
// from the calling process.
//
// Note that it is a programmer error to mix 'incompatible' flags. For example,
// you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
type SubprocessFlags int

const (
	// SubprocessFlagsNone: no flags.
	SubprocessFlagsNone SubprocessFlags = 0b0
	// SubprocessFlagsStdinPipe: create a pipe for the stdin of the spawned
	// process that can be accessed with g_subprocess_get_stdin_pipe().
	SubprocessFlagsStdinPipe SubprocessFlags = 0b1
	// SubprocessFlagsStdinInherit: stdin is inherited from the calling process.
	SubprocessFlagsStdinInherit SubprocessFlags = 0b10
	// SubprocessFlagsStdoutPipe: create a pipe for the stdout of the spawned
	// process that can be accessed with g_subprocess_get_stdout_pipe().
	SubprocessFlagsStdoutPipe SubprocessFlags = 0b100
	// SubprocessFlagsStdoutSilence: silence the stdout of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStdoutSilence SubprocessFlags = 0b1000
	// SubprocessFlagsStderrPipe: create a pipe for the stderr of the spawned
	// process that can be accessed with g_subprocess_get_stderr_pipe().
	SubprocessFlagsStderrPipe SubprocessFlags = 0b10000
	// SubprocessFlagsStderrSilence: silence the stderr of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStderrSilence SubprocessFlags = 0b100000
	// SubprocessFlagsStderrMerge: merge the stderr of the spawned process with
	// whatever the stdout happens to be. This is a good way of directing both
	// streams to a common log file, for example.
	SubprocessFlagsStderrMerge SubprocessFlags = 0b1000000
	// SubprocessFlagsInheritFds: spawned processes will inherit the file
	// descriptors of their parent, unless those descriptors have been
	// explicitly marked as close-on-exec. This flag has no effect over the
	// "standard" file descriptors (stdin, stdout, stderr).
	SubprocessFlagsInheritFds SubprocessFlags = 0b10000000
)

func marshalSubprocessFlags(p uintptr) (interface{}, error) {
	return SubprocessFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TestDBusFlags: flags to define future DBus behaviour.
type TestDBusFlags int

const (
	// TestDBusFlagsNone: no flags.
	TestDBusFlagsNone TestDBusFlags = 0b0
)

func marshalTestDBusFlags(p uintptr) (interface{}, error) {
	return TestDBusFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsCertificateFlags: a set of flags describing TLS certification validation.
// This can be used to set which validation steps to perform (eg, with
// g_tls_client_connection_set_validation_flags()), or to describe why a
// particular certificate was rejected (eg, in Connection::accept-certificate).
type TlsCertificateFlags int

const (
	// TlsCertificateFlagsUnknownCa: the signing certificate authority is not
	// known.
	TlsCertificateFlagsUnknownCa TlsCertificateFlags = 0b1
	// TlsCertificateFlagsBadIdentity: the certificate does not match the
	// expected identity of the site that it was retrieved from.
	TlsCertificateFlagsBadIdentity TlsCertificateFlags = 0b10
	// TlsCertificateFlagsNotActivated: the certificate's activation time is
	// still in the future
	TlsCertificateFlagsNotActivated TlsCertificateFlags = 0b100
	// TlsCertificateFlagsExpired: the certificate has expired
	TlsCertificateFlagsExpired TlsCertificateFlags = 0b1000
	// TlsCertificateFlagsRevoked: the certificate has been revoked according to
	// the Connection's certificate revocation list.
	TlsCertificateFlagsRevoked TlsCertificateFlags = 0b10000
	// TlsCertificateFlagsInsecure: the certificate's algorithm is considered
	// insecure.
	TlsCertificateFlagsInsecure TlsCertificateFlags = 0b100000
	// TlsCertificateFlagsGenericError: some other error occurred validating the
	// certificate
	TlsCertificateFlagsGenericError TlsCertificateFlags = 0b1000000
	// TlsCertificateFlagsValidateAll: the combination of all of the above flags
	TlsCertificateFlagsValidateAll TlsCertificateFlags = 0b1111111
)

func marshalTlsCertificateFlags(p uintptr) (interface{}, error) {
	return TlsCertificateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsDatabaseVerifyFlags: flags for g_tls_database_verify_chain().
type TlsDatabaseVerifyFlags int

const (
	// TlsDatabaseVerifyFlagsNone: no verification flags
	TlsDatabaseVerifyFlagsNone TlsDatabaseVerifyFlags = 0b0
)

func marshalTlsDatabaseVerifyFlags(p uintptr) (interface{}, error) {
	return TlsDatabaseVerifyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsPasswordFlags: various flags for the password.
type TlsPasswordFlags int

const (
	// TlsPasswordFlagsNone: no flags
	TlsPasswordFlagsNone TlsPasswordFlags = 0b0
	// TlsPasswordFlagsRetry: the password was wrong, and the user should retry.
	TlsPasswordFlagsRetry TlsPasswordFlags = 0b10
	// TlsPasswordFlagsManyTries: hint to the user that the password has been
	// wrong many times, and the user may not have many chances left.
	TlsPasswordFlagsManyTries TlsPasswordFlags = 0b100
	// TlsPasswordFlagsFinalTry: hint to the user that this is the last try to
	// get this password right.
	TlsPasswordFlagsFinalTry TlsPasswordFlags = 0b1000
)

func marshalTlsPasswordFlags(p uintptr) (interface{}, error) {
	return TlsPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ActionNameIsValid: checks if @action_name is valid.
//
// @action_name is valid if it consists only of alphanumeric characters, plus
// '-' and '.'. The empty string is not a valid action name.
//
// It is an error to call this function with a non-utf8 @action_name.
// @action_name must not be nil.
func ActionNameIsValid(actionName string) bool

// ActionParseDetailedName: parses a detailed action name into its separate name
// and target components.
//
// Detailed action names can have three formats.
//
// The first format is used to represent an action name with no target value and
// consists of just an action name containing no whitespace nor the characters
// ':', '(' or ')'. For example: "app.action".
//
// The second format is used to represent an action with a target value that is
// a non-empty string consisting only of alphanumerics, plus '-' and '.'. In
// that case, the action name and target value are separated by a double colon
// ("::"). For example: "app.action::target".
//
// The third format is used to represent an action with any type of target
// value, including strings. The target value follows the action name,
// surrounded in parens. For example: "app.action(42)". The target value is
// parsed using g_variant_parse(). If a tuple-typed value is desired, it must be
// specified in the same way, resulting in two sets of parens, for example:
// "app.action((1,2,3))". A string target can be specified this way as well:
// "app.action('target')". For strings, this third format must be used if *
// target value is empty or contains characters other than alphanumerics, '-'
// and '.'.
func ActionParseDetailedName(detailedName string) (string, *glib.Variant, bool)

// ActionPrintDetailedName: formats a detailed action name from @action_name and
// @target_value.
//
// It is an error to call this function with an invalid action name.
//
// This function is the opposite of g_action_parse_detailed_name(). It will
// produce a string that can be parsed back to the @action_name and
// @target_value by that function.
//
// See that function for the types of strings that will be printed by this
// function.
func ActionPrintDetailedName(actionName string, targetValue *glib.Variant) string

// AppInfoCreateFromCommandline: creates a new Info from the given information.
//
// Note that for @commandline, the quoting rules of the Exec key of the
// [freedesktop.org Desktop Entry
// Specification](http://freedesktop.org/Standards/desktop-entry-spec) are
// applied. For example, if the @commandline contains percent-encoded URIs, the
// percent-character must be doubled in order to prevent it from being swallowed
// by Exec key unquoting. See the specification for exact quoting rules.
func AppInfoCreateFromCommandline(commandline string, applicationName string, flags AppInfoCreateFlags) AppInfo

// AppInfoGetAll: gets a list of all of the applications currently registered on
// this system.
//
// For desktop files, this includes applications that have `NoDisplay=true` set
// or are excluded from display by means of `OnlyShowIn` or `NotShowIn`. See
// g_app_info_should_show(). The returned list does not include applications
// which have the `Hidden` key set.
func AppInfoGetAll() *glib.List

// AppInfoGetAllForType: gets a list of all Infos for a given content type,
// including the recommended and fallback Infos. See
// g_app_info_get_recommended_for_type() and g_app_info_get_fallback_for_type().
func AppInfoGetAllForType(contentType string) *glib.List

// AppInfoGetDefaultForType: gets the default Info for a given content type.
func AppInfoGetDefaultForType(contentType string, mustSupportUris bool) AppInfo

// AppInfoGetDefaultForURIScheme: gets the default application for handling URIs
// with the given URI scheme. A URI scheme is the initial part of the URI, up to
// but not including the ':', e.g. "http", "ftp" or "sip".
func AppInfoGetDefaultForURIScheme(uriScheme string) AppInfo

// AppInfoGetFallbackForType: gets a list of fallback Infos for a given content
// type, i.e. those applications which claim to support the given content type
// by MIME type subclassing and not directly.
func AppInfoGetFallbackForType(contentType string) *glib.List

// AppInfoGetRecommendedForType: gets a list of recommended Infos for a given
// content type, i.e. those applications which claim to support the given
// content type exactly, and not by MIME type subclassing. Note that the first
// application of the list is the last used one, i.e. the last one for which
// g_app_info_set_as_last_used_for_type() has been called.
func AppInfoGetRecommendedForType(contentType string) *glib.List

// AppInfoLaunchDefaultForURI: utility function that launches the default
// application registered to handle the specified uri. Synchronous I/O is done
// on the uri to detect the type of the file if required.
//
// The D-Busactivated applications don't have to be started if your application
// terminates too soon after this function. To prevent this, use
// g_app_info_launch_default_for_uri_async() instead.
func AppInfoLaunchDefaultForURI(uri string, context *AppLaunchContext) bool

// AppInfoLaunchDefaultForURIAsync: async version of
// g_app_info_launch_default_for_uri().
//
// This version is useful if you are interested in receiving error information
// in the case where the application is sandboxed and the portal may present an
// application chooser dialog to the user.
//
// This is also useful if you want to be sure that the D-Busactivated
// applications are really started before termination and if you are interested
// in receiving error information from their activation.
func AppInfoLaunchDefaultForURIAsync(uri string, context *AppLaunchContext, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)

// AppInfoLaunchDefaultForURIFinish: finishes an asynchronous
// launch-default-for-uri operation.
func AppInfoLaunchDefaultForURIFinish(result AsyncResult) bool

// AppInfoResetTypeAssociations: removes all changes to the type associations
// done by g_app_info_set_as_default_for_type(),
// g_app_info_set_as_default_for_extension(), g_app_info_add_supports_type() or
// g_app_info_remove_supports_type().
func AppInfoResetTypeAssociations(contentType string)

// BusGet: asynchronously connects to the message bus specified by @bus_type.
//
// When the operation is finished, @callback will be invoked. You can then call
// g_bus_get_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See g_bus_get_sync() for the
// synchronous version.
func BusGet(busType BusType, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)

// BusGetFinish: finishes an operation started with g_bus_get().
//
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
func BusGetFinish(res AsyncResult) *DBusConnection

// BusGetSync: synchronously connects to the message bus specified by @bus_type.
// Note that the returned object may shared with other callers, e.g. if two
// separate parts of a process calls this function with the same @bus_type, they
// will share the same object.
//
// This is a synchronous failable function. See g_bus_get() and
// g_bus_get_finish() for the asynchronous version.
//
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
func BusGetSync(busType BusType, cancellable *Cancellable) *DBusConnection

// BusOwnName: starts acquiring @name on the bus specified by @bus_type and
// calls @name_acquired_handler and @name_lost_handler when the name is acquired
// respectively lost. Callbacks will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this function from.
//
// You are guaranteed that one of the @name_acquired_handler and
// @name_lost_handler callbacks will be invoked after calling this function -
// there are three possible cases:
//
// - @name_lost_handler with a nil connection (if a connection to the bus can't
// be made).
//
// - @bus_acquired_handler then @name_lost_handler (if the name can't be
// obtained)
//
// - @bus_acquired_handler then @name_acquired_handler (if the name was
// obtained).
//
// When you are done owning the name, just call g_bus_unown_name() with the
// owner id this function returns.
//
// If the name is acquired or lost (for example another application could
// acquire the name if you allow replacement or the application currently owning
// the name exits), the handlers are also invoked. If the BusConnection that is
// used for attempting to own the name closes, then @name_lost_handler is
// invoked since it is no longer possible for other processes to access the
// process.
//
// You cannot use g_bus_own_name() several times for the same name (unless
// interleaved with calls to g_bus_unown_name()) - only the first call will
// work.
//
// Another guarantee is that invocations of @name_acquired_handler and
// @name_lost_handler are guaranteed to alternate; that is, if
// @name_acquired_handler is invoked then you are guaranteed that the next time
// one of the handlers is invoked, it will be @name_lost_handler. The reverse is
// also true.
//
// If you plan on exporting objects (using e.g.
// g_dbus_connection_register_object()), note that it is generally too late to
// export the objects in @name_acquired_handler. Instead, you can do this in
// @bus_acquired_handler since you are guaranteed that this will run before
// @name is requested from the bus.
//
// This behavior makes it very simple to write applications that wants to [own
// names][gdbus-owning-names] and export objects. Simply register objects to be
// exported in @bus_acquired_handler and unregister the objects (if any) in
// @name_lost_handler.
func BusOwnName(busType BusType, name string, flags BusNameOwnerFlags, busAcquiredHandler BusAcquiredCallback, nameAcquiredHandler BusNameAcquiredCallback, nameLostHandler BusNameLostCallback, userData unsafe.Pointer, userDataFreeFunc unsafe.Pointer) uint

// BusOwnNameOnConnection: like g_bus_own_name() but takes a BusConnection
// instead of a Type.
func BusOwnNameOnConnection(connection *DBusConnection, name string, flags BusNameOwnerFlags, nameAcquiredHandler BusNameAcquiredCallback, nameLostHandler BusNameLostCallback, userData unsafe.Pointer, userDataFreeFunc unsafe.Pointer) uint

// BusOwnNameOnConnectionWithClosures: version of g_bus_own_name_on_connection()
// using closures instead of callbacks for easier binding in other languages.
func BusOwnNameOnConnectionWithClosures(connection *DBusConnection, name string, flags BusNameOwnerFlags, nameAcquiredClosure *externglib.Closure, nameLostClosure *externglib.Closure) uint

// BusOwnNameWithClosures: version of g_bus_own_name() using closures instead of
// callbacks for easier binding in other languages.
func BusOwnNameWithClosures(busType BusType, name string, flags BusNameOwnerFlags, busAcquiredClosure *externglib.Closure, nameAcquiredClosure *externglib.Closure, nameLostClosure *externglib.Closure) uint

// BusUnownName: stops owning a name.
//
// Note that there may still be D-Bus traffic to process (relating to owning and
// unowning the name) in the current thread-default Context after this function
// has returned. You should continue to iterate the Context until the Notify
// function passed to g_bus_own_name() is called, in order to avoid memory leaks
// through callbacks queued on the Context after its stopped being iterated.
func BusUnownName(ownerID uint)

// BusUnwatchName: stops watching a name.
//
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_bus_watch_name() is called, in order to avoid
// memory leaks through callbacks queued on the Context after its stopped being
// iterated.
func BusUnwatchName(watcherID uint)

// BusWatchName: starts watching @name on the bus specified by @bus_type and
// calls @name_appeared_handler and @name_vanished_handler when the name is
// known to have an owner respectively known to lose its owner. Callbacks will
// be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this function from.
//
// You are guaranteed that one of the handlers will be invoked after calling
// this function. When you are done watching the name, just call
// g_bus_unwatch_name() with the watcher id this function returns.
//
// If the name vanishes or appears (for example the application owning the name
// could restart), the handlers are also invoked. If the BusConnection that is
// used for watching the name disconnects, then @name_vanished_handler is
// invoked since it is no longer possible to access the name.
//
// Another guarantee is that invocations of @name_appeared_handler and
// @name_vanished_handler are guaranteed to alternate; that is, if
// @name_appeared_handler is invoked then you are guaranteed that the next time
// one of the handlers is invoked, it will be @name_vanished_handler. The
// reverse is also true.
//
// This behavior makes it very simple to write applications that want to take
// action when a certain [name exists][gdbus-watching-names]. Basically, the
// application should create object proxies in @name_appeared_handler and
// destroy them again (if any) in @name_vanished_handler.
func BusWatchName(busType BusType, name string, flags BusNameWatcherFlags, nameAppearedHandler BusNameAppearedCallback, nameVanishedHandler BusNameVanishedCallback, userData unsafe.Pointer, userDataFreeFunc unsafe.Pointer) uint

// BusWatchNameOnConnection: like g_bus_watch_name() but takes a BusConnection
// instead of a Type.
func BusWatchNameOnConnection(connection *DBusConnection, name string, flags BusNameWatcherFlags, nameAppearedHandler BusNameAppearedCallback, nameVanishedHandler BusNameVanishedCallback, userData unsafe.Pointer, userDataFreeFunc unsafe.Pointer) uint

// BusWatchNameOnConnectionWithClosures: version of
// g_bus_watch_name_on_connection() using closures instead of callbacks for
// easier binding in other languages.
func BusWatchNameOnConnectionWithClosures(connection *DBusConnection, name string, flags BusNameWatcherFlags, nameAppearedClosure *externglib.Closure, nameVanishedClosure *externglib.Closure) uint

// BusWatchNameWithClosures: version of g_bus_watch_name() using closures
// instead of callbacks for easier binding in other languages.
func BusWatchNameWithClosures(busType BusType, name string, flags BusNameWatcherFlags, nameAppearedClosure *externglib.Closure, nameVanishedClosure *externglib.Closure) uint

// ContentTypeCanBeExecutable: checks if a content type can be executable. Note
// that for instance things like text files can be executables (i.e. scripts and
// batch files).
func ContentTypeCanBeExecutable(_type string) bool

// ContentTypeEquals: compares two content types for equality.
func ContentTypeEquals(type1 string, type2 string) bool

// ContentTypeFromMimeType: tries to find a content type based on the mime type
// name.
func ContentTypeFromMimeType(mimeType string) string

// ContentTypeGetDescription: gets the human readable description of the content
// type.
func ContentTypeGetDescription(_type string) string

// ContentTypeGetGenericIconName: gets the generic icon name for a content type.
//
// See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on the generic icon name.
func ContentTypeGetGenericIconName(_type string) string

// ContentTypeGetIcon: gets the icon for a content type.
func ContentTypeGetIcon(_type string) Icon

// ContentTypeGetMimeDirs: get the list of directories which MIME data is loaded
// from. See g_content_type_set_mime_dirs() for details.
func ContentTypeGetMimeDirs() []string

// ContentTypeGetMimeType: gets the mime type for the content type, if one is
// registered.
func ContentTypeGetMimeType(_type string) string

// ContentTypeGetSymbolicIcon: gets the symbolic icon for a content type.
func ContentTypeGetSymbolicIcon(_type string) Icon

// ContentTypeGuess: guesses the content type based on example data. If the
// function is uncertain, @result_uncertain will be set to true. Either
// @filename or @data may be nil, in which case the guess will be based solely
// on the other argument.
func ContentTypeGuess(filename string, data []uint8, dataSize uint) (bool, string)

// ContentTypeGuessForTree: tries to guess the type of the tree with root @root,
// by looking at the files it contains. The result is an array of content types,
// with the best guess coming first.
//
// The types returned all have the form x-content/foo, e.g. x-content/audio-cdda
// (for audio CDs) or x-content/image-dcf (for a camera memory card). See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This function is useful in the implementation of
// g_mount_guess_content_type().
func ContentTypeGuessForTree(root File) []string

// ContentTypeIsA: determines if @type is a subset of @supertype.
func ContentTypeIsA(_type string, supertype string) bool

// ContentTypeIsMimeType: determines if @type is a subset of @mime_type.
// Convenience wrapper around g_content_type_is_a().
func ContentTypeIsMimeType(_type string, mimeType string) bool

// ContentTypeIsUnknown: checks if the content type is the generic "unknown"
// type. On UNIX this is the "application/octet-stream" mimetype, while on win32
// it is "*" and on OSX it is a dynamic type or octet-stream.
func ContentTypeIsUnknown(_type string) bool

// ContentTypeSetMimeDirs: set the list of directories used by GIO to load the
// MIME database. If @dirs is nil, the directories used are the default:
//
// - the `mime` subdirectory of the directory in `$XDG_DATA_HOME` - the `mime`
// subdirectory of every directory in `$XDG_DATA_DIRS`
//
// This function is intended to be used when writing tests that depend on
// information stored in the MIME database, in order to control the data.
//
// Typically, in case your tests use G_TEST_OPTION_ISOLATE_DIRS, but they depend
// on the systems MIME database, you should call this function with @dirs set
// to nil before calling g_test_init(), for instance:
//
//      // Load MIME data from the system
//      g_content_type_set_mime_dirs (NULL);
//      // Isolate the environment
//      g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
//
//      
//
//      return g_test_run ();
//
func ContentTypeSetMimeDirs(dirs []string)

// ContentTypesGetRegistered: gets a list of strings containing all the
// registered content types known to the system. The list and its data should be
// freed using `g_list_free_full (list, g_free)`.
func ContentTypesGetRegistered() *glib.List

// DbusAddressEscapeValue: escape @string so it can appear in a D-Bus address as
// the value part of a key-value pair.
//
// For instance, if @string is `/run/bus-for-:0`, this function would return
// `/run/bus-for-3A0`, which could be used in a D-Bus address like
// `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-3A0`.
func DbusAddressEscapeValue(string string) string

// DbusAddressGetForBusSync: synchronously looks up the D-Bus address for the
// well-known message bus instance specified by @bus_type. This may involve
// using various platform specific mechanisms.
//
// The returned address will be in the [D-Bus address
// format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DbusAddressGetForBusSync(busType BusType, cancellable *Cancellable) string

// DbusAddressGetStream: asynchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// [D-Bus address
// format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// When the operation is finished, @callback will be invoked. You can then call
// g_dbus_address_get_stream_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See
// g_dbus_address_get_stream_sync() for the synchronous version.
func DbusAddressGetStream(address string, cancellable *Cancellable, callback AsyncReadyCallback, userData unsafe.Pointer)

// DbusAddressGetStreamFinish: finishes an operation started with
// g_dbus_address_get_stream().
func DbusAddressGetStreamFinish(res AsyncResult) (string, *IOStream)

// DbusAddressGetStreamSync: synchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// [D-Bus address
// format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This is a synchronous failable function. See g_dbus_address_get_stream() for
// the asynchronous version.
func DbusAddressGetStreamSync(address string, cancellable *Cancellable) (string, *IOStream)

// DbusAnnotationInfoLookup: looks up the value of an annotation.
//
// The cost of this function is O(n) in number of annotations.
func DbusAnnotationInfoLookup(annotations []*DBusAnnotationInfo, name string) string

// DbusErrorEncodeGerror: creates a D-Bus error name to use for @error. If
// @error matches a registered error (cf. g_dbus_error_register_error()), the
// corresponding D-Bus error name will be returned.
//
// Otherwise the a name of the form
// `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE` will
// be used. This allows other GDBus applications to map the error on the wire
// back to a #GError using g_dbus_error_new_for_dbus_error().
//
// This function is typically only used in object mappings to put a #GError on
// the wire. Regular applications should not use it.
func DbusErrorEncodeGerror(error *glib.Error) string

// DbusErrorGetRemoteError: gets the D-Bus error name used for @error, if any.
//
// This function is guaranteed to return a D-Bus error name for all #GErrors
// returned from functions handling remote method calls (e.g.
// g_dbus_connection_call_finish()) unless g_dbus_error_strip_remote_error() has
// been used on @error.
func DbusErrorGetRemoteError(error *glib.Error) string

// DbusErrorIsRemoteError: checks if @error represents an error received via
// D-Bus from a remote peer. If so, use g_dbus_error_get_remote_error() to get
// the name of the error.
func DbusErrorIsRemoteError(error *glib.Error) bool

// DbusErrorNewForDbusError: creates a #GError based on the contents of
// @dbus_error_name and @dbus_error_message.
//
// Errors registered with g_dbus_error_register_error() will be looked up using
// @dbus_error_name and if a match is found, the error domain and code is used.
// Applications can use g_dbus_error_get_remote_error() to recover
// @dbus_error_name.
//
// If a match against a registered error is not found and the D-Bus error name
// is in a form as returned by g_dbus_error_encode_gerror() the error domain and
// code encoded in the name is used to create the #GError. Also,
// @dbus_error_name is added to the error message such that it can be recovered
// with g_dbus_error_get_remote_error().
//
// Otherwise, a #GError with the error code G_IO_ERROR_DBUS_ERROR in the
// IO_ERROR error domain is returned. Also, @dbus_error_name is added to the
// error message such that it can be recovered with
// g_dbus_error_get_remote_error().
//
// In all three cases, @dbus_error_name can always be recovered from the
// returned #GError using the g_dbus_error_get_remote_error() function (unless
// g_dbus_error_strip_remote_error() hasn't been used on the returned error).
//
// This function is typically only used in object mappings to prepare #GError
// instances for applications. Regular applications should not use it.
func DbusErrorNewForDbusError(dbusErrorName string, dbusErrorMessage string) *glib.Error

func DbusErrorQuark() glib.Quark

// DbusErrorRegisterError: creates an association to map between
// @dbus_error_name and #GErrors specified by @error_domain and @error_code.
//
// This is typically done in the routine that returns the #GQuark for an error
// domain.
func DbusErrorRegisterError(errorDomain glib.Quark, errorCode int, dbusErrorName string) bool

// DbusErrorRegisterErrorDomain: helper function for associating a #GError error
// domain with D-Bus error names.
func DbusErrorRegisterErrorDomain(errorDomainQuarkName string, quarkVolatile uint, entries []DBusErrorEntry, numEntries uint)

// DbusErrorStripRemoteError: looks for extra information in the error message
// used to recover the D-Bus error name and strips it if found. If stripped, the
// message field in @error will correspond exactly to what was received on the
// wire.
//
// This is typically used when presenting errors to the end user.
func DbusErrorStripRemoteError(error *glib.Error) bool

// DbusErrorUnregisterError: destroys an association previously set up with
// g_dbus_error_register_error().
func DbusErrorUnregisterError(errorDomain glib.Quark, errorCode int, dbusErrorName string) bool

// DbusGenerateGuid: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DbusGenerateGuid() string

// DbusGvalueToGvariant: converts a #GValue to a #GVariant of the type indicated
// by the @type parameter.
//
// The conversion is using the following rules:
//
// - TYPE_STRING: 's', 'o', 'g' or 'ay' - TYPE_STRV: 'as', 'ao' or 'aay' -
// TYPE_BOOLEAN: 'b' - TYPE_UCHAR: 'y' - TYPE_INT: 'i', 'n' - TYPE_UINT: 'u',
// 'q' - TYPE_INT64 'x' - TYPE_UINT64: 't' - TYPE_DOUBLE: 'd' - TYPE_VARIANT:
// Any Type
//
// This can fail if e.g. @gvalue is of type TYPE_STRING and @type is
// ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType (including
// e.g. TYPE_OBJECT and TYPE_BOXED derived-types) not in the table above.
//
// Note that if @gvalue is of type TYPE_VARIANT and its value is nil, the empty
// #GVariant instance (never nil) for @type is returned (e.g. 0 for scalar
// types, the empty string for string types, '/' for object path types, the
// empty array for any array type and so on).
//
// See the g_dbus_gvariant_to_gvalue() function for how to convert a #GVariant
// to a #GValue.
func DbusGvalueToGvariant(gvalue *externglib.Value, _type *glib.VariantType) *glib.Variant

// DbusGvariantToGvalue: converts a #GVariant to a #GValue. If @value is
// floating, it is consumed.
//
// The rules specified in the g_dbus_gvalue_to_gvariant() function are used -
// this function is essentially its reverse form. So, a #GVariant containing any
// basic or string array type will be converted to a #GValue containing a basic
// value or string array. Any other #GVariant (handle, variant, tuple, dict
// entry) will be converted to a #GValue containing that #GVariant.
//
// The conversion never fails - a valid #GValue is always returned in
// @out_gvalue.
func DbusGvariantToGvalue(value *glib.Variant) externglib.Value

// DbusIsAddress: checks if @string is a [D-Bus
// address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This doesn't check if @string is actually supported by BusServer or
// BusConnection - use g_dbus_is_supported_address() to do more checks.
func DbusIsAddress(string string) bool

// DbusIsGuid: checks if @string is a D-Bus GUID.
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DbusIsGuid(string string) bool

// DbusIsInterfaceName: checks if @string is a valid D-Bus interface name.
func DbusIsInterfaceName(string string) bool

// DbusIsMemberName: checks if @string is a valid D-Bus member (e.g. signal or
// method) name.
func DbusIsMemberName(string string) bool

// DbusIsName: checks if @string is a valid D-Bus bus name (either unique or
// well-known).
func DbusIsName(string string) bool

// DbusIsSupportedAddress: like g_dbus_is_address() but also checks if the
// library supports the transports in @string and that key/value pairs for each
// transport are valid. See the specification of the [D-Bus address
// format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DbusIsSupportedAddress(string string) bool

// DbusIsUniqueName: checks if @string is a valid D-Bus unique bus name.
func DbusIsUniqueName(string string) bool

// NewDtlsClientConnection: creates a new ClientConnection wrapping @base_socket
// which is assumed to communicate with the server identified by
// @server_identity.
func NewDtlsClientConnection(baseSocket DtlsClientConnection, serverIdentity SocketConnectable) DtlsClientConnection

// NewDtlsServerConnection: creates a new ServerConnection wrapping
// @base_socket.
func NewDtlsServerConnection(baseSocket DtlsClientConnection, certificate *TlsCertificate) DtlsClientConnection

// FileNewForCommandlineArg: creates a #GFile with the given argument from the
// command line. The value of @arg can be either a URI, an absolute path or a
// relative path resolved relative to the current working directory. This
// operation never fails, but the returned object might not support any I/O
// operation if @arg points to a malformed path.
//
// Note that on Windows, this function expects its argument to be in UTF-8 --
// not the system code page. This means that you should not use this function
// with string from argv as it is passed to main(). g_win32_get_command_line()
// will return a UTF-8 version of the commandline. #GApplication also uses UTF-8
// but g_application_command_line_create_file_for_arg() may be more useful for
// you there. It is also always possible to use this function with Context
// arguments of type G_OPTION_ARG_FILENAME.
func FileNewForCommandlineArg(arg string) File

// FileNewForCommandlineArgAndCwd: creates a #GFile with the given argument from
// the command line.
//
// This function is similar to g_file_new_for_commandline_arg() except that it
// allows for passing the current working directory as an argument instead of
// using the current working directory of the process.
//
// This is useful if the commandline argument was given in a context other than
// the invocation of the current process.
//
// See also g_application_command_line_create_file_for_arg().
func FileNewForCommandlineArgAndCwd(arg string, cwd string) File

// FileNewForPath: constructs a #GFile for a given path. This operation never
// fails, but the returned object might not support any I/O operation if @path
// is malformed.
func FileNewForPath(path string) File

// FileNewForURI: constructs a #GFile for a given URI. This operation never
// fails, but the returned object might not support any I/O operation if @uri is
// malformed or if the uri type is not supported.
func FileNewForURI(uri string) File

// FileNewTmp: opens a file in the preferred directory for temporary files (as
// returned by g_get_tmp_dir()) and returns a #GFile and IOStream pointing to
// it.
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, and containing no directory components. If it is nil,
// a default template is used.
//
// Unlike the other #GFile constructors, this will return nil if a temporary
// file could not be created.
func FileNewTmp(tmpl string) (*FileIOStream, File)

// FileParseName: constructs a #GFile with the given @parse_name (i.e. something
// given by g_file_get_parse_name()). This operation never fails, but the
// returned object might not support any I/O operation if the @parse_name cannot
// be parsed.
func FileParseName(parseName string) File

// IconDeserialize: deserializes a #GIcon previously serialized using
// g_icon_serialize().
func IconDeserialize(value *glib.Variant) Icon

// IconHash: gets a hash for an icon.
func IconHash(icon unsafe.Pointer) uint

// IconNewForString: generate a #GIcon instance from @str. This function can
// fail if @str is not valid - see g_icon_to_string() for discussion.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that each #GType is registered with the type system prior
// to calling g_icon_new_for_string().
func IconNewForString(str string) Icon

// IOErrorFromErrno: converts errno.h error codes into GIO error codes. The
// fallback value G_IO_ERROR_FAILED is returned for error codes not currently
// handled (but note that future GLib releases may return a more specific value
// instead).
//
// As errno is global and may be modified by intermediate function calls, you
// should save its value as soon as the call which sets it
func IOErrorFromErrno(errNo int) IOErrorEnum

// IOErrorQuark: gets the GIO Error Quark.
func IOErrorQuark() glib.Quark

// IOExtensionPointImplement: registers @type as extension for the extension
// point with name @extension_point_name.
//
// If @type has already been registered as an extension for this extension
// point, the existing OExtension object is returned.
func IOExtensionPointImplement(extensionPointName string, _type externglib.Type, extensionName string, priority int) *IOExtension

// IOExtensionPointLookup: looks up an existing extension point.
func IOExtensionPointLookup(name string) *IOExtensionPoint

// IOExtensionPointRegister: registers an extension point.
func IOExtensionPointRegister(name string) *IOExtensionPoint

// IOModulesLoadAllInDirectory: loads all the modules in the specified
// directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectory(dirname string) *glib.List

// IOModulesLoadAllInDirectoryWithScope: loads all the modules in the specified
// directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectoryWithScope(dirname string, scope *IOModuleScope) *glib.List

// IOModulesScanAllInDirectory: scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectory(dirname string)

// IOModulesScanAllInDirectoryWithScope: scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope)

// IOSchedulerCancelAllJobs: cancels all cancellable I/O jobs.
//
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
func IOSchedulerCancelAllJobs()

// IOSchedulerPushJob: schedules the I/O job to run in another thread.
//
// @notify will be called on @user_data after @job_func has returned, regardless
// whether the job was cancelled or has run to completion.
//
// If @cancellable is not nil, it can be used to cancel the I/O job by calling
// g_cancellable_cancel() or by calling g_io_scheduler_cancel_all_jobs().
func IOSchedulerPushJob(jobFunc IOSchedulerJobFunc, userData unsafe.Pointer, notify unsafe.Pointer, ioPriority int, cancellable *Cancellable)

// NewKeyfileSettingsBackend: creates a keyfile-backed Backend.
//
// The filename of the keyfile to use is given by @filename.
//
// All settings read to or written from the backend must fall under the path
// given in @root_path (which must start and end with a slash and not contain
// two consecutive slashes). @root_path may be "/".
//
// If @root_group is non-nil then it specifies the name of the keyfile group
// used for keys that are written directly below @root_path. For example, if
// @root_path is "/apps/example/" and @root_group is "toplevel", then settings
// the key "/apps/example/enabled" to a value of true will cause the following
// to appear in the keyfile:
//
//
//      [toplevel]
//      enabled=true
//
// If @root_group is nil then it is not permitted to store keys directly below
// the @root_path.
//
// For keys not stored directly below @root_path (ie: in a sub-path), the name
// of the subpath (with the final slash stripped) is used as the name of the
// keyfile group. To continue the example, if
// "/apps/example/profiles/default/font-size" were set to 12 then the following
// would appear in the keyfile:
//
//
//      [profiles/default]
//      font-size=12
//
// The backend will refuse writes (and return writability as being false) for
// keys outside of @root_path and, in the event that @root_group is nil, also
// for keys directly under @root_path. Writes will also be refused if the
// backend detects that it has the inability to rewrite the keyfile (ie: the
// containing directory is not writable).
//
// There is no checking done for your key namespace clashing with the syntax of
// the key file format. For example, if you have '[' or ']' characters in your
// path names or '=' in your key names you may be in trouble.
//
// The backend reads default values from a keyfile called `defaults` in the
// directory specified by the SettingsBackend:defaults-dir property, and a list
// of locked keys from a text file with the name `locks` in the same location.
func NewKeyfileSettingsBackend(filename string, rootPath string, rootGroup string) *SettingsBackend

// MemoryMonitorDupDefault: gets a reference to the default Monitor for the
// system.
func MemoryMonitorDupDefault() MemoryMonitor

// NewMemorySettingsBackend: creates a memory-backed Backend.
//
// This backend allows changes to settings, but does not write them to any
// backing storage, so the next time you run your application, the memory
// backend will start out with the default values again.
func NewMemorySettingsBackend() *SettingsBackend

// NetworkMonitorGetDefault: gets the default Monitor for the system.
func NetworkMonitorGetDefault() NetworkMonitor

// NetworkingInit: initializes the platform networking libraries (eg, on
// Windows, this calls WSAStartup()). GLib will call this itself if it is
// needed, so you only need to call it if you directly call system networking
// functions (without calling any GLib networking functions first).
func NetworkingInit()

// NewNullSettingsBackend: creates a readonly Backend.
//
// This backend does not allow changes to settings, so all settings will always
// have their default values.
func NewNullSettingsBackend() *SettingsBackend

// NewPollableSource: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource that expects a callback of type
// SourceFunc. The new source does not actually do anything on its own; use
// g_source_add_child_source() to add other sources to it to cause it to
// trigger.
func NewPollableSource(pollableStream *externglib.Object) *glib.Source

// PollableSourceNewFull: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource, as with g_pollable_source_new(), but
// also attaching @child_source (with a dummy callback), and @cancellable, if
// they are non-nil.
func PollableSourceNewFull(pollableStream unsafe.Pointer, childSource *glib.Source, cancellable *Cancellable) *glib.Source

// PollableStreamRead: tries to read from @stream, as with g_input_stream_read()
// (if @blocking is true) or g_pollable_input_stream_read_nonblocking() (if
// @blocking is false). This can be used to more easily share code between
// blocking and non-blocking implementations of a method.
//
// If @blocking is false, then @stream must be a InputStream for which
// g_pollable_input_stream_can_poll() returns true, or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// InputStream.
func PollableStreamRead(stream *InputStream, buffer []uint8, count uint, blocking bool, cancellable *Cancellable) int

// PollableStreamWrite: tries to write to @stream, as with
// g_output_stream_write() (if @blocking is true) or
// g_pollable_output_stream_write_nonblocking() (if @blocking is false). This
// can be used to more easily share code between blocking and non-blocking
// implementations of a method.
//
// If @blocking is false, then @stream must be a OutputStream for which
// g_pollable_output_stream_can_poll() returns true or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// OutputStream.
func PollableStreamWrite(stream *OutputStream, buffer []uint8, count uint, blocking bool, cancellable *Cancellable) int

// PollableStreamWriteAll: tries to write @count bytes to @stream, as with
// g_output_stream_write_all(), but using g_pollable_stream_write() rather than
// g_output_stream_write().
//
// On a successful write of @count bytes, true is returned, and @bytes_written
// is set to @count.
//
// If there is an error during the operation (including G_IO_ERROR_WOULD_BLOCK
// in the non-blocking case), false is returned and @error is set to indicate
// the error status, @bytes_written is updated to contain the number of bytes
// written into the stream before the error occurred.
//
// As with g_pollable_stream_write(), if @blocking is false, then @stream must
// be a OutputStream for which g_pollable_output_stream_can_poll() returns true
// or else the behavior is undefined. If @blocking is true, then @stream does
// not need to be a OutputStream.
func PollableStreamWriteAll(stream *OutputStream, buffer []uint8, count uint, blocking bool, cancellable *Cancellable) (uint, bool)

// ProxyGetDefaultForProtocol: find the `gio-proxy` extension point for a proxy
// implementation that supports the specified protocol.
func ProxyGetDefaultForProtocol(protocol string) Proxy

// ProxyResolverGetDefault: gets the default Resolver for the system.
func ProxyResolverGetDefault() ProxyResolver

// ResolverErrorQuark: gets the #GResolver Error Quark.
func ResolverErrorQuark() glib.Quark

// ResourceErrorQuark: gets the #GResource Error Quark.
func ResourceErrorQuark() glib.Quark

// ResourceLoad: loads a binary resource bundle and creates a #GResource
// representation of it, allowing you to query it for data.
//
// If you want to use this resource in the global resource namespace you need to
// register it with g_resources_register().
//
// If @filename is empty or the data in it is corrupt, G_RESOURCE_ERROR_INTERNAL
// will be returned. If @filename doesnt exist, or there is an error in reading
// it, an error from g_mapped_file_new() will be returned.
func ResourceLoad(filename string) *Resource

// ResourcesEnumerateChildren: returns all the names of children at the
// specified @path in the set of globally registered resources. The return
// result is a nil terminated list of strings which should be released with
// g_strfreev().
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) []string

// ResourcesGetInfo: looks for a file at the specified @path in the set of
// globally registered resources and if found returns information about it.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (uint, uint32, bool)

// ResourcesLookupData: looks for a file at the specified @path in the set of
// globally registered resources and returns a #GBytes that lets you directly
// access the data in memory.
//
// The data is always followed by a zero byte, so you can safely use the data as
// a C string. However, that byte is not included in the size of the GBytes.
//
// For uncompressed resource files this is a pointer directly into the resource
// bundle, which is typically in some readonly data section in the program
// binary. For compressed files we allocate memory on the heap and automatically
// uncompress the data.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesLookupData(path string, lookupFlags ResourceLookupFlags) *glib.Bytes

// ResourcesOpenStream: looks for a file at the specified @path in the set of
// globally registered resources and returns a Stream that lets you read the
// data.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) *InputStream

// ResourcesRegister: registers the resource with the process-global set of
// resources. Once a resource is registered the files in it can be accessed with
// the global resource lookup functions like g_resources_lookup_data().
func ResourcesRegister(resource *Resource)

// ResourcesUnregister: unregisters the resource from the process-global set of
// resources.
func ResourcesUnregister(resource *Resource)

// SettingsSchemaSourceGetDefault: gets the default system schema source.
//
// This function is not required for normal uses of #GSettings but it may be
// useful to authors of plugin management systems or to those who want to
// introspect the content of schemas.
//
// If no schemas are installed, nil will be returned.
//
// The returned source may actually consist of multiple schema sources from
// different directories, depending on which directories were given in
// `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all lookups
// performed against the default source should probably be done recursively.
func SettingsSchemaSourceGetDefault() *SettingsSchemaSource

// SimpleAsyncReportGerrorInIdle: reports an error in an idle function. Similar
// to g_simple_async_report_error_in_idle(), but takes a #GError rather than
// building a new one.
func SimpleAsyncReportGerrorInIdle(object *externglib.Object, callback AsyncReadyCallback, userData unsafe.Pointer, error *glib.Error)

// SimpleAsyncReportTakeGerrorInIdle: reports an error in an idle function.
// Similar to g_simple_async_report_gerror_in_idle(), but takes over the
// caller's ownership of @error, so the caller does not have to free it any
// more.
func SimpleAsyncReportTakeGerrorInIdle(object *externglib.Object, callback AsyncReadyCallback, userData unsafe.Pointer, error *glib.Error)

// SrvTargetListSort: sorts @targets in place according to the algorithm in RFC
// 2782.
func SrvTargetListSort(targets *glib.List) *glib.List

// TlsBackendGetDefault: gets the default Backend for the system.
func TlsBackendGetDefault() TlsBackend

// TlsChannelBindingErrorQuark: gets the TLS channel binding error quark.
func TlsChannelBindingErrorQuark() glib.Quark

// NewTlsClientConnection: creates a new ClientConnection wrapping
// @base_io_stream (which must have pollable input and output streams) which is
// assumed to communicate with the server identified by @server_identity.
//
// See the documentation for Connection:base-io-stream for restrictions on when
// application code can run operations on the @base_io_stream after this
// function has returned.
func NewTlsClientConnection(baseIOStream *IOStream, serverIdentity SocketConnectable) *IOStream

// TlsErrorQuark: gets the TLS error quark.
func TlsErrorQuark() glib.Quark

// NewTlsFileDatabase: creates a new FileDatabase which uses anchor certificate
// authorities in @anchors to verify certificate chains.
//
// The certificates in @anchors must be PEM encoded.
func NewTlsFileDatabase(anchors string) TlsFileDatabase

// NewTlsServerConnection: creates a new ServerConnection wrapping
// @base_io_stream (which must have pollable input and output streams).
//
// See the documentation for Connection:base-io-stream for restrictions on when
// application code can run operations on the @base_io_stream after this
// function has returned.
func NewTlsServerConnection(baseIOStream *IOStream, certificate *TlsCertificate) *IOStream

// UnixIsMountPathSystemInternal: determines if @mount_path is considered an
// implementation of the OS. This is primarily used for hiding mountable and
// mounted volumes that only are used in the OS and has little to no relevance
// to the casual user.
func UnixIsMountPathSystemInternal(mountPath string) bool

// UnixIsSystemDevicePath: determines if @device_path is considered a block
// device path which is only used in implementation of the OS. This is primarily
// used for hiding mounted volumes that are intended as APIs for programs to
// read, and system administrators at a shell; rather than something that
// should, for example, appear in a GUI. For example, the Linux `/proc`
// filesystem.
//
// The list of device paths considered system ones may change over time.
func UnixIsSystemDevicePath(devicePath string) bool

// UnixIsSystemFsType: determines if @fs_type is considered a type of file
// system which is only used in implementation of the OS. This is primarily used
// for hiding mounted volumes that are intended as APIs for programs to read,
// and system administrators at a shell; rather than something that should, for
// example, appear in a GUI. For example, the Linux `/proc` filesystem.
//
// The list of file system types considered system ones may change over time.
func UnixIsSystemFsType(fsType string) bool

// UnixMountAt: gets a MountEntry for a given mount path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountAt(mountPath string) (uint64, *UnixMountEntry)

// UnixMountCompare: compares two unix mounts.
func UnixMountCompare(mount1 *UnixMountEntry, mount2 *UnixMountEntry) int

// UnixMountCopy: makes a copy of @mount_entry.
func UnixMountCopy(mountEntry *UnixMountEntry) *UnixMountEntry

// UnixMountFor: gets a MountEntry for a given file path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountFor(filePath string) (uint64, *UnixMountEntry)

// UnixMountFree: frees a unix mount.
func UnixMountFree(mountEntry *UnixMountEntry)

// UnixMountGetDevicePath: gets the device path for a unix mount.
func UnixMountGetDevicePath(mountEntry *UnixMountEntry) string

// UnixMountGetFsType: gets the filesystem type for the unix mount.
func UnixMountGetFsType(mountEntry *UnixMountEntry) string

// UnixMountGetMountPath: gets the mount path for a unix mount.
func UnixMountGetMountPath(mountEntry *UnixMountEntry) string

// UnixMountGetOptions: gets a comma-separated list of mount options for the
// unix mount. For example, `rw,relatime,seclabel,data=ordered`.
//
// This is similar to g_unix_mount_point_get_options(), but it takes a
// MountEntry as an argument.
func UnixMountGetOptions(mountEntry *UnixMountEntry) string

// UnixMountGetRootPath: gets the root of the mount within the filesystem. This
// is useful e.g. for mounts created by bind operation, or btrfs subvolumes.
//
// For example, the root path is equal to "/" for mount created by "mount
// /dev/sda1 /mnt/foo" and "/bar" for "mount --bind /mnt/foo/bar /mnt/bar".
func UnixMountGetRootPath(mountEntry *UnixMountEntry) string

// UnixMountGuessCanEject: guesses whether a Unix mount can be ejected.
func UnixMountGuessCanEject(mountEntry *UnixMountEntry) bool

// UnixMountGuessIcon: guesses the icon of a Unix mount.
func UnixMountGuessIcon(mountEntry *UnixMountEntry) Icon

// UnixMountGuessName: guesses the name of a Unix mount. The result is a
// translated string.
func UnixMountGuessName(mountEntry *UnixMountEntry) string

// UnixMountGuessShouldDisplay: guesses whether a Unix mount should be displayed
// in the UI.
func UnixMountGuessShouldDisplay(mountEntry *UnixMountEntry) bool

// UnixMountGuessSymbolicIcon: guesses the symbolic icon of a Unix mount.
func UnixMountGuessSymbolicIcon(mountEntry *UnixMountEntry) Icon

// UnixMountIsReadonly: checks if a unix mount is mounted read only.
func UnixMountIsReadonly(mountEntry *UnixMountEntry) bool

// UnixMountIsSystemInternal: checks if a Unix mount is a system mount. This is
// the Boolean OR of g_unix_is_system_fs_type(), g_unix_is_system_device_path()
// and g_unix_is_mount_path_system_internal() on @mount_entrys properties.
//
// The definition of what a system mount entry is may change over time as new
// file system types and device paths are ignored.
func UnixMountIsSystemInternal(mountEntry *UnixMountEntry) bool

// UnixMountPointAt: gets a MountPoint for a given mount path. If @time_read is
// set, it will be filled with a unix timestamp for checking if the mount points
// have changed since with g_unix_mount_points_changed_since().
//
// If more mount points have the same mount path, the last matching mount point
// is returned.
func UnixMountPointAt(mountPath string) (uint64, *UnixMountPoint)

// UnixMountPointsChangedSince: checks if the unix mount points have changed
// since a given unix time.
func UnixMountPointsChangedSince(time uint64) bool

// UnixMountPointsGet: gets a #GList of MountPoint containing the unix mount
// points. If @time_read is set, it will be filled with the mount timestamp,
// allowing for checking if the mounts have changed with
// g_unix_mount_points_changed_since().
func UnixMountPointsGet() (uint64, *glib.List)

// UnixMountsChangedSince: checks if the unix mounts have changed since a given
// unix time.
func UnixMountsChangedSince(time uint64) bool

// UnixMountsGet: gets a #GList of MountEntry containing the unix mounts. If
// @time_read is set, it will be filled with the mount timestamp, allowing for
// checking if the mounts have changed with g_unix_mounts_changed_since().
func UnixMountsGet() (uint64, *glib.List)

// ActionEntry: this struct defines a single action. It is for use with
// g_action_map_add_action_entries().
//
// The order of the items in the structure are intended to reflect frequency of
// use. It is permissible to use an incomplete initialiser in order to leave
// some of the later values as nil. All values after @name are optional.
// Additional optional fields may be added in the future.
//
// See g_action_map_add_action_entries() for an example.
type ActionEntry struct {
	// Name: the name of the action
	Name string
	// ParameterType: the type of the parameter that must be passed to the
	// activate function for this action, given as a single GVariant type string
	// (or nil for no parameter)
	ParameterType string
	// State: the initial state for this action, given in [GVariant text
	// format][gvariant-text]. The state is parsed with no extra type
	// information, so type tags must be added to the string if they are
	// necessary. Stateless actions should give nil here.
	State string

	native *C.GActionEntry
}

func wrapActionEntry(p *C.GActionEntry) *ActionEntry {
	v := ActionEntry{native: p}

	v.Name = C.GoString(p.name)
	v.ParameterType = C.GoString(p.parameter_type)
	v.State = C.GoString(p.state)

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*ActionEntry).free)

	return &v
}

func marshalActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GActionEntry)(unsafe.Pointer(b))

	return wrapActionEntry(c)
}

func (a *ActionEntry) free() {}

// Native returns the pointer to *C.GActionEntry. The caller is expected to
// cast.
func (a *ActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(a.native)
}

// DBusAnnotationInfo: information about an annotation.
type DBusAnnotationInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Key: the name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
	Key string
	// Value: the value of the annotation.
	Value string
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusAnnotationInfo
}

func wrapDBusAnnotationInfo(p *C.GDBusAnnotationInfo) *DBusAnnotationInfo {
	var v DBusAnnotationInfo

	v.RefCount = int(p.ref_count)
	v.Key = C.GoString(p.key)
	v.Value = C.GoString(p.value)

	return &v
}

func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusAnnotationInfo)(unsafe.Pointer(b))

	return wrapDBusAnnotationInfo(c)
}

// Native returns the pointer to *C.GDBusAnnotationInfo. The caller is expected to
// cast.
func (d *DBusAnnotationInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusArgInfo: information about an argument for a method or a signal.
type DBusArgInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: name of the argument, e.g. @unix_user_id.
	Name string
	// Signature: d-Bus signature of the argument (a single complete type).
	Signature string
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusArgInfo
}

func wrapDBusArgInfo(p *C.GDBusArgInfo) *DBusArgInfo {
	var v DBusArgInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)
	v.Signature = C.GoString(p.signature)

	return &v
}

func marshalDBusArgInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusArgInfo)(unsafe.Pointer(b))

	return wrapDBusArgInfo(c)
}

// Native returns the pointer to *C.GDBusArgInfo. The caller is expected to
// cast.
func (d *DBusArgInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusErrorEntry: struct used in g_dbus_error_register_error_domain().
type DBusErrorEntry struct {
	// ErrorCode: an error code.
	ErrorCode int
	// DbusErrorName: the D-Bus error name to associate with @error_code.
	DbusErrorName string

	native *C.GDBusErrorEntry
}

func wrapDBusErrorEntry(p *C.GDBusErrorEntry) *DBusErrorEntry {
	var v DBusErrorEntry

	v.ErrorCode = int(p.error_code)
	v.DbusErrorName = C.GoString(p.dbus_error_name)

	return &v
}

func marshalDBusErrorEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusErrorEntry)(unsafe.Pointer(b))

	return wrapDBusErrorEntry(c)
}

// Native returns the pointer to *C.GDBusErrorEntry. The caller is expected to
// cast.
func (d *DBusErrorEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusInterfaceInfo: information about a D-Bus interface.
type DBusInterfaceInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus interface, e.g.
	// "org.freedesktop.DBus.Properties".
	Name string
	// Methods: a pointer to a nil-terminated array of pointers to BusMethodInfo
	// structures or nil if there are no methods.
	Methods []*DBusMethodInfo
	// Signals: a pointer to a nil-terminated array of pointers to BusSignalInfo
	// structures or nil if there are no signals.
	Signals []*DBusSignalInfo
	// Properties: a pointer to a nil-terminated array of pointers to
	// BusPropertyInfo structures or nil if there are no properties.
	Properties []*DBusPropertyInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusInterfaceInfo
}

func wrapDBusInterfaceInfo(p *C.GDBusInterfaceInfo) *DBusInterfaceInfo {
	var v DBusInterfaceInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)

	return &v
}

func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusInterfaceInfo)(unsafe.Pointer(b))

	return wrapDBusInterfaceInfo(c)
}

// Native returns the pointer to *C.GDBusInterfaceInfo. The caller is expected to
// cast.
func (d *DBusInterfaceInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusInterfaceVTable: virtual table for handling properties and method calls
// for a D-Bus interface.
//
// Since 2.38, if you want to handle getting/setting D-Bus properties
// asynchronously, give nil as your get_property() or set_property() function.
// The D-Bus call will be directed to your @method_call function, with the
// provided @interface_name set to "org.freedesktop.DBus.Properties".
//
// Ownership of the BusMethodInvocation object passed to the method_call()
// function is transferred to your handler; you must call one of the methods of
// BusMethodInvocation to return a reply (possibly empty), or an error. These
// functions also take ownership of the passed-in invocation object, so unless
// the invocation object has otherwise been referenced, it will be then be
// freed. Calling one of these functions may be done within your method_call()
// implementation but it also can be done at a later point to handle the method
// asynchronously.
//
// The usual checks on the validity of the calls is performed. For `Get` calls,
// an error is automatically returned if the property does not exist or the
// permissions do not allow access. The same checks are performed for `Set`
// calls, and the provided value is also checked for being the correct type.
//
// For both `Get` and `Set` calls, the BusMethodInvocation passed to the
// @method_call handler can be queried with
// g_dbus_method_invocation_get_property_info() to get a pointer to the
// BusPropertyInfo of the property.
//
// If you have readable properties specified in your interface info, you must
// ensure that you either provide a non-nil @get_property() function or provide
// implementations of both the `Get` and `GetAll` methods on
// org.freedesktop.DBus.Properties interface in your @method_call function. Note
// that the required return type of the `Get` call is `(v)`, not the type of the
// property. `GetAll` expects a return value of type `a{sv}`.
//
// If you have writable properties specified in your interface info, you must
// ensure that you either provide a non-nil @set_property() function or provide
// an implementation of the `Set` call. If implementing the call, you must
// return the value of type G_VARIANT_TYPE_UNIT.
type DBusInterfaceVTable struct {
	// MethodCall: function for handling incoming method calls.
	MethodCall DBusInterfaceMethodCallFunc
	// GetProperty: function for getting a property.
	GetProperty DBusInterfaceGetPropertyFunc
	// SetProperty: function for setting a property.
	SetProperty DBusInterfaceSetPropertyFunc

	native *C.GDBusInterfaceVTable
}

func wrapDBusInterfaceVTable(p *C.GDBusInterfaceVTable) *DBusInterfaceVTable {
	v := DBusInterfaceVTable{native: p}

	v.MethodCall = wrapDBusInterfaceMethodCallFunc(p.method_call)
	v.GetProperty = wrapDBusInterfaceGetPropertyFunc(p.get_property)
	v.SetProperty = wrapDBusInterfaceSetPropertyFunc(p.set_property)

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*DBusInterfaceVTable).free)

	return &v
}

func marshalDBusInterfaceVTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusInterfaceVTable)(unsafe.Pointer(b))

	return wrapDBusInterfaceVTable(c)
}

func (d *DBusInterfaceVTable) free() {}

// Native returns the pointer to *C.GDBusInterfaceVTable. The caller is expected to
// cast.
func (d *DBusInterfaceVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusMethodInfo: information about a method on an D-Bus interface.
type DBusMethodInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus method, e.g. @RequestName.
	Name string
	// InArgs: a pointer to a nil-terminated array of pointers to BusArgInfo
	// structures or nil if there are no in arguments.
	InArgs []*DBusArgInfo
	// OutArgs: a pointer to a nil-terminated array of pointers to BusArgInfo
	// structures or nil if there are no out arguments.
	OutArgs []*DBusArgInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusMethodInfo
}

func wrapDBusMethodInfo(p *C.GDBusMethodInfo) *DBusMethodInfo {
	var v DBusMethodInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)

	return &v
}

func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusMethodInfo)(unsafe.Pointer(b))

	return wrapDBusMethodInfo(c)
}

// Native returns the pointer to *C.GDBusMethodInfo. The caller is expected to
// cast.
func (d *DBusMethodInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusNodeInfo: information about nodes in a remote object hierarchy.
type DBusNodeInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Path: the path of the node or nil if omitted. Note that this may be a
	// relative path. See the D-Bus specification for more details.
	Path string
	// Interfaces: a pointer to a nil-terminated array of pointers to
	// BusInterfaceInfo structures or nil if there are no interfaces.
	Interfaces []*DBusInterfaceInfo
	// Nodes: a pointer to a nil-terminated array of pointers to BusNodeInfo
	// structures or nil if there are no nodes.
	Nodes []*DBusNodeInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusNodeInfo
}

func wrapDBusNodeInfo(p *C.GDBusNodeInfo) *DBusNodeInfo {
	var v DBusNodeInfo

	v.RefCount = int(p.ref_count)
	v.Path = C.GoString(p.path)

	return &v
}

func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusNodeInfo)(unsafe.Pointer(b))

	return wrapDBusNodeInfo(c)
}

// Native returns the pointer to *C.GDBusNodeInfo. The caller is expected to
// cast.
func (d *DBusNodeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

func NewDBusNodeInfo(xmlData string) *DBusNodeInfo

// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
type DBusPropertyInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus property, e.g. "SupportedFilesystems".
	Name string
	// Signature: the D-Bus signature of the property (a single complete type).
	Signature string
	// Flags: access control flags for the property.
	Flags DBusPropertyInfoFlags
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusPropertyInfo
}

func wrapDBusPropertyInfo(p *C.GDBusPropertyInfo) *DBusPropertyInfo {
	var v DBusPropertyInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)
	v.Signature = C.GoString(p.signature)
	v.Flags = DBusPropertyInfoFlags(p.flags)

	return &v
}

func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusPropertyInfo)(unsafe.Pointer(b))

	return wrapDBusPropertyInfo(c)
}

// Native returns the pointer to *C.GDBusPropertyInfo. The caller is expected to
// cast.
func (d *DBusPropertyInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusSignalInfo: information about a signal on a D-Bus interface.
type DBusSignalInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus signal, e.g. "NameOwnerChanged".
	Name string
	// Args: a pointer to a nil-terminated array of pointers to BusArgInfo
	// structures or nil if there are no arguments.
	Args []*DBusArgInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusSignalInfo
}

func wrapDBusSignalInfo(p *C.GDBusSignalInfo) *DBusSignalInfo {
	var v DBusSignalInfo

	v.RefCount = int(p.ref_count)
	v.Name = C.GoString(p.name)

	return &v
}

func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusSignalInfo)(unsafe.Pointer(b))

	return wrapDBusSignalInfo(c)
}

// Native returns the pointer to *C.GDBusSignalInfo. The caller is expected to
// cast.
func (d *DBusSignalInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusSubtreeVTable: virtual table for handling subtrees registered with
// g_dbus_connection_register_subtree().
type DBusSubtreeVTable struct {
	// Enumerate: function for enumerating child nodes.
	Enumerate DBusSubtreeEnumerateFunc
	// Introspect: function for introspecting a child node.
	Introspect DBusSubtreeIntrospectFunc
	// Dispatch: function for dispatching a remote call on a child node.
	Dispatch DBusSubtreeDispatchFunc

	native *C.GDBusSubtreeVTable
}

func wrapDBusSubtreeVTable(p *C.GDBusSubtreeVTable) *DBusSubtreeVTable {
	v := DBusSubtreeVTable{native: p}

	v.Enumerate = wrapDBusSubtreeEnumerateFunc(p.enumerate)
	v.Introspect = wrapDBusSubtreeIntrospectFunc(p.introspect)
	v.Dispatch = wrapDBusSubtreeDispatchFunc(p.dispatch)

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*DBusSubtreeVTable).free)

	return &v
}

func marshalDBusSubtreeVTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GDBusSubtreeVTable)(unsafe.Pointer(b))

	return wrapDBusSubtreeVTable(c)
}

func (d *DBusSubtreeVTable) free() {}

// Native returns the pointer to *C.GDBusSubtreeVTable. The caller is expected to
// cast.
func (d *DBusSubtreeVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// FileAttributeInfo: information about a specific attribute.
type FileAttributeInfo struct {
	// Name: the name of the attribute.
	Name string
	// Type: the AttributeType type of the attribute.
	Type FileAttributeType
	// Flags: a set of AttributeInfoFlags.
	Flags FileAttributeInfoFlags

	native *C.GFileAttributeInfo
}

func wrapFileAttributeInfo(p *C.GFileAttributeInfo) *FileAttributeInfo {
	var v FileAttributeInfo

	v.Name = C.GoString(p.name)
	v.Type = FileAttributeType(p._type)
	v.Flags = FileAttributeInfoFlags(p.flags)

	return &v
}

func marshalFileAttributeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GFileAttributeInfo)(unsafe.Pointer(b))

	return wrapFileAttributeInfo(c)
}

// Native returns the pointer to *C.GFileAttributeInfo. The caller is expected to
// cast.
func (f *FileAttributeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

// FileAttributeInfoList: acts as a lightweight registry for possible valid file
// attributes. The registry stores Key-Value pair formats as AttributeInfos.
type FileAttributeInfoList struct {
	// Infos: an array of AttributeInfos.
	Infos *FileAttributeInfo
	// NInfos: the number of values in the array.
	NInfos int

	native *C.GFileAttributeInfoList
}

func wrapFileAttributeInfoList(p *C.GFileAttributeInfoList) *FileAttributeInfoList {
	var v FileAttributeInfoList

	v.Infos = wrap * FileAttributeInfo(p.infos)
	v.NInfos = int(p.n_infos)

	return &v
}

func marshalFileAttributeInfoList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GFileAttributeInfoList)(unsafe.Pointer(b))

	return wrapFileAttributeInfoList(c)
}

// Native returns the pointer to *C.GFileAttributeInfoList. The caller is expected to
// cast.
func (f *FileAttributeInfoList) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

func NewFileAttributeInfoList() *FileAttributeInfoList

// FileAttributeMatcher: determines if a string matches a file attribute.
type FileAttributeMatcher struct {
	native *C.GFileAttributeMatcher
}

func wrapFileAttributeMatcher(p *C.GFileAttributeMatcher) *FileAttributeMatcher {
	v := FileAttributeMatcher{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*FileAttributeMatcher).free)

	return &v
}

func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GFileAttributeMatcher)(unsafe.Pointer(b))

	return wrapFileAttributeMatcher(c)
}

func (f *FileAttributeMatcher) free() {}

// Native returns the pointer to *C.GFileAttributeMatcher. The caller is expected to
// cast.
func (f *FileAttributeMatcher) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher

// InputMessage: structure used for scatter/gather data input when receiving
// multiple messages or packets in one go. You generally pass in an array of
// empty Vectors and the operation will use all the buffers as if they were one
// buffer, and will set @bytes_received to the total number of bytes received
// across all Vectors.
//
// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from the
// POSIX sockets API (see `man 2 recvmmsg`).
//
// If @address is non-nil then it is set to the source address the message was
// received from, and the caller must free it afterwards.
//
// If @control_messages is non-nil then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. @num_control_messages is set to the number of elements in this
// array, which may be zero.
//
// Flags relevant to this message will be returned in @flags. For example,
// `MSG_EOR` or `MSG_TRUNC`.
type InputMessage struct {
	// Address: return location for a Address, or nil
	Address **SocketAddress
	// Vectors: pointer to an array of input vectors
	Vectors []InputVector
	// NumVectors: the number of input vectors pointed to by @vectors
	NumVectors uint
	// BytesReceived: will be set to the number of bytes that have been received
	BytesReceived uint
	// Flags: collection of MsgFlags for the received message, outputted by the
	// call
	Flags int
	// ControlMessages: return location for a caller-allocated array of
	// ControlMessages, or nil
	ControlMessages []**SocketControlMessage
	// NumControlMessages: return location for the number of elements in
	// @control_messages
	NumControlMessages uint

	native *C.GInputMessage
}

func wrapInputMessage(p *C.GInputMessage) *InputMessage {
	var v InputMessage

	v.Address = wrap * *SocketAddress(p.address)

	v.NumVectors = uint(p.num_vectors)
	v.BytesReceived = uint(p.bytes_received)
	v.Flags = int(p.flags)

	v.NumControlMessages = uint(p.num_control_messages)

	return &v
}

func marshalInputMessage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GInputMessage)(unsafe.Pointer(b))

	return wrapInputMessage(c)
}

// Native returns the pointer to *C.GInputMessage. The caller is expected to
// cast.
func (i *InputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(i.native)
}

// InputVector: structure used for scatter/gather data input. You generally pass
// in an array of Vectors and the operation will store the read data starting in
// the first buffer, switching to the next as needed.
type InputVector struct {
	// Buffer: pointer to a buffer where data will be written.
	Buffer unsafe.Pointer
	// Size: the available size in @buffer.
	Size uint

	native *C.GInputVector
}

func wrapInputVector(p *C.GInputVector) *InputVector {
	var v InputVector

	v.Buffer = unsafe.Pointer(p.buffer)
	v.Size = uint(p.size)

	return &v
}

func marshalInputVector(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GInputVector)(unsafe.Pointer(b))

	return wrapInputVector(c)
}

// Native returns the pointer to *C.GInputVector. The caller is expected to
// cast.
func (i *InputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(i.native)
}

// OutputMessage: structure used for scatter/gather data output when sending
// multiple messages or packets in one go. You generally pass in an array of
// Vectors and the operation will use all the buffers as if they were one
// buffer.
//
// If @address is nil then the message is sent to the default receiver (as
// previously set by g_socket_connect()).
type OutputMessage struct {
	// Address: a Address, or nil
	Address *SocketAddress
	// Vectors: pointer to an array of output vectors
	Vectors *OutputVector
	// NumVectors: the number of output vectors pointed to by @vectors.
	NumVectors uint
	// BytesSent: initialize to 0. Will be set to the number of bytes that have
	// been sent
	BytesSent uint
	// ControlMessages: a pointer to an array of ControlMessages, or nil.
	ControlMessages []*SocketControlMessage
	// NumControlMessages: number of elements in @control_messages.
	NumControlMessages uint

	native *C.GOutputMessage
}

func wrapOutputMessage(p *C.GOutputMessage) *OutputMessage {
	var v OutputMessage

	v.Address = wrap * SocketAddress(p.address)
	v.Vectors = wrap * OutputVector(p.vectors)
	v.NumVectors = uint(p.num_vectors)
	v.BytesSent = uint(p.bytes_sent)

	v.NumControlMessages = uint(p.num_control_messages)

	return &v
}

func marshalOutputMessage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GOutputMessage)(unsafe.Pointer(b))

	return wrapOutputMessage(c)
}

// Native returns the pointer to *C.GOutputMessage. The caller is expected to
// cast.
func (o *OutputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(o.native)
}

// OutputVector: structure used for scatter/gather data output. You generally
// pass in an array of Vectors and the operation will use all the buffers as if
// they were one buffer.
type OutputVector struct {
	// Buffer: pointer to a buffer of data to read.
	Buffer unsafe.Pointer
	// Size: the size of @buffer.
	Size uint

	native *C.GOutputVector
}

func wrapOutputVector(p *C.GOutputVector) *OutputVector {
	var v OutputVector

	v.Buffer = unsafe.Pointer(p.buffer)
	v.Size = uint(p.size)

	return &v
}

func marshalOutputVector(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GOutputVector)(unsafe.Pointer(b))

	return wrapOutputVector(c)
}

// Native returns the pointer to *C.GOutputVector. The caller is expected to
// cast.
func (o *OutputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(o.native)
}

// Resource: applications and libraries often contain binary or textual data
// that is really part of the application, rather than user data. For instance
// Builder .ui files, splashscreen images, GMenu markup XML, CSS files, icons,
// etc. These are often shipped as files in `$datadir/appname`, or manually
// included as literal strings in the code.
//
// The #GResource API and the [glib-compile-resources][glib-compile-resources]
// program provide a convenient and efficient alternative to this which has some
// nice properties. You maintain the files as normal files, so its easy to edit
// them, but during the build the files are combined into a binary bundle that
// is linked into the executable. This means that loading the resource files are
// efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in
// the filesystem). It also makes it easier to create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included
// in the resource bundle in a compressed form, but will be automatically
// uncompressed when the resource is used. This is very useful e.g. for larger
// text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of
// the `preprocess` attribute to a comma-separated list of preprocessing
// options. The only options currently supported are:
//
// `xml-stripblanks` which will use the xmllint command to strip ignorable
// whitespace from the XML file. For this to work, the `XMLLINT` environment
// variable must be set to the full path to the xmllint executable, or xmllint
// must be in the `PATH`; otherwise the preprocessing step is skipped.
//
// `to-pixdata` which will use the gdk-pixbuf-pixdata command to convert images
// to the GdkPixdata format, which allows you to create pixbufs directly using
// the data inside the resource file, rather than an (uncompressed) copy of it.
// For this, the gdk-pixbuf-pixdata program must be in the PATH, or the
// `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
// gdk-pixbuf-pixdata executable; otherwise the resource compiler will abort.
//
// `json-stripblanks` which will use the `json-glib-format` command to strip
// ignorable whitespace from the JSON file. For this to work, the
// `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
// `json-glib-format` executable, or it must be in the `PATH`; otherwise the
// preprocessing step is skipped. In addition, at least version 1.6 of
// `json-glib-format` is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given `prefix` and the filename from the `file` element.
// The `alias` attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the
// [glib-compile-resources][glib-compile-resources] program which takes an XML
// file that describes the bundle, and a set of files that the XML references.
// These are combined into a binary resource bundle.
//
//
//    <?xml version="1.0" encoding="UTF-8"?>
//    <gresources>
//      <gresource prefix="/org/gtk/Example">
//        <file>data/splashscreen.png</file>
//        <file compressed="true">dialog.ui</file>
//        <file preprocess="xml-stripblanks">menumarkup.xml</file>
//        <file alias="example.css">data/example.css</file>
//      </gresource>
//    </gresources>
//
//
//    /org/gtk/Example/data/splashscreen.png
//    /org/gtk/Example/dialog.ui
//    /org/gtk/Example/menumarkup.xml
//    /org/gtk/Example/example.css
//
// Note that all resources in the process share the same namespace, so use
// Java-style path prefixes (like in the above example) to avoid conflicts.
//
// You can then use [glib-compile-resources][glib-compile-resources] to compile
// the XML to a binary bundle that you can load with g_resource_load(). However,
// its more common to use the --generate-source and --generate-header arguments
// to create a source file and header to link directly into your application.
// This will generate `get_resource()`, `register_resource()` and
// `unregister_resource()` functions, prefixed by the `--c-name` argument passed
// to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
// the generated #GResource object. The register and unregister functions
// register the resource so its files can be accessed using
// g_resources_lookup_data().
//
// Once a #GResource has been created and registered all the data in it can be
// accessed globally in the process by using API calls like
// g_resources_open_stream() to stream the data or g_resources_lookup_data() to
// get a direct pointer to the data. You can also use URIs like
// "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access the
// resource data.
//
// Some higher-level APIs, such as Application, will automatically load
// resources from certain well-known paths in the resource namespace as a
// convenience. See the documentation for those APIs for details.
//
// There are two forms of the generated source, the default version uses the
// compiler support for constructor and destructor functions (where available)
// to automatically create and register the #GResource on startup or library
// load time. If you pass `--manual-register`, two functions to
// register/unregister the resource are created instead. This requires an
// explicit initialization call in your application/library, but it works on all
// platforms, even on the minor ones where constructors are not supported.
// (Constructor support is available for at least Win32, Mac OS and Linux.)
//
// Note that resource data can point directly into the data segment of e.g. a
// library, so if you are unloading libraries during runtime you need to be very
// careful with keeping around pointers to data from a resource, as this goes
// away when the library is unloaded. However, in practice this is not generally
// a problem, since most resource accesses are for your own resources, and
// resource data is often used once, during parsing, and then released.
//
// When debugging a program or testing a change to an installed version, it is
// often useful to be able to replace resources in the program or library,
// without recompiling, for debugging or quick hacking and testing purposes.
// Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment
// variable to selectively overlay resources with replacements from the
// filesystem. It is a G_SEARCHPATH_SEPARATOR-separated list of substitutions to
// perform during resource lookups.
//
// A substitution has the form
//
//
//       /org/gtk/libgtk=/home/desrt/gtk-overlay
//
// The part before the `=` is the resource subpath for which the overlay
// applies. The part after is a filesystem path which contains files and
// subdirectories as you would like to be loaded as resources with the
// equivalent names.
//
// In the example above, if an application tried to load a resource with the
// resource path `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check
// the filesystem path `/home/desrt/gtk-overlay/ui/gtkdialog.ui`. If a file was
// found there, it would be used instead. This is an overlay, not an outright
// replacement, which means that if a file is not found at that path, the
// built-in version will be used instead. Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash
// before the '='. The path after the slash should ideally be absolute, but this
// is not strictly required. It is possible to overlay the location of a single
// resource with an individual file.
type Resource struct {
	native *C.GResource
}

func wrapResource(p *C.GResource) *Resource {
	v := Resource{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*Resource).free)

	return &v
}

func marshalResource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GResource)(unsafe.Pointer(b))

	return wrapResource(c)
}

func (r *Resource) free() {}

// Native returns the pointer to *C.GResource. The caller is expected to
// cast.
func (r *Resource) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

func NewResource(data *glib.Bytes) *Resource

// SettingsSchema: the SchemaSource and Schema APIs provide a mechanism for
// advanced control over the loading of schemas and a mechanism for
// introspecting their content.
//
// Plugin loading systems that wish to provide plugins a way to access settings
// face the problem of how to make the schemas for these settings visible to
// GSettings. Typically, a plugin will want to ship the schema along with itself
// and it won't be installed into the standard system directories for schemas.
//
// SchemaSource provides a mechanism for dealing with this by allowing the
// creation of a new 'schema source' from which schemas can be acquired. This
// schema source can then become part of the metadata associated with the plugin
// and queried whenever the plugin requires access to some settings.
//
// Consider the following example:
//
//    typedef struct
//    {
//       ...
//       GSettingsSchemaSource *schema_source;
//       ...
//    } Plugin;
//
//    Plugin *
//    initialise_plugin (const gchar *dir)
//    {
//      Plugin *plugin;
//
//      ...
//
//      plugin->schema_source =
//        g_settings_schema_source_new_from_directory (dir,
//          g_settings_schema_source_get_default (), FALSE, NULL);
//
//      ...
//
//      return plugin;
//    }
//
//    ...
//
//    GSettings *
//    plugin_get_settings (Plugin      *plugin,
//                         const gchar *schema_id)
//    {
//      GSettingsSchema *schema;
//
//      if (schema_id == NULL)
//        schema_id = plugin->identifier;
//
//      schema = g_settings_schema_source_lookup (plugin->schema_source,
//                                                schema_id, FALSE);
//
//      if (schema == NULL)
//        {
//          ... disable the plugin or abort, etc ...
//        }
//
//      return g_settings_new_full (schema, NULL, NULL);
//    }
//
//
// The code above shows how hooks should be added to the code that initialises
// (or enables) the plugin to create the schema source and how an API can be
// added to the plugin system to provide a convenient way for the plugin to
// access its settings, using the schemas that it ships.
//
// From the standpoint of the plugin, it would need to ensure that it ships a
// gschemas.compiled file as part of itself, and then simply do the following:
//
//    {
//      GSettings *settings;
//      gint some_value;
//
//      settings = plugin_get_settings (self, NULL);
//      some_value = g_settings_get_int (settings, "some-value");
//      ...
//    }
//
//
// It's also possible that the plugin system expects the schema source files
// (ie: .gschema.xml files) instead of a gschemas.compiled file. In that case,
// the plugin loading system must compile the schemas for itself before
// attempting to create the settings source.
type SettingsSchema struct {
	native *C.GSettingsSchema
}

func wrapSettingsSchema(p *C.GSettingsSchema) *SettingsSchema {
	v := SettingsSchema{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*SettingsSchema).free)

	return &v
}

func marshalSettingsSchema(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GSettingsSchema)(unsafe.Pointer(b))

	return wrapSettingsSchema(c)
}

func (s *SettingsSchema) free() {}

// Native returns the pointer to *C.GSettingsSchema. The caller is expected to
// cast.
func (s *SettingsSchema) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// SettingsSchemaKey: GSettingsSchemaKey is an opaque data structure and can
// only be accessed using the following functions.
type SettingsSchemaKey struct {
	native *C.GSettingsSchemaKey
}

func wrapSettingsSchemaKey(p *C.GSettingsSchemaKey) *SettingsSchemaKey {
	v := SettingsSchemaKey{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*SettingsSchemaKey).free)

	return &v
}

func marshalSettingsSchemaKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GSettingsSchemaKey)(unsafe.Pointer(b))

	return wrapSettingsSchemaKey(c)
}

func (s *SettingsSchemaKey) free() {}

// Native returns the pointer to *C.GSettingsSchemaKey. The caller is expected to
// cast.
func (s *SettingsSchemaKey) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// SettingsSchemaSource: this is an opaque structure type. You may not access it
// directly.
type SettingsSchemaSource struct {
	native *C.GSettingsSchemaSource
}

func wrapSettingsSchemaSource(p *C.GSettingsSchemaSource) *SettingsSchemaSource {
	v := SettingsSchemaSource{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*SettingsSchemaSource).free)

	return &v
}

func marshalSettingsSchemaSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GSettingsSchemaSource)(unsafe.Pointer(b))

	return wrapSettingsSchemaSource(c)
}

func (s *SettingsSchemaSource) free() {}

// Native returns the pointer to *C.GSettingsSchemaSource. The caller is expected to
// cast.
func (s *SettingsSchemaSource) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

func NewSettingsSchemaSource(directory string, parent *SettingsSchemaSource, trusted bool) *SettingsSchemaSource

// SrvTarget: SRV (service) records are used by some network protocols to
// provide service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain; rather than
// connecting directly to "example.com" or assuming a specific server hostname
// like "xmpp.example.com", an XMPP client would look up the "xmpp-client" SRV
// record for "example.com", and then connect to whatever host was pointed to by
// that record.
//
// You can use g_resolver_lookup_service() or g_resolver_lookup_service_async()
// to find the Targets for a given service. However, if you are simply planning
// to connect to the remote service, you can use Service's Connectable interface
// and not need to worry about Target at all.
type SrvTarget struct {
	native *C.GSrvTarget
}

func wrapSrvTarget(p *C.GSrvTarget) *SrvTarget {
	v := SrvTarget{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*SrvTarget).free)

	return &v
}

func marshalSrvTarget(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GSrvTarget)(unsafe.Pointer(b))

	return wrapSrvTarget(c)
}

func (s *SrvTarget) free() {}

// Native returns the pointer to *C.GSrvTarget. The caller is expected to
// cast.
func (s *SrvTarget) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget

// StaticResource: GStaticResource is an opaque data structure and can only be
// accessed using the following functions.
type StaticResource struct {
	native *C.GStaticResource
}

func wrapStaticResource(p *C.GStaticResource) *StaticResource {
	v := StaticResource{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*StaticResource).free)

	return &v
}

func marshalStaticResource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GStaticResource)(unsafe.Pointer(b))

	return wrapStaticResource(c)
}

func (s *StaticResource) free() {}

// Native returns the pointer to *C.GStaticResource. The caller is expected to
// cast.
func (s *StaticResource) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// UnixMountEntry: defines a Unix mount entry (e.g.
// <filename>/media/cdrom</filename>). This corresponds roughly to a mtab entry.
type UnixMountEntry struct {
	native *C.GUnixMountEntry
}

func wrapUnixMountEntry(p *C.GUnixMountEntry) *UnixMountEntry {
	v := UnixMountEntry{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*UnixMountEntry).free)

	return &v
}

func marshalUnixMountEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GUnixMountEntry)(unsafe.Pointer(b))

	return wrapUnixMountEntry(c)
}

func (u *UnixMountEntry) free() {}

// Native returns the pointer to *C.GUnixMountEntry. The caller is expected to
// cast.
func (u *UnixMountEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(u.native)
}

// UnixMountPoint: defines a Unix mount point (e.g. <filename>/dev</filename>).
// This corresponds roughly to a fstab entry.
type UnixMountPoint struct {
	native *C.GUnixMountPoint
}

func wrapUnixMountPoint(p *C.GUnixMountPoint) *UnixMountPoint {
	v := UnixMountPoint{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*UnixMountPoint).free)

	return &v
}

func marshalUnixMountPoint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GUnixMountPoint)(unsafe.Pointer(b))

	return wrapUnixMountPoint(c)
}

func (u *UnixMountPoint) free() {}

// Native returns the pointer to *C.GUnixMountPoint. The caller is expected to
// cast.
func (u *UnixMountPoint) Native() unsafe.Pointer {
	return unsafe.Pointer(u.native)
}

// AppInfoMonitor: GAppInfoMonitor is a very simple object used for monitoring
// the app info database for changes (ie: newly installed or removed
// applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor struct {
	*externglib.Object
}

func wrapAppInfoMonitor(obj *glib.Object) *AppInfoMonitor {
	return &AppInfoMonitor{*externglib.Object{obj}}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
type AppLaunchContext struct {
	*externglib.Object
}

func wrapAppLaunchContext(obj *glib.Object) *AppLaunchContext {
	return &AppLaunchContext{*externglib.Object{obj}}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Application: a #GApplication is the foundation of an application. It wraps
// some low-level platform-specific services and is intended to act as the
// foundation for higher-level application classes such as Application or
// Application. In general, you should not use this class outside of a higher
// level framework.
//
// GApplication provides convenient life cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using g_application_hold() and g_application_release(). If it drops to zero,
// the application exits. Higher-level classes such as Application employ the
// use count to ensure that the application stays alive as long as it has any
// opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent, but
// corresponds roughly to a graphical desktop login. When your application is
// launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
//
// The use of #GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a #GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling g_application_run(). All checks for uniqueness are
// done internally. If the application is the primary instance then the startup
// signal is emitted and the mainloop runs. If the application is not the
// primary instance then a signal is sent to the primary instance and
// g_application_run() promptly returns. See the code examples below.
//
// If used, the expected form of an application identifier is the same as that
// of of a [D-Bus well-known bus
// name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: `com.example.MyApp`,
// `org.example.internal_apps.Calculator`, `org._7_zip.Archiver`. For details on
// valid application identifiers, see g_application_id_is_valid().
//
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application is
// scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with the
// shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is not
// running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in g_application_register()).
// Unfortunately, this means that you cannot use g_application_get_is_remote()
// to decide if you want to register object paths.
//
// GApplication also implements the Group and Map interfaces and lets you easily
// export actions by adding them with g_action_map_add_action(). When invoking
// an action by calling g_action_group_activate_action() on the application, it
// is always invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the BusActionGroup wrapper to conveniently
// access them remotely. GIO provides a BusMenuModel wrapper for remote access
// to exported Models.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the application,
// GApplication passes some platform data from the launching instance to the
// primary instance, in the form of a #GVariant dictionary mapping strings to
// variants. To use platform data, override the @before_emit or @after_emit
// virtual functions in your #GApplication subclass. When dealing with
// CommandLine objects, the platform data is directly available via
// g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
//
// As the name indicates, the platform data may vary depending on the operating
// system, but it always includes the current directory (key "cwd"), and
// optionally the environment (ie the set of environment variables and their
// values) of the calling process (key "environ"). The environment is only added
// to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// #GApplication subclasses can add their own platform data by overriding the
// @add_platform_data virtual function. For instance, Application adds startup
// notification data in this way.
//
// To parse commandline arguments you may handle the #GApplication::command-line
// signal or override the local_command_line() vfunc, to parse them in either
// the primary instance or the local instance, respectively.
//
// For an example of opening files with a GApplication, see
// [gapplication-example-open.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication, see
// [gapplication-example-actions.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with GApplication, see
// [gapplication-example-dbushooks.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).
type Application struct {
	*externglib.Object
}

func wrapApplication(obj *glib.Object) *Application {
	return &Application{*externglib.Object{obj}}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ApplicationCommandLine: GApplicationCommandLine represents a command-line
// invocation of an application. It is created by #GApplication and emitted in
// the #GApplication::command-line signal and virtual function.
//
// The class contains the list of arguments that the program was invoked with.
// It is also possible to query if the commandline invocation was local (ie: the
// current process is running in direct response to the invocation) or remote
// (ie: some other process forwarded the commandline to this process).
//
// The GApplicationCommandLine object can provide the @argc and @argv parameters
// for use with the Context command-line parsing API, with the
// g_application_command_line_get_arguments() function. See
// [gapplication-example-cmdline3.c][gapplication-example-cmdline3] for an
// example.
//
// The exit status of the originally-invoked process may be set and messages can
// be printed to stdout or stderr of that process. The lifecycle of the
// originally-invoked process is tied to the lifecycle of this object (ie: the
// process exits when the last reference is dropped).
//
// The main use for CommandLine (and the #GApplication::command-line signal) is
// 'Emacs server' like use cases: You can set the `EDITOR` environment variable
// to have e.g. git use your favourite editor to edit commit messages, and if
// you already have an instance of the editor running, the editing will happen
// in the running instance, instead of opening a new one. An important aspect of
// this use case is that the process that gets started by git does not return
// until the editing is done.
//
// Normally, the commandline is completely handled in the
// #GApplication::command-line handler. The launching instance exits once the
// signal handler in the primary instance has returned, and the return value of
// the signal handler becomes the exit status of the launching instance. |[<!--
// language="C" --> static int command_line (GApplication *application,
// GApplicationCommandLine *cmdline) { gchar **argv; gint argc; gint i;
//
// argv = g_application_command_line_get_arguments (cmdline, &argc);
//
// g_application_command_line_print (cmdline, "This text is written back\n" "to
// stdout of the caller\n");
//
// for (i = 0; i < argc; i++) g_print ("argument d: s\n", i, argv[i]);
//
// g_strfreev (argv);
//
// return 0; } ]| The complete example can be found here:
// [gapplication-example-cmdline.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline.c)
//
// In more complicated cases, the handling of the comandline can be split
// between the launcher and the primary instance. |[<!-- language="C" --> static
// gboolean test_local_cmdline (GApplication *application, gchar ***arguments,
// gint *exit_status) { gint i, j; gchar **argv;
//
// argv = *arguments;
//
// i = 1; while (argv[i]) { if (g_str_has_prefix (argv[i], "--local-")) {
// g_print ("handling argument s locally\n", argv[i]); g_free (argv[i]); for (j
// = i; argv[j]; j++) argv[j] = argv[j + 1]; } else { g_print ("not handling
// argument s locally\n", argv[i]); i++; } }
//
// *exit_status = 0;
//
// return FALSE; }
//
// static void test_application_class_init (TestApplicationClass *class) {
// G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;
//
// ... } ]| In this example of split commandline handling, options that start
// with `--local-` are handled locally, all other options are passed to the
// #GApplication::command-line handler which runs in the primary instance.
//
// The complete example can be found here:
// [gapplication-example-cmdline2.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline2.c)
//
// If handling the commandline requires a lot of work, it may be better to defer
// it. |[<!-- language="C" --> static gboolean my_cmdline_handler (gpointer
// data) { GApplicationCommandLine *cmdline = data;
//
// // do the heavy lifting in an idle
//
// g_application_command_line_set_exit_status (cmdline, 0); g_object_unref
// (cmdline); // this releases the application
//
// return G_SOURCE_REMOVE; }
//
// static int command_line (GApplication *application, GApplicationCommandLine
// *cmdline) { // keep the application running until we are done with this
// commandline g_application_hold (application);
//
// g_object_set_data_full (G_OBJECT (cmdline), "application", application,
// (GDestroyNotify)g_application_release);
//
// g_object_ref (cmdline); g_idle_add (my_cmdline_handler, cmdline);
//
// return 0; } ]| In this example the commandline is not completely handled
// before the #GApplication::command-line handler returns. Instead, we keep a
// reference to the CommandLine object and handle it later (in this example, in
// an idle). Note that it is necessary to hold the application until you are
// done with the commandline.
//
// The complete example can be found here:
// [gapplication-example-cmdline3.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline3.c)
type ApplicationCommandLine struct {
	*externglib.Object
}

func wrapApplicationCommandLine(obj *glib.Object) *ApplicationCommandLine {
	return &ApplicationCommandLine{*externglib.Object{obj}}
}

func marshalApplicationCommandLine(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// BufferedInputStream: buffered input stream implements InputStream and
// provides for buffered reads.
//
// By default, InputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered input stream, use g_buffered_input_stream_new(), or
// g_buffered_input_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_input_stream_get_buffer_size(). To change the size of a buffered
// input stream's buffer, use g_buffered_input_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedInputStream struct {
	FilterInputStream
}

func wrapBufferedInputStream(obj *glib.Object) *BufferedInputStream {
	return &BufferedInputStream{FilterInputStream{InputStream{*externglib.Object{obj}}}}
}

func marshalBufferedInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// BufferedOutputStream: buffered output stream implements OutputStream and
// provides for buffered writes.
//
// By default, OutputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered output stream, use g_buffered_output_stream_new(), or
// g_buffered_output_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_output_stream_get_buffer_size(). To change the size of a buffered
// output stream's buffer, use g_buffered_output_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedOutputStream struct {
	FilterOutputStream
}

func wrapBufferedOutputStream(obj *glib.Object) *BufferedOutputStream {
	return &BufferedOutputStream{FilterOutputStream{OutputStream{*externglib.Object{obj}}}}
}

func marshalBufferedOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// BytesIcon: GBytesIcon specifies an image held in memory in a common format
// (usually png) to be used as icon.
type BytesIcon struct {
	*externglib.Object
}

func wrapBytesIcon(obj *glib.Object) *BytesIcon {
	return &BytesIcon{*externglib.Object{obj}}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Cancellable: GCancellable is a thread-safe operation cancellation stack used
// throughout GIO to allow for cancellation of synchronous and asynchronous
// operations.
type Cancellable struct {
	*externglib.Object
}

func wrapCancellable(obj *glib.Object) *Cancellable {
	return &Cancellable{*externglib.Object{obj}}
}

func marshalCancellable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// CharsetConverter: GCharsetConverter is an implementation of #GConverter based
// on GIConv.
type CharsetConverter struct {
	*externglib.Object
}

func wrapCharsetConverter(obj *glib.Object) *CharsetConverter {
	return &CharsetConverter{*externglib.Object{obj}}
}

func marshalCharsetConverter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ConverterInputStream: converter input stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, InputStream implements InputStream.
type ConverterInputStream struct {
	FilterInputStream
}

func wrapConverterInputStream(obj *glib.Object) *ConverterInputStream {
	return &ConverterInputStream{FilterInputStream{InputStream{*externglib.Object{obj}}}}
}

func marshalConverterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ConverterOutputStream: converter output stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, OutputStream implements OutputStream.
type ConverterOutputStream struct {
	FilterOutputStream
}

func wrapConverterOutputStream(obj *glib.Object) *ConverterOutputStream {
	return &ConverterOutputStream{FilterOutputStream{OutputStream{*externglib.Object{obj}}}}
}

func marshalConverterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Credentials: the #GCredentials type is a reference-counted wrapper for native
// credentials. This information is typically used for identifying,
// authenticating and authorizing other processes.
//
// Some operating systems supports looking up the credentials of the remote peer
// of a communication endpoint - see e.g. g_socket_get_credentials().
//
// Some operating systems supports securely sending and receiving credentials
// over a Unix Domain Socket, see CredentialsMessage,
// g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials() for details.
//
// On Linux, the native credential type is a `struct ucred` - see the unix(7)
// man page for details. This corresponds to G_CREDENTIALS_TYPE_LINUX_UCRED.
//
// On Apple operating systems (including iOS, tvOS, and macOS), the native
// credential type is a `struct xucred`. This corresponds to
// G_CREDENTIALS_TYPE_APPLE_XUCRED.
//
// On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is
// a `struct cmsgcred`. This corresponds to G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
//
// On NetBSD, the native credential type is a `struct unpcbid`. This corresponds
// to G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
//
// On OpenBSD, the native credential type is a `struct sockpeercred`. This
// corresponds to G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
//
// On Solaris (including OpenSolaris and its derivatives), the native credential
// type is a `ucred_t`. This corresponds to G_CREDENTIALS_TYPE_SOLARIS_UCRED.
type Credentials struct {
	*externglib.Object
}

func wrapCredentials(obj *glib.Object) *Credentials {
	return &Credentials{*externglib.Object{obj}}
}

func marshalCredentials(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusActionGroup: GDBusActionGroup is an implementation of the Group interface
// that can be used as a proxy for an action group that is exported over D-Bus
// with g_dbus_connection_export_action_group().
type DBusActionGroup struct {
	*externglib.Object
}

func wrapDBusActionGroup(obj *glib.Object) *DBusActionGroup {
	return &DBusActionGroup{*externglib.Object{obj}}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_allow_mechanism (GDBusAuthObserver *observer,
//                        const gchar       *mechanism,
//                        gpointer           user_data)
//    {
//      if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
//        {
//          return TRUE;
//        }
//
//      return FALSE;
//    }
//
//
// Controlling Authorization {#auth-observer}
//
// By default, a BusServer or server-side BusConnection will accept connections
// from any successfully authenticated user (but not from anonymous connections
// using the `ANONYMOUS` mechanism). If you only want to allow D-Bus connections
// from processes owned by the same uid as the server, you would use a signal
// handler like the following:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
//
type DBusAuthObserver struct {
	*externglib.Object
}

func wrapDBusAuthObserver(obj *glib.Object) *DBusAuthObserver {
	return &DBusAuthObserver{*externglib.Object{obj}}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
// An example D-Bus server {#gdbus-server}
//
// Here is an example for a D-Bus server:
// [gdbus-example-server.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
// An example for exporting a subtree {#gdbus-subtree-server}
//
// Here is an example for exporting a subtree:
// [gdbus-example-subtree.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
// An example for file descriptor passing {#gdbus-unix-fd-client}
//
// Here is an example for passing UNIX file descriptors:
// [gdbus-unix-fd-client.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
// An example for exporting a GObject {#gdbus-export}
//
// Here is an example for exporting a #GObject:
// [gdbus-example-export.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection struct {
	*externglib.Object
}

func wrapDBusConnection(obj *glib.Object) *DBusConnection {
	return &DBusConnection{*externglib.Object{obj}}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusInterfaceSkeleton: abstract base class for D-Bus interfaces on the
// service side.
type DBusInterfaceSkeleton struct {
	*externglib.Object
}

func wrapDBusInterfaceSkeleton(obj *glib.Object) *DBusInterfaceSkeleton {
	return &DBusInterfaceSkeleton{*externglib.Object{obj}}
}

func marshalDBusInterfaceSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusMenuModel: GDBusMenuModel is an implementation of Model that can be used
// as a proxy for a menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel struct {
	MenuModel
}

func wrapDBusMenuModel(obj *glib.Object) *DBusMenuModel {
	return &DBusMenuModel{MenuModel{*externglib.Object{obj}}}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusMessage: a type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage struct {
	*externglib.Object
}

func wrapDBusMessage(obj *glib.Object) *DBusMessage {
	return &DBusMessage{*externglib.Object{obj}}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusMethodInvocation: instances of the BusMethodInvocation class are used
// when handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation struct {
	*externglib.Object
}

func wrapDBusMethodInvocation(obj *glib.Object) *DBusMethodInvocation {
	return &DBusMethodInvocation{*externglib.Object{obj}}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusObjectManagerClient: GDBusObjectManagerClient is used to create, monitor
// and delete object proxies for remote objects exported by a
// BusObjectManagerServer (or any code implementing the
// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
//
// Once an instance of this type has been created, you can connect to the
// BusObjectManager::object-added and BusObjectManager::object-removed signals
// and inspect the BusObjectProxy objects returned by
// g_dbus_object_manager_get_objects().
//
// If the name for a BusObjectManagerClient is not owned by anyone at object
// construction time, the default behavior is to request the message bus to
// launch an owner for the name. This behavior can be disabled using the
// G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START flag. It's also worth
// noting that this only works if the name of interest is activatable in the
// first place. E.g. in some cases it is not possible to launch an owner for the
// requested name. In this case, BusObjectManagerClient object construction
// still succeeds but there will be no object proxies (e.g.
// g_dbus_object_manager_get_objects() returns the empty list) and the
// BusObjectManagerClient:name-owner property is nil.
//
// The owner of the requested name can come and go (for example consider a
// system service being restarted)  BusObjectManagerClient handles this case
// too; simply connect to the #GObject::notify signal to watch for changes on
// the BusObjectManagerClient:name-owner property. When the name owner vanishes,
// the behavior is that BusObjectManagerClient:name-owner is set to nil (this
// includes emission of the #GObject::notify signal) and then
// BusObjectManager::object-removed signals are synthesized for all currently
// existing object proxies. Since BusObjectManagerClient:name-owner is nil when
// this happens, you can use this information to disambiguate a synthesized
// signal from a genuine signal caused by object removal on the remote
// BusObjectManager. Similarly, when a new name owner appears,
// BusObjectManager::object-added signals are synthesized while
// BusObjectManagerClient:name-owner is still nil. Only when all object proxies
// have been added, the BusObjectManagerClient:name-owner is set to the new name
// owner (this includes emission of the #GObject::notify signal). Furthermore,
// you are guaranteed that BusObjectManagerClient:name-owner will alternate
// between a name owner (e.g. `:1.42`) and nil even in the case where the name
// of interest is atomically replaced
//
// Ultimately, BusObjectManagerClient is used to obtain BusProxy instances. All
// signals (including the org.freedesktop.DBus.Properties::PropertiesChanged
// signal) delivered to BusProxy instances are guaranteed to originate from the
// name owner. This guarantee along with the behavior described above, means
// that certain race conditions including the "half the proxy is from the old
// owner and the other half is from the new owner" problem cannot happen.
//
// To avoid having the application connect to signals on the returned
// BusObjectProxy and BusProxy objects, the BusObject::interface-added,
// BusObject::interface-removed, BusProxy::g-properties-changed and
// BusProxy::g-signal signals are also emitted on the BusObjectManagerClient
// instance managing these objects. The signals emitted are
// BusObjectManager::interface-added, BusObjectManager::interface-removed,
// BusObjectManagerClient::interface-proxy-properties-changed and
// BusObjectManagerClient::interface-proxy-signal.
//
// Note that all callbacks and signals are emitted in the [thread-default main
// context][g-main-context-push-thread-default] that the BusObjectManagerClient
// object was constructed in. Additionally, the BusObjectProxy and BusProxy
// objects originating from the BusObjectManagerClient object will be created in
// the same context and, consequently, will deliver signals in the same main
// loop.
type DBusObjectManagerClient struct {
	*externglib.Object
}

func wrapDBusObjectManagerClient(obj *glib.Object) *DBusObjectManagerClient {
	return &DBusObjectManagerClient{*externglib.Object{obj}}
}

func marshalDBusObjectManagerClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusObjectManagerServer: GDBusObjectManagerServer is used to export BusObject
// instances using the standardized
// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface. For example, remote D-Bus clients can get all objects and
// properties in a single call. Additionally, any change in the object hierarchy
// is broadcast using signals. This means that D-Bus clients can keep caches up
// to date by only listening to D-Bus signals.
//
// The recommended path to export an object manager at is the path form of the
// well-known name of a D-Bus service, or below. For example, if a D-Bus service
// is available at the well-known name `net.example.ExampleService1`, the object
// manager should typically be exported at `/net/example/ExampleService1`, or
// below (to allow for multiple object managers in a service).
//
// It is supported, but not recommended, to export an object manager at the root
// path, `/`.
//
// See BusObjectManagerClient for the client-side code that is intended to be
// used with BusObjectManagerServer or any D-Bus object implementing the
// org.freedesktop.DBus.ObjectManager interface.
type DBusObjectManagerServer struct {
	*externglib.Object
}

func wrapDBusObjectManagerServer(obj *glib.Object) *DBusObjectManagerServer {
	return &DBusObjectManagerServer{*externglib.Object{obj}}
}

func marshalDBusObjectManagerServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusObjectProxy: a BusObjectProxy is an object used to represent a remote
// object with one or more D-Bus interfaces. Normally, you don't instantiate a
// BusObjectProxy yourself - typically BusObjectManagerClient is used to obtain
// it.
type DBusObjectProxy struct {
	*externglib.Object
}

func wrapDBusObjectProxy(obj *glib.Object) *DBusObjectProxy {
	return &DBusObjectProxy{*externglib.Object{obj}}
}

func marshalDBusObjectProxy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusObjectSkeleton: a BusObjectSkeleton instance is essentially a group of
// D-Bus interfaces. The set of exported interfaces on the object may be dynamic
// and change at runtime.
//
// This type is intended to be used with BusObjectManager.
type DBusObjectSkeleton struct {
	*externglib.Object
}

func wrapDBusObjectSkeleton(obj *glib.Object) *DBusObjectSkeleton {
	return &DBusObjectSkeleton{*externglib.Object{obj}}
}

func marshalDBusObjectSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusProxy: GDBusProxy is a base class used for proxies to access a D-Bus
// interface on a remote object. A BusProxy can be constructed for both
// well-known and unique names.
//
// By default, BusProxy will cache all properties (and listen to changes) of the
// remote object, and proxy all signals that get emitted. This behaviour can be
// changed by passing suitable BusProxyFlags when the proxy is created. If the
// proxy is for a well-known name, the property cache is flushed when the name
// owner vanishes and reloaded when a name owner appears.
//
// The unique name owner of the proxy's name is tracked and can be read from
// BusProxy:g-name-owner. Connect to the #GObject::notify signal to get notified
// of changes. Additionally, only signals and property changes emitted from the
// current name owner are considered and calls are always sent to the current
// name owner. This avoids a number of race conditions when the name is lost by
// one owner and claimed by another. However, if no name owner currently exists,
// then calls will be sent to the well-known name which may result in the
// message bus launching an owner (unless G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// is set).
//
// The generic BusProxy::g-properties-changed and BusProxy::g-signal signals are
// not very convenient to work with. Therefore, the recommended way of working
// with proxies is to subclass BusProxy, and have more natural properties and
// signals in your derived class. This [example][gdbus-example-gdbus-codegen]
// shows how this can easily be done using the [gdbus-codegen][gdbus-codegen]
// tool.
//
// A BusProxy instance can be used from multiple threads but note that all
// signals (e.g. BusProxy::g-signal, BusProxy::g-properties-changed and
// #GObject::notify) are emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread where the instance
// was constructed.
//
// An example using a proxy for a well-known name can be found in
// [gdbus-example-watch-proxy.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c)
type DBusProxy struct {
	*externglib.Object
}

func wrapDBusProxy(obj *glib.Object) *DBusProxy {
	return &DBusProxy{*externglib.Object{obj}}
}

func marshalDBusProxy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DBusServer: GDBusServer is a helper for listening to and accepting D-Bus
// connections. This can be used to create a new D-Bus server, allowing two
// peers to use the D-Bus protocol for their own specialized communication. A
// server instance provided in this way will not perform message routing or
// implement the org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with G-DBus can be found in
// [gdbus-example-peer.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer.
type DBusServer struct {
	*externglib.Object
}

func wrapDBusServer(obj *glib.Object) *DBusServer {
	return &DBusServer{*externglib.Object{obj}}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DataInputStream: data input stream implements Stream and includes functions
// for reading structured data directly from a binary input stream.
type DataInputStream struct {
	BufferedInputStream
}

func wrapDataInputStream(obj *glib.Object) *DataInputStream {
	return &DataInputStream{BufferedInputStream{FilterInputStream{InputStream{*externglib.Object{obj}}}}}
}

func marshalDataInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DataOutputStream: data output stream implements Stream and includes functions
// for writing data directly to an output stream.
type DataOutputStream struct {
	FilterOutputStream
}

func wrapDataOutputStream(obj *glib.Object) *DataOutputStream {
	return &DataOutputStream{FilterOutputStream{OutputStream{*externglib.Object{obj}}}}
}

func marshalDataOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DesktopAppInfo: GDesktopAppInfo is an implementation of Info based on desktop
// files.
//
// Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type DesktopAppInfo struct {
	*externglib.Object
}

func wrapDesktopAppInfo(obj *glib.Object) *DesktopAppInfo {
	return &DesktopAppInfo{*externglib.Object{obj}}
}

func marshalDesktopAppInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Emblem: GEmblem is an implementation of #GIcon that supports having an
// emblem, which is an icon with additional properties. It can than be added to
// a Icon.
//
// Currently, only metainformation about the emblem's origin is supported. More
// may be added in the future.
type Emblem struct {
	*externglib.Object
}

func wrapEmblem(obj *glib.Object) *Emblem {
	return &Emblem{*externglib.Object{obj}}
}

func marshalEmblem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// EmblemedIcon: GEmblemedIcon is an implementation of #GIcon that supports
// adding an emblem to an icon. Adding multiple emblems to an icon is ensured
// via g_emblemed_icon_add_emblem().
//
// Note that Icon allows no control over the position of the emblems. See also
// #GEmblem for more information.
type EmblemedIcon struct {
	*externglib.Object
}

func wrapEmblemedIcon(obj *glib.Object) *EmblemedIcon {
	return &EmblemedIcon{*externglib.Object{obj}}
}

func marshalEmblemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileEnumerator: GFileEnumerator allows you to operate on a set of #GFiles,
// returning a Info structure for each file enumerated (e.g.
// g_file_enumerate_children() will return a Enumerator for each of the children
// within a directory).
//
// To get the next file's information from a Enumerator, use
// g_file_enumerator_next_file() or its asynchronous version,
// g_file_enumerator_next_files_async(). Note that the asynchronous version will
// return a list of Infos, whereas the synchronous will only return the next
// file in the enumerator.
//
// The ordering of returned files is unspecified for non-Unix platforms; for
// more information, see g_dir_read_name(). On Unix, when operating on local
// files, returned files will be sorted by inode number. Effectively you can
// assume that the ordering of returned files will be stable between successive
// calls (and applications) assuming the directory is unchanged.
//
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your application code.
//
// To close a Enumerator, use g_file_enumerator_close(), or its asynchronous
// version, g_file_enumerator_close_async(). Once a Enumerator is closed, no
// further actions may be performed on it, and it should be freed with
// g_object_unref().
type FileEnumerator struct {
	*externglib.Object
}

func wrapFileEnumerator(obj *glib.Object) *FileEnumerator {
	return &FileEnumerator{*externglib.Object{obj}}
}

func marshalFileEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileIOStream: GFileIOStream provides io streams that both read and write to
// the same file handle.
//
// GFileIOStream implements #GSeekable, which allows the io stream to jump to
// arbitrary positions in the file and to truncate the file, provided the
// filesystem of the file supports these operations.
//
// To find the position of a file io stream, use g_seekable_tell().
//
// To find out if a file io stream supports seeking, use g_seekable_can_seek().
// To position a file io stream, use g_seekable_seek(). To find out if a file io
// stream supports truncating, use g_seekable_can_truncate(). To truncate a file
// io stream, use g_seekable_truncate().
//
// The default implementation of all the IOStream operations and the
// implementation of #GSeekable just call into the same operations on the output
// stream.
type FileIOStream struct {
	IOStream
}

func wrapFileIOStream(obj *glib.Object) *FileIOStream {
	return &FileIOStream{IOStream{*externglib.Object{obj}}}
}

func marshalFileIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileIcon: GFileIcon specifies an icon by pointing to an image file to be used
// as icon.
type FileIcon struct {
	*externglib.Object
}

func wrapFileIcon(obj *glib.Object) *FileIcon {
	return &FileIcon{*externglib.Object{obj}}
}

func marshalFileIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileInfo: functionality for manipulating basic metadata for files. Info
// implements methods for getting information that all files should contain, and
// allows for manipulation of extended attributes.
//
// See [GFileAttribute][gio-GFileAttribute] for more information on how GIO
// handles file attributes.
//
// To obtain a Info for a #GFile, use g_file_query_info() (or its async
// variant). To obtain a Info for a file input or output stream, use
// g_file_input_stream_query_info() or g_file_output_stream_query_info() (or
// their async variants).
//
// To change the actual attributes of a file, you should then set the attribute
// in the Info and call g_file_set_attributes_from_info() or
// g_file_set_attributes_async() on a GFile.
//
// However, not all attributes can be changed in the file. For instance, the
// actual size of a file cannot be changed via g_file_info_set_size(). You may
// call g_file_query_settable_attributes() and
// g_file_query_writable_namespaces() to discover the settable attributes of a
// particular file at runtime.
//
// AttributeMatcher allows for searching through a Info for attributes.
type FileInfo struct {
	*externglib.Object
}

func wrapFileInfo(obj *glib.Object) *FileInfo {
	return &FileInfo{*externglib.Object{obj}}
}

func marshalFileInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileInputStream: GFileInputStream provides input streams that take their
// content from a file.
//
// GFileInputStream implements #GSeekable, which allows the input stream to jump
// to arbitrary positions in the file, provided the filesystem of the file
// allows it. To find the position of a file input stream, use
// g_seekable_tell(). To find out if a file input stream supports seeking, use
// g_seekable_can_seek(). To position a file input stream, use
// g_seekable_seek().
type FileInputStream struct {
	InputStream
}

func wrapFileInputStream(obj *glib.Object) *FileInputStream {
	return &FileInputStream{InputStream{*externglib.Object{obj}}}
}

func marshalFileInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileMonitor: monitors a file or directory for changes.
//
// To obtain a Monitor for a file or directory, use g_file_monitor(),
// g_file_monitor_file(), or g_file_monitor_directory().
//
// To get informed about changes to the file or directory you are monitoring,
// connect to the Monitor::changed signal. The signal will be emitted in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that the monitor was created in (though if the global default main
// context is blocked, this may cause notifications to be blocked even if the
// thread-default context is still running).
type FileMonitor struct {
	*externglib.Object
}

func wrapFileMonitor(obj *glib.Object) *FileMonitor {
	return &FileMonitor{*externglib.Object{obj}}
}

func marshalFileMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileOutputStream: GFileOutputStream provides output streams that write their
// content to a file.
//
// GFileOutputStream implements #GSeekable, which allows the output stream to
// jump to arbitrary positions in the file and to truncate the file, provided
// the filesystem of the file supports these operations.
//
// To find the position of a file output stream, use g_seekable_tell(). To find
// out if a file output stream supports seeking, use g_seekable_can_seek().To
// position a file output stream, use g_seekable_seek(). To find out if a file
// output stream supports truncating, use g_seekable_can_truncate(). To truncate
// a file output stream, use g_seekable_truncate().
type FileOutputStream struct {
	OutputStream
}

func wrapFileOutputStream(obj *glib.Object) *FileOutputStream {
	return &FileOutputStream{OutputStream{*externglib.Object{obj}}}
}

func marshalFileOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FilenameCompleter: completes partial file and directory names given a partial
// string by looking in the file system for clues. Can return a list of possible
// completion strings for widget implementations.
type FilenameCompleter struct {
	*externglib.Object
}

func wrapFilenameCompleter(obj *glib.Object) *FilenameCompleter {
	return &FilenameCompleter{*externglib.Object{obj}}
}

func marshalFilenameCompleter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FilterInputStream: base class for input stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterInputStream struct {
	InputStream
}

func wrapFilterInputStream(obj *glib.Object) *FilterInputStream {
	return &FilterInputStream{InputStream{*externglib.Object{obj}}}
}

func marshalFilterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FilterOutputStream: base class for output stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterOutputStream struct {
	OutputStream
}

func wrapFilterOutputStream(obj *glib.Object) *FilterOutputStream {
	return &FilterOutputStream{OutputStream{*externglib.Object{obj}}}
}

func marshalFilterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// IOStream: GIOStream represents an object that has both read and write
// streams. Generally the two streams act as separate input and output streams,
// but they share some common resources and state. For instance, for seekable
// streams, both streams may use the same position.
//
// Examples of OStream objects are Connection, which represents a two-way
// network connection; and IOStream, which represents a file handle opened in
// read-write mode.
//
// To do the actual reading and writing you need to get the substreams with
// g_io_stream_get_input_stream() and g_io_stream_get_output_stream().
//
// The OStream object owns the input and the output streams, not the other way
// around, so keeping the substreams alive will not keep the OStream object
// alive. If the OStream object is freed it will be closed, thus closing the
// substreams, so even if the substreams stay alive they will always return
// G_IO_ERROR_CLOSED for all operations.
//
// To close a stream use g_io_stream_close() which will close the common stream
// object and also the individual substreams. You can also close the substreams
// themselves. In most cases this only marks the substream as closed, so further
// I/O on it fails but common state in the OStream may still be open. However,
// some streams may support "half-closed" states where one direction of the
// stream is actually shut down.
//
// Operations on OStreams cannot be started while another operation on the
// OStream or its substreams is in progress. Specifically, an application can
// read from the Stream and write to the Stream simultaneously (either in
// separate threads, or as asynchronous operations in the same thread), but an
// application cannot start any OStream operation while there is a OStream,
// Stream or Stream operation in progress, and an application cant start any
// Stream or Stream operation while there is a OStream operation in progress.
//
// This is a product of individual stream operations being associated with a
// given Context (the thread-default context at the time the operation was
// started), rather than entire streams being associated with a single Context.
//
// GIO may run operations on OStreams from other (worker) threads, and this may
// be exposed to application code in the behaviour of wrapper streams, such as
// InputStream or Connection. With such wrapper APIs, application code may only
// run operations on the base (wrapped) stream when the wrapper stream is idle.
// Note that the semantics of such operations may not be well-defined due to the
// state the wrapper stream leaves the base stream in (though they are
// guaranteed not to crash).
type IOStream struct {
	*externglib.Object
}

func wrapIOStream(obj *glib.Object) *IOStream {
	return &IOStream{*externglib.Object{obj}}
}

func marshalIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// InetAddress: GInetAddress represents an IPv4 or IPv6 internet address. Use
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to look up
// the Address for a hostname. Use g_resolver_lookup_by_address() or
// g_resolver_lookup_by_address_async() to look up the hostname for a Address.
//
// To actually connect to a remote host, you will need a SocketAddress (which
// includes a Address as well as a port number).
type InetAddress struct {
	*externglib.Object
}

func wrapInetAddress(obj *glib.Object) *InetAddress {
	return &InetAddress{*externglib.Object{obj}}
}

func marshalInetAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// InetAddressMask: GInetAddressMask represents a range of IPv4 or IPv6
// addresses described by a base address and a length indicating how many bits
// of the base address are relevant for matching purposes. These are often given
// in string form. Eg, "10.0.0.0/8", or "fe80::/10".
type InetAddressMask struct {
	*externglib.Object
}

func wrapInetAddressMask(obj *glib.Object) *InetAddressMask {
	return &InetAddressMask{*externglib.Object{obj}}
}

func marshalInetAddressMask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// InetSocketAddress: an IPv4 or IPv6 socket address; that is, the combination
// of a Address and a port number.
type InetSocketAddress struct {
	SocketAddress
}

func wrapInetSocketAddress(obj *glib.Object) *InetSocketAddress {
	return &InetSocketAddress{SocketAddress{*externglib.Object{obj}}}
}

func marshalInetSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// InputStream: GInputStream has functions to read from a stream
// (g_input_stream_read()), to close a stream (g_input_stream_close()) and to
// skip some content (g_input_stream_skip()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type InputStream struct {
	*externglib.Object
}

func wrapInputStream(obj *glib.Object) *InputStream {
	return &InputStream{*externglib.Object{obj}}
}

func marshalInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ListStore: GListStore is a simple implementation of Model that stores all
// items in memory.
//
// It provides insertions, deletions, and lookups in logarithmic time with a
// fast path for the common case of iterating the list linearly.
type ListStore struct {
	*externglib.Object
}

func wrapListStore(obj *glib.Object) *ListStore {
	return &ListStore{*externglib.Object{obj}}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MemoryInputStream: GMemoryInputStream is a class for using arbitrary memory
// chunks as input for GIO streaming input operations.
//
// As of GLib 2.34, InputStream implements InputStream.
type MemoryInputStream struct {
	InputStream
}

func wrapMemoryInputStream(obj *glib.Object) *MemoryInputStream {
	return &MemoryInputStream{InputStream{*externglib.Object{obj}}}
}

func marshalMemoryInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MemoryOutputStream: GMemoryOutputStream is a class for using arbitrary memory
// chunks as output for GIO streaming output operations.
//
// As of GLib 2.34, OutputStream trivially implements OutputStream: it always
// polls as ready.
type MemoryOutputStream struct {
	OutputStream
}

func wrapMemoryOutputStream(obj *glib.Object) *MemoryOutputStream {
	return &MemoryOutputStream{OutputStream{*externglib.Object{obj}}}
}

func marshalMemoryOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Menu: GMenu is a simple implementation of Model. You populate a #GMenu by
// adding Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu struct {
	MenuModel
}

func wrapMenu(obj *glib.Object) *Menu {
	return &Menu{MenuModel{*externglib.Object{obj}}}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MenuAttributeIter: GMenuAttributeIter is an opaque structure type. You must
// access it using the functions below.
type MenuAttributeIter struct {
	*externglib.Object
}

func wrapMenuAttributeIter(obj *glib.Object) *MenuAttributeIter {
	return &MenuAttributeIter{*externglib.Object{obj}}
}

func marshalMenuAttributeIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MenuItem: GMenuItem is an opaque structure type. You must access it using the
// functions below.
type MenuItem struct {
	*externglib.Object
}

func wrapMenuItem(obj *glib.Object) *MenuItem {
	return &MenuItem{*externglib.Object{obj}}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MenuLinkIter: GMenuLinkIter is an opaque structure type. You must access it
// using the functions below.
type MenuLinkIter struct {
	*externglib.Object
}

func wrapMenuLinkIter(obj *glib.Object) *MenuLinkIter {
	return &MenuLinkIter{*externglib.Object{obj}}
}

func marshalMenuLinkIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MenuModel: GMenuModel represents the contents of a menu -- an ordered list of
// menu items. The items are associated with actions, which can be activated
// through them. Items can be grouped in sections, and may have submenus
// associated with them. Both items and sections usually have some
// representation data, such as labels or icons. The type of the associated
// action (ie whether it is stateful, and what kind of state it has) can
// influence the representation of the item.
//
// The conceptual model of menus in Model is hierarchical: sections and submenus
// are again represented by Models. Menus themselves do not define their own
// roles. Rather, the role of a particular Model is defined by the item that
// references it (or, in the case of the 'root' menu, is defined by the context
// in which it is used).
//
// As an example, consider the visible portions of this menu:
//
// An example menu {#menu-example}
//
// ![](menu-example.png)
//
// There are 8 "menus" visible in the screenshot: one menubar, two submenus and
// 5 sections:
//
// - the toplevel menubar (containing 4 items) - the View submenu (containing 3
// sections) - the first section of the View submenu (containing 2 items) - the
// second section of the View submenu (containing 1 item) - the final section of
// the View submenu (containing 1 item) - the Highlight Mode submenu (containing
// 2 sections) - the Sources section (containing 2 items) - the Markup section
// (containing 2 items)
//
// The [example][menu-model] illustrates the conceptual connection between these
// 8 menus. Each large block in the figure represents a menu and the smaller
// blocks within the large block represent items in that menu. Some items
// contain references to other menus.
//
// A menu example {#menu-model}
//
// ![](menu-model.png)
//
// Notice that the separators visible in the [example][menu-example] appear
// nowhere in the [menu model][menu-model]. This is because separators are not
// explicitly represented in the menu model. Instead, a separator is inserted
// between any two non-empty sections of a menu. Section items can have labels
// just like any other item. In that case, a display system may show a section
// header instead of a separator.
//
// The motivation for this abstract model of application controls is that modern
// user interfaces tend to make these controls available outside the
// application. Examples include global menus, jumplists, dash boards, etc. To
// support such uses, it is necessary to 'export' information about actions and
// their representation in menus, which is exactly what the [GActionGroup
// exporter][gio-GActionGroup-exporter] and the [GMenuModel
// exporter][gio-GMenuModel-exporter] do for Group and Model. The client-side
// counterparts to make use of the exported information are BusActionGroup and
// BusMenuModel.
//
// The API of Model is very generic, with iterators for the attributes and links
// of an item, see g_menu_model_iterate_item_attributes() and
// g_menu_model_iterate_item_links(). The 'standard' attributes and link types
// have predefined names: G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, G_MENU_LINK_SECTION and G_MENU_LINK_SUBMENU.
//
// Items in a Model represent active controls if they refer to an action that
// can get activated when the user interacts with the menu item. The reference
// to the action is encoded by the string id in the G_MENU_ATTRIBUTE_ACTION
// attribute. An action id uniquely identifies an action in an action group.
// Which action group(s) provide actions depends on the context in which the
// menu model is used. E.g. when the model is exported as the application menu
// of a Application, actions can be application-wide or window-specific (and
// thus come from two different action groups). By convention, the
// application-wide actions have names that start with "app.", while the names
// of window-specific actions start with "win.".
//
// While a wide variety of stateful actions is possible, the following is the
// minimum that is expected to be supported by all users of exported menu
// information: - an action with no parameter type and no state - an action with
// no parameter type and boolean state - an action with string parameter type
// and string state
//
//
// Stateless
//
// A stateless action typically corresponds to an ordinary menu item.
//
// Selecting such a menu item will activate the action (with no parameter).
//
//
// Boolean State
//
// An action with a boolean state will most typically be used with a "toggle" or
// "switch" menu item. The state can be set directly, but activating the action
// (with no parameter) results in the state being toggled.
//
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as "checked" when the state is true.
//
//
// String Parameter and State
//
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of radio
// menu items. Activating the action with a string parameter is equivalent to
// setting that parameter as the state.
//
// Radio menu items, in addition to being associated with the action, will have
// a target value. Selecting that menu item will result in activation of the
// action with the target value as the parameter. The menu item should be
// rendered as "selected" when the state of the action is equal to the target
// value of the menu item.
type MenuModel struct {
	*externglib.Object
}

func wrapMenuModel(obj *glib.Object) *MenuModel {
	return &MenuModel{*externglib.Object{obj}}
}

func marshalMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MountOperation: GMountOperation provides a mechanism for interacting with the
// user. It can be used for authenticating mountable operations, such as loop
// mounting files, hard drive partitions or server locations. It can also be
// used to ask the user questions or show a list of applications preventing
// unmount or eject operations from completing.
//
// Note that Operation is used for more than just #GMount objects  for example
// it is also used in g_drive_start() and g_drive_stop().
//
// Users should instantiate a subclass of this that implements all the various
// callbacks to show the required dialogs, such as MountOperation. If no user
// interaction is desired (for example when automounting filesystems at login
// time), usually nil can be passed, see each method taking a Operation for
// details.
//
// The term TCRYPT is used to mean compatible with TrueCrypt and VeraCrypt.
// [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system
// for encrypting file containers, partitions or whole disks, typically used
// with Windows. [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of
// TrueCrypt with various improvements and auditing fixes.
type MountOperation struct {
	*externglib.Object
}

func wrapMountOperation(obj *glib.Object) *MountOperation {
	return &MountOperation{*externglib.Object{obj}}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// NativeSocketAddress: a socket address of some unknown native type.
type NativeSocketAddress struct {
	SocketAddress
}

func wrapNativeSocketAddress(obj *glib.Object) *NativeSocketAddress {
	return &NativeSocketAddress{SocketAddress{*externglib.Object{obj}}}
}

func marshalNativeSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

type NativeVolumeMonitor struct {
	VolumeMonitor
}

func wrapNativeVolumeMonitor(obj *glib.Object) *NativeVolumeMonitor {
	return &NativeVolumeMonitor{VolumeMonitor{*externglib.Object{obj}}}
}

func marshalNativeVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// NetworkAddress: GNetworkAddress provides an easy way to resolve a hostname
// and then attempt to connect to that host, handling the possibility of
// multiple IP addresses and multiple address families.
//
// The enumeration results of resolved addresses *may* be cached as long as this
// object is kept alive which may have unexpected results if alive for too long.
//
// See Connectable for an example of using the connectable interface.
type NetworkAddress struct {
	*externglib.Object
}

func wrapNetworkAddress(obj *glib.Object) *NetworkAddress {
	return &NetworkAddress{*externglib.Object{obj}}
}

func marshalNetworkAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// NetworkService: like Address does with hostnames, Service provides an easy
// way to resolve a SRV record, and then attempt to connect to one of the hosts
// that implements that service, handling service priority/weighting, multiple
// IP addresses, and multiple address families.
//
// See Target for more information about SRV records, and see Connectable for an
// example of using the connectable interface.
type NetworkService struct {
	*externglib.Object
}

func wrapNetworkService(obj *glib.Object) *NetworkService {
	return &NetworkService{*externglib.Object{obj}}
}

func marshalNetworkService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Notification: GNotification is a mechanism for creating a notification to be
// shown to the user -- typically as a pop-up notification presented by the
// desktop environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification struct {
	*externglib.Object
}

func wrapNotification(obj *glib.Object) *Notification {
	return &Notification{*externglib.Object{obj}}
}

func marshalNotification(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// OutputStream: GOutputStream has functions to write to a stream
// (g_output_stream_write()), to close a stream (g_output_stream_close()) and to
// flush pending writes (g_output_stream_flush()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type OutputStream struct {
	*externglib.Object
}

func wrapOutputStream(obj *glib.Object) *OutputStream {
	return &OutputStream{*externglib.Object{obj}}
}

func marshalOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Permission: a #GPermission represents the status of the caller's permission
// to perform a certain action.
//
// You can query if the action is currently allowed and if it is possible to
// acquire the permission so that the action will be allowed in the future.
//
// There is also an API to actually acquire the permission and one to release
// it.
//
// As an example, a #GPermission might represent the ability for the user to
// write to a #GSettings object. This #GPermission object could then be used to
// decide if it is appropriate to show a "Click here to unlock" button in a
// dialog and to provide the mechanism to invoke when that button is clicked.
type Permission struct {
	*externglib.Object
}

func wrapPermission(obj *glib.Object) *Permission {
	return &Permission{*externglib.Object{obj}}
}

func marshalPermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// PropertyAction: a Action is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction struct {
	*externglib.Object
}

func wrapPropertyAction(obj *glib.Object) *PropertyAction {
	return &PropertyAction{*externglib.Object{obj}}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ProxyAddress: support for proxied SocketAddress.
type ProxyAddress struct {
	InetSocketAddress
}

func wrapProxyAddress(obj *glib.Object) *ProxyAddress {
	return &ProxyAddress{InetSocketAddress{SocketAddress{*externglib.Object{obj}}}}
}

func marshalProxyAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ProxyAddressEnumerator: GProxyAddressEnumerator is a wrapper around
// AddressEnumerator which takes the Address instances returned by the
// AddressEnumerator and wraps them in Address instances, using the given
// AddressEnumerator:proxy-resolver.
//
// This enumerator will be returned (for example, by
// g_socket_connectable_enumerate()) as appropriate when a proxy is configured;
// there should be no need to manually wrap a AddressEnumerator instance with
// one.
type ProxyAddressEnumerator struct {
	SocketAddressEnumerator
}

func wrapProxyAddressEnumerator(obj *glib.Object) *ProxyAddressEnumerator {
	return &ProxyAddressEnumerator{SocketAddressEnumerator{*externglib.Object{obj}}}
}

func marshalProxyAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Resolver: GResolver provides cancellable synchronous and asynchronous DNS
// resolution, for hostnames (g_resolver_lookup_by_address(),
// g_resolver_lookup_by_name() and their async variants) and SRV (service)
// records (g_resolver_lookup_service()).
//
// Address and Service provide wrappers around #GResolver functionality that
// also implement Connectable, making it easy to connect to a remote
// host/service.
type Resolver struct {
	*externglib.Object
}

func wrapResolver(obj *glib.Object) *Resolver {
	return &Resolver{*externglib.Object{obj}}
}

func marshalResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Settings: the #GSettings class provides a convenient API for storing and
// retrieving application settings.
//
// Reads and writes can be considered to be non-blocking. Reading settings with
// #GSettings is typically extremely fast: on approximately the same order of
// magnitude (but slower than) a Table lookup. Writing settings is also
// extremely fast in terms of time to return to your application, but can be
// extremely expensive for other threads and other processes. Many settings
// backends (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings a lot of
// work can be avoided. For dconf, the D-Bus service doesn't even need to be
// started in this case. For this reason, you should only ever modify #GSettings
// keys in response to explicit user action. Particular care should be paid to
// ensure that modifications are not made during startup -- for example, when
// setting the initial value of preferences widgets. The built-in
// g_settings_bind() functionality is careful not to write settings in response
// to notify signals as a result of modifications that it makes to widgets.
//
// When creating a GSettings instance, you have to specify a schema that
// describes the keys in your settings and their types and default values, as
// well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings are
// stored in the conceptual global tree of settings. However, schemas can also
// be '[relocatable][gsettings-relocatable]', i.e. not equipped with a fixed
// path. This is useful e.g. when the schema describes an 'account', and you
// want to be able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character ('/') and must
// not contain two sequential slash characters. Paths should be chosen based on
// a domain name associated with the program or library to which the settings
// belong. Examples of paths are "/org/gtk/settings/file-chooser/" and
// "/ca/desrt/dconf-editor/". Paths should not start with "/apps/", "/desktop/"
// or "/system/" as they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not restrict
// keys to basic types like strings and numbers. GSettings stores values as
// #GVariant, and allows any Type for keys. Key names are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be localized,
// but the localized values are stored in gettext catalogs and looked up with
// the domain that is specified in the `gettext-domain` attribute of the
// <schemalist> or <schema> elements and the category that is specified in the
// `l10n` attribute of the <default> element. The string which is translated
// includes all text in the <default> element, including any surrounding
// quotation marks.
//
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the <default> element  it is recommended to
// add these comments to aid translators understand the meaning and implications
// of the default value. An optional translation `context` attribute can be set
// on the <default> element to disambiguate multiple defaults which use the same
// string.
//
//
//     <!-- Translators: A list of words which are not allowed to be typed, in
//          GVariant serialization syntax.
//          See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
//     <default l10n='messages' context='Banned words'>['bad', 'words']</default>
//
// Translations of default values must remain syntactically valid serialized
// #GVariants (e.g. retaining any surrounding quotation marks) or runtime errors
// will occur.
//
// GSettings uses schemas in a compact binary form that is created by the
// [glib-compile-schemas][glib-compile-schemas] utility. The input is a schema
// description in an XML format.
//
// A DTD for the gschema XML format can be found here:
// [gschema.dtd](https://git.gnome.org/browse/glib/tree/gio/gschema.dtd)
//
// The [glib-compile-schemas][glib-compile-schemas] tool expects schema files to
// have the extension `.gschema.xml`.
//
// At runtime, schemas are identified by their id (as specified in the id
// attribute of the <schema> element). The convention for schema ids is to use a
// dotted name, similar in style to a D-Bus bus name, e.g.
// "org.gnome.SessionManager". In particular, if the settings are for a specific
// service that owns a D-Bus bus name, the D-Bus bus name and schema id should
// match. For schemas which deal with settings not associated with one named
// application, the id should not use StudlyCaps, e.g.
// "org.gnome.font-rendering".
//
// In addition to #GVariant types, keys can have types that have enumerated
// types. These can be described by a <choice>, <enum> or <flags> element, as
// seen in the [example][schema-enumerated]. The underlying type of such a key
// is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
// g_settings_get_flags(), g_settings_set_flags() access the numeric values
// corresponding to the string value of enum and flags keys.
//
// An example for default value: |[ <schemalist> <schema id="org.gtk.Test"
// path="/org/gtk/Test/" gettext-domain="test">
//
// <key name="greeting" type="s"> <default l10n="messages">"Hello,
// earthlings"</default> <summary>A greeting</summary> <description> Greeting of
// the invading martians </description> </key>
//
// <key name="box" type="(ii)"> <default>(20,30)</default> </key>
//
// <key name="empty-string" type="s"> <default>""</default> <summary>Empty
// strings have to be provided in GVariant form</summary> </key>
//
//      </schema>
//    </schemalist>
//
//
//
//    <schemalist>
//
//      <enum id="org.gtk.Test.myenum">
//        <value nick="first" value="1"/>
//        <value nick="second" value="2"/>
//      </enum>
//
//      <flags id="org.gtk.Test.myflags">
//        <value nick="flag1" value="1"/>
//        <value nick="flag2" value="2"/>
//        <value nick="flag3" value="4"/>
//      </flags>
//
//      <schema id="org.gtk.Test">
//
//        <key name="key-with-range" type="i">
//          <range min="1" max="100"/>
//          <default>10</default>
//        </key>
//
//        <key name="key-with-choices" type="s">
//          <choices>
//            <choice value='Elisabeth'/>
//            <choice value='Annabeth'/>
//            <choice value='Joe'/>
//          </choices>
//          <aliases>
//            <alias value='Anna' target='Annabeth'/>
//            <alias value='Beth' target='Elisabeth'/>
//          </aliases>
//          <default>'Joe'</default>
//        </key>
//
//        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
//          <default>'first'</default>
//        </key>
//
//        <key name='flags-key' flags='org.gtk.Test.myflags'>
//          <default>["flag1","flag2"]</default>
//        </key>
//      </schema>
//    </schemalist>
//
//
// Vendor overrides
//
//
//        [org.gtk.Example]
//        key1='string'
//        key2=1.5
//
// glib-compile-schemas expects schema files to have the extension
// `.gschema.override`.
//
//
// Binding
//
// A very convenient feature of GSettings lets you bind #GObject properties
// directly to settings, using g_settings_bind(). Once a GObject property has
// been bound to a setting, changes on either side are automatically propagated
// to the other side. GSettings handles details like mapping between GObject and
// GVariant types, and preventing infinite cycles.
//
// This makes it very easy to hook up a preferences dialog to the underlying
// settings. To make this even more convenient, GSettings looks for a boolean
// property with the name "sensitivity" and automatically binds it to the
// writability of the bound setting. If this 'magic' gets in the way, it can be
// suppressed with the SETTINGS_BIND_NO_SENSITIVITY flag.
//
// Relocatable schemas {#gsettings-relocatable}
//
// A relocatable schema is one with no `path` attribute specified on its
// <schema> element. By using g_settings_new_with_path(), a #GSettings object
// can be instantiated for a relocatable schema, assigning a path to the
// instance. Paths passed to g_settings_new_with_path() will typically be
// constructed dynamically from a constant prefix plus some form of instance
// identifier; but they must still be valid GSettings paths. Paths could also be
// constant and used with a globally installed schema originating from a
// dependency library.
//
//
//    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
//      <child name="main" schema="org.foo.MyApp.Window"/>
//    </schema>
//
// Build system integration {#gsettings-build-system}
//
//
//    GLIB_GSETTINGS
//
// In the appropriate `Makefile.am`, use the following snippet to compile and
// install the named schema: |[ gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
// EXTRA_DIST = $(gsettings_SCHEMAS)
//
//    @GSETTINGS_RULES@
//
//
//
//    data/org.foo.MyApp.gschema.xml
//
//
//    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
//
// GSettings will use gettext to look up translations for the <summary> and
// <description> elements, and also any <default> elements which have a `l10n`
// attribute set. Translations must not be included in the `.gschema.xml` file
// by the build system, for example by using intltool XML rules with a
// `.gschema.xml.in` template.
//
//
//    gsettings_ENUM_NAMESPACE = org.foo.MyApp
//    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
//
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
type Settings struct {
	*externglib.Object
}

func wrapSettings(obj *glib.Object) *Settings {
	return &Settings{*externglib.Object{obj}}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SettingsBackend: the Backend interface defines a generic interface for
// non-strictly-typed data that is stored in a hierarchy. To implement an
// alternative storage backend for #GSettings, you need to implement the Backend
// interface and then make it implement the extension point
// SETTINGS_BACKEND_EXTENSION_POINT_NAME.
//
// The interface defines methods for reading and writing values, a method for
// determining if writing of certain values will fail (lockdown) and a change
// notification mechanism.
//
// The semantics of the interface are very precisely defined and implementations
// must carefully adhere to the expectations of callers that are documented on
// each of the interface methods.
//
// Some of the Backend functions accept or return a #GTree. These trees always
// have strings as keys and #GVariant as values.
// g_settings_backend_create_tree() is a convenience function to create suitable
// trees.
//
// The Backend API is exported to allow third-party implementations, but does
// not carry the same stability guarantees as the public GIO API. For this
// reason, you have to define the C preprocessor symbol
// G_SETTINGS_ENABLE_BACKEND before including `gio/gsettingsbackend.h`.
type SettingsBackend struct {
	*externglib.Object
}

func wrapSettingsBackend(obj *glib.Object) *SettingsBackend {
	return &SettingsBackend{*externglib.Object{obj}}
}

func marshalSettingsBackend(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SimpleAction: a Action is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of adding
// it to a ActionGroup.
//
// See also Action.
type SimpleAction struct {
	*externglib.Object
}

func wrapSimpleAction(obj *glib.Object) *SimpleAction {
	return &SimpleAction{*externglib.Object{obj}}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SimpleActionGroup: GSimpleActionGroup is a hash table filled with #GAction
// objects, implementing the Group and Map interfaces.
type SimpleActionGroup struct {
	*externglib.Object
}

func wrapSimpleActionGroup(obj *glib.Object) *SimpleActionGroup {
	return &SimpleActionGroup{*externglib.Object{obj}}
}

func marshalSimpleActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SimpleAsyncResult: as of GLib 2.46, AsyncResult is deprecated in favor of
// #GTask, which provides a simpler API.
//
// AsyncResult implements Result.
//
// GSimpleAsyncResult handles ReadyCallbacks, error reporting, operation
// cancellation and the final state of an operation, completely transparent to
// the application. Results can be returned as a pointer e.g. for functions that
// return data that is collected asynchronously, a boolean value for checking
// the success or failure of an operation, or a #gssize for operations which
// return the number of bytes modified by the operation; all of the simple
// return cases are covered.
//
// Most of the time, an application will not need to know of the details of this
// API; it is handled transparently, and any necessary operations are handled by
// Result's interface. However, if implementing a new GIO module, for writing
// language bindings, or for complex applications that need better control of
// how asynchronous operations are completed, it is important to understand this
// functionality.
//
// GSimpleAsyncResults are tagged with the calling function to ensure that
// asynchronous functions and their finishing functions are used together
// correctly.
//
// To create a new AsyncResult, call g_simple_async_result_new(). If the result
// needs to be created for a #GError, use g_simple_async_result_new_from_error()
// or g_simple_async_result_new_take_error(). If a #GError is not available
// (e.g. the asynchronous operation's doesn't take a #GError argument), but the
// result still needs to be created for an error condition, use
// g_simple_async_result_new_error() (or g_simple_async_result_set_error_va() if
// your application or binding requires passing a variable argument list
// directly), and the error can then be propagated through the use of
// g_simple_async_result_propagate_error().
//
// An asynchronous operation can be made to ignore a cancellation event by
// calling g_simple_async_result_set_handle_cancellation() with a AsyncResult
// for the operation and false. This is useful for operations that are dangerous
// to cancel, such as close (which would cause a leak if cancelled before being
// run).
//
// GSimpleAsyncResult can integrate into GLib's event loop, Loop, or it can use
// #GThreads. g_simple_async_result_complete() will finish an I/O task directly
// from the point where it is called. g_simple_async_result_complete_in_idle()
// will finish it from an idle handler in the [thread-default main
// context][g-main-context-push-thread-default] where the AsyncResult was
// created. g_simple_async_result_run_in_thread() will run the job in a separate
// thread and then use g_simple_async_result_complete_in_idle() to deliver the
// result.
//
// To set the results of an asynchronous function,
// g_simple_async_result_set_op_res_gpointer(),
// g_simple_async_result_set_op_res_gboolean(), and
// g_simple_async_result_set_op_res_gssize() are provided, setting the
// operation's result to a gpointer, gboolean, or gssize, respectively.
//
// Likewise, to get the result of an asynchronous function,
// g_simple_async_result_get_op_res_gpointer(),
// g_simple_async_result_get_op_res_gboolean(), and
// g_simple_async_result_get_op_res_gssize() are provided, getting the
// operation's result as a gpointer, gboolean, and gssize, respectively.
//
// For the details of the requirements implementations must respect, see Result.
// A typical implementation of an asynchronous operation using
// GSimpleAsyncResult looks something like this:
//
//    static void
//    baked_cb (Cake    *cake,
//              gpointer user_data)
//    {
//      // In this example, this callback is not given a reference to the cake,
//      // so the GSimpleAsyncResult has to take a reference to it.
//      GSimpleAsyncResult *result = user_data;
//
//      if (cake == NULL)
//        g_simple_async_result_set_error (result,
//                                         BAKER_ERRORS,
//                                         BAKER_ERROR_NO_FLOUR,
//                                         "Go to the supermarket");
//      else
//        g_simple_async_result_set_op_res_gpointer (result,
//                                                   g_object_ref (cake),
//                                                   g_object_unref);
//
//
//      // In this example, we assume that baked_cb is called as a callback from
//      // the mainloop, so it's safe to complete the operation synchronously here.
//      // If, however, _baker_prepare_cake () might call its callback without
//      // first returning to the mainloop  inadvisable, but some APIs do so 
//      // we would need to use g_simple_async_result_complete_in_idle().
//      g_simple_async_result_complete (result);
//      g_object_unref (result);
//    }
//
//    void
//    baker_bake_cake_async (Baker              *self,
//                           guint               radius,
//                           GAsyncReadyCallback callback,
//                           gpointer            user_data)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      if (radius < 3)
//        {
//          g_simple_async_report_error_in_idle (G_OBJECT (self),
//                                               callback,
//                                               user_data,
//                                               BAKER_ERRORS,
//                                               BAKER_ERROR_TOO_SMALL,
//                                               "ucm radius cakes are silly",
//                                               radius);
//          return;
//        }
//
//      simple = g_simple_async_result_new (G_OBJECT (self),
//                                          callback,
//                                          user_data,
//                                          baker_bake_cake_async);
//      cake = _baker_get_cached_cake (self, radius);
//
//      if (cake != NULL)
//        {
//          g_simple_async_result_set_op_res_gpointer (simple,
//                                                     g_object_ref (cake),
//                                                     g_object_unref);
//          g_simple_async_result_complete_in_idle (simple);
//          g_object_unref (simple);
//          // Drop the reference returned by _baker_get_cached_cake();
//          // the GSimpleAsyncResult has taken its own reference.
//          g_object_unref (cake);
//          return;
//        }
//
//      _baker_prepare_cake (self, radius, baked_cb, simple);
//    }
//
//    Cake *
//    baker_bake_cake_finish (Baker        *self,
//                            GAsyncResult *result,
//                            GError      **error)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      g_return_val_if_fail (g_simple_async_result_is_valid (result,
//                                                            G_OBJECT (self),
//                                                            baker_bake_cake_async),
//                            NULL);
//
//      simple = (GSimpleAsyncResult *) result;
//
//      if (g_simple_async_result_propagate_error (simple, error))
//        return NULL;
//
//      cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//      return g_object_ref (cake);
//    }
//
type SimpleAsyncResult struct {
	*externglib.Object
}

func wrapSimpleAsyncResult(obj *glib.Object) *SimpleAsyncResult {
	return &SimpleAsyncResult{*externglib.Object{obj}}
}

func marshalSimpleAsyncResult(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SimpleIOStream: GSimpleIOStream creates a OStream from an arbitrary Stream
// and Stream. This allows any pair of input and output streams to be used with
// OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream struct {
	IOStream
}

func wrapSimpleIOStream(obj *glib.Object) *SimpleIOStream {
	return &SimpleIOStream{IOStream{*externglib.Object{obj}}}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SimplePermission: GSimplePermission is a trivial implementation of
// #GPermission that represents a permission that is either always or never
// allowed. The value is given at construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission struct {
	Permission
}

func wrapSimplePermission(obj *glib.Object) *SimplePermission {
	return &SimplePermission{Permission{*externglib.Object{obj}}}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SimpleProxyResolver: GSimpleProxyResolver is a simple Resolver implementation
// that handles a single default proxy, multiple URI-scheme-specific proxies,
// and a list of hosts that proxies should not be used for.
//
// ProxyResolver is never the default proxy resolver, but it can be used as the
// base class for another proxy resolver implementation, or it can be created
// and used manually, such as with g_socket_client_set_proxy_resolver().
type SimpleProxyResolver struct {
	*externglib.Object
}

func wrapSimpleProxyResolver(obj *glib.Object) *SimpleProxyResolver {
	return &SimpleProxyResolver{*externglib.Object{obj}}
}

func marshalSimpleProxyResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Socket: a #GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API. It
// supports both the UNIX socket implementations and winsock2 on Windows.
//
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful
//
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return nil
//
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which dont take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
type Socket struct {
	*externglib.Object
}

func wrapSocket(obj *glib.Object) *Socket {
	return &Socket{*externglib.Object{obj}}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketAddress: GSocketAddress is the equivalent of struct sockaddr in the BSD
// sockets API. This is an abstract class; use SocketAddress for internet
// sockets, or SocketAddress for UNIX domain sockets.
type SocketAddress struct {
	*externglib.Object
}

func wrapSocketAddress(obj *glib.Object) *SocketAddress {
	return &SocketAddress{*externglib.Object{obj}}
}

func marshalSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketAddressEnumerator: GSocketAddressEnumerator is an enumerator type for
// Address instances. It is returned by enumeration functions such as
// g_socket_connectable_enumerate(), which returns a AddressEnumerator to list
// each Address which could be used to connect to that Connectable.
//
// Enumeration is typically a blocking operation, so the asynchronous methods
// g_socket_address_enumerator_next_async() and
// g_socket_address_enumerator_next_finish() should be used where possible.
//
// Each AddressEnumerator can only be enumerated once. Once
// g_socket_address_enumerator_next() has returned nil, further enumeration with
// that AddressEnumerator is not possible, and it can be unreffed.
type SocketAddressEnumerator struct {
	*externglib.Object
}

func wrapSocketAddressEnumerator(obj *glib.Object) *SocketAddressEnumerator {
	return &SocketAddressEnumerator{*externglib.Object{obj}}
}

func marshalSocketAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketClient: GSocketClient is a lightweight high-level utility class for
// connecting to a network host using a connection oriented socket type.
//
// You create a Client object, set any options you want, and then call a sync or
// async connect operation, which returns a Connection subclass on success.
//
// The type of the Connection object returned depends on the type of the
// underlying socket that is in use. For instance, for a TCP/IP connection it
// will be a Connection.
//
// As Client is a lightweight object, you don't need to cache it. You can just
// create a new one any time you need one.
type SocketClient struct {
	*externglib.Object
}

func wrapSocketClient(obj *glib.Object) *SocketClient {
	return &SocketClient{*externglib.Object{obj}}
}

func marshalSocketClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketConnection: GSocketConnection is a OStream for a connected socket. They
// can be created either by Client when connecting to a host, or by Listener
// when accepting a new client.
//
// The type of the Connection object returned from these calls depends on the
// type of the underlying socket that is in use. For instance, for a TCP/IP
// connection it will be a Connection.
//
// Choosing what type of object to construct is done with the socket connection
// factory, and it is possible for 3rd parties to register custom socket
// connection types for specific combination of socket family/type/protocol
// using g_socket_connection_factory_register_type().
//
// To close a Connection, use g_io_stream_close(). Closing both substreams of
// the OStream separately will not close the underlying #GSocket.
type SocketConnection struct {
	IOStream
}

func wrapSocketConnection(obj *glib.Object) *SocketConnection {
	return &SocketConnection{IOStream{*externglib.Object{obj}}}
}

func marshalSocketConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketControlMessage: a ControlMessage is a special-purpose utility message
// that can be sent to or received from a #GSocket. These types of messages are
// often called "ancillary data".
//
// The message can represent some sort of special instruction to or information
// from the socket or can represent a special kind of transfer to the peer (for
// example, sending a file descriptor over a UNIX socket).
//
// These messages are sent with g_socket_send_message() and received with
// g_socket_receive_message().
//
// To extend the set of control message that can be sent, subclass this class
// and override the get_size, get_level, get_type and serialize methods.
//
// To extend the set of control messages that can be received, subclass this
// class and implement the deserialize method. Also, make sure your class is
// registered with the GType typesystem before calling
// g_socket_receive_message() to read such a message.
type SocketControlMessage struct {
	*externglib.Object
}

func wrapSocketControlMessage(obj *glib.Object) *SocketControlMessage {
	return &SocketControlMessage{*externglib.Object{obj}}
}

func marshalSocketControlMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketListener: a Listener is an object that keeps track of a set of server
// sockets and helps you accept sockets from any of the socket, either sync or
// async.
//
// Add addresses and ports to listen on using g_socket_listener_add_address()
// and g_socket_listener_add_inet_port(). These will be listened on until
// g_socket_listener_close() is called. Dropping your final reference to the
// Listener will not cause g_socket_listener_close() to be called implicitly, as
// some references to the Listener may be held internally.
//
// If you want to implement a network server, also look at Service and
// SocketService which are subclasses of Listener that make this even easier.
type SocketListener struct {
	*externglib.Object
}

func wrapSocketListener(obj *glib.Object) *SocketListener {
	return &SocketListener{*externglib.Object{obj}}
}

func marshalSocketListener(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SocketService: a Service is an object that represents a service that is
// provided to the network or over local sockets. When a new connection is made
// to the service the Service::incoming signal is emitted.
//
// A Service is a subclass of Listener and you need to add the addresses you
// want to accept connections on with the Listener APIs.
//
// There are two options for implementing a network service based on Service.
// The first is to create the service using g_socket_service_new() and to
// connect to the Service::incoming signal. The second is to subclass Service
// and override the default signal handler implementation.
//
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested in
// writing connection handlers that contain blocking code then see
// SocketService.
//
// The socket service runs on the main loop of the [thread-default
// context][g-main-context-push-thread-default-context] of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
type SocketService struct {
	SocketListener
}

func wrapSocketService(obj *glib.Object) *SocketService {
	return &SocketService{SocketListener{*externglib.Object{obj}}}
}

func marshalSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Subprocess: GSubprocess allows the creation of and interaction with child
// processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified)
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc)
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess struct {
	*externglib.Object
}

func wrapSubprocess(obj *glib.Object) *Subprocess {
	return &Subprocess{*externglib.Object{obj}}
}

func marshalSubprocess(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher struct {
	*externglib.Object
}

func wrapSubprocessLauncher(obj *glib.Object) *SubprocessLauncher {
	return &SubprocessLauncher{*externglib.Object{obj}}
}

func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Task: a #GTask represents and manages a cancellable "task".
//
//
// Asynchronous operations
//
// The most common usage of #GTask is as a Result, to manage data during an
// asynchronous operation. You call g_task_new() in the "start" method, followed
// by g_task_set_task_data() and the like if you need to keep some additional
// data associated with the task, and then pass the task object around through
// your asynchronous operation. Eventually, you will call a method such as
// g_task_return_pointer() or g_task_return_error(), which will save the value
// you give it and then invoke the task's callback function in the
// [thread-default main context][g-main-context-push-thread-default] where it
// was created (waiting until the next iteration of the main loop first, if
// necessary). The caller will pass the #GTask back to the operation's finish
// function (as a Result), and you can use g_task_propagate_pointer() or the
// like to extract the return value.
//
// Here is an example for using GTask as a GAsyncResult: |[<!-- language="C" -->
// typedef struct { CakeFrostingType frosting; char *message; } DecorationData;
//
// static void decoration_data_free (DecorationData *decoration) { g_free
// (decoration->message); g_slice_free (DecorationData, decoration); }
//
// static void baked_cb (Cake *cake, gpointer user_data) { GTask *task =
// user_data; DecorationData *decoration = g_task_get_task_data (task); GError
// *error = NULL;
//
// if (cake == NULL) { g_task_return_new_error (task, BAKER_ERROR,
// BAKER_ERROR_NO_FLOUR, "Go to the supermarket"); g_object_unref (task);
// return; }
//
// if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
// { g_object_unref (cake); // g_task_return_error() takes ownership of error
// g_task_return_error (task, error); g_object_unref (task); return; }
//
// g_task_return_pointer (task, cake, g_object_unref); g_object_unref (task); }
//
// void baker_bake_cake_async (Baker *self, guint radius, CakeFlavor flavor,
// CakeFrostingType frosting, const char *message, GCancellable *cancellable,
// GAsyncReadyCallback callback, gpointer user_data) { GTask *task;
// DecorationData *decoration; Cake *cake;
//
// task = g_task_new (self, cancellable, callback, user_data); if (radius < 3) {
// g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL, "ucm
// radius cakes are silly", radius); g_object_unref (task); return; }
//
// cake = _baker_get_cached_cake (self, radius, flavor, frosting, message); if
// (cake != NULL) { // _baker_get_cached_cake() returns a reffed cake
// g_task_return_pointer (task, cake, g_object_unref); g_object_unref (task);
// return; }
//
// decoration = g_slice_new (DecorationData); decoration->frosting = frosting;
// decoration->message = g_strdup (message); g_task_set_task_data (task,
// decoration, (GDestroyNotify) decoration_data_free);
//
// _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task); }
//
// Cake * baker_bake_cake_finish (Baker *self, GAsyncResult *result, GError
// **error) { g_return_val_if_fail (g_task_is_valid (result, self), NULL);
//
//          return g_task_propagate_pointer (G_TASK (result), error);
//        }
//
//
//    ## Chained asynchronous operations
//
//    #GTask also tries to simplify asynchronous operations that
//    internally chain together several smaller asynchronous
//    operations. g_task_get_cancellable(), g_task_get_context(),
//    and g_task_get_priority() allow you to get back the task's
//    #GCancellable, Context, and [I/O priority][io-priority]
//    when starting a new subtask, so you don't have to keep track
//    of them yourself. g_task_attach_source() simplifies the case
//    of waiting for a source to fire (automatically using the correct
//    Context and priority).
//
//        typedef struct {
//          Cake *cake;
//          CakeFrostingType frosting;
//          char *message;
//        } BakingData;
//
//        static void
//        decoration_data_free (BakingData *bd)
//        {
//          if (bd->cake)
//            g_object_unref (bd->cake);
//          g_free (bd->message);
//          g_slice_free (BakingData, bd);
//        }
//
//        static void
//        decorated_cb (Cake         *cake,
//                      GAsyncResult *result,
//                      gpointer      user_data)
//        {
//          GTask *task = user_data;
//          GError *error = NULL;
//
//          if (!cake_decorate_finish (cake, result, &error))
//            {
//              g_object_unref (cake);
//              g_task_return_error (task, error);
//              g_object_unref (task);
//              return;
//            }
//
//          // baking_data_free() will drop its ref on the cake, so we have to
//          // take another here to give to the caller.
//          g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
//          g_object_unref (task);
//        }
//
//        static gboolean
//        decorator_ready (gpointer user_data)
//        {
//          GTask *task = user_data;
//          BakingData *bd = g_task_get_task_data (task);
//
//          cake_decorate_async (bd->cake, bd->frosting, bd->message,
//                               g_task_get_cancellable (task),
//                               decorated_cb, task);
//
//          return G_SOURCE_REMOVE;
//        }
//
//        static void
//        baked_cb (Cake     *cake,
//                  gpointer  user_data)
//        {
//          GTask *task = user_data;
//          BakingData *bd = g_task_get_task_data (task);
//          GError *error = NULL;
//
//          if (cake == NULL)
//            {
//              g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
//                                       "Go to the supermarket");
//              g_object_unref (task);
//              return;
//            }
//
//          bd->cake = cake;
//
//          // Bail out now if the user has already cancelled
//          if (g_task_return_error_if_cancelled (task))
//            {
//              g_object_unref (task);
//              return;
//            }
//
//          if (cake_decorator_available (cake))
//            decorator_ready (task);
//          else
//            {
//              GSource *source;
//
//              source = cake_decorator_wait_source_new (cake);
//              // Attach @source to @task's GMainContext and have it call
//              // decorator_ready() when it is ready.
//              g_task_attach_source (task, source, decorator_ready);
//              g_source_unref (source);
//            }
//        }
//
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               gint                 priority,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          GTask *task;
//          BakingData *bd;
//
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_priority (task, priority);
//
//          bd = g_slice_new0 (BakingData);
//          bd->frosting = frosting;
//          bd->message = g_strdup (message);
//          g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);
//
//          _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
//        }
//
//        Cake *
//        baker_bake_cake_finish (Baker         *self,
//                                GAsyncResult  *result,
//                                GError       **error)
//        {
//          g_return_val_if_fail (g_task_is_valid (result, self), NULL);
//
//          return g_task_propagate_pointer (G_TASK (result), error);
//        }
//
//
//
// Asynchronous operations from synchronous ones
//
// You can use g_task_run_in_thread() to turn a synchronous operation into an
// asynchronous one, by running it in a thread. When it completes, the result
// will be dispatched to the [thread-default main
// context][g-main-context-push-thread-default] where the #GTask was created.
//
// Running a task in a thread: |[<!-- language="C" --> typedef struct { guint
// radius; CakeFlavor flavor; CakeFrostingType frosting; char *message; }
// CakeData;
//
// static void cake_data_free (CakeData *cake_data) { g_free
// (cake_data->message); g_slice_free (CakeData, cake_data); }
//
// static void bake_cake_thread (GTask *task, gpointer source_object, gpointer
// task_data, GCancellable *cancellable) { Baker *self = source_object; CakeData
// *cake_data = task_data; Cake *cake; GError *error = NULL;
//
// cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
// cake_data->frosting, cake_data->message, cancellable, &error); if (cake)
// g_task_return_pointer (task, cake, g_object_unref); else g_task_return_error
// (task, error); }
//
// void baker_bake_cake_async (Baker *self, guint radius, CakeFlavor flavor,
// CakeFrostingType frosting, const char *message, GCancellable *cancellable,
// GAsyncReadyCallback callback, gpointer user_data) { CakeData *cake_data;
// GTask *task;
//
// cake_data = g_slice_new (CakeData); cake_data->radius = radius;
// cake_data->flavor = flavor; cake_data->frosting = frosting;
// cake_data->message = g_strdup (message); task = g_task_new (self,
// cancellable, callback, user_data); g_task_set_task_data (task, cake_data,
// (GDestroyNotify) cake_data_free); g_task_run_in_thread (task,
// bake_cake_thread); g_object_unref (task); }
//
// Cake * baker_bake_cake_finish (Baker *self, GAsyncResult *result, GError
// **error) { g_return_val_if_fail (g_task_is_valid (result, self), NULL);
//
//          return g_task_propagate_pointer (G_TASK (result), error);
//        }
//
//
//    ## Adding cancellability to uncancellable tasks
//
//    Finally, g_task_run_in_thread() and g_task_run_in_thread_sync()
//    can be used to turn an uncancellable operation into a
//    cancellable one. If you call g_task_set_return_on_cancel(),
//    passing true, then if the task's #GCancellable is cancelled,
//    it will return control back to the caller immediately, while
//    allowing the task thread to continue running in the background
//    (and simply discarding its result when it finally does finish).
//    Provided that the task thread is careful about how it uses
//    locks and other externally-visible resources, this allows you
//    to make "GLib-friendly" asynchronous and cancellable
//    synchronous variants of blocking APIs.
//
//        static void
//        bake_cake_thread (GTask         *task,
//                          gpointer       source_object,
//                          gpointer       task_data,
//                          GCancellable  *cancellable)
//        {
//          Baker *self = source_object;
//          CakeData *cake_data = task_data;
//          Cake *cake;
//          GError *error = NULL;
//
//          cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//                            cake_data->frosting, cake_data->message,
//                            &error);
//          if (error)
//            {
//              g_task_return_error (task, error);
//              return;
//            }
//
//          // If the task has already been cancelled, then we don't want to add
//          // the cake to the cake cache. Likewise, we don't  want to have the
//          // task get cancelled in the middle of updating the cache.
//          // g_task_set_return_on_cancel() will return true here if it managed
//          // to disable return-on-cancel, or false if the task was cancelled
//          // before it could.
//          if (g_task_set_return_on_cancel (task, FALSE))
//            {
//              // If the caller cancels at this point, their
//              // GAsyncReadyCallback won't be invoked until we return,
//              // so we don't have to worry that this code will run at
//              // the same time as that code does. But if there were
//              // other functions that might look at the cake cache,
//              // then we'd probably need a GMutex here as well.
//              baker_add_cake_to_cache (baker, cake);
//              g_task_return_pointer (task, cake, g_object_unref);
//            }
//        }
//
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          CakeData *cake_data;
//          GTask *task;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread (task, bake_cake_thread);
//        }
//
//        Cake *
//        baker_bake_cake_sync (Baker               *self,
//                              guint                radius,
//                              CakeFlavor           flavor,
//                              CakeFrostingType     frosting,
//                              const char          *message,
//                              GCancellable        *cancellable,
//                              GError             **error)
//        {
//          CakeData *cake_data;
//          GTask *task;
//          Cake *cake;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, NULL, NULL);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread_sync (task, bake_cake_thread);
//
//          cake = g_task_propagate_pointer (task, error);
//          g_object_unref (task);
//          return cake;
//        }
//
//
//
// Porting from GSimpleAsyncResult
//
// #GTask's API attempts to be simpler than AsyncResult's in several ways: - You
// can save task-specific data with g_task_set_task_data(), and
//
//    retrieve it later with g_task_get_task_data(). This replaces the
//    abuse of g_simple_async_result_set_op_res_gpointer() for the same
//    purpose with AsyncResult.
//
// - In addition to the task data, #GTask also keeps track of the
//
//    [priority][io-priority], #GCancellable, and
//    Context associated with the task, so tasks that consist of
//    a chain of simpler asynchronous operations will have easy access
//    to those values when starting each sub-task.
//
// - g_task_return_error_if_cancelled() provides simplified
//
//    handling for cancellation. In addition, cancellation
//    overrides any other #GTask return value by default, like
//    AsyncResult does when
//    g_simple_async_result_set_check_cancellable() is called.
//    (You can use g_task_set_check_cancellable() to turn off that
//    behavior.) On the other hand, g_task_run_in_thread()
//    guarantees that it will always run your
//    `task_func`, even if the task's #GCancellable
//    is already cancelled before the task gets a chance to run;
//    you can start your `task_func` with a
//    g_task_return_error_if_cancelled() check if you need the
//    old behavior.
//
// - The "return" methods (eg, g_task_return_pointer())
//
//    automatically cause the task to be "completed" as well, and
//    there is no need to worry about the "complete" vs "complete
//    in idle" distinction. (#GTask automatically figures out
//    whether the task's callback can be invoked directly, or
//    if it needs to be sent to another Context, or delayed
//    until the next iteration of the current Context.)
//
// - The "finish" functions for #GTask based operations are generally
//
//    much simpler than AsyncResult ones, normally consisting
//    of only a single call to g_task_propagate_pointer() or the like.
//    Since g_task_propagate_pointer() "steals" the return value from
//    the #GTask, it is not necessary to juggle pointers around to
//    prevent it from being freed twice.
//
// - With AsyncResult, it was common to call
//
//    g_simple_async_result_propagate_error() from the
//    `_finish()` wrapper function, and have
//    virtual method implementations only deal with successful
//    returns. This behavior is deprecated, because it makes it
//    difficult for a subclass to chain to a parent class's async
//    methods. Instead, the wrapper function should just be a
//    simple wrapper, and the virtual method should call an
//    appropriate `g_task_propagate_` function.
//    Note that wrapper methods can now use
//    g_async_result_legacy_propagate_error() to do old-style
//    AsyncResult error-returning behavior, and
//    g_async_result_is_tagged() to check if a result is tagged as
//    having come from the `_async()` wrapper
//    function (for "short-circuit" results, such as when passing
//    0 to g_input_stream_read_async())
type Task struct {
	*externglib.Object
}

func wrapTask(obj *glib.Object) *Task {
	return &Task{*externglib.Object{obj}}
}

func marshalTask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TcpConnection: this is the subclass of Connection that is created for TCP/IP
// sockets.
type TcpConnection struct {
	SocketConnection
}

func wrapTcpConnection(obj *glib.Object) *TcpConnection {
	return &TcpConnection{SocketConnection{IOStream{*externglib.Object{obj}}}}
}

func marshalTcpConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TcpWrapperConnection: a WrapperConnection can be used to wrap a OStream that
// is based on a #GSocket, but which is not actually a Connection. This is used
// by Client so that it can always return a Connection, even when the connection
// it has actually created is not directly a Connection.
type TcpWrapperConnection struct {
	TcpConnection
}

func wrapTcpWrapperConnection(obj *glib.Object) *TcpWrapperConnection {
	return &TcpWrapperConnection{TcpConnection{SocketConnection{IOStream{*externglib.Object{obj}}}}}
}

func marshalTcpWrapperConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TestDBus: a helper class for testing code which uses D-Bus without touching
// the user's session bus.
//
// Note that DBus modifies the users environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure. |[ [D-BUS Service]
// Name=org.gtk.GDBus.Examples.ObjectManager
// Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server ]| You
// will also need to indicate this service directory in your test fixtures, so
// you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as: |[
// -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\" ]| Once you have a
// service definition file which is local to your source tree, you can proceed
// to set up a GTest fixture using the DBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found here:
// [gdbus-test-fixture.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your
// schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas: |[ all-am: $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
//
type TestDBus struct {
	*externglib.Object
}

func wrapTestDBus(obj *glib.Object) *TestDBus {
	return &TestDBus{*externglib.Object{obj}}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ThemedIcon: GThemedIcon is an implementation of #GIcon that supports icon
// themes. Icon contains a list of all of the icons present in an icon theme, so
// that icons can be looked up quickly. Icon does not provide actual pixmaps for
// icons, just the icon names. Ideally something like
// gtk_icon_theme_choose_icon() should be used to resolve the list of names so
// that fallback icons work nicely with themes that inherit other themes.
type ThemedIcon struct {
	*externglib.Object
}

func wrapThemedIcon(obj *glib.Object) *ThemedIcon {
	return &ThemedIcon{*externglib.Object{obj}}
}

func marshalThemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ThreadedSocketService: a SocketService is a simple subclass of Service that
// handles incoming connections by creating a worker thread and dispatching the
// connection to it by emitting the SocketService::run signal in the new thread.
//
// The signal handler may perform blocking IO and need not return until the
// connection is closed.
//
// The service is implemented using a thread pool, so there is a limited amount
// of threads available to serve incoming requests. The service automatically
// stops the Service from accepting new connections when all threads are busy.
//
// As with Service, you may connect to SocketService::run, or subclass and
// override the default handler.
type ThreadedSocketService struct {
	SocketService
}

func wrapThreadedSocketService(obj *glib.Object) *ThreadedSocketService {
	return &ThreadedSocketService{SocketService{SocketListener{*externglib.Object{obj}}}}
}

func marshalThreadedSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TlsCertificate: a certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate received by
// a client from a server), or the combination of a certificate and a private
// key (which is needed when acting as a ServerConnection).
type TlsCertificate struct {
	*externglib.Object
}

func wrapTlsCertificate(obj *glib.Object) *TlsCertificate {
	return &TlsCertificate{*externglib.Object{obj}}
}

func marshalTlsCertificate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TlsConnection: GTlsConnection is the base TLS connection class type, which
// wraps a OStream and provides TLS encryption on top of it. Its subclasses,
// ClientConnection and ServerConnection, implement client-side and server-side
// TLS, respectively.
//
// For DTLS (Datagram TLS) support, see Connection.
type TlsConnection struct {
	IOStream
}

func wrapTlsConnection(obj *glib.Object) *TlsConnection {
	return &TlsConnection{IOStream{*externglib.Object{obj}}}
}

func marshalTlsConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TlsDatabase: GTlsDatabase is used to look up certificates and other
// information from a certificate or key store. It is an abstract base class
// which TLS library specific subtypes override.
//
// A Database may be accessed from multiple threads by the TLS backend. All
// implementations are required to be fully thread-safe.
//
// Most common client applications will not directly interact with Database. It
// is used internally by Connection.
type TlsDatabase struct {
	*externglib.Object
}

func wrapTlsDatabase(obj *glib.Object) *TlsDatabase {
	return &TlsDatabase{*externglib.Object{obj}}
}

func marshalTlsDatabase(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TlsInteraction: GTlsInteraction provides a mechanism for the TLS connection
// and database code to interact with the user. It can be used to ask the user
// for passwords.
//
// To use a Interaction with a TLS connection use
// g_tls_connection_set_interaction().
//
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
//
// Callers should use the 'invoke' functions like
// g_tls_interaction_invoke_ask_password() to run interaction methods. These
// functions make sure that the interaction is invoked in the main loop and not
// in the current thread, if the current thread is not running the main loop.
//
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
// it must also implement the corresponding finish method.
type TlsInteraction struct {
	*externglib.Object
}

func wrapTlsInteraction(obj *glib.Object) *TlsInteraction {
	return &TlsInteraction{*externglib.Object{obj}}
}

func marshalTlsInteraction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TlsPassword: holds a password used in TLS.
type TlsPassword struct {
	*externglib.Object
}

func wrapTlsPassword(obj *glib.Object) *TlsPassword {
	return &TlsPassword{*externglib.Object{obj}}
}

func marshalTlsPassword(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// UnixConnection: this is the subclass of Connection that is created for UNIX
// domain sockets.
//
// It contains functions to do some of the UNIX socket specific functionality
// like passing file descriptors.
//
// Note that `<gio/gunixconnection.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixConnection struct {
	SocketConnection
}

func wrapUnixConnection(obj *glib.Object) *UnixConnection {
	return &UnixConnection{SocketConnection{IOStream{*externglib.Object{obj}}}}
}

func marshalUnixConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// UnixCredentialsMessage: this ControlMessage contains a #GCredentials
// instance. It may be sent using g_socket_send_message() and received using
// g_socket_receive_message() over UNIX sockets (ie: sockets in the
// G_SOCKET_FAMILY_UNIX family).
//
// For an easier way to send and receive credentials over stream-oriented UNIX
// sockets, see g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials(). To receive credentials of a foreign
// process connected to a socket, use g_socket_get_credentials().
type UnixCredentialsMessage struct {
	SocketControlMessage
}

func wrapUnixCredentialsMessage(obj *glib.Object) *UnixCredentialsMessage {
	return &UnixCredentialsMessage{SocketControlMessage{*externglib.Object{obj}}}
}

func marshalUnixCredentialsMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// UnixFDList: a FDList contains a list of file descriptors. It owns the file
// descriptors that it contains, closing them when finalized.
//
// It may be wrapped in a FDMessage and sent over a #GSocket in the
// G_SOCKET_FAMILY_UNIX family by using g_socket_send_message() and received
// using g_socket_receive_message().
//
// Note that `<gio/gunixfdlist.h>` belongs to the UNIX-specific GIO interfaces,
// thus you have to use the `gio-unix-2.0.pc` pkg-config file when using it.
type UnixFDList struct {
	*externglib.Object
}

func wrapUnixFDList(obj *glib.Object) *UnixFDList {
	return &UnixFDList{*externglib.Object{obj}}
}

func marshalUnixFDList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// UnixFDMessage: this ControlMessage contains a FDList. It may be sent using
// g_socket_send_message() and received using g_socket_receive_message() over
// UNIX sockets (ie: sockets in the G_SOCKET_FAMILY_UNIX family). The file
// descriptors are copied between processes by the kernel.
//
// For an easier way to send and receive file descriptors over stream-oriented
// UNIX sockets, see g_unix_connection_send_fd() and
// g_unix_connection_receive_fd().
//
// Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixFDMessage struct {
	SocketControlMessage
}

func wrapUnixFDMessage(obj *glib.Object) *UnixFDMessage {
	return &UnixFDMessage{SocketControlMessage{*externglib.Object{obj}}}
}

func marshalUnixFDMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// UnixInputStream: GUnixInputStream implements Stream for reading from a UNIX
// file descriptor, including asynchronous operations. (If the file descriptor
// refers to a socket or pipe, this will use poll() to do asynchronous I/O. If
// it refers to a regular file, it will fall back to doing asynchronous I/O in
// another thread.)
//
// Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixInputStream struct {
	InputStream
}

func wrapUnixInputStream(obj *glib.Object) *UnixInputStream {
	return &UnixInputStream{InputStream{*externglib.Object{obj}}}
}

func marshalUnixInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// UnixMountMonitor: watches Mounts for changes.
type UnixMountMonitor struct {
	*externglib.Object
}

func wrapUnixMountMonitor(obj *glib.Object) *UnixMountMonitor {
	return &UnixMountMonitor{*externglib.Object{obj}}
}

func marshalUnixMountMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// UnixOutputStream: GUnixOutputStream implements Stream for writing to a UNIX
// file descriptor, including asynchronous operations. (If the file descriptor
// refers to a socket or pipe, this will use poll() to do asynchronous I/O. If
// it refers to a regular file, it will fall back to doing asynchronous I/O in
// another thread.)
//
// Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixOutputStream struct {
	OutputStream
}

func wrapUnixOutputStream(obj *glib.Object) *UnixOutputStream {
	return &UnixOutputStream{OutputStream{*externglib.Object{obj}}}
}

func marshalUnixOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// UnixSocketAddress: support for UNIX-domain (also known as local) sockets.
//
// UNIX domain sockets are generally visible in the filesystem. However, some
// systems support abstract socket names which are not visible in the filesystem
// and not affected by the filesystem permissions, visibility, etc. Currently
// this is only supported under Linux. If you attempt to use abstract sockets on
// other systems, function calls may return G_IO_ERROR_NOT_SUPPORTED errors. You
// can use g_unix_socket_address_abstract_names_supported() to see if abstract
// names are supported.
//
// Note that `<gio/gunixsocketaddress.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixSocketAddress struct {
	SocketAddress
}

func wrapUnixSocketAddress(obj *glib.Object) *UnixSocketAddress {
	return &UnixSocketAddress{SocketAddress{*externglib.Object{obj}}}
}

func marshalUnixSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Vfs: entry point for using GIO functionality.
type Vfs struct {
	*externglib.Object
}

func wrapVfs(obj *glib.Object) *Vfs {
	return &Vfs{*externglib.Object{obj}}
}

func marshalVfs(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// VolumeMonitor: GVolumeMonitor is for listing the user interesting devices and
// volumes on the computer. In other words, what a file selector or file manager
// would show in a sidebar.
//
// Monitor is not [thread-default-context
// aware][g-main-context-push-thread-default], and so should not be used other
// than from the main thread, with no thread-default-context active.
//
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor struct {
	*externglib.Object
}

func wrapVolumeMonitor(obj *glib.Object) *VolumeMonitor {
	return &VolumeMonitor{*externglib.Object{obj}}
}

func marshalVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ZlibCompressor: zlib decompression
type ZlibCompressor struct {
	*externglib.Object
}

func wrapZlibCompressor(obj *glib.Object) *ZlibCompressor {
	return &ZlibCompressor{*externglib.Object{obj}}
}

func marshalZlibCompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ZlibDecompressor: zlib decompression
type ZlibDecompressor struct {
	*externglib.Object
}

func wrapZlibDecompressor(obj *glib.Object) *ZlibDecompressor {
	return &ZlibDecompressor{*externglib.Object{obj}}
}

func marshalZlibDecompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := glib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}
