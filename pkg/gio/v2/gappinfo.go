// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern GAppInfo* _gotk4_gio2_AppInfoIface_dup(GAppInfo*);
// extern GIcon* _gotk4_gio2_AppInfoIface_get_icon(GAppInfo*);
// extern char* _gotk4_gio2_AppInfoIface_get_commandline(GAppInfo*);
// extern char* _gotk4_gio2_AppInfoIface_get_description(GAppInfo*);
// extern char* _gotk4_gio2_AppInfoIface_get_display_name(GAppInfo*);
// extern char* _gotk4_gio2_AppInfoIface_get_executable(GAppInfo*);
// extern char* _gotk4_gio2_AppInfoIface_get_id(GAppInfo*);
// extern char* _gotk4_gio2_AppInfoIface_get_name(GAppInfo*);
// extern char* _gotk4_gio2_AppLaunchContextClass_get_display(GAppLaunchContext*, GAppInfo*, GList*);
// extern char* _gotk4_gio2_AppLaunchContextClass_get_startup_notify_id(GAppLaunchContext*, GAppInfo*, GList*);
// extern char** _gotk4_gio2_AppInfoIface_get_supported_types(GAppInfo*);
// extern gboolean _gotk4_gio2_AppInfoIface_add_supports_type(GAppInfo*, char*, GError**);
// extern gboolean _gotk4_gio2_AppInfoIface_can_delete(GAppInfo*);
// extern gboolean _gotk4_gio2_AppInfoIface_can_remove_supports_type(GAppInfo*);
// extern gboolean _gotk4_gio2_AppInfoIface_do_delete(GAppInfo*);
// extern gboolean _gotk4_gio2_AppInfoIface_equal(GAppInfo*, GAppInfo*);
// extern gboolean _gotk4_gio2_AppInfoIface_launch(GAppInfo*, GList*, GAppLaunchContext*, GError**);
// extern gboolean _gotk4_gio2_AppInfoIface_launch_uris(GAppInfo*, GList*, GAppLaunchContext*, GError**);
// extern gboolean _gotk4_gio2_AppInfoIface_launch_uris_finish(GAppInfo*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gio2_AppInfoIface_remove_supports_type(GAppInfo*, char*, GError**);
// extern gboolean _gotk4_gio2_AppInfoIface_set_as_default_for_extension(GAppInfo*, char*, GError**);
// extern gboolean _gotk4_gio2_AppInfoIface_set_as_default_for_type(GAppInfo*, char*, GError**);
// extern gboolean _gotk4_gio2_AppInfoIface_set_as_last_used_for_type(GAppInfo*, char*, GError**);
// extern gboolean _gotk4_gio2_AppInfoIface_should_show(GAppInfo*);
// extern gboolean _gotk4_gio2_AppInfoIface_supports_files(GAppInfo*);
// extern gboolean _gotk4_gio2_AppInfoIface_supports_uris(GAppInfo*);
// extern void _gotk4_gio2_AppLaunchContextClass_launch_failed(GAppLaunchContext*, char*);
// extern void _gotk4_gio2_AppLaunchContextClass_launched(GAppLaunchContext*, GAppInfo*, GVariant*);
// extern void _gotk4_gio2_AppLaunchContext_ConnectLaunchFailed(gpointer, gchar*, guintptr);
// extern void _gotk4_gio2_AppLaunchContext_ConnectLaunched(gpointer, GAppInfo*, GVariant*, guintptr);
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

// glib.Type values for gappinfo.go.
var (
	GTypeAppInfo          = externglib.Type(C.g_app_info_get_type())
	GTypeAppLaunchContext = externglib.Type(C.g_app_launch_context_get_type())
)

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeAppInfo, F: marshalAppInfo},
		{T: GTypeAppLaunchContext, F: marshalAppLaunchContext},
	})
}

// AppInfoOverrider contains methods that are overridable.
type AppInfoOverrider interface {
	externglib.Objector
	// AddSupportsType adds a content type to the application information to
	// indicate the application is capable of opening files with the given
	// content type.
	//
	// The function takes the following parameters:
	//
	//    - contentType: string.
	//
	AddSupportsType(contentType string) error
	// CanDelete obtains the information whether the Info can be deleted. See
	// g_app_info_delete().
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if appinfo can be deleted.
	//
	CanDelete() bool
	// CanRemoveSupportsType checks if a supported content type can be removed
	// from an application.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if it is possible to remove supported content types from a
	//      given appinfo, FALSE if not.
	//
	CanRemoveSupportsType() bool
	// DoDelete tries to delete a Info.
	//
	// On some platforms, there may be a difference between user-defined Infos
	// which can be deleted, and system-wide ones which cannot. See
	// g_app_info_can_delete().
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if appinfo has been deleted.
	//
	DoDelete() bool
	// Dup creates a duplicate of a Info.
	//
	// The function returns the following values:
	//
	//    - appInfo: duplicate of appinfo.
	//
	Dup() AppInfoOverrider
	// Equal checks if two Infos are equal.
	//
	// Note that the check *may not* compare each individual field, and only
	// does an identity check. In case detecting changes in the contents is
	// needed, program code must additionally compare relevant fields.
	//
	// The function takes the following parameters:
	//
	//    - appinfo2: second Info.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if appinfo1 is equal to appinfo2. FALSE otherwise.
	//
	Equal(appinfo2 AppInfoOverrider) bool
	// Commandline gets the commandline with which the application will be
	// started.
	//
	// The function returns the following values:
	//
	//    - filename (optional): string containing the appinfo's commandline, or
	//      NULL if this information is not available.
	//
	Commandline() string
	// Description gets a human-readable description of an installed
	// application.
	//
	// The function returns the following values:
	//
	//    - utf8 (optional): string containing a description of the application
	//      appinfo, or NULL if none.
	//
	Description() string
	// DisplayName gets the display name of the application. The display name is
	// often more descriptive to the user than the name itself.
	//
	// The function returns the following values:
	//
	//    - utf8: display name of the application for appinfo, or the name if no
	//      display name is available.
	//
	DisplayName() string
	// Executable gets the executable's name for the installed application.
	//
	// The function returns the following values:
	//
	//    - filename: string containing the appinfo's application binaries name.
	//
	Executable() string
	// Icon gets the icon for the application.
	//
	// The function returns the following values:
	//
	//    - icon (optional): default #GIcon for appinfo or NULL if there is no
	//      default icon.
	//
	Icon() IconOverrider
	// ID gets the ID of an application. An id is a string that identifies the
	// application. The exact format of the id is platform dependent. For
	// instance, on Unix this is the desktop file id from the xdg menu
	// specification.
	//
	// Note that the returned ID may be NULL, depending on how the appinfo has
	// been constructed.
	//
	// The function returns the following values:
	//
	//    - utf8 (optional): string containing the application's ID.
	//
	ID() string
	// Name gets the installed name of the application.
	//
	// The function returns the following values:
	//
	//    - utf8: name of the application for appinfo.
	//
	Name() string
	// SupportedTypes retrieves the list of content types that app_info claims
	// to support. If this information is not provided by the environment, this
	// function will return NULL. This function does not take in consideration
	// associations added with g_app_info_add_supports_type(), but only those
	// exported directly by the application.
	//
	// The function returns the following values:
	//
	//    - utf8s: a list of content types.
	//
	SupportedTypes() []string
	// Launch launches the application. Passes files to the launched application
	// as arguments, using the optional context to get information about the
	// details of the launcher (like what screen it is on). On error, error will
	// be set accordingly.
	//
	// To launch the application without arguments pass a NULL files list.
	//
	// Note that even if the launch is successful the application launched can
	// fail to start if it runs into problems during startup. There is no way to
	// detect this.
	//
	// Some URIs can be changed when passed through a GFile (for instance
	// unsupported URIs with strange formats like mailto:), so if you have a
	// textual URI you want to pass in as argument, consider using
	// g_app_info_launch_uris() instead.
	//
	// The launched application inherits the environment of the launching
	// process, but it can be modified with g_app_launch_context_setenv() and
	// g_app_launch_context_unsetenv().
	//
	// On UNIX, this function sets the GIO_LAUNCHED_DESKTOP_FILE environment
	// variable with the path of the launched desktop file and
	// GIO_LAUNCHED_DESKTOP_FILE_PID to the process id of the launched process.
	// This can be used to ignore GIO_LAUNCHED_DESKTOP_FILE, should it be
	// inherited by further processes. The DISPLAY and DESKTOP_STARTUP_ID
	// environment variables are also set, based on information provided in
	// context.
	//
	// The function takes the following parameters:
	//
	//    - files (optional) of #GFile objects.
	//    - context (optional) or NULL.
	//
	Launch(files []FileOverrider, context *AppLaunchContext) error
	// LaunchURIs launches the application. This passes the uris to the launched
	// application as arguments, using the optional context to get information
	// about the details of the launcher (like what screen it is on). On error,
	// error will be set accordingly.
	//
	// To launch the application without arguments pass a NULL uris list.
	//
	// Note that even if the launch is successful the application launched can
	// fail to start if it runs into problems during startup. There is no way to
	// detect this.
	//
	// The function takes the following parameters:
	//
	//    - uris (optional) containing URIs to launch.
	//    - context (optional) or NULL.
	//
	LaunchURIs(uris []string, context *AppLaunchContext) error
	// LaunchURIsFinish finishes a g_app_info_launch_uris_async() operation.
	//
	// The function takes the following parameters:
	//
	//    - result: Result.
	//
	LaunchURIsFinish(result AsyncResultOverrider) error
	// RemoveSupportsType removes a supported type from an application, if
	// possible.
	//
	// The function takes the following parameters:
	//
	//    - contentType: string.
	//
	RemoveSupportsType(contentType string) error
	// SetAsDefaultForExtension sets the application as the default handler for
	// the given file extension.
	//
	// The function takes the following parameters:
	//
	//    - extension: string containing the file extension (without the dot).
	//
	SetAsDefaultForExtension(extension string) error
	// SetAsDefaultForType sets the application as the default handler for a
	// given type.
	//
	// The function takes the following parameters:
	//
	//    - contentType: content type.
	//
	SetAsDefaultForType(contentType string) error
	// SetAsLastUsedForType sets the application as the last used application
	// for a given type. This will make the application appear as first in the
	// list returned by g_app_info_get_recommended_for_type(), regardless of the
	// default application for that content type.
	//
	// The function takes the following parameters:
	//
	//    - contentType: content type.
	//
	SetAsLastUsedForType(contentType string) error
	// ShouldShow checks if the application info should be shown in menus that
	// list available applications.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the appinfo should be shown, FALSE otherwise.
	//
	ShouldShow() bool
	// SupportsFiles checks if the application accepts files as arguments.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the appinfo supports files.
	//
	SupportsFiles() bool
	// SupportsURIs checks if the application supports reading files and
	// directories from URIs.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the appinfo supports URIs.
	//
	SupportsURIs() bool
}

// WrapAppInfoOverrider wraps the AppInfoOverrider
// interface implementation to access the instance methods.
func WrapAppInfoOverrider(obj AppInfoOverrider) *AppInfo {
	return wrapAppInfo(externglib.BaseObject(obj))
}

// AppInfo and LaunchContext are used for describing and launching applications
// installed on the system.
//
// As of GLib 2.20, URIs will always be converted to POSIX paths (using
// g_file_get_path()) when using g_app_info_launch() even if the application
// requested an URI and not a POSIX path. For example for a desktop-file based
// application with Exec key totem U and a single URI, sftp://foo/file.avi, then
// /home/user/.gvfs/sftp on foo/file.avi will be passed. This will only work if
// a set of suitable GIO extensions (such as gvfs 2.26 compiled with FUSE
// support), is available and operational; if this is not the case, the URI will
// be passed unmodified to the application. Some URIs, such as mailto:, of
// course cannot be mapped to a POSIX path (in gvfs there's no FUSE mount for
// it); such URIs will be passed unmodified to the application.
//
// Specifically for gvfs 2.26 and later, the POSIX URI will be mapped back to
// the GIO URI in the #GFile constructors (since gvfs implements the #GVfs
// extension point). As such, if the application needs to examine the URI, it
// needs to use g_file_get_uri() or similar on #GFile. In other words, an
// application cannot assume that the URI passed to e.g.
// g_file_new_for_commandline_arg() is equal to the result of g_file_get_uri().
// The following snippet illustrates this:
//
//    GFile *f;
//    char *uri;
//
//    file = g_file_new_for_commandline_arg (uri_from_commandline);
//
//    uri = g_file_get_uri (file);
//    strcmp (uri, uri_from_commandline) == 0;
//    g_free (uri);
//
//    if (g_file_has_uri_scheme (file, "cdda"))
//      {
//        // do something special with uri
//      }
//    g_object_unref (file);
//
// This code will work when both cdda://sr0/Track 1.wav and
// /home/user/.gvfs/cdda on sr0/Track 1.wav is passed to the application. It
// should be noted that it's generally not safe for applications to rely on the
// format of a particular URIs. Different launcher applications (e.g. file
// managers) may have different ideas of what a given URI means.
type AppInfo struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*AppInfo)(nil)
)

// AppInfor describes AppInfo's interface methods.
type AppInfor interface {
	externglib.Objector

	// AddSupportsType adds a content type to the application information to
	// indicate the application is capable of opening files with the given
	// content type.
	AddSupportsType(contentType string) error
	// CanDelete obtains the information whether the Info can be deleted.
	CanDelete() bool
	// CanRemoveSupportsType checks if a supported content type can be removed
	// from an application.
	CanRemoveSupportsType() bool
	// Delete tries to delete a Info.
	Delete() bool
	// Dup creates a duplicate of a Info.
	Dup() AppInfoOverrider
	// Equal checks if two Infos are equal.
	Equal(appinfo2 AppInfoOverrider) bool
	// Commandline gets the commandline with which the application will be
	// started.
	Commandline() string
	// Description gets a human-readable description of an installed
	// application.
	Description() string
	// DisplayName gets the display name of the application.
	DisplayName() string
	// Executable gets the executable's name for the installed application.
	Executable() string
	// Icon gets the icon for the application.
	Icon() IconOverrider
	// ID gets the ID of an application.
	ID() string
	// Name gets the installed name of the application.
	Name() string
	// SupportedTypes retrieves the list of content types that app_info claims
	// to support.
	SupportedTypes() []string
	// Launch launches the application.
	Launch(files []FileOverrider, context *AppLaunchContext) error
	// LaunchURIs launches the application.
	LaunchURIs(uris []string, context *AppLaunchContext) error
	// LaunchURIsAsync: async version of g_app_info_launch_uris().
	LaunchURIsAsync(ctx context.Context, uris []string, context *AppLaunchContext, callback AsyncReadyCallback)
	// LaunchURIsFinish finishes a g_app_info_launch_uris_async() operation.
	LaunchURIsFinish(result AsyncResultOverrider) error
	// RemoveSupportsType removes a supported type from an application, if
	// possible.
	RemoveSupportsType(contentType string) error
	// SetAsDefaultForExtension sets the application as the default handler for
	// the given file extension.
	SetAsDefaultForExtension(extension string) error
	// SetAsDefaultForType sets the application as the default handler for a
	// given type.
	SetAsDefaultForType(contentType string) error
	// SetAsLastUsedForType sets the application as the last used application
	// for a given type.
	SetAsLastUsedForType(contentType string) error
	// ShouldShow checks if the application info should be shown in menus that
	// list available applications.
	ShouldShow() bool
	// SupportsFiles checks if the application accepts files as arguments.
	SupportsFiles() bool
	// SupportsURIs checks if the application supports reading files and
	// directories from URIs.
	SupportsURIs() bool
}

var _ AppInfor = (*AppInfo)(nil)

func ifaceInitAppInfor(gifacePtr, data C.gpointer) {
	iface := (*C.GAppInfoIface)(unsafe.Pointer(gifacePtr))
	iface.add_supports_type = (*[0]byte)(C._gotk4_gio2_AppInfoIface_add_supports_type)
	iface.can_delete = (*[0]byte)(C._gotk4_gio2_AppInfoIface_can_delete)
	iface.can_remove_supports_type = (*[0]byte)(C._gotk4_gio2_AppInfoIface_can_remove_supports_type)
	iface.do_delete = (*[0]byte)(C._gotk4_gio2_AppInfoIface_do_delete)
	iface.dup = (*[0]byte)(C._gotk4_gio2_AppInfoIface_dup)
	iface.equal = (*[0]byte)(C._gotk4_gio2_AppInfoIface_equal)
	iface.get_commandline = (*[0]byte)(C._gotk4_gio2_AppInfoIface_get_commandline)
	iface.get_description = (*[0]byte)(C._gotk4_gio2_AppInfoIface_get_description)
	iface.get_display_name = (*[0]byte)(C._gotk4_gio2_AppInfoIface_get_display_name)
	iface.get_executable = (*[0]byte)(C._gotk4_gio2_AppInfoIface_get_executable)
	iface.get_icon = (*[0]byte)(C._gotk4_gio2_AppInfoIface_get_icon)
	iface.get_id = (*[0]byte)(C._gotk4_gio2_AppInfoIface_get_id)
	iface.get_name = (*[0]byte)(C._gotk4_gio2_AppInfoIface_get_name)
	iface.get_supported_types = (*[0]byte)(C._gotk4_gio2_AppInfoIface_get_supported_types)
	iface.launch = (*[0]byte)(C._gotk4_gio2_AppInfoIface_launch)
	iface.launch_uris = (*[0]byte)(C._gotk4_gio2_AppInfoIface_launch_uris)
	iface.launch_uris_finish = (*[0]byte)(C._gotk4_gio2_AppInfoIface_launch_uris_finish)
	iface.remove_supports_type = (*[0]byte)(C._gotk4_gio2_AppInfoIface_remove_supports_type)
	iface.set_as_default_for_extension = (*[0]byte)(C._gotk4_gio2_AppInfoIface_set_as_default_for_extension)
	iface.set_as_default_for_type = (*[0]byte)(C._gotk4_gio2_AppInfoIface_set_as_default_for_type)
	iface.set_as_last_used_for_type = (*[0]byte)(C._gotk4_gio2_AppInfoIface_set_as_last_used_for_type)
	iface.should_show = (*[0]byte)(C._gotk4_gio2_AppInfoIface_should_show)
	iface.supports_files = (*[0]byte)(C._gotk4_gio2_AppInfoIface_supports_files)
	iface.supports_uris = (*[0]byte)(C._gotk4_gio2_AppInfoIface_supports_uris)
}

//export _gotk4_gio2_AppInfoIface_add_supports_type
func _gotk4_gio2_AppInfoIface_add_supports_type(arg0 *C.GAppInfo, arg1 *C.char, _cerr **C.GError) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	var _contentType string // out

	_contentType = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	_goerr := iface.AddSupportsType(_contentType)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_can_delete
func _gotk4_gio2_AppInfoIface_can_delete(arg0 *C.GAppInfo) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	ok := iface.CanDelete()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_can_remove_supports_type
func _gotk4_gio2_AppInfoIface_can_remove_supports_type(arg0 *C.GAppInfo) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	ok := iface.CanRemoveSupportsType()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_do_delete
func _gotk4_gio2_AppInfoIface_do_delete(arg0 *C.GAppInfo) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	ok := iface.DoDelete()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_dup
func _gotk4_gio2_AppInfoIface_dup(arg0 *C.GAppInfo) (cret *C.GAppInfo) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	appInfo := iface.Dup()

	cret = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appInfo).Native()))
	C.g_object_ref(C.gpointer(externglib.InternObject(appInfo).Native()))

	return cret
}

//export _gotk4_gio2_AppInfoIface_equal
func _gotk4_gio2_AppInfoIface_equal(arg0 *C.GAppInfo, arg1 *C.GAppInfo) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	var _appinfo2 AppInfoOverrider // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AppInfoOverrider)
			return ok
		})
		rv, ok := casted.(AppInfoOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_appinfo2 = rv
	}

	ok := iface.Equal(_appinfo2)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_get_commandline
func _gotk4_gio2_AppInfoIface_get_commandline(arg0 *C.GAppInfo) (cret *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	filename := iface.Commandline()

	if filename != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(cret))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_get_description
func _gotk4_gio2_AppInfoIface_get_description(arg0 *C.GAppInfo) (cret *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	utf8 := iface.Description()

	if utf8 != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
		defer C.free(unsafe.Pointer(cret))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_get_display_name
func _gotk4_gio2_AppInfoIface_get_display_name(arg0 *C.GAppInfo) (cret *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	utf8 := iface.DisplayName()

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_gio2_AppInfoIface_get_executable
func _gotk4_gio2_AppInfoIface_get_executable(arg0 *C.GAppInfo) (cret *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	filename := iface.Executable()

	cret = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_gio2_AppInfoIface_get_icon
func _gotk4_gio2_AppInfoIface_get_icon(arg0 *C.GAppInfo) (cret *C.GIcon) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	icon := iface.Icon()

	if icon != nil {
		cret = (*C.GIcon)(unsafe.Pointer(externglib.InternObject(icon).Native()))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_get_id
func _gotk4_gio2_AppInfoIface_get_id(arg0 *C.GAppInfo) (cret *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	utf8 := iface.ID()

	if utf8 != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
		defer C.free(unsafe.Pointer(cret))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_get_name
func _gotk4_gio2_AppInfoIface_get_name(arg0 *C.GAppInfo) (cret *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	utf8 := iface.Name()

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_gio2_AppInfoIface_get_supported_types
func _gotk4_gio2_AppInfoIface_get_supported_types(arg0 *C.GAppInfo) (cret **C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	utf8s := iface.SupportedTypes()

	{
		cret = (**C.char)(C.calloc(C.size_t((len(utf8s) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(cret))
		{
			out := unsafe.Slice(cret, len(utf8s)+1)
			var zero *C.char
			out[len(utf8s)] = zero
			for i := range utf8s {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(utf8s[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_launch
func _gotk4_gio2_AppInfoIface_launch(arg0 *C.GAppInfo, arg1 *C.GList, arg2 *C.GAppLaunchContext, _cerr **C.GError) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	var _files []FileOverrider     // out
	var _context *AppLaunchContext // out

	if arg1 != nil {
		_files = make([]FileOverrider, 0, gextras.ListSize(unsafe.Pointer(arg1)))
		gextras.MoveList(unsafe.Pointer(arg1), false, func(v unsafe.Pointer) {
			src := (*C.GFile)(v)
			var dst FileOverrider // out
			{
				objptr := unsafe.Pointer(src)
				if objptr == nil {
					panic("object of type gio.Filer is nil")
				}

				object := externglib.Take(objptr)
				casted := object.WalkCast(func(obj externglib.Objector) bool {
					_, ok := obj.(FileOverrider)
					return ok
				})
				rv, ok := casted.(FileOverrider)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
				}
				dst = rv
			}
			_files = append(_files, dst)
		})
	}
	if arg2 != nil {
		_context = wrapAppLaunchContext(externglib.Take(unsafe.Pointer(arg2)))
	}

	_goerr := iface.Launch(_files, _context)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_launch_uris
func _gotk4_gio2_AppInfoIface_launch_uris(arg0 *C.GAppInfo, arg1 *C.GList, arg2 *C.GAppLaunchContext, _cerr **C.GError) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	var _uris []string             // out
	var _context *AppLaunchContext // out

	if arg1 != nil {
		_uris = make([]string, 0, gextras.ListSize(unsafe.Pointer(arg1)))
		gextras.MoveList(unsafe.Pointer(arg1), false, func(v unsafe.Pointer) {
			src := (*C.gchar)(v)
			var dst string // out
			dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
			_uris = append(_uris, dst)
		})
	}
	if arg2 != nil {
		_context = wrapAppLaunchContext(externglib.Take(unsafe.Pointer(arg2)))
	}

	_goerr := iface.LaunchURIs(_uris, _context)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_launch_uris_finish
func _gotk4_gio2_AppInfoIface_launch_uris_finish(arg0 *C.GAppInfo, arg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	var _result AsyncResultOverrider // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AsyncResultOverrider)
			return ok
		})
		rv, ok := casted.(AsyncResultOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	_goerr := iface.LaunchURIsFinish(_result)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_remove_supports_type
func _gotk4_gio2_AppInfoIface_remove_supports_type(arg0 *C.GAppInfo, arg1 *C.char, _cerr **C.GError) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	var _contentType string // out

	_contentType = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	_goerr := iface.RemoveSupportsType(_contentType)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_set_as_default_for_extension
func _gotk4_gio2_AppInfoIface_set_as_default_for_extension(arg0 *C.GAppInfo, arg1 *C.char, _cerr **C.GError) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	var _extension string // out

	_extension = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	_goerr := iface.SetAsDefaultForExtension(_extension)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_set_as_default_for_type
func _gotk4_gio2_AppInfoIface_set_as_default_for_type(arg0 *C.GAppInfo, arg1 *C.char, _cerr **C.GError) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	var _contentType string // out

	_contentType = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	_goerr := iface.SetAsDefaultForType(_contentType)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_set_as_last_used_for_type
func _gotk4_gio2_AppInfoIface_set_as_last_used_for_type(arg0 *C.GAppInfo, arg1 *C.char, _cerr **C.GError) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	var _contentType string // out

	_contentType = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	_goerr := iface.SetAsLastUsedForType(_contentType)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_should_show
func _gotk4_gio2_AppInfoIface_should_show(arg0 *C.GAppInfo) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	ok := iface.ShouldShow()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_supports_files
func _gotk4_gio2_AppInfoIface_supports_files(arg0 *C.GAppInfo) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	ok := iface.SupportsFiles()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_AppInfoIface_supports_uris
func _gotk4_gio2_AppInfoIface_supports_uris(arg0 *C.GAppInfo) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(AppInfoOverrider)

	ok := iface.SupportsURIs()

	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapAppInfo(obj *externglib.Object) *AppInfo {
	return &AppInfo{
		Object: obj,
	}
}

func marshalAppInfo(p uintptr) (interface{}, error) {
	return wrapAppInfo(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddSupportsType adds a content type to the application information to
// indicate the application is capable of opening files with the given content
// type.
//
// The function takes the following parameters:
//
//    - contentType: string.
//
func (appinfo *AppInfo) AddSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_add_supports_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CanDelete obtains the information whether the Info can be deleted. See
// g_app_info_delete().
//
// The function returns the following values:
//
//    - ok: TRUE if appinfo can be deleted.
//
func (appinfo *AppInfo) CanDelete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_can_delete(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanRemoveSupportsType checks if a supported content type can be removed from
// an application.
//
// The function returns the following values:
//
//    - ok: TRUE if it is possible to remove supported content types from a given
//      appinfo, FALSE if not.
//
func (appinfo *AppInfo) CanRemoveSupportsType() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_can_remove_supports_type(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Delete tries to delete a Info.
//
// On some platforms, there may be a difference between user-defined Infos which
// can be deleted, and system-wide ones which cannot. See
// g_app_info_can_delete().
//
// The function returns the following values:
//
//    - ok: TRUE if appinfo has been deleted.
//
func (appinfo *AppInfo) Delete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_delete(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dup creates a duplicate of a Info.
//
// The function returns the following values:
//
//    - appInfo: duplicate of appinfo.
//
func (appinfo *AppInfo) Dup() AppInfoOverrider {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GAppInfo // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_dup(_arg0)
	runtime.KeepAlive(appinfo)

	var _appInfo AppInfoOverrider // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := externglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AppInfoOverrider)
			return ok
		})
		rv, ok := casted.(AppInfoOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_appInfo = rv
	}

	return _appInfo
}

// Equal checks if two Infos are equal.
//
// Note that the check *may not* compare each individual field, and only does an
// identity check. In case detecting changes in the contents is needed, program
// code must additionally compare relevant fields.
//
// The function takes the following parameters:
//
//    - appinfo2: second Info.
//
// The function returns the following values:
//
//    - ok: TRUE if appinfo1 is equal to appinfo2. FALSE otherwise.
//
func (appinfo1 *AppInfo) Equal(appinfo2 AppInfoOverrider) bool {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo1).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo2).Native()))

	_cret = C.g_app_info_equal(_arg0, _arg1)
	runtime.KeepAlive(appinfo1)
	runtime.KeepAlive(appinfo2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Commandline gets the commandline with which the application will be started.
//
// The function returns the following values:
//
//    - filename (optional): string containing the appinfo's commandline, or NULL
//      if this information is not available.
//
func (appinfo *AppInfo) Commandline() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_commandline(_arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// Description gets a human-readable description of an installed application.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing a description of the application
//      appinfo, or NULL if none.
//
func (appinfo *AppInfo) Description() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_description(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// DisplayName gets the display name of the application. The display name is
// often more descriptive to the user than the name itself.
//
// The function returns the following values:
//
//    - utf8: display name of the application for appinfo, or the name if no
//      display name is available.
//
func (appinfo *AppInfo) DisplayName() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_display_name(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Executable gets the executable's name for the installed application.
//
// The function returns the following values:
//
//    - filename: string containing the appinfo's application binaries name.
//
func (appinfo *AppInfo) Executable() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_executable(_arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// Icon gets the icon for the application.
//
// The function returns the following values:
//
//    - icon (optional): default #GIcon for appinfo or NULL if there is no
//      default icon.
//
func (appinfo *AppInfo) Icon() IconOverrider {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GIcon    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_icon(_arg0)
	runtime.KeepAlive(appinfo)

	var _icon IconOverrider // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(IconOverrider)
				return ok
			})
			rv, ok := casted.(IconOverrider)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Iconner")
			}
			_icon = rv
		}
	}

	return _icon
}

// ID gets the ID of an application. An id is a string that identifies the
// application. The exact format of the id is platform dependent. For instance,
// on Unix this is the desktop file id from the xdg menu specification.
//
// Note that the returned ID may be NULL, depending on how the appinfo has been
// constructed.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the application's ID.
//
func (appinfo *AppInfo) ID() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_id(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Name gets the installed name of the application.
//
// The function returns the following values:
//
//    - utf8: name of the application for appinfo.
//
func (appinfo *AppInfo) Name() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_name(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SupportedTypes retrieves the list of content types that app_info claims to
// support. If this information is not provided by the environment, this
// function will return NULL. This function does not take in consideration
// associations added with g_app_info_add_supports_type(), but only those
// exported directly by the application.
//
// The function returns the following values:
//
//    - utf8s: a list of content types.
//
func (appinfo *AppInfo) SupportedTypes() []string {
	var _arg0 *C.GAppInfo // out
	var _cret **C.char    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_supported_types(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8s []string // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Launch launches the application. Passes files to the launched application as
// arguments, using the optional context to get information about the details of
// the launcher (like what screen it is on). On error, error will be set
// accordingly.
//
// To launch the application without arguments pass a NULL files list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// Some URIs can be changed when passed through a GFile (for instance
// unsupported URIs with strange formats like mailto:), so if you have a textual
// URI you want to pass in as argument, consider using g_app_info_launch_uris()
// instead.
//
// The launched application inherits the environment of the launching process,
// but it can be modified with g_app_launch_context_setenv() and
// g_app_launch_context_unsetenv().
//
// On UNIX, this function sets the GIO_LAUNCHED_DESKTOP_FILE environment
// variable with the path of the launched desktop file and
// GIO_LAUNCHED_DESKTOP_FILE_PID to the process id of the launched process. This
// can be used to ignore GIO_LAUNCHED_DESKTOP_FILE, should it be inherited by
// further processes. The DISPLAY and DESKTOP_STARTUP_ID environment variables
// are also set, based on information provided in context.
//
// The function takes the following parameters:
//
//    - files (optional) of #GFile objects.
//    - context (optional) or NULL.
//
func (appinfo *AppInfo) Launch(files []FileOverrider, context *AppLaunchContext) error {
	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))
	if files != nil {
		for i := len(files) - 1; i >= 0; i-- {
			src := files[i]
			var dst *C.GFile // out
			dst = (*C.GFile)(unsafe.Pointer(externglib.InternObject(src).Native()))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	}

	C.g_app_info_launch(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(files)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LaunchURIs launches the application. This passes the uris to the launched
// application as arguments, using the optional context to get information about
// the details of the launcher (like what screen it is on). On error, error will
// be set accordingly.
//
// To launch the application without arguments pass a NULL uris list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// The function takes the following parameters:
//
//    - uris (optional) containing URIs to launch.
//    - context (optional) or NULL.
//
func (appinfo *AppInfo) LaunchURIs(uris []string, context *AppLaunchContext) error {
	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))
	if uris != nil {
		for i := len(uris) - 1; i >= 0; i-- {
			src := uris[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	}

	C.g_app_info_launch_uris(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(uris)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LaunchURIsAsync: async version of g_app_info_launch_uris().
//
// The callback is invoked immediately after the application launch, but it
// waits for activation in case of D-Busâ€“activated applications and also
// provides extended error information for sandboxed applications, see notes for
// g_app_info_launch_default_for_uri_async().
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - uris (optional) containing URIs to launch.
//    - context (optional) or NULL.
//    - callback (optional) to call when the request is done.
//
func (appinfo *AppInfo) LaunchURIsAsync(ctx context.Context, uris []string, context *AppLaunchContext, callback AsyncReadyCallback) {
	var _arg0 *C.GAppInfo           // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GList              // out
	var _arg2 *C.GAppLaunchContext  // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if uris != nil {
		for i := len(uris) - 1; i >= 0; i-- {
			src := uris[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_app_info_launch_uris_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uris)
	runtime.KeepAlive(context)
	runtime.KeepAlive(callback)
}

// LaunchURIsFinish finishes a g_app_info_launch_uris_async() operation.
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (appinfo *AppInfo) LaunchURIsFinish(result AsyncResultOverrider) error {
	var _arg0 *C.GAppInfo     // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(externglib.InternObject(result).Native()))

	C.g_app_info_launch_uris_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveSupportsType removes a supported type from an application, if possible.
//
// The function takes the following parameters:
//
//    - contentType: string.
//
func (appinfo *AppInfo) RemoveSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_remove_supports_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAsDefaultForExtension sets the application as the default handler for the
// given file extension.
//
// The function takes the following parameters:
//
//    - extension: string containing the file extension (without the dot).
//
func (appinfo *AppInfo) SetAsDefaultForExtension(extension string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_extension(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(extension)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAsDefaultForType sets the application as the default handler for a given
// type.
//
// The function takes the following parameters:
//
//    - contentType: content type.
//
func (appinfo *AppInfo) SetAsDefaultForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAsLastUsedForType sets the application as the last used application for a
// given type. This will make the application appear as first in the list
// returned by g_app_info_get_recommended_for_type(), regardless of the default
// application for that content type.
//
// The function takes the following parameters:
//
//    - contentType: content type.
//
func (appinfo *AppInfo) SetAsLastUsedForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_last_used_for_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ShouldShow checks if the application info should be shown in menus that list
// available applications.
//
// The function returns the following values:
//
//    - ok: TRUE if the appinfo should be shown, FALSE otherwise.
//
func (appinfo *AppInfo) ShouldShow() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_should_show(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsFiles checks if the application accepts files as arguments.
//
// The function returns the following values:
//
//    - ok: TRUE if the appinfo supports files.
//
func (appinfo *AppInfo) SupportsFiles() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_supports_files(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsURIs checks if the application supports reading files and directories
// from URIs.
//
// The function returns the following values:
//
//    - ok: TRUE if the appinfo supports URIs.
//
func (appinfo *AppInfo) SupportsURIs() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_supports_uris(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppInfoCreateFromCommandline creates a new Info from the given information.
//
// Note that for commandline, the quoting rules of the Exec key of the
// freedesktop.org Desktop Entry Specification
// (http://freedesktop.org/Standards/desktop-entry-spec) are applied. For
// example, if the commandline contains percent-encoded URIs, the
// percent-character must be doubled in order to prevent it from being swallowed
// by Exec key unquoting. See the specification for exact quoting rules.
//
// The function takes the following parameters:
//
//    - commandline to use.
//    - applicationName (optional): application name, or NULL to use commandline.
//    - flags that can specify details of the created Info.
//
// The function returns the following values:
//
//    - appInfo: new Info for given command.
//
func AppInfoCreateFromCommandline(commandline, applicationName string, flags AppInfoCreateFlags) (AppInfoOverrider, error) {
	var _arg1 *C.char               // out
	var _arg2 *C.char               // out
	var _arg3 C.GAppInfoCreateFlags // out
	var _cret *C.GAppInfo           // in
	var _cerr *C.GError             // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(commandline)))
	defer C.free(unsafe.Pointer(_arg1))
	if applicationName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(applicationName)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.GAppInfoCreateFlags(flags)

	_cret = C.g_app_info_create_from_commandline(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(commandline)
	runtime.KeepAlive(applicationName)
	runtime.KeepAlive(flags)

	var _appInfo AppInfoOverrider // out
	var _goerr error              // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := externglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AppInfoOverrider)
			return ok
		})
		rv, ok := casted.(AppInfoOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_appInfo = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _appInfo, _goerr
}

// AppInfoGetAll gets a list of all of the applications currently registered on
// this system.
//
// For desktop files, this includes applications that have NoDisplay=true set or
// are excluded from display by means of OnlyShowIn or NotShowIn. See
// g_app_info_should_show(). The returned list does not include applications
// which have the Hidden key set.
//
// The function returns the following values:
//
//    - list: newly allocated #GList of references to Infos.
//
func AppInfoGetAll() []AppInfoOverrider {
	var _cret *C.GList // in

	_cret = C.g_app_info_get_all()

	var _list []AppInfoOverrider // out

	_list = make([]AppInfoOverrider, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst AppInfoOverrider // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.AppInfor is nil")
			}

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(AppInfoOverrider)
				return ok
			})
			rv, ok := casted.(AppInfoOverrider)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoGetAllForType gets a list of all Infos for a given content type,
// including the recommended and fallback Infos. See
// g_app_info_get_recommended_for_type() and g_app_info_get_fallback_for_type().
//
// The function takes the following parameters:
//
//    - contentType: content type to find a Info for.
//
// The function returns the following values:
//
//    - list of Infos for given content_type or NULL on error.
//
func AppInfoGetAllForType(contentType string) []AppInfoOverrider {
	var _arg1 *C.char  // out
	var _cret *C.GList // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_all_for_type(_arg1)
	runtime.KeepAlive(contentType)

	var _list []AppInfoOverrider // out

	_list = make([]AppInfoOverrider, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst AppInfoOverrider // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.AppInfor is nil")
			}

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(AppInfoOverrider)
				return ok
			})
			rv, ok := casted.(AppInfoOverrider)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoGetDefaultForType gets the default Info for a given content type.
//
// The function takes the following parameters:
//
//    - contentType: content type to find a Info for.
//    - mustSupportUris: if TRUE, the Info is expected to support URIs.
//
// The function returns the following values:
//
//    - appInfo (optional) for given content_type or NULL on error.
//
func AppInfoGetDefaultForType(contentType string, mustSupportUris bool) AppInfoOverrider {
	var _arg1 *C.char     // out
	var _arg2 C.gboolean  // out
	var _cret *C.GAppInfo // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))
	if mustSupportUris {
		_arg2 = C.TRUE
	}

	_cret = C.g_app_info_get_default_for_type(_arg1, _arg2)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(mustSupportUris)

	var _appInfo AppInfoOverrider // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(AppInfoOverrider)
				return ok
			})
			rv, ok := casted.(AppInfoOverrider)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
			}
			_appInfo = rv
		}
	}

	return _appInfo
}

// AppInfoGetDefaultForURIScheme gets the default application for handling URIs
// with the given URI scheme. A URI scheme is the initial part of the URI, up to
// but not including the ':', e.g. "http", "ftp" or "sip".
//
// The function takes the following parameters:
//
//    - uriScheme: string containing a URI scheme.
//
// The function returns the following values:
//
//    - appInfo (optional) for given uri_scheme or NULL on error.
//
func AppInfoGetDefaultForURIScheme(uriScheme string) AppInfoOverrider {
	var _arg1 *C.char     // out
	var _cret *C.GAppInfo // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_default_for_uri_scheme(_arg1)
	runtime.KeepAlive(uriScheme)

	var _appInfo AppInfoOverrider // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(AppInfoOverrider)
				return ok
			})
			rv, ok := casted.(AppInfoOverrider)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
			}
			_appInfo = rv
		}
	}

	return _appInfo
}

// AppInfoGetFallbackForType gets a list of fallback Infos for a given content
// type, i.e. those applications which claim to support the given content type
// by MIME type subclassing and not directly.
//
// The function takes the following parameters:
//
//    - contentType: content type to find a Info for.
//
// The function returns the following values:
//
//    - list of Infos for given content_type or NULL on error.
//
func AppInfoGetFallbackForType(contentType string) []AppInfoOverrider {
	var _arg1 *C.gchar // out
	var _cret *C.GList // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_fallback_for_type(_arg1)
	runtime.KeepAlive(contentType)

	var _list []AppInfoOverrider // out

	_list = make([]AppInfoOverrider, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst AppInfoOverrider // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.AppInfor is nil")
			}

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(AppInfoOverrider)
				return ok
			})
			rv, ok := casted.(AppInfoOverrider)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoGetRecommendedForType gets a list of recommended Infos for a given
// content type, i.e. those applications which claim to support the given
// content type exactly, and not by MIME type subclassing. Note that the first
// application of the list is the last used one, i.e. the last one for which
// g_app_info_set_as_last_used_for_type() has been called.
//
// The function takes the following parameters:
//
//    - contentType: content type to find a Info for.
//
// The function returns the following values:
//
//    - list of Infos for given content_type or NULL on error.
//
func AppInfoGetRecommendedForType(contentType string) []AppInfoOverrider {
	var _arg1 *C.gchar // out
	var _cret *C.GList // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_recommended_for_type(_arg1)
	runtime.KeepAlive(contentType)

	var _list []AppInfoOverrider // out

	_list = make([]AppInfoOverrider, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst AppInfoOverrider // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.AppInfor is nil")
			}

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(AppInfoOverrider)
				return ok
			})
			rv, ok := casted.(AppInfoOverrider)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoLaunchDefaultForURI: utility function that launches the default
// application registered to handle the specified uri. Synchronous I/O is done
// on the uri to detect the type of the file if required.
//
// The D-Busâ€“activated applications don't have to be started if your application
// terminates too soon after this function. To prevent this, use
// g_app_info_launch_default_for_uri_async() instead.
//
// The function takes the following parameters:
//
//    - uri to show.
//    - context (optional): optional LaunchContext.
//
func AppInfoLaunchDefaultForURI(uri string, context *AppLaunchContext) error {
	var _arg1 *C.char              // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	}

	C.g_app_info_launch_default_for_uri(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AppInfoLaunchDefaultForURIAsync: async version of
// g_app_info_launch_default_for_uri().
//
// This version is useful if you are interested in receiving error information
// in the case where the application is sandboxed and the portal may present an
// application chooser dialog to the user.
//
// This is also useful if you want to be sure that the D-Busâ€“activated
// applications are really started before termination and if you are interested
// in receiving error information from their activation.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - uri to show.
//    - context (optional): optional LaunchContext.
//    - callback (optional) to call when the request is done.
//
func AppInfoLaunchDefaultForURIAsync(ctx context.Context, uri string, context *AppLaunchContext, callback AsyncReadyCallback) {
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 *C.GAppLaunchContext  // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_app_info_launch_default_for_uri_async(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(context)
	runtime.KeepAlive(callback)
}

// AppInfoLaunchDefaultForURIFinish finishes an asynchronous
// launch-default-for-uri operation.
//
// The function takes the following parameters:
//
//    - result: Result.
//
func AppInfoLaunchDefaultForURIFinish(result AsyncResultOverrider) error {
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(externglib.InternObject(result).Native()))

	C.g_app_info_launch_default_for_uri_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AppInfoResetTypeAssociations removes all changes to the type associations
// done by g_app_info_set_as_default_for_type(),
// g_app_info_set_as_default_for_extension(), g_app_info_add_supports_type() or
// g_app_info_remove_supports_type().
//
// The function takes the following parameters:
//
//    - contentType: content type.
//
func AppInfoResetTypeAssociations(contentType string) {
	var _arg1 *C.char // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_reset_type_associations(_arg1)
	runtime.KeepAlive(contentType)
}

// AppInfoMonitorGet gets the InfoMonitor for the current thread-default main
// context.
//
// The InfoMonitor will emit a "changed" signal in the thread-default main
// context whenever the list of installed applications (as reported by
// g_app_info_get_all()) may have changed.
//
// You must only call g_object_unref() on the return value from under the same
// main context as you created it.
//
// The function returns the following values:
//
//    - appInfoMonitor: reference to a InfoMonitor.
//
func AppInfoMonitorGet() *AppInfoMonitor {
	var _cret *C.GAppInfoMonitor // in

	_cret = C.g_app_info_monitor_get()

	var _appInfoMonitor *AppInfoMonitor // out

	_appInfoMonitor = wrapAppInfoMonitor(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appInfoMonitor
}

// AppLaunchContextOverrider contains methods that are overridable.
type AppLaunchContextOverrider interface {
	externglib.Objector
	// Display gets the display string for the context. This is used to ensure
	// new applications are started on the same display as the launching
	// application, by setting the DISPLAY environment variable.
	//
	// The function takes the following parameters:
	//
	//    - info: Info.
	//    - files of #GFile objects.
	//
	// The function returns the following values:
	//
	//    - utf8 (optional): display string for the display.
	//
	Display(info AppInfoOverrider, files []FileOverrider) string
	// StartupNotifyID initiates startup notification for the application and
	// returns the DESKTOP_STARTUP_ID for the launched operation, if supported.
	//
	// Startup notification IDs are defined in the FreeDesktop.Org Startup
	// Notifications standard
	// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
	//
	// The function takes the following parameters:
	//
	//    - info: Info.
	//    - files of of #GFile objects.
	//
	// The function returns the following values:
	//
	//    - utf8 (optional): startup notification ID for the application, or NULL
	//      if not supported.
	//
	StartupNotifyID(info AppInfoOverrider, files []FileOverrider) string
	// LaunchFailed: called when an application has failed to launch, so that it
	// can cancel the application startup notification started in
	// g_app_launch_context_get_startup_notify_id().
	//
	// The function takes the following parameters:
	//
	//    - startupNotifyId: startup notification id that was returned by
	//      g_app_launch_context_get_startup_notify_id().
	//
	LaunchFailed(startupNotifyId string)
	// The function takes the following parameters:
	//
	//    - info
	//    - platformData
	//
	Launched(info AppInfoOverrider, platformData *glib.Variant)
}

// WrapAppLaunchContextOverrider wraps the AppLaunchContextOverrider
// interface implementation to access the instance methods.
func WrapAppLaunchContextOverrider(obj AppLaunchContextOverrider) *AppLaunchContext {
	return wrapAppLaunchContext(externglib.BaseObject(obj))
}

// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
type AppLaunchContext struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*AppLaunchContext)(nil)
)

func classInitAppLaunchContexter(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GAppLaunchContextClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GAppLaunchContextClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface {
		Display(info AppInfoOverrider, files []FileOverrider) string
	}); ok {
		pclass.get_display = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_get_display)
	}

	if _, ok := goval.(interface {
		StartupNotifyID(info AppInfoOverrider, files []FileOverrider) string
	}); ok {
		pclass.get_startup_notify_id = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_get_startup_notify_id)
	}

	if _, ok := goval.(interface{ LaunchFailed(startupNotifyId string) }); ok {
		pclass.launch_failed = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_launch_failed)
	}

	if _, ok := goval.(interface {
		Launched(info AppInfoOverrider, platformData *glib.Variant)
	}); ok {
		pclass.launched = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_launched)
	}
}

//export _gotk4_gio2_AppLaunchContextClass_get_display
func _gotk4_gio2_AppLaunchContextClass_get_display(arg0 *C.GAppLaunchContext, arg1 *C.GAppInfo, arg2 *C.GList) (cret *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Display(info AppInfoOverrider, files []FileOverrider) string
	})

	var _info AppInfoOverrider // out
	var _files []FileOverrider // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AppInfoOverrider)
			return ok
		})
		rv, ok := casted.(AppInfoOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_info = rv
	}
	_files = make([]FileOverrider, 0, gextras.ListSize(unsafe.Pointer(arg2)))
	gextras.MoveList(unsafe.Pointer(arg2), false, func(v unsafe.Pointer) {
		src := (*C.GFile)(v)
		var dst FileOverrider // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.Filer is nil")
			}

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(FileOverrider)
				return ok
			})
			rv, ok := casted.(FileOverrider)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
			}
			dst = rv
		}
		_files = append(_files, dst)
	})

	utf8 := iface.Display(_info, _files)

	if utf8 != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
	}

	return cret
}

//export _gotk4_gio2_AppLaunchContextClass_get_startup_notify_id
func _gotk4_gio2_AppLaunchContextClass_get_startup_notify_id(arg0 *C.GAppLaunchContext, arg1 *C.GAppInfo, arg2 *C.GList) (cret *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		StartupNotifyID(info AppInfoOverrider, files []FileOverrider) string
	})

	var _info AppInfoOverrider // out
	var _files []FileOverrider // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AppInfoOverrider)
			return ok
		})
		rv, ok := casted.(AppInfoOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_info = rv
	}
	_files = make([]FileOverrider, 0, gextras.ListSize(unsafe.Pointer(arg2)))
	gextras.MoveList(unsafe.Pointer(arg2), false, func(v unsafe.Pointer) {
		src := (*C.GFile)(v)
		var dst FileOverrider // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.Filer is nil")
			}

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(FileOverrider)
				return ok
			})
			rv, ok := casted.(FileOverrider)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
			}
			dst = rv
		}
		_files = append(_files, dst)
	})

	utf8 := iface.StartupNotifyID(_info, _files)

	if utf8 != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
	}

	return cret
}

//export _gotk4_gio2_AppLaunchContextClass_launch_failed
func _gotk4_gio2_AppLaunchContextClass_launch_failed(arg0 *C.GAppLaunchContext, arg1 *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ LaunchFailed(startupNotifyId string) })

	var _startupNotifyId string // out

	_startupNotifyId = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	iface.LaunchFailed(_startupNotifyId)
}

//export _gotk4_gio2_AppLaunchContextClass_launched
func _gotk4_gio2_AppLaunchContextClass_launched(arg0 *C.GAppLaunchContext, arg1 *C.GAppInfo, arg2 *C.GVariant) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Launched(info AppInfoOverrider, platformData *glib.Variant)
	})

	var _info AppInfoOverrider      // out
	var _platformData *glib.Variant // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AppInfoOverrider)
			return ok
		})
		rv, ok := casted.(AppInfoOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_info = rv
	}
	_platformData = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.g_variant_ref(arg2)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_platformData)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	iface.Launched(_info, _platformData)
}

func wrapAppLaunchContext(obj *externglib.Object) *AppLaunchContext {
	return &AppLaunchContext{
		Object: obj,
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	return wrapAppLaunchContext(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gio2_AppLaunchContext_ConnectLaunchFailed
func _gotk4_gio2_AppLaunchContext_ConnectLaunchFailed(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(startupNotifyId string)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(startupNotifyId string))
	}

	var _startupNotifyId string // out

	_startupNotifyId = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_startupNotifyId)
}

// ConnectLaunchFailed signal is emitted when a Info launch fails. The startup
// notification id is provided, so that the launcher can cancel the startup
// notification.
func (context *AppLaunchContext) ConnectLaunchFailed(f func(startupNotifyId string)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(context, "launch-failed", false, unsafe.Pointer(C._gotk4_gio2_AppLaunchContext_ConnectLaunchFailed), f)
}

//export _gotk4_gio2_AppLaunchContext_ConnectLaunched
func _gotk4_gio2_AppLaunchContext_ConnectLaunched(arg0 C.gpointer, arg1 *C.GAppInfo, arg2 *C.GVariant, arg3 C.guintptr) {
	var f func(info AppInfoOverrider, platformData *glib.Variant)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(info AppInfoOverrider, platformData *glib.Variant))
	}

	var _info AppInfoOverrider      // out
	var _platformData *glib.Variant // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AppInfoOverrider)
			return ok
		})
		rv, ok := casted.(AppInfoOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_info = rv
	}
	_platformData = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.g_variant_ref(arg2)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_platformData)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	f(_info, _platformData)
}

// ConnectLaunched signal is emitted when a Info is successfully launched. The
// platform_data is an GVariant dictionary mapping strings to variants (ie
// a{sv}), which contains additional, platform-specific data about this launch.
// On UNIX, at least the "pid" and "startup-notification-id" keys will be
// present.
func (context *AppLaunchContext) ConnectLaunched(f func(info AppInfoOverrider, platformData *glib.Variant)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(context, "launched", false, unsafe.Pointer(C._gotk4_gio2_AppLaunchContext_ConnectLaunched), f)
}

// NewAppLaunchContext creates a new application launch context. This is not
// normally used, instead you instantiate a subclass of this, such as
// AppLaunchContext.
//
// The function returns the following values:
//
//    - appLaunchContext: LaunchContext.
//
func NewAppLaunchContext() *AppLaunchContext {
	var _cret *C.GAppLaunchContext // in

	_cret = C.g_app_launch_context_new()

	var _appLaunchContext *AppLaunchContext // out

	_appLaunchContext = wrapAppLaunchContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appLaunchContext
}

// Display gets the display string for the context. This is used to ensure new
// applications are started on the same display as the launching application, by
// setting the DISPLAY environment variable.
//
// The function takes the following parameters:
//
//    - info: Info.
//    - files of #GFile objects.
//
// The function returns the following values:
//
//    - utf8 (optional): display string for the display.
//
func (context *AppLaunchContext) Display(info AppInfoOverrider, files []FileOverrider) string {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(externglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C.g_app_launch_context_get_display(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Environment gets the complete environment variable list to be passed to the
// child process when context is used to launch an application. This is a
// NULL-terminated array of strings, where each string has the form KEY=VALUE.
//
// The function returns the following values:
//
//    - filenames: the child's environment.
//
func (context *AppLaunchContext) Environment() []string {
	var _arg0 *C.GAppLaunchContext // out
	var _cret **C.char             // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))

	_cret = C.g_app_launch_context_get_environment(_arg0)
	runtime.KeepAlive(context)

	var _filenames []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// StartupNotifyID initiates startup notification for the application and
// returns the DESKTOP_STARTUP_ID for the launched operation, if supported.
//
// Startup notification IDs are defined in the FreeDesktop.Org Startup
// Notifications standard
// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
//
// The function takes the following parameters:
//
//    - info: Info.
//    - files of of #GFile objects.
//
// The function returns the following values:
//
//    - utf8 (optional): startup notification ID for the application, or NULL if
//      not supported.
//
func (context *AppLaunchContext) StartupNotifyID(info AppInfoOverrider, files []FileOverrider) string {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(externglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C.g_app_launch_context_get_startup_notify_id(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// LaunchFailed: called when an application has failed to launch, so that it can
// cancel the application startup notification started in
// g_app_launch_context_get_startup_notify_id().
//
// The function takes the following parameters:
//
//    - startupNotifyId: startup notification id that was returned by
//      g_app_launch_context_get_startup_notify_id().
//
func (context *AppLaunchContext) LaunchFailed(startupNotifyId string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(startupNotifyId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_launch_context_launch_failed(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(startupNotifyId)
}

// Setenv arranges for variable to be set to value in the child's environment
// when context is used to launch an application.
//
// The function takes the following parameters:
//
//    - variable: environment variable to set.
//    - value for to set the variable to.
//
func (context *AppLaunchContext) Setenv(variable, value string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out
	var _arg2 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_app_launch_context_setenv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
}

// Unsetenv arranges for variable to be unset in the child's environment when
// context is used to launch an application.
//
// The function takes the following parameters:
//
//    - variable: environment variable to remove.
//
func (context *AppLaunchContext) Unsetenv(variable string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_launch_context_unsetenv(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(variable)
}
