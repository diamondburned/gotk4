// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GTypeDatagramBased returns the GType for the type DatagramBased.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeDatagramBased() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gio", "DatagramBased").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalDatagramBased)
	return gtype
}

// DatagramBasedOverrider contains methods that are overridable.
type DatagramBasedOverrider interface {
}

// DatagramBased is a networking interface for representing datagram-based
// communications. It is a more or less direct mapping of the core parts of the
// BSD socket API in a portable GObject interface. It is implemented by
// #GSocket, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
//
// Based is entirely platform independent, and is intended to be used alongside
// higher-level networking APIs such as OStream.
//
// It uses vectored scatter/gather I/O by default, allowing for many messages to
// be sent or received in a single call. Where possible, implementations of the
// interface should take advantage of vectored I/O to minimise processing or
// system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
// possible. Callers should take advantage of scatter/gather I/O (the use of
// multiple buffers per message) to avoid unnecessary copying of data to
// assemble or disassemble a message.
//
// Each Based operation has a timeout parameter which may be negative for
// blocking behaviour, zero for non-blocking behaviour, or positive for timeout
// behaviour. A blocking operation blocks until finished or there is an error. A
// non-blocking operation will return immediately with a G_IO_ERROR_WOULD_BLOCK
// error if it cannot make progress. A timeout operation will block until the
// operation is complete or the timeout expires; if the timeout expires it will
// return what progress it made, or G_IO_ERROR_TIMED_OUT if no progress was
// made. To know when a call would successfully run you can call
// g_datagram_based_condition_check() or g_datagram_based_condition_wait(). You
// can also use g_datagram_based_create_source() and attach it to a Context to
// get callbacks when I/O is possible.
//
// When running a non-blocking operation applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// As with #GSocket, Baseds can be either connection oriented (for example,
// SCTP) or connectionless (for example, UDP). Baseds must be datagram-based,
// not stream-based. The interface does not cover connection establishment â€” use
// methods on the underlying type to establish a connection before sending and
// receiving data through the Based API. For connectionless socket types the
// target/source address is specified or received in each I/O operation.
//
// Like most other APIs in GLib, Based is not inherently thread safe. To use a
// Based concurrently from multiple threads, you must implement your own
// locking.
//
// DatagramBased wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DatagramBased struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DatagramBased)(nil)
)

// DatagramBasedder describes DatagramBased's interface methods.
type DatagramBasedder interface {
	coreglib.Objector

	baseDatagramBased() *DatagramBased
}

var _ DatagramBasedder = (*DatagramBased)(nil)

func ifaceInitDatagramBasedder(gifacePtr, data C.gpointer) {
}

func wrapDatagramBased(obj *coreglib.Object) *DatagramBased {
	return &DatagramBased{
		Object: obj,
	}
}

func marshalDatagramBased(p uintptr) (interface{}, error) {
	return wrapDatagramBased(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *DatagramBased) baseDatagramBased() *DatagramBased {
	return v
}

// BaseDatagramBased returns the underlying base object.
func BaseDatagramBased(obj DatagramBasedder) *DatagramBased {
	return obj.baseDatagramBased()
}
