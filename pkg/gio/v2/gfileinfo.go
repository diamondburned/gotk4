// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

// glib.Type values for gfileinfo.go.
var GTypeFileInfo = externglib.Type(C.g_file_info_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeFileInfo, F: marshalFileInfo},
	})
}

// FILE_ATTRIBUTE_ACCESS_CAN_DELETE: key in the "access" namespace for checking
// deletion privileges. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN. This attribute will be TRUE if the user is
// able to delete the file.
const FILE_ATTRIBUTE_ACCESS_CAN_DELETE = "access::can-delete"

// FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: key in the "access" namespace for getting
// execution privileges. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN. This attribute will be TRUE if the user is
// able to execute the file.
const FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE = "access::can-execute"

// FILE_ATTRIBUTE_ACCESS_CAN_READ: key in the "access" namespace for getting
// read privileges. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN. This attribute will be TRUE if the user is
// able to read the file.
const FILE_ATTRIBUTE_ACCESS_CAN_READ = "access::can-read"

// FILE_ATTRIBUTE_ACCESS_CAN_RENAME: key in the "access" namespace for checking
// renaming privileges. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN. This attribute will be TRUE if the user is
// able to rename the file.
const FILE_ATTRIBUTE_ACCESS_CAN_RENAME = "access::can-rename"

// FILE_ATTRIBUTE_ACCESS_CAN_TRASH: key in the "access" namespace for checking
// trashing privileges. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN. This attribute will be TRUE if the user is
// able to move the file to the trash.
const FILE_ATTRIBUTE_ACCESS_CAN_TRASH = "access::can-trash"

// FILE_ATTRIBUTE_ACCESS_CAN_WRITE: key in the "access" namespace for getting
// write privileges. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN. This attribute will be TRUE if the user is
// able to write to the file.
const FILE_ATTRIBUTE_ACCESS_CAN_WRITE = "access::can-write"

// FILE_ATTRIBUTE_DOS_IS_ARCHIVE: key in the "dos" namespace for checking if the
// file's archive flag is set. This attribute is TRUE if the archive flag is
// set. This attribute is only available for DOS file systems. Corresponding
// AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_DOS_IS_ARCHIVE = "dos::is-archive"

// FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: key in the "dos" namespace for checking if
// the file is a NTFS mount point (a volume mount or a junction point). This
// attribute is TRUE if file is a reparse point of type
// IO_REPARSE_TAG_MOUNT_POINT
// (https://msdn.microsoft.com/en-us/library/dd541667.aspx). This attribute is
// only available for DOS file systems. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT = "dos::is-mountpoint"

// FILE_ATTRIBUTE_DOS_IS_SYSTEM: key in the "dos" namespace for checking if the
// file's backup flag is set. This attribute is TRUE if the backup flag is set.
// This attribute is only available for DOS file systems. Corresponding
// AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_DOS_IS_SYSTEM = "dos::is-system"

// FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: key in the "dos" namespace for getting
// the file NTFS reparse tag. This value is 0 for files that are not reparse
// points. See the Reparse Tags
// (https://msdn.microsoft.com/en-us/library/dd541667.aspx) page for possible
// reparse tag values. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG = "dos::reparse-point-tag"

// FILE_ATTRIBUTE_ETAG_VALUE: key in the "etag" namespace for getting the value
// of the file's entity tag. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_ETAG_VALUE = "etag::value"

// FILE_ATTRIBUTE_FILESYSTEM_FREE: key in the "filesystem" namespace for getting
// the number of bytes of free space left on the file system. Corresponding
// AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_FILESYSTEM_FREE = "filesystem::free"

// FILE_ATTRIBUTE_FILESYSTEM_READONLY: key in the "filesystem" namespace for
// checking if the file system is read only. Is set to TRUE if the file system
// is read only. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_FILESYSTEM_READONLY = "filesystem::readonly"

// FILE_ATTRIBUTE_FILESYSTEM_REMOTE: key in the "filesystem" namespace for
// checking if the file system is remote. Is set to TRUE if the file system is
// remote. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_FILESYSTEM_REMOTE = "filesystem::remote"

// FILE_ATTRIBUTE_FILESYSTEM_SIZE: key in the "filesystem" namespace for getting
// the total size (in bytes) of the file system, used in
// g_file_query_filesystem_info(). Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_FILESYSTEM_SIZE = "filesystem::size"

// FILE_ATTRIBUTE_FILESYSTEM_TYPE: key in the "filesystem" namespace for getting
// the file system's type. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_FILESYSTEM_TYPE = "filesystem::type"

// FILE_ATTRIBUTE_FILESYSTEM_USED: key in the "filesystem" namespace for getting
// the number of bytes of used on the file system. Corresponding AttributeType
// is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_FILESYSTEM_USED = "filesystem::used"

// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: key in the "filesystem" namespace for
// hinting a file manager application whether it should preview (e.g. thumbnail)
// files on the file system. The value for this key contain a PreviewType.
const FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW = "filesystem::use-preview"

// FILE_ATTRIBUTE_GVFS_BACKEND: key in the "gvfs" namespace that gets the name
// of the current GVFS backend in use. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_GVFS_BACKEND = "gvfs::backend"

// FILE_ATTRIBUTE_ID_FILE: key in the "id" namespace for getting a file
// identifier. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING. An
// example use would be during listing files, to avoid recursive directory
// scanning.
const FILE_ATTRIBUTE_ID_FILE = "id::file"

// FILE_ATTRIBUTE_ID_FILESYSTEM: key in the "id" namespace for getting the file
// system identifier. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING. An example use would be during drag and drop to
// see if the source and target are on the same filesystem (default to move) or
// not (default to copy).
const FILE_ATTRIBUTE_ID_FILESYSTEM = "id::filesystem"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be ejected.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT = "mountable::can-eject"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) is mountable.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT = "mountable::can-mount"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be polled.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL = "mountable::can-poll"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_START: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START = "mountable::can-start"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: key in the "mountable" namespace
// for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started
// degraded. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED = "mountable::can-start-degraded"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be stopped.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP = "mountable::can-stop"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) is unmountable.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT = "mountable::can-unmount"

// FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: key in the "mountable" namespace for
// getting the HAL UDI for the mountable file. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI = "mountable::hal-udi"

// FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: key in the "mountable"
// namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) is
// automatically polled for media. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = "mountable::is-media-check-automatic"

// FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: key in the "mountable" namespace
// for getting the StartStopType. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE = "mountable::start-stop-type"

// FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: key in the "mountable" namespace for
// getting the unix device. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE = "mountable::unix-device"

// FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: key in the "mountable" namespace
// for getting the unix device file. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE = "mountable::unix-device-file"

// FILE_ATTRIBUTE_OWNER_GROUP: key in the "owner" namespace for getting the file
// owner's group. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_OWNER_GROUP = "owner::group"

// FILE_ATTRIBUTE_OWNER_USER: key in the "owner" namespace for getting the user
// name of the file's owner. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_OWNER_USER = "owner::user"

// FILE_ATTRIBUTE_OWNER_USER_REAL: key in the "owner" namespace for getting the
// real name of the user that owns the file. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_OWNER_USER_REAL = "owner::user-real"

// FILE_ATTRIBUTE_PREVIEW_ICON: key in the "preview" namespace for getting a
// #GIcon that can be used to get preview of the file. For example, it may be a
// low resolution thumbnail without metadata. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_OBJECT. The value for this key should contain a #GIcon.
const FILE_ATTRIBUTE_PREVIEW_ICON = "preview::icon"

// FILE_ATTRIBUTE_RECENT_MODIFIED: key in the "recent" namespace for getting
// time, when the metadata for the file in recent:/// was last changed.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_INT64.
const FILE_ATTRIBUTE_RECENT_MODIFIED = "recent::modified"

// FILE_ATTRIBUTE_SELINUX_CONTEXT: key in the "selinux" namespace for getting
// the file's SELinux context. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING. Note that this attribute is only available if
// GLib has been built with SELinux support.
const FILE_ATTRIBUTE_SELINUX_CONTEXT = "selinux::context"

// FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: key in the "standard" namespace for
// getting the amount of disk space that is consumed by the file (in bytes).
// This will generally be larger than the file size (due to block size overhead)
// but can occasionally be smaller (for example, for sparse files).
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE = "standard::allocated-size"

// FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: key in the "standard" namespace for
// getting the content type of the file. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING. The value for this key should contain a valid
// content type.
const FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE = "standard::content-type"

// FILE_ATTRIBUTE_STANDARD_COPY_NAME: key in the "standard" namespace for
// getting the copy name of the file. The copy name is an optional version of
// the name. If available it's always in UTF8, and corresponds directly to the
// original filename (only transcoded to UTF8). This is useful if you want to
// copy the file to another filesystem that might have a different encoding. If
// the filename is not a valid string in the encoding selected for the
// filesystem it is in then the copy name will not be set.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_COPY_NAME = "standard::copy-name"

// FILE_ATTRIBUTE_STANDARD_DESCRIPTION: key in the "standard" namespace for
// getting the description of the file. The description is a utf8 string that
// describes the file, generally containing the filename, but can also contain
// further information. Example descriptions could be "filename (on hostname)"
// for a remote file or "filename (in trash)" for a file in the trash. This is
// useful for instance as the window title when displaying a directory or for a
// bookmarks menu.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_DESCRIPTION = "standard::description"

// FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: key in the "standard" namespace for
// getting the display name of the file. A display name is guaranteed to be in
// UTF-8 and can thus be displayed in the UI. It is guaranteed to be set on
// every file. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME = "standard::display-name"

// FILE_ATTRIBUTE_STANDARD_EDIT_NAME: key in the "standard" namespace for edit
// name of the file. An edit name is similar to the display name, but it is
// meant to be used when you want to rename the file in the UI. The display name
// might contain information you don't want in the new filename (such as
// "(invalid unicode)" if the filename was in an invalid encoding).
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_EDIT_NAME = "standard::edit-name"

// FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: key in the "standard" namespace
// for getting the fast content type. The fast content type isn't as reliable as
// the regular one, as it only uses the filename to guess it, but it is faster
// to calculate than the regular content type. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE = "standard::fast-content-type"

// FILE_ATTRIBUTE_STANDARD_ICON: key in the "standard" namespace for getting the
// icon for the file. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_OBJECT. The value for this key should contain a #GIcon.
const FILE_ATTRIBUTE_STANDARD_ICON = "standard::icon"

// FILE_ATTRIBUTE_STANDARD_IS_BACKUP: key in the "standard" namespace for
// checking if a file is a backup file. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_BACKUP = "standard::is-backup"

// FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: key in the "standard" namespace for
// checking if a file is hidden. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_HIDDEN = "standard::is-hidden"

// FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: key in the "standard" namespace for
// checking if the file is a symlink. Typically the actual type is something
// else, if we followed the symlink to get the type. On Windows NTFS mountpoints
// are considered to be symlinks as well. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_SYMLINK = "standard::is-symlink"

// FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: key in the "standard" namespace for
// checking if a file is virtual. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL = "standard::is-virtual"

// FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: key in the "standard" namespace for
// checking if a file is volatile. This is meant for opaque, non-POSIX-like
// backends to indicate that the URI is not persistent. Applications should look
// at FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_VOLATILE = "standard::is-volatile"

// FILE_ATTRIBUTE_STANDARD_NAME: key in the "standard" namespace for getting the
// name of the file. The name is the on-disk filename which may not be in any
// known encoding, and can thus not be generally displayed as is. It is
// guaranteed to be set on every file. Use FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
// if you need to display the name in a user interface. Corresponding
// AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_STANDARD_NAME = "standard::name"

// FILE_ATTRIBUTE_STANDARD_SIZE: key in the "standard" namespace for getting the
// file's size (in bytes). Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_STANDARD_SIZE = "standard::size"

// FILE_ATTRIBUTE_STANDARD_SORT_ORDER: key in the "standard" namespace for
// setting the sort order of a file. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_INT32. An example use would be in file managers, which
// would use this key to set the order files are displayed. Files with smaller
// sort order should be sorted first, and files without sort order as if sort
// order was zero.
const FILE_ATTRIBUTE_STANDARD_SORT_ORDER = "standard::sort-order"

// FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: key in the "standard" namespace for
// getting the symbolic icon for the file. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_OBJECT. The value for this key should contain a #GIcon.
const FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON = "standard::symbolic-icon"

// FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: key in the "standard" namespace for
// getting the symlink target, if the file is a symlink. Corresponding
// AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET = "standard::symlink-target"

// FILE_ATTRIBUTE_STANDARD_TARGET_URI: key in the "standard" namespace for
// getting the target URI for the file, in the case of G_FILE_TYPE_SHORTCUT or
// G_FILE_TYPE_MOUNTABLE files. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_TARGET_URI = "standard::target-uri"

// FILE_ATTRIBUTE_STANDARD_TYPE: key in the "standard" namespace for storing
// file types. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32. The
// value for this key should contain a Type.
const FILE_ATTRIBUTE_STANDARD_TYPE = "standard::type"

// FILE_ATTRIBUTE_THUMBNAILING_FAILED: key in the "thumbnail" namespace for
// checking if thumbnailing failed. This attribute is TRUE if thumbnailing
// failed. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAILING_FAILED = "thumbnail::failed"

// FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: key in the "thumbnail" namespace for
// checking whether the thumbnail is outdated. This attribute is TRUE if the
// thumbnail is up-to-date with the file it represents, and FALSE if the file
// has been modified since the thumbnail was generated.
//
// If G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is TRUE and this attribute is FALSE,
// it indicates that thumbnailing may be attempted again and may succeed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID = "thumbnail::is-valid"

// FILE_ATTRIBUTE_THUMBNAIL_PATH: key in the "thumbnail" namespace for getting
// the path to the thumbnail image. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_THUMBNAIL_PATH = "thumbnail::path"

// FILE_ATTRIBUTE_TIME_ACCESS: key in the "time" namespace for getting the time
// the file was last accessed. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the time since the file was last
// accessed, in seconds since the UNIX epoch.
const FILE_ATTRIBUTE_TIME_ACCESS = "time::access"

// FILE_ATTRIBUTE_TIME_ACCESS_USEC: key in the "time" namespace for getting the
// microseconds of the time the file was last accessed. This should be used in
// conjunction with FILE_ATTRIBUTE_TIME_ACCESS. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_ACCESS_USEC = "time::access-usec"

// FILE_ATTRIBUTE_TIME_CHANGED: key in the "time" namespace for getting the time
// the file was last changed. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the time since the file was last
// changed, in seconds since the UNIX epoch.
//
// This corresponds to the traditional UNIX ctime.
const FILE_ATTRIBUTE_TIME_CHANGED = "time::changed"

// FILE_ATTRIBUTE_TIME_CHANGED_USEC: key in the "time" namespace for getting the
// microseconds of the time the file was last changed. This should be used in
// conjunction with FILE_ATTRIBUTE_TIME_CHANGED. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_CHANGED_USEC = "time::changed-usec"

// FILE_ATTRIBUTE_TIME_CREATED: key in the "time" namespace for getting the time
// the file was created. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the time since the file was
// created, in seconds since the UNIX epoch.
//
// This may correspond to Linux stx_btime, FreeBSD st_birthtim, NetBSD
// st_birthtime or NTFS ctime.
const FILE_ATTRIBUTE_TIME_CREATED = "time::created"

// FILE_ATTRIBUTE_TIME_CREATED_USEC: key in the "time" namespace for getting the
// microseconds of the time the file was created. This should be used in
// conjunction with FILE_ATTRIBUTE_TIME_CREATED. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_CREATED_USEC = "time::created-usec"

// FILE_ATTRIBUTE_TIME_MODIFIED: key in the "time" namespace for getting the
// time the file was last modified. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the time since the file was
// modified, in seconds since the UNIX epoch.
const FILE_ATTRIBUTE_TIME_MODIFIED = "time::modified"

// FILE_ATTRIBUTE_TIME_MODIFIED_USEC: key in the "time" namespace for getting
// the microseconds of the time the file was last modified. This should be used
// in conjunction with FILE_ATTRIBUTE_TIME_MODIFIED. Corresponding AttributeType
// is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_MODIFIED_USEC = "time::modified-usec"

// FILE_ATTRIBUTE_TRASH_DELETION_DATE: key in the "trash" namespace. When
// requested against items in trash:///, will return the date and time when the
// file was trashed. The format of the returned string is YYYY-MM-DDThh:mm:ss.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_TRASH_DELETION_DATE = "trash::deletion-date"

// FILE_ATTRIBUTE_TRASH_ITEM_COUNT: key in the "trash" namespace. When requested
// against trash:/// returns the number of (toplevel) items in the trash folder.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TRASH_ITEM_COUNT = "trash::item-count"

// FILE_ATTRIBUTE_TRASH_ORIG_PATH: key in the "trash" namespace. When requested
// against items in trash:///, will return the original path to the file before
// it was trashed. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_TRASH_ORIG_PATH = "trash::orig-path"

// FILE_ATTRIBUTE_UNIX_BLOCKS: key in the "unix" namespace for getting the
// number of blocks allocated for the file. This attribute is only available for
// UNIX file systems. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_UNIX_BLOCKS = "unix::blocks"

// FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: key in the "unix" namespace for getting the
// block size for the file system. This attribute is only available for UNIX
// file systems. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_BLOCK_SIZE = "unix::block-size"

// FILE_ATTRIBUTE_UNIX_DEVICE: key in the "unix" namespace for getting the
// device id of the device the file is located on (see stat() documentation).
// This attribute is only available for UNIX file systems. Corresponding
// AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_DEVICE = "unix::device"

// FILE_ATTRIBUTE_UNIX_GID: key in the "unix" namespace for getting the group ID
// for the file. This attribute is only available for UNIX file systems.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_GID = "unix::gid"

// FILE_ATTRIBUTE_UNIX_INODE: key in the "unix" namespace for getting the inode
// of the file. This attribute is only available for UNIX file systems.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_UNIX_INODE = "unix::inode"

// FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: key in the "unix" namespace for checking
// if the file represents a UNIX mount point. This attribute is TRUE if the file
// is a UNIX mount point. Since 2.58, / is considered to be a mount point. This
// attribute is only available for UNIX file systems. Corresponding
// AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT = "unix::is-mountpoint"

// FILE_ATTRIBUTE_UNIX_MODE: key in the "unix" namespace for getting the mode of
// the file (e.g. whether the file is a regular file, symlink, etc). See the
// documentation for lstat(): this attribute is equivalent to the st_mode member
// of struct stat, and includes both the file type and permissions. This
// attribute is only available for UNIX file systems. Corresponding
// AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_MODE = "unix::mode"

// FILE_ATTRIBUTE_UNIX_NLINK: key in the "unix" namespace for getting the number
// of hard links for a file. See lstat() documentation. This attribute is only
// available for UNIX file systems. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_NLINK = "unix::nlink"

// FILE_ATTRIBUTE_UNIX_RDEV: key in the "unix" namespace for getting the device
// ID for the file (if it is a special file). See lstat() documentation. This
// attribute is only available for UNIX file systems. Corresponding
// AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_RDEV = "unix::rdev"

// FILE_ATTRIBUTE_UNIX_UID: key in the "unix" namespace for getting the user ID
// for the file. This attribute is only available for UNIX file systems.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_UID = "unix::uid"

// FileInfoOverrider contains methods that are overridable.
type FileInfoOverrider interface {
}

// FileInfo: functionality for manipulating basic metadata for files. Info
// implements methods for getting information that all files should contain, and
// allows for manipulation of extended attributes.
//
// See [GFileAttribute][gio-GFileAttribute] for more information on how GIO
// handles file attributes.
//
// To obtain a Info for a #GFile, use g_file_query_info() (or its async
// variant). To obtain a Info for a file input or output stream, use
// g_file_input_stream_query_info() or g_file_output_stream_query_info() (or
// their async variants).
//
// To change the actual attributes of a file, you should then set the attribute
// in the Info and call g_file_set_attributes_from_info() or
// g_file_set_attributes_async() on a GFile.
//
// However, not all attributes can be changed in the file. For instance, the
// actual size of a file cannot be changed via g_file_info_set_size(). You may
// call g_file_query_settable_attributes() and
// g_file_query_writable_namespaces() to discover the settable attributes of a
// particular file at runtime.
//
// AttributeMatcher allows for searching through a Info for attributes.
type FileInfo struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*FileInfo)(nil)
)

func classInitFileInfor(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapFileInfo(obj *externglib.Object) *FileInfo {
	return &FileInfo{
		Object: obj,
	}
}

func marshalFileInfo(p uintptr) (interface{}, error) {
	return wrapFileInfo(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFileInfo creates a new file info structure.
//
// The function returns the following values:
//
//    - fileInfo: Info.
//
func NewFileInfo() *FileInfo {
	var _cret *C.GFileInfo // in

	_cret = C.g_file_info_new()

	var _fileInfo *FileInfo // out

	_fileInfo = wrapFileInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileInfo
}

// ClearStatus clears the status information from info.
func (info *FileInfo) ClearStatus() {
	var _arg0 *C.GFileInfo // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	C.g_file_info_clear_status(_arg0)
	runtime.KeepAlive(info)
}

// CopyInto: first clears all of the [GFileAttribute][gio-GFileAttribute] of
// dest_info, and then copies all of the file attributes from src_info to
// dest_info.
//
// The function takes the following parameters:
//
//    - destInfo: destination to copy attributes to.
//
func (srcInfo *FileInfo) CopyInto(destInfo *FileInfo) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GFileInfo // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(srcInfo).Native()))
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(destInfo).Native()))

	C.g_file_info_copy_into(_arg0, _arg1)
	runtime.KeepAlive(srcInfo)
	runtime.KeepAlive(destInfo)
}

// Dup duplicates a file info structure.
//
// The function returns the following values:
//
//    - fileInfo: duplicate Info of other.
//
func (other *FileInfo) Dup() *FileInfo {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GFileInfo // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(other).Native()))

	_cret = C.g_file_info_dup(_arg0)
	runtime.KeepAlive(other)

	var _fileInfo *FileInfo // out

	_fileInfo = wrapFileInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileInfo
}

// AttributeAsString gets the value of a attribute, formatted as a string. This
// escapes things as needed to make the string valid UTF-8.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - utf8 (optional): UTF-8 string associated with the given attribute, or
//      NULL if the attribute wasnâ€™t set. When you're done with the string it
//      must be freed with g_free().
//
func (info *FileInfo) AttributeAsString(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_as_string(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// AttributeBoolean gets the value of a boolean attribute. If the attribute does
// not contain a boolean value, FALSE will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - ok: boolean value contained within the attribute.
//
func (info *FileInfo) AttributeBoolean(attribute string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_boolean(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AttributeByteString gets the value of a byte string attribute. If the
// attribute does not contain a byte string, NULL will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - utf8 (optional) contents of the attribute value as a byte string, or NULL
//      otherwise.
//
func (info *FileInfo) AttributeByteString(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_byte_string(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// AttributeData gets the attribute type, value and status for an attribute key.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - typ (optional): return location for the attribute type, or NULL.
//    - valuePp (optional): return location for the attribute value, or NULL; the
//      attribute value will not be NULL.
//    - status (optional): return location for the attribute status, or NULL.
//    - ok: TRUE if info has an attribute named attribute, FALSE otherwise.
//
func (info *FileInfo) AttributeData(attribute string) (FileAttributeType, cgo.Handle, FileAttributeStatus, bool) {
	var _arg0 *C.GFileInfo           // out
	var _arg1 *C.char                // out
	var _arg2 C.GFileAttributeType   // in
	var _arg3 C.gpointer             // in
	var _arg4 C.GFileAttributeStatus // in
	var _cret C.gboolean             // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_data(_arg0, _arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _typ FileAttributeType      // out
	var _valuePp cgo.Handle         // out
	var _status FileAttributeStatus // out
	var _ok bool                    // out

	_typ = FileAttributeType(_arg2)
	_valuePp = (cgo.Handle)(unsafe.Pointer(_arg3))
	_status = FileAttributeStatus(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _typ, _valuePp, _status, _ok
}

// AttributeInt32 gets a signed 32-bit integer contained within the attribute.
// If the attribute does not contain a signed 32-bit integer, or is invalid, 0
// will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - gint32: signed 32-bit integer from the attribute.
//
func (info *FileInfo) AttributeInt32(attribute string) int32 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gint32     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_int32(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// AttributeInt64 gets a signed 64-bit integer contained within the attribute.
// If the attribute does not contain a signed 64-bit integer, or is invalid, 0
// will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - gint64: signed 64-bit integer from the attribute.
//
func (info *FileInfo) AttributeInt64(attribute string) int64 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gint64     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_int64(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// AttributeObject gets the value of a #GObject attribute. If the attribute does
// not contain a #GObject, NULL will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - object (optional) associated with the given attribute, or NULL otherwise.
//
func (info *FileInfo) AttributeObject(attribute string) *externglib.Object {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.GObject   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_object(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _object *externglib.Object // out

	if _cret != nil {
		_object = externglib.Take(unsafe.Pointer(_cret))
	}

	return _object
}

// AttributeStatus gets the attribute status for an attribute key.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - fileAttributeStatus for the given attribute, or
//      G_FILE_ATTRIBUTE_STATUS_UNSET if the key is invalid.
//
func (info *FileInfo) AttributeStatus(attribute string) FileAttributeStatus {
	var _arg0 *C.GFileInfo           // out
	var _arg1 *C.char                // out
	var _cret C.GFileAttributeStatus // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_status(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _fileAttributeStatus FileAttributeStatus // out

	_fileAttributeStatus = FileAttributeStatus(_cret)

	return _fileAttributeStatus
}

// AttributeString gets the value of a string attribute. If the attribute does
// not contain a string, NULL will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - utf8 (optional) contents of the attribute value as a UTF-8 string, or
//      NULL otherwise.
//
func (info *FileInfo) AttributeString(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_string(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// AttributeStringv gets the value of a stringv attribute. If the attribute does
// not contain a stringv, NULL will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - utf8s (optional) contents of the attribute value as a stringv, or NULL
//      otherwise. Do not free. These returned strings are UTF-8.
//
func (info *FileInfo) AttributeStringv(attribute string) []string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret **C.char     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_stringv(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _utf8s []string // out

	if _cret != nil {
		{
			var i int
			var z *C.char
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			}
		}
	}

	return _utf8s
}

// AttributeType gets the attribute type for an attribute key.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - fileAttributeType for the given attribute, or
//      G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.
//
func (info *FileInfo) AttributeType(attribute string) FileAttributeType {
	var _arg0 *C.GFileInfo         // out
	var _arg1 *C.char              // out
	var _cret C.GFileAttributeType // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_type(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _fileAttributeType FileAttributeType // out

	_fileAttributeType = FileAttributeType(_cret)

	return _fileAttributeType
}

// AttributeUint32 gets an unsigned 32-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 32-bit integer, or
// is invalid, 0 will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - guint32: unsigned 32-bit integer from the attribute.
//
func (info *FileInfo) AttributeUint32(attribute string) uint32 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.guint32    // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_uint32(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// AttributeUint64 gets a unsigned 64-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 64-bit integer, or
// is invalid, 0 will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - guint64: unsigned 64-bit integer from the attribute.
//
func (info *FileInfo) AttributeUint64(attribute string) uint64 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.guint64    // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_uint64(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ContentType gets the file's content type.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the file's content type, or NULL if
//      unknown.
//
func (info *FileInfo) ContentType() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_content_type(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// DeletionDate returns the Time representing the deletion date of the file, as
// available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
// G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, NULL is returned.
//
// The function returns the following values:
//
//    - dateTime (optional) or NULL.
//
func (info *FileInfo) DeletionDate() *glib.DateTime {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_deletion_date(_arg0)
	runtime.KeepAlive(info)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// DisplayName gets a display name for a file. This is guaranteed to always be
// set.
//
// The function returns the following values:
//
//    - utf8: string containing the display name.
//
func (info *FileInfo) DisplayName() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_display_name(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EditName gets the edit name for a file.
//
// The function returns the following values:
//
//    - utf8: string containing the edit name.
//
func (info *FileInfo) EditName() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_edit_name(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ETag gets the [entity tag][gfile-etag] for a given Info. See
// G_FILE_ATTRIBUTE_ETAG_VALUE.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the value of the "etag:value"
//      attribute.
//
func (info *FileInfo) ETag() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_etag(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// FileType gets a file's type (whether it is a regular file, symlink, etc).
// This is different from the file's content type, see
// g_file_info_get_content_type().
//
// The function returns the following values:
//
//    - fileType for the given file.
//
func (info *FileInfo) FileType() FileType {
	var _arg0 *C.GFileInfo // out
	var _cret C.GFileType  // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_file_type(_arg0)
	runtime.KeepAlive(info)

	var _fileType FileType // out

	_fileType = FileType(_cret)

	return _fileType
}

// Icon gets the icon for a file.
//
// The function returns the following values:
//
//    - icon (optional) for the given info.
//
func (info *FileInfo) Icon() *Icon {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GIcon     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_icon(_arg0)
	runtime.KeepAlive(info)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _icon
}

// IsBackup checks if a file is a backup file.
//
// The function returns the following values:
//
//    - ok: TRUE if file is a backup file, FALSE otherwise.
//
func (info *FileInfo) IsBackup() bool {
	var _arg0 *C.GFileInfo // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_is_backup(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsHidden checks if a file is hidden.
//
// The function returns the following values:
//
//    - ok: TRUE if the file is a hidden file, FALSE otherwise.
//
func (info *FileInfo) IsHidden() bool {
	var _arg0 *C.GFileInfo // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_is_hidden(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSymlink checks if a file is a symlink.
//
// The function returns the following values:
//
//    - ok: TRUE if the given info is a symlink.
//
func (info *FileInfo) IsSymlink() bool {
	var _arg0 *C.GFileInfo // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_is_symlink(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ModificationDateTime gets the modification time of the current info and
// returns it as a Time.
//
// This requires the G_FILE_ATTRIBUTE_TIME_MODIFIED attribute. If
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is provided, the resulting Time will have
// microsecond precision.
//
// The function returns the following values:
//
//    - dateTime (optional): modification time, or NULL if unknown.
//
func (info *FileInfo) ModificationDateTime() *glib.DateTime {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_modification_date_time(_arg0)
	runtime.KeepAlive(info)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// ModificationTime gets the modification time of the current info and sets it
// in result.
//
// Deprecated: Use g_file_info_get_modification_date_time() instead, as Val is
// deprecated due to the year 2038 problem.
//
// The function returns the following values:
//
//    - result: Val.
//
func (info *FileInfo) ModificationTime() *glib.TimeVal {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.GTimeVal   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	C.g_file_info_get_modification_time(_arg0, &_arg1)
	runtime.KeepAlive(info)

	var _result *glib.TimeVal // out

	_result = (*glib.TimeVal)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _result
}

// Name gets the name for a file. This is guaranteed to always be set.
//
// The function returns the following values:
//
//    - filename: string containing the file name.
//
func (info *FileInfo) Name() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_name(_arg0)
	runtime.KeepAlive(info)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// Size gets the file's size (in bytes). The size is retrieved through the value
// of the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted from
// #guint64 to #goffset before returning the result.
//
// The function returns the following values:
//
//    - gint64 containing the file's size (in bytes).
//
func (info *FileInfo) Size() int64 {
	var _arg0 *C.GFileInfo // out
	var _cret C.goffset    // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_size(_arg0)
	runtime.KeepAlive(info)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// SortOrder gets the value of the sort_order attribute from the Info. See
// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
//
// The function returns the following values:
//
//    - gint32 containing the value of the "standard::sort_order" attribute.
//
func (info *FileInfo) SortOrder() int32 {
	var _arg0 *C.GFileInfo // out
	var _cret C.gint32     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_sort_order(_arg0)
	runtime.KeepAlive(info)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// SymbolicIcon gets the symbolic icon for a file.
//
// The function returns the following values:
//
//    - icon (optional) for the given info.
//
func (info *FileInfo) SymbolicIcon() *Icon {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GIcon     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_symbolic_icon(_arg0)
	runtime.KeepAlive(info)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _icon
}

// SymlinkTarget gets the symlink target for a given Info.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the symlink target.
//
func (info *FileInfo) SymlinkTarget() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_symlink_target(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// HasAttribute checks if a file info structure has an attribute named
// attribute.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - ok: TRUE if info has an attribute named attribute, FALSE otherwise.
//
func (info *FileInfo) HasAttribute(attribute string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_has_attribute(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasNamespace checks if a file info structure has an attribute in the
// specified name_space.
//
// The function takes the following parameters:
//
//    - nameSpace: file attribute namespace.
//
// The function returns the following values:
//
//    - ok: TRUE if info has an attribute in name_space, FALSE otherwise.
//
func (info *FileInfo) HasNamespace(nameSpace string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(nameSpace)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_has_namespace(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(nameSpace)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListAttributes lists the file info structure's attributes.
//
// The function takes the following parameters:
//
//    - nameSpace (optional): file attribute key's namespace, or NULL to list all
//      attributes.
//
// The function returns the following values:
//
//    - utf8s (optional): a null-terminated array of strings of all of the
//      possible attribute types for the given name_space, or NULL on error.
//
func (info *FileInfo) ListAttributes(nameSpace string) []string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret **C.char     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	if nameSpace != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(nameSpace)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_file_info_list_attributes(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(nameSpace)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.char
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// RemoveAttribute removes all cases of attribute from info if it exists.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
func (info *FileInfo) RemoveAttribute(attribute string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_remove_attribute(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
}

// SetAttribute sets the attribute to contain the given value, if possible. To
// unset the attribute, use G_FILE_ATTRIBUTE_TYPE_INVALID for type.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - typ: AttributeType.
//    - valueP: pointer to the value.
//
func (info *FileInfo) SetAttribute(attribute string, typ FileAttributeType, valueP cgo.Handle) {
	var _arg0 *C.GFileInfo         // out
	var _arg1 *C.char              // out
	var _arg2 C.GFileAttributeType // out
	var _arg3 C.gpointer           // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileAttributeType(typ)
	_arg3 = (C.gpointer)(unsafe.Pointer(valueP))

	C.g_file_info_set_attribute(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(valueP)
}

// SetAttributeBoolean sets the attribute to contain the given attr_value, if
// possible.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - attrValue: boolean value.
//
func (info *FileInfo) SetAttributeBoolean(attribute string, attrValue bool) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	if attrValue {
		_arg2 = C.TRUE
	}

	C.g_file_info_set_attribute_boolean(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeByteString sets the attribute to contain the given attr_value, if
// possible.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - attrValue: byte string.
//
func (info *FileInfo) SetAttributeByteString(attribute, attrValue string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_file_info_set_attribute_byte_string(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeInt32 sets the attribute to contain the given attr_value, if
// possible.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - attrValue: signed 32-bit integer.
//
func (info *FileInfo) SetAttributeInt32(attribute string, attrValue int32) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.gint32     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint32(attrValue)

	C.g_file_info_set_attribute_int32(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeInt64 sets the attribute to contain the given attr_value, if
// possible.
//
// The function takes the following parameters:
//
//    - attribute name to set.
//    - attrValue: int64 value to set attribute to.
//
func (info *FileInfo) SetAttributeInt64(attribute string, attrValue int64) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.gint64     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint64(attrValue)

	C.g_file_info_set_attribute_int64(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeMask sets mask on info to match specific attribute types.
//
// The function takes the following parameters:
//
//    - mask: AttributeMatcher.
//
func (info *FileInfo) SetAttributeMask(mask *FileAttributeMatcher) {
	var _arg0 *C.GFileInfo             // out
	var _arg1 *C.GFileAttributeMatcher // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(mask)))

	C.g_file_info_set_attribute_mask(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(mask)
}

// SetAttributeObject sets the attribute to contain the given attr_value, if
// possible.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - attrValue: #GObject.
//
func (info *FileInfo) SetAttributeObject(attribute string, attrValue *externglib.Object) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.GObject   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(attrValue.Native()))

	C.g_file_info_set_attribute_object(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeStatus sets the attribute status for an attribute key. This is
// only needed by external code that implement g_file_set_attributes_from_info()
// or similar functions.
//
// The attribute must exist in info for this to work. Otherwise FALSE is
// returned and info is unchanged.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - status: AttributeStatus.
//
// The function returns the following values:
//
//    - ok: TRUE if the status was changed, FALSE if the key was not set.
//
func (info *FileInfo) SetAttributeStatus(attribute string, status FileAttributeStatus) bool {
	var _arg0 *C.GFileInfo           // out
	var _arg1 *C.char                // out
	var _arg2 C.GFileAttributeStatus // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileAttributeStatus(status)

	_cret = C.g_file_info_set_attribute_status(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(status)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAttributeString sets the attribute to contain the given attr_value, if
// possible.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - attrValue: UTF-8 string.
//
func (info *FileInfo) SetAttributeString(attribute, attrValue string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_file_info_set_attribute_string(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeStringv sets the attribute to contain the given attr_value, if
// possible.
//
// Sinze: 2.22.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - attrValue: NULL terminated array of UTF-8 strings.
//
func (info *FileInfo) SetAttributeStringv(attribute string, attrValue []string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 **C.char     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(attrValue) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(attrValue)+1)
			var zero *C.char
			out[len(attrValue)] = zero
			for i := range attrValue {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(attrValue[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.g_file_info_set_attribute_stringv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeUint32 sets the attribute to contain the given attr_value, if
// possible.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - attrValue: unsigned 32-bit integer.
//
func (info *FileInfo) SetAttributeUint32(attribute string, attrValue uint32) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.guint32    // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint32(attrValue)

	C.g_file_info_set_attribute_uint32(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeUint64 sets the attribute to contain the given attr_value, if
// possible.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - attrValue: unsigned 64-bit integer.
//
func (info *FileInfo) SetAttributeUint64(attribute string, attrValue uint64) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.guint64    // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint64(attrValue)

	C.g_file_info_set_attribute_uint64(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetContentType sets the content type attribute for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
//
// The function takes the following parameters:
//
//    - contentType: content type. See [GContentType][gio-GContentType].
//
func (info *FileInfo) SetContentType(contentType string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_content_type(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(contentType)
}

// SetDisplayName sets the display name for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
//
// The function takes the following parameters:
//
//    - displayName: string containing a display name.
//
func (info *FileInfo) SetDisplayName(displayName string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_display_name(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(displayName)
}

// SetEditName sets the edit name for the current file. See
// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
//
// The function takes the following parameters:
//
//    - editName: string containing an edit name.
//
func (info *FileInfo) SetEditName(editName string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(editName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_edit_name(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(editName)
}

// SetFileType sets the file type in a Info to type. See
// G_FILE_ATTRIBUTE_STANDARD_TYPE.
//
// The function takes the following parameters:
//
//    - typ: Type.
//
func (info *FileInfo) SetFileType(typ FileType) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.GFileType  // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = C.GFileType(typ)

	C.g_file_info_set_file_type(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(typ)
}

// SetIcon sets the icon for a given Info. See G_FILE_ATTRIBUTE_STANDARD_ICON.
//
// The function takes the following parameters:
//
//    - icon: #GIcon.
//
func (info *FileInfo) SetIcon(icon Iconner) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(externglib.InternObject(icon).Native()))

	C.g_file_info_set_icon(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(icon)
}

// SetIsHidden sets the "is_hidden" attribute in a Info according to is_hidden.
// See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
//
// The function takes the following parameters:
//
//    - isHidden: #gboolean.
//
func (info *FileInfo) SetIsHidden(isHidden bool) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	if isHidden {
		_arg1 = C.TRUE
	}

	C.g_file_info_set_is_hidden(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(isHidden)
}

// SetIsSymlink sets the "is_symlink" attribute in a Info according to
// is_symlink. See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
//
// The function takes the following parameters:
//
//    - isSymlink: #gboolean.
//
func (info *FileInfo) SetIsSymlink(isSymlink bool) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	if isSymlink {
		_arg1 = C.TRUE
	}

	C.g_file_info_set_is_symlink(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(isSymlink)
}

// SetModificationDateTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the given
// date/time value.
//
// The function takes the following parameters:
//
//    - mtime: Time.
//
func (info *FileInfo) SetModificationDateTime(mtime *glib.DateTime) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GDateTime // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(mtime)))

	C.g_file_info_set_modification_date_time(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(mtime)
}

// SetModificationTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the given
// time value.
//
// Deprecated: Use g_file_info_set_modification_date_time() instead, as Val is
// deprecated due to the year 2038 problem.
//
// The function takes the following parameters:
//
//    - mtime: Val.
//
func (info *FileInfo) SetModificationTime(mtime *glib.TimeVal) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GTimeVal  // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(mtime)))

	C.g_file_info_set_modification_time(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(mtime)
}

// SetName sets the name attribute for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_NAME.
//
// The function takes the following parameters:
//
//    - name: string containing a name.
//
func (info *FileInfo) SetName(name string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_name(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
}

// SetSize sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info to
// the given size.
//
// The function takes the following parameters:
//
//    - size containing the file's size.
//
func (info *FileInfo) SetSize(size int64) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.goffset    // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = C.goffset(size)

	C.g_file_info_set_size(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(size)
}

// SetSortOrder sets the sort order attribute in the file info structure. See
// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
//
// The function takes the following parameters:
//
//    - sortOrder: sort order integer.
//
func (info *FileInfo) SetSortOrder(sortOrder int32) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.gint32     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = C.gint32(sortOrder)

	C.g_file_info_set_sort_order(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(sortOrder)
}

// SetSymbolicIcon sets the symbolic icon for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
//
// The function takes the following parameters:
//
//    - icon: #GIcon.
//
func (info *FileInfo) SetSymbolicIcon(icon Iconner) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(externglib.InternObject(icon).Native()))

	C.g_file_info_set_symbolic_icon(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(icon)
}

// SetSymlinkTarget sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute
// in the file info to the given symlink target.
//
// The function takes the following parameters:
//
//    - symlinkTarget: static string containing a path to a symlink target.
//
func (info *FileInfo) SetSymlinkTarget(symlinkTarget string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkTarget)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_symlink_target(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(symlinkTarget)
}

// UnsetAttributeMask unsets a mask set by g_file_info_set_attribute_mask(), if
// one is set.
func (info *FileInfo) UnsetAttributeMask() {
	var _arg0 *C.GFileInfo // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(externglib.InternObject(info).Native()))

	C.g_file_info_unset_attribute_mask(_arg0)
	runtime.KeepAlive(info)
}
