// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

//export _gotk4_gio2_ActionGroup_ConnectActionAdded
func _gotk4_gio2_ActionGroup_ConnectActionAdded(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(actionName string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(actionName string))
	}

	var _actionName string // out

	_actionName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_actionName)
}

//export _gotk4_gio2_ActionGroup_ConnectActionEnabledChanged
func _gotk4_gio2_ActionGroup_ConnectActionEnabledChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 C.gboolean, arg3 C.guintptr) {
	var f func(actionName string, enabled bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(actionName string, enabled bool))
	}

	var _actionName string // out
	var _enabled bool      // out

	_actionName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	if arg2 != 0 {
		_enabled = true
	}

	f(_actionName, _enabled)
}

//export _gotk4_gio2_ActionGroup_ConnectActionRemoved
func _gotk4_gio2_ActionGroup_ConnectActionRemoved(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(actionName string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(actionName string))
	}

	var _actionName string // out

	_actionName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_actionName)
}

//export _gotk4_gio2_ActionGroup_ConnectActionStateChanged
func _gotk4_gio2_ActionGroup_ConnectActionStateChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.GVariant, arg3 C.guintptr) {
	var f func(actionName string, value *glib.Variant)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(actionName string, value *glib.Variant))
	}

	var _actionName string   // out
	var _value *glib.Variant // out

	_actionName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_value = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.g_variant_ref(arg2)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_value)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	f(_actionName, _value)
}

//export _gotk4_gio2_DBusObject_ConnectInterfaceAdded
func _gotk4_gio2_DBusObject_ConnectInterfaceAdded(arg0 C.gpointer, arg1 *C.GDBusInterface, arg2 C.guintptr) {
	var f func(iface DBusInterfacer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iface DBusInterfacer))
	}

	var _iface DBusInterfacer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.DBusInterfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DBusInterfacer)
			return ok
		})
		rv, ok := casted.(DBusInterfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DBusInterfacer")
		}
		_iface = rv
	}

	f(_iface)
}

//export _gotk4_gio2_DBusObject_ConnectInterfaceRemoved
func _gotk4_gio2_DBusObject_ConnectInterfaceRemoved(arg0 C.gpointer, arg1 *C.GDBusInterface, arg2 C.guintptr) {
	var f func(iface DBusInterfacer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iface DBusInterfacer))
	}

	var _iface DBusInterfacer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.DBusInterfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DBusInterfacer)
			return ok
		})
		rv, ok := casted.(DBusInterfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DBusInterfacer")
		}
		_iface = rv
	}

	f(_iface)
}

//export _gotk4_gio2_DBusObjectManager_ConnectInterfaceAdded
func _gotk4_gio2_DBusObjectManager_ConnectInterfaceAdded(arg0 C.gpointer, arg1 *C.GDBusObject, arg2 *C.GDBusInterface, arg3 C.guintptr) {
	var f func(object DBusObjector, iface DBusInterfacer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DBusObjector, iface DBusInterfacer))
	}

	var _object DBusObjector  // out
	var _iface DBusInterfacer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.DBusObjector is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DBusObjector)
			return ok
		})
		rv, ok := casted.(DBusObjector)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DBusObjector")
		}
		_object = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gio.DBusInterfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DBusInterfacer)
			return ok
		})
		rv, ok := casted.(DBusInterfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DBusInterfacer")
		}
		_iface = rv
	}

	f(_object, _iface)
}

//export _gotk4_gio2_DBusObjectManager_ConnectInterfaceRemoved
func _gotk4_gio2_DBusObjectManager_ConnectInterfaceRemoved(arg0 C.gpointer, arg1 *C.GDBusObject, arg2 *C.GDBusInterface, arg3 C.guintptr) {
	var f func(object DBusObjector, iface DBusInterfacer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DBusObjector, iface DBusInterfacer))
	}

	var _object DBusObjector  // out
	var _iface DBusInterfacer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.DBusObjector is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DBusObjector)
			return ok
		})
		rv, ok := casted.(DBusObjector)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DBusObjector")
		}
		_object = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gio.DBusInterfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DBusInterfacer)
			return ok
		})
		rv, ok := casted.(DBusInterfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DBusInterfacer")
		}
		_iface = rv
	}

	f(_object, _iface)
}

//export _gotk4_gio2_DBusObjectManager_ConnectObjectAdded
func _gotk4_gio2_DBusObjectManager_ConnectObjectAdded(arg0 C.gpointer, arg1 *C.GDBusObject, arg2 C.guintptr) {
	var f func(object DBusObjector)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DBusObjector))
	}

	var _object DBusObjector // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.DBusObjector is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DBusObjector)
			return ok
		})
		rv, ok := casted.(DBusObjector)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DBusObjector")
		}
		_object = rv
	}

	f(_object)
}

//export _gotk4_gio2_DBusObjectManager_ConnectObjectRemoved
func _gotk4_gio2_DBusObjectManager_ConnectObjectRemoved(arg0 C.gpointer, arg1 *C.GDBusObject, arg2 C.guintptr) {
	var f func(object DBusObjector)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DBusObjector))
	}

	var _object DBusObjector // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.DBusObjector is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DBusObjector)
			return ok
		})
		rv, ok := casted.(DBusObjector)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DBusObjector")
		}
		_object = rv
	}

	f(_object)
}

//export _gotk4_gio2_Drive_ConnectChanged
func _gotk4_gio2_Drive_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Drive_ConnectDisconnected
func _gotk4_gio2_Drive_ConnectDisconnected(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Drive_ConnectEjectButton
func _gotk4_gio2_Drive_ConnectEjectButton(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Drive_ConnectStopButton
func _gotk4_gio2_Drive_ConnectStopButton(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_DtlsConnection_ConnectAcceptCertificate
func _gotk4_gio2_DtlsConnection_ConnectAcceptCertificate(arg0 C.gpointer, arg1 *C.GTlsCertificate, arg2 C.GTlsCertificateFlags, arg3 C.guintptr) (cret C.gboolean) {
	var f func(peerCert TLSCertificater, errors TLSCertificateFlags) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(peerCert TLSCertificater, errors TLSCertificateFlags) (ok bool))
	}

	var _peerCert TLSCertificater   // out
	var _errors TLSCertificateFlags // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSCertificater)
			return ok
		})
		rv, ok := casted.(TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_peerCert = rv
	}
	_errors = TLSCertificateFlags(arg2)

	ok := f(_peerCert, _errors)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_ListModel_ConnectItemsChanged
func _gotk4_gio2_ListModel_ConnectItemsChanged(arg0 C.gpointer, arg1 C.guint, arg2 C.guint, arg3 C.guint, arg4 C.guintptr) {
	var f func(position, removed, added uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(position, removed, added uint))
	}

	var _position uint // out
	var _removed uint  // out
	var _added uint    // out

	_position = uint(arg1)
	_removed = uint(arg2)
	_added = uint(arg3)

	f(_position, _removed, _added)
}

//export _gotk4_gio2_MemoryMonitor_ConnectLowMemoryWarning
func _gotk4_gio2_MemoryMonitor_ConnectLowMemoryWarning(arg0 C.gpointer, arg1 C.GMemoryMonitorWarningLevel, arg2 C.guintptr) {
	var f func(level MemoryMonitorWarningLevel)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(level MemoryMonitorWarningLevel))
	}

	var _level MemoryMonitorWarningLevel // out

	_level = MemoryMonitorWarningLevel(arg1)

	f(_level)
}

//export _gotk4_gio2_Mount_ConnectChanged
func _gotk4_gio2_Mount_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Mount_ConnectPreUnmount
func _gotk4_gio2_Mount_ConnectPreUnmount(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Mount_ConnectUnmounted
func _gotk4_gio2_Mount_ConnectUnmounted(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_NetworkMonitor_ConnectNetworkChanged
func _gotk4_gio2_NetworkMonitor_ConnectNetworkChanged(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(networkAvailable bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(networkAvailable bool))
	}

	var _networkAvailable bool // out

	if arg1 != 0 {
		_networkAvailable = true
	}

	f(_networkAvailable)
}

//export _gotk4_gio2_Volume_ConnectChanged
func _gotk4_gio2_Volume_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Volume_ConnectRemoved
func _gotk4_gio2_Volume_ConnectRemoved(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_AppInfoMonitor_ConnectChanged
func _gotk4_gio2_AppInfoMonitor_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_AppLaunchContext_ConnectLaunchFailed
func _gotk4_gio2_AppLaunchContext_ConnectLaunchFailed(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(startupNotifyId string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(startupNotifyId string))
	}

	var _startupNotifyId string // out

	_startupNotifyId = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_startupNotifyId)
}

//export _gotk4_gio2_AppLaunchContext_ConnectLaunched
func _gotk4_gio2_AppLaunchContext_ConnectLaunched(arg0 C.gpointer, arg1 *C.GAppInfo, arg2 *C.GVariant, arg3 C.guintptr) {
	var f func(info AppInfor, platformData *glib.Variant)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(info AppInfor, platformData *glib.Variant))
	}

	var _info AppInfor              // out
	var _platformData *glib.Variant // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(AppInfor)
			return ok
		})
		rv, ok := casted.(AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_info = rv
	}
	_platformData = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.g_variant_ref(arg2)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_platformData)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	f(_info, _platformData)
}

//export _gotk4_gio2_Application_ConnectActivate
func _gotk4_gio2_Application_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Application_ConnectCommandLine
func _gotk4_gio2_Application_ConnectCommandLine(arg0 C.gpointer, arg1 *C.GApplicationCommandLine, arg2 C.guintptr) (cret C.gint) {
	var f func(commandLine *ApplicationCommandLine) (gint int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(commandLine *ApplicationCommandLine) (gint int))
	}

	var _commandLine *ApplicationCommandLine // out

	_commandLine = wrapApplicationCommandLine(coreglib.Take(unsafe.Pointer(arg1)))

	gint := f(_commandLine)

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gio2_Application_ConnectHandleLocalOptions
func _gotk4_gio2_Application_ConnectHandleLocalOptions(arg0 C.gpointer, arg1 *C.GVariantDict, arg2 C.guintptr) (cret C.gint) {
	var f func(options *glib.VariantDict) (gint int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(options *glib.VariantDict) (gint int))
	}

	var _options *glib.VariantDict // out

	_options = (*glib.VariantDict)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_variant_dict_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_options)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_dict_unref((*C.GVariantDict)(intern.C))
		},
	)

	gint := f(_options)

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gio2_Application_ConnectNameLost
func _gotk4_gio2_Application_ConnectNameLost(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_Application_ConnectOpen
func _gotk4_gio2_Application_ConnectOpen(arg0 C.gpointer, arg1 **C.GFile, arg2 C.gint, arg3 *C.gchar, arg4 C.guintptr) {
	var f func(files []Filer, hint string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(files []Filer, hint string))
	}

	var _files []Filer // out
	var _hint string   // out

	{
		src := unsafe.Slice((**C.GFile)(arg1), arg2)
		_files = make([]Filer, arg2)
		for i := 0; i < int(arg2); i++ {
			{
				objptr := unsafe.Pointer(src[i])
				if objptr == nil {
					panic("object of type gio.Filer is nil")
				}

				object := coreglib.Take(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(Filer)
					return ok
				})
				rv, ok := casted.(Filer)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
				}
				_files[i] = rv
			}
		}
	}
	_hint = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	f(_files, _hint)
}

//export _gotk4_gio2_Application_ConnectShutdown
func _gotk4_gio2_Application_ConnectShutdown(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Application_ConnectStartup
func _gotk4_gio2_Application_ConnectStartup(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Cancellable_ConnectCancelled
func _gotk4_gio2_Cancellable_ConnectCancelled(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_DBusAuthObserver_ConnectAllowMechanism
func _gotk4_gio2_DBusAuthObserver_ConnectAllowMechanism(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) (cret C.gboolean) {
	var f func(mechanism string) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mechanism string) (ok bool))
	}

	var _mechanism string // out

	_mechanism = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := f(_mechanism)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_DBusAuthObserver_ConnectAuthorizeAuthenticatedPeer
func _gotk4_gio2_DBusAuthObserver_ConnectAuthorizeAuthenticatedPeer(arg0 C.gpointer, arg1 *C.GIOStream, arg2 *C.GCredentials, arg3 C.guintptr) (cret C.gboolean) {
	var f func(stream IOStreamer, credentials *Credentials) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(stream IOStreamer, credentials *Credentials) (ok bool))
	}

	var _stream IOStreamer        // out
	var _credentials *Credentials // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IOStreamer)
			return ok
		})
		rv, ok := casted.(IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_stream = rv
	}
	if arg2 != nil {
		_credentials = wrapCredentials(coreglib.Take(unsafe.Pointer(arg2)))
	}

	ok := f(_stream, _credentials)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_DBusConnection_ConnectClosed
func _gotk4_gio2_DBusConnection_ConnectClosed(arg0 C.gpointer, arg1 C.gboolean, arg2 *C.GError, arg3 C.guintptr) {
	var f func(remotePeerVanished bool, err error)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(remotePeerVanished bool, err error))
	}

	var _remotePeerVanished bool // out
	var _err error               // out

	if arg1 != 0 {
		_remotePeerVanished = true
	}
	if arg2 != nil {
		_err = gerror.Take(unsafe.Pointer(arg2))
	}

	f(_remotePeerVanished, _err)
}

//export _gotk4_gio2_DBusInterfaceSkeleton_ConnectGAuthorizeMethod
func _gotk4_gio2_DBusInterfaceSkeleton_ConnectGAuthorizeMethod(arg0 C.gpointer, arg1 *C.GDBusMethodInvocation, arg2 C.guintptr) (cret C.gboolean) {
	var f func(invocation *DBusMethodInvocation) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(invocation *DBusMethodInvocation) (ok bool))
	}

	var _invocation *DBusMethodInvocation // out

	_invocation = wrapDBusMethodInvocation(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_invocation)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxyPropertiesChanged
func _gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxyPropertiesChanged(arg0 C.gpointer, arg1 *C.GDBusObjectProxy, arg2 *C.GDBusProxy, arg3 *C.GVariant, arg4 **C.gchar, arg5 C.guintptr) {
	var f func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, changedProperties *glib.Variant, invalidatedProperties []string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, changedProperties *glib.Variant, invalidatedProperties []string))
	}

	var _objectProxy *DBusObjectProxy    // out
	var _interfaceProxy *DBusProxy       // out
	var _changedProperties *glib.Variant // out
	var _invalidatedProperties []string  // out

	_objectProxy = wrapDBusObjectProxy(coreglib.Take(unsafe.Pointer(arg1)))
	_interfaceProxy = wrapDBusProxy(coreglib.Take(unsafe.Pointer(arg2)))
	_changedProperties = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	C.g_variant_ref(arg3)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_changedProperties)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	{
		var i int
		var z *C.gchar
		for p := arg4; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(arg4, i)
		_invalidatedProperties = make([]string, i)
		for i := range src {
			_invalidatedProperties[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	f(_objectProxy, _interfaceProxy, _changedProperties, _invalidatedProperties)
}

//export _gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxySignal
func _gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxySignal(arg0 C.gpointer, arg1 *C.GDBusObjectProxy, arg2 *C.GDBusProxy, arg3 *C.gchar, arg4 *C.gchar, arg5 *C.GVariant, arg6 C.guintptr) {
	var f func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, senderName, signalName string, parameters *glib.Variant)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg6))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, senderName, signalName string, parameters *glib.Variant))
	}

	var _objectProxy *DBusObjectProxy // out
	var _interfaceProxy *DBusProxy    // out
	var _senderName string            // out
	var _signalName string            // out
	var _parameters *glib.Variant     // out

	_objectProxy = wrapDBusObjectProxy(coreglib.Take(unsafe.Pointer(arg1)))
	_interfaceProxy = wrapDBusProxy(coreglib.Take(unsafe.Pointer(arg2)))
	_senderName = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_signalName = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_parameters = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	C.g_variant_ref(arg5)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_parameters)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	f(_objectProxy, _interfaceProxy, _senderName, _signalName, _parameters)
}

//export _gotk4_gio2_DBusObjectSkeleton_ConnectAuthorizeMethod
func _gotk4_gio2_DBusObjectSkeleton_ConnectAuthorizeMethod(arg0 C.gpointer, arg1 *C.GDBusInterfaceSkeleton, arg2 *C.GDBusMethodInvocation, arg3 C.guintptr) (cret C.gboolean) {
	var f func(iface DBusInterfaceSkeletonner, invocation *DBusMethodInvocation) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iface DBusInterfaceSkeletonner, invocation *DBusMethodInvocation) (ok bool))
	}

	var _iface DBusInterfaceSkeletonner   // out
	var _invocation *DBusMethodInvocation // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.DBusInterfaceSkeletonner is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DBusInterfaceSkeletonner)
			return ok
		})
		rv, ok := casted.(DBusInterfaceSkeletonner)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DBusInterfaceSkeletonner")
		}
		_iface = rv
	}
	_invocation = wrapDBusMethodInvocation(coreglib.Take(unsafe.Pointer(arg2)))

	ok := f(_iface, _invocation)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_DBusProxy_ConnectGPropertiesChanged
func _gotk4_gio2_DBusProxy_ConnectGPropertiesChanged(arg0 C.gpointer, arg1 *C.GVariant, arg2 **C.gchar, arg3 C.guintptr) {
	var f func(changedProperties *glib.Variant, invalidatedProperties []string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(changedProperties *glib.Variant, invalidatedProperties []string))
	}

	var _changedProperties *glib.Variant // out
	var _invalidatedProperties []string  // out

	_changedProperties = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_variant_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_changedProperties)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	{
		var i int
		var z *C.gchar
		for p := arg2; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(arg2, i)
		_invalidatedProperties = make([]string, i)
		for i := range src {
			_invalidatedProperties[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	f(_changedProperties, _invalidatedProperties)
}

//export _gotk4_gio2_DBusProxy_ConnectGSignal
func _gotk4_gio2_DBusProxy_ConnectGSignal(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.GVariant, arg4 C.guintptr) {
	var f func(senderName, signalName string, parameters *glib.Variant)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(senderName, signalName string, parameters *glib.Variant))
	}

	var _senderName string        // out
	var _signalName string        // out
	var _parameters *glib.Variant // out

	if arg1 != nil {
		_senderName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	}
	_signalName = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_parameters = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	C.g_variant_ref(arg3)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_parameters)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	f(_senderName, _signalName, _parameters)
}

//export _gotk4_gio2_DBusServer_ConnectNewConnection
func _gotk4_gio2_DBusServer_ConnectNewConnection(arg0 C.gpointer, arg1 *C.GDBusConnection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(connection *DBusConnection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(connection *DBusConnection) (ok bool))
	}

	var _connection *DBusConnection // out

	_connection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_connection)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_FileMonitor_ConnectChanged
func _gotk4_gio2_FileMonitor_ConnectChanged(arg0 C.gpointer, arg1 *C.GFile, arg2 *C.GFile, arg3 C.GFileMonitorEvent, arg4 C.guintptr) {
	var f func(file, otherFile Filer, eventType FileMonitorEvent)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(file, otherFile Filer, eventType FileMonitorEvent))
	}

	var _file Filer                 // out
	var _otherFile Filer            // out
	var _eventType FileMonitorEvent // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Filer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Filer)
			return ok
		})
		rv, ok := casted.(Filer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
		}
		_file = rv
	}
	if arg2 != nil {
		{
			objptr := unsafe.Pointer(arg2)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Filer)
				return ok
			})
			rv, ok := casted.(Filer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
			}
			_otherFile = rv
		}
	}
	_eventType = FileMonitorEvent(arg3)

	f(_file, _otherFile, _eventType)
}

//export _gotk4_gio2_FilenameCompleter_ConnectGotCompletionData
func _gotk4_gio2_FilenameCompleter_ConnectGotCompletionData(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_MenuModel_ConnectItemsChanged
func _gotk4_gio2_MenuModel_ConnectItemsChanged(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.gint, arg4 C.guintptr) {
	var f func(position, removed, added int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(position, removed, added int))
	}

	var _position int // out
	var _removed int  // out
	var _added int    // out

	_position = int(arg1)
	_removed = int(arg2)
	_added = int(arg3)

	f(_position, _removed, _added)
}

//export _gotk4_gio2_MountOperation_ConnectAborted
func _gotk4_gio2_MountOperation_ConnectAborted(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_MountOperation_ConnectAskPassword
func _gotk4_gio2_MountOperation_ConnectAskPassword(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 C.GAskPasswordFlags, arg5 C.guintptr) {
	var f func(message, defaultUser, defaultDomain string, flags AskPasswordFlags)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(message, defaultUser, defaultDomain string, flags AskPasswordFlags))
	}

	var _message string         // out
	var _defaultUser string     // out
	var _defaultDomain string   // out
	var _flags AskPasswordFlags // out

	_message = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_defaultUser = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_defaultDomain = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_flags = AskPasswordFlags(arg4)

	f(_message, _defaultUser, _defaultDomain, _flags)
}

//export _gotk4_gio2_MountOperation_ConnectAskQuestion
func _gotk4_gio2_MountOperation_ConnectAskQuestion(arg0 C.gpointer, arg1 *C.gchar, arg2 **C.gchar, arg3 C.guintptr) {
	var f func(message string, choices []string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(message string, choices []string))
	}

	var _message string   // out
	var _choices []string // out

	_message = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	{
		var i int
		var z *C.gchar
		for p := arg2; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(arg2, i)
		_choices = make([]string, i)
		for i := range src {
			_choices[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	f(_message, _choices)
}

//export _gotk4_gio2_MountOperation_ConnectReply
func _gotk4_gio2_MountOperation_ConnectReply(arg0 C.gpointer, arg1 C.GMountOperationResult, arg2 C.guintptr) {
	var f func(result MountOperationResult)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(result MountOperationResult))
	}

	var _result MountOperationResult // out

	_result = MountOperationResult(arg1)

	f(_result)
}

//export _gotk4_gio2_MountOperation_ConnectShowUnmountProgress
func _gotk4_gio2_MountOperation_ConnectShowUnmountProgress(arg0 C.gpointer, arg1 *C.gchar, arg2 C.gint64, arg3 C.gint64, arg4 C.guintptr) {
	var f func(message string, timeLeft, bytesLeft int64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(message string, timeLeft, bytesLeft int64))
	}

	var _message string  // out
	var _timeLeft int64  // out
	var _bytesLeft int64 // out

	_message = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_timeLeft = int64(arg2)
	_bytesLeft = int64(arg3)

	f(_message, _timeLeft, _bytesLeft)
}

//export _gotk4_gio2_Resolver_ConnectReload
func _gotk4_gio2_Resolver_ConnectReload(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gio2_Settings_ConnectChangeEvent
func _gotk4_gio2_Settings_ConnectChangeEvent(arg0 C.gpointer, arg1 C.gpointer, arg2 C.gint, arg3 C.guintptr) (cret C.gboolean) {
	var f func(keys []glib.Quark) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(keys []glib.Quark) (ok bool))
	}

	var _keys []glib.Quark // out

	{
		src := unsafe.Slice((*C.GQuark)(arg1), arg2)
		_keys = make([]glib.Quark, arg2)
		for i := 0; i < int(arg2); i++ {
			_keys[i] = uint32(src[i])
		}
	}

	ok := f(_keys)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_Settings_ConnectChanged
func _gotk4_gio2_Settings_ConnectChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(key string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(key string))
	}

	var _key string // out

	_key = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_key)
}

//export _gotk4_gio2_Settings_ConnectWritableChangeEvent
func _gotk4_gio2_Settings_ConnectWritableChangeEvent(arg0 C.gpointer, arg1 C.guint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(key uint) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(key uint) (ok bool))
	}

	var _key uint // out

	_key = uint(arg1)

	ok := f(_key)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_Settings_ConnectWritableChanged
func _gotk4_gio2_Settings_ConnectWritableChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(key string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(key string))
	}

	var _key string // out

	_key = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_key)
}

//export _gotk4_gio2_SimpleAction_ConnectActivate
func _gotk4_gio2_SimpleAction_ConnectActivate(arg0 C.gpointer, arg1 *C.GVariant, arg2 C.guintptr) {
	var f func(parameter *glib.Variant)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(parameter *glib.Variant))
	}

	var _parameter *glib.Variant // out

	if arg1 != nil {
		_parameter = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		C.g_variant_ref(arg1)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_parameter)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	f(_parameter)
}

//export _gotk4_gio2_SimpleAction_ConnectChangeState
func _gotk4_gio2_SimpleAction_ConnectChangeState(arg0 C.gpointer, arg1 *C.GVariant, arg2 C.guintptr) {
	var f func(value *glib.Variant)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(value *glib.Variant))
	}

	var _value *glib.Variant // out

	if arg1 != nil {
		_value = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		C.g_variant_ref(arg1)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_value)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	f(_value)
}

//export _gotk4_gio2_SocketClient_ConnectEvent
func _gotk4_gio2_SocketClient_ConnectEvent(arg0 C.gpointer, arg1 C.GSocketClientEvent, arg2 *C.GSocketConnectable, arg3 *C.GIOStream, arg4 C.guintptr) {
	var f func(event SocketClientEvent, connectable SocketConnectabler, connection IOStreamer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event SocketClientEvent, connectable SocketConnectabler, connection IOStreamer))
	}

	var _event SocketClientEvent        // out
	var _connectable SocketConnectabler // out
	var _connection IOStreamer          // out

	_event = SocketClientEvent(arg1)
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gio.SocketConnectabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketConnectabler)
			return ok
		})
		rv, ok := casted.(SocketConnectabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketConnectabler")
		}
		_connectable = rv
	}
	if arg3 != nil {
		{
			objptr := unsafe.Pointer(arg3)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(IOStreamer)
				return ok
			})
			rv, ok := casted.(IOStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
			}
			_connection = rv
		}
	}

	f(_event, _connectable, _connection)
}

//export _gotk4_gio2_SocketListener_ConnectEvent
func _gotk4_gio2_SocketListener_ConnectEvent(arg0 C.gpointer, arg1 C.GSocketListenerEvent, arg2 *C.GSocket, arg3 C.guintptr) {
	var f func(event SocketListenerEvent, socket *Socket)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event SocketListenerEvent, socket *Socket))
	}

	var _event SocketListenerEvent // out
	var _socket *Socket            // out

	_event = SocketListenerEvent(arg1)
	_socket = wrapSocket(coreglib.Take(unsafe.Pointer(arg2)))

	f(_event, _socket)
}

//export _gotk4_gio2_SocketService_ConnectIncoming
func _gotk4_gio2_SocketService_ConnectIncoming(arg0 C.gpointer, arg1 *C.GSocketConnection, arg2 C.GObject, arg3 C.guintptr) (cret C.gboolean) {
	var f func(connection *SocketConnection, sourceObject *coreglib.Object) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(connection *SocketConnection, sourceObject *coreglib.Object) (ok bool))
	}

	var _connection *SocketConnection  // out
	var _sourceObject *coreglib.Object // out

	_connection = wrapSocketConnection(coreglib.Take(unsafe.Pointer(arg1)))
	_sourceObject = coreglib.Take(unsafe.Pointer(&arg2))

	ok := f(_connection, _sourceObject)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_ThreadedSocketService_ConnectRun
func _gotk4_gio2_ThreadedSocketService_ConnectRun(arg0 C.gpointer, arg1 *C.GSocketConnection, arg2 C.GObject, arg3 C.guintptr) (cret C.gboolean) {
	var f func(connection *SocketConnection, sourceObject *coreglib.Object) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(connection *SocketConnection, sourceObject *coreglib.Object) (ok bool))
	}

	var _connection *SocketConnection  // out
	var _sourceObject *coreglib.Object // out

	_connection = wrapSocketConnection(coreglib.Take(unsafe.Pointer(arg1)))
	_sourceObject = coreglib.Take(unsafe.Pointer(&arg2))

	ok := f(_connection, _sourceObject)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_TlsConnection_ConnectAcceptCertificate
func _gotk4_gio2_TlsConnection_ConnectAcceptCertificate(arg0 C.gpointer, arg1 *C.GTlsCertificate, arg2 C.GTlsCertificateFlags, arg3 C.guintptr) (cret C.gboolean) {
	var f func(peerCert TLSCertificater, errors TLSCertificateFlags) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(peerCert TLSCertificater, errors TLSCertificateFlags) (ok bool))
	}

	var _peerCert TLSCertificater   // out
	var _errors TLSCertificateFlags // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSCertificater)
			return ok
		})
		rv, ok := casted.(TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_peerCert = rv
	}
	_errors = TLSCertificateFlags(arg2)

	ok := f(_peerCert, _errors)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveChanged
func _gotk4_gio2_VolumeMonitor_ConnectDriveChanged(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveConnected
func _gotk4_gio2_VolumeMonitor_ConnectDriveConnected(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected
func _gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton
func _gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveStopButton
func _gotk4_gio2_VolumeMonitor_ConnectDriveStopButton(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

//export _gotk4_gio2_VolumeMonitor_ConnectMountAdded
func _gotk4_gio2_VolumeMonitor_ConnectMountAdded(arg0 C.gpointer, arg1 *C.GMount, arg2 C.guintptr) {
	var f func(mount Mounter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mount Mounter))
	}

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	f(_mount)
}

//export _gotk4_gio2_VolumeMonitor_ConnectMountChanged
func _gotk4_gio2_VolumeMonitor_ConnectMountChanged(arg0 C.gpointer, arg1 *C.GMount, arg2 C.guintptr) {
	var f func(mount Mounter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mount Mounter))
	}

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	f(_mount)
}

//export _gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount
func _gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount(arg0 C.gpointer, arg1 *C.GMount, arg2 C.guintptr) {
	var f func(mount Mounter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mount Mounter))
	}

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	f(_mount)
}

//export _gotk4_gio2_VolumeMonitor_ConnectMountRemoved
func _gotk4_gio2_VolumeMonitor_ConnectMountRemoved(arg0 C.gpointer, arg1 *C.GMount, arg2 C.guintptr) {
	var f func(mount Mounter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mount Mounter))
	}

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	f(_mount)
}

//export _gotk4_gio2_VolumeMonitor_ConnectVolumeAdded
func _gotk4_gio2_VolumeMonitor_ConnectVolumeAdded(arg0 C.gpointer, arg1 *C.GVolume, arg2 C.guintptr) {
	var f func(volume Volumer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(volume Volumer))
	}

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	f(_volume)
}

//export _gotk4_gio2_VolumeMonitor_ConnectVolumeChanged
func _gotk4_gio2_VolumeMonitor_ConnectVolumeChanged(arg0 C.gpointer, arg1 *C.GVolume, arg2 C.guintptr) {
	var f func(volume Volumer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(volume Volumer))
	}

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	f(_volume)
}

//export _gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved
func _gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved(arg0 C.gpointer, arg1 *C.GVolume, arg2 C.guintptr) {
	var f func(volume Volumer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(volume Volumer))
	}

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	f(_volume)
}
