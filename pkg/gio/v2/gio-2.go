// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
// GDBusMessage* _gotk4_gio2_DBusMessageFilterFunction(GDBusConnection*, GDBusMessage*, gboolean, gpointer);
// extern void callbackDelete(gpointer);
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// void _gotk4_gio2_DBusSignalCallback(GDBusConnection*, gchar*, gchar*, gchar*, gchar*, GVariant*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitorrer},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIconner},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGrouper},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserverer},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnectioner},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModeller},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessager},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocationer},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServerer},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenuer},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItemmer},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotificationer},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyActioner},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleActioner},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStreamer},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermissioner},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocesser},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncherer},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBusser},
	})
}

// ResolverErrorQuark gets the #GResolver Error Quark.
func ResolverErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_resolver_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)

	return _quark
}

// ResourceErrorQuark gets the #GResource Error Quark.
func ResourceErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_resource_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)

	return _quark
}

// TLSChannelBindingErrorQuark gets the TLS channel binding error quark.
func TLSChannelBindingErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_tls_channel_binding_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)

	return _quark
}

// TLSErrorQuark gets the TLS error quark.
func TLSErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_tls_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)

	return _quark
}

// IOErrorQuark gets the GIO Error Quark.
func IOErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_io_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)

	return _quark
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor struct {
	*externglib.Object
}

func wrapAppInfoMonitor(obj *externglib.Object) *AppInfoMonitor {
	return &AppInfoMonitor{
		Object: obj,
	}
}

func marshalAppInfoMonitorrer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapAppInfoMonitor(obj), nil
}

func (*AppInfoMonitor) privateAppInfoMonitor() {}

// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
type BytesIcon struct {
	*externglib.Object

	LoadableIcon
}

func wrapBytesIcon(obj *externglib.Object) *BytesIcon {
	return &BytesIcon{
		Object: obj,
		LoadableIcon: LoadableIcon{
			Icon: Icon{
				Object: obj,
			},
		},
	}
}

func marshalBytesIconner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapBytesIcon(obj), nil
}

func (*BytesIcon) privateBytesIcon() {}

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup struct {
	*externglib.Object

	RemoteActionGroup
}

func wrapDBusActionGroup(obj *externglib.Object) *DBusActionGroup {
	return &DBusActionGroup{
		Object: obj,
		RemoteActionGroup: RemoteActionGroup{
			ActionGroup: ActionGroup{
				Object: obj,
			},
		},
	}
}

func marshalDBusActionGrouper(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusActionGroup(obj), nil
}

func (*DBusActionGroup) privateDBusActionGroup() {}

// DBusAuthObserver type provides a mechanism for participating in how a
// BusServer (or a BusConnection) authenticates remote peers. Simply instantiate
// a BusAuthObserver and connect to the signals you are interested in. Note that
// new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the EXTERNAL mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
type DBusAuthObserver struct {
	*externglib.Object
}

func wrapDBusAuthObserver(obj *externglib.Object) *DBusAuthObserver {
	return &DBusAuthObserver{
		Object: obj,
	}
}

func marshalDBusAuthObserverer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusAuthObserver(obj), nil
}

// NewDBusAuthObserver creates a new BusAuthObserver object.
func NewDBusAuthObserver() *DBusAuthObserver {
	var _cret *C.GDBusAuthObserver // in

	_cret = C.g_dbus_auth_observer_new()

	var _dBusAuthObserver *DBusAuthObserver // out

	_dBusAuthObserver = wrapDBusAuthObserver(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusAuthObserver
}

// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on observer.
func (observer *DBusAuthObserver) AllowMechanism(mechanism string) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.gchar             // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(mechanism)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_auth_observer_allow_mechanism(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AuthorizeAuthenticatedPeer emits the
// BusAuthObserver::authorize-authenticated-peer signal on observer.
func (observer *DBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStreamer, credentials *Credentials) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.GIOStream         // out
	var _arg2 *C.GCredentials      // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.GCredentials)(unsafe.Pointer(credentials.Native()))

	_cret = C.g_dbus_auth_observer_authorize_authenticated_peer(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusConnection type is used for D-Bus connections to remote peers such as a
// message buses. It is a low-level API that offers a lot of flexibility. For
// instance, it lets you establish a connection over any transport that can by
// represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
//
// An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
//
// An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
//
// An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
//
// An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection struct {
	*externglib.Object

	AsyncInitable
	Initable
}

func wrapDBusConnection(obj *externglib.Object) *DBusConnection {
	return &DBusConnection{
		Object: obj,
		AsyncInitable: AsyncInitable{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusConnectioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusConnection(obj), nil
}

// NewDBusConnectionFinish finishes an operation started with
// g_dbus_connection_new().
func NewDBusConnectionFinish(res AsyncResulter) (*DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_new_finish(_arg1, &_cerr)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressFinish finishes an operation started with
// g_dbus_connection_new_for_address().
func NewDBusConnectionForAddressFinish(res AsyncResulter) (*DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_new_for_address_finish(_arg1, &_cerr)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressSync: synchronously connects and sets up a D-Bus
// client connection for exchanging D-Bus messages with an endpoint specified by
// address which must be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This constructor can only be used to initiate client-side connections - use
// g_dbus_connection_new_sync() if you need to act as the server. In particular,
// flags cannot contain the G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
//
// This is a synchronous failable constructor. See
// g_dbus_connection_new_for_address() for the asynchronous version.
//
// If observer is not NULL it may be used to control the authentication process.
func NewDBusConnectionForAddressSync(ctx context.Context, address string, flags DBusConnectionFlags, observer *DBusAuthObserver) (*DBusConnection, error) {
	var _arg4 *C.GCancellable        // out
	var _arg1 *C.gchar               // out
	var _arg2 C.GDBusConnectionFlags // out
	var _arg3 *C.GDBusAuthObserver   // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GDBusConnectionFlags(flags)
	_arg3 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))

	_cret = C.g_dbus_connection_new_for_address_sync(_arg1, _arg2, _arg3, _arg4, &_cerr)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// NewDBusConnectionSync: synchronously sets up a D-Bus connection for
// exchanging D-Bus messages with the end represented by stream.
//
// If stream is a Connection, then the corresponding #GSocket will be put into
// non-blocking mode.
//
// The D-Bus connection will interact with stream from a worker thread. As a
// result, the caller should not interact with stream after this method has been
// called, except by calling g_object_unref() on it.
//
// If observer is not NULL it may be used to control the authentication process.
//
// This is a synchronous failable constructor. See g_dbus_connection_new() for
// the asynchronous version.
func NewDBusConnectionSync(ctx context.Context, stream IOStreamer, guid string, flags DBusConnectionFlags, observer *DBusAuthObserver) (*DBusConnection, error) {
	var _arg5 *C.GCancellable        // out
	var _arg1 *C.GIOStream           // out
	var _arg2 *C.gchar               // out
	var _arg3 C.GDBusConnectionFlags // out
	var _arg4 *C.GDBusAuthObserver   // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	if guid != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(guid)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.GDBusConnectionFlags(flags)
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))

	_cret = C.g_dbus_connection_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// AddFilter adds a message filter. Filters are handlers that are run on all
// incoming and outgoing messages, prior to standard dispatch. Filters are run
// in the order that they were added. The same handler can be added as a filter
// more than once, in which case it will be run more than once. Filters added
// during a filter callback won't be run on the message being processed. Filter
// functions are allowed to modify and even drop messages.
//
// Note that filters are run in a dedicated message handling thread so they
// can't block and, generally, can't do anything but signal a worker thread.
// Also note that filters are rarely needed - use API such as
// g_dbus_connection_send_message_with_reply(),
// g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
//
// If a filter consumes an incoming message the message is not dispatched
// anywhere else - not even the standard dispatch machinery (that API such as
// g_dbus_connection_signal_subscribe() and
// g_dbus_connection_send_message_with_reply() relies on) will see the message.
// Similarly, if a filter consumes an outgoing message, the message will not be
// sent to the other peer.
//
// If user_data_free_func is non-NULL, it will be called (in the thread-default
// main context of the thread you are calling this method from) at some point
// after user_data is no longer needed. (It is not guaranteed to be called
// synchronously when the filter is removed, and may be called after connection
// has been destroyed.)
func (connection *DBusConnection) AddFilter(filterFunction DBusMessageFilterFunction) uint {
	var _arg0 *C.GDBusConnection           // out
	var _arg1 C.GDBusMessageFilterFunction // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*[0]byte)(C._gotk4_gio2_DBusMessageFilterFunction)
	_arg2 = C.gpointer(gbox.Assign(filterFunction))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.g_dbus_connection_add_filter(_arg0, _arg1, _arg2, _arg3)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Call: asynchronously invokes the method_name method on the interface_name
// D-Bus interface on the remote object at object_path owned by bus_name.
//
// If connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If parameters contains a value not compatible with the
// D-Bus protocol, the operation fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// If reply_type is non-NULL then the reply will be checked for having this type
// and an error will be raised if it does not match. Said another way, if you
// give a reply_type then any non-NULL return value will be of this type. Unless
// itâ€™s G_VARIANT_TYPE_UNIT, the reply_type will be a tuple containing one or
// more values.
//
// If the parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//    g_dbus_connection_call (connection,
//                            "org.freedesktop.StringThings",
//                            "/org/freedesktop/StringThings",
//                            "org.freedesktop.StringThings",
//                            "TwoStrings",
//                            g_variant_new ("(ss)",
//                                           "Thing One",
//                                           "Thing Two"),
//                            NULL,
//                            G_DBUS_CALL_FLAGS_NONE,
//                            -1,
//                            NULL,
//                            (GAsyncReadyCallback) two_strings_done,
//                            NULL);
//
// This is an asynchronous method. When the operation is finished, callback will
// be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_connection_call_finish() to get
// the result of the operation. See g_dbus_connection_call_sync() for the
// synchronous version of this function.
//
// If callback is NULL then the D-Bus method call message will be sent with the
// G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
func (connection *DBusConnection) Call(ctx context.Context, busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection     // out
	var _arg9 *C.GCancellable        // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.gchar               // out
	var _arg4 *C.gchar               // out
	var _arg5 *C.GVariant            // out
	var _arg6 *C.GVariantType        // out
	var _arg7 C.GDBusCallFlags       // out
	var _arg8 C.gint                 // out
	var _arg10 C.GAsyncReadyCallback // out
	var _arg11 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if busName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(busName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	_arg6 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(replyType)))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg10 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg11 = C.gpointer(gbox.AssignOnce(callback))

	C.g_dbus_connection_call(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}

// CallFinish finishes an operation started with g_dbus_connection_call().
func (connection *DBusConnection) CallFinish(res AsyncResulter) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_call_finish(_arg0, _arg1, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(gextras.StructNative(unsafe.Pointer(v))))
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// CallSync: synchronously invokes the method_name method on the interface_name
// D-Bus interface on the remote object at object_path owned by bus_name.
//
// If connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If parameters contains a value not compatible with the
// D-Bus protocol, the operation fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// If reply_type is non-NULL then the reply will be checked for having this type
// and an error will be raised if it does not match. Said another way, if you
// give a reply_type then any non-NULL return value will be of this type.
//
// If the parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//    g_dbus_connection_call_sync (connection,
//                                 "org.freedesktop.StringThings",
//                                 "/org/freedesktop/StringThings",
//                                 "org.freedesktop.StringThings",
//                                 "TwoStrings",
//                                 g_variant_new ("(ss)",
//                                                "Thing One",
//                                                "Thing Two"),
//                                 NULL,
//                                 G_DBUS_CALL_FLAGS_NONE,
//                                 -1,
//                                 NULL,
//                                 &error);
//
// The calling thread is blocked until a reply is received. See
// g_dbus_connection_call() for the asynchronous version of this method.
func (connection *DBusConnection) CallSync(ctx context.Context, busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg9 *C.GCancellable    // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if busName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(busName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	_arg6 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(replyType)))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)

	_cret = C.g_dbus_connection_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(gextras.StructNative(unsafe.Pointer(v))))
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// CallWithUnixFdList: like g_dbus_connection_call() but also takes a FDList
// object.
//
// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values in
// the body of the message. For example, if a message contains two file
// descriptors, fd_list would have length 2, and g_variant_new_handle (0) and
// g_variant_new_handle (1) would appear somewhere in the body of the message
// (not necessarily in that order!) to represent the file descriptors at indexes
// 0 and 1 respectively.
//
// When designing D-Bus APIs that are intended to be interoperable, please note
// that non-GDBus implementations of D-Bus can usually only access file
// descriptors if they are referenced in this way by a value of type
// G_VARIANT_TYPE_HANDLE in the body of the message.
//
// This method is only available on UNIX.
func (connection *DBusConnection) CallWithUnixFdList(ctx context.Context, busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList *UnixFDList, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection     // out
	var _arg10 *C.GCancellable       // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.gchar               // out
	var _arg4 *C.gchar               // out
	var _arg5 *C.GVariant            // out
	var _arg6 *C.GVariantType        // out
	var _arg7 C.GDBusCallFlags       // out
	var _arg8 C.gint                 // out
	var _arg9 *C.GUnixFDList         // out
	var _arg11 C.GAsyncReadyCallback // out
	var _arg12 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg10 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if busName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(busName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	_arg6 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(replyType)))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	_arg11 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg12 = C.gpointer(gbox.AssignOnce(callback))

	C.g_dbus_connection_call_with_unix_fd_list(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12)
}

// CallWithUnixFdListFinish finishes an operation started with
// g_dbus_connection_call_with_unix_fd_list().
//
// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values in
// the body of the message. For example, if g_variant_get_handle() returns 5,
// that is intended to be a reference to the file descriptor that can be
// accessed by g_unix_fd_list_get (*out_fd_list, 5, ...).
//
// When designing D-Bus APIs that are intended to be interoperable, please note
// that non-GDBus implementations of D-Bus can usually only access file
// descriptors if they are referenced in this way by a value of type
// G_VARIANT_TYPE_HANDLE in the body of the message.
func (connection *DBusConnection) CallWithUnixFdListFinish(res AsyncResulter) (*UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GUnixFDList     // in
	var _arg2 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_call_with_unix_fd_list_finish(_arg0, &_arg1, _arg2, &_cerr)

	var _outFdList *UnixFDList // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	if _arg1 != nil {
		_outFdList = wrapUnixFDList(externglib.AssumeOwnership(unsafe.Pointer(_arg1)))
	}
	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(gextras.StructNative(unsafe.Pointer(v))))
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outFdList, _variant, _goerr
}

// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes and
// returns FDList objects. See g_dbus_connection_call_with_unix_fd_list() and
// g_dbus_connection_call_with_unix_fd_list_finish() for more details.
//
// This method is only available on UNIX.
func (connection *DBusConnection) CallWithUnixFdListSync(ctx context.Context, busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList *UnixFDList) (*UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg11 *C.GCancellable   // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _arg9 *C.GUnixFDList     // out
	var _arg10 *C.GUnixFDList    // in
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg11 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if busName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(busName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	_arg6 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(replyType)))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	_cret = C.g_dbus_connection_call_with_unix_fd_list_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_arg10, _arg11, &_cerr)

	var _outFdList *UnixFDList // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	if _arg10 != nil {
		_outFdList = wrapUnixFDList(externglib.AssumeOwnership(unsafe.Pointer(_arg10)))
	}
	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(gextras.StructNative(unsafe.Pointer(v))))
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outFdList, _variant, _goerr
}

// Close closes connection. Note that this never causes the process to exit
// (this might only happen if the other end of a shared message bus connection
// disconnects, see BusConnection:exit-on-close).
//
// Once the connection is closed, operations such as sending a message will
// return with the error G_IO_ERROR_CLOSED. Closing a connection will not
// automatically flush the connection so queued messages may be lost. Use
// g_dbus_connection_flush() if you need such guarantees.
//
// If connection is already closed, this method fails with G_IO_ERROR_CLOSED.
//
// When connection has been closed, the BusConnection::closed signal is emitted
// in the [thread-default main context][g-main-context-push-thread-default] of
// the thread that connection was constructed in.
//
// This is an asynchronous method. When the operation is finished, callback will
// be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_connection_close_finish() to get
// the result of the operation. See g_dbus_connection_close_sync() for the
// synchronous version.
func (connection *DBusConnection) Close(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg3 = C.gpointer(gbox.AssignOnce(callback))

	C.g_dbus_connection_close(_arg0, _arg1, _arg2, _arg3)
}

// CloseFinish finishes an operation started with g_dbus_connection_close().
func (connection *DBusConnection) CloseFinish(res AsyncResulter) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_dbus_connection_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CloseSync: synchronously closes connection. The calling thread is blocked
// until this is done. See g_dbus_connection_close() for the asynchronous
// version of this method and more details about what it does.
func (connection *DBusConnection) CloseSync(ctx context.Context) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_dbus_connection_close_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EmitSignal emits a signal.
//
// If the parameters GVariant is floating, it is consumed.
//
// This can only fail if parameters is not compatible with the D-Bus protocol
// (G_IO_ERROR_INVALID_ARGUMENT), or if connection has been closed
// (G_IO_ERROR_CLOSED).
func (connection *DBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	if destinationBusName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(destinationBusName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(signalName)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))

	C.g_dbus_connection_emit_signal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ExportActionGroup exports action_group on connection at object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// A given object path can only have one action group exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// error set accordingly).
//
// You can unexport the action group using
// g_dbus_connection_unexport_action_group() with the return value of this
// function.
//
// The thread default main context is taken at the time of this call. All
// incoming action activations and state change requests are reported from this
// context. Any changes on the action group that cause it to emit signals must
// also come from this same context. Since incoming action activations and state
// change requests are rather likely to cause changes on the action group, this
// effectively limits a given action group to being exported from only one main
// context.
func (connection *DBusConnection) ExportActionGroup(objectPath string, actionGroup ActionGrouper) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GActionGroup    // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer(actionGroup.Native()))

	_cret = C.g_dbus_connection_export_action_group(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint, _goerr
}

// ExportMenuModel exports menu on connection at object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// An object path can only have one menu model exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// error set accordingly).
//
// You can unexport the menu model using g_dbus_connection_unexport_menu_model()
// with the return value of this function.
func (connection *DBusConnection) ExportMenuModel(objectPath string, menu MenuModeller) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GMenuModel      // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(menu.Native()))

	_cret = C.g_dbus_connection_export_menu_model(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint, _goerr
}

// Flush: asynchronously flushes connection, that is, writes all queued outgoing
// message to the transport and then flushes the transport (using
// g_output_stream_flush_async()). This is useful in programs that wants to emit
// a D-Bus signal and then exit immediately. Without flushing the connection,
// there is no guaranteed that the message has been sent to the networking
// buffers in the OS kernel.
//
// This is an asynchronous method. When the operation is finished, callback will
// be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_connection_flush_finish() to get
// the result of the operation. See g_dbus_connection_flush_sync() for the
// synchronous version.
func (connection *DBusConnection) Flush(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg3 = C.gpointer(gbox.AssignOnce(callback))

	C.g_dbus_connection_flush(_arg0, _arg1, _arg2, _arg3)
}

// FlushFinish finishes an operation started with g_dbus_connection_flush().
func (connection *DBusConnection) FlushFinish(res AsyncResulter) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_dbus_connection_flush_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// FlushSync: synchronously flushes connection. The calling thread is blocked
// until this is done. See g_dbus_connection_flush() for the asynchronous
// version of this method and more details about what it does.
func (connection *DBusConnection) FlushSync(ctx context.Context) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_dbus_connection_flush_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Capabilities gets the capabilities negotiated with the remote peer
func (connection *DBusConnection) Capabilities() DBusCapabilityFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusCapabilityFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_capabilities(_arg0)

	var _dBusCapabilityFlags DBusCapabilityFlags // out

	_dBusCapabilityFlags = DBusCapabilityFlags(_cret)

	return _dBusCapabilityFlags
}

// ExitOnClose gets whether the process is terminated when connection is closed
// by the remote peer. See BusConnection:exit-on-close for more details.
func (connection *DBusConnection) ExitOnClose() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_exit_on_close(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Flags gets the flags used to construct this connection
func (connection *DBusConnection) Flags() DBusConnectionFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusConnectionFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_flags(_arg0)

	var _dBusConnectionFlags DBusConnectionFlags // out

	_dBusConnectionFlags = DBusConnectionFlags(_cret)

	return _dBusConnectionFlags
}

// GUID of the peer performing the role of server when authenticating. See
// BusConnection:guid for more details.
func (connection *DBusConnection) GUID() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// LastSerial retrieves the last serial number assigned to a BusMessage on the
// current thread. This includes messages sent via both low-level API such as
// g_dbus_connection_send_message() as well as high-level API such as
// g_dbus_connection_emit_signal(), g_dbus_connection_call() or
// g_dbus_proxy_call().
func (connection *DBusConnection) LastSerial() uint32 {
	var _arg0 *C.GDBusConnection // out
	var _cret C.guint32          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_last_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// PeerCredentials gets the credentials of the authenticated peer. This will
// always return NULL unless connection acted as a server (e.g.
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and the
// client passed credentials as part of the authentication process.
//
// In a message bus setup, the message bus is always the server and each
// application is a client. So this method will always return NULL for message
// bus clients.
func (connection *DBusConnection) PeerCredentials() *Credentials {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GCredentials    // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_peer_credentials(_arg0)

	var _credentials *Credentials // out

	_credentials = wrapCredentials(externglib.Take(unsafe.Pointer(_cret)))

	return _credentials
}

// Stream gets the underlying stream used for IO.
//
// While the BusConnection is active, it will interact with this stream from a
// worker thread, so it is not safe to interact with the stream directly.
func (connection *DBusConnection) Stream() IOStreamer {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GIOStream       // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_stream(_arg0)

	var _ioStream IOStreamer // out

	_ioStream = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(IOStreamer)

	return _ioStream
}

// UniqueName gets the unique name of connection as assigned by the message bus.
// This can also be used to figure out if connection is a message bus
// connection.
func (connection *DBusConnection) UniqueName() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_unique_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsClosed gets whether connection is closed.
func (connection *DBusConnection) IsClosed() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFilter removes a filter.
//
// Note that since filters run in a different thread, there is a race condition
// where it is possible that the filter will be running even after calling
// g_dbus_connection_remove_filter(), so you cannot just free data that the
// filter might be using. Instead, you should pass a Notify to
// g_dbus_connection_add_filter(), which will be called when it is guaranteed
// that the data is no longer needed.
func (connection *DBusConnection) RemoveFilter(filterId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(filterId)

	C.g_dbus_connection_remove_filter(_arg0, _arg1)
}

// SendMessage: asynchronously sends message to the peer represented by
// connection.
//
// Unless flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the
// serial number will be assigned by connection and set on message via
// g_dbus_message_set_serial(). If out_serial is not NULL, then the serial
// number used will be written to this location prior to submitting the message
// to the underlying transport. While it has a volatile qualifier, this is a
// historical artifact and the argument passed to it should not be volatile.
//
// If connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If message is not well-formed, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that message must be unlocked, unless flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (connection *DBusConnection) SendMessage(message *DBusMessage, flags DBusSendMessageFlags) (uint32, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.guint32               // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)

	C.g_dbus_connection_send_message(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _outSerial uint32 // out
	var _goerr error      // out

	_outSerial = uint32(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outSerial, _goerr
}

// SendMessageWithReply: asynchronously sends message to the peer represented by
// connection.
//
// Unless flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the
// serial number will be assigned by connection and set on message via
// g_dbus_message_set_serial(). If out_serial is not NULL, then the serial
// number used will be written to this location prior to submitting the message
// to the underlying transport. While it has a volatile qualifier, this is a
// historical artifact and the argument passed to it should not be volatile.
//
// If connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If message is not well-formed, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// This is an asynchronous method. When the operation is finished, callback will
// be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call
// g_dbus_connection_send_message_with_reply_finish() to get the result of the
// operation. See g_dbus_connection_send_message_with_reply_sync() for the
// synchronous version.
//
// Note that message must be unlocked, unless flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (connection *DBusConnection) SendMessageWithReply(ctx context.Context, message *DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, callback AsyncReadyCallback) uint32 {
	var _arg0 *C.GDBusConnection      // out
	var _arg5 *C.GCancellable         // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg4 C.guint32               // in
	var _arg6 C.GAsyncReadyCallback   // out
	var _arg7 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)
	_arg3 = C.gint(timeoutMsec)
	_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg7 = C.gpointer(gbox.AssignOnce(callback))

	C.g_dbus_connection_send_message_with_reply(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, _arg6, _arg7)

	var _outSerial uint32 // out

	_outSerial = uint32(_arg4)

	return _outSerial
}

// SendMessageWithReplyFinish finishes an operation started with
// g_dbus_connection_send_message_with_reply().
//
// Note that error is only set if a local in-process error occurred. That is to
// say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode this
// to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (connection *DBusConnection) SendMessageWithReplyFinish(res AsyncResulter) (*DBusMessage, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusMessage    // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_send_message_with_reply_finish(_arg0, _arg1, &_cerr)

	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_dBusMessage = wrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusMessage, _goerr
}

// SendMessageWithReplySync: synchronously sends message to the peer represented
// by connection and blocks the calling thread until a reply is received or the
// timeout is reached. See g_dbus_connection_send_message_with_reply() for the
// asynchronous version of this method.
//
// Unless flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the
// serial number will be assigned by connection and set on message via
// g_dbus_message_set_serial(). If out_serial is not NULL, then the serial
// number used will be written to this location prior to submitting the message
// to the underlying transport. While it has a volatile qualifier, this is a
// historical artifact and the argument passed to it should not be volatile.
//
// If connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If message is not well-formed, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// Note that error is only set if a local in-process error occurred. That is to
// say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode this
// to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that message must be unlocked, unless flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (connection *DBusConnection) SendMessageWithReplySync(ctx context.Context, message *DBusMessage, flags DBusSendMessageFlags, timeoutMsec int) (uint32, *DBusMessage, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg5 *C.GCancellable         // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg4 C.guint32               // in
	var _cret *C.GDBusMessage         // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)
	_arg3 = C.gint(timeoutMsec)

	_cret = C.g_dbus_connection_send_message_with_reply_sync(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, &_cerr)

	var _outSerial uint32         // out
	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_outSerial = uint32(_arg4)
	_dBusMessage = wrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outSerial, _dBusMessage, _goerr
}

// SetExitOnClose sets whether the process should be terminated when connection
// is closed by the remote peer. See BusConnection:exit-on-close for more
// details.
//
// Note that this function should be used with care. Most modern UNIX desktops
// tie the notion of a user session with the session bus, and expect all of a
// user's applications to quit when their bus connection goes away. If you are
// setting exit_on_close to FALSE for the shared session bus connection, you
// should make sure that your application exits when the user session ends.
func (connection *DBusConnection) SetExitOnClose(exitOnClose bool) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	if exitOnClose {
		_arg1 = C.TRUE
	}

	C.g_dbus_connection_set_exit_on_close(_arg0, _arg1)
}

// SignalSubscribe subscribes to signals on connection and invokes callback with
// a whenever the signal is received. Note that callback will be invoked in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread you are calling this method from.
//
// If connection is not a message bus connection, sender must be NULL.
//
// If sender is a well-known name note that callback is invoked with the unique
// name for the owner of sender, not the well-known name as one would expect.
// This is because the message bus rewrites the name. As such, to avoid certain
// race conditions, users should be tracking the name owner of the well-known
// name and use that when processing the received signal.
//
// If one of G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
// G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, arg0 is interpreted as part of
// a namespace or path. The first argument of a signal is matched against that
// part as specified by D-Bus.
//
// If user_data_free_func is non-NULL, it will be called (in the thread-default
// main context of the thread you are calling this method from) at some point
// after user_data is no longer needed. (It is not guaranteed to be called
// synchronously when the signal is unsubscribed from, and may be called after
// connection has been destroyed.)
//
// As callback is potentially invoked in a different thread from where itâ€™s
// emitted, itâ€™s possible for this to happen after
// g_dbus_connection_signal_unsubscribe() has been called in another thread. Due
// to this, user_data should have a strong reference which is freed with
// user_data_free_func, rather than pointing to data whose lifecycle is tied to
// the signal subscription. For example, if a #GObject is used to store the
// subscription ID from g_dbus_connection_signal_subscribe(), a strong reference
// to that #GObject must be passed to user_data, and g_object_unref() passed to
// user_data_free_func. You are responsible for breaking the resulting reference
// count cycle by explicitly unsubscribing from the signal when dropping the
// last external reference to the #GObject. Alternatively, a weak reference may
// be used.
//
// It is guaranteed that if you unsubscribe from a signal using
// g_dbus_connection_signal_unsubscribe() from the same thread which made the
// corresponding g_dbus_connection_signal_subscribe() call, callback will not be
// invoked after g_dbus_connection_signal_unsubscribe() returns.
//
// The returned subscription identifier is an opaque value which is guaranteed
// to never be zero.
//
// This function can never fail.
func (connection *DBusConnection) SignalSubscribe(sender string, interfaceName string, member string, objectPath string, arg0 string, flags DBusSignalFlags, callback DBusSignalCallback) uint {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 C.GDBusSignalFlags    // out
	var _arg7 C.GDBusSignalCallback // out
	var _arg8 C.gpointer
	var _arg9 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	if sender != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(sender)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if interfaceName != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if member != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(member)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if objectPath != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if arg0 != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(arg0)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	_arg6 = C.GDBusSignalFlags(flags)
	_arg7 = (*[0]byte)(C._gotk4_gio2_DBusSignalCallback)
	_arg8 = C.gpointer(gbox.Assign(callback))
	_arg9 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.g_dbus_connection_signal_subscribe(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SignalUnsubscribe unsubscribes from signals.
//
// Note that there may still be D-Bus traffic to process (relating to this
// signal subscription) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_dbus_connection_signal_subscribe() is called, in
// order to avoid memory leaks through callbacks queued on the Context after
// itâ€™s stopped being iterated.
func (connection *DBusConnection) SignalUnsubscribe(subscriptionId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(subscriptionId)

	C.g_dbus_connection_signal_unsubscribe(_arg0, _arg1)
}

// StartMessageProcessing: if connection was created with
// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
// processing messages. Does nothing on if connection wasn't created with this
// flag or if the method has already been called.
func (connection *DBusConnection) StartMessageProcessing() {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	C.g_dbus_connection_start_message_processing(_arg0)
}

// UnexportActionGroup reverses the effect of a previous call to
// g_dbus_connection_export_action_group().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_action_group() or to call it with the same ID more
// than once.
func (connection *DBusConnection) UnexportActionGroup(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_action_group(_arg0, _arg1)
}

// UnexportMenuModel reverses the effect of a previous call to
// g_dbus_connection_export_menu_model().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_menu_model() or to call it with the same ID more
// than once.
func (connection *DBusConnection) UnexportMenuModel(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_menu_model(_arg0, _arg1)
}

// UnregisterObject unregisters an object.
func (connection *DBusConnection) UnregisterObject(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_object(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnregisterSubtree unregisters a subtree.
func (connection *DBusConnection) UnregisterSubtree(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_subtree(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel struct {
	MenuModel
}

func wrapDBusMenuModel(obj *externglib.Object) *DBusMenuModel {
	return &DBusMenuModel{
		MenuModel: MenuModel{
			Object: obj,
		},
	}
}

func marshalDBusMenuModeller(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusMenuModel(obj), nil
}

func (*DBusMenuModel) privateDBusMenuModel() {}

// DBusMessage: type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage struct {
	*externglib.Object
}

func wrapDBusMessage(obj *externglib.Object) *DBusMessage {
	return &DBusMessage{
		Object: obj,
	}
}

func marshalDBusMessager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusMessage(obj), nil
}

// NewDBusMessage creates a new empty BusMessage.
func NewDBusMessage() *DBusMessage {
	var _cret *C.GDBusMessage // in

	_cret = C.g_dbus_message_new()

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// NewDBusMessageFromBlob creates a new BusMessage from the data stored at blob.
// The byte order that the message was in can be retrieved using
// g_dbus_message_get_byte_order().
//
// If the blob cannot be parsed, contains invalid fields, or contains invalid
// headers, G_IO_ERROR_INVALID_ARGUMENT will be returned.
func NewDBusMessageFromBlob(blob []byte, capabilities DBusCapabilityFlags) (*DBusMessage, error) {
	var _arg1 *C.guchar // out
	var _arg2 C.gsize
	var _arg3 C.GDBusCapabilityFlags // out
	var _cret *C.GDBusMessage        // in
	var _cerr *C.GError              // in

	_arg2 = (C.gsize)(len(blob))
	if len(blob) > 0 {
		_arg1 = (*C.guchar)(unsafe.Pointer(&blob[0]))
	}
	_arg3 = C.GDBusCapabilityFlags(capabilities)

	_cret = C.g_dbus_message_new_from_blob(_arg1, _arg2, _arg3, &_cerr)

	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_dBusMessage = wrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusMessage, _goerr
}

// NewDBusMessageMethodCall creates a new BusMessage for a method call.
func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) *DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg2))
	if interface_ != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interface_)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_dbus_message_new_method_call(_arg1, _arg2, _arg3, _arg4)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// NewDBusMessageSignal creates a new BusMessage for a signal emission.
func NewDBusMessageSignal(path string, interface_ string, signal string) *DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(interface_)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(signal)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_message_new_signal(_arg1, _arg2, _arg3)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// Copy copies message. The copy is a deep copy and the returned BusMessage is
// completely identical except that it is guaranteed to not be locked.
//
// This operation can fail if e.g. message contains file descriptors and the
// per-process or system-wide open files limit is reached.
func (message *DBusMessage) Copy() (*DBusMessage, error) {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_copy(_arg0, &_cerr)

	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_dBusMessage = wrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusMessage, _goerr
}

// Arg0: convenience to get the first item in the body of message.
func (message *DBusMessage) Arg0() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_arg0(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Body gets the body of a message.
func (message *DBusMessage) Body() *glib.Variant {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_body(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _variant
}

// ByteOrder gets the byte order of message.
func (message *DBusMessage) ByteOrder() DBusMessageByteOrder {
	var _arg0 *C.GDBusMessage         // out
	var _cret C.GDBusMessageByteOrder // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_byte_order(_arg0)

	var _dBusMessageByteOrder DBusMessageByteOrder // out

	_dBusMessageByteOrder = DBusMessageByteOrder(_cret)

	return _dBusMessageByteOrder
}

// Destination: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (message *DBusMessage) Destination() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_destination(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ErrorName: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME
// header field.
func (message *DBusMessage) ErrorName() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_error_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Flags gets the flags for message.
func (message *DBusMessage) Flags() DBusMessageFlags {
	var _arg0 *C.GDBusMessage     // out
	var _cret C.GDBusMessageFlags // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_flags(_arg0)

	var _dBusMessageFlags DBusMessageFlags // out

	_dBusMessageFlags = DBusMessageFlags(_cret)

	return _dBusMessageFlags
}

// Header gets a header field on message.
//
// The caller is responsible for checking the type of the returned #GVariant
// matches what is expected.
func (message *DBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _cret *C.GVariant               // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.GDBusMessageHeaderField(headerField)

	_cret = C.g_dbus_message_get_header(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _variant
}

// HeaderFields gets an array of all header fields on message that are set.
func (message *DBusMessage) HeaderFields() []byte {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.guchar       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_header_fields(_arg0)

	var _guint8s []byte // out

	{
		var i int
		var z C.guchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = byte(src[i])
		}
	}

	return _guint8s
}

// Interface: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE
// header field.
func (message *DBusMessage) Interface() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_interface(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Locked checks whether message is locked. To monitor changes to this value,
// conncet to the #GObject::notify signal to listen for changes on the
// BusMessage:locked property.
func (message *DBusMessage) Locked() bool {
	var _arg0 *C.GDBusMessage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header
// field.
func (message *DBusMessage) Member() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_member(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// MessageType gets the type of message.
func (message *DBusMessage) MessageType() DBusMessageType {
	var _arg0 *C.GDBusMessage    // out
	var _cret C.GDBusMessageType // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_message_type(_arg0)

	var _dBusMessageType DBusMessageType // out

	_dBusMessageType = DBusMessageType(_cret)

	return _dBusMessageType
}

// NumUnixFds: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (message *DBusMessage) NumUnixFds() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_num_unix_fds(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
func (message *DBusMessage) Path() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ReplySerial: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (message *DBusMessage) ReplySerial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_reply_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER header
// field.
func (message *DBusMessage) Sender() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Serial gets the serial for message.
func (message *DBusMessage) Serial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Signature: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE
// header field.
func (message *DBusMessage) Signature() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_signature(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UnixFdList gets the UNIX file descriptors associated with message, if any.
//
// This method is only available on UNIX.
//
// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values in
// the body of the message. For example, if g_variant_get_handle() returns 5,
// that is intended to be a reference to the file descriptor that can be
// accessed by g_unix_fd_list_get (list, 5, ...).
func (message *DBusMessage) UnixFdList() *UnixFDList {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GUnixFDList  // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_unix_fd_list(_arg0)

	var _unixFDList *UnixFDList // out

	_unixFDList = wrapUnixFDList(externglib.Take(unsafe.Pointer(_cret)))

	return _unixFDList
}

// Lock: if message is locked, does nothing. Otherwise locks the message.
func (message *DBusMessage) Lock() {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	C.g_dbus_message_lock(_arg0)
}

// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
// method_call_message.
func (methodCallMessage *DBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) *DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(methodCallMessage.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(errorName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(errorMessage)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_message_new_method_error_literal(_arg0, _arg1, _arg2)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// NewMethodReply creates a new BusMessage that is a reply to
// method_call_message.
func (methodCallMessage *DBusMessage) NewMethodReply() *DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(methodCallMessage.Native()))

	_cret = C.g_dbus_message_new_method_reply(_arg0)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// Print produces a human-readable multi-line description of message.
//
// The contents of the description has no ABI guarantees, the contents and
// formatting is subject to change at any time. Typical output looks something
// like this:
//
//    Flags:   none
//    Version: 0
//    Serial:  4
//    Headers:
//      path -> objectpath '/org/gtk/GDBus/TestObject'
//      interface -> 'org.gtk.GDBus.TestInterface'
//      member -> 'GimmeStdout'
//      destination -> ':1.146'
//    Body: ()
//    UNIX File Descriptors:
//      (none)
//
// or
//
//    Flags:   no-reply-expected
//    Version: 0
//    Serial:  477
//    Headers:
//      reply-serial -> uint32 4
//      destination -> ':1.159'
//      sender -> ':1.146'
//      num-unix-fds -> uint32 1
//    Body: ()
//    UNIX File Descriptors:
//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
func (message *DBusMessage) Print(indent uint) string {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint         // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.guint(indent)

	_cret = C.g_dbus_message_print(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SetBody sets the body message. As a side-effect the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type string
// of body (or cleared if body is NULL).
//
// If body is floating, message assumes ownership of body.
func (message *DBusMessage) SetBody(body *glib.Variant) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(body)))

	C.g_dbus_message_set_body(_arg0, _arg1)
}

// SetByteOrder sets the byte order of message.
func (message *DBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder) {
	var _arg0 *C.GDBusMessage         // out
	var _arg1 C.GDBusMessageByteOrder // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.GDBusMessageByteOrder(byteOrder)

	C.g_dbus_message_set_byte_order(_arg0, _arg1)
}

// SetDestination: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (message *DBusMessage) SetDestination(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_destination(_arg0, _arg1)
}

// SetErrorName: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (message *DBusMessage) SetErrorName(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_error_name(_arg0, _arg1)
}

// SetFlags sets the flags to set on message.
func (message *DBusMessage) SetFlags(flags DBusMessageFlags) {
	var _arg0 *C.GDBusMessage     // out
	var _arg1 C.GDBusMessageFlags // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.GDBusMessageFlags(flags)

	C.g_dbus_message_set_flags(_arg0, _arg1)
}

// SetHeader sets a header field on message.
//
// If value is floating, message assumes ownership of value.
func (message *DBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant) {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _arg2 *C.GVariant               // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.GDBusMessageHeaderField(headerField)
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_dbus_message_set_header(_arg0, _arg1, _arg2)
}

// SetInterface: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (message *DBusMessage) SetInterface(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_interface(_arg0, _arg1)
}

// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
func (message *DBusMessage) SetMember(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_member(_arg0, _arg1)
}

// SetMessageType sets message to be of type.
func (message *DBusMessage) SetMessageType(typ DBusMessageType) {
	var _arg0 *C.GDBusMessage    // out
	var _arg1 C.GDBusMessageType // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.GDBusMessageType(typ)

	C.g_dbus_message_set_message_type(_arg0, _arg1)
}

// SetNumUnixFds: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (message *DBusMessage) SetNumUnixFds(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_num_unix_fds(_arg0, _arg1)
}

// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
func (message *DBusMessage) SetPath(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_path(_arg0, _arg1)
}

// SetReplySerial: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (message *DBusMessage) SetReplySerial(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_reply_serial(_arg0, _arg1)
}

// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
func (message *DBusMessage) SetSender(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_sender(_arg0, _arg1)
}

// SetSerial sets the serial for message.
func (message *DBusMessage) SetSerial(serial uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.guint32(serial)

	C.g_dbus_message_set_serial(_arg0, _arg1)
}

// SetSignature: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
func (message *DBusMessage) SetSignature(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_signature(_arg0, _arg1)
}

// SetUnixFdList sets the UNIX file descriptors associated with message. As a
// side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field is set
// to the number of fds in fd_list (or cleared if fd_list is NULL).
//
// This method is only available on UNIX.
//
// When designing D-Bus APIs that are intended to be interoperable, please note
// that non-GDBus implementations of D-Bus can usually only access file
// descriptors if they are referenced by a value of type G_VARIANT_TYPE_HANDLE
// in the body of the message.
func (message *DBusMessage) SetUnixFdList(fdList *UnixFDList) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GUnixFDList  // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_message_set_unix_fd_list(_arg0, _arg1)
}

// ToGError: if message is not of type G_DBUS_MESSAGE_TYPE_ERROR does nothing
// and returns FALSE.
//
// Otherwise this method encodes the error in message as a #GError using
// g_dbus_error_set_dbus_error() using the information in the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of message as well as the
// first string item in message's body.
func (message *DBusMessage) ToGError() error {
	var _arg0 *C.GDBusMessage // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	C.g_dbus_message_to_gerror(_arg0, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation struct {
	*externglib.Object
}

func wrapDBusMethodInvocation(obj *externglib.Object) *DBusMethodInvocation {
	return &DBusMethodInvocation{
		Object: obj,
	}
}

func marshalDBusMethodInvocationer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusMethodInvocation(obj), nil
}

// Connection gets the BusConnection the method was invoked on.
func (invocation *DBusMethodInvocation) Connection() *DBusConnection {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusConnection       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_connection(_arg0)

	var _dBusConnection *DBusConnection // out

	_dBusConnection = wrapDBusConnection(externglib.Take(unsafe.Pointer(_cret)))

	return _dBusConnection
}

// InterfaceName gets the name of the D-Bus interface the method was invoked on.
//
// If this method call is a property Get, Set or GetAll call that has been
// redirected to the method call handler then "org.freedesktop.DBus.Properties"
// will be returned. See BusInterfaceVTable for more information.
func (invocation *DBusMethodInvocation) InterfaceName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_interface_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Message gets the BusMessage for the method invocation. This is useful if you
// need to use low-level protocol features, such as UNIX file descriptor
// passing, that cannot be properly expressed in the #GVariant API.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (invocation *DBusMethodInvocation) Message() *DBusMessage {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMessage          // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_message(_arg0)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(externglib.Take(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// MethodInfo gets information about the method call, if any.
//
// If this method invocation is a property Get, Set or GetAll call that has been
// redirected to the method call handler then NULL will be returned. See
// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for more
// information.
func (invocation *DBusMethodInvocation) MethodInfo() *DBusMethodInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMethodInfo       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_method_info(_arg0)

	var _dBusMethodInfo *DBusMethodInfo // out

	_dBusMethodInfo = (*DBusMethodInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_dBusMethodInfo, func(v *DBusMethodInfo) {
		C.g_dbus_method_info_unref((*C.GDBusMethodInfo)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _dBusMethodInfo
}

// MethodName gets the name of the method that was invoked.
func (invocation *DBusMethodInvocation) MethodName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_method_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ObjectPath gets the object path the method was invoked on.
func (invocation *DBusMethodInvocation) ObjectPath() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Parameters gets the parameters of the method invocation. If there are no
// input parameters then this will return a GVariant with 0 children rather than
// NULL.
func (invocation *DBusMethodInvocation) Parameters() *glib.Variant {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GVariant              // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_parameters(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _variant
}

// PropertyInfo gets information about the property that this method call is
// for, if any.
//
// This will only be set in the case of an invocation in response to a property
// Get or Set call that has been directed to the method call handler for an
// object on account of its property_get() or property_set() vtable pointers
// being unset.
//
// See BusInterfaceVTable for more information.
//
// If the call was GetAll, NULL will be returned.
func (invocation *DBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusPropertyInfo     // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_property_info(_arg0)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	_dBusPropertyInfo = (*DBusPropertyInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_dBusPropertyInfo, func(v *DBusPropertyInfo) {
		C.g_dbus_property_info_unref((*C.GDBusPropertyInfo)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _dBusPropertyInfo
}

// Sender gets the bus name that invoked the method.
func (invocation *DBusMethodInvocation) Sender() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ReturnDBusError finishes handling a D-Bus method call by returning an error.
//
// This method will take ownership of invocation. See BusInterfaceVTable for
// more information about the ownership of invocation.
func (invocation *DBusMethodInvocation) ReturnDBusError(errorName string, errorMessage string) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.gchar                 // out
	var _arg2 *C.gchar                 // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(errorName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(errorMessage)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_dbus_method_invocation_return_dbus_error(_arg0, _arg1, _arg2)
}

// ReturnErrorLiteral: like g_dbus_method_invocation_return_error() but without
// printf()-style formatting.
//
// This method will take ownership of invocation. See BusInterfaceVTable for
// more information about the ownership of invocation.
func (invocation *DBusMethodInvocation) ReturnErrorLiteral(domain glib.Quark, code int, message string) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 C.GQuark                 // out
	var _arg2 C.gint                   // out
	var _arg3 *C.gchar                 // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))
	_arg1 = C.guint32(domain)
	_arg2 = C.gint(code)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_dbus_method_invocation_return_error_literal(_arg0, _arg1, _arg2, _arg3)
}

// ReturnGError: like g_dbus_method_invocation_return_error() but takes a
// #GError instead of the error domain, error code and message.
//
// This method will take ownership of invocation. See BusInterfaceVTable for
// more information about the ownership of invocation.
func (invocation *DBusMethodInvocation) ReturnGError(err error) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GError                // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))
	_arg1 = (*C.GError)(gerror.New(err))

	C.g_dbus_method_invocation_return_gerror(_arg0, _arg1)
}

// ReturnValue finishes handling a D-Bus method call by returning parameters. If
// the parameters GVariant is floating, it is consumed.
//
// It is an error if parameters is not of the right format: it must be a tuple
// containing the out-parameters of the D-Bus method. Even if the method has a
// single out-parameter, it must be contained in a tuple. If the method has no
// out-parameters, parameters may be NULL or an empty tuple.
//
//    GDBusMethodInvocation *invocation = some_invocation;
//    g_autofree gchar *result_string = NULL;
//    g_autoptr (GError) error = NULL;
//
//    result_string = calculate_result (&error);
//
//    if (error != NULL)
//      g_dbus_method_invocation_return_gerror (invocation, error);
//    else
//      g_dbus_method_invocation_return_value (invocation,
//                                             g_variant_new ("(s)", result_string));
//
//    // Do not free invocation here; returning a value does that
//
// This method will take ownership of invocation. See BusInterfaceVTable for
// more information about the ownership of invocation.
//
// Since 2.48, if the method call requested for a reply not to be sent then this
// call will sink parameters and free invocation, but otherwise do nothing (as
// per the recommendations of the D-Bus specification).
func (invocation *DBusMethodInvocation) ReturnValue(parameters *glib.Variant) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))

	C.g_dbus_method_invocation_return_value(_arg0, _arg1)
}

// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value() but
// also takes a FDList.
//
// This method is only available on UNIX.
//
// This method will take ownership of invocation. See BusInterfaceVTable for
// more information about the ownership of invocation.
func (invocation *DBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList *UnixFDList) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out
	var _arg2 *C.GUnixFDList           // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	_arg2 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_method_invocation_return_value_with_unix_fd_list(_arg0, _arg1, _arg2)
}

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with GDBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer. Since GLib 2.68 this can be achieved more simply by
// passing the G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the
// server.
type DBusServer struct {
	*externglib.Object

	Initable
}

func wrapDBusServer(obj *externglib.Object) *DBusServer {
	return &DBusServer{
		Object: obj,
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusServerer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusServer(obj), nil
}

// NewDBusServerSync creates a new D-Bus server that listens on the first
// address in address that works.
//
// Once constructed, you can use g_dbus_server_get_client_address() to get a
// D-Bus address string that clients can use to connect.
//
// To have control over the available authentication mechanisms and the users
// that are authorized to connect, it is strongly recommended to provide a
// non-NULL BusAuthObserver.
//
// Connect to the BusServer::new-connection signal to handle incoming
// connections.
//
// The returned BusServer isn't active - you have to start it with
// g_dbus_server_start().
//
// BusServer is used in this [example][gdbus-peer-to-peer].
//
// This is a synchronous failable constructor. There is currently no
// asynchronous version.
func NewDBusServerSync(ctx context.Context, address string, flags DBusServerFlags, guid string, observer *DBusAuthObserver) (*DBusServer, error) {
	var _arg5 *C.GCancellable      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.GDBusServerFlags   // out
	var _arg3 *C.gchar             // out
	var _arg4 *C.GDBusAuthObserver // out
	var _cret *C.GDBusServer       // in
	var _cerr *C.GError            // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GDBusServerFlags(flags)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(guid)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))

	_cret = C.g_dbus_server_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusServer *DBusServer // out
	var _goerr error            // out

	_dBusServer = wrapDBusServer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusServer, _goerr
}

// ClientAddress gets a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses) string
// that can be used by clients to connect to server.
func (server *DBusServer) ClientAddress() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	_cret = C.g_dbus_server_get_client_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Flags gets the flags for server.
func (server *DBusServer) Flags() DBusServerFlags {
	var _arg0 *C.GDBusServer     // out
	var _cret C.GDBusServerFlags // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	_cret = C.g_dbus_server_get_flags(_arg0)

	var _dBusServerFlags DBusServerFlags // out

	_dBusServerFlags = DBusServerFlags(_cret)

	return _dBusServerFlags
}

// GUID gets the GUID for server.
func (server *DBusServer) GUID() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	_cret = C.g_dbus_server_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsActive gets whether server is active.
func (server *DBusServer) IsActive() bool {
	var _arg0 *C.GDBusServer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	_cret = C.g_dbus_server_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start starts server.
func (server *DBusServer) Start() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	C.g_dbus_server_start(_arg0)
}

// Stop stops server.
func (server *DBusServer) Stop() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	C.g_dbus_server_stop(_arg0)
}

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu struct {
	MenuModel
}

func wrapMenu(obj *externglib.Object) *Menu {
	return &Menu{
		MenuModel: MenuModel{
			Object: obj,
		},
	}
}

func marshalMenuer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapMenu(obj), nil
}

// NewMenu creates a new #GMenu.
//
// The new menu has no items.
func NewMenu() *Menu {
	var _cret *C.GMenu // in

	_cret = C.g_menu_new()

	var _menu *Menu // out

	_menu = wrapMenu(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menu
}

// Append: convenience function for appending a normal menu item to the end of
// menu. Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (menu *Menu) Append(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if detailedAction != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.g_menu_append(_arg0, _arg1, _arg2)
}

// AppendItem appends item to the end of menu.
//
// See g_menu_insert_item() for more information.
func (menu *Menu) AppendItem(item *MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_append_item(_arg0, _arg1)
}

// AppendSection: convenience function for appending a section menu item to the
// end of menu. Combine g_menu_item_new_section() and g_menu_insert_item() for a
// more flexible alternative.
func (menu *Menu) AppendSection(label string, section MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_append_section(_arg0, _arg1, _arg2)
}

// AppendSubmenu: convenience function for appending a submenu menu item to the
// end of menu. Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
// more flexible alternative.
func (menu *Menu) AppendSubmenu(label string, submenu MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_append_submenu(_arg0, _arg1, _arg2)
}

// Freeze marks menu as frozen.
//
// After the menu is frozen, it is an error to attempt to make any changes to
// it. In effect this means that the #GMenu API must no longer be used.
//
// This function causes g_menu_model_is_mutable() to begin returning FALSE,
// which has some positive performance implications.
func (menu *Menu) Freeze() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))

	C.g_menu_freeze(_arg0)
}

// Insert: convenience function for inserting a normal menu item into menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (menu *Menu) Insert(position int, label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)
	if label != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if detailedAction != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_menu_insert(_arg0, _arg1, _arg2, _arg3)
}

// InsertItem inserts item into menu.
//
// The "insertion" is actually done by copying all of the attribute and link
// values of item and using them to form a new item within menu. As such, item
// itself is not really inserted, but rather, a menu item that is exactly the
// same as the one presently described by item.
//
// This means that item is essentially useless after the insertion occurs. Any
// changes you make to it are ignored unless it is inserted again (at which
// point its updated values will be copied).
//
// You should probably just free item once you're done.
//
// There are many convenience functions to take care of common cases. See
// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as well
// as "prepend" and "append" variants of each of these functions.
func (menu *Menu) InsertItem(position int, item *MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 C.gint       // out
	var _arg2 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_insert_item(_arg0, _arg1, _arg2)
}

// InsertSection: convenience function for inserting a section menu item into
// menu. Combine g_menu_item_new_section() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *Menu) InsertSection(position int, label string, section MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)
	if label != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_insert_section(_arg0, _arg1, _arg2, _arg3)
}

// InsertSubmenu: convenience function for inserting a submenu menu item into
// menu. Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *Menu) InsertSubmenu(position int, label string, submenu MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)
	if label != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_insert_submenu(_arg0, _arg1, _arg2, _arg3)
}

// Prepend: convenience function for prepending a normal menu item to the start
// of menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *Menu) Prepend(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if detailedAction != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.g_menu_prepend(_arg0, _arg1, _arg2)
}

// PrependItem prepends item to the start of menu.
//
// See g_menu_insert_item() for more information.
func (menu *Menu) PrependItem(item *MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_prepend_item(_arg0, _arg1)
}

// PrependSection: convenience function for prepending a section menu item to
// the start of menu. Combine g_menu_item_new_section() and g_menu_insert_item()
// for a more flexible alternative.
func (menu *Menu) PrependSection(label string, section MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_prepend_section(_arg0, _arg1, _arg2)
}

// PrependSubmenu: convenience function for prepending a submenu menu item to
// the start of menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
// for a more flexible alternative.
func (menu *Menu) PrependSubmenu(label string, submenu MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_prepend_submenu(_arg0, _arg1, _arg2)
}

// Remove removes an item from the menu.
//
// position gives the index of the item to remove.
//
// It is an error if position is not in range the range from 0 to one less than
// the number of items in the menu.
//
// It is not possible to remove items by identity since items are added to the
// menu simply by copying their links and attributes (ie: identity of the item
// itself is not preserved).
func (menu *Menu) Remove(position int) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)

	C.g_menu_remove(_arg0, _arg1)
}

// RemoveAll removes all items in the menu.
func (menu *Menu) RemoveAll() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))

	C.g_menu_remove_all(_arg0)
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem struct {
	*externglib.Object
}

func wrapMenuItem(obj *externglib.Object) *MenuItem {
	return &MenuItem{
		Object: obj,
	}
}

func marshalMenuItemmer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapMenuItem(obj), nil
}

// NewMenuItem creates a new Item.
//
// If label is non-NULL it is used to set the "label" attribute of the new item.
//
// If detailed_action is non-NULL it is used to set the "action" and possibly
// the "target" attribute of the new item. See g_menu_item_set_detailed_action()
// for more information.
func NewMenuItem(label string, detailedAction string) *MenuItem {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GMenuItem // in

	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if detailedAction != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_menu_item_new(_arg1, _arg2)

	var _menuItem *MenuItem // out

	_menuItem = wrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemFromModel creates a Item as an exact copy of an existing menu item
// in a Model.
//
// item_index must be valid (ie: be sure to call g_menu_model_get_n_items()
// first).
func NewMenuItemFromModel(model MenuModeller, itemIndex int) *MenuItem {
	var _arg1 *C.GMenuModel // out
	var _arg2 C.gint        // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	_arg2 = C.gint(itemIndex)

	_cret = C.g_menu_item_new_from_model(_arg1, _arg2)

	var _menuItem *MenuItem // out

	_menuItem = wrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemSection creates a new Item representing a section.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_section().
//
// The effect of having one menu appear as a section of another is exactly as it
// sounds: the items from section become a direct part of the menu that
// menu_item is added to.
//
// Visual separation is typically displayed between two non-empty sections. If
// label is non-NULL then it will be encorporated into this visual indication.
// This allows for labeled subsections of a menu.
//
// As a simple example, consider a typical "Edit" menu from a simple program. It
// probably contains an "Undo" and "Redo" item, followed by a separator,
// followed by "Cut", "Copy" and "Paste".
//
// This would be accomplished by creating three #GMenu instances. The first
// would be populated with the "Undo" and "Redo" items, and the second with the
// "Cut", "Copy" and "Paste" items. The first and second menus would then be
// added as submenus of the third. In XML format, this would look something like
// the following:
//
//    <menu id='edit-menu'>
//      <section>
//        <item label='Undo'/>
//        <item label='Redo'/>
//      </section>
//      <section>
//        <item label='Cut'/>
//        <item label='Copy'/>
//        <item label='Paste'/>
//      </section>
//    </menu>
//
// The following example is exactly equivalent. It is more illustrative of the
// exact relationship between the menus and items (keeping in mind that the
// 'link' element defines a new menu that is linked to the containing one). The
// style of the second example is more verbose and difficult to read (and
// therefore not recommended except for the purpose of understanding what is
// really going on).
//
//    <menu id='edit-menu'>
//      <item>
//        <link name='section'>
//          <item label='Undo'/>
//          <item label='Redo'/>
//        </link>
//      </item>
//      <item>
//        <link name='section'>
//          <item label='Cut'/>
//          <item label='Copy'/>
//          <item label='Paste'/>
//        </link>
//      </item>
//    </menu>
func NewMenuItemSection(label string, section MenuModeller) *MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	_cret = C.g_menu_item_new_section(_arg1, _arg2)

	var _menuItem *MenuItem // out

	_menuItem = wrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemSubmenu creates a new Item representing a submenu.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_submenu().
func NewMenuItemSubmenu(label string, submenu MenuModeller) *MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	_cret = C.g_menu_item_new_submenu(_arg1, _arg2)

	var _menuItem *MenuItem // out

	_menuItem = wrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// AttributeValue queries the named attribute on menu_item.
//
// If expected_type is specified and the attribute does not have this type, NULL
// is returned. NULL is also returned if the attribute simply does not exist.
func (menuItem *MenuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _arg0 *C.GMenuItem    // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(expectedType)))

	_cret = C.g_menu_item_get_attribute_value(_arg0, _arg1, _arg2)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _variant
}

// Link queries the named link on menu_item.
func (menuItem *MenuItem) Link(link string) MenuModeller {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_menu_item_get_link(_arg0, _arg1)

	var _menuModel MenuModeller // out

	_menuModel = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(MenuModeller)

	return _menuModel
}

// SetActionAndTargetValue sets or unsets the "action" and "target" attributes
// of menu_item.
//
// If action is NULL then both the "action" and "target" attributes are unset
// (and target_value is ignored).
//
// If action is non-NULL then the "action" attribute is set. The "target"
// attribute is then set to the value of target_value if it is non-NULL or unset
// otherwise.
//
// Normal menu items (ie: not submenu, section or other custom item types) are
// expected to have the "action" attribute set to identify the action that they
// are associated with. The state type of the action help to determine the
// disposition of the menu item. See #GAction and Group for an overview of
// actions.
//
// In general, clicking on the menu item will result in activation of the named
// action with the "target" attribute given as the parameter to the action
// invocation. If the "target" attribute is not set then the action is invoked
// with no parameter.
//
// If the action has no state then the menu item is usually drawn as a plain
// menu item (ie: with no additional decoration).
//
// If the action has a boolean state then the menu item is usually drawn as a
// toggle menu item (ie: with a checkmark or equivalent indication). The item
// should be marked as 'toggled' or 'checked' when the boolean state is TRUE.
//
// If the action has a string state then the menu item is usually drawn as a
// radio menu item (ie: with a radio bullet or equivalent indication). The item
// should be marked as 'selected' when the string state is equal to the value of
// the target property.
//
// See g_menu_item_set_action_and_target() or g_menu_item_set_detailed_action()
// for two equivalent calls that are probably more convenient for most uses.
func (menuItem *MenuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	if action != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(action)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(targetValue)))

	C.g_menu_item_set_action_and_target_value(_arg0, _arg1, _arg2)
}

// SetAttributeValue sets or unsets an attribute on menu_item.
//
// The attribute to set or unset is specified by attribute. This can be one of
// the standard attribute names G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, or a custom attribute name. Attribute names are
// restricted to lowercase characters, numbers and '-'. Furthermore, the names
// must begin with a lowercase character, must not end with a '-', and must not
// contain consecutive dashes.
//
// must consist only of lowercase ASCII characters, digits and '-'.
//
// If value is non-NULL then it is used as the new value for the attribute. If
// value is NULL then the attribute is unset. If the value #GVariant is
// floating, it is consumed.
//
// See also g_menu_item_set_attribute() for a more convenient way to do the
// same.
func (menuItem *MenuItem) SetAttributeValue(attribute string, value *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_menu_item_set_attribute_value(_arg0, _arg1, _arg2)
}

// SetDetailedAction sets the "action" and possibly the "target" attribute of
// menu_item.
//
// The format of detailed_action is the same format parsed by
// g_action_parse_detailed_name().
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but slightly
// less convenient) alternatives.
//
// See also g_menu_item_set_action_and_target_value() for a description of the
// semantics of the action and target attributes.
func (menuItem *MenuItem) SetDetailedAction(detailedAction string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_detailed_action(_arg0, _arg1)
}

// SetIcon sets (or unsets) the icon on menu_item.
//
// This call is the same as calling g_icon_serialize() and using the result as
// the value to g_menu_item_set_attribute_value() for G_MENU_ATTRIBUTE_ICON.
//
// This API is only intended for use with "noun" menu items; things like
// bookmarks or applications in an "Open With" menu. Don't use it on menu items
// corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
//
// If icon is NULL then the icon is unset.
func (menuItem *MenuItem) SetIcon(icon Iconner) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_menu_item_set_icon(_arg0, _arg1)
}

// SetLabel sets or unsets the "label" attribute of menu_item.
//
// If label is non-NULL it is used as the label for the menu item. If it is NULL
// then the label attribute is unset.
func (menuItem *MenuItem) SetLabel(label string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_menu_item_set_label(_arg0, _arg1)
}

// SetLink creates a link from menu_item to model if non-NULL, or unsets it.
//
// Links are used to establish a relationship between a particular menu item and
// another menu. For example, G_MENU_LINK_SUBMENU is used to associate a submenu
// with a particular menu item, and G_MENU_LINK_SECTION is used to create a
// section. Other types of link can be used, but there is no guarantee that
// clients will be able to make sense of them. Link types are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
func (menuItem *MenuItem) SetLink(link string, model MenuModeller) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.g_menu_item_set_link(_arg0, _arg1, _arg2)
}

// SetSection sets or unsets the "section" link of menu_item to section.
//
// The effect of having one menu appear as a section of another is exactly as it
// sounds: the items from section become a direct part of the menu that
// menu_item is added to. See g_menu_item_new_section() for more information
// about what it means for a menu item to be a section.
func (menuItem *MenuItem) SetSection(section MenuModeller) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_item_set_section(_arg0, _arg1)
}

// SetSubmenu sets or unsets the "submenu" link of menu_item to submenu.
//
// If submenu is non-NULL, it is linked to. If it is NULL then the link is
// unset.
//
// The effect of having one menu appear as a submenu of another is exactly as it
// sounds.
func (menuItem *MenuItem) SetSubmenu(submenu MenuModeller) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_item_set_submenu(_arg0, _arg1)
}

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification struct {
	*externglib.Object
}

func wrapNotification(obj *externglib.Object) *Notification {
	return &Notification{
		Object: obj,
	}
}

func marshalNotificationer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapNotification(obj), nil
}

// NewNotification creates a new #GNotification with title as its title.
//
// After populating notification with more details, it can be sent to the
// desktop shell with g_application_send_notification(). Changing any properties
// after this call will not have any effect until resending notification.
func NewNotification(title string) *Notification {
	var _arg1 *C.gchar         // out
	var _cret *C.GNotification // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_notification_new(_arg1)

	var _notification *Notification // out

	_notification = wrapNotification(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _notification
}

// AddButton adds a button to notification that activates the action in
// detailed_action when clicked. That action must be an application-wide action
// (starting with "app."). If detailed_action contains a target, the action will
// be activated with that target as its parameter.
//
// See g_action_parse_detailed_name() for a description of the format for
// detailed_action.
func (notification *Notification) AddButton(label string, detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_notification_add_button(_arg0, _arg1, _arg2)
}

// AddButtonWithTarget adds a button to notification that activates action when
// clicked. action must be an application-wide action (it must start with
// "app.").
//
// If target is non-NULL, action will be activated with target as its parameter.
func (notification *Notification) AddButtonWithTarget(label string, action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(action)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(target)))

	C.g_notification_add_button_with_target_value(_arg0, _arg1, _arg2, _arg3)
}

// SetBody sets the body of notification to body.
func (notification *Notification) SetBody(body string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	if body != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(body)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_notification_set_body(_arg0, _arg1)
}

// SetDefaultAction sets the default action of notification to detailed_action.
// This action is activated when the notification is clicked on.
//
// The action in detailed_action must be an application-wide action (it must
// start with "app."). If detailed_action contains a target, the given action
// will be activated with that target as its parameter. See
// g_action_parse_detailed_name() for a description of the format for
// detailed_action.
//
// When no default action is set, the application that the notification was sent
// on is activated.
func (notification *Notification) SetDefaultAction(detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_default_action(_arg0, _arg1)
}

// SetDefaultActionAndTarget sets the default action of notification to action.
// This action is activated when the notification is clicked on. It must be an
// application-wide action (start with "app.").
//
// If target is non-NULL, action will be activated with target as its parameter.
//
// When no default action is set, the application that the notification was sent
// on is activated.
func (notification *Notification) SetDefaultActionAndTarget(action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(action)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(target)))

	C.g_notification_set_default_action_and_target_value(_arg0, _arg1, _arg2)
}

// SetIcon sets the icon of notification to icon.
func (notification *Notification) SetIcon(icon Iconner) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.GIcon         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_notification_set_icon(_arg0, _arg1)
}

// SetPriority sets the priority of notification to priority. See Priority for
// possible values.
func (notification *Notification) SetPriority(priority NotificationPriority) {
	var _arg0 *C.GNotification        // out
	var _arg1 C.GNotificationPriority // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = C.GNotificationPriority(priority)

	C.g_notification_set_priority(_arg0, _arg1)
}

// SetTitle sets the title of notification to title.
func (notification *Notification) SetTitle(title string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_title(_arg0, _arg1)
}

// SetUrgent: deprecated in favor of g_notification_set_priority().
//
// Deprecated: Since 2.42, this has been deprecated in favour of
// g_notification_set_priority().
func (notification *Notification) SetUrgent(urgent bool) {
	var _arg0 *C.GNotification // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	if urgent {
		_arg1 = C.TRUE
	}

	C.g_notification_set_urgent(_arg0, _arg1)
}

// PropertyAction is a way to get a #GAction with a state value reflecting and
// controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction struct {
	*externglib.Object

	Action
}

func wrapPropertyAction(obj *externglib.Object) *PropertyAction {
	return &PropertyAction{
		Object: obj,
		Action: Action{
			Object: obj,
		},
	}
}

func marshalPropertyActioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapPropertyAction(obj), nil
}

// NewPropertyAction creates a #GAction corresponding to the value of property
// property_name on object.
//
// The property must be existent and readable and writable (and not
// construct-only).
//
// This function takes a reference on object and doesn't release it until the
// action is destroyed.
func NewPropertyAction(name string, object *externglib.Object, propertyName string) *PropertyAction {
	var _arg1 *C.gchar           // out
	var _arg2 C.gpointer         // out
	var _arg3 *C.gchar           // out
	var _cret *C.GPropertyAction // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gpointer(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_property_action_new(_arg1, _arg2, _arg3)

	var _propertyAction *PropertyAction // out

	_propertyAction = wrapPropertyAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _propertyAction
}

func (*PropertyAction) privatePropertyAction() {}

// SimpleAction is the obvious simple implementation of the #GAction interface.
// This is the easiest way to create an action for purposes of adding it to a
// ActionGroup.
//
// See also Action.
type SimpleAction struct {
	*externglib.Object

	Action
}

func wrapSimpleAction(obj *externglib.Object) *SimpleAction {
	return &SimpleAction{
		Object: obj,
		Action: Action{
			Object: obj,
		},
	}
}

func marshalSimpleActioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSimpleAction(obj), nil
}

// NewSimpleAction creates a new action.
//
// The created action is stateless. See g_simple_action_new_stateful() to create
// an action that has state.
func NewSimpleAction(name string, parameterType *glib.VariantType) *SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(parameterType)))

	_cret = C.g_simple_action_new(_arg1, _arg2)

	var _simpleAction *SimpleAction // out

	_simpleAction = wrapSimpleAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleAction
}

// NewSimpleActionStateful creates a new stateful action.
//
// All future state values must have the same Type as the initial state.
//
// If the state #GVariant is floating, it is consumed.
func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) *SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _arg3 *C.GVariant      // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(parameterType)))
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(state)))

	_cret = C.g_simple_action_new_stateful(_arg1, _arg2, _arg3)

	var _simpleAction *SimpleAction // out

	_simpleAction = wrapSimpleAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleAction
}

// SetEnabled sets the action as enabled or not.
//
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to modify its enabled flag.
func (simple *SimpleAction) SetEnabled(enabled bool) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(simple.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.g_simple_action_set_enabled(_arg0, _arg1)
}

// SetState sets the state of the action.
//
// This directly updates the 'state' property to the given value.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to directly modify the 'state' property. Instead,
// they should call g_action_change_state() to request the change.
//
// If the value GVariant is floating, it is consumed.
func (simple *SimpleAction) SetState(value *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(simple.Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_simple_action_set_state(_arg0, _arg1)
}

// SetStateHint sets the state hint for the action.
//
// See g_action_get_state_hint() for more information about action state hints.
func (simple *SimpleAction) SetStateHint(stateHint *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(simple.Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(stateHint)))

	C.g_simple_action_set_state_hint(_arg0, _arg1)
}

// SimpleIOStream creates a OStream from an arbitrary Stream and Stream. This
// allows any pair of input and output streams to be used with OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream struct {
	IOStream
}

func wrapSimpleIOStream(obj *externglib.Object) *SimpleIOStream {
	return &SimpleIOStream{
		IOStream: IOStream{
			Object: obj,
		},
	}
}

func marshalSimpleIOStreamer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSimpleIOStream(obj), nil
}

// NewSimpleIOStream creates a new IOStream wrapping input_stream and
// output_stream. See also OStream.
func NewSimpleIOStream(inputStream InputStreamer, outputStream OutputStreamer) *SimpleIOStream {
	var _arg1 *C.GInputStream  // out
	var _arg2 *C.GOutputStream // out
	var _cret *C.GIOStream     // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(inputStream.Native()))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer(outputStream.Native()))

	_cret = C.g_simple_io_stream_new(_arg1, _arg2)

	var _simpleIOStream *SimpleIOStream // out

	_simpleIOStream = wrapSimpleIOStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleIOStream
}

func (*SimpleIOStream) privateSimpleIOStream() {}

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission struct {
	Permission
}

func wrapSimplePermission(obj *externglib.Object) *SimplePermission {
	return &SimplePermission{
		Permission: Permission{
			Object: obj,
		},
	}
}

func marshalSimplePermissioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSimplePermission(obj), nil
}

// NewSimplePermission creates a new #GPermission instance that represents an
// action that is either always or never allowed.
func NewSimplePermission(allowed bool) *SimplePermission {
	var _arg1 C.gboolean     // out
	var _cret *C.GPermission // in

	if allowed {
		_arg1 = C.TRUE
	}

	_cret = C.g_simple_permission_new(_arg1)

	var _simplePermission *SimplePermission // out

	_simplePermission = wrapSimplePermission(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simplePermission
}

func (*SimplePermission) privateSimplePermission() {}

// Subprocess allows the creation of and interaction with child processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the subprocess.py included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// communicate() method of subprocess.py. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess struct {
	*externglib.Object

	Initable
}

func wrapSubprocess(obj *externglib.Object) *Subprocess {
	return &Subprocess{
		Object: obj,
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalSubprocesser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSubprocess(obj), nil
}

// NewSubprocess: create a new process with the given flags and argument list.
//
// The argument list is expected to be NULL-terminated.
func NewSubprocess(argv []string, flags SubprocessFlags) (*Subprocess, error) {
	var _arg1 **C.gchar          // out
	var _arg2 C.GSubprocessFlags // out
	var _cret *C.GSubprocess     // in
	var _cerr *C.GError          // in

	{
		_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(argv)+1)
			var zero *C.gchar
			out[len(argv)] = zero
			for i := range argv {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(argv[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg2 = C.GSubprocessFlags(flags)

	_cret = C.g_subprocess_newv(_arg1, _arg2, &_cerr)

	var _subprocess *Subprocess // out
	var _goerr error            // out

	_subprocess = wrapSubprocess(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _subprocess, _goerr
}

// CommunicateUTF8: like g_subprocess_communicate(), but validates the output of
// the process as UTF-8, and returns it as a regular NUL terminated string.
//
// On error, stdout_buf and stderr_buf will be set to undefined values and
// should not be used.
func (subprocess *Subprocess) CommunicateUTF8(ctx context.Context, stdinBuf string) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.char         // out
	var _arg3 *C.char         // in
	var _arg4 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if stdinBuf != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(stdinBuf)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_subprocess_communicate_utf8(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	if _arg3 != nil {
		_stdoutBuf = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _arg4 != nil {
		_stderrBuf = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _stdoutBuf, _stderrBuf, _goerr
}

// CommunicateUTF8Async asynchronous version of g_subprocess_communicate_utf8().
// Complete invocation with g_subprocess_communicate_utf8_finish().
func (subprocess *Subprocess) CommunicateUTF8Async(ctx context.Context, stdinBuf string, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if stdinBuf != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(stdinBuf)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.g_subprocess_communicate_utf8_async(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// CommunicateUTF8Finish: complete an invocation of
// g_subprocess_communicate_utf8_async().
func (subprocess *Subprocess) CommunicateUTF8Finish(result AsyncResulter) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _arg3 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_communicate_utf8_finish(_arg0, _arg1, &_arg2, &_arg3, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	if _arg2 != nil {
		_stdoutBuf = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_stderrBuf = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _stdoutBuf, _stderrBuf, _goerr
}

// ForceExit: use an operating-system specific method to attempt an immediate,
// forceful termination of the process. There is no mechanism to determine
// whether or not the request itself was successful; however, you can use
// g_subprocess_wait() to monitor the status of the process after calling this
// function.
//
// On Unix, this function sends SIGKILL.
func (subprocess *Subprocess) ForceExit() {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	C.g_subprocess_force_exit(_arg0)
}

// ExitStatus: check the exit status of the subprocess, given that it exited
// normally. This is the value passed to the exit() system call or the return
// value from main.
//
// This is equivalent to the system WEXITSTATUS macro.
//
// It is an error to call this function before g_subprocess_wait() and unless
// g_subprocess_get_if_exited() returned TRUE.
func (subprocess *Subprocess) ExitStatus() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_exit_status(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Identifier: on UNIX, returns the process ID as a decimal string. On Windows,
// returns the result of GetProcessId() also as a string. If the subprocess has
// terminated, this will return NULL.
func (subprocess *Subprocess) Identifier() string {
	var _arg0 *C.GSubprocess // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_identifier(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IfExited: check if the given subprocess exited normally (ie: by way of exit()
// or return from main()).
//
// This is equivalent to the system WIFEXITED macro.
//
// It is an error to call this function before g_subprocess_wait() has returned.
func (subprocess *Subprocess) IfExited() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_if_exited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IfSignaled: check if the given subprocess terminated in response to a signal.
//
// This is equivalent to the system WIFSIGNALED macro.
//
// It is an error to call this function before g_subprocess_wait() has returned.
func (subprocess *Subprocess) IfSignaled() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_if_signaled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Status gets the raw status code of the process, as from waitpid().
//
// This value has no particular meaning, but it can be used with the macros
// defined by the system headers such as WIFEXITED. It can also be used with
// g_spawn_check_exit_status().
//
// It is more likely that you want to use g_subprocess_get_if_exited() followed
// by g_subprocess_get_exit_status().
//
// It is an error to call this function before g_subprocess_wait() has returned.
func (subprocess *Subprocess) Status() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_status(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// StderrPipe gets the Stream from which to read the stderr output of
// subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE,
// otherwise NULL will be returned.
func (subprocess *Subprocess) StderrPipe() InputStreamer {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_stderr_pipe(_arg0)

	var _inputStream InputStreamer // out

	_inputStream = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(InputStreamer)

	return _inputStream
}

// StdinPipe gets the Stream that you can write to in order to give data to the
// stdin of subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE and not
// G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise NULL will be returned.
func (subprocess *Subprocess) StdinPipe() OutputStreamer {
	var _arg0 *C.GSubprocess   // out
	var _cret *C.GOutputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_stdin_pipe(_arg0)

	var _outputStream OutputStreamer // out

	_outputStream = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(OutputStreamer)

	return _outputStream
}

// StdoutPipe gets the Stream from which to read the stdout output of
// subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// otherwise NULL will be returned.
func (subprocess *Subprocess) StdoutPipe() InputStreamer {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_stdout_pipe(_arg0)

	var _inputStream InputStreamer // out

	_inputStream = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(InputStreamer)

	return _inputStream
}

// Successful checks if the process was "successful". A process is considered
// successful if it exited cleanly with an exit status of 0, either by way of
// the exit() system call or return from main().
//
// It is an error to call this function before g_subprocess_wait() has returned.
func (subprocess *Subprocess) Successful() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_successful(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TermSig: get the signal number that caused the subprocess to terminate, given
// that it terminated due to a signal.
//
// This is equivalent to the system WTERMSIG macro.
//
// It is an error to call this function before g_subprocess_wait() and unless
// g_subprocess_get_if_signaled() returned TRUE.
func (subprocess *Subprocess) TermSig() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_term_sig(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SendSignal sends the UNIX signal signal_num to the subprocess, if it is still
// running.
//
// This API is race-free. If the subprocess has terminated, it will not be
// signalled.
//
// This API is not available on Windows.
func (subprocess *Subprocess) SendSignal(signalNum int) {
	var _arg0 *C.GSubprocess // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = C.gint(signalNum)

	C.g_subprocess_send_signal(_arg0, _arg1)
}

// Wait: synchronously wait for the subprocess to terminate.
//
// After the process terminates you can query its exit status with functions
// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
//
// This function does not fail in the case of the subprocess having abnormal
// termination. See g_subprocess_wait_check() for that.
//
// Cancelling cancellable doesn't kill the subprocess. Call
// g_subprocess_force_exit() if it is desirable.
func (subprocess *Subprocess) Wait(ctx context.Context) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_subprocess_wait(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// WaitAsync: wait for the subprocess to terminate.
//
// This is the asynchronous version of g_subprocess_wait().
func (subprocess *Subprocess) WaitAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg3 = C.gpointer(gbox.AssignOnce(callback))

	C.g_subprocess_wait_async(_arg0, _arg1, _arg2, _arg3)
}

// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
func (subprocess *Subprocess) WaitCheck(ctx context.Context) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_subprocess_wait_check(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// WaitCheckAsync combines g_subprocess_wait_async() with
// g_spawn_check_exit_status().
//
// This is the asynchronous version of g_subprocess_wait_check().
func (subprocess *Subprocess) WaitCheckAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg3 = C.gpointer(gbox.AssignOnce(callback))

	C.g_subprocess_wait_check_async(_arg0, _arg1, _arg2, _arg3)
}

// WaitCheckFinish collects the result of a previous call to
// g_subprocess_wait_check_async().
func (subprocess *Subprocess) WaitCheckFinish(result AsyncResulter) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_wait_check_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// WaitFinish collects the result of a previous call to
// g_subprocess_wait_async().
func (subprocess *Subprocess) WaitFinish(result AsyncResulter) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_wait_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher struct {
	*externglib.Object
}

func wrapSubprocessLauncher(obj *externglib.Object) *SubprocessLauncher {
	return &SubprocessLauncher{
		Object: obj,
	}
}

func marshalSubprocessLauncherer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSubprocessLauncher(obj), nil
}

// NewSubprocessLauncher creates a new Launcher.
//
// The launcher is created with the default options. A copy of the environment
// of the calling process is made at the time of this call and will be used as
// the environment that the process is launched in.
func NewSubprocessLauncher(flags SubprocessFlags) *SubprocessLauncher {
	var _arg1 C.GSubprocessFlags     // out
	var _cret *C.GSubprocessLauncher // in

	_arg1 = C.GSubprocessFlags(flags)

	_cret = C.g_subprocess_launcher_new(_arg1)

	var _subprocessLauncher *SubprocessLauncher // out

	_subprocessLauncher = wrapSubprocessLauncher(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _subprocessLauncher
}

// Close closes all the file descriptors previously passed to the object with
// g_subprocess_launcher_take_fd(), g_subprocess_launcher_take_stderr_fd(), etc.
//
// After calling this method, any subsequent calls to
// g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will return
// G_IO_ERROR_CLOSED. This method is idempotent if called more than once.
//
// This function is called automatically when the Launcher is disposed, but is
// provided separately so that garbage collected language bindings can call it
// earlier to guarantee when FDs are closed.
func (self *SubprocessLauncher) Close() {
	var _arg0 *C.GSubprocessLauncher // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))

	C.g_subprocess_launcher_close(_arg0)
}

// Env returns the value of the environment variable variable in the environment
// of processes launched from this launcher.
//
// On UNIX, the returned string can be an arbitrary byte string. On Windows, it
// will be UTF-8.
func (self *SubprocessLauncher) env(variable string) string {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_subprocess_launcher_getenv(_arg0, _arg1)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// SetCwd sets the current working directory that processes will be launched
// with.
//
// By default processes are launched with the current working directory of the
// launching process at the time of launch.
func (self *SubprocessLauncher) SetCwd(cwd string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(cwd)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_cwd(_arg0, _arg1)
}

// SetEnviron: replace the entire environment of processes launched from this
// launcher with the given 'environ' variable.
//
// Typically you will build this variable by using g_listenv() to copy the
// process 'environ' and using the functions g_environ_setenv(),
// g_environ_unsetenv(), etc.
//
// As an alternative, you can use g_subprocess_launcher_setenv(),
// g_subprocess_launcher_unsetenv(), etc.
//
// Pass an empty array to set an empty environment. Pass NULL to inherit the
// parent processâ€™ environment. As of GLib 2.54, the parent processâ€™ environment
// will be copied when g_subprocess_launcher_set_environ() is called.
// Previously, it was copied when the subprocess was executed. This means the
// copied environment may now be modified (using g_subprocess_launcher_setenv(),
// etc.) before launching the subprocess.
//
// On UNIX, all strings in this array can be arbitrary byte strings. On Windows,
// they should be in UTF-8.
func (self *SubprocessLauncher) SetEnviron(env []string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar              // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	{
		_arg1 = (**C.gchar)(C.malloc(C.ulong(len(env)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(env)+1)
			var zero *C.gchar
			out[len(env)] = zero
			for i := range env {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(env[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.g_subprocess_launcher_set_environ(_arg0, _arg1)
}

// SetFlags sets the flags on the launcher.
//
// The default flags are G_SUBPROCESS_FLAGS_NONE.
//
// You may not set flags that specify conflicting options for how to handle a
// particular stdio stream (eg: specifying both G_SUBPROCESS_FLAGS_STDIN_PIPE
// and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
//
// You may also not set a flag that conflicts with a previous call to a function
// like g_subprocess_launcher_set_stdin_file_path() or
// g_subprocess_launcher_take_stdout_fd().
func (self *SubprocessLauncher) SetFlags(flags SubprocessFlags) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.GSubprocessFlags     // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = C.GSubprocessFlags(flags)

	C.g_subprocess_launcher_set_flags(_arg0, _arg1)
}

// SetStderrFilePath sets the file path to use as the stderr for spawned
// processes.
//
// If path is NULL then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as would
// be the case if using '2>' at the shell.
//
// If you want to send both stdout and stderr to the same file then use
// G_SUBPROCESS_FLAGS_STDERR_MERGE.
//
// You may not set a stderr file path if a stderr fd is already set or if the
// launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) SetStderrFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	if path != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_subprocess_launcher_set_stderr_file_path(_arg0, _arg1)
}

// SetStdinFilePath sets the file path to use as the stdin for spawned
// processes.
//
// If path is NULL then any previously given path is unset.
//
// The file must exist or spawning the process will fail.
//
// You may not set a stdin file path if a stdin fd is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) SetStdinFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdin_file_path(_arg0, _arg1)
}

// SetStdoutFilePath sets the file path to use as the stdout for spawned
// processes.
//
// If path is NULL then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as would
// be the case if using '>' at the shell.
//
// You may not set a stdout file path if a stdout fd is already set or if the
// launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) SetStdoutFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	if path != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_subprocess_launcher_set_stdout_file_path(_arg0, _arg1)
}

// Setenv sets the environment variable variable in the environment of processes
// launched from this launcher.
//
// On UNIX, both the variable's name and value can be arbitrary byte strings,
// except that the variable's name cannot contain '='. On Windows, they should
// be in UTF-8.
func (self *SubprocessLauncher) Setenv(variable string, value string, overwrite bool) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 C.gboolean             // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))
	if overwrite {
		_arg3 = C.TRUE
	}

	C.g_subprocess_launcher_setenv(_arg0, _arg1, _arg2, _arg3)
}

// Spawnv creates a #GSubprocess given a provided array of arguments.
func (self *SubprocessLauncher) Spawnv(argv []string) (*Subprocess, error) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar              // out
	var _cret *C.GSubprocess         // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	{
		_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(argv)+1)
			var zero *C.gchar
			out[len(argv)] = zero
			for i := range argv {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(argv[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.g_subprocess_launcher_spawnv(_arg0, _arg1, &_cerr)

	var _subprocess *Subprocess // out
	var _goerr error            // out

	_subprocess = wrapSubprocess(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _subprocess, _goerr
}

// TakeFd: transfer an arbitrary file descriptor from parent process to the
// child. This function takes ownership of the source_fd; it will be closed in
// the parent when self is freed.
//
// By default, all file descriptors from the parent will be closed. This
// function allows you to create (for example) a custom pipe() or socketpair()
// before launching the process, and choose the target descriptor in the child.
//
// An example use case is GNUPG, which has a command line argument
// --passphrase-fd providing a file descriptor number where it expects the
// passphrase to be written.
func (self *SubprocessLauncher) TakeFd(sourceFd int, targetFd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out
	var _arg2 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(sourceFd)
	_arg2 = C.gint(targetFd)

	C.g_subprocess_launcher_take_fd(_arg0, _arg1, _arg2)
}

// TakeStderrFd sets the file descriptor to use as the stderr for spawned
// processes.
//
// If fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stderr through to the stderr of
// the parent process.
//
// The passed fd belongs to the Launcher. It will be automatically closed when
// the launcher is finalized. The file descriptor will also be closed on the
// child side when executing the spawned process.
//
// You may not set a stderr fd if a stderr file path is already set or if the
// launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) TakeStderrFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stderr_fd(_arg0, _arg1)
}

// TakeStdinFd sets the file descriptor to use as the stdin for spawned
// processes.
//
// If fd is -1 then any previously given fd is unset.
//
// Note that if your intention is to have the stdin of the calling process
// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better way
// to go about doing that.
//
// The passed fd is noted but will not be touched in the current process. It is
// therefore necessary that it be kept open by the caller until the subprocess
// is spawned. The file descriptor will also not be explicitly closed on the
// child side, so it must be marked O_CLOEXEC if that's what you want.
//
// You may not set a stdin fd if a stdin file path is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) TakeStdinFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdin_fd(_arg0, _arg1)
}

// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
// processes.
//
// If fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stdout through to the stdout of
// the parent process.
//
// The passed fd is noted but will not be touched in the current process. It is
// therefore necessary that it be kept open by the caller until the subprocess
// is spawned. The file descriptor will also not be explicitly closed on the
// child side, so it must be marked O_CLOEXEC if that's what you want.
//
// You may not set a stdout fd if a stdout file path is already set or if the
// launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) TakeStdoutFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdout_fd(_arg0, _arg1)
}

// Unsetenv removes the environment variable variable from the environment of
// processes launched from this launcher.
//
// On UNIX, the variable's name can be an arbitrary byte string not containing
// '='. On Windows, it should be in UTF-8.
func (self *SubprocessLauncher) Unsetenv(variable string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_unsetenv(_arg0, _arg1)
}

// TestDBus: helper class for testing code which uses D-Bus without touching the
// user's session bus.
//
// Note that DBus modifies the userâ€™s environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a services subdirectory of your tests directory is a
// good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as my-server.service.in in the services
// directory and have it processed by configure.
//
//    [D-BUS Service]
//    Name=org.gtk.GDBus.Examples.ObjectManager
//    Exec=abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//
// You will also need to indicate this service directory in your test fixtures,
// so you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as:
//
//       -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//
//    Once you have a service definition file which is local to your source tree,
//
// you can proceed to set up a GTest fixture using the DBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found here:
// gdbus-test-fixture.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting GSETTINGS_SCHEMA_DIR to the in tree directory holding your
// schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas:
//
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
type TestDBus struct {
	*externglib.Object
}

func wrapTestDBus(obj *externglib.Object) *TestDBus {
	return &TestDBus{
		Object: obj,
	}
}

func marshalTestDBusser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTestDBus(obj), nil
}

// NewTestDBus: create a new DBus object.
func NewTestDBus(flags TestDBusFlags) *TestDBus {
	var _arg1 C.GTestDBusFlags // out
	var _cret *C.GTestDBus     // in

	_arg1 = C.GTestDBusFlags(flags)

	_cret = C.g_test_dbus_new(_arg1)

	var _testDBus *TestDBus // out

	_testDBus = wrapTestDBus(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _testDBus
}

// AddServiceDir: add a path where dbus-daemon will look up .service files. This
// can't be called after g_test_dbus_up().
func (self *TestDBus) AddServiceDir(path string) {
	var _arg0 *C.GTestDBus // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_test_dbus_add_service_dir(_arg0, _arg1)
}

// Down: stop the session bus started by g_test_dbus_up().
//
// This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
// to be destroyed. This is done to ensure that the next unit test won't get a
// leaked singleton from this test.
func (self *TestDBus) Down() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	C.g_test_dbus_down(_arg0)
}

// BusAddress: get the address on which dbus-daemon is running. If
// g_test_dbus_up() has not been called yet, NULL is returned. This can be used
// with g_dbus_connection_new_for_address().
func (self *TestDBus) BusAddress() string {
	var _arg0 *C.GTestDBus // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	_cret = C.g_test_dbus_get_bus_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Flags: get the flags of the DBus object.
func (self *TestDBus) Flags() TestDBusFlags {
	var _arg0 *C.GTestDBus     // out
	var _cret C.GTestDBusFlags // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	_cret = C.g_test_dbus_get_flags(_arg0)

	var _testDBusFlags TestDBusFlags // out

	_testDBusFlags = TestDBusFlags(_cret)

	return _testDBusFlags
}

// Stop the session bus started by g_test_dbus_up().
//
// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests wanting
// to verify behaviour after the session bus has been stopped can use this
// function but should still call g_test_dbus_down() when done.
func (self *TestDBus) Stop() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	C.g_test_dbus_stop(_arg0)
}

// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
// call, it is safe for unit tests to start sending messages on the session bus.
//
// If this function is called from setup callback of g_test_add(),
// g_test_dbus_down() must be called in its teardown callback.
//
// If this function is called from unit test's main(), then g_test_dbus_down()
// must be called after g_test_run().
func (self *TestDBus) Up() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	C.g_test_dbus_up(_arg0)
}
