// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
//
// void gotk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitorrer},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIconner},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGrouper},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserverer},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnectioner},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModeller},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessager},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocationer},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServerer},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenuer},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItemmer},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotificationer},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyActioner},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleActioner},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStreamer},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermissioner},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocesser},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncherer},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBusser},
	})
}

// AppInfoMonitorrer describes AppInfoMonitor's methods.
type AppInfoMonitorrer interface {
	privateAppInfoMonitor()
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor struct {
	*externglib.Object
}

var (
	_ AppInfoMonitorrer = (*AppInfoMonitor)(nil)
	_ gextras.Nativer   = (*AppInfoMonitor)(nil)
)

func wrapAppInfoMonitor(obj *externglib.Object) AppInfoMonitorrer {
	return &AppInfoMonitor{
		Object: obj,
	}
}

func marshalAppInfoMonitorrer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapAppInfoMonitor(obj), nil
}

func (*AppInfoMonitor) privateAppInfoMonitor() {}

// BytesIconner describes BytesIcon's methods.
type BytesIconner interface {
	privateBytesIcon()
}

// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
type BytesIcon struct {
	*externglib.Object

	LoadableIcon
}

var (
	_ BytesIconner    = (*BytesIcon)(nil)
	_ gextras.Nativer = (*BytesIcon)(nil)
)

func wrapBytesIcon(obj *externglib.Object) BytesIconner {
	return &BytesIcon{
		Object: obj,
		LoadableIcon: LoadableIcon{
			Icon: Icon{
				Object: obj,
			},
		},
	}
}

func marshalBytesIconner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapBytesIcon(obj), nil
}

func (*BytesIcon) privateBytesIcon() {}

// DBusActionGrouper describes DBusActionGroup's methods.
type DBusActionGrouper interface {
	privateDBusActionGroup()
}

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup struct {
	*externglib.Object

	RemoteActionGroup
}

var (
	_ DBusActionGrouper = (*DBusActionGroup)(nil)
	_ gextras.Nativer   = (*DBusActionGroup)(nil)
)

func wrapDBusActionGroup(obj *externglib.Object) DBusActionGrouper {
	return &DBusActionGroup{
		Object: obj,
		RemoteActionGroup: RemoteActionGroup{
			ActionGroup: ActionGroup{
				Object: obj,
			},
		},
	}
}

func marshalDBusActionGrouper(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusActionGroup(obj), nil
}

func (*DBusActionGroup) privateDBusActionGroup() {}

// DBusAuthObserverer describes DBusAuthObserver's methods.
type DBusAuthObserverer interface {
	// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
	// @observer.
	AllowMechanism(mechanism string) bool

	AuthorizeAuthenticatedPeer(stream IOStreamer, credentials Credentialser) bool
}

// DBusAuthObserver type provides a mechanism for participating in how a
// BusServer (or a BusConnection) authenticates remote peers. Simply instantiate
// a BusAuthObserver and connect to the signals you are interested in. Note that
// new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
type DBusAuthObserver struct {
	*externglib.Object
}

var (
	_ DBusAuthObserverer = (*DBusAuthObserver)(nil)
	_ gextras.Nativer    = (*DBusAuthObserver)(nil)
)

func wrapDBusAuthObserver(obj *externglib.Object) DBusAuthObserverer {
	return &DBusAuthObserver{
		Object: obj,
	}
}

func marshalDBusAuthObserverer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusAuthObserver(obj), nil
}

// NewDBusAuthObserver creates a new BusAuthObserver object.
func NewDBusAuthObserver() *DBusAuthObserver {
	var _cret *C.GDBusAuthObserver // in

	_cret = C.g_dbus_auth_observer_new()

	var _dBusAuthObserver *DBusAuthObserver // out

	_dBusAuthObserver = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusAuthObserver)

	return _dBusAuthObserver
}

// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
// @observer.
func (observer *DBusAuthObserver) AllowMechanism(mechanism string) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.gchar             // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg1 = (*C.gchar)(C.CString(mechanism))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_auth_observer_allow_mechanism(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AuthorizeAuthenticatedPeer emits the
// BusAuthObserver::authorize-authenticated-peer signal on @observer.
func (observer *DBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStreamer, credentials Credentialser) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.GIOStream         // out
	var _arg2 *C.GCredentials      // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer((stream).(gextras.Nativer).Native()))
	_arg2 = (*C.GCredentials)(unsafe.Pointer((credentials).(gextras.Nativer).Native()))

	_cret = C.g_dbus_auth_observer_authorize_authenticated_peer(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusConnectioner describes DBusConnection's methods.
type DBusConnectioner interface {
	// CallFinish finishes an operation started with g_dbus_connection_call().
	CallFinish(res AsyncResulter) (*glib.Variant, error)
	// CallWithUnixFdListFinish finishes an operation started with
	// g_dbus_connection_call_with_unix_fd_list().
	CallWithUnixFdListFinish(res AsyncResulter) (*UnixFDList, *glib.Variant, error)
	// Close closes @connection.
	Close(cancellable Cancellabler, callback AsyncReadyCallback)
	// CloseFinish finishes an operation started with g_dbus_connection_close().
	CloseFinish(res AsyncResulter) error
	// CloseSync: synchronously closes @connection.
	CloseSync(cancellable Cancellabler) error
	// EmitSignal emits a signal.
	EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error
	// ExportActionGroup exports @action_group on @connection at @object_path.
	ExportActionGroup(objectPath string, actionGroup ActionGrouper) (uint, error)
	// ExportMenuModel exports @menu on @connection at @object_path.
	ExportMenuModel(objectPath string, menu MenuModeller) (uint, error)
	// Flush: asynchronously flushes @connection, that is, writes all queued
	// outgoing message to the transport and then flushes the transport (using
	// g_output_stream_flush_async()).
	Flush(cancellable Cancellabler, callback AsyncReadyCallback)
	// FlushFinish finishes an operation started with g_dbus_connection_flush().
	FlushFinish(res AsyncResulter) error
	// FlushSync: synchronously flushes @connection.
	FlushSync(cancellable Cancellabler) error
	// Capabilities gets the capabilities negotiated with the remote peer
	Capabilities() DBusCapabilityFlags
	// ExitOnClose gets whether the process is terminated when @connection is
	// closed by the remote peer.
	ExitOnClose() bool
	// Flags gets the flags used to construct this connection
	Flags() DBusConnectionFlags
	// Guid: GUID of the peer performing the role of server when authenticating.
	Guid() string
	// LastSerial retrieves the last serial number assigned to a BusMessage on
	// the current thread.
	LastSerial() uint32
	// PeerCredentials gets the credentials of the authenticated peer.
	PeerCredentials() *Credentials
	// Stream gets the underlying stream used for IO.
	Stream() *IOStream
	// UniqueName gets the unique name of @connection as assigned by the message
	// bus.
	UniqueName() string
	// IsClosed gets whether @connection is closed.
	IsClosed() bool
	// RemoveFilter removes a filter.
	RemoveFilter(filterId uint)
	// SendMessageWithReplyFinish finishes an operation started with
	// g_dbus_connection_send_message_with_reply().
	SendMessageWithReplyFinish(res AsyncResulter) (*DBusMessage, error)
	// SetExitOnClose sets whether the process should be terminated when
	// @connection is closed by the remote peer.
	SetExitOnClose(exitOnClose bool)
	// SignalUnsubscribe unsubscribes from signals.
	SignalUnsubscribe(subscriptionId uint)
	// StartMessageProcessing: if @connection was created with
	// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
	// processing messages.
	StartMessageProcessing()
	// UnexportActionGroup reverses the effect of a previous call to
	// g_dbus_connection_export_action_group().
	UnexportActionGroup(exportId uint)
	// UnexportMenuModel reverses the effect of a previous call to
	// g_dbus_connection_export_menu_model().
	UnexportMenuModel(exportId uint)
	// UnregisterObject unregisters an object.
	UnregisterObject(registrationId uint) bool
	// UnregisterSubtree unregisters a subtree.
	UnregisterSubtree(registrationId uint) bool
}

// DBusConnection type is used for D-Bus connections to remote peers such as a
// message buses. It is a low-level API that offers a lot of flexibility. For
// instance, it lets you establish a connection over any transport that can by
// represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
//
// An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
//
// An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
//
// An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
//
// An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection struct {
	*externglib.Object

	AsyncInitable
	Initable
}

var (
	_ DBusConnectioner = (*DBusConnection)(nil)
	_ gextras.Nativer  = (*DBusConnection)(nil)
)

func wrapDBusConnection(obj *externglib.Object) DBusConnectioner {
	return &DBusConnection{
		Object: obj,
		AsyncInitable: AsyncInitable{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusConnectioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusConnection(obj), nil
}

// NewDBusConnectionFinish finishes an operation started with
// g_dbus_connection_new().
func NewDBusConnectionFinish(res AsyncResulter) (*DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	_cret = C.g_dbus_connection_new_finish(_arg1, &_cerr)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressFinish finishes an operation started with
// g_dbus_connection_new_for_address().
func NewDBusConnectionForAddressFinish(res AsyncResulter) (*DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	_cret = C.g_dbus_connection_new_for_address_finish(_arg1, &_cerr)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// CallFinish finishes an operation started with g_dbus_connection_call().
func (connection *DBusConnection) CallFinish(res AsyncResulter) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	_cret = C.g_dbus_connection_call_finish(_arg0, _arg1, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

// CallWithUnixFdListFinish finishes an operation started with
// g_dbus_connection_call_with_unix_fd_list().
//
// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values in
// the body of the message. For example, if g_variant_get_handle() returns 5,
// that is intended to be a reference to the file descriptor that can be
// accessed by `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
//
// When designing D-Bus APIs that are intended to be interoperable, please note
// that non-GDBus implementations of D-Bus can usually only access file
// descriptors if they are referenced in this way by a value of type
// G_VARIANT_TYPE_HANDLE in the body of the message.
func (connection *DBusConnection) CallWithUnixFdListFinish(res AsyncResulter) (*UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GUnixFDList     // in
	var _arg2 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg2 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	_cret = C.g_dbus_connection_call_with_unix_fd_list_finish(_arg0, &_arg1, _arg2, &_cerr)

	var _outFdList *UnixFDList // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1)))).(*UnixFDList)
	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

// Close closes @connection. Note that this never causes the process to exit
// (this might only happen if the other end of a shared message bus connection
// disconnects, see BusConnection:exit-on-close).
//
// Once the connection is closed, operations such as sending a message will
// return with the error G_IO_ERROR_CLOSED. Closing a connection will not
// automatically flush the connection so queued messages may be lost. Use
// g_dbus_connection_flush() if you need such guarantees.
//
// If @connection is already closed, this method fails with G_IO_ERROR_CLOSED.
//
// When @connection has been closed, the BusConnection::closed signal is emitted
// in the [thread-default main context][g-main-context-push-thread-default] of
// the thread that @connection was constructed in.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_connection_close_finish() to get
// the result of the operation. See g_dbus_connection_close_sync() for the
// synchronous version.
func (connection *DBusConnection) Close(cancellable Cancellabler, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_close(_arg0, _arg1, _arg2, _arg3)
}

// CloseFinish finishes an operation started with g_dbus_connection_close().
func (connection *DBusConnection) CloseFinish(res AsyncResulter) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	C.g_dbus_connection_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// CloseSync: synchronously closes @connection. The calling thread is blocked
// until this is done. See g_dbus_connection_close() for the asynchronous
// version of this method and more details about what it does.
func (connection *DBusConnection) CloseSync(cancellable Cancellabler) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))

	C.g_dbus_connection_close_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// EmitSignal emits a signal.
//
// If the parameters GVariant is floating, it is consumed.
//
// This can only fail if @parameters is not compatible with the D-Bus protocol
// (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
// (G_IO_ERROR_CLOSED).
func (connection *DBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.gchar)(C.CString(destinationBusName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters))

	C.g_dbus_connection_emit_signal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ExportActionGroup exports @action_group on @connection at @object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// A given object path can only have one action group exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// @error set accordingly).
//
// You can unexport the action group using
// g_dbus_connection_unexport_action_group() with the return value of this
// function.
//
// The thread default main context is taken at the time of this call. All
// incoming action activations and state change requests are reported from this
// context. Any changes on the action group that cause it to emit signals must
// also come from this same context. Since incoming action activations and state
// change requests are rather likely to cause changes on the action group, this
// effectively limits a given action group to being exported from only one main
// context.
func (connection *DBusConnection) ExportActionGroup(objectPath string, actionGroup ActionGrouper) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GActionGroup    // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer((actionGroup).(gextras.Nativer).Native()))

	_cret = C.g_dbus_connection_export_action_group(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// ExportMenuModel exports @menu on @connection at @object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// An object path can only have one menu model exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// @error set accordingly).
//
// You can unexport the menu model using g_dbus_connection_unexport_menu_model()
// with the return value of this function.
func (connection *DBusConnection) ExportMenuModel(objectPath string, menu MenuModeller) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GMenuModel      // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer((menu).(gextras.Nativer).Native()))

	_cret = C.g_dbus_connection_export_menu_model(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// Flush: asynchronously flushes @connection, that is, writes all queued
// outgoing message to the transport and then flushes the transport (using
// g_output_stream_flush_async()). This is useful in programs that wants to emit
// a D-Bus signal and then exit immediately. Without flushing the connection,
// there is no guaranteed that the message has been sent to the networking
// buffers in the OS kernel.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_connection_flush_finish() to get
// the result of the operation. See g_dbus_connection_flush_sync() for the
// synchronous version.
func (connection *DBusConnection) Flush(cancellable Cancellabler, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_flush(_arg0, _arg1, _arg2, _arg3)
}

// FlushFinish finishes an operation started with g_dbus_connection_flush().
func (connection *DBusConnection) FlushFinish(res AsyncResulter) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	C.g_dbus_connection_flush_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// FlushSync: synchronously flushes @connection. The calling thread is blocked
// until this is done. See g_dbus_connection_flush() for the asynchronous
// version of this method and more details about what it does.
func (connection *DBusConnection) FlushSync(cancellable Cancellabler) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))

	C.g_dbus_connection_flush_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Capabilities gets the capabilities negotiated with the remote peer
func (connection *DBusConnection) Capabilities() DBusCapabilityFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusCapabilityFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_capabilities(_arg0)

	var _dBusCapabilityFlags DBusCapabilityFlags // out

	_dBusCapabilityFlags = (DBusCapabilityFlags)(_cret)

	return _dBusCapabilityFlags
}

// ExitOnClose gets whether the process is terminated when @connection is closed
// by the remote peer. See BusConnection:exit-on-close for more details.
func (connection *DBusConnection) ExitOnClose() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_exit_on_close(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Flags gets the flags used to construct this connection
func (connection *DBusConnection) Flags() DBusConnectionFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusConnectionFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_flags(_arg0)

	var _dBusConnectionFlags DBusConnectionFlags // out

	_dBusConnectionFlags = (DBusConnectionFlags)(_cret)

	return _dBusConnectionFlags
}

// Guid: GUID of the peer performing the role of server when authenticating. See
// BusConnection:guid for more details.
func (connection *DBusConnection) Guid() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LastSerial retrieves the last serial number assigned to a BusMessage on the
// current thread. This includes messages sent via both low-level API such as
// g_dbus_connection_send_message() as well as high-level API such as
// g_dbus_connection_emit_signal(), g_dbus_connection_call() or
// g_dbus_proxy_call().
func (connection *DBusConnection) LastSerial() uint32 {
	var _arg0 *C.GDBusConnection // out
	var _cret C.guint32          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_last_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// PeerCredentials gets the credentials of the authenticated peer. This will
// always return nil unless @connection acted as a server (e.g.
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and the
// client passed credentials as part of the authentication process.
//
// In a message bus setup, the message bus is always the server and each
// application is a client. So this method will always return nil for message
// bus clients.
func (connection *DBusConnection) PeerCredentials() *Credentials {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GCredentials    // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_peer_credentials(_arg0)

	var _credentials *Credentials // out

	_credentials = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Credentials)

	return _credentials
}

// Stream gets the underlying stream used for IO.
//
// While the BusConnection is active, it will interact with this stream from a
// worker thread, so it is not safe to interact with the stream directly.
func (connection *DBusConnection) Stream() *IOStream {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GIOStream       // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_stream(_arg0)

	var _ioStream *IOStream // out

	_ioStream = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*IOStream)

	return _ioStream
}

// UniqueName gets the unique name of @connection as assigned by the message
// bus. This can also be used to figure out if @connection is a message bus
// connection.
func (connection *DBusConnection) UniqueName() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_get_unique_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsClosed gets whether @connection is closed.
func (connection *DBusConnection) IsClosed() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_connection_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFilter removes a filter.
//
// Note that since filters run in a different thread, there is a race condition
// where it is possible that the filter will be running even after calling
// g_dbus_connection_remove_filter(), so you cannot just free data that the
// filter might be using. Instead, you should pass a Notify to
// g_dbus_connection_add_filter(), which will be called when it is guaranteed
// that the data is no longer needed.
func (connection *DBusConnection) RemoveFilter(filterId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(filterId)

	C.g_dbus_connection_remove_filter(_arg0, _arg1)
}

// SendMessageWithReplyFinish finishes an operation started with
// g_dbus_connection_send_message_with_reply().
//
// Note that @error is only set if a local in-process error occurred. That is to
// say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode this
// to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (connection *DBusConnection) SendMessageWithReplyFinish(res AsyncResulter) (*DBusMessage, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusMessage    // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	_cret = C.g_dbus_connection_send_message_with_reply_finish(_arg0, _arg1, &_cerr)

	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_dBusMessage = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

// SetExitOnClose sets whether the process should be terminated when @connection
// is closed by the remote peer. See BusConnection:exit-on-close for more
// details.
//
// Note that this function should be used with care. Most modern UNIX desktops
// tie the notion of a user session with the session bus, and expect all of a
// user's applications to quit when their bus connection goes away. If you are
// setting @exit_on_close to false for the shared session bus connection, you
// should make sure that your application exits when the user session ends.
func (connection *DBusConnection) SetExitOnClose(exitOnClose bool) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	if exitOnClose {
		_arg1 = C.TRUE
	}

	C.g_dbus_connection_set_exit_on_close(_arg0, _arg1)
}

// SignalUnsubscribe unsubscribes from signals.
//
// Note that there may still be D-Bus traffic to process (relating to this
// signal subscription) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_dbus_connection_signal_subscribe() is called, in
// order to avoid memory leaks through callbacks queued on the Context after
// itâ€™s stopped being iterated.
func (connection *DBusConnection) SignalUnsubscribe(subscriptionId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(subscriptionId)

	C.g_dbus_connection_signal_unsubscribe(_arg0, _arg1)
}

// StartMessageProcessing: if @connection was created with
// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
// processing messages. Does nothing on if @connection wasn't created with this
// flag or if the method has already been called.
func (connection *DBusConnection) StartMessageProcessing() {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	C.g_dbus_connection_start_message_processing(_arg0)
}

// UnexportActionGroup reverses the effect of a previous call to
// g_dbus_connection_export_action_group().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_action_group() or to call it with the same ID more
// than once.
func (connection *DBusConnection) UnexportActionGroup(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_action_group(_arg0, _arg1)
}

// UnexportMenuModel reverses the effect of a previous call to
// g_dbus_connection_export_menu_model().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_menu_model() or to call it with the same ID more
// than once.
func (connection *DBusConnection) UnexportMenuModel(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_menu_model(_arg0, _arg1)
}

// UnregisterObject unregisters an object.
func (connection *DBusConnection) UnregisterObject(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_object(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnregisterSubtree unregisters a subtree.
func (connection *DBusConnection) UnregisterSubtree(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_subtree(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusMenuModeller describes DBusMenuModel's methods.
type DBusMenuModeller interface {
	privateDBusMenuModel()
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel struct {
	MenuModel
}

var (
	_ DBusMenuModeller = (*DBusMenuModel)(nil)
	_ gextras.Nativer  = (*DBusMenuModel)(nil)
)

func wrapDBusMenuModel(obj *externglib.Object) DBusMenuModeller {
	return &DBusMenuModel{
		MenuModel: MenuModel{
			Object: obj,
		},
	}
}

func marshalDBusMenuModeller(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusMenuModel(obj), nil
}

func (*DBusMenuModel) privateDBusMenuModel() {}

// DBusMessager describes DBusMessage's methods.
type DBusMessager interface {
	// Copy copies @message.
	Copy() (*DBusMessage, error)
	// Arg0: convenience to get the first item in the body of @message.
	Arg0() string
	// Body gets the body of a message.
	Body() *glib.Variant
	// ByteOrder gets the byte order of @message.
	ByteOrder() DBusMessageByteOrder
	// Destination: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	Destination() string
	// ErrorName: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	ErrorName() string
	// Flags gets the flags for @message.
	Flags() DBusMessageFlags
	// HeaderFields gets an array of all header fields on @message that are set.
	HeaderFields() []byte
	// Interface: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	Interface() string
	// Locked checks whether @message is locked.
	Locked() bool
	// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	Member() string
	// MessageType gets the type of @message.
	MessageType() DBusMessageType
	// NumUnixFds: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	NumUnixFds() uint32
	// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
	// field.
	Path() string
	// ReplySerial: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	ReplySerial() uint32
	// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	Sender() string
	// Serial gets the serial for @message.
	Serial() uint32
	// Signature: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	Signature() string
	// UnixFdList gets the UNIX file descriptors associated with @message, if
	// any.
	UnixFdList() *UnixFDList
	// Lock: if @message is locked, does nothing.
	Lock()
	// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
	// @method_call_message.
	NewMethodErrorLiteral(errorName string, errorMessage string) *DBusMessage
	// NewMethodReply creates a new BusMessage that is a reply to
	// @method_call_message.
	NewMethodReply() *DBusMessage
	// Print produces a human-readable multi-line description of @message.
	Print(indent uint) string
	// SetBody sets the body @message.
	SetBody(body *glib.Variant)
	// SetDestination: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	SetDestination(value string)
	// SetErrorName: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	SetErrorName(value string)
	// SetInterface: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	SetInterface(value string)
	// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	SetMember(value string)
	// SetNumUnixFds: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	SetNumUnixFds(value uint32)
	// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
	// header field.
	SetPath(value string)
	// SetReplySerial: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	SetReplySerial(value uint32)
	// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	SetSender(value string)
	// SetSerial sets the serial for @message.
	SetSerial(serial uint32)
	// SetSignature: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	SetSignature(value string)
	// SetUnixFdList sets the UNIX file descriptors associated with @message.
	SetUnixFdList(fdList UnixFDLister)
	// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
	// nothing and returns false.
	ToGerror() error
}

// DBusMessage: type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage struct {
	*externglib.Object
}

var (
	_ DBusMessager    = (*DBusMessage)(nil)
	_ gextras.Nativer = (*DBusMessage)(nil)
)

func wrapDBusMessage(obj *externglib.Object) DBusMessager {
	return &DBusMessage{
		Object: obj,
	}
}

func marshalDBusMessager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusMessage(obj), nil
}

// NewDBusMessage creates a new empty BusMessage.
func NewDBusMessage() *DBusMessage {
	var _cret *C.GDBusMessage // in

	_cret = C.g_dbus_message_new()

	var _dBusMessage *DBusMessage // out

	_dBusMessage = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusMessage)

	return _dBusMessage
}

// NewDBusMessageMethodCall creates a new BusMessage for a method call.
func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) *DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(method))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_dbus_message_new_method_call(_arg1, _arg2, _arg3, _arg4)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusMessage)

	return _dBusMessage
}

// NewDBusMessageSignal creates a new BusMessage for a signal emission.
func NewDBusMessageSignal(path string, interface_ string, signal string) *DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(signal))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_message_new_signal(_arg1, _arg2, _arg3)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusMessage)

	return _dBusMessage
}

// Copy copies @message. The copy is a deep copy and the returned BusMessage is
// completely identical except that it is guaranteed to not be locked.
//
// This operation can fail if e.g. @message contains file descriptors and the
// per-process or system-wide open files limit is reached.
func (message *DBusMessage) Copy() (*DBusMessage, error) {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_copy(_arg0, &_cerr)

	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_dBusMessage = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

// Arg0: convenience to get the first item in the body of @message.
func (message *DBusMessage) Arg0() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_arg0(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Body gets the body of a message.
func (message *DBusMessage) Body() *glib.Variant {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_body(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// ByteOrder gets the byte order of @message.
func (message *DBusMessage) ByteOrder() DBusMessageByteOrder {
	var _arg0 *C.GDBusMessage         // out
	var _cret C.GDBusMessageByteOrder // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_byte_order(_arg0)

	var _dBusMessageByteOrder DBusMessageByteOrder // out

	_dBusMessageByteOrder = (DBusMessageByteOrder)(_cret)

	return _dBusMessageByteOrder
}

// Destination: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (message *DBusMessage) Destination() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_destination(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ErrorName: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME
// header field.
func (message *DBusMessage) ErrorName() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_error_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Flags gets the flags for @message.
func (message *DBusMessage) Flags() DBusMessageFlags {
	var _arg0 *C.GDBusMessage     // out
	var _cret C.GDBusMessageFlags // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_flags(_arg0)

	var _dBusMessageFlags DBusMessageFlags // out

	_dBusMessageFlags = (DBusMessageFlags)(_cret)

	return _dBusMessageFlags
}

// HeaderFields gets an array of all header fields on @message that are set.
func (message *DBusMessage) HeaderFields() []byte {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.guchar

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_header_fields(_arg0)

	var _guint8s []byte

	{
		var i int
		var z C.guchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = byte(src[i])
		}
	}

	return _guint8s
}

// Interface: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE
// header field.
func (message *DBusMessage) Interface() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_interface(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Locked checks whether @message is locked. To monitor changes to this value,
// conncet to the #GObject::notify signal to listen for changes on the
// BusMessage:locked property.
func (message *DBusMessage) Locked() bool {
	var _arg0 *C.GDBusMessage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header
// field.
func (message *DBusMessage) Member() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_member(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// MessageType gets the type of @message.
func (message *DBusMessage) MessageType() DBusMessageType {
	var _arg0 *C.GDBusMessage    // out
	var _cret C.GDBusMessageType // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_message_type(_arg0)

	var _dBusMessageType DBusMessageType // out

	_dBusMessageType = (DBusMessageType)(_cret)

	return _dBusMessageType
}

// NumUnixFds: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (message *DBusMessage) NumUnixFds() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_num_unix_fds(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
func (message *DBusMessage) Path() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ReplySerial: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (message *DBusMessage) ReplySerial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_reply_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER header
// field.
func (message *DBusMessage) Sender() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Serial gets the serial for @message.
func (message *DBusMessage) Serial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Signature: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE
// header field.
func (message *DBusMessage) Signature() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_signature(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UnixFdList gets the UNIX file descriptors associated with @message, if any.
//
// This method is only available on UNIX.
//
// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values in
// the body of the message. For example, if g_variant_get_handle() returns 5,
// that is intended to be a reference to the file descriptor that can be
// accessed by `g_unix_fd_list_get (list, 5, ...)`.
func (message *DBusMessage) UnixFdList() *UnixFDList {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GUnixFDList  // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	_cret = C.g_dbus_message_get_unix_fd_list(_arg0)

	var _unixFDList *UnixFDList // out

	_unixFDList = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*UnixFDList)

	return _unixFDList
}

// Lock: if @message is locked, does nothing. Otherwise locks the message.
func (message *DBusMessage) Lock() {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	C.g_dbus_message_lock(_arg0)
}

// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
// @method_call_message.
func (methodCallMessage *DBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) *DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(methodCallMessage.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_message_new_method_error_literal(_arg0, _arg1, _arg2)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusMessage)

	return _dBusMessage
}

// NewMethodReply creates a new BusMessage that is a reply to
// @method_call_message.
func (methodCallMessage *DBusMessage) NewMethodReply() *DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(methodCallMessage.Native()))

	_cret = C.g_dbus_message_new_method_reply(_arg0)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DBusMessage)

	return _dBusMessage
}

// Print produces a human-readable multi-line description of @message.
//
// The contents of the description has no ABI guarantees, the contents and
// formatting is subject to change at any time. Typical output looks something
// like this:
//
//    Flags:   none
//    Version: 0
//    Serial:  4
//    Headers:
//      path -> objectpath '/org/gtk/GDBus/TestObject'
//      interface -> 'org.gtk.GDBus.TestInterface'
//      member -> 'GimmeStdout'
//      destination -> ':1.146'
//    Body: ()
//    UNIX File Descriptors:
//      (none)
//
// or
//
//    Flags:   no-reply-expected
//    Version: 0
//    Serial:  477
//    Headers:
//      reply-serial -> uint32 4
//      destination -> ':1.159'
//      sender -> ':1.146'
//      num-unix-fds -> uint32 1
//    Body: ()
//    UNIX File Descriptors:
//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
func (message *DBusMessage) Print(indent uint) string {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint         // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.guint(indent)

	_cret = C.g_dbus_message_print(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SetBody sets the body @message. As a side-effect the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type string
// of @body (or cleared if @body is nil).
//
// If @body is floating, @message assumes ownership of @body.
func (message *DBusMessage) SetBody(body *glib.Variant) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(body))

	C.g_dbus_message_set_body(_arg0, _arg1)
}

// SetDestination: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (message *DBusMessage) SetDestination(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_destination(_arg0, _arg1)
}

// SetErrorName: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (message *DBusMessage) SetErrorName(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_error_name(_arg0, _arg1)
}

// SetInterface: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (message *DBusMessage) SetInterface(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_interface(_arg0, _arg1)
}

// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
func (message *DBusMessage) SetMember(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_member(_arg0, _arg1)
}

// SetNumUnixFds: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (message *DBusMessage) SetNumUnixFds(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_num_unix_fds(_arg0, _arg1)
}

// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
func (message *DBusMessage) SetPath(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_path(_arg0, _arg1)
}

// SetReplySerial: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (message *DBusMessage) SetReplySerial(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_reply_serial(_arg0, _arg1)
}

// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
func (message *DBusMessage) SetSender(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_sender(_arg0, _arg1)
}

// SetSerial sets the serial for @message.
func (message *DBusMessage) SetSerial(serial uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = C.guint32(serial)

	C.g_dbus_message_set_serial(_arg0, _arg1)
}

// SetSignature: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
func (message *DBusMessage) SetSignature(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_signature(_arg0, _arg1)
}

// SetUnixFdList sets the UNIX file descriptors associated with @message. As a
// side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field is set
// to the number of fds in @fd_list (or cleared if @fd_list is nil).
//
// This method is only available on UNIX.
//
// When designing D-Bus APIs that are intended to be interoperable, please note
// that non-GDBus implementations of D-Bus can usually only access file
// descriptors if they are referenced by a value of type G_VARIANT_TYPE_HANDLE
// in the body of the message.
func (message *DBusMessage) SetUnixFdList(fdList UnixFDLister) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GUnixFDList  // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg1 = (*C.GUnixFDList)(unsafe.Pointer((fdList).(gextras.Nativer).Native()))

	C.g_dbus_message_set_unix_fd_list(_arg0, _arg1)
}

// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does nothing
// and returns false.
//
// Otherwise this method encodes the error in @message as a #GError using
// g_dbus_error_set_dbus_error() using the information in the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well as
// the first string item in @message's body.
func (message *DBusMessage) ToGerror() error {
	var _arg0 *C.GDBusMessage // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))

	C.g_dbus_message_to_gerror(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// DBusMethodInvocationer describes DBusMethodInvocation's methods.
type DBusMethodInvocationer interface {
	// Connection gets the BusConnection the method was invoked on.
	Connection() *DBusConnection
	// InterfaceName gets the name of the D-Bus interface the method was invoked
	// on.
	InterfaceName() string
	// Message gets the BusMessage for the method invocation.
	Message() *DBusMessage
	// MethodInfo gets information about the method call, if any.
	MethodInfo() *DBusMethodInfo
	// MethodName gets the name of the method that was invoked.
	MethodName() string
	// ObjectPath gets the object path the method was invoked on.
	ObjectPath() string
	// Parameters gets the parameters of the method invocation.
	Parameters() *glib.Variant
	// PropertyInfo gets information about the property that this method call is
	// for, if any.
	PropertyInfo() *DBusPropertyInfo
	// Sender gets the bus name that invoked the method.
	Sender() string
	// ReturnDBusError finishes handling a D-Bus method call by returning an
	// error.
	ReturnDBusError(errorName string, errorMessage string)
	// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
	// #GError instead of the error domain, error code and message.
	ReturnGerror(err error)
	// ReturnValue finishes handling a D-Bus method call by returning
	// @parameters.
	ReturnValue(parameters *glib.Variant)
	// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
	// but also takes a FDList.
	ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDLister)
}

// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation struct {
	*externglib.Object
}

var (
	_ DBusMethodInvocationer = (*DBusMethodInvocation)(nil)
	_ gextras.Nativer        = (*DBusMethodInvocation)(nil)
)

func wrapDBusMethodInvocation(obj *externglib.Object) DBusMethodInvocationer {
	return &DBusMethodInvocation{
		Object: obj,
	}
}

func marshalDBusMethodInvocationer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusMethodInvocation(obj), nil
}

// Connection gets the BusConnection the method was invoked on.
func (invocation *DBusMethodInvocation) Connection() *DBusConnection {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusConnection       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_connection(_arg0)

	var _dBusConnection *DBusConnection // out

	_dBusConnection = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*DBusConnection)

	return _dBusConnection
}

// InterfaceName gets the name of the D-Bus interface the method was invoked on.
//
// If this method call is a property Get, Set or GetAll call that has been
// redirected to the method call handler then "org.freedesktop.DBus.Properties"
// will be returned. See BusInterfaceVTable for more information.
func (invocation *DBusMethodInvocation) InterfaceName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_interface_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Message gets the BusMessage for the method invocation. This is useful if you
// need to use low-level protocol features, such as UNIX file descriptor
// passing, that cannot be properly expressed in the #GVariant API.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (invocation *DBusMethodInvocation) Message() *DBusMessage {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMessage          // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_message(_arg0)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*DBusMessage)

	return _dBusMessage
}

// MethodInfo gets information about the method call, if any.
//
// If this method invocation is a property Get, Set or GetAll call that has been
// redirected to the method call handler then nil will be returned. See
// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for more
// information.
func (invocation *DBusMethodInvocation) MethodInfo() *DBusMethodInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMethodInfo       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_method_info(_arg0)

	var _dBusMethodInfo *DBusMethodInfo // out

	_dBusMethodInfo = (*DBusMethodInfo)(unsafe.Pointer(_cret))
	C.g_dbus_method_info_ref(_cret)
	runtime.SetFinalizer(_dBusMethodInfo, func(v *DBusMethodInfo) {
		C.g_dbus_method_info_unref((*C.GDBusMethodInfo)(unsafe.Pointer(v)))
	})

	return _dBusMethodInfo
}

// MethodName gets the name of the method that was invoked.
func (invocation *DBusMethodInvocation) MethodName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_method_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ObjectPath gets the object path the method was invoked on.
func (invocation *DBusMethodInvocation) ObjectPath() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Parameters gets the parameters of the method invocation. If there are no
// input parameters then this will return a GVariant with 0 children rather than
// NULL.
func (invocation *DBusMethodInvocation) Parameters() *glib.Variant {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GVariant              // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_parameters(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// PropertyInfo gets information about the property that this method call is
// for, if any.
//
// This will only be set in the case of an invocation in response to a property
// Get or Set call that has been directed to the method call handler for an
// object on account of its property_get() or property_set() vtable pointers
// being unset.
//
// See BusInterfaceVTable for more information.
//
// If the call was GetAll, nil will be returned.
func (invocation *DBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusPropertyInfo     // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_property_info(_arg0)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	_dBusPropertyInfo = (*DBusPropertyInfo)(unsafe.Pointer(_cret))
	C.g_dbus_property_info_ref(_cret)
	runtime.SetFinalizer(_dBusPropertyInfo, func(v *DBusPropertyInfo) {
		C.g_dbus_property_info_unref((*C.GDBusPropertyInfo)(unsafe.Pointer(v)))
	})

	return _dBusPropertyInfo
}

// Sender gets the bus name that invoked the method.
func (invocation *DBusMethodInvocation) Sender() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))

	_cret = C.g_dbus_method_invocation_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ReturnDBusError finishes handling a D-Bus method call by returning an error.
//
// This method will take ownership of @invocation. See BusInterfaceVTable for
// more information about the ownership of @invocation.
func (invocation *DBusMethodInvocation) ReturnDBusError(errorName string, errorMessage string) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.gchar                 // out
	var _arg2 *C.gchar                 // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_dbus_method_invocation_return_dbus_error(_arg0, _arg1, _arg2)
}

// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
// #GError instead of the error domain, error code and message.
//
// This method will take ownership of @invocation. See BusInterfaceVTable for
// more information about the ownership of @invocation.
func (invocation *DBusMethodInvocation) ReturnGerror(err error) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GError                // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))
	_arg1 = (*C.GError)(gerror.New(err))

	C.g_dbus_method_invocation_return_gerror(_arg0, _arg1)
}

// ReturnValue finishes handling a D-Bus method call by returning @parameters.
// If the @parameters GVariant is floating, it is consumed.
//
// It is an error if @parameters is not of the right format: it must be a tuple
// containing the out-parameters of the D-Bus method. Even if the method has a
// single out-parameter, it must be contained in a tuple. If the method has no
// out-parameters, @parameters may be nil or an empty tuple.
//
//    GDBusMethodInvocation *invocation = some_invocation;
//    g_autofree gchar *result_string = NULL;
//    g_autoptr (GError) error = NULL;
//
//    result_string = calculate_result (&error);
//
//    if (error != NULL)
//      g_dbus_method_invocation_return_gerror (invocation, error);
//    else
//      g_dbus_method_invocation_return_value (invocation,
//                                             g_variant_new ("(s)", result_string));
//
//    // Do not free @invocation here; returning a value does that
//
// This method will take ownership of @invocation. See BusInterfaceVTable for
// more information about the ownership of @invocation.
//
// Since 2.48, if the method call requested for a reply not to be sent then this
// call will sink @parameters and free @invocation, but otherwise do nothing (as
// per the recommendations of the D-Bus specification).
func (invocation *DBusMethodInvocation) ReturnValue(parameters *glib.Variant) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters))

	C.g_dbus_method_invocation_return_value(_arg0, _arg1)
}

// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value() but
// also takes a FDList.
//
// This method is only available on UNIX.
//
// This method will take ownership of @invocation. See BusInterfaceVTable for
// more information about the ownership of @invocation.
func (invocation *DBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDLister) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out
	var _arg2 *C.GUnixFDList           // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(invocation.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters))
	_arg2 = (*C.GUnixFDList)(unsafe.Pointer((fdList).(gextras.Nativer).Native()))

	C.g_dbus_method_invocation_return_value_with_unix_fd_list(_arg0, _arg1, _arg2)
}

// DBusServerer describes DBusServer's methods.
type DBusServerer interface {
	// ClientAddress gets a D-Bus address
	// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
	// string that can be used by clients to connect to @server.
	ClientAddress() string
	// Flags gets the flags for @server.
	Flags() DBusServerFlags
	// Guid gets the GUID for @server.
	Guid() string
	// IsActive gets whether @server is active.
	IsActive() bool
	// Start starts @server.
	Start()
	// Stop stops @server.
	Stop()
}

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with GDBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer. Since GLib 2.68 this can be achieved more simply by
// passing the G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the
// server.
type DBusServer struct {
	*externglib.Object

	Initable
}

var (
	_ DBusServerer    = (*DBusServer)(nil)
	_ gextras.Nativer = (*DBusServer)(nil)
)

func wrapDBusServer(obj *externglib.Object) DBusServerer {
	return &DBusServer{
		Object: obj,
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusServerer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDBusServer(obj), nil
}

// ClientAddress gets a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses) string
// that can be used by clients to connect to @server.
func (server *DBusServer) ClientAddress() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	_cret = C.g_dbus_server_get_client_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Flags gets the flags for @server.
func (server *DBusServer) Flags() DBusServerFlags {
	var _arg0 *C.GDBusServer     // out
	var _cret C.GDBusServerFlags // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	_cret = C.g_dbus_server_get_flags(_arg0)

	var _dBusServerFlags DBusServerFlags // out

	_dBusServerFlags = (DBusServerFlags)(_cret)

	return _dBusServerFlags
}

// Guid gets the GUID for @server.
func (server *DBusServer) Guid() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	_cret = C.g_dbus_server_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsActive gets whether @server is active.
func (server *DBusServer) IsActive() bool {
	var _arg0 *C.GDBusServer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	_cret = C.g_dbus_server_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start starts @server.
func (server *DBusServer) Start() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	C.g_dbus_server_start(_arg0)
}

// Stop stops @server.
func (server *DBusServer) Stop() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(server.Native()))

	C.g_dbus_server_stop(_arg0)
}

// Menuer describes Menu's methods.
type Menuer interface {
	// Append: convenience function for appending a normal menu item to the end
	// of @menu.
	Append(label string, detailedAction string)
	// AppendItem appends @item to the end of @menu.
	AppendItem(item MenuItemmer)
	// AppendSection: convenience function for appending a section menu item to
	// the end of @menu.
	AppendSection(label string, section MenuModeller)
	// AppendSubmenu: convenience function for appending a submenu menu item to
	// the end of @menu.
	AppendSubmenu(label string, submenu MenuModeller)
	// Freeze marks @menu as frozen.
	Freeze()
	// Insert: convenience function for inserting a normal menu item into @menu.
	Insert(position int, label string, detailedAction string)
	// InsertItem inserts @item into @menu.
	InsertItem(position int, item MenuItemmer)
	// InsertSection: convenience function for inserting a section menu item
	// into @menu.
	InsertSection(position int, label string, section MenuModeller)
	// InsertSubmenu: convenience function for inserting a submenu menu item
	// into @menu.
	InsertSubmenu(position int, label string, submenu MenuModeller)
	// Prepend: convenience function for prepending a normal menu item to the
	// start of @menu.
	Prepend(label string, detailedAction string)
	// PrependItem prepends @item to the start of @menu.
	PrependItem(item MenuItemmer)
	// PrependSection: convenience function for prepending a section menu item
	// to the start of @menu.
	PrependSection(label string, section MenuModeller)
	// PrependSubmenu: convenience function for prepending a submenu menu item
	// to the start of @menu.
	PrependSubmenu(label string, submenu MenuModeller)
	// Remove removes an item from the menu.
	Remove(position int)
	// RemoveAll removes all items in the menu.
	RemoveAll()
}

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu struct {
	MenuModel
}

var (
	_ Menuer          = (*Menu)(nil)
	_ gextras.Nativer = (*Menu)(nil)
)

func wrapMenu(obj *externglib.Object) Menuer {
	return &Menu{
		MenuModel: MenuModel{
			Object: obj,
		},
	}
}

func marshalMenuer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapMenu(obj), nil
}

// NewMenu creates a new #GMenu.
//
// The new menu has no items.
func NewMenu() *Menu {
	var _cret *C.GMenu // in

	_cret = C.g_menu_new()

	var _menu *Menu // out

	_menu = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*Menu)

	return _menu
}

// Append: convenience function for appending a normal menu item to the end of
// @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (menu *Menu) Append(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_append(_arg0, _arg1, _arg2)
}

// AppendItem appends @item to the end of @menu.
//
// See g_menu_insert_item() for more information.
func (menu *Menu) AppendItem(item MenuItemmer) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer((item).(gextras.Nativer).Native()))

	C.g_menu_append_item(_arg0, _arg1)
}

// AppendSection: convenience function for appending a section menu item to the
// end of @menu. Combine g_menu_item_new_section() and g_menu_insert_item() for
// a more flexible alternative.
func (menu *Menu) AppendSection(label string, section MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer((section).(gextras.Nativer).Native()))

	C.g_menu_append_section(_arg0, _arg1, _arg2)
}

// AppendSubmenu: convenience function for appending a submenu menu item to the
// end of @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item() for
// a more flexible alternative.
func (menu *Menu) AppendSubmenu(label string, submenu MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer((submenu).(gextras.Nativer).Native()))

	C.g_menu_append_submenu(_arg0, _arg1, _arg2)
}

// Freeze marks @menu as frozen.
//
// After the menu is frozen, it is an error to attempt to make any changes to
// it. In effect this means that the #GMenu API must no longer be used.
//
// This function causes g_menu_model_is_mutable() to begin returning false,
// which has some positive performance implications.
func (menu *Menu) Freeze() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))

	C.g_menu_freeze(_arg0)
}

// Insert: convenience function for inserting a normal menu item into @menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (menu *Menu) Insert(position int, label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_menu_insert(_arg0, _arg1, _arg2, _arg3)
}

// InsertItem inserts @item into @menu.
//
// The "insertion" is actually done by copying all of the attribute and link
// values of @item and using them to form a new item within @menu. As such,
// @item itself is not really inserted, but rather, a menu item that is exactly
// the same as the one presently described by @item.
//
// This means that @item is essentially useless after the insertion occurs. Any
// changes you make to it are ignored unless it is inserted again (at which
// point its updated values will be copied).
//
// You should probably just free @item once you're done.
//
// There are many convenience functions to take care of common cases. See
// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as well
// as "prepend" and "append" variants of each of these functions.
func (menu *Menu) InsertItem(position int, item MenuItemmer) {
	var _arg0 *C.GMenu     // out
	var _arg1 C.gint       // out
	var _arg2 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.GMenuItem)(unsafe.Pointer((item).(gextras.Nativer).Native()))

	C.g_menu_insert_item(_arg0, _arg1, _arg2)
}

// InsertSection: convenience function for inserting a section menu item into
// @menu. Combine g_menu_item_new_section() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *Menu) InsertSection(position int, label string, section MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer((section).(gextras.Nativer).Native()))

	C.g_menu_insert_section(_arg0, _arg1, _arg2, _arg3)
}

// InsertSubmenu: convenience function for inserting a submenu menu item into
// @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *Menu) InsertSubmenu(position int, label string, submenu MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer((submenu).(gextras.Nativer).Native()))

	C.g_menu_insert_submenu(_arg0, _arg1, _arg2, _arg3)
}

// Prepend: convenience function for prepending a normal menu item to the start
// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *Menu) Prepend(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_prepend(_arg0, _arg1, _arg2)
}

// PrependItem prepends @item to the start of @menu.
//
// See g_menu_insert_item() for more information.
func (menu *Menu) PrependItem(item MenuItemmer) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer((item).(gextras.Nativer).Native()))

	C.g_menu_prepend_item(_arg0, _arg1)
}

// PrependSection: convenience function for prepending a section menu item to
// the start of @menu. Combine g_menu_item_new_section() and
// g_menu_insert_item() for a more flexible alternative.
func (menu *Menu) PrependSection(label string, section MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer((section).(gextras.Nativer).Native()))

	C.g_menu_prepend_section(_arg0, _arg1, _arg2)
}

// PrependSubmenu: convenience function for prepending a submenu menu item to
// the start of @menu. Combine g_menu_item_new_submenu() and
// g_menu_insert_item() for a more flexible alternative.
func (menu *Menu) PrependSubmenu(label string, submenu MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer((submenu).(gextras.Nativer).Native()))

	C.g_menu_prepend_submenu(_arg0, _arg1, _arg2)
}

// Remove removes an item from the menu.
//
// @position gives the index of the item to remove.
//
// It is an error if position is not in range the range from 0 to one less than
// the number of items in the menu.
//
// It is not possible to remove items by identity since items are added to the
// menu simply by copying their links and attributes (ie: identity of the item
// itself is not preserved).
func (menu *Menu) Remove(position int) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(position)

	C.g_menu_remove(_arg0, _arg1)
}

// RemoveAll removes all items in the menu.
func (menu *Menu) RemoveAll() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(menu.Native()))

	C.g_menu_remove_all(_arg0)
}

// MenuItemmer describes MenuItem's methods.
type MenuItemmer interface {
	// AttributeValue queries the named @attribute on @menu_item.
	AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant
	// Link queries the named @link on @menu_item.
	Link(link string) *MenuModel
	// SetActionAndTargetValue sets or unsets the "action" and "target"
	// attributes of @menu_item.
	SetActionAndTargetValue(action string, targetValue *glib.Variant)
	// SetAttributeValue sets or unsets an attribute on @menu_item.
	SetAttributeValue(attribute string, value *glib.Variant)
	// SetDetailedAction sets the "action" and possibly the "target" attribute
	// of @menu_item.
	SetDetailedAction(detailedAction string)
	// SetIcon sets (or unsets) the icon on @menu_item.
	SetIcon(icon Iconner)
	// SetLabel sets or unsets the "label" attribute of @menu_item.
	SetLabel(label string)
	// SetLink creates a link from @menu_item to @model if non-nil, or unsets
	// it.
	SetLink(link string, model MenuModeller)
	// SetSection sets or unsets the "section" link of @menu_item to @section.
	SetSection(section MenuModeller)
	// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
	SetSubmenu(submenu MenuModeller)
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem struct {
	*externglib.Object
}

var (
	_ MenuItemmer     = (*MenuItem)(nil)
	_ gextras.Nativer = (*MenuItem)(nil)
)

func wrapMenuItem(obj *externglib.Object) MenuItemmer {
	return &MenuItem{
		Object: obj,
	}
}

func marshalMenuItemmer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapMenuItem(obj), nil
}

// NewMenuItem creates a new Item.
//
// If @label is non-nil it is used to set the "label" attribute of the new item.
//
// If @detailed_action is non-nil it is used to set the "action" and possibly
// the "target" attribute of the new item. See g_menu_item_set_detailed_action()
// for more information.
func NewMenuItem(label string, detailedAction string) *MenuItem {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GMenuItem // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_menu_item_new(_arg1, _arg2)

	var _menuItem *MenuItem // out

	_menuItem = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*MenuItem)

	return _menuItem
}

// NewMenuItemFromModel creates a Item as an exact copy of an existing menu item
// in a Model.
//
// @item_index must be valid (ie: be sure to call g_menu_model_get_n_items()
// first).
func NewMenuItemFromModel(model MenuModeller, itemIndex int) *MenuItem {
	var _arg1 *C.GMenuModel // out
	var _arg2 C.gint        // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer((model).(gextras.Nativer).Native()))
	_arg2 = C.gint(itemIndex)

	_cret = C.g_menu_item_new_from_model(_arg1, _arg2)

	var _menuItem *MenuItem // out

	_menuItem = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*MenuItem)

	return _menuItem
}

// NewMenuItemSection creates a new Item representing a section.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_section().
//
// The effect of having one menu appear as a section of another is exactly as it
// sounds: the items from @section become a direct part of the menu that
// @menu_item is added to.
//
// Visual separation is typically displayed between two non-empty sections. If
// @label is non-nil then it will be encorporated into this visual indication.
// This allows for labeled subsections of a menu.
//
// As a simple example, consider a typical "Edit" menu from a simple program. It
// probably contains an "Undo" and "Redo" item, followed by a separator,
// followed by "Cut", "Copy" and "Paste".
//
// This would be accomplished by creating three #GMenu instances. The first
// would be populated with the "Undo" and "Redo" items, and the second with the
// "Cut", "Copy" and "Paste" items. The first and second menus would then be
// added as submenus of the third. In XML format, this would look something like
// the following:
//
//    <menu id='edit-menu'>
//      <section>
//        <item label='Undo'/>
//        <item label='Redo'/>
//      </section>
//      <section>
//        <item label='Cut'/>
//        <item label='Copy'/>
//        <item label='Paste'/>
//      </section>
//    </menu>
//
// The following example is exactly equivalent. It is more illustrative of the
// exact relationship between the menus and items (keeping in mind that the
// 'link' element defines a new menu that is linked to the containing one). The
// style of the second example is more verbose and difficult to read (and
// therefore not recommended except for the purpose of understanding what is
// really going on).
//
//    <menu id='edit-menu'>
//      <item>
//        <link name='section'>
//          <item label='Undo'/>
//          <item label='Redo'/>
//        </link>
//      </item>
//      <item>
//        <link name='section'>
//          <item label='Cut'/>
//          <item label='Copy'/>
//          <item label='Paste'/>
//        </link>
//      </item>
//    </menu>
func NewMenuItemSection(label string, section MenuModeller) *MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer((section).(gextras.Nativer).Native()))

	_cret = C.g_menu_item_new_section(_arg1, _arg2)

	var _menuItem *MenuItem // out

	_menuItem = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*MenuItem)

	return _menuItem
}

// NewMenuItemSubmenu creates a new Item representing a submenu.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_submenu().
func NewMenuItemSubmenu(label string, submenu MenuModeller) *MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer((submenu).(gextras.Nativer).Native()))

	_cret = C.g_menu_item_new_submenu(_arg1, _arg2)

	var _menuItem *MenuItem // out

	_menuItem = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*MenuItem)

	return _menuItem
}

// AttributeValue queries the named @attribute on @menu_item.
//
// If @expected_type is specified and the attribute does not have this type, nil
// is returned. nil is also returned if the attribute simply does not exist.
func (menuItem *MenuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _arg0 *C.GMenuItem    // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType))

	_cret = C.g_menu_item_get_attribute_value(_arg0, _arg1, _arg2)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// Link queries the named @link on @menu_item.
func (menuItem *MenuItem) Link(link string) *MenuModel {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_menu_item_get_link(_arg0, _arg1)

	var _menuModel *MenuModel // out

	_menuModel = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*MenuModel)

	return _menuModel
}

// SetActionAndTargetValue sets or unsets the "action" and "target" attributes
// of @menu_item.
//
// If @action is nil then both the "action" and "target" attributes are unset
// (and @target_value is ignored).
//
// If @action is non-nil then the "action" attribute is set. The "target"
// attribute is then set to the value of @target_value if it is non-nil or unset
// otherwise.
//
// Normal menu items (ie: not submenu, section or other custom item types) are
// expected to have the "action" attribute set to identify the action that they
// are associated with. The state type of the action help to determine the
// disposition of the menu item. See #GAction and Group for an overview of
// actions.
//
// In general, clicking on the menu item will result in activation of the named
// action with the "target" attribute given as the parameter to the action
// invocation. If the "target" attribute is not set then the action is invoked
// with no parameter.
//
// If the action has no state then the menu item is usually drawn as a plain
// menu item (ie: with no additional decoration).
//
// If the action has a boolean state then the menu item is usually drawn as a
// toggle menu item (ie: with a checkmark or equivalent indication). The item
// should be marked as 'toggled' or 'checked' when the boolean state is true.
//
// If the action has a string state then the menu item is usually drawn as a
// radio menu item (ie: with a radio bullet or equivalent indication). The item
// should be marked as 'selected' when the string state is equal to the value of
// the @target property.
//
// See g_menu_item_set_action_and_target() or g_menu_item_set_detailed_action()
// for two equivalent calls that are probably more convenient for most uses.
func (menuItem *MenuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(targetValue))

	C.g_menu_item_set_action_and_target_value(_arg0, _arg1, _arg2)
}

// SetAttributeValue sets or unsets an attribute on @menu_item.
//
// The attribute to set or unset is specified by @attribute. This can be one of
// the standard attribute names G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, or a custom attribute name. Attribute names are
// restricted to lowercase characters, numbers and '-'. Furthermore, the names
// must begin with a lowercase character, must not end with a '-', and must not
// contain consecutive dashes.
//
// must consist only of lowercase ASCII characters, digits and '-'.
//
// If @value is non-nil then it is used as the new value for the attribute. If
// @value is nil then the attribute is unset. If the @value #GVariant is
// floating, it is consumed.
//
// See also g_menu_item_set_attribute() for a more convenient way to do the
// same.
func (menuItem *MenuItem) SetAttributeValue(attribute string, value *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value))

	C.g_menu_item_set_attribute_value(_arg0, _arg1, _arg2)
}

// SetDetailedAction sets the "action" and possibly the "target" attribute of
// @menu_item.
//
// The format of @detailed_action is the same format parsed by
// g_action_parse_detailed_name().
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but slightly
// less convenient) alternatives.
//
// See also g_menu_item_set_action_and_target_value() for a description of the
// semantics of the action and target attributes.
func (menuItem *MenuItem) SetDetailedAction(detailedAction string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_detailed_action(_arg0, _arg1)
}

// SetIcon sets (or unsets) the icon on @menu_item.
//
// This call is the same as calling g_icon_serialize() and using the result as
// the value to g_menu_item_set_attribute_value() for G_MENU_ATTRIBUTE_ICON.
//
// This API is only intended for use with "noun" menu items; things like
// bookmarks or applications in an "Open With" menu. Don't use it on menu items
// corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
//
// If @icon is nil then the icon is unset.
func (menuItem *MenuItem) SetIcon(icon Iconner) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer((icon).(gextras.Nativer).Native()))

	C.g_menu_item_set_icon(_arg0, _arg1)
}

// SetLabel sets or unsets the "label" attribute of @menu_item.
//
// If @label is non-nil it is used as the label for the menu item. If it is nil
// then the label attribute is unset.
func (menuItem *MenuItem) SetLabel(label string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_label(_arg0, _arg1)
}

// SetLink creates a link from @menu_item to @model if non-nil, or unsets it.
//
// Links are used to establish a relationship between a particular menu item and
// another menu. For example, G_MENU_LINK_SUBMENU is used to associate a submenu
// with a particular menu item, and G_MENU_LINK_SECTION is used to create a
// section. Other types of link can be used, but there is no guarantee that
// clients will be able to make sense of them. Link types are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
func (menuItem *MenuItem) SetLink(link string, model MenuModeller) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer((model).(gextras.Nativer).Native()))

	C.g_menu_item_set_link(_arg0, _arg1, _arg2)
}

// SetSection sets or unsets the "section" link of @menu_item to @section.
//
// The effect of having one menu appear as a section of another is exactly as it
// sounds: the items from @section become a direct part of the menu that
// @menu_item is added to. See g_menu_item_new_section() for more information
// about what it means for a menu item to be a section.
func (menuItem *MenuItem) SetSection(section MenuModeller) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer((section).(gextras.Nativer).Native()))

	C.g_menu_item_set_section(_arg0, _arg1)
}

// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
//
// If @submenu is non-nil, it is linked to. If it is nil then the link is unset.
//
// The effect of having one menu appear as a submenu of another is exactly as it
// sounds.
func (menuItem *MenuItem) SetSubmenu(submenu MenuModeller) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(menuItem.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer((submenu).(gextras.Nativer).Native()))

	C.g_menu_item_set_submenu(_arg0, _arg1)
}

// Notificationer describes Notification's methods.
type Notificationer interface {
	// AddButton adds a button to @notification that activates the action in
	// @detailed_action when clicked.
	AddButton(label string, detailedAction string)
	// AddButtonWithTargetValue adds a button to @notification that activates
	// @action when clicked.
	AddButtonWithTargetValue(label string, action string, target *glib.Variant)
	// SetBody sets the body of @notification to @body.
	SetBody(body string)
	// SetDefaultAction sets the default action of @notification to
	// @detailed_action.
	SetDefaultAction(detailedAction string)
	// SetDefaultActionAndTargetValue sets the default action of @notification
	// to @action.
	SetDefaultActionAndTargetValue(action string, target *glib.Variant)
	// SetIcon sets the icon of @notification to @icon.
	SetIcon(icon Iconner)
	// SetTitle sets the title of @notification to @title.
	SetTitle(title string)
	// SetUrgent: deprecated in favor of g_notification_set_priority().
	SetUrgent(urgent bool)
}

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification struct {
	*externglib.Object
}

var (
	_ Notificationer  = (*Notification)(nil)
	_ gextras.Nativer = (*Notification)(nil)
)

func wrapNotification(obj *externglib.Object) Notificationer {
	return &Notification{
		Object: obj,
	}
}

func marshalNotificationer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapNotification(obj), nil
}

// NewNotification creates a new #GNotification with @title as its title.
//
// After populating @notification with more details, it can be sent to the
// desktop shell with g_application_send_notification(). Changing any properties
// after this call will not have any effect until resending @notification.
func NewNotification(title string) *Notification {
	var _arg1 *C.gchar         // out
	var _cret *C.GNotification // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_notification_new(_arg1)

	var _notification *Notification // out

	_notification = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*Notification)

	return _notification
}

// AddButton adds a button to @notification that activates the action in
// @detailed_action when clicked. That action must be an application-wide action
// (starting with "app."). If @detailed_action contains a target, the action
// will be activated with that target as its parameter.
//
// See g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
func (notification *Notification) AddButton(label string, detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_notification_add_button(_arg0, _arg1, _arg2)
}

// AddButtonWithTargetValue adds a button to @notification that activates
// @action when clicked. @action must be an application-wide action (it must
// start with "app.").
//
// If @target is non-nil, @action will be activated with @target as its
// parameter.
func (notification *Notification) AddButtonWithTargetValue(label string, action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariant)(unsafe.Pointer(target))

	C.g_notification_add_button_with_target_value(_arg0, _arg1, _arg2, _arg3)
}

// SetBody sets the body of @notification to @body.
func (notification *Notification) SetBody(body string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(C.CString(body))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_body(_arg0, _arg1)
}

// SetDefaultAction sets the default action of @notification to
// @detailed_action. This action is activated when the notification is clicked
// on.
//
// The action in @detailed_action must be an application-wide action (it must
// start with "app."). If @detailed_action contains a target, the given action
// will be activated with that target as its parameter. See
// g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
//
// When no default action is set, the application that the notification was sent
// on is activated.
func (notification *Notification) SetDefaultAction(detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_default_action(_arg0, _arg1)
}

// SetDefaultActionAndTargetValue sets the default action of @notification to
// @action. This action is activated when the notification is clicked on. It
// must be an application-wide action (start with "app.").
//
// If @target is non-nil, @action will be activated with @target as its
// parameter.
//
// When no default action is set, the application that the notification was sent
// on is activated.
func (notification *Notification) SetDefaultActionAndTargetValue(action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(target))

	C.g_notification_set_default_action_and_target_value(_arg0, _arg1, _arg2)
}

// SetIcon sets the icon of @notification to @icon.
func (notification *Notification) SetIcon(icon Iconner) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.GIcon         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer((icon).(gextras.Nativer).Native()))

	C.g_notification_set_icon(_arg0, _arg1)
}

// SetTitle sets the title of @notification to @title.
func (notification *Notification) SetTitle(title string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_title(_arg0, _arg1)
}

// SetUrgent: deprecated in favor of g_notification_set_priority().
//
// Deprecated: Since 2.42, this has been deprecated in favour of
// g_notification_set_priority().
func (notification *Notification) SetUrgent(urgent bool) {
	var _arg0 *C.GNotification // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(notification.Native()))
	if urgent {
		_arg1 = C.TRUE
	}

	C.g_notification_set_urgent(_arg0, _arg1)
}

// PropertyActioner describes PropertyAction's methods.
type PropertyActioner interface {
	privatePropertyAction()
}

// PropertyAction is a way to get a #GAction with a state value reflecting and
// controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction struct {
	*externglib.Object

	Action
}

var (
	_ PropertyActioner = (*PropertyAction)(nil)
	_ gextras.Nativer  = (*PropertyAction)(nil)
)

func wrapPropertyAction(obj *externglib.Object) PropertyActioner {
	return &PropertyAction{
		Object: obj,
		Action: Action{
			Object: obj,
		},
	}
}

func marshalPropertyActioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapPropertyAction(obj), nil
}

// NewPropertyAction creates a #GAction corresponding to the value of property
// @property_name on @object.
//
// The property must be existent and readable and writable (and not
// construct-only).
//
// This function takes a reference on @object and doesn't release it until the
// action is destroyed.
func NewPropertyAction(name string, object gextras.Objector, propertyName string) *PropertyAction {
	var _arg1 *C.gchar           // out
	var _arg2 C.gpointer         // out
	var _arg3 *C.gchar           // out
	var _cret *C.GPropertyAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gpointer)(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_property_action_new(_arg1, _arg2, _arg3)

	var _propertyAction *PropertyAction // out

	_propertyAction = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*PropertyAction)

	return _propertyAction
}

func (*PropertyAction) privatePropertyAction() {}

// SimpleActioner describes SimpleAction's methods.
type SimpleActioner interface {
	// SetEnabled sets the action as enabled or not.
	SetEnabled(enabled bool)
	// SetState sets the state of the action.
	SetState(value *glib.Variant)
	// SetStateHint sets the state hint for the action.
	SetStateHint(stateHint *glib.Variant)
}

// SimpleAction is the obvious simple implementation of the #GAction interface.
// This is the easiest way to create an action for purposes of adding it to a
// ActionGroup.
//
// See also Action.
type SimpleAction struct {
	*externglib.Object

	Action
}

var (
	_ SimpleActioner  = (*SimpleAction)(nil)
	_ gextras.Nativer = (*SimpleAction)(nil)
)

func wrapSimpleAction(obj *externglib.Object) SimpleActioner {
	return &SimpleAction{
		Object: obj,
		Action: Action{
			Object: obj,
		},
	}
}

func marshalSimpleActioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSimpleAction(obj), nil
}

// NewSimpleAction creates a new action.
//
// The created action is stateless. See g_simple_action_new_stateful() to create
// an action that has state.
func NewSimpleAction(name string, parameterType *glib.VariantType) *SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType))

	_cret = C.g_simple_action_new(_arg1, _arg2)

	var _simpleAction *SimpleAction // out

	_simpleAction = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*SimpleAction)

	return _simpleAction
}

// NewSimpleActionStateful creates a new stateful action.
//
// All future state values must have the same Type as the initial @state.
//
// If the @state #GVariant is floating, it is consumed.
func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) *SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _arg3 *C.GVariant      // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType))
	_arg3 = (*C.GVariant)(unsafe.Pointer(state))

	_cret = C.g_simple_action_new_stateful(_arg1, _arg2, _arg3)

	var _simpleAction *SimpleAction // out

	_simpleAction = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*SimpleAction)

	return _simpleAction
}

// SetEnabled sets the action as enabled or not.
//
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to modify its enabled flag.
func (simple *SimpleAction) SetEnabled(enabled bool) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(simple.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.g_simple_action_set_enabled(_arg0, _arg1)
}

// SetState sets the state of the action.
//
// This directly updates the 'state' property to the given value.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to directly modify the 'state' property. Instead,
// they should call g_action_change_state() to request the change.
//
// If the @value GVariant is floating, it is consumed.
func (simple *SimpleAction) SetState(value *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(simple.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value))

	C.g_simple_action_set_state(_arg0, _arg1)
}

// SetStateHint sets the state hint for the action.
//
// See g_action_get_state_hint() for more information about action state hints.
func (simple *SimpleAction) SetStateHint(stateHint *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(simple.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(stateHint))

	C.g_simple_action_set_state_hint(_arg0, _arg1)
}

// SimpleIOStreamer describes SimpleIOStream's methods.
type SimpleIOStreamer interface {
	privateSimpleIOStream()
}

// SimpleIOStream creates a OStream from an arbitrary Stream and Stream. This
// allows any pair of input and output streams to be used with OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream struct {
	IOStream
}

var (
	_ SimpleIOStreamer = (*SimpleIOStream)(nil)
	_ gextras.Nativer  = (*SimpleIOStream)(nil)
)

func wrapSimpleIOStream(obj *externglib.Object) SimpleIOStreamer {
	return &SimpleIOStream{
		IOStream: IOStream{
			Object: obj,
		},
	}
}

func marshalSimpleIOStreamer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSimpleIOStream(obj), nil
}

// NewSimpleIOStream creates a new IOStream wrapping @input_stream and
// @output_stream. See also OStream.
func NewSimpleIOStream(inputStream InputStreamer, outputStream OutputStreamer) *SimpleIOStream {
	var _arg1 *C.GInputStream  // out
	var _arg2 *C.GOutputStream // out
	var _cret *C.GIOStream     // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer((inputStream).(gextras.Nativer).Native()))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer((outputStream).(gextras.Nativer).Native()))

	_cret = C.g_simple_io_stream_new(_arg1, _arg2)

	var _simpleIOStream *SimpleIOStream // out

	_simpleIOStream = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*SimpleIOStream)

	return _simpleIOStream
}

func (*SimpleIOStream) privateSimpleIOStream() {}

// SimplePermissioner describes SimplePermission's methods.
type SimplePermissioner interface {
	privateSimplePermission()
}

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission struct {
	Permission
}

var (
	_ SimplePermissioner = (*SimplePermission)(nil)
	_ gextras.Nativer    = (*SimplePermission)(nil)
)

func wrapSimplePermission(obj *externglib.Object) SimplePermissioner {
	return &SimplePermission{
		Permission: Permission{
			Object: obj,
		},
	}
}

func marshalSimplePermissioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSimplePermission(obj), nil
}

// NewSimplePermission creates a new #GPermission instance that represents an
// action that is either always or never allowed.
func NewSimplePermission(allowed bool) *SimplePermission {
	var _arg1 C.gboolean     // out
	var _cret *C.GPermission // in

	if allowed {
		_arg1 = C.TRUE
	}

	_cret = C.g_simple_permission_new(_arg1)

	var _simplePermission *SimplePermission // out

	_simplePermission = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*SimplePermission)

	return _simplePermission
}

func (*SimplePermission) privateSimplePermission() {}

// Subprocesser describes Subprocess's methods.
type Subprocesser interface {
	// CommunicateUTF8: like g_subprocess_communicate(), but validates the
	// output of the process as UTF-8, and returns it as a regular NUL
	// terminated string.
	CommunicateUTF8(stdinBuf string, cancellable Cancellabler) (stdoutBuf string, stderrBuf string, goerr error)
	// CommunicateUTF8Async asynchronous version of
	// g_subprocess_communicate_utf8().
	CommunicateUTF8Async(stdinBuf string, cancellable Cancellabler, callback AsyncReadyCallback)
	// CommunicateUTF8Finish: complete an invocation of
	// g_subprocess_communicate_utf8_async().
	CommunicateUTF8Finish(result AsyncResulter) (stdoutBuf string, stderrBuf string, goerr error)
	// ForceExit: use an operating-system specific method to attempt an
	// immediate, forceful termination of the process.
	ForceExit()
	// ExitStatus: check the exit status of the subprocess, given that it exited
	// normally.
	ExitStatus() int
	// Identifier: on UNIX, returns the process ID as a decimal string.
	Identifier() string
	// IfExited: check if the given subprocess exited normally (ie: by way of
	// exit() or return from main()).
	IfExited() bool
	// IfSignaled: check if the given subprocess terminated in response to a
	// signal.
	IfSignaled() bool
	// Status gets the raw status code of the process, as from waitpid().
	Status() int
	// StderrPipe gets the Stream from which to read the stderr output of
	// @subprocess.
	StderrPipe() *InputStream
	// StdinPipe gets the Stream that you can write to in order to give data to
	// the stdin of @subprocess.
	StdinPipe() *OutputStream
	// StdoutPipe gets the Stream from which to read the stdout output of
	// @subprocess.
	StdoutPipe() *InputStream
	// Successful checks if the process was "successful".
	Successful() bool
	// TermSig: get the signal number that caused the subprocess to terminate,
	// given that it terminated due to a signal.
	TermSig() int
	// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
	// still running.
	SendSignal(signalNum int)
	// Wait: synchronously wait for the subprocess to terminate.
	Wait(cancellable Cancellabler) error
	// WaitAsync: wait for the subprocess to terminate.
	WaitAsync(cancellable Cancellabler, callback AsyncReadyCallback)
	// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
	WaitCheck(cancellable Cancellabler) error
	// WaitCheckAsync combines g_subprocess_wait_async() with
	// g_spawn_check_exit_status().
	WaitCheckAsync(cancellable Cancellabler, callback AsyncReadyCallback)
	// WaitCheckFinish collects the result of a previous call to
	// g_subprocess_wait_check_async().
	WaitCheckFinish(result AsyncResulter) error
	// WaitFinish collects the result of a previous call to
	// g_subprocess_wait_async().
	WaitFinish(result AsyncResulter) error
}

// Subprocess allows the creation of and interaction with child processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess struct {
	*externglib.Object

	Initable
}

var (
	_ Subprocesser    = (*Subprocess)(nil)
	_ gextras.Nativer = (*Subprocess)(nil)
)

func wrapSubprocess(obj *externglib.Object) Subprocesser {
	return &Subprocess{
		Object: obj,
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalSubprocesser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSubprocess(obj), nil
}

// CommunicateUTF8: like g_subprocess_communicate(), but validates the output of
// the process as UTF-8, and returns it as a regular NUL terminated string.
//
// On error, @stdout_buf and @stderr_buf will be set to undefined values and
// should not be used.
func (subprocess *Subprocess) CommunicateUTF8(stdinBuf string, cancellable Cancellabler) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.char         // out
	var _arg2 *C.GCancellable // out
	var _arg3 *C.char         // in
	var _arg4 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.char)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))

	C.g_subprocess_communicate_utf8(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_stderrBuf = C.GoString(_arg4)
	defer C.free(unsafe.Pointer(_arg4))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

// CommunicateUTF8Async asynchronous version of g_subprocess_communicate_utf8().
// Complete invocation with g_subprocess_communicate_utf8_finish().
func (subprocess *Subprocess) CommunicateUTF8Async(stdinBuf string, cancellable Cancellabler, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.char               // out
	var _arg2 *C.GCancellable       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.char)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))
	_arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg4 = C.gpointer(box.Assign(callback))

	C.g_subprocess_communicate_utf8_async(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// CommunicateUTF8Finish: complete an invocation of
// g_subprocess_communicate_utf8_async().
func (subprocess *Subprocess) CommunicateUTF8Finish(result AsyncResulter) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _arg3 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	C.g_subprocess_communicate_utf8_finish(_arg0, _arg1, &_arg2, &_arg3, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_stderrBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

// ForceExit: use an operating-system specific method to attempt an immediate,
// forceful termination of the process. There is no mechanism to determine
// whether or not the request itself was successful; however, you can use
// g_subprocess_wait() to monitor the status of the process after calling this
// function.
//
// On Unix, this function sends SIGKILL.
func (subprocess *Subprocess) ForceExit() {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	C.g_subprocess_force_exit(_arg0)
}

// ExitStatus: check the exit status of the subprocess, given that it exited
// normally. This is the value passed to the exit() system call or the return
// value from main.
//
// This is equivalent to the system WEXITSTATUS macro.
//
// It is an error to call this function before g_subprocess_wait() and unless
// g_subprocess_get_if_exited() returned true.
func (subprocess *Subprocess) ExitStatus() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_exit_status(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Identifier: on UNIX, returns the process ID as a decimal string. On Windows,
// returns the result of GetProcessId() also as a string. If the subprocess has
// terminated, this will return nil.
func (subprocess *Subprocess) Identifier() string {
	var _arg0 *C.GSubprocess // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_identifier(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IfExited: check if the given subprocess exited normally (ie: by way of exit()
// or return from main()).
//
// This is equivalent to the system WIFEXITED macro.
//
// It is an error to call this function before g_subprocess_wait() has returned.
func (subprocess *Subprocess) IfExited() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_if_exited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IfSignaled: check if the given subprocess terminated in response to a signal.
//
// This is equivalent to the system WIFSIGNALED macro.
//
// It is an error to call this function before g_subprocess_wait() has returned.
func (subprocess *Subprocess) IfSignaled() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_if_signaled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Status gets the raw status code of the process, as from waitpid().
//
// This value has no particular meaning, but it can be used with the macros
// defined by the system headers such as WIFEXITED. It can also be used with
// g_spawn_check_exit_status().
//
// It is more likely that you want to use g_subprocess_get_if_exited() followed
// by g_subprocess_get_exit_status().
//
// It is an error to call this function before g_subprocess_wait() has returned.
func (subprocess *Subprocess) Status() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_status(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// StderrPipe gets the Stream from which to read the stderr output of
// @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE,
// otherwise nil will be returned.
func (subprocess *Subprocess) StderrPipe() *InputStream {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_stderr_pipe(_arg0)

	var _inputStream *InputStream // out

	_inputStream = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*InputStream)

	return _inputStream
}

// StdinPipe gets the Stream that you can write to in order to give data to the
// stdin of @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE and not
// G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise nil will be returned.
func (subprocess *Subprocess) StdinPipe() *OutputStream {
	var _arg0 *C.GSubprocess   // out
	var _cret *C.GOutputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_stdin_pipe(_arg0)

	var _outputStream *OutputStream // out

	_outputStream = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*OutputStream)

	return _outputStream
}

// StdoutPipe gets the Stream from which to read the stdout output of
// @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// otherwise nil will be returned.
func (subprocess *Subprocess) StdoutPipe() *InputStream {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_stdout_pipe(_arg0)

	var _inputStream *InputStream // out

	_inputStream = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*InputStream)

	return _inputStream
}

// Successful checks if the process was "successful". A process is considered
// successful if it exited cleanly with an exit status of 0, either by way of
// the exit() system call or return from main().
//
// It is an error to call this function before g_subprocess_wait() has returned.
func (subprocess *Subprocess) Successful() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_successful(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TermSig: get the signal number that caused the subprocess to terminate, given
// that it terminated due to a signal.
//
// This is equivalent to the system WTERMSIG macro.
//
// It is an error to call this function before g_subprocess_wait() and unless
// g_subprocess_get_if_signaled() returned true.
func (subprocess *Subprocess) TermSig() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))

	_cret = C.g_subprocess_get_term_sig(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
// still running.
//
// This API is race-free. If the subprocess has terminated, it will not be
// signalled.
//
// This API is not available on Windows.
func (subprocess *Subprocess) SendSignal(signalNum int) {
	var _arg0 *C.GSubprocess // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = C.gint(signalNum)

	C.g_subprocess_send_signal(_arg0, _arg1)
}

// Wait: synchronously wait for the subprocess to terminate.
//
// After the process terminates you can query its exit status with functions
// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
//
// This function does not fail in the case of the subprocess having abnormal
// termination. See g_subprocess_wait_check() for that.
//
// Cancelling @cancellable doesn't kill the subprocess. Call
// g_subprocess_force_exit() if it is desirable.
func (subprocess *Subprocess) Wait(cancellable Cancellabler) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))

	C.g_subprocess_wait(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// WaitAsync: wait for the subprocess to terminate.
//
// This is the asynchronous version of g_subprocess_wait().
func (subprocess *Subprocess) WaitAsync(cancellable Cancellabler, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_subprocess_wait_async(_arg0, _arg1, _arg2, _arg3)
}

// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
func (subprocess *Subprocess) WaitCheck(cancellable Cancellabler) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))

	C.g_subprocess_wait_check(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// WaitCheckAsync combines g_subprocess_wait_async() with
// g_spawn_check_exit_status().
//
// This is the asynchronous version of g_subprocess_wait_check().
func (subprocess *Subprocess) WaitCheckAsync(cancellable Cancellabler, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer((cancellable).(gextras.Nativer).Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_subprocess_wait_check_async(_arg0, _arg1, _arg2, _arg3)
}

// WaitCheckFinish collects the result of a previous call to
// g_subprocess_wait_check_async().
func (subprocess *Subprocess) WaitCheckFinish(result AsyncResulter) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	C.g_subprocess_wait_check_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// WaitFinish collects the result of a previous call to
// g_subprocess_wait_async().
func (subprocess *Subprocess) WaitFinish(result AsyncResulter) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(subprocess.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	C.g_subprocess_wait_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SubprocessLauncherer describes SubprocessLauncher's methods.
type SubprocessLauncherer interface {
	// Close closes all the file descriptors previously passed to the object
	// with g_subprocess_launcher_take_fd(),
	// g_subprocess_launcher_take_stderr_fd(), etc.
	Close()
	// Env returns the value of the environment variable @variable in the
	// environment of processes launched from this launcher.
	env(variable string) string
	// SetCwd sets the current working directory that processes will be launched
	// with.
	SetCwd(cwd string)
	// SetEnviron: replace the entire environment of processes launched from
	// this launcher with the given 'environ' variable.
	SetEnviron(env []string)
	// SetStderrFilePath sets the file path to use as the stderr for spawned
	// processes.
	SetStderrFilePath(path string)
	// SetStdinFilePath sets the file path to use as the stdin for spawned
	// processes.
	SetStdinFilePath(path string)
	// SetStdoutFilePath sets the file path to use as the stdout for spawned
	// processes.
	SetStdoutFilePath(path string)
	// Setenv sets the environment variable @variable in the environment of
	// processes launched from this launcher.
	Setenv(variable string, value string, overwrite bool)
	// Spawnv creates a #GSubprocess given a provided array of arguments.
	Spawnv(argv []string) (*Subprocess, error)
	// TakeFd: transfer an arbitrary file descriptor from parent process to the
	// child.
	TakeFd(sourceFd int, targetFd int)
	// TakeStderrFd sets the file descriptor to use as the stderr for spawned
	// processes.
	TakeStderrFd(fd int)
	// TakeStdinFd sets the file descriptor to use as the stdin for spawned
	// processes.
	TakeStdinFd(fd int)
	// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
	// processes.
	TakeStdoutFd(fd int)
	// Unsetenv removes the environment variable @variable from the environment
	// of processes launched from this launcher.
	Unsetenv(variable string)
}

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher struct {
	*externglib.Object
}

var (
	_ SubprocessLauncherer = (*SubprocessLauncher)(nil)
	_ gextras.Nativer      = (*SubprocessLauncher)(nil)
)

func wrapSubprocessLauncher(obj *externglib.Object) SubprocessLauncherer {
	return &SubprocessLauncher{
		Object: obj,
	}
}

func marshalSubprocessLauncherer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSubprocessLauncher(obj), nil
}

// Close closes all the file descriptors previously passed to the object with
// g_subprocess_launcher_take_fd(), g_subprocess_launcher_take_stderr_fd(), etc.
//
// After calling this method, any subsequent calls to
// g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will return
// G_IO_ERROR_CLOSED. This method is idempotent if called more than once.
//
// This function is called automatically when the Launcher is disposed, but is
// provided separately so that garbage collected language bindings can call it
// earlier to guarantee when FDs are closed.
func (self *SubprocessLauncher) Close() {
	var _arg0 *C.GSubprocessLauncher // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))

	C.g_subprocess_launcher_close(_arg0)
}

// Env returns the value of the environment variable @variable in the
// environment of processes launched from this launcher.
//
// On UNIX, the returned string can be an arbitrary byte string. On Windows, it
// will be UTF-8.
func (self *SubprocessLauncher) env(variable string) string {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_subprocess_launcher_getenv(_arg0, _arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// SetCwd sets the current working directory that processes will be launched
// with.
//
// By default processes are launched with the current working directory of the
// launching process at the time of launch.
func (self *SubprocessLauncher) SetCwd(cwd string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(C.CString(cwd))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_cwd(_arg0, _arg1)
}

// SetEnviron: replace the entire environment of processes launched from this
// launcher with the given 'environ' variable.
//
// Typically you will build this variable by using g_listenv() to copy the
// process 'environ' and using the functions g_environ_setenv(),
// g_environ_unsetenv(), etc.
//
// As an alternative, you can use g_subprocess_launcher_setenv(),
// g_subprocess_launcher_unsetenv(), etc.
//
// Pass an empty array to set an empty environment. Pass nil to inherit the
// parent processâ€™ environment. As of GLib 2.54, the parent processâ€™ environment
// will be copied when g_subprocess_launcher_set_environ() is called.
// Previously, it was copied when the subprocess was executed. This means the
// copied environment may now be modified (using g_subprocess_launcher_setenv(),
// etc.) before launching the subprocess.
//
// On UNIX, all strings in this array can be arbitrary byte strings. On Windows,
// they should be in UTF-8.
func (self *SubprocessLauncher) SetEnviron(env []string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(env)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(env))
		for i := range env {
			out[i] = (*C.gchar)(C.CString(env[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_subprocess_launcher_set_environ(_arg0, _arg1)
}

// SetStderrFilePath sets the file path to use as the stderr for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as would
// be the case if using '2>' at the shell.
//
// If you want to send both stdout and stderr to the same file then use
// G_SUBPROCESS_FLAGS_STDERR_MERGE.
//
// You may not set a stderr file path if a stderr fd is already set or if the
// launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) SetStderrFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stderr_file_path(_arg0, _arg1)
}

// SetStdinFilePath sets the file path to use as the stdin for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file must exist or spawning the process will fail.
//
// You may not set a stdin file path if a stdin fd is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) SetStdinFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdin_file_path(_arg0, _arg1)
}

// SetStdoutFilePath sets the file path to use as the stdout for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as would
// be the case if using '>' at the shell.
//
// You may not set a stdout file path if a stdout fd is already set or if the
// launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) SetStdoutFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdout_file_path(_arg0, _arg1)
}

// Setenv sets the environment variable @variable in the environment of
// processes launched from this launcher.
//
// On UNIX, both the variable's name and value can be arbitrary byte strings,
// except that the variable's name cannot contain '='. On Windows, they should
// be in UTF-8.
func (self *SubprocessLauncher) Setenv(variable string, value string, overwrite bool) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 C.gboolean             // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))
	if overwrite {
		_arg3 = C.TRUE
	}

	C.g_subprocess_launcher_setenv(_arg0, _arg1, _arg2, _arg3)
}

// Spawnv creates a #GSubprocess given a provided array of arguments.
func (self *SubprocessLauncher) Spawnv(argv []string) (*Subprocess, error) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar
	var _cret *C.GSubprocess // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_subprocess_launcher_spawnv(_arg0, _arg1, &_cerr)

	var _subprocess *Subprocess // out
	var _goerr error            // out

	_subprocess = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*Subprocess)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _subprocess, _goerr
}

// TakeFd: transfer an arbitrary file descriptor from parent process to the
// child. This function takes ownership of the @source_fd; it will be closed in
// the parent when @self is freed.
//
// By default, all file descriptors from the parent will be closed. This
// function allows you to create (for example) a custom `pipe()` or
// `socketpair()` before launching the process, and choose the target descriptor
// in the child.
//
// An example use case is GNUPG, which has a command line argument
// `--passphrase-fd` providing a file descriptor number where it expects the
// passphrase to be written.
func (self *SubprocessLauncher) TakeFd(sourceFd int, targetFd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out
	var _arg2 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(sourceFd)
	_arg2 = C.gint(targetFd)

	C.g_subprocess_launcher_take_fd(_arg0, _arg1, _arg2)
}

// TakeStderrFd sets the file descriptor to use as the stderr for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stderr through to the stderr of
// the parent process.
//
// The passed @fd belongs to the Launcher. It will be automatically closed when
// the launcher is finalized. The file descriptor will also be closed on the
// child side when executing the spawned process.
//
// You may not set a stderr fd if a stderr file path is already set or if the
// launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) TakeStderrFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stderr_fd(_arg0, _arg1)
}

// TakeStdinFd sets the file descriptor to use as the stdin for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that if your intention is to have the stdin of the calling process
// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better way
// to go about doing that.
//
// The passed @fd is noted but will not be touched in the current process. It is
// therefore necessary that it be kept open by the caller until the subprocess
// is spawned. The file descriptor will also not be explicitly closed on the
// child side, so it must be marked O_CLOEXEC if that's what you want.
//
// You may not set a stdin fd if a stdin file path is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) TakeStdinFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdin_fd(_arg0, _arg1)
}

// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stdout through to the stdout of
// the parent process.
//
// The passed @fd is noted but will not be touched in the current process. It is
// therefore necessary that it be kept open by the caller until the subprocess
// is spawned. The file descriptor will also not be explicitly closed on the
// child side, so it must be marked O_CLOEXEC if that's what you want.
//
// You may not set a stdout fd if a stdout file path is already set or if the
// launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (self *SubprocessLauncher) TakeStdoutFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdout_fd(_arg0, _arg1)
}

// Unsetenv removes the environment variable @variable from the environment of
// processes launched from this launcher.
//
// On UNIX, the variable's name can be an arbitrary byte string not containing
// '='. On Windows, it should be in UTF-8.
func (self *SubprocessLauncher) Unsetenv(variable string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_unsetenv(_arg0, _arg1)
}

// TestDBusser describes TestDBus's methods.
type TestDBusser interface {
	// AddServiceDir: add a path where dbus-daemon will look up .service files.
	AddServiceDir(path string)
	// Down: stop the session bus started by g_test_dbus_up().
	Down()
	// BusAddress: get the address on which dbus-daemon is running.
	BusAddress() string
	// Flags: get the flags of the DBus object.
	Flags() TestDBusFlags
	// Stop the session bus started by g_test_dbus_up().
	Stop()
	// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS.
	Up()
}

// TestDBus: helper class for testing code which uses D-Bus without touching the
// user's session bus.
//
// Note that DBus modifies the userâ€™s environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
//
//    [D-BUS Service]
//    Name=org.gtk.GDBus.Examples.ObjectManager
//    Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//
// You will also need to indicate this service directory in your test fixtures,
// so you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as:
//
//       -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//
//    Once you have a service definition file which is local to your source tree,
//
// you can proceed to set up a GTest fixture using the DBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found here:
// gdbus-test-fixture.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your
// schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas:
//
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
type TestDBus struct {
	*externglib.Object
}

var (
	_ TestDBusser     = (*TestDBus)(nil)
	_ gextras.Nativer = (*TestDBus)(nil)
)

func wrapTestDBus(obj *externglib.Object) TestDBusser {
	return &TestDBus{
		Object: obj,
	}
}

func marshalTestDBusser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTestDBus(obj), nil
}

// AddServiceDir: add a path where dbus-daemon will look up .service files. This
// can't be called after g_test_dbus_up().
func (self *TestDBus) AddServiceDir(path string) {
	var _arg0 *C.GTestDBus // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_test_dbus_add_service_dir(_arg0, _arg1)
}

// Down: stop the session bus started by g_test_dbus_up().
//
// This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
// to be destroyed. This is done to ensure that the next unit test won't get a
// leaked singleton from this test.
func (self *TestDBus) Down() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	C.g_test_dbus_down(_arg0)
}

// BusAddress: get the address on which dbus-daemon is running. If
// g_test_dbus_up() has not been called yet, nil is returned. This can be used
// with g_dbus_connection_new_for_address().
func (self *TestDBus) BusAddress() string {
	var _arg0 *C.GTestDBus // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	_cret = C.g_test_dbus_get_bus_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Flags: get the flags of the DBus object.
func (self *TestDBus) Flags() TestDBusFlags {
	var _arg0 *C.GTestDBus     // out
	var _cret C.GTestDBusFlags // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	_cret = C.g_test_dbus_get_flags(_arg0)

	var _testDBusFlags TestDBusFlags // out

	_testDBusFlags = (TestDBusFlags)(_cret)

	return _testDBusFlags
}

// Stop the session bus started by g_test_dbus_up().
//
// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests wanting
// to verify behaviour after the session bus has been stopped can use this
// function but should still call g_test_dbus_down() when done.
func (self *TestDBus) Stop() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	C.g_test_dbus_stop(_arg0)
}

// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
// call, it is safe for unit tests to start sending messages on the session bus.
//
// If this function is called from setup callback of g_test_add(),
// g_test_dbus_down() must be called in its teardown callback.
//
// If this function is called from unit test's main(), then g_test_dbus_down()
// must be called after g_test_run().
func (self *TestDBus) Up() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(self.Native()))

	C.g_test_dbus_up(_arg0)
}
