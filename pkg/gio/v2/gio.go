// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_bus_type_get_type()), F: marshalBusType},
		{T: externglib.Type(C.g_converter_result_get_type()), F: marshalConverterResult},
		{T: externglib.Type(C.g_credentials_type_get_type()), F: marshalCredentialsType},
		{T: externglib.Type(C.g_dbus_error_get_type()), F: marshalDBusError},
		{T: externglib.Type(C.g_dbus_message_byte_order_get_type()), F: marshalDBusMessageByteOrder},
		{T: externglib.Type(C.g_dbus_message_header_field_get_type()), F: marshalDBusMessageHeaderField},
		{T: externglib.Type(C.g_dbus_message_type_get_type()), F: marshalDBusMessageType},
		{T: externglib.Type(C.g_data_stream_byte_order_get_type()), F: marshalDataStreamByteOrder},
		{T: externglib.Type(C.g_data_stream_newline_type_get_type()), F: marshalDataStreamNewlineType},
		{T: externglib.Type(C.g_drive_start_stop_type_get_type()), F: marshalDriveStartStopType},
		{T: externglib.Type(C.g_emblem_origin_get_type()), F: marshalEmblemOrigin},
		{T: externglib.Type(C.g_file_attribute_status_get_type()), F: marshalFileAttributeStatus},
		{T: externglib.Type(C.g_file_attribute_type_get_type()), F: marshalFileAttributeType},
		{T: externglib.Type(C.g_file_monitor_event_get_type()), F: marshalFileMonitorEvent},
		{T: externglib.Type(C.g_file_type_get_type()), F: marshalFileType},
		{T: externglib.Type(C.g_filesystem_preview_type_get_type()), F: marshalFilesystemPreviewType},
		{T: externglib.Type(C.g_io_error_enum_get_type()), F: marshalIOErrorEnum},
		{T: externglib.Type(C.g_io_module_scope_flags_get_type()), F: marshalIOModuleScopeFlags},
		{T: externglib.Type(C.g_memory_monitor_warning_level_get_type()), F: marshalMemoryMonitorWarningLevel},
		{T: externglib.Type(C.g_mount_operation_result_get_type()), F: marshalMountOperationResult},
		{T: externglib.Type(C.g_network_connectivity_get_type()), F: marshalNetworkConnectivity},
		{T: externglib.Type(C.g_notification_priority_get_type()), F: marshalNotificationPriority},
		{T: externglib.Type(C.g_password_save_get_type()), F: marshalPasswordSave},
		{T: externglib.Type(C.g_pollable_return_get_type()), F: marshalPollableReturn},
		{T: externglib.Type(C.g_resolver_error_get_type()), F: marshalResolverError},
		{T: externglib.Type(C.g_resolver_record_type_get_type()), F: marshalResolverRecordType},
		{T: externglib.Type(C.g_resource_error_get_type()), F: marshalResourceError},
		{T: externglib.Type(C.g_socket_client_event_get_type()), F: marshalSocketClientEvent},
		{T: externglib.Type(C.g_socket_family_get_type()), F: marshalSocketFamily},
		{T: externglib.Type(C.g_socket_listener_event_get_type()), F: marshalSocketListenerEvent},
		{T: externglib.Type(C.g_socket_protocol_get_type()), F: marshalSocketProtocol},
		{T: externglib.Type(C.g_socket_type_get_type()), F: marshalSocketType},
		{T: externglib.Type(C.g_tls_authentication_mode_get_type()), F: marshalTLSAuthenticationMode},
		{T: externglib.Type(C.g_tls_certificate_request_flags_get_type()), F: marshalTLSCertificateRequestFlags},
		{T: externglib.Type(C.g_tls_channel_binding_error_get_type()), F: marshalTLSChannelBindingError},
		{T: externglib.Type(C.g_tls_channel_binding_type_get_type()), F: marshalTLSChannelBindingType},
		{T: externglib.Type(C.g_tls_database_lookup_flags_get_type()), F: marshalTLSDatabaseLookupFlags},
		{T: externglib.Type(C.g_tls_error_get_type()), F: marshalTLSError},
		{T: externglib.Type(C.g_tls_interaction_result_get_type()), F: marshalTLSInteractionResult},
		{T: externglib.Type(C.g_tls_rehandshake_mode_get_type()), F: marshalTLSRehandshakeMode},
		{T: externglib.Type(C.g_unix_socket_address_type_get_type()), F: marshalUnixSocketAddressType},
		{T: externglib.Type(C.g_zlib_compressor_format_get_type()), F: marshalZlibCompressorFormat},
		{T: externglib.Type(C.g_app_info_create_flags_get_type()), F: marshalAppInfoCreateFlags},
		{T: externglib.Type(C.g_application_flags_get_type()), F: marshalApplicationFlags},
		{T: externglib.Type(C.g_ask_password_flags_get_type()), F: marshalAskPasswordFlags},
		{T: externglib.Type(C.g_bus_name_owner_flags_get_type()), F: marshalBusNameOwnerFlags},
		{T: externglib.Type(C.g_bus_name_watcher_flags_get_type()), F: marshalBusNameWatcherFlags},
		{T: externglib.Type(C.g_converter_flags_get_type()), F: marshalConverterFlags},
		{T: externglib.Type(C.g_dbus_call_flags_get_type()), F: marshalDBusCallFlags},
		{T: externglib.Type(C.g_dbus_capability_flags_get_type()), F: marshalDBusCapabilityFlags},
		{T: externglib.Type(C.g_dbus_connection_flags_get_type()), F: marshalDBusConnectionFlags},
		{T: externglib.Type(C.g_dbus_interface_skeleton_flags_get_type()), F: marshalDBusInterfaceSkeletonFlags},
		{T: externglib.Type(C.g_dbus_message_flags_get_type()), F: marshalDBusMessageFlags},
		{T: externglib.Type(C.g_dbus_object_manager_client_flags_get_type()), F: marshalDBusObjectManagerClientFlags},
		{T: externglib.Type(C.g_dbus_property_info_flags_get_type()), F: marshalDBusPropertyInfoFlags},
		{T: externglib.Type(C.g_dbus_proxy_flags_get_type()), F: marshalDBusProxyFlags},
		{T: externglib.Type(C.g_dbus_send_message_flags_get_type()), F: marshalDBusSendMessageFlags},
		{T: externglib.Type(C.g_dbus_server_flags_get_type()), F: marshalDBusServerFlags},
		{T: externglib.Type(C.g_dbus_signal_flags_get_type()), F: marshalDBusSignalFlags},
		{T: externglib.Type(C.g_dbus_subtree_flags_get_type()), F: marshalDBusSubtreeFlags},
		{T: externglib.Type(C.g_drive_start_flags_get_type()), F: marshalDriveStartFlags},
		{T: externglib.Type(C.g_file_attribute_info_flags_get_type()), F: marshalFileAttributeInfoFlags},
		{T: externglib.Type(C.g_file_copy_flags_get_type()), F: marshalFileCopyFlags},
		{T: externglib.Type(C.g_file_create_flags_get_type()), F: marshalFileCreateFlags},
		{T: externglib.Type(C.g_file_measure_flags_get_type()), F: marshalFileMeasureFlags},
		{T: externglib.Type(C.g_file_monitor_flags_get_type()), F: marshalFileMonitorFlags},
		{T: externglib.Type(C.g_file_query_info_flags_get_type()), F: marshalFileQueryInfoFlags},
		{T: externglib.Type(C.g_io_stream_splice_flags_get_type()), F: marshalIOStreamSpliceFlags},
		{T: externglib.Type(C.g_mount_mount_flags_get_type()), F: marshalMountMountFlags},
		{T: externglib.Type(C.g_mount_unmount_flags_get_type()), F: marshalMountUnmountFlags},
		{T: externglib.Type(C.g_output_stream_splice_flags_get_type()), F: marshalOutputStreamSpliceFlags},
		{T: externglib.Type(C.g_resolver_name_lookup_flags_get_type()), F: marshalResolverNameLookupFlags},
		{T: externglib.Type(C.g_resource_flags_get_type()), F: marshalResourceFlags},
		{T: externglib.Type(C.g_resource_lookup_flags_get_type()), F: marshalResourceLookupFlags},
		{T: externglib.Type(C.g_settings_bind_flags_get_type()), F: marshalSettingsBindFlags},
		{T: externglib.Type(C.g_socket_msg_flags_get_type()), F: marshalSocketMsgFlags},
		{T: externglib.Type(C.g_subprocess_flags_get_type()), F: marshalSubprocessFlags},
		{T: externglib.Type(C.g_test_dbus_flags_get_type()), F: marshalTestDBusFlags},
		{T: externglib.Type(C.g_tls_certificate_flags_get_type()), F: marshalTLSCertificateFlags},
		{T: externglib.Type(C.g_tls_database_verify_flags_get_type()), F: marshalTLSDatabaseVerifyFlags},
		{T: externglib.Type(C.g_tls_password_flags_get_type()), F: marshalTLSPasswordFlags},
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIcon},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
	})
}

// BusType: an enumeration for well-known message buses.
type BusType int

const (
	// BusTypeStarter: an alias for the message bus that activated the process,
	// if any.
	BusTypeStarter BusType = -1
	// BusTypeNone: not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem: the system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession: the login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p uintptr) (interface{}, error) {
	return BusType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterResult results returned from g_converter_convert().
type ConverterResult int

const (
	// ConverterResultError: there was an error during conversion.
	ConverterResultError ConverterResult = 0
	// ConverterResultConverted: some data was consumed or produced
	ConverterResultConverted ConverterResult = 1
	// ConverterResultFinished: the conversion is finished
	ConverterResultFinished ConverterResult = 2
	// ConverterResultFlushed: flushing is finished
	ConverterResultFlushed ConverterResult = 3
)

func marshalConverterResult(p uintptr) (interface{}, error) {
	return ConverterResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CredentialsType: enumeration describing different kinds of native credential
// types.
type CredentialsType int

const (
	// CredentialsTypeInvalid indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = 0
	// CredentialsTypeLinuxUcred: the native credentials type is a `struct
	// ucred`.
	CredentialsTypeLinuxUcred CredentialsType = 1
	// CredentialsTypeFreebsdCmsgcred: the native credentials type is a `struct
	// cmsgcred`.
	CredentialsTypeFreebsdCmsgcred CredentialsType = 2
	// CredentialsTypeOpenbsdSockpeercred: the native credentials type is a
	// `struct sockpeercred`. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred CredentialsType = 3
	// CredentialsTypeSolarisUcred: the native credentials type is a `ucred_t`.
	// Added in 2.40.
	CredentialsTypeSolarisUcred CredentialsType = 4
	// CredentialsTypeNetbsdUnpcbid: the native credentials type is a `struct
	// unpcbid`. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid CredentialsType = 5
	// CredentialsTypeAppleXucred: the native credentials type is a `struct
	// xucred`. Added in 2.66.
	CredentialsTypeAppleXucred CredentialsType = 6
)

func marshalCredentialsType(p uintptr) (interface{}, error) {
	return CredentialsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusError: error codes for the G_DBUS_ERROR error domain.
type DBusError int

const (
	// DBusErrorFailed: a generic error; "something went wrong" - see the error
	// message for more.
	DBusErrorFailed DBusError = 0
	// DBusErrorNoMemory: there was not enough memory to complete an operation.
	DBusErrorNoMemory DBusError = 1
	// DBusErrorServiceUnknown: the bus doesn't know how to launch a service to
	// supply the bus name you wanted.
	DBusErrorServiceUnknown DBusError = 2
	// DBusErrorNameHasNoOwner: the bus name you referenced doesn't exist (i.e.
	// no application owns it).
	DBusErrorNameHasNoOwner DBusError = 3
	// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
	DBusErrorNoReply DBusError = 4
	// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
	DBusErrorIOError DBusError = 5
	// DBusErrorBadAddress: a D-Bus bus address was malformed.
	DBusErrorBadAddress DBusError = 6
	// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
	DBusErrorNotSupported DBusError = 7
	// DBusErrorLimitsExceeded: some limited resource is exhausted.
	DBusErrorLimitsExceeded DBusError = 8
	// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
	DBusErrorAccessDenied DBusError = 9
	// DBusErrorAuthFailed: authentication didn't work.
	DBusErrorAuthFailed DBusError = 10
	// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
	DBusErrorNoServer DBusError = 11
	// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimeout DBusError = 12
	// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
	DBusErrorNoNetwork DBusError = 13
	// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
	DBusErrorAddressInUse DBusError = 14
	// DBusErrorDisconnected: the connection is disconnected and you're trying
	// to use it.
	DBusErrorDisconnected DBusError = 15
	// DBusErrorInvalidArgs: invalid arguments passed to a method call.
	DBusErrorInvalidArgs DBusError = 16
	// DBusErrorFileNotFound: missing file.
	DBusErrorFileNotFound DBusError = 17
	// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
	DBusErrorFileExists DBusError = 18
	// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
	DBusErrorUnknownMethod DBusError = 19
	// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimedOut DBusError = 20
	// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
	DBusErrorMatchRuleNotFound DBusError = 21
	// DBusErrorMatchRuleInvalid: the match rule isn't syntactically valid.
	DBusErrorMatchRuleInvalid DBusError = 22
	// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
	DBusErrorSpawnExecFailed DBusError = 23
	// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
	DBusErrorSpawnForkFailed DBusError = 24
	// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
	DBusErrorSpawnChildExited DBusError = 25
	// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
	DBusErrorSpawnChildSignaled DBusError = 26
	// DBusErrorSpawnFailed: while starting a new process, something went wrong.
	DBusErrorSpawnFailed DBusError = 27
	// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
	DBusErrorSpawnSetupFailed DBusError = 28
	// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
	DBusErrorSpawnConfigInvalid DBusError = 29
	// DBusErrorSpawnServiceInvalid bus name was not valid.
	DBusErrorSpawnServiceInvalid DBusError = 30
	// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
	DBusErrorSpawnServiceNotFound DBusError = 31
	// DBusErrorSpawnPermissionsInvalid permissions are incorrect on the setuid
	// helper.
	DBusErrorSpawnPermissionsInvalid DBusError = 32
	// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
	DBusErrorSpawnFileInvalid DBusError = 33
	// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
	DBusErrorSpawnNoMemory DBusError = 34
	// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
	DBusErrorUnixProcessIDUnknown DBusError = 35
	// DBusErrorInvalidSignature: a type signature is not valid.
	DBusErrorInvalidSignature DBusError = 36
	// DBusErrorInvalidFileContent: a file contains invalid syntax or is
	// otherwise broken.
	DBusErrorInvalidFileContent DBusError = 37
	// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
	DBusErrorSelinuxSecurityContextUnknown DBusError = 38
	// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
	DBusErrorAdtAuditDataUnknown DBusError = 39
	// DBusErrorObjectPathInUse there's already an object with the requested
	// object path.
	DBusErrorObjectPathInUse DBusError = 40
	// DBusErrorUnknownObject: object you invoked a method on isn't known. Since
	// 2.42
	DBusErrorUnknownObject DBusError = 41
	// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42
	DBusErrorUnknownInterface DBusError = 42
	// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42
	DBusErrorUnknownProperty DBusError = 43
	// DBusErrorPropertyReadOnly: property you tried to set is read-only. Since
	// 2.42
	DBusErrorPropertyReadOnly DBusError = 44
)

func marshalDBusError(p uintptr) (interface{}, error) {
	return DBusError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
type DBusMessageByteOrder int

const (
	// DBusMessageByteOrderBigEndian: the byte order is big endian.
	DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
	// DBusMessageByteOrderLittleEndian: the byte order is little endian.
	DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
)

func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
	return DBusMessageByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageHeaderField: header fields used in BusMessage.
type DBusMessageHeaderField int

const (
	// DBusMessageHeaderFieldInvalid: not a valid header field.
	DBusMessageHeaderFieldInvalid DBusMessageHeaderField = 0
	// DBusMessageHeaderFieldPath: the object path.
	DBusMessageHeaderFieldPath DBusMessageHeaderField = 1
	// DBusMessageHeaderFieldInterface: the interface name.
	DBusMessageHeaderFieldInterface DBusMessageHeaderField = 2
	// DBusMessageHeaderFieldMember: the method or signal name.
	DBusMessageHeaderFieldMember DBusMessageHeaderField = 3
	// DBusMessageHeaderFieldErrorName: the name of the error that occurred.
	DBusMessageHeaderFieldErrorName DBusMessageHeaderField = 4
	// DBusMessageHeaderFieldReplySerial: the serial number the message is a
	// reply to.
	DBusMessageHeaderFieldReplySerial DBusMessageHeaderField = 5
	// DBusMessageHeaderFieldDestination: the name the message is intended for.
	DBusMessageHeaderFieldDestination DBusMessageHeaderField = 6
	// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
	DBusMessageHeaderFieldSender DBusMessageHeaderField = 7
	// DBusMessageHeaderFieldSignature: the signature of the message body.
	DBusMessageHeaderFieldSignature DBusMessageHeaderField = 8
	// DBusMessageHeaderFieldNumUnixFds: the number of UNIX file descriptors
	// that accompany the message.
	DBusMessageHeaderFieldNumUnixFds DBusMessageHeaderField = 9
)

func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
	return DBusMessageHeaderField(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageType: message types used in BusMessage.
type DBusMessageType int

const (
	// DBusMessageTypeInvalid: message is of invalid type.
	DBusMessageTypeInvalid DBusMessageType = 0
	// DBusMessageTypeMethodCall: method call.
	DBusMessageTypeMethodCall DBusMessageType = 1
	// DBusMessageTypeMethodReturn: method reply.
	DBusMessageTypeMethodReturn DBusMessageType = 2
	// DBusMessageTypeError: error reply.
	DBusMessageTypeError DBusMessageType = 3
	// DBusMessageTypeSignal: signal emission.
	DBusMessageTypeSignal DBusMessageType = 4
)

func marshalDBusMessageType(p uintptr) (interface{}, error) {
	return DBusMessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamByteOrder is used to ensure proper endianness of streaming data
// sources across various machine architectures.
type DataStreamByteOrder int

const (
	// DataStreamByteOrderBigEndian selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = 0
	// DataStreamByteOrderLittleEndian selects Little Endian byte order.
	DataStreamByteOrderLittleEndian DataStreamByteOrder = 1
	// DataStreamByteOrderHostEndian selects endianness based on host machine's
	// architecture.
	DataStreamByteOrderHostEndian DataStreamByteOrder = 2
)

func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
	return DataStreamByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamNewlineType is used when checking for or setting the line endings
// for a given file.
type DataStreamNewlineType int

const (
	// DataStreamNewlineTypeLf selects "LF" line endings, common on most modern
	// UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = 0
	// DataStreamNewlineTypeCr selects "CR" line endings.
	DataStreamNewlineTypeCr DataStreamNewlineType = 1
	// DataStreamNewlineTypeCrLf selects "CR, LF" line ending, common on
	// Microsoft Windows.
	DataStreamNewlineTypeCrLf DataStreamNewlineType = 2
	// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
	DataStreamNewlineTypeAny DataStreamNewlineType = 3
)

func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
	return DataStreamNewlineType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
type DriveStartStopType int

const (
	// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = 0
	// DriveStartStopTypeShutdown: the stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
	DriveStartStopTypeShutdown DriveStartStopType = 1
	// DriveStartStopTypeNetwork: the start/stop methods are used for
	// connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork DriveStartStopType = 2
	// DriveStartStopTypeMultidisk: the start/stop methods will
	// assemble/disassemble a virtual drive from several physical drives.
	DriveStartStopTypeMultidisk DriveStartStopType = 3
	// DriveStartStopTypePassword: the start/stop methods will unlock/lock the
	// disk (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command)
	DriveStartStopTypePassword DriveStartStopType = 4
)

func marshalDriveStartStopType(p uintptr) (interface{}, error) {
	return DriveStartStopType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EmblemOrigin: GEmblemOrigin is used to add information about the origin of
// the emblem to #GEmblem.
type EmblemOrigin int

const (
	// EmblemOriginUnknown: emblem of unknown origin
	EmblemOriginUnknown EmblemOrigin = 0
	// EmblemOriginDevice: emblem adds device-specific information
	EmblemOriginDevice EmblemOrigin = 1
	// EmblemOriginLivemetadata: emblem depicts live metadata, such as
	// "readonly"
	EmblemOriginLivemetadata EmblemOrigin = 2
	// EmblemOriginTag: emblem comes from a user-defined tag, e.g. set by
	// nautilus (in the future)
	EmblemOriginTag EmblemOrigin = 3
)

func marshalEmblemOrigin(p uintptr) (interface{}, error) {
	return EmblemOrigin(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
type FileAttributeStatus int

const (
	// FileAttributeStatusUnset: attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = 0
	// FileAttributeStatusSet: attribute value is set.
	FileAttributeStatusSet FileAttributeStatus = 1
	// FileAttributeStatusErrorSetting indicates an error in setting the value.
	FileAttributeStatusErrorSetting FileAttributeStatus = 2
)

func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
	return FileAttributeStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeType: the data types for file attributes.
type FileAttributeType int

const (
	// FileAttributeTypeInvalid indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = 0
	// FileAttributeTypeString: a null terminated UTF8 string.
	FileAttributeTypeString FileAttributeType = 1
	// FileAttributeTypeByteString: a zero terminated string of non-zero bytes.
	FileAttributeTypeByteString FileAttributeType = 2
	// FileAttributeTypeBoolean: a boolean value.
	FileAttributeTypeBoolean FileAttributeType = 3
	// FileAttributeTypeUint32: an unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32 FileAttributeType = 4
	// FileAttributeTypeInt32: a signed 4-byte/32-bit integer.
	FileAttributeTypeInt32 FileAttributeType = 5
	// FileAttributeTypeUint64: an unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64 FileAttributeType = 6
	// FileAttributeTypeInt64: a signed 8-byte/64-bit integer.
	FileAttributeTypeInt64 FileAttributeType = 7
	// FileAttributeTypeObject: a #GObject.
	FileAttributeTypeObject FileAttributeType = 8
	// FileAttributeTypeStringv: a nil terminated char **. Since 2.22
	FileAttributeTypeStringv FileAttributeType = 9
)

func marshalFileAttributeType(p uintptr) (interface{}, error) {
	return FileAttributeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorEvent specifies what type of event a monitor event is.
type FileMonitorEvent int

const (
	// FileMonitorEventChanged: a file changed.
	FileMonitorEventChanged FileMonitorEvent = 0
	// FileMonitorEventChangesDoneHint: a hint that this was probably the last
	// change in a set of changes.
	FileMonitorEventChangesDoneHint FileMonitorEvent = 1
	// FileMonitorEventDeleted: a file was deleted.
	FileMonitorEventDeleted FileMonitorEvent = 2
	// FileMonitorEventCreated: a file was created.
	FileMonitorEventCreated FileMonitorEvent = 3
	// FileMonitorEventAttributeChanged: a file attribute was changed.
	FileMonitorEventAttributeChanged FileMonitorEvent = 4
	// FileMonitorEventPreUnmount: the file location will soon be unmounted.
	FileMonitorEventPreUnmount FileMonitorEvent = 5
	// FileMonitorEventUnmounted: the file location was unmounted.
	FileMonitorEventUnmounted FileMonitorEvent = 6
	// FileMonitorEventMoved: the file was moved -- only sent if the
	// (deprecated) G_FILE_MONITOR_SEND_MOVED flag is set
	FileMonitorEventMoved FileMonitorEvent = 7
	// FileMonitorEventRenamed: the file was renamed within the current
	// directory -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set.
	// Since: 2.46.
	FileMonitorEventRenamed FileMonitorEvent = 8
	// FileMonitorEventMovedIn: the file was moved into the monitored directory
	// from another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
	FileMonitorEventMovedIn FileMonitorEvent = 9
	// FileMonitorEventMovedOut: the file was moved out of the monitored
	// directory to another location -- only sent if the
	// G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46
	FileMonitorEventMovedOut FileMonitorEvent = 10
)

func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
	return FileMonitorEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileType indicates the file's on-disk type.
//
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type; use
// Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a file is
// a symlink or not. This is due to the fact that NTFS does not have a single
// filesystem object type for symbolic links - it has files that symlink to
// files, and directories that symlink to directories. Type enumeration cannot
// precisely represent this important distinction, which is why all Windows
// symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
type FileType int

const (
	// FileTypeUnknown file's type is unknown.
	FileTypeUnknown FileType = 0
	// FileTypeRegular: file handle represents a regular file.
	FileTypeRegular FileType = 1
	// FileTypeDirectory: file handle represents a directory.
	FileTypeDirectory FileType = 2
	// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
	FileTypeSymbolicLink FileType = 3
	// FileTypeSpecial: file is a "special" file, such as a socket, fifo, block
	// device, or character device.
	FileTypeSpecial FileType = 4
	// FileTypeShortcut: file is a shortcut (Windows systems).
	FileTypeShortcut FileType = 5
	// FileTypeMountable: file is a mountable location.
	FileTypeMountable FileType = 6
)

func marshalFileType(p uintptr) (interface{}, error) {
	return FileType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilesystemPreviewType indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType int

const (
	// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = 0
	// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
	FilesystemPreviewTypeIfLocal FilesystemPreviewType = 1
	// FilesystemPreviewTypeNever: never preview files.
	FilesystemPreviewTypeNever FilesystemPreviewType = 2
)

func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
	return FilesystemPreviewType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOErrorEnum: error codes returned by GIO functions.
//
// Note that this domain may be extended in future GLib releases. In general,
// new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before. You
// should therefore avoid writing code like
//
//    if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
//      {
//        // Assume that this is EPRINTERONFIRE
//        ...
//      }
//
// but should instead treat all unrecognized error codes the same as
// IO_ERROR_FAILED.
//
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
type IOErrorEnum int

const (
	// IOErrorEnumFailed: generic error condition for when an operation fails
	// and no more specific OErrorEnum value is defined.
	IOErrorEnumFailed IOErrorEnum = 0
	// IOErrorEnumNotFound: file not found.
	IOErrorEnumNotFound IOErrorEnum = 1
	// IOErrorEnumExists: file already exists.
	IOErrorEnumExists IOErrorEnum = 2
	// IOErrorEnumIsDirectory: file is a directory.
	IOErrorEnumIsDirectory IOErrorEnum = 3
	// IOErrorEnumNotDirectory: file is not a directory.
	IOErrorEnumNotDirectory IOErrorEnum = 4
	// IOErrorEnumNotEmpty: file is a directory that isn't empty.
	IOErrorEnumNotEmpty IOErrorEnum = 5
	// IOErrorEnumNotRegularFile: file is not a regular file.
	IOErrorEnumNotRegularFile IOErrorEnum = 6
	// IOErrorEnumNotSymbolicLink: file is not a symbolic link.
	IOErrorEnumNotSymbolicLink IOErrorEnum = 7
	// IOErrorEnumNotMountableFile: file cannot be mounted.
	IOErrorEnumNotMountableFile IOErrorEnum = 8
	// IOErrorEnumFilenameTooLong: filename is too many characters.
	IOErrorEnumFilenameTooLong IOErrorEnum = 9
	// IOErrorEnumInvalidFilename: filename is invalid or contains invalid
	// characters.
	IOErrorEnumInvalidFilename IOErrorEnum = 10
	// IOErrorEnumTooManyLinks: file contains too many symbolic links.
	IOErrorEnumTooManyLinks IOErrorEnum = 11
	// IOErrorEnumNoSpace: no space left on drive.
	IOErrorEnumNoSpace IOErrorEnum = 12
	// IOErrorEnumInvalidArgument: invalid argument.
	IOErrorEnumInvalidArgument IOErrorEnum = 13
	// IOErrorEnumPermissionDenied: permission denied.
	IOErrorEnumPermissionDenied IOErrorEnum = 14
	// IOErrorEnumNotSupported: operation (or one of its parameters) not
	// supported
	IOErrorEnumNotSupported IOErrorEnum = 15
	// IOErrorEnumNotMounted: file isn't mounted.
	IOErrorEnumNotMounted IOErrorEnum = 16
	// IOErrorEnumAlreadyMounted: file is already mounted.
	IOErrorEnumAlreadyMounted IOErrorEnum = 17
	// IOErrorEnumClosed: file was closed.
	IOErrorEnumClosed IOErrorEnum = 18
	// IOErrorEnumCancelled: operation was cancelled. See #GCancellable.
	IOErrorEnumCancelled IOErrorEnum = 19
	// IOErrorEnumPending operations are still pending.
	IOErrorEnumPending IOErrorEnum = 20
	// IOErrorEnumReadOnly: file is read only.
	IOErrorEnumReadOnly IOErrorEnum = 21
	// IOErrorEnumCantCreateBackup: backup couldn't be created.
	IOErrorEnumCantCreateBackup IOErrorEnum = 22
	// IOErrorEnumWrongEtag file's Entity Tag was incorrect.
	IOErrorEnumWrongEtag IOErrorEnum = 23
	// IOErrorEnumTimedOut: operation timed out.
	IOErrorEnumTimedOut IOErrorEnum = 24
	// IOErrorEnumWouldRecurse: operation would be recursive.
	IOErrorEnumWouldRecurse IOErrorEnum = 25
	// IOErrorEnumBusy: file is busy.
	IOErrorEnumBusy IOErrorEnum = 26
	// IOErrorEnumWouldBlock: operation would block.
	IOErrorEnumWouldBlock IOErrorEnum = 27
	// IOErrorEnumHostNotFound: host couldn't be found (remote operations).
	IOErrorEnumHostNotFound IOErrorEnum = 28
	// IOErrorEnumWouldMerge: operation would merge files.
	IOErrorEnumWouldMerge IOErrorEnum = 29
	// IOErrorEnumFailedHandled: operation failed and a helper program has
	// already interacted with the user. Do not display any error dialog.
	IOErrorEnumFailedHandled IOErrorEnum = 30
	// IOErrorEnumTooManyOpenFiles: the current process has too many files open
	// and can't open any more. Duplicate descriptors do count toward this
	// limit. Since 2.20
	IOErrorEnumTooManyOpenFiles IOErrorEnum = 31
	// IOErrorEnumNotInitialized: the object has not been initialized. Since
	// 2.22
	IOErrorEnumNotInitialized IOErrorEnum = 32
	// IOErrorEnumAddressInUse: the requested address is already in use. Since
	// 2.22
	IOErrorEnumAddressInUse IOErrorEnum = 33
	// IOErrorEnumPartialInput: need more input to finish operation. Since 2.24
	IOErrorEnumPartialInput IOErrorEnum = 34
	// IOErrorEnumInvalidData: the input data was invalid. Since 2.24
	IOErrorEnumInvalidData IOErrorEnum = 35
	// IOErrorEnumDBusError: a remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
	IOErrorEnumDBusError IOErrorEnum = 36
	// IOErrorEnumHostUnreachable: host unreachable. Since 2.26
	IOErrorEnumHostUnreachable IOErrorEnum = 37
	// IOErrorEnumNetworkUnreachable: network unreachable. Since 2.26
	IOErrorEnumNetworkUnreachable IOErrorEnum = 38
	// IOErrorEnumConnectionRefused: connection refused. Since 2.26
	IOErrorEnumConnectionRefused IOErrorEnum = 39
	// IOErrorEnumProxyFailed: connection to proxy server failed. Since 2.26
	IOErrorEnumProxyFailed IOErrorEnum = 40
	// IOErrorEnumProxyAuthFailed: proxy authentication failed. Since 2.26
	IOErrorEnumProxyAuthFailed IOErrorEnum = 41
	// IOErrorEnumProxyNeedAuth: proxy server needs authentication. Since 2.26
	IOErrorEnumProxyNeedAuth IOErrorEnum = 42
	// IOErrorEnumProxyNotAllowed: proxy connection is not allowed by ruleset.
	// Since 2.26
	IOErrorEnumProxyNotAllowed IOErrorEnum = 43
	// IOErrorEnumBrokenPipe: broken pipe. Since 2.36
	IOErrorEnumBrokenPipe IOErrorEnum = 44
	// IOErrorEnumConnectionClosed: connection closed by peer. Note that this is
	// the same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection
	// closed" errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
	IOErrorEnumConnectionClosed IOErrorEnum = 44
	// IOErrorEnumNotConnected: transport endpoint is not connected. Since 2.44
	IOErrorEnumNotConnected IOErrorEnum = 45
	// IOErrorEnumMessageTooLarge: message too large. Since 2.48.
	IOErrorEnumMessageTooLarge IOErrorEnum = 46
)

func marshalIOErrorEnum(p uintptr) (interface{}, error) {
	return IOErrorEnum(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOModuleScopeFlags flags for use with g_io_module_scope_new().
type IOModuleScopeFlags int

const (
	// IOModuleScopeFlagsNone: no module scan flags
	IOModuleScopeFlagsNone IOModuleScopeFlags = 0
	// IOModuleScopeFlagsBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
	IOModuleScopeFlagsBlockDuplicates IOModuleScopeFlags = 1
)

func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
	return IOModuleScopeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MemoryMonitorWarningLevel: memory availability warning levels.
//
// Note that because new values might be added, it is recommended that
// applications check MonitorWarningLevel as ranges, for example:
//
//    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//      drop_caches ();
type MemoryMonitorWarningLevel int

const (
	// MemoryMonitorWarningLevelLow: memory on the device is low, processes
	// should free up unneeded resources (for example, in-memory caches) so they
	// can be used elsewhere.
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium: same as
	// @G_MEMORY_MONITOR_WARNING_LEVEL_LOW but the device has even less free
	// memory, so processes should try harder to free up unneeded resources. If
	// your process does not need to stay running, it is a good time for it to
	// quit.
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical: the system will soon start terminating
	// processes to reclaim memory, including background processes.
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p uintptr) (interface{}, error) {
	return MemoryMonitorWarningLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountOperationResult is returned as a result when a request for information
// is send by the mounting operation.
type MountOperationResult int

const (
	// MountOperationResultHandled: the request was fulfilled and the user
	// specified data is now available
	MountOperationResultHandled MountOperationResult = 0
	// MountOperationResultAborted: the user requested the mount operation to be
	// aborted
	MountOperationResultAborted MountOperationResult = 1
	// MountOperationResultUnhandled: the request was unhandled (i.e. not
	// implemented)
	MountOperationResultUnhandled MountOperationResult = 2
)

func marshalMountOperationResult(p uintptr) (interface{}, error) {
	return MountOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NetworkConnectivity: the host's network connectivity state, as reported by
// Monitor.
type NetworkConnectivity int

const (
	// NetworkConnectivityLocal: the host is not configured with a route to the
	// Internet; it may or may not be connected to a local network.
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited: the host is connected to a network, but does
	// not appear to be able to reach the full Internet, perhaps due to upstream
	// network problems.
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal: the host is behind a captive portal and cannot
	// reach the full Internet.
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull: the host is connected to a network, and appears
	// to be able to reach the full Internet.
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p uintptr) (interface{}, error) {
	return NetworkConnectivity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotificationPriority: priority levels for #GNotifications.
type NotificationPriority int

const (
	// NotificationPriorityNormal: the default priority, to be used for the
	// majority of notifications (for example email messages, software updates,
	// completed download/sync operations)
	NotificationPriorityNormal NotificationPriority = 0
	// NotificationPriorityLow: for notifications that do not require immediate
	// attention - typically used for contextual background information, such as
	// contact birthdays or local weather
	NotificationPriorityLow NotificationPriority = 1
	// NotificationPriorityHigh: for events that require more attention, usually
	// because responses are time-sensitive (for example chat and SMS messages
	// or alarms)
	NotificationPriorityHigh NotificationPriority = 2
	// NotificationPriorityUrgent: for urgent notifications, or notifications
	// that require a response in a short space of time (for example phone calls
	// or emergency warnings)
	NotificationPriorityUrgent NotificationPriority = 3
)

func marshalNotificationPriority(p uintptr) (interface{}, error) {
	return NotificationPriority(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PasswordSave is used to indicate the lifespan of a saved password.
//
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to, and
// later retrieves it again from there.
type PasswordSave int

const (
	// PasswordSaveNever: never save a password.
	PasswordSaveNever PasswordSave = 0
	// PasswordSaveForSession: save a password for the session.
	PasswordSaveForSession PasswordSave = 1
	// PasswordSavePermanently: save a password permanently.
	PasswordSavePermanently PasswordSave = 2
)

func marshalPasswordSave(p uintptr) (interface{}, error) {
	return PasswordSave(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PollableReturn: return value for various IO operations that signal errors via
// the return value and not necessarily via a #GError.
//
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for regularly
// happening errors like G_IO_ERROR_WOULD_BLOCK.
//
// In case of G_POLLABLE_RETURN_FAILED a #GError should be set for the operation
// to give details about the error that happened.
type PollableReturn int

const (
	// PollableReturnFailed: generic error condition for when an operation
	// fails.
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOk: the operation was successfully finished.
	PollableReturnOk PollableReturn = 1
	// PollableReturnWouldBlock: the operation would block.
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p uintptr) (interface{}, error) {
	return PollableReturn(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverError: an error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError int

const (
	// ResolverErrorNotFound: the requested name/address/service was not found
	ResolverErrorNotFound ResolverError = 0
	// ResolverErrorTemporaryFailure: the requested information could not be
	// looked up due to a network error or similar problem
	ResolverErrorTemporaryFailure ResolverError = 1
	// ResolverErrorInternal: unknown error
	ResolverErrorInternal ResolverError = 2
)

func marshalResolverError(p uintptr) (interface{}, error) {
	return ResolverError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverRecordType: the type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
//
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
// weight, a `guint16` with the port, and a string of the hostname.
//
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// `(qs)`, representing a `guint16` with the preference, and a string containing
// the mail exchanger hostname.
//
// G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// `(as)`, representing an array of the strings in the text record. Note: Most
// TXT records only contain a single string, but RFC 1035
// (https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record to
// contain multiple strings. The RFC which defines the interpretation of a
// specific TXT record will likely require concatenation of multiple strings if
// they are present, as with RFC 7208
// (https://tools.ietf.org/html/rfc7208#section-3.3).
//
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// `(ssuuuuu)`, representing a string containing the primary name server, a
// string containing the administrator, the serial as a `guint32`, the refresh
// interval as a `guint32`, the retry interval as a `guint32`, the expire
// timeout as a `guint32`, and the TTL as a `guint32`.
//
// G_RESOLVER_RECORD_NS records are returned as variants with the signature
// `(s)`, representing a string of the hostname of the name server.
type ResolverRecordType int

const (
	// ResolverRecordTypeSrv: look up DNS SRV records for a domain
	ResolverRecordTypeSrv ResolverRecordType = 1
	// ResolverRecordTypeMx: look up DNS MX records for a domain
	ResolverRecordTypeMx ResolverRecordType = 2
	// ResolverRecordTypeTxt: look up DNS TXT records for a name
	ResolverRecordTypeTxt ResolverRecordType = 3
	// ResolverRecordTypeSoa: look up DNS SOA records for a zone
	ResolverRecordTypeSoa ResolverRecordType = 4
	// ResolverRecordTypeNs: look up DNS NS records for a domain
	ResolverRecordTypeNs ResolverRecordType = 5
)

func marshalResolverRecordType(p uintptr) (interface{}, error) {
	return ResolverRecordType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceError: an error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError int

const (
	// ResourceErrorNotFound: no file was found at the requested path
	ResourceErrorNotFound ResourceError = 0
	// ResourceErrorInternal: unknown error
	ResourceErrorInternal ResourceError = 1
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketClientEvent describes an event occurring on a Client. See the
// Client::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketClientEvent int

const (
	// SocketClientEventResolving: the client is doing a DNS lookup.
	SocketClientEventResolving SocketClientEvent = 0
	// SocketClientEventResolved: the client has completed a DNS lookup.
	SocketClientEventResolved SocketClientEvent = 1
	// SocketClientEventConnecting: the client is connecting to a remote host
	// (either a proxy or the destination server).
	SocketClientEventConnecting SocketClientEvent = 2
	// SocketClientEventConnected: the client has connected to a remote host.
	SocketClientEventConnected SocketClientEvent = 3
	// SocketClientEventProxyNegotiating: the client is negotiating with a proxy
	// to connect to the destination server.
	SocketClientEventProxyNegotiating SocketClientEvent = 4
	// SocketClientEventProxyNegotiated: the client has negotiated with the
	// proxy server.
	SocketClientEventProxyNegotiated SocketClientEvent = 5
	// SocketClientEventTLSHandshaking: the client is performing a TLS
	// handshake.
	SocketClientEventTLSHandshaking SocketClientEvent = 6
	// SocketClientEventTLSHandshaked: the client has performed a TLS handshake.
	SocketClientEventTLSHandshaked SocketClientEvent = 7
	// SocketClientEventComplete: the client is done with a particular
	// Connectable.
	SocketClientEventComplete SocketClientEvent = 8
)

func marshalSocketClientEvent(p uintptr) (interface{}, error) {
	return SocketClientEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketFamily: the protocol family of a Address. (These values are identical
// to the system defines AF_INET, AF_INET6 and AF_UNIX, if available.)
type SocketFamily int

const (
	// SocketFamilyInvalid: no address family
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyUnix: the UNIX domain family
	SocketFamilyUnix SocketFamily = 1
	// SocketFamilyIpv4: the IPv4 family
	SocketFamilyIpv4 SocketFamily = 2
	// SocketFamilyIpv6: the IPv6 family
	SocketFamilyIpv6 SocketFamily = 10
)

func marshalSocketFamily(p uintptr) (interface{}, error) {
	return SocketFamily(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketListenerEvent describes an event occurring on a Listener. See the
// Listener::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketListenerEvent int

const (
	// SocketListenerEventBinding: the listener is about to bind a socket.
	SocketListenerEventBinding SocketListenerEvent = 0
	// SocketListenerEventBound: the listener has bound a socket.
	SocketListenerEventBound SocketListenerEvent = 1
	// SocketListenerEventListening: the listener is about to start listening on
	// this socket.
	SocketListenerEventListening SocketListenerEvent = 2
	// SocketListenerEventListened: the listener is now listening on this
	// socket.
	SocketListenerEventListened SocketListenerEvent = 3
)

func marshalSocketListenerEvent(p uintptr) (interface{}, error) {
	return SocketListenerEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketProtocol: a protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
//
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
type SocketProtocol int

const (
	// SocketProtocolUnknown: the protocol type is unknown
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault: the default protocol for the family/type
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTcp: TCP over IP
	SocketProtocolTcp SocketProtocol = 6
	// SocketProtocolUdp: UDP over IP
	SocketProtocolUdp SocketProtocol = 17
	// SocketProtocolSctp: SCTP over IP
	SocketProtocolSctp SocketProtocol = 132
)

func marshalSocketProtocol(p uintptr) (interface{}, error) {
	return SocketProtocol(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketType flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
type SocketType int

const (
	// SocketTypeInvalid: type unknown or wrong
	SocketTypeInvalid SocketType = 0
	// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream SocketType = 1
	// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP)
	SocketTypeDatagram SocketType = 2
	// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket SocketType = 3
)

func marshalSocketType(p uintptr) (interface{}, error) {
	return SocketType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSAuthenticationMode: the client authentication mode for a ServerConnection.
type TLSAuthenticationMode int

const (
	// TLSAuthenticationModeNone: client authentication not required
	TLSAuthenticationModeNone TLSAuthenticationMode = 0
	// TLSAuthenticationModeRequested: client authentication is requested
	TLSAuthenticationModeRequested TLSAuthenticationMode = 1
	// TLSAuthenticationModeRequired: client authentication is required
	TLSAuthenticationModeRequired TLSAuthenticationMode = 2
)

func marshalTLSAuthenticationMode(p uintptr) (interface{}, error) {
	return TLSAuthenticationMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSCertificateRequestFlags flags for g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
type TLSCertificateRequestFlags int

const (
	// TLSCertificateRequestFlagsNone: no flags
	TLSCertificateRequestFlagsNone TLSCertificateRequestFlags = 0
)

func marshalTLSCertificateRequestFlags(p uintptr) (interface{}, error) {
	return TLSCertificateRequestFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSChannelBindingError: an error code used with G_TLS_CHANNEL_BINDING_ERROR
// in a #GError to indicate a TLS channel binding retrieval error.
type TLSChannelBindingError int

const (
	// TLSChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
	TLSChannelBindingErrorNotImplemented TLSChannelBindingError = 0
	// TLSChannelBindingErrorInvalidState: the handshake is not yet complete on
	// the connection which is a strong requirement for any existing binding
	// type.
	TLSChannelBindingErrorInvalidState TLSChannelBindingError = 1
	// TLSChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
	TLSChannelBindingErrorNotAvailable TLSChannelBindingError = 2
	// TLSChannelBindingErrorNotSupported: binding type is not supported on the
	// current connection. This error could be triggered when requesting
	// `tls-server-end-point` binding data for a certificate which has no hash
	// function or uses multiple hash functions.
	TLSChannelBindingErrorNotSupported TLSChannelBindingError = 3
	// TLSChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
	TLSChannelBindingErrorGeneralError TLSChannelBindingError = 4
)

func marshalTLSChannelBindingError(p uintptr) (interface{}, error) {
	return TLSChannelBindingError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSChannelBindingType: the type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929. The
// `tls-unique-for-telnet` (https://tools.ietf.org/html/rfc5929#section-5)
// binding type is not currently implemented.
type TLSChannelBindingType int

const (
	// TLSChannelBindingTypeUnique: `tls-unique`
	// (https://tools.ietf.org/html/rfc5929#section-3) binding type
	TLSChannelBindingTypeUnique TLSChannelBindingType = 0
	// TLSChannelBindingTypeServerEndPoint: `tls-server-end-point`
	// (https://tools.ietf.org/html/rfc5929#section-4) binding type
	TLSChannelBindingTypeServerEndPoint TLSChannelBindingType = 1
)

func marshalTLSChannelBindingType(p uintptr) (interface{}, error) {
	return TLSChannelBindingType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSDatabaseLookupFlags flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
type TLSDatabaseLookupFlags int

const (
	// TLSDatabaseLookupFlagsNone: no lookup flags
	TLSDatabaseLookupFlagsNone TLSDatabaseLookupFlags = 0
	// TLSDatabaseLookupFlagsKeypair: restrict lookup to certificates that have
	// a private key.
	TLSDatabaseLookupFlagsKeypair TLSDatabaseLookupFlags = 1
)

func marshalTLSDatabaseLookupFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSError: an error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TLSError int

const (
	// TLSErrorUnavailable: no TLS provider is available
	TLSErrorUnavailable TLSError = 0
	// TLSErrorMisc miscellaneous TLS error
	TLSErrorMisc TLSError = 1
	// TLSErrorBadCertificate: the certificate presented could not be parsed or
	// failed validation.
	TLSErrorBadCertificate TLSError = 2
	// TLSErrorNotTLS: the TLS handshake failed because the peer does not seem
	// to be a TLS server.
	TLSErrorNotTLS TLSError = 3
	// TLSErrorHandshake: the TLS handshake failed because the peer's
	// certificate was not acceptable.
	TLSErrorHandshake TLSError = 4
	// TLSErrorCertificateRequired: the TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
	TLSErrorCertificateRequired TLSError = 5
	// TLSErrorEOF: the TLS connection was closed without proper notice, which
	// may indicate an attack. See g_tls_connection_set_require_close_notify().
	TLSErrorEOF TLSError = 6
	// TLSErrorInappropriateFallback: the TLS handshake failed because the
	// client sent the fallback SCSV, indicating a protocol downgrade attack.
	// Since: 2.60
	TLSErrorInappropriateFallback TLSError = 7
)

func marshalTLSError(p uintptr) (interface{}, error) {
	return TLSError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSInteractionResult is returned by various functions in Interaction when
// finishing an interaction request.
type TLSInteractionResult int

const (
	// TLSInteractionResultUnhandled: the interaction was unhandled (i.e. not
	// implemented).
	TLSInteractionResultUnhandled TLSInteractionResult = 0
	// TLSInteractionResultHandled: the interaction completed, and resulting
	// data is available.
	TLSInteractionResultHandled TLSInteractionResult = 1
	// TLSInteractionResultFailed: the interaction has failed, or was cancelled.
	// and the operation should be aborted.
	TLSInteractionResultFailed TLSInteractionResult = 2
)

func marshalTLSInteractionResult(p uintptr) (interface{}, error) {
	return TLSInteractionResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
type TLSRehandshakeMode int

const (
	// TLSRehandshakeModeNever: never allow rehandshaking
	TLSRehandshakeModeNever TLSRehandshakeMode = 0
	// TLSRehandshakeModeSafely: allow safe rehandshaking only
	TLSRehandshakeModeSafely TLSRehandshakeMode = 1
	// TLSRehandshakeModeUnsafely: allow unsafe rehandshaking
	TLSRehandshakeModeUnsafely TLSRehandshakeMode = 2
)

func marshalTLSRehandshakeMode(p uintptr) (interface{}, error) {
	return TLSRehandshakeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UnixSocketAddressType: the type of name used by a SocketAddress.
// G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain socket bound
// to a filesystem path. G_UNIX_SOCKET_ADDRESS_ANONYMOUS indicates a socket not
// bound to any name (eg, a client-side socket, or a socket created with
// socketpair()).
//
// For abstract sockets, there are two incompatible ways of naming them; the man
// pages suggest using the entire `struct sockaddr_un` as the name, padding the
// unused parts of the sun_path field with zeroes; this corresponds to
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED. However, many programs instead just
// use a portion of sun_path, and pass an appropriate smaller length to bind()
// or connect(). This is G_UNIX_SOCKET_ADDRESS_ABSTRACT.
type UnixSocketAddressType int

const (
	// UnixSocketAddressTypeInvalid: invalid
	UnixSocketAddressTypeInvalid UnixSocketAddressType = 0
	// UnixSocketAddressTypeAnonymous: anonymous
	UnixSocketAddressTypeAnonymous UnixSocketAddressType = 1
	// UnixSocketAddressTypePath: a filesystem path
	UnixSocketAddressTypePath UnixSocketAddressType = 2
	// UnixSocketAddressTypeAbstract: an abstract name
	UnixSocketAddressTypeAbstract UnixSocketAddressType = 3
	// UnixSocketAddressTypeAbstractPadded: an abstract name, 0-padded to the
	// full length of a unix socket name
	UnixSocketAddressTypeAbstractPadded UnixSocketAddressType = 4
)

func marshalUnixSocketAddressType(p uintptr) (interface{}, error) {
	return UnixSocketAddressType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ZlibCompressorFormat: used to select the type of data format to use for
// Decompressor and Compressor.
type ZlibCompressorFormat int

const (
	// ZlibCompressorFormatZlib: deflate compression with zlib header
	ZlibCompressorFormatZlib ZlibCompressorFormat = 0
	// ZlibCompressorFormatGzip: gzip file format
	ZlibCompressorFormatGzip ZlibCompressorFormat = 1
	// ZlibCompressorFormatRaw: deflate compression with no header
	ZlibCompressorFormatRaw ZlibCompressorFormat = 2
)

func marshalZlibCompressorFormat(p uintptr) (interface{}, error) {
	return ZlibCompressorFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppInfoCreateFlags flags used when creating a Info.
type AppInfoCreateFlags int

const (
	// AppInfoCreateFlagsNone: no flags.
	AppInfoCreateFlagsNone AppInfoCreateFlags = 0b0
	// AppInfoCreateFlagsNeedsTerminal: application opens in a terminal window.
	AppInfoCreateFlagsNeedsTerminal AppInfoCreateFlags = 0b1
	// AppInfoCreateFlagsSupportsUris: application supports URI arguments.
	AppInfoCreateFlagsSupportsUris AppInfoCreateFlags = 0b10
	// AppInfoCreateFlagsSupportsStartupNotification: application supports
	// startup notification. Since 2.26
	AppInfoCreateFlagsSupportsStartupNotification AppInfoCreateFlags = 0b100
)

func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
	return AppInfoCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationFlags flags used to define the behaviour of a #GApplication.
type ApplicationFlags int

const (
	// ApplicationFlagsFlagsNone: default
	ApplicationFlagsFlagsNone ApplicationFlags = 0b0
	// ApplicationFlagsIsService: run as a service. In this mode, registration
	// fails if the service is already running, and the application will
	// initially wait up to 10 seconds for an initial activation message to
	// arrive.
	ApplicationFlagsIsService ApplicationFlags = 0b1
	// ApplicationFlagsIsLauncher: don't try to become the primary instance.
	ApplicationFlagsIsLauncher ApplicationFlags = 0b10
	// ApplicationFlagsHandlesOpen: this application handles opening files (in
	// the primary instance). Note that this flag only affects the default
	// implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
	ApplicationFlagsHandlesOpen ApplicationFlags = 0b100
	// ApplicationFlagsHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
	ApplicationFlagsHandlesCommandLine ApplicationFlags = 0b1000
	// ApplicationFlagsSendEnvironment: send the environment of the launching
	// process to the primary instance. Set this flag if your application is
	// expected to behave differently depending on certain environment
	// variables. For instance, an editor might be expected to use the
	// `GIT_COMMITTER_NAME` environment variable when editing a git commit
	// message. The environment is available to the #GApplication::command-line
	// signal handler, via g_application_command_line_getenv().
	ApplicationFlagsSendEnvironment ApplicationFlags = 0b10000
	// ApplicationFlagsNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID is
	// given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
	ApplicationFlagsNonUnique ApplicationFlags = 0b100000
	// ApplicationFlagsCanOverrideAppID: allow users to override the application
	// ID from the command line with `--gapplication-app-id`. Since: 2.48
	ApplicationFlagsCanOverrideAppID ApplicationFlags = 0b1000000
	// ApplicationFlagsAllowReplacement: allow another instance to take over the
	// bus name. Since: 2.60
	ApplicationFlagsAllowReplacement ApplicationFlags = 0b10000000
	// ApplicationFlagsReplace: take over from another instance. This flag is
	// usually set by passing `--gapplication-replace` on the commandline.
	// Since: 2.60
	ApplicationFlagsReplace ApplicationFlags = 0b100000000
)

func marshalApplicationFlags(p uintptr) (interface{}, error) {
	return ApplicationFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AskPasswordFlags PasswordFlags are used to request specific information from
// the user, or to notify the user of their choices in an authentication
// situation.
type AskPasswordFlags int

const (
	// AskPasswordFlagsNeedPassword: operation requires a password.
	AskPasswordFlagsNeedPassword AskPasswordFlags = 0b1
	// AskPasswordFlagsNeedUsername: operation requires a username.
	AskPasswordFlagsNeedUsername AskPasswordFlags = 0b10
	// AskPasswordFlagsNeedDomain: operation requires a domain.
	AskPasswordFlagsNeedDomain AskPasswordFlags = 0b100
	// AskPasswordFlagsSavingSupported: operation supports saving settings.
	AskPasswordFlagsSavingSupported AskPasswordFlags = 0b1000
	// AskPasswordFlagsAnonymousSupported: operation supports anonymous users.
	AskPasswordFlagsAnonymousSupported AskPasswordFlags = 0b10000
	// AskPasswordFlagsTcrypt: operation takes TCRYPT parameters (Since: 2.58)
	AskPasswordFlagsTcrypt AskPasswordFlags = 0b100000
)

func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
	return AskPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameOwnerFlags flags used in g_bus_own_name().
type BusNameOwnerFlags int

const (
	// BusNameOwnerFlagsNone: no flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0b0
	// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 0b1
	// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the
	// name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 0b10
	// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns the
	// name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54)
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 0b100
)

func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
	return BusNameOwnerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameWatcherFlags flags used in g_bus_watch_name().
type BusNameWatcherFlags int

const (
	// BusNameWatcherFlagsNone: no flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0b0
	// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 0b1
)

func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
	return BusNameWatcherFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterFlags flags used when calling a g_converter_convert().
type ConverterFlags int

const (
	// ConverterFlagsNone: no flags.
	ConverterFlagsNone ConverterFlags = 0b0
	// ConverterFlagsInputAtEnd: at end of input data
	ConverterFlagsInputAtEnd ConverterFlags = 0b1
	// ConverterFlagsFlush: flush data
	ConverterFlagsFlush ConverterFlags = 0b10
)

func marshalConverterFlags(p uintptr) (interface{}, error) {
	return ConverterFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCallFlags flags used in g_dbus_connection_call() and similar APIs.
type DBusCallFlags int

const (
	// DBusCallFlagsNone: no flags set.
	DBusCallFlagsNone DBusCallFlags = 0b0
	// DBusCallFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this method invocation.
	DBusCallFlagsNoAutoStart DBusCallFlags = 0b1
	// DBusCallFlagsAllowInteractiveAuthorization: the caller is prepared to
	// wait for interactive authorization. Since 2.46.
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 0b10
)

func marshalDBusCallFlags(p uintptr) (interface{}, error) {
	return DBusCallFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCapabilityFlags capabilities negotiated with the remote peer.
type DBusCapabilityFlags int

const (
	// DBusCapabilityFlagsNone: no flags set.
	DBusCapabilityFlagsNone DBusCapabilityFlags = 0b0
	// DBusCapabilityFlagsUnixFdPassing: the connection supports exchanging UNIX
	// file descriptors with the remote peer.
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 0b1
)

func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
	return DBusCapabilityFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusConnectionFlags flags used when creating a new BusConnection.
type DBusConnectionFlags int

const (
	// DBusConnectionFlagsNone: no flags set.
	DBusConnectionFlagsNone DBusConnectionFlags = 0b0
	// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
	DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 0b1
	// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
	DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 0b10
	// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 0b100
	// DBusConnectionFlagsMessageBusConnection pass this flag if connecting to a
	// peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
	DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 0b1000
	// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
	DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 0b10000
)

func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
	return DBusConnectionFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusInterfaceSkeletonFlags flags describing the behavior of a
// BusInterfaceSkeleton instance.
type DBusInterfaceSkeletonFlags int

const (
	// DBusInterfaceSkeletonFlagsNone: no flags set.
	DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0b0
	// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 0b1
)

func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
	return DBusInterfaceSkeletonFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageFlags: message flags used in BusMessage.
type DBusMessageFlags int

const (
	// DBusMessageFlagsNone: no flags set.
	DBusMessageFlagsNone DBusMessageFlags = 0b0
	// DBusMessageFlagsNoReplyExpected: a reply is not expected.
	DBusMessageFlagsNoReplyExpected DBusMessageFlags = 0b1
	// DBusMessageFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this message.
	DBusMessageFlagsNoAutoStart DBusMessageFlags = 0b10
	// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 0b100
)

func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
	return DBusMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusObjectManagerClientFlags flags used when constructing a
// BusObjectManagerClient.
type DBusObjectManagerClientFlags int

const (
	// DBusObjectManagerClientFlagsNone: no flags set.
	DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0b0
	// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager is
	// for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 0b1
)

func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
	return DBusObjectManagerClientFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusPropertyInfoFlags flags describing the access control of a D-Bus
// property.
type DBusPropertyInfoFlags int

const (
	// DBusPropertyInfoFlagsNone: no flags set.
	DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0b0
	// DBusPropertyInfoFlagsReadable: property is readable.
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 0b1
	// DBusPropertyInfoFlagsWritable: property is writable.
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 0b10
)

func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
	return DBusPropertyInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusProxyFlags flags used when constructing an instance of a BusProxy derived
// class.
type DBusProxyFlags int

const (
	// DBusProxyFlagsNone: no flags set.
	DBusProxyFlagsNone DBusProxyFlags = 0b0
	// DBusProxyFlagsDoNotLoadProperties: don't load properties.
	DBusProxyFlagsDoNotLoadProperties DBusProxyFlags = 0b1
	// DBusProxyFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
	DBusProxyFlagsDoNotConnectSignals DBusProxyFlags = 0b10
	// DBusProxyFlagsDoNotAutoStart: if the proxy is for a well-known name, do
	// not ask the bus to launch an owner during proxy initialization or a
	// method call. This flag is only meaningful in proxies for well-known
	// names.
	DBusProxyFlagsDoNotAutoStart DBusProxyFlags = 0b100
	// DBusProxyFlagsGetInvalidatedProperties: if set, the property value for
	// any __invalidated property__ will be (asynchronously) retrieved upon
	// receiving the `PropertiesChanged`
	// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
	DBusProxyFlagsGetInvalidatedProperties DBusProxyFlags = 0b1000
	// DBusProxyFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call. This
	// flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
	DBusProxyFlagsDoNotAutoStartAtConstruction DBusProxyFlags = 0b10000
)

func marshalDBusProxyFlags(p uintptr) (interface{}, error) {
	return DBusProxyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSendMessageFlags flags used when sending BusMessages on a BusConnection.
type DBusSendMessageFlags int

const (
	// DBusSendMessageFlagsNone: no flags set.
	DBusSendMessageFlagsNone DBusSendMessageFlags = 0b0
	// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 0b1
)

func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
	return DBusSendMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusServerFlags flags used when creating a BusServer.
type DBusServerFlags int

const (
	// DBusServerFlagsNone: no flags set.
	DBusServerFlagsNone DBusServerFlags = 0b0
	// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
	DBusServerFlagsRunInThread DBusServerFlags = 0b1
	// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 0b10
)

func marshalDBusServerFlags(p uintptr) (interface{}, error) {
	return DBusServerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSignalFlags flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
type DBusSignalFlags int

const (
	// DBusSignalFlagsNone: no flags set.
	DBusSignalFlagsNone DBusSignalFlags = 0b0
	// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
	DBusSignalFlagsNoMatchRule DBusSignalFlags = 0b1
	// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 0b10
	// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
	DBusSignalFlagsMatchArg0Path DBusSignalFlags = 0b100
)

func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
	return DBusSignalFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSubtreeFlags flags passed to g_dbus_connection_register_subtree().
type DBusSubtreeFlags int

const (
	// DBusSubtreeFlagsNone: no flags set.
	DBusSubtreeFlagsNone DBusSubtreeFlags = 0b0
	// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 0b1
)

func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
	return DBusSubtreeFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartFlags flags used when starting a drive.
type DriveStartFlags int

const (
	// DriveStartFlagsNone: no flags set.
	DriveStartFlagsNone DriveStartFlags = 0b0
)

func marshalDriveStartFlags(p uintptr) (interface{}, error) {
	return DriveStartFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeInfoFlags flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags int

const (
	// FileAttributeInfoFlagsNone: no flags set.
	FileAttributeInfoFlagsNone FileAttributeInfoFlags = 0b0
	// FileAttributeInfoFlagsCopyWithFile: copy the attribute values when the
	// file is copied.
	FileAttributeInfoFlagsCopyWithFile FileAttributeInfoFlags = 0b1
	// FileAttributeInfoFlagsCopyWhenMoved: copy the attribute values when the
	// file is moved.
	FileAttributeInfoFlagsCopyWhenMoved FileAttributeInfoFlags = 0b10
)

func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
	return FileAttributeInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCopyFlags flags used when copying or moving files.
type FileCopyFlags int

const (
	// FileCopyFlagsNone: no flags set.
	FileCopyFlagsNone FileCopyFlags = 0b0
	// FileCopyFlagsOverwrite: overwrite any existing files
	FileCopyFlagsOverwrite FileCopyFlags = 0b1
	// FileCopyFlagsBackup: make a backup of any existing files.
	FileCopyFlagsBackup FileCopyFlags = 0b10
	// FileCopyFlagsNofollowSymlinks: don't follow symlinks.
	FileCopyFlagsNofollowSymlinks FileCopyFlags = 0b100
	// FileCopyFlagsAllMetadata: copy all file metadata instead of just default
	// set used for copy (see Info).
	FileCopyFlagsAllMetadata FileCopyFlags = 0b1000
	// FileCopyFlagsNoFallbackForMove: don't use copy and delete fallback if
	// native move not supported.
	FileCopyFlagsNoFallbackForMove FileCopyFlags = 0b10000
	// FileCopyFlagsTargetDefaultPerms leaves target file with default perms,
	// instead of setting the source file perms.
	FileCopyFlagsTargetDefaultPerms FileCopyFlags = 0b100000
)

func marshalFileCopyFlags(p uintptr) (interface{}, error) {
	return FileCopyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCreateFlags flags used when an operation may create a file.
type FileCreateFlags int

const (
	// FileCreateFlagsNone: no flags set.
	FileCreateFlagsNone FileCreateFlags = 0b0
	// FileCreateFlagsPrivate: create a file that can only be accessed by the
	// current user.
	FileCreateFlagsPrivate FileCreateFlags = 0b1
	// FileCreateFlagsReplaceDestination: replace the destination as if it
	// didn't exist before. Don't try to keep any old permissions, replace
	// instead of following links. This is generally useful if you're doing a
	// "copy over" rather than a "save new version of" replace operation. You
	// can think of it as "unlink destination" before writing to it, although
	// the implementation may not be exactly like that. This flag can only be
	// used with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20
	FileCreateFlagsReplaceDestination FileCreateFlags = 0b10
)

func marshalFileCreateFlags(p uintptr) (interface{}, error) {
	return FileCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMeasureFlags flags that can be used with g_file_measure_disk_usage().
type FileMeasureFlags int

const (
	// FileMeasureFlagsNone: no flags set.
	FileMeasureFlagsNone FileMeasureFlags = 0b0
	// FileMeasureFlagsReportAnyError: report any error encountered while
	// traversing the directory tree. Normally errors are only reported for the
	// toplevel file.
	FileMeasureFlagsReportAnyError FileMeasureFlags = 0b10
	// FileMeasureFlagsApparentSize: tally usage based on apparent file sizes.
	// Normally, the block-size is used, if available, as this is a more
	// accurate representation of disk space used. Compare with `du
	// --apparent-size`.
	FileMeasureFlagsApparentSize FileMeasureFlags = 0b100
	// FileMeasureFlagsNoXdev: do not cross mount point boundaries. Compare with
	// `du -x`.
	FileMeasureFlagsNoXdev FileMeasureFlags = 0b1000
)

func marshalFileMeasureFlags(p uintptr) (interface{}, error) {
	return FileMeasureFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorFlags flags used to set what a Monitor will watch for.
type FileMonitorFlags int

const (
	// FileMonitorFlagsNone: no flags set.
	FileMonitorFlagsNone FileMonitorFlags = 0b0
	// FileMonitorFlagsWatchMounts: watch for mount events.
	FileMonitorFlagsWatchMounts FileMonitorFlags = 0b1
	// FileMonitorFlagsSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorFlagsSendMoved FileMonitorFlags = 0b10
	// FileMonitorFlagsWatchHardLinks: watch for changes to the file made via
	// another hard link. Since 2.36.
	FileMonitorFlagsWatchHardLinks FileMonitorFlags = 0b100
	// FileMonitorFlagsWatchMoves: watch for rename operations on a monitored
	// directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
	FileMonitorFlagsWatchMoves FileMonitorFlags = 0b1000
)

func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
	return FileMonitorFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileQueryInfoFlags flags used when querying a Info.
type FileQueryInfoFlags int

const (
	// FileQueryInfoFlagsNone: no flags set.
	FileQueryInfoFlagsNone FileQueryInfoFlags = 0b0
	// FileQueryInfoFlagsNofollowSymlinks: don't follow symlinks.
	FileQueryInfoFlagsNofollowSymlinks FileQueryInfoFlags = 0b1
)

func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
	return FileQueryInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOStreamSpliceFlags gIOStreamSpliceFlags determine how streams should be
// spliced.
type IOStreamSpliceFlags int

const (
	// IOStreamSpliceFlagsNone: do not close either stream.
	IOStreamSpliceFlagsNone IOStreamSpliceFlags = 0b0
	// IOStreamSpliceFlagsCloseStream1: close the first stream after the splice.
	IOStreamSpliceFlagsCloseStream1 IOStreamSpliceFlags = 0b1
	// IOStreamSpliceFlagsCloseStream2: close the second stream after the
	// splice.
	IOStreamSpliceFlagsCloseStream2 IOStreamSpliceFlags = 0b10
	// IOStreamSpliceFlagsWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
	IOStreamSpliceFlagsWaitForBoth IOStreamSpliceFlags = 0b100
)

func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
	return IOStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountMountFlags flags used when mounting a mount.
type MountMountFlags int

const (
	// MountMountFlagsNone: no flags set.
	MountMountFlagsNone MountMountFlags = 0b0
)

func marshalMountMountFlags(p uintptr) (interface{}, error) {
	return MountMountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountUnmountFlags flags used when an unmounting a mount.
type MountUnmountFlags int

const (
	// MountUnmountFlagsNone: no flags set.
	MountUnmountFlagsNone MountUnmountFlags = 0b0
	// MountUnmountFlagsForce: unmount even if there are outstanding file
	// operations on the mount.
	MountUnmountFlagsForce MountUnmountFlags = 0b1
)

func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
	return MountUnmountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// OutputStreamSpliceFlags gOutputStreamSpliceFlags determine how streams should
// be spliced.
type OutputStreamSpliceFlags int

const (
	// OutputStreamSpliceFlagsNone: do not close either stream.
	OutputStreamSpliceFlagsNone OutputStreamSpliceFlags = 0b0
	// OutputStreamSpliceFlagsCloseSource: close the source stream after the
	// splice.
	OutputStreamSpliceFlagsCloseSource OutputStreamSpliceFlags = 0b1
	// OutputStreamSpliceFlagsCloseTarget: close the target stream after the
	// splice.
	OutputStreamSpliceFlagsCloseTarget OutputStreamSpliceFlags = 0b10
)

func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
	return OutputStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverNameLookupFlags flags to modify lookup behavior.
type ResolverNameLookupFlags int

const (
	// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name())
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0b0
	// ResolverNameLookupFlagsIpv4Only: only resolve ipv4 addresses
	ResolverNameLookupFlagsIpv4Only ResolverNameLookupFlags = 0b1
	// ResolverNameLookupFlagsIpv6Only: only resolve ipv6 addresses
	ResolverNameLookupFlagsIpv6Only ResolverNameLookupFlags = 0b10
)

func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
	return ResolverNameLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceFlags gResourceFlags give information about a particular file inside
// a resource bundle.
type ResourceFlags int

const (
	// ResourceFlagsNone: no flags set.
	ResourceFlagsNone ResourceFlags = 0b0
	// ResourceFlagsCompressed: the file is compressed.
	ResourceFlagsCompressed ResourceFlags = 0b1
)

func marshalResourceFlags(p uintptr) (interface{}, error) {
	return ResourceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceLookupFlags gResourceLookupFlags determine how resource path lookups
// are handled.
type ResourceLookupFlags int

const (
	// ResourceLookupFlagsNone: no flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0b0
)

func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
	return ResourceLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SettingsBindFlags flags used when creating a binding. These flags determine
// in which direction the binding works. The default is to synchronize in both
// directions.
type SettingsBindFlags int

const (
	// SettingsBindFlagsDefault: equivalent to
	// `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
	SettingsBindFlagsDefault SettingsBindFlags = 0b0
	// SettingsBindFlagsGet: update the #GObject property when the setting
	// changes. It is an error to use this flag if the property is not writable.
	SettingsBindFlagsGet SettingsBindFlags = 0b1
	// SettingsBindFlagsSet: update the setting when the #GObject property
	// changes. It is an error to use this flag if the property is not readable.
	SettingsBindFlagsSet SettingsBindFlags = 0b10
	// SettingsBindFlagsNoSensitivity: do not try to bind a "sensitivity"
	// property to the writability of the setting
	SettingsBindFlagsNoSensitivity SettingsBindFlags = 0b100
	// SettingsBindFlagsGetNoChanges: when set in addition to SETTINGS_BIND_GET,
	// set the #GObject property value initially from the setting, but do not
	// listen for changes of the setting
	SettingsBindFlagsGetNoChanges SettingsBindFlags = 0b1000
	// SettingsBindFlagsInvertBoolean: when passed to g_settings_bind(), uses a
	// pair of mapping functions that invert the boolean value when mapping
	// between the setting and the property. The setting and property must both
	// be booleans. You cannot pass this flag to g_settings_bind_with_mapping().
	SettingsBindFlagsInvertBoolean SettingsBindFlags = 0b10000
)

func marshalSettingsBindFlags(p uintptr) (interface{}, error) {
	return SettingsBindFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketMsgFlags flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
type SocketMsgFlags int

const (
	// SocketMsgFlagsNone: no flags.
	SocketMsgFlagsNone SocketMsgFlags = 0b0
	// SocketMsgFlagsOob: request to send/receive out of band data.
	SocketMsgFlagsOob SocketMsgFlags = 0b1
	// SocketMsgFlagsPeek: read data from the socket without removing it from
	// the queue.
	SocketMsgFlagsPeek SocketMsgFlags = 0b10
	// SocketMsgFlagsDontroute: don't use a gateway to send out the packet, only
	// send to hosts on directly connected networks.
	SocketMsgFlagsDontroute SocketMsgFlags = 0b100
)

func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
	return SocketMsgFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubprocessFlags flags to define the behaviour of a #GSubprocess.
//
// Note that the default for stdin is to redirect from `/dev/null`. For stdout
// and stderr the default are for them to inherit the corresponding descriptor
// from the calling process.
//
// Note that it is a programmer error to mix 'incompatible' flags. For example,
// you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
type SubprocessFlags int

const (
	// SubprocessFlagsNone: no flags.
	SubprocessFlagsNone SubprocessFlags = 0b0
	// SubprocessFlagsStdinPipe: create a pipe for the stdin of the spawned
	// process that can be accessed with g_subprocess_get_stdin_pipe().
	SubprocessFlagsStdinPipe SubprocessFlags = 0b1
	// SubprocessFlagsStdinInherit: stdin is inherited from the calling process.
	SubprocessFlagsStdinInherit SubprocessFlags = 0b10
	// SubprocessFlagsStdoutPipe: create a pipe for the stdout of the spawned
	// process that can be accessed with g_subprocess_get_stdout_pipe().
	SubprocessFlagsStdoutPipe SubprocessFlags = 0b100
	// SubprocessFlagsStdoutSilence: silence the stdout of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStdoutSilence SubprocessFlags = 0b1000
	// SubprocessFlagsStderrPipe: create a pipe for the stderr of the spawned
	// process that can be accessed with g_subprocess_get_stderr_pipe().
	SubprocessFlagsStderrPipe SubprocessFlags = 0b10000
	// SubprocessFlagsStderrSilence: silence the stderr of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStderrSilence SubprocessFlags = 0b100000
	// SubprocessFlagsStderrMerge: merge the stderr of the spawned process with
	// whatever the stdout happens to be. This is a good way of directing both
	// streams to a common log file, for example.
	SubprocessFlagsStderrMerge SubprocessFlags = 0b1000000
	// SubprocessFlagsInheritFds: spawned processes will inherit the file
	// descriptors of their parent, unless those descriptors have been
	// explicitly marked as close-on-exec. This flag has no effect over the
	// "standard" file descriptors (stdin, stdout, stderr).
	SubprocessFlagsInheritFds SubprocessFlags = 0b10000000
)

func marshalSubprocessFlags(p uintptr) (interface{}, error) {
	return SubprocessFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TestDBusFlags flags to define future DBus behaviour.
type TestDBusFlags int

const (
	// TestDBusFlagsNone: no flags.
	TestDBusFlagsNone TestDBusFlags = 0b0
)

func marshalTestDBusFlags(p uintptr) (interface{}, error) {
	return TestDBusFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSCertificateFlags: a set of flags describing TLS certification validation.
// This can be used to set which validation steps to perform (eg, with
// g_tls_client_connection_set_validation_flags()), or to describe why a
// particular certificate was rejected (eg, in Connection::accept-certificate).
type TLSCertificateFlags int

const (
	// TLSCertificateFlagsUnknownCa: the signing certificate authority is not
	// known.
	TLSCertificateFlagsUnknownCa TLSCertificateFlags = 0b1
	// TLSCertificateFlagsBadIdentity: the certificate does not match the
	// expected identity of the site that it was retrieved from.
	TLSCertificateFlagsBadIdentity TLSCertificateFlags = 0b10
	// TLSCertificateFlagsNotActivated: the certificate's activation time is
	// still in the future
	TLSCertificateFlagsNotActivated TLSCertificateFlags = 0b100
	// TLSCertificateFlagsExpired: the certificate has expired
	TLSCertificateFlagsExpired TLSCertificateFlags = 0b1000
	// TLSCertificateFlagsRevoked: the certificate has been revoked according to
	// the Connection's certificate revocation list.
	TLSCertificateFlagsRevoked TLSCertificateFlags = 0b10000
	// TLSCertificateFlagsInsecure: the certificate's algorithm is considered
	// insecure.
	TLSCertificateFlagsInsecure TLSCertificateFlags = 0b100000
	// TLSCertificateFlagsGenericError: some other error occurred validating the
	// certificate
	TLSCertificateFlagsGenericError TLSCertificateFlags = 0b1000000
	// TLSCertificateFlagsValidateAll: the combination of all of the above flags
	TLSCertificateFlagsValidateAll TLSCertificateFlags = 0b1111111
)

func marshalTLSCertificateFlags(p uintptr) (interface{}, error) {
	return TLSCertificateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSDatabaseVerifyFlags flags for g_tls_database_verify_chain().
type TLSDatabaseVerifyFlags int

const (
	// TLSDatabaseVerifyFlagsNone: no verification flags
	TLSDatabaseVerifyFlagsNone TLSDatabaseVerifyFlags = 0b0
)

func marshalTLSDatabaseVerifyFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseVerifyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSPasswordFlags various flags for the password.
type TLSPasswordFlags int

const (
	// TLSPasswordFlagsNone: no flags
	TLSPasswordFlagsNone TLSPasswordFlags = 0b0
	// TLSPasswordFlagsRetry: the password was wrong, and the user should retry.
	TLSPasswordFlagsRetry TLSPasswordFlags = 0b10
	// TLSPasswordFlagsManyTries: hint to the user that the password has been
	// wrong many times, and the user may not have many chances left.
	TLSPasswordFlagsManyTries TLSPasswordFlags = 0b100
	// TLSPasswordFlagsFinalTry: hint to the user that this is the last try to
	// get this password right.
	TLSPasswordFlagsFinalTry TLSPasswordFlags = 0b1000
)

func marshalTLSPasswordFlags(p uintptr) (interface{}, error) {
	return TLSPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor interface {
	gextras.Objector
}

// appInfoMonitor implements the AppInfoMonitor interface.
type appInfoMonitor struct {
	gextras.Objector
}

var _ AppInfoMonitor = (*appInfoMonitor)(nil)

// WrapAppInfoMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppInfoMonitor(obj *externglib.Object) AppInfoMonitor {
	return AppInfoMonitor{
		Objector: obj,
	}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppInfoMonitor(obj), nil
}

// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
type BytesIcon interface {
	gextras.Objector
	Icon
	LoadableIcon

	// Bytes gets the #GBytes associated with the given @icon.
	Bytes() *glib.Bytes
}

// bytesIcon implements the BytesIcon interface.
type bytesIcon struct {
	gextras.Objector
	Icon
	LoadableIcon
}

var _ BytesIcon = (*bytesIcon)(nil)

// WrapBytesIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapBytesIcon(obj *externglib.Object) BytesIcon {
	return BytesIcon{
		Objector:     obj,
		Icon:         WrapIcon(obj),
		LoadableIcon: WrapLoadableIcon(obj),
	}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBytesIcon(obj), nil
}

// NewBytesIcon constructs a class BytesIcon.
func NewBytesIcon(bytes *glib.Bytes) BytesIcon {
	var arg1 *C.GBytes

	arg1 = (*C.GBytes)(unsafe.Pointer(bytes.Native()))

	var cret C.GBytesIcon
	var ret1 BytesIcon

	cret = C.g_bytes_icon_new(bytes)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(BytesIcon)

	return ret1
}

// Bytes gets the #GBytes associated with the given @icon.
func (i bytesIcon) Bytes() *glib.Bytes {
	var arg0 *C.GBytesIcon

	arg0 = (*C.GBytesIcon)(unsafe.Pointer(i.Native()))

	var cret *C.GBytes
	var ret1 *glib.Bytes

	cret = C.g_bytes_icon_get_bytes(arg0)

	ret1 = glib.WrapBytes(unsafe.Pointer(cret))

	return ret1
}

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup interface {
	gextras.Objector
	ActionGroup
	RemoteActionGroup
}

// dBusActionGroup implements the DBusActionGroup interface.
type dBusActionGroup struct {
	gextras.Objector
	ActionGroup
	RemoteActionGroup
}

var _ DBusActionGroup = (*dBusActionGroup)(nil)

// WrapDBusActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusActionGroup(obj *externglib.Object) DBusActionGroup {
	return DBusActionGroup{
		Objector:          obj,
		ActionGroup:       WrapActionGroup(obj),
		RemoteActionGroup: WrapRemoteActionGroup(obj),
	}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusActionGroup(obj), nil
}

// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
type DBusAuthObserver interface {
	gextras.Objector

	// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
	// @observer.
	AllowMechanism(mechanism string) bool
	// AuthorizeAuthenticatedPeer emits the
	// BusAuthObserver::authorize-authenticated-peer signal on @observer.
	AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool
}

// dBusAuthObserver implements the DBusAuthObserver interface.
type dBusAuthObserver struct {
	gextras.Objector
}

var _ DBusAuthObserver = (*dBusAuthObserver)(nil)

// WrapDBusAuthObserver wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusAuthObserver(obj *externglib.Object) DBusAuthObserver {
	return DBusAuthObserver{
		Objector: obj,
	}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusAuthObserver(obj), nil
}

// NewDBusAuthObserver constructs a class DBusAuthObserver.
func NewDBusAuthObserver() DBusAuthObserver {
	var cret C.GDBusAuthObserver
	var ret1 DBusAuthObserver

	cret = C.g_dbus_auth_observer_new()

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusAuthObserver)

	return ret1
}

// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
// @observer.
func (o dBusAuthObserver) AllowMechanism(mechanism string) bool {
	var arg0 *C.GDBusAuthObserver
	var arg1 *C.gchar

	arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	arg1 = (*C.gchar)(C.CString(mechanism))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_dbus_auth_observer_allow_mechanism(arg0, mechanism)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// AuthorizeAuthenticatedPeer emits the
// BusAuthObserver::authorize-authenticated-peer signal on @observer.
func (o dBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool {
	var arg0 *C.GDBusAuthObserver
	var arg1 *C.GIOStream
	var arg2 *C.GCredentials

	arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	arg2 = (*C.GCredentials)(unsafe.Pointer(credentials.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_dbus_auth_observer_authorize_authenticated_peer(arg0, stream, credentials)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
//
// An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
//
// An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
//
// An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
//
// An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection interface {
	gextras.Objector
	AsyncInitable
	Initable

	// AddFilter adds a message filter. Filters are handlers that are run on all
	// incoming and outgoing messages, prior to standard dispatch. Filters are
	// run in the order that they were added. The same handler can be added as a
	// filter more than once, in which case it will be run more than once.
	// Filters added during a filter callback won't be run on the message being
	// processed. Filter functions are allowed to modify and even drop messages.
	//
	// Note that filters are run in a dedicated message handling thread so they
	// can't block and, generally, can't do anything but signal a worker thread.
	// Also note that filters are rarely needed - use API such as
	// g_dbus_connection_send_message_with_reply(),
	// g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
	//
	// If a filter consumes an incoming message the message is not dispatched
	// anywhere else - not even the standard dispatch machinery (that API such
	// as g_dbus_connection_signal_subscribe() and
	// g_dbus_connection_send_message_with_reply() relies on) will see the
	// message. Similarly, if a filter consumes an outgoing message, the message
	// will not be sent to the other peer.
	//
	// If @user_data_free_func is non-nil, it will be called (in the
	// thread-default main context of the thread you are calling this method
	// from) at some point after @user_data is no longer needed. (It is not
	// guaranteed to be called synchronously when the filter is removed, and may
	// be called after @connection has been destroyed.)
	AddFilter(filterFunction DBusMessageFilterFunction) uint
	// Call: asynchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type. Unless its G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple
	// containing one or more values.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//    g_dbus_connection_call (connection,
	//                            "org.freedesktop.StringThings",
	//                            "/org/freedesktop/StringThings",
	//                            "org.freedesktop.StringThings",
	//                            "TwoStrings",
	//                            g_variant_new ("(ss)",
	//                                           "Thing One",
	//                                           "Thing Two"),
	//                            NULL,
	//                            G_DBUS_CALL_FLAGS_NONE,
	//                            -1,
	//                            NULL,
	//                            (GAsyncReadyCallback) two_strings_done,
	//                            NULL);
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_call_finish() to get the result of the operation. See
	// g_dbus_connection_call_sync() for the synchronous version of this
	// function.
	//
	// If @callback is nil then the D-Bus method call message will be sent with
	// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
	Call(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)
	// CallFinish finishes an operation started with g_dbus_connection_call().
	CallFinish(res AsyncResult) (variant *glib.Variant, err error)
	// CallSync: synchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//    g_dbus_connection_call_sync (connection,
	//                                 "org.freedesktop.StringThings",
	//                                 "/org/freedesktop/StringThings",
	//                                 "org.freedesktop.StringThings",
	//                                 "TwoStrings",
	//                                 g_variant_new ("(ss)",
	//                                                "Thing One",
	//                                                "Thing Two"),
	//                                 NULL,
	//                                 G_DBUS_CALL_FLAGS_NONE,
	//                                 -1,
	//                                 NULL,
	//                                 &error);
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_connection_call() for the asynchronous version of this method.
	CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (variant *glib.Variant, err error)
	// CallWithUnixFdList: like g_dbus_connection_call() but also takes a FDList
	// object.
	//
	// This method is only available on UNIX.
	CallWithUnixFdList(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)
	// CallWithUnixFdListFinish finishes an operation started with
	// g_dbus_connection_call_with_unix_fd_list().
	CallWithUnixFdListFinish(res AsyncResult) (outFdList UnixFDList, variant *glib.Variant, err error)
	// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes
	// and returns FDList objects.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant, err error)
	// Close closes @connection. Note that this never causes the process to exit
	// (this might only happen if the other end of a shared message bus
	// connection disconnects, see BusConnection:exit-on-close).
	//
	// Once the connection is closed, operations such as sending a message will
	// return with the error G_IO_ERROR_CLOSED. Closing a connection will not
	// automatically flush the connection so queued messages may be lost. Use
	// g_dbus_connection_flush() if you need such guarantees.
	//
	// If @connection is already closed, this method fails with
	// G_IO_ERROR_CLOSED.
	//
	// When @connection has been closed, the BusConnection::closed signal is
	// emitted in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread that
	// @connection was constructed in.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_close_finish() to get the result of the operation. See
	// g_dbus_connection_close_sync() for the synchronous version.
	Close(cancellable Cancellable, callback AsyncReadyCallback)
	// CloseFinish finishes an operation started with g_dbus_connection_close().
	CloseFinish(res AsyncResult) error
	// CloseSync: synchronously closes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_close() for the
	// asynchronous version of this method and more details about what it does.
	CloseSync(cancellable Cancellable) error
	// EmitSignal emits a signal.
	//
	// If the parameters GVariant is floating, it is consumed.
	//
	// This can only fail if @parameters is not compatible with the D-Bus
	// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
	// (G_IO_ERROR_CLOSED).
	EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error
	// ExportActionGroup exports @action_group on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// A given object path can only have one action group exported on it. If
	// this constraint is violated, the export will fail and 0 will be returned
	// (with @error set accordingly).
	//
	// You can unexport the action group using
	// g_dbus_connection_unexport_action_group() with the return value of this
	// function.
	//
	// The thread default main context is taken at the time of this call. All
	// incoming action activations and state change requests are reported from
	// this context. Any changes on the action group that cause it to emit
	// signals must also come from this same context. Since incoming action
	// activations and state change requests are rather likely to cause changes
	// on the action group, this effectively limits a given action group to
	// being exported from only one main context.
	ExportActionGroup(objectPath string, actionGroup ActionGroup) (guint uint, err error)
	// ExportMenuModel exports @menu on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// An object path can only have one menu model exported on it. If this
	// constraint is violated, the export will fail and 0 will be returned (with
	// @error set accordingly).
	//
	// You can unexport the menu model using
	// g_dbus_connection_unexport_menu_model() with the return value of this
	// function.
	ExportMenuModel(objectPath string, menu MenuModel) (guint uint, err error)
	// Flush: asynchronously flushes @connection, that is, writes all queued
	// outgoing message to the transport and then flushes the transport (using
	// g_output_stream_flush_async()). This is useful in programs that wants to
	// emit a D-Bus signal and then exit immediately. Without flushing the
	// connection, there is no guaranteed that the message has been sent to the
	// networking buffers in the OS kernel.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_flush_finish() to get the result of the operation. See
	// g_dbus_connection_flush_sync() for the synchronous version.
	Flush(cancellable Cancellable, callback AsyncReadyCallback)
	// FlushFinish finishes an operation started with g_dbus_connection_flush().
	FlushFinish(res AsyncResult) error
	// FlushSync: synchronously flushes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_flush() for the
	// asynchronous version of this method and more details about what it does.
	FlushSync(cancellable Cancellable) error
	// Capabilities gets the capabilities negotiated with the remote peer
	Capabilities() DBusCapabilityFlags
	// ExitOnClose gets whether the process is terminated when @connection is
	// closed by the remote peer. See BusConnection:exit-on-close for more
	// details.
	ExitOnClose() bool
	// Flags gets the flags used to construct this connection
	Flags() DBusConnectionFlags
	// Guid: the GUID of the peer performing the role of server when
	// authenticating. See BusConnection:guid for more details.
	Guid() string
	// LastSerial retrieves the last serial number assigned to a BusMessage on
	// the current thread. This includes messages sent via both low-level API
	// such as g_dbus_connection_send_message() as well as high-level API such
	// as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
	// g_dbus_proxy_call().
	LastSerial() uint32
	// PeerCredentials gets the credentials of the authenticated peer. This will
	// always return nil unless @connection acted as a server (e.g.
	// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and
	// the client passed credentials as part of the authentication process.
	//
	// In a message bus setup, the message bus is always the server and each
	// application is a client. So this method will always return nil for
	// message bus clients.
	PeerCredentials() Credentials
	// Stream gets the underlying stream used for IO.
	//
	// While the BusConnection is active, it will interact with this stream from
	// a worker thread, so it is not safe to interact with the stream directly.
	Stream() IOStream
	// UniqueName gets the unique name of @connection as assigned by the message
	// bus. This can also be used to figure out if @connection is a message bus
	// connection.
	UniqueName() string
	// IsClosed gets whether @connection is closed.
	IsClosed() bool
	// RemoveFilter removes a filter.
	//
	// Note that since filters run in a different thread, there is a race
	// condition where it is possible that the filter will be running even after
	// calling g_dbus_connection_remove_filter(), so you cannot just free data
	// that the filter might be using. Instead, you should pass a Notify to
	// g_dbus_connection_add_filter(), which will be called when it is
	// guaranteed that the data is no longer needed.
	RemoveFilter(filterID uint)
	// SendMessage: asynchronously sends @message to the peer represented by
	// @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @message is not well-formed, the operation fails
	// with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessage(message DBusMessage, flags DBusSendMessageFlags) (outSerial uint32, err error)
	// SendMessageWithReply: asynchronously sends @message to the peer
	// represented by @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_send_message_with_reply_finish() to get the result of
	// the operation. See g_dbus_connection_send_message_with_reply_sync() for
	// the synchronous version.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	SendMessageWithReply(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32
	// SendMessageWithReplyFinish finishes an operation started with
	// g_dbus_connection_send_message_with_reply().
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	SendMessageWithReplyFinish(res AsyncResult) (dBusMessage DBusMessage, err error)
	// SendMessageWithReplySync: synchronously sends @message to the peer
	// represented by @connection and blocks the calling thread until a reply is
	// received or the timeout is reached. See
	// g_dbus_connection_send_message_with_reply() for the asynchronous version
	// of this method.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (outSerial uint32, dBusMessage DBusMessage, err error)
	// SetExitOnClose sets whether the process should be terminated when
	// @connection is closed by the remote peer. See BusConnection:exit-on-close
	// for more details.
	//
	// Note that this function should be used with care. Most modern UNIX
	// desktops tie the notion of a user session with the session bus, and
	// expect all of a user's applications to quit when their bus connection
	// goes away. If you are setting @exit_on_close to false for the shared
	// session bus connection, you should make sure that your application exits
	// when the user session ends.
	SetExitOnClose(exitOnClose bool)
	// SignalSubscribe subscribes to signals on @connection and invokes
	// @callback with a whenever the signal is received. Note that @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from.
	//
	// If @connection is not a message bus connection, @sender must be nil.
	//
	// If @sender is a well-known name note that @callback is invoked with the
	// unique name for the owner of @sender, not the well-known name as one
	// would expect. This is because the message bus rewrites the name. As such,
	// to avoid certain race conditions, users should be tracking the name owner
	// of the well-known name and use that when processing the received signal.
	//
	// If one of G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
	// G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is interpreted as
	// part of a namespace or path. The first argument of a signal is matched
	// against that part as specified by D-Bus.
	//
	// If @user_data_free_func is non-nil, it will be called (in the
	// thread-default main context of the thread you are calling this method
	// from) at some point after @user_data is no longer needed. (It is not
	// guaranteed to be called synchronously when the signal is unsubscribed
	// from, and may be called after @connection has been destroyed.)
	//
	// As @callback is potentially invoked in a different thread from where its
	// emitted, its possible for this to happen after
	// g_dbus_connection_signal_unsubscribe() has been called in another thread.
	// Due to this, @user_data should have a strong reference which is freed
	// with @user_data_free_func, rather than pointing to data whose lifecycle
	// is tied to the signal subscription. For example, if a #GObject is used to
	// store the subscription ID from g_dbus_connection_signal_subscribe(), a
	// strong reference to that #GObject must be passed to @user_data, and
	// g_object_unref() passed to @user_data_free_func. You are responsible for
	// breaking the resulting reference count cycle by explicitly unsubscribing
	// from the signal when dropping the last external reference to the
	// #GObject. Alternatively, a weak reference may be used.
	//
	// It is guaranteed that if you unsubscribe from a signal using
	// g_dbus_connection_signal_unsubscribe() from the same thread which made
	// the corresponding g_dbus_connection_signal_subscribe() call, @callback
	// will not be invoked after g_dbus_connection_signal_unsubscribe() returns.
	//
	// The returned subscription identifier is an opaque value which is
	// guaranteed to never be zero.
	//
	// This function can never fail.
	SignalSubscribe(sender string, interfaceName string, member string, objectPath string, arg0 string, flags DBusSignalFlags, callback DBusSignalCallback) uint
	// SignalUnsubscribe unsubscribes from signals.
	//
	// Note that there may still be D-Bus traffic to process (relating to this
	// signal subscription) in the current thread-default Context after this
	// function has returned. You should continue to iterate the Context until
	// the Notify function passed to g_dbus_connection_signal_subscribe() is
	// called, in order to avoid memory leaks through callbacks queued on the
	// Context after its stopped being iterated.
	SignalUnsubscribe(subscriptionID uint)
	// StartMessageProcessing: if @connection was created with
	// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
	// processing messages. Does nothing on if @connection wasn't created with
	// this flag or if the method has already been called.
	StartMessageProcessing()
	// UnexportActionGroup reverses the effect of a previous call to
	// g_dbus_connection_export_action_group().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_action_group() or to call it with the same ID
	// more than once.
	UnexportActionGroup(exportID uint)
	// UnexportMenuModel reverses the effect of a previous call to
	// g_dbus_connection_export_menu_model().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_menu_model() or to call it with the same ID more
	// than once.
	UnexportMenuModel(exportID uint)
	// UnregisterObject unregisters an object.
	UnregisterObject(registrationID uint) bool
	// UnregisterSubtree unregisters a subtree.
	UnregisterSubtree(registrationID uint) bool
}

// dBusConnection implements the DBusConnection interface.
type dBusConnection struct {
	gextras.Objector
	AsyncInitable
	Initable
}

var _ DBusConnection = (*dBusConnection)(nil)

// WrapDBusConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusConnection(obj *externglib.Object) DBusConnection {
	return DBusConnection{
		Objector:      obj,
		AsyncInitable: WrapAsyncInitable(obj),
		Initable:      WrapInitable(obj),
	}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusConnection(obj), nil
}

// NewDBusConnectionFinish constructs a class DBusConnection.
func NewDBusConnectionFinish(res AsyncResult) (dBusConnection DBusConnection, err error) {
	var arg1 *C.GAsyncResult

	arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var errout *C.GError
	var goerr error
	var cret C.GDBusConnection
	var ret2 DBusConnection

	cret = C.g_dbus_connection_new_finish(res, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusConnection)

	return goerr, ret2
}

// NewDBusConnectionForAddressFinish constructs a class DBusConnection.
func NewDBusConnectionForAddressFinish(res AsyncResult) (dBusConnection DBusConnection, err error) {
	var arg1 *C.GAsyncResult

	arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var errout *C.GError
	var goerr error
	var cret C.GDBusConnection
	var ret2 DBusConnection

	cret = C.g_dbus_connection_new_for_address_finish(res, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusConnection)

	return goerr, ret2
}

// NewDBusConnectionForAddressSync constructs a class DBusConnection.
func NewDBusConnectionForAddressSync(address string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (dBusConnection DBusConnection, err error) {
	var arg1 *C.gchar
	var arg2 C.GDBusConnectionFlags
	var arg3 *C.GDBusAuthObserver
	var arg4 *C.GCancellable

	arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GDBusConnectionFlags)(flags)
	arg3 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var goerr error
	var cret C.GDBusConnection
	var ret2 DBusConnection

	cret = C.g_dbus_connection_new_for_address_sync(address, flags, observer, cancellable, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusConnection)

	return goerr, ret2
}

// NewDBusConnectionSync constructs a class DBusConnection.
func NewDBusConnectionSync(stream IOStream, guid string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (dBusConnection DBusConnection, err error) {
	var arg1 *C.GIOStream
	var arg2 *C.gchar
	var arg3 C.GDBusConnectionFlags
	var arg4 *C.GDBusAuthObserver
	var arg5 *C.GCancellable

	arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	arg2 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GDBusConnectionFlags)(flags)
	arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var goerr error
	var cret C.GDBusConnection
	var ret2 DBusConnection

	cret = C.g_dbus_connection_new_sync(stream, guid, flags, observer, cancellable, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusConnection)

	return goerr, ret2
}

// AddFilter adds a message filter. Filters are handlers that are run on all
// incoming and outgoing messages, prior to standard dispatch. Filters are
// run in the order that they were added. The same handler can be added as a
// filter more than once, in which case it will be run more than once.
// Filters added during a filter callback won't be run on the message being
// processed. Filter functions are allowed to modify and even drop messages.
//
// Note that filters are run in a dedicated message handling thread so they
// can't block and, generally, can't do anything but signal a worker thread.
// Also note that filters are rarely needed - use API such as
// g_dbus_connection_send_message_with_reply(),
// g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
//
// If a filter consumes an incoming message the message is not dispatched
// anywhere else - not even the standard dispatch machinery (that API such
// as g_dbus_connection_signal_subscribe() and
// g_dbus_connection_send_message_with_reply() relies on) will see the
// message. Similarly, if a filter consumes an outgoing message, the message
// will not be sent to the other peer.
//
// If @user_data_free_func is non-nil, it will be called (in the
// thread-default main context of the thread you are calling this method
// from) at some point after @user_data is no longer needed. (It is not
// guaranteed to be called synchronously when the filter is removed, and may
// be called after @connection has been destroyed.)
func (c dBusConnection) AddFilter(filterFunction DBusMessageFilterFunction) uint {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret C.guint
	var ret1 uint

	cret = C.g_dbus_connection_add_filter(arg0, filterFunction, userData, userDataFreeFunc)

	ret1 = C.guint(cret)

	return ret1
}

// Call: asynchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at @object_path
// owned by @bus_name.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
// with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If @reply_type is non-nil then the reply will be checked for having this
// type and an error will be raised if it does not match. Said another way,
// if you give a @reply_type then any non-nil return value will be of this
// type. Unless its G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple
// containing one or more values.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//    g_dbus_connection_call (connection,
//                            "org.freedesktop.StringThings",
//                            "/org/freedesktop/StringThings",
//                            "org.freedesktop.StringThings",
//                            "TwoStrings",
//                            g_variant_new ("(ss)",
//                                           "Thing One",
//                                           "Thing Two"),
//                            NULL,
//                            G_DBUS_CALL_FLAGS_NONE,
//                            -1,
//                            NULL,
//                            (GAsyncReadyCallback) two_strings_done,
//                            NULL);
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call
// g_dbus_connection_call_finish() to get the result of the operation. See
// g_dbus_connection_call_sync() for the synchronous version of this
// function.
//
// If @callback is nil then the D-Bus method call message will be sent with
// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
func (c dBusConnection) Call(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	C.g_dbus_connection_call(arg0, busName, objectPath, interfaceName, methodName, parameters, replyType, flags, timeoutMsec, cancellable, callback, userData)
}

// CallFinish finishes an operation started with g_dbus_connection_call().
func (c dBusConnection) CallFinish(res AsyncResult) (variant *glib.Variant, err error) {
	var arg0 *C.GDBusConnection
	var arg1 *C.GAsyncResult

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var errout *C.GError
	var goerr error
	var cret *C.GVariant
	var ret2 *glib.Variant

	cret = C.g_dbus_connection_call_finish(arg0, res, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret2, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goerr, ret2
}

// CallSync: synchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at @object_path
// owned by @bus_name.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
// with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If @reply_type is non-nil then the reply will be checked for having this
// type and an error will be raised if it does not match. Said another way,
// if you give a @reply_type then any non-nil return value will be of this
// type.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//    g_dbus_connection_call_sync (connection,
//                                 "org.freedesktop.StringThings",
//                                 "/org/freedesktop/StringThings",
//                                 "org.freedesktop.StringThings",
//                                 "TwoStrings",
//                                 g_variant_new ("(ss)",
//                                                "Thing One",
//                                                "Thing Two"),
//                                 NULL,
//                                 G_DBUS_CALL_FLAGS_NONE,
//                                 -1,
//                                 NULL,
//                                 &error);
//
// The calling thread is blocked until a reply is received. See
// g_dbus_connection_call() for the asynchronous version of this method.
func (c dBusConnection) CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (variant *glib.Variant, err error) {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.GVariant
	var arg6 *C.GVariantType
	var arg7 C.GDBusCallFlags
	var arg8 C.gint
	var arg9 *C.GCancellable

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	arg7 = (C.GDBusCallFlags)(flags)
	arg8 = C.gint(timeoutMsec)
	arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var goerr error
	var cret *C.GVariant
	var ret2 *glib.Variant

	cret = C.g_dbus_connection_call_sync(arg0, busName, objectPath, interfaceName, methodName, parameters, replyType, flags, timeoutMsec, cancellable, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret2, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goerr, ret2
}

// CallWithUnixFdList: like g_dbus_connection_call() but also takes a FDList
// object.
//
// This method is only available on UNIX.
func (c dBusConnection) CallWithUnixFdList(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	C.g_dbus_connection_call_with_unix_fd_list(arg0, busName, objectPath, interfaceName, methodName, parameters, replyType, flags, timeoutMsec, fdList, cancellable, callback, userData)
}

// CallWithUnixFdListFinish finishes an operation started with
// g_dbus_connection_call_with_unix_fd_list().
func (c dBusConnection) CallWithUnixFdListFinish(res AsyncResult) (outFdList UnixFDList, variant *glib.Variant, err error) {
	var arg0 *C.GDBusConnection
	var arg2 *C.GAsyncResult

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var arg1 *C.GUnixFDList
	var ret1 UnixFDList
	var errout *C.GError
	var goerr error
	var cret *C.GVariant
	var ret3 *glib.Variant

	cret = C.g_dbus_connection_call_with_unix_fd_list_finish(arg0, &arg1, res, &errout)

	*ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg1.Native()))).(UnixFDList)
	goerr = gerror.Take(unsafe.Pointer(errout))
	ret3 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret3, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1, goerr, ret3
}

// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes
// and returns FDList objects.
//
// This method is only available on UNIX.
func (c dBusConnection) CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant, err error) {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.GVariant
	var arg6 *C.GVariantType
	var arg7 C.GDBusCallFlags
	var arg8 C.gint
	var arg9 *C.GUnixFDList
	var arg11 *C.GCancellable

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	arg7 = (C.GDBusCallFlags)(flags)
	arg8 = C.gint(timeoutMsec)
	arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	arg11 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var arg10 *C.GUnixFDList
	var ret10 UnixFDList
	var errout *C.GError
	var goerr error
	var cret *C.GVariant
	var ret3 *glib.Variant

	cret = C.g_dbus_connection_call_with_unix_fd_list_sync(arg0, busName, objectPath, interfaceName, methodName, parameters, replyType, flags, timeoutMsec, fdList, &arg10, cancellable, &errout)

	*ret10 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg10.Native()))).(UnixFDList)
	goerr = gerror.Take(unsafe.Pointer(errout))
	ret3 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret3, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret10, goerr, ret3
}

// Close closes @connection. Note that this never causes the process to exit
// (this might only happen if the other end of a shared message bus
// connection disconnects, see BusConnection:exit-on-close).
//
// Once the connection is closed, operations such as sending a message will
// return with the error G_IO_ERROR_CLOSED. Closing a connection will not
// automatically flush the connection so queued messages may be lost. Use
// g_dbus_connection_flush() if you need such guarantees.
//
// If @connection is already closed, this method fails with
// G_IO_ERROR_CLOSED.
//
// When @connection has been closed, the BusConnection::closed signal is
// emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread that
// @connection was constructed in.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call
// g_dbus_connection_close_finish() to get the result of the operation. See
// g_dbus_connection_close_sync() for the synchronous version.
func (c dBusConnection) Close(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	C.g_dbus_connection_close(arg0, cancellable, callback, userData)
}

// CloseFinish finishes an operation started with g_dbus_connection_close().
func (c dBusConnection) CloseFinish(res AsyncResult) error {
	var arg0 *C.GDBusConnection
	var arg1 *C.GAsyncResult

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var errout *C.GError
	var goerr error

	C.g_dbus_connection_close_finish(arg0, res, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// CloseSync: synchronously closes @connection. The calling thread is
// blocked until this is done. See g_dbus_connection_close() for the
// asynchronous version of this method and more details about what it does.
func (c dBusConnection) CloseSync(cancellable Cancellable) error {
	var arg0 *C.GDBusConnection
	var arg1 *C.GCancellable

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var goerr error

	C.g_dbus_connection_close_sync(arg0, cancellable, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// EmitSignal emits a signal.
//
// If the parameters GVariant is floating, it is consumed.
//
// This can only fail if @parameters is not compatible with the D-Bus
// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
// (G_IO_ERROR_CLOSED).
func (c dBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.GVariant

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(destinationBusName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

	var errout *C.GError
	var goerr error

	C.g_dbus_connection_emit_signal(arg0, destinationBusName, objectPath, interfaceName, signalName, parameters, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// ExportActionGroup exports @action_group on @connection at @object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// A given object path can only have one action group exported on it. If
// this constraint is violated, the export will fail and 0 will be returned
// (with @error set accordingly).
//
// You can unexport the action group using
// g_dbus_connection_unexport_action_group() with the return value of this
// function.
//
// The thread default main context is taken at the time of this call. All
// incoming action activations and state change requests are reported from
// this context. Any changes on the action group that cause it to emit
// signals must also come from this same context. Since incoming action
// activations and state change requests are rather likely to cause changes
// on the action group, this effectively limits a given action group to
// being exported from only one main context.
func (c dBusConnection) ExportActionGroup(objectPath string, actionGroup ActionGroup) (guint uint, err error) {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.GActionGroup

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GActionGroup)(unsafe.Pointer(actionGroup.Native()))

	var errout *C.GError
	var goerr error
	var cret C.guint
	var ret2 uint

	cret = C.g_dbus_connection_export_action_group(arg0, objectPath, actionGroup, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = C.guint(cret)

	return goerr, ret2
}

// ExportMenuModel exports @menu on @connection at @object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// An object path can only have one menu model exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// @error set accordingly).
//
// You can unexport the menu model using
// g_dbus_connection_unexport_menu_model() with the return value of this
// function.
func (c dBusConnection) ExportMenuModel(objectPath string, menu MenuModel) (guint uint, err error) {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(unsafe.Pointer(menu.Native()))

	var errout *C.GError
	var goerr error
	var cret C.guint
	var ret2 uint

	cret = C.g_dbus_connection_export_menu_model(arg0, objectPath, menu, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = C.guint(cret)

	return goerr, ret2
}

// Flush: asynchronously flushes @connection, that is, writes all queued
// outgoing message to the transport and then flushes the transport (using
// g_output_stream_flush_async()). This is useful in programs that wants to
// emit a D-Bus signal and then exit immediately. Without flushing the
// connection, there is no guaranteed that the message has been sent to the
// networking buffers in the OS kernel.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call
// g_dbus_connection_flush_finish() to get the result of the operation. See
// g_dbus_connection_flush_sync() for the synchronous version.
func (c dBusConnection) Flush(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	C.g_dbus_connection_flush(arg0, cancellable, callback, userData)
}

// FlushFinish finishes an operation started with g_dbus_connection_flush().
func (c dBusConnection) FlushFinish(res AsyncResult) error {
	var arg0 *C.GDBusConnection
	var arg1 *C.GAsyncResult

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var errout *C.GError
	var goerr error

	C.g_dbus_connection_flush_finish(arg0, res, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// FlushSync: synchronously flushes @connection. The calling thread is
// blocked until this is done. See g_dbus_connection_flush() for the
// asynchronous version of this method and more details about what it does.
func (c dBusConnection) FlushSync(cancellable Cancellable) error {
	var arg0 *C.GDBusConnection
	var arg1 *C.GCancellable

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var goerr error

	C.g_dbus_connection_flush_sync(arg0, cancellable, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// Capabilities gets the capabilities negotiated with the remote peer
func (c dBusConnection) Capabilities() DBusCapabilityFlags {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret C.GDBusCapabilityFlags
	var ret1 DBusCapabilityFlags

	cret = C.g_dbus_connection_get_capabilities(arg0)

	ret1 = DBusCapabilityFlags(cret)

	return ret1
}

// ExitOnClose gets whether the process is terminated when @connection is
// closed by the remote peer. See BusConnection:exit-on-close for more
// details.
func (c dBusConnection) ExitOnClose() bool {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_dbus_connection_get_exit_on_close(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Flags gets the flags used to construct this connection
func (c dBusConnection) Flags() DBusConnectionFlags {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret C.GDBusConnectionFlags
	var ret1 DBusConnectionFlags

	cret = C.g_dbus_connection_get_flags(arg0)

	ret1 = DBusConnectionFlags(cret)

	return ret1
}

// Guid: the GUID of the peer performing the role of server when
// authenticating. See BusConnection:guid for more details.
func (c dBusConnection) Guid() string {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_connection_get_guid(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// LastSerial retrieves the last serial number assigned to a BusMessage on
// the current thread. This includes messages sent via both low-level API
// such as g_dbus_connection_send_message() as well as high-level API such
// as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
// g_dbus_proxy_call().
func (c dBusConnection) LastSerial() uint32 {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret C.guint32
	var ret1 uint32

	cret = C.g_dbus_connection_get_last_serial(arg0)

	ret1 = C.guint32(cret)

	return ret1
}

// PeerCredentials gets the credentials of the authenticated peer. This will
// always return nil unless @connection acted as a server (e.g.
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and
// the client passed credentials as part of the authentication process.
//
// In a message bus setup, the message bus is always the server and each
// application is a client. So this method will always return nil for
// message bus clients.
func (c dBusConnection) PeerCredentials() Credentials {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret *C.GCredentials
	var ret1 Credentials

	cret = C.g_dbus_connection_get_peer_credentials(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Credentials)

	return ret1
}

// Stream gets the underlying stream used for IO.
//
// While the BusConnection is active, it will interact with this stream from
// a worker thread, so it is not safe to interact with the stream directly.
func (c dBusConnection) Stream() IOStream {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret *C.GIOStream
	var ret1 IOStream

	cret = C.g_dbus_connection_get_stream(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(IOStream)

	return ret1
}

// UniqueName gets the unique name of @connection as assigned by the message
// bus. This can also be used to figure out if @connection is a message bus
// connection.
func (c dBusConnection) UniqueName() string {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_connection_get_unique_name(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// IsClosed gets whether @connection is closed.
func (c dBusConnection) IsClosed() bool {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_dbus_connection_is_closed(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// RemoveFilter removes a filter.
//
// Note that since filters run in a different thread, there is a race
// condition where it is possible that the filter will be running even after
// calling g_dbus_connection_remove_filter(), so you cannot just free data
// that the filter might be using. Instead, you should pass a Notify to
// g_dbus_connection_add_filter(), which will be called when it is
// guaranteed that the data is no longer needed.
func (c dBusConnection) RemoveFilter(filterID uint) {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(filterID)

	C.g_dbus_connection_remove_filter(arg0, filterID)
}

// SendMessage: asynchronously sends @message to the peer represented by
// @connection.
//
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the
// message to the underlying transport.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @message is not well-formed, the operation fails
// with G_IO_ERROR_INVALID_ARGUMENT.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (c dBusConnection) SendMessage(message DBusMessage, flags DBusSendMessageFlags) (outSerial uint32, err error) {
	var arg0 *C.GDBusConnection
	var arg1 *C.GDBusMessage
	var arg2 C.GDBusSendMessageFlags

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	arg2 = (C.GDBusSendMessageFlags)(flags)

	var arg3 C.guint32
	var ret3 uint32
	var errout *C.GError
	var goerr error

	C.g_dbus_connection_send_message(arg0, message, flags, &arg3, &errout)

	*ret3 = C.guint32(arg3)
	goerr = gerror.Take(unsafe.Pointer(errout))

	return ret3, goerr
}

// SendMessageWithReply: asynchronously sends @message to the peer
// represented by @connection.
//
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the
// message to the underlying transport.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
// fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call
// g_dbus_connection_send_message_with_reply_finish() to get the result of
// the operation. See g_dbus_connection_send_message_with_reply_sync() for
// the synchronous version.
//
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (c dBusConnection) SendMessageWithReply(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32 {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var arg4 C.guint32
	var ret4 uint32

	C.g_dbus_connection_send_message_with_reply(arg0, message, flags, timeoutMsec, &arg4, cancellable, callback, userData)

	*ret4 = C.guint32(arg4)

	return ret4
}

// SendMessageWithReplyFinish finishes an operation started with
// g_dbus_connection_send_message_with_reply().
//
// Note that @error is only set if a local in-process error occurred. That
// is to say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
// this to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (c dBusConnection) SendMessageWithReplyFinish(res AsyncResult) (dBusMessage DBusMessage, err error) {
	var arg0 *C.GDBusConnection
	var arg1 *C.GAsyncResult

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var errout *C.GError
	var goerr error
	var cret *C.GDBusMessage
	var ret2 DBusMessage

	cret = C.g_dbus_connection_send_message_with_reply_finish(arg0, res, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusMessage)

	return goerr, ret2
}

// SendMessageWithReplySync: synchronously sends @message to the peer
// represented by @connection and blocks the calling thread until a reply is
// received or the timeout is reached. See
// g_dbus_connection_send_message_with_reply() for the asynchronous version
// of this method.
//
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the
// message to the underlying transport.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
// fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// Note that @error is only set if a local in-process error occurred. That
// is to say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
// this to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (c dBusConnection) SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (outSerial uint32, dBusMessage DBusMessage, err error) {
	var arg0 *C.GDBusConnection
	var arg1 *C.GDBusMessage
	var arg2 C.GDBusSendMessageFlags
	var arg3 C.gint
	var arg5 *C.GCancellable

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	arg2 = (C.GDBusSendMessageFlags)(flags)
	arg3 = C.gint(timeoutMsec)
	arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var arg4 C.guint32
	var ret4 uint32
	var errout *C.GError
	var goerr error
	var cret *C.GDBusMessage
	var ret3 DBusMessage

	cret = C.g_dbus_connection_send_message_with_reply_sync(arg0, message, flags, timeoutMsec, &arg4, cancellable, &errout)

	*ret4 = C.guint32(arg4)
	goerr = gerror.Take(unsafe.Pointer(errout))
	ret3 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusMessage)

	return ret4, goerr, ret3
}

// SetExitOnClose sets whether the process should be terminated when
// @connection is closed by the remote peer. See BusConnection:exit-on-close
// for more details.
//
// Note that this function should be used with care. Most modern UNIX
// desktops tie the notion of a user session with the session bus, and
// expect all of a user's applications to quit when their bus connection
// goes away. If you are setting @exit_on_close to false for the shared
// session bus connection, you should make sure that your application exits
// when the user session ends.
func (c dBusConnection) SetExitOnClose(exitOnClose bool) {
	var arg0 *C.GDBusConnection
	var arg1 C.gboolean

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	if exitOnClose {
		arg1 = C.gboolean(1)
	}

	C.g_dbus_connection_set_exit_on_close(arg0, exitOnClose)
}

// SignalSubscribe subscribes to signals on @connection and invokes
// @callback with a whenever the signal is received. Note that @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from.
//
// If @connection is not a message bus connection, @sender must be nil.
//
// If @sender is a well-known name note that @callback is invoked with the
// unique name for the owner of @sender, not the well-known name as one
// would expect. This is because the message bus rewrites the name. As such,
// to avoid certain race conditions, users should be tracking the name owner
// of the well-known name and use that when processing the received signal.
//
// If one of G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
// G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is interpreted as
// part of a namespace or path. The first argument of a signal is matched
// against that part as specified by D-Bus.
//
// If @user_data_free_func is non-nil, it will be called (in the
// thread-default main context of the thread you are calling this method
// from) at some point after @user_data is no longer needed. (It is not
// guaranteed to be called synchronously when the signal is unsubscribed
// from, and may be called after @connection has been destroyed.)
//
// As @callback is potentially invoked in a different thread from where its
// emitted, its possible for this to happen after
// g_dbus_connection_signal_unsubscribe() has been called in another thread.
// Due to this, @user_data should have a strong reference which is freed
// with @user_data_free_func, rather than pointing to data whose lifecycle
// is tied to the signal subscription. For example, if a #GObject is used to
// store the subscription ID from g_dbus_connection_signal_subscribe(), a
// strong reference to that #GObject must be passed to @user_data, and
// g_object_unref() passed to @user_data_free_func. You are responsible for
// breaking the resulting reference count cycle by explicitly unsubscribing
// from the signal when dropping the last external reference to the
// #GObject. Alternatively, a weak reference may be used.
//
// It is guaranteed that if you unsubscribe from a signal using
// g_dbus_connection_signal_unsubscribe() from the same thread which made
// the corresponding g_dbus_connection_signal_subscribe() call, @callback
// will not be invoked after g_dbus_connection_signal_unsubscribe() returns.
//
// The returned subscription identifier is an opaque value which is
// guaranteed to never be zero.
//
// This function can never fail.
func (c dBusConnection) SignalSubscribe(sender string, interfaceName string, member string, objectPath string, arg0 string, flags DBusSignalFlags, callback DBusSignalCallback) uint {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var cret C.guint
	var ret1 uint

	cret = C.g_dbus_connection_signal_subscribe(arg0, sender, interfaceName, member, objectPath, arg0, flags, callback, userData, userDataFreeFunc)

	ret1 = C.guint(cret)

	return ret1
}

// SignalUnsubscribe unsubscribes from signals.
//
// Note that there may still be D-Bus traffic to process (relating to this
// signal subscription) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until
// the Notify function passed to g_dbus_connection_signal_subscribe() is
// called, in order to avoid memory leaks through callbacks queued on the
// Context after its stopped being iterated.
func (c dBusConnection) SignalUnsubscribe(subscriptionID uint) {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(subscriptionID)

	C.g_dbus_connection_signal_unsubscribe(arg0, subscriptionID)
}

// StartMessageProcessing: if @connection was created with
// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
// processing messages. Does nothing on if @connection wasn't created with
// this flag or if the method has already been called.
func (c dBusConnection) StartMessageProcessing() {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	C.g_dbus_connection_start_message_processing(arg0)
}

// UnexportActionGroup reverses the effect of a previous call to
// g_dbus_connection_export_action_group().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_action_group() or to call it with the same ID
// more than once.
func (c dBusConnection) UnexportActionGroup(exportID uint) {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(exportID)

	C.g_dbus_connection_unexport_action_group(arg0, exportID)
}

// UnexportMenuModel reverses the effect of a previous call to
// g_dbus_connection_export_menu_model().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_menu_model() or to call it with the same ID more
// than once.
func (c dBusConnection) UnexportMenuModel(exportID uint) {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(exportID)

	C.g_dbus_connection_unexport_menu_model(arg0, exportID)
}

// UnregisterObject unregisters an object.
func (c dBusConnection) UnregisterObject(registrationID uint) bool {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(registrationID)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_dbus_connection_unregister_object(arg0, registrationID)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// UnregisterSubtree unregisters a subtree.
func (c dBusConnection) UnregisterSubtree(registrationID uint) bool {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(registrationID)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_dbus_connection_unregister_subtree(arg0, registrationID)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel interface {
	MenuModel
}

// dBusMenuModel implements the DBusMenuModel interface.
type dBusMenuModel struct {
	MenuModel
}

var _ DBusMenuModel = (*dBusMenuModel)(nil)

// WrapDBusMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMenuModel(obj *externglib.Object) DBusMenuModel {
	return DBusMenuModel{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMenuModel(obj), nil
}

// DBusMessage: a type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage interface {
	gextras.Objector

	// Copy copies @message. The copy is a deep copy and the returned BusMessage
	// is completely identical except that it is guaranteed to not be locked.
	//
	// This operation can fail if e.g. @message contains file descriptors and
	// the per-process or system-wide open files limit is reached.
	Copy() (dBusMessage DBusMessage, err error)
	// Arg0: convenience to get the first item in the body of @message.
	Arg0() string
	// Body gets the body of a message.
	Body() *glib.Variant
	// ByteOrder gets the byte order of @message.
	ByteOrder() DBusMessageByteOrder
	// Destination: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	Destination() string
	// ErrorName: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	ErrorName() string
	// Flags gets the flags for @message.
	Flags() DBusMessageFlags
	// Header gets a header field on @message.
	//
	// The caller is responsible for checking the type of the returned #GVariant
	// matches what is expected.
	Header(headerField DBusMessageHeaderField) *glib.Variant
	// HeaderFields gets an array of all header fields on @message that are set.
	HeaderFields() []byte
	// Interface: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	Interface() string
	// Locked checks whether @message is locked. To monitor changes to this
	// value, conncet to the #GObject::notify signal to listen for changes on
	// the BusMessage:locked property.
	Locked() bool
	// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	Member() string
	// MessageType gets the type of @message.
	MessageType() DBusMessageType
	// NumUnixFds: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	NumUnixFds() uint32
	// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
	// field.
	Path() string
	// ReplySerial: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	ReplySerial() uint32
	// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	Sender() string
	// Serial gets the serial for @message.
	Serial() uint32
	// Signature: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	Signature() string
	// UnixFdList gets the UNIX file descriptors associated with @message, if
	// any.
	//
	// This method is only available on UNIX.
	UnixFdList() UnixFDList
	// Lock: if @message is locked, does nothing. Otherwise locks the message.
	Lock()
	// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
	// @method_call_message.
	NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage
	// NewMethodReply creates a new BusMessage that is a reply to
	// @method_call_message.
	NewMethodReply() DBusMessage
	// Print produces a human-readable multi-line description of @message.
	//
	// The contents of the description has no ABI guarantees, the contents and
	// formatting is subject to change at any time. Typical output looks
	// something like this:
	//
	//    Flags:   none
	//    Version: 0
	//    Serial:  4
	//    Headers:
	//      path -> objectpath '/org/gtk/GDBus/TestObject'
	//      interface -> 'org.gtk.GDBus.TestInterface'
	//      member -> 'GimmeStdout'
	//      destination -> ':1.146'
	//    Body: ()
	//    UNIX File Descriptors:
	//      (none)
	//
	// or
	//
	//    Flags:   no-reply-expected
	//    Version: 0
	//    Serial:  477
	//    Headers:
	//      reply-serial -> uint32 4
	//      destination -> ':1.159'
	//      sender -> ':1.146'
	//      num-unix-fds -> uint32 1
	//    Body: ()
	//    UNIX File Descriptors:
	//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
	Print(indent uint) string
	// SetBody sets the body @message. As a side-effect the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type
	// string of @body (or cleared if @body is nil).
	//
	// If @body is floating, @message assumes ownership of @body.
	SetBody(body *glib.Variant)
	// SetByteOrder sets the byte order of @message.
	SetByteOrder(byteOrder DBusMessageByteOrder)
	// SetDestination: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	SetDestination(value string)
	// SetErrorName: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	SetErrorName(value string)
	// SetFlags sets the flags to set on @message.
	SetFlags(flags DBusMessageFlags)
	// SetHeader sets a header field on @message.
	//
	// If @value is floating, @message assumes ownership of @value.
	SetHeader(headerField DBusMessageHeaderField, value *glib.Variant)
	// SetInterface: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	SetInterface(value string)
	// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	SetMember(value string)
	// SetMessageType sets @message to be of @type.
	SetMessageType(typ DBusMessageType)
	// SetNumUnixFds: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	SetNumUnixFds(value uint32)
	// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
	// header field.
	SetPath(value string)
	// SetReplySerial: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	SetReplySerial(value uint32)
	// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	SetSender(value string)
	// SetSerial sets the serial for @message.
	SetSerial(serial uint32)
	// SetSignature: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	SetSignature(value string)
	// SetUnixFdList sets the UNIX file descriptors associated with @message. As
	// a side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field
	// is set to the number of fds in @fd_list (or cleared if @fd_list is nil).
	//
	// This method is only available on UNIX.
	SetUnixFdList(fdList UnixFDList)
	// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
	// nothing and returns false.
	//
	// Otherwise this method encodes the error in @message as a #GError using
	// g_dbus_error_set_dbus_error() using the information in the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well
	// as the first string item in @message's body.
	ToGerror() error
}

// dBusMessage implements the DBusMessage interface.
type dBusMessage struct {
	gextras.Objector
}

var _ DBusMessage = (*dBusMessage)(nil)

// WrapDBusMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMessage(obj *externglib.Object) DBusMessage {
	return DBusMessage{
		Objector: obj,
	}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMessage(obj), nil
}

// NewDBusMessage constructs a class DBusMessage.
func NewDBusMessage() DBusMessage {
	var cret C.GDBusMessage
	var ret1 DBusMessage

	cret = C.g_dbus_message_new()

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusMessage)

	return ret1
}

// NewDBusMessageMethodCall constructs a class DBusMessage.
func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) DBusMessage {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(method))
	defer C.free(unsafe.Pointer(arg4))

	var cret C.GDBusMessage
	var ret1 DBusMessage

	cret = C.g_dbus_message_new_method_call(name, path, interface_, method)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusMessage)

	return ret1
}

// NewDBusMessageSignal constructs a class DBusMessage.
func NewDBusMessageSignal(path string, interface_ string, signal string) DBusMessage {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(signal))
	defer C.free(unsafe.Pointer(arg3))

	var cret C.GDBusMessage
	var ret1 DBusMessage

	cret = C.g_dbus_message_new_signal(path, interface_, signal)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusMessage)

	return ret1
}

// Copy copies @message. The copy is a deep copy and the returned BusMessage
// is completely identical except that it is guaranteed to not be locked.
//
// This operation can fail if e.g. @message contains file descriptors and
// the per-process or system-wide open files limit is reached.
func (m dBusMessage) Copy() (dBusMessage DBusMessage, err error) {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var errout *C.GError
	var goerr error
	var cret *C.GDBusMessage
	var ret2 DBusMessage

	cret = C.g_dbus_message_copy(arg0, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusMessage)

	return goerr, ret2
}

// Arg0: convenience to get the first item in the body of @message.
func (m dBusMessage) Arg0() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_message_get_arg0(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Body gets the body of a message.
func (m dBusMessage) Body() *glib.Variant {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.GVariant
	var ret1 *glib.Variant

	cret = C.g_dbus_message_get_body(arg0)

	ret1 = glib.WrapVariant(unsafe.Pointer(cret))

	return ret1
}

// ByteOrder gets the byte order of @message.
func (m dBusMessage) ByteOrder() DBusMessageByteOrder {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret C.GDBusMessageByteOrder
	var ret1 DBusMessageByteOrder

	cret = C.g_dbus_message_get_byte_order(arg0)

	ret1 = DBusMessageByteOrder(cret)

	return ret1
}

// Destination: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (m dBusMessage) Destination() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_message_get_destination(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// ErrorName: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (m dBusMessage) ErrorName() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_message_get_error_name(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Flags gets the flags for @message.
func (m dBusMessage) Flags() DBusMessageFlags {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret C.GDBusMessageFlags
	var ret1 DBusMessageFlags

	cret = C.g_dbus_message_get_flags(arg0)

	ret1 = DBusMessageFlags(cret)

	return ret1
}

// Header gets a header field on @message.
//
// The caller is responsible for checking the type of the returned #GVariant
// matches what is expected.
func (m dBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageHeaderField

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (C.GDBusMessageHeaderField)(headerField)

	var cret *C.GVariant
	var ret1 *glib.Variant

	cret = C.g_dbus_message_get_header(arg0, headerField)

	ret1 = glib.WrapVariant(unsafe.Pointer(cret))

	return ret1
}

// HeaderFields gets an array of all header fields on @message that are set.
func (m dBusMessage) HeaderFields() []byte {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.guchar
	var ret1 []byte

	cret = C.g_dbus_message_get_header_fields(arg0)

	{
		var length int
		for p := cret; *p != 0; p = (*C.guchar)(ptr.Add(unsafe.Pointer(p), C.sizeof_guchar)) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		ret1 = make([]byte, length)
		for i := uintptr(0); i < uintptr(length); i += C.sizeof_guchar {
			src := (C.guchar)(ptr.Add(unsafe.Pointer(cret), i))
			ret1[i] = C.guchar(src)
		}
	}

	return ret1
}

// Interface: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (m dBusMessage) Interface() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_message_get_interface(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Locked checks whether @message is locked. To monitor changes to this
// value, conncet to the #GObject::notify signal to listen for changes on
// the BusMessage:locked property.
func (m dBusMessage) Locked() bool {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_dbus_message_get_locked(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
func (m dBusMessage) Member() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_message_get_member(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// MessageType gets the type of @message.
func (m dBusMessage) MessageType() DBusMessageType {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret C.GDBusMessageType
	var ret1 DBusMessageType

	cret = C.g_dbus_message_get_message_type(arg0)

	ret1 = DBusMessageType(cret)

	return ret1
}

// NumUnixFds: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (m dBusMessage) NumUnixFds() uint32 {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret C.guint32
	var ret1 uint32

	cret = C.g_dbus_message_get_num_unix_fds(arg0)

	ret1 = C.guint32(cret)

	return ret1
}

// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
func (m dBusMessage) Path() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_message_get_path(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// ReplySerial: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (m dBusMessage) ReplySerial() uint32 {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret C.guint32
	var ret1 uint32

	cret = C.g_dbus_message_get_reply_serial(arg0)

	ret1 = C.guint32(cret)

	return ret1
}

// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
func (m dBusMessage) Sender() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_message_get_sender(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Serial gets the serial for @message.
func (m dBusMessage) Serial() uint32 {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret C.guint32
	var ret1 uint32

	cret = C.g_dbus_message_get_serial(arg0)

	ret1 = C.guint32(cret)

	return ret1
}

// Signature: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
func (m dBusMessage) Signature() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_message_get_signature(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// UnixFdList gets the UNIX file descriptors associated with @message, if
// any.
//
// This method is only available on UNIX.
func (m dBusMessage) UnixFdList() UnixFDList {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.GUnixFDList
	var ret1 UnixFDList

	cret = C.g_dbus_message_get_unix_fd_list(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(UnixFDList)

	return ret1
}

// Lock: if @message is locked, does nothing. Otherwise locks the message.
func (m dBusMessage) Lock() {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	C.g_dbus_message_lock(arg0)
}

// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
// @method_call_message.
func (m dBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(arg2))

	var cret *C.GDBusMessage
	var ret1 DBusMessage

	cret = C.g_dbus_message_new_method_error_literal(arg0, errorName, errorMessage)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusMessage)

	return ret1
}

// NewMethodReply creates a new BusMessage that is a reply to
// @method_call_message.
func (m dBusMessage) NewMethodReply() DBusMessage {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var cret *C.GDBusMessage
	var ret1 DBusMessage

	cret = C.g_dbus_message_new_method_reply(arg0)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusMessage)

	return ret1
}

// Print produces a human-readable multi-line description of @message.
//
// The contents of the description has no ABI guarantees, the contents and
// formatting is subject to change at any time. Typical output looks
// something like this:
//
//    Flags:   none
//    Version: 0
//    Serial:  4
//    Headers:
//      path -> objectpath '/org/gtk/GDBus/TestObject'
//      interface -> 'org.gtk.GDBus.TestInterface'
//      member -> 'GimmeStdout'
//      destination -> ':1.146'
//    Body: ()
//    UNIX File Descriptors:
//      (none)
//
// or
//
//    Flags:   no-reply-expected
//    Version: 0
//    Serial:  477
//    Headers:
//      reply-serial -> uint32 4
//      destination -> ':1.159'
//      sender -> ':1.146'
//      num-unix-fds -> uint32 1
//    Body: ()
//    UNIX File Descriptors:
//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
func (m dBusMessage) Print(indent uint) string {
	var arg0 *C.GDBusMessage
	var arg1 C.guint

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = C.guint(indent)

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_message_print(arg0, indent)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// SetBody sets the body @message. As a side-effect the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type
// string of @body (or cleared if @body is nil).
//
// If @body is floating, @message assumes ownership of @body.
func (m dBusMessage) SetBody(body *glib.Variant) {
	var arg0 *C.GDBusMessage
	var arg1 *C.GVariant

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GVariant)(unsafe.Pointer(body.Native()))

	C.g_dbus_message_set_body(arg0, body)
}

// SetByteOrder sets the byte order of @message.
func (m dBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder) {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageByteOrder

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (C.GDBusMessageByteOrder)(byteOrder)

	C.g_dbus_message_set_byte_order(arg0, byteOrder)
}

// SetDestination: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (m dBusMessage) SetDestination(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_destination(arg0, value)
}

// SetErrorName: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (m dBusMessage) SetErrorName(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_error_name(arg0, value)
}

// SetFlags sets the flags to set on @message.
func (m dBusMessage) SetFlags(flags DBusMessageFlags) {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageFlags

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (C.GDBusMessageFlags)(flags)

	C.g_dbus_message_set_flags(arg0, flags)
}

// SetHeader sets a header field on @message.
//
// If @value is floating, @message assumes ownership of @value.
func (m dBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant) {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageHeaderField
	var arg2 *C.GVariant

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (C.GDBusMessageHeaderField)(headerField)
	arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_dbus_message_set_header(arg0, headerField, value)
}

// SetInterface: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (m dBusMessage) SetInterface(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_interface(arg0, value)
}

// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
func (m dBusMessage) SetMember(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_member(arg0, value)
}

// SetMessageType sets @message to be of @type.
func (m dBusMessage) SetMessageType(typ DBusMessageType) {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageType

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (C.GDBusMessageType)(typ)

	C.g_dbus_message_set_message_type(arg0, typ)
}

// SetNumUnixFds: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (m dBusMessage) SetNumUnixFds(value uint32) {
	var arg0 *C.GDBusMessage
	var arg1 C.guint32

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = C.guint32(value)

	C.g_dbus_message_set_num_unix_fds(arg0, value)
}

// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
// header field.
func (m dBusMessage) SetPath(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_path(arg0, value)
}

// SetReplySerial: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (m dBusMessage) SetReplySerial(value uint32) {
	var arg0 *C.GDBusMessage
	var arg1 C.guint32

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = C.guint32(value)

	C.g_dbus_message_set_reply_serial(arg0, value)
}

// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
func (m dBusMessage) SetSender(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_sender(arg0, value)
}

// SetSerial sets the serial for @message.
func (m dBusMessage) SetSerial(serial uint32) {
	var arg0 *C.GDBusMessage
	var arg1 C.guint32

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = C.guint32(serial)

	C.g_dbus_message_set_serial(arg0, serial)
}

// SetSignature: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
func (m dBusMessage) SetSignature(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_signature(arg0, value)
}

// SetUnixFdList sets the UNIX file descriptors associated with @message. As
// a side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field
// is set to the number of fds in @fd_list (or cleared if @fd_list is nil).
//
// This method is only available on UNIX.
func (m dBusMessage) SetUnixFdList(fdList UnixFDList) {
	var arg0 *C.GDBusMessage
	var arg1 *C.GUnixFDList

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_message_set_unix_fd_list(arg0, fdList)
}

// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
// nothing and returns false.
//
// Otherwise this method encodes the error in @message as a #GError using
// g_dbus_error_set_dbus_error() using the information in the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well
// as the first string item in @message's body.
func (m dBusMessage) ToGerror() error {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var errout *C.GError
	var goerr error

	C.g_dbus_message_to_gerror(arg0, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation interface {
	gextras.Objector

	// Connection gets the BusConnection the method was invoked on.
	Connection() DBusConnection
	// InterfaceName gets the name of the D-Bus interface the method was invoked
	// on.
	//
	// If this method call is a property Get, Set or GetAll call that has been
	// redirected to the method call handler then
	// "org.freedesktop.DBus.Properties" will be returned. See
	// BusInterfaceVTable for more information.
	InterfaceName() string
	// Message gets the BusMessage for the method invocation. This is useful if
	// you need to use low-level protocol features, such as UNIX file descriptor
	// passing, that cannot be properly expressed in the #GVariant API.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	Message() DBusMessage
	// MethodInfo gets information about the method call, if any.
	//
	// If this method invocation is a property Get, Set or GetAll call that has
	// been redirected to the method call handler then nil will be returned. See
	// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
	// more information.
	MethodInfo() *DBusMethodInfo
	// MethodName gets the name of the method that was invoked.
	MethodName() string
	// ObjectPath gets the object path the method was invoked on.
	ObjectPath() string
	// Parameters gets the parameters of the method invocation. If there are no
	// input parameters then this will return a GVariant with 0 children rather
	// than NULL.
	Parameters() *glib.Variant
	// PropertyInfo gets information about the property that this method call is
	// for, if any.
	//
	// This will only be set in the case of an invocation in response to a
	// property Get or Set call that has been directed to the method call
	// handler for an object on account of its property_get() or property_set()
	// vtable pointers being unset.
	//
	// See BusInterfaceVTable for more information.
	//
	// If the call was GetAll, nil will be returned.
	PropertyInfo() *DBusPropertyInfo
	// Sender gets the bus name that invoked the method.
	Sender() string
	// UserData gets the @user_data #gpointer passed to
	// g_dbus_connection_register_object().
	UserData() interface{}
	// ReturnDBusError finishes handling a D-Bus method call by returning an
	// error.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnDBusError(errorName string, errorMessage string)
	// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
	// #GError instead of the error domain, error code and message.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnGerror(error error)
	// ReturnValue finishes handling a D-Bus method call by returning
	// @parameters. If the @parameters GVariant is floating, it is consumed.
	//
	// It is an error if @parameters is not of the right format: it must be a
	// tuple containing the out-parameters of the D-Bus method. Even if the
	// method has a single out-parameter, it must be contained in a tuple. If
	// the method has no out-parameters, @parameters may be nil or an empty
	// tuple.
	//
	//    GDBusMethodInvocation *invocation = some_invocation;
	//    g_autofree gchar *result_string = NULL;
	//    g_autoptr (GError) error = NULL;
	//
	//    result_string = calculate_result (&error);
	//
	//    if (error != NULL)
	//      g_dbus_method_invocation_return_gerror (invocation, error);
	//    else
	//      g_dbus_method_invocation_return_value (invocation,
	//                                             g_variant_new ("(s)", result_string));
	//
	//    // Do not free @invocation here; returning a value does that
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	//
	// Since 2.48, if the method call requested for a reply not to be sent then
	// this call will sink @parameters and free @invocation, but otherwise do
	// nothing (as per the recommendations of the D-Bus specification).
	ReturnValue(parameters *glib.Variant)
	// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
	// but also takes a FDList.
	//
	// This method is only available on UNIX.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList)
	// TakeError: like g_dbus_method_invocation_return_gerror() but takes
	// ownership of @error so the caller does not need to free it.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	TakeError(error error)
}

// dBusMethodInvocation implements the DBusMethodInvocation interface.
type dBusMethodInvocation struct {
	gextras.Objector
}

var _ DBusMethodInvocation = (*dBusMethodInvocation)(nil)

// WrapDBusMethodInvocation wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMethodInvocation(obj *externglib.Object) DBusMethodInvocation {
	return DBusMethodInvocation{
		Objector: obj,
	}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMethodInvocation(obj), nil
}

// Connection gets the BusConnection the method was invoked on.
func (i dBusMethodInvocation) Connection() DBusConnection {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusConnection
	var ret1 DBusConnection

	cret = C.g_dbus_method_invocation_get_connection(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(DBusConnection)

	return ret1
}

// InterfaceName gets the name of the D-Bus interface the method was invoked
// on.
//
// If this method call is a property Get, Set or GetAll call that has been
// redirected to the method call handler then
// "org.freedesktop.DBus.Properties" will be returned. See
// BusInterfaceVTable for more information.
func (i dBusMethodInvocation) InterfaceName() string {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_method_invocation_get_interface_name(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Message gets the BusMessage for the method invocation. This is useful if
// you need to use low-level protocol features, such as UNIX file descriptor
// passing, that cannot be properly expressed in the #GVariant API.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (i dBusMethodInvocation) Message() DBusMessage {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusMessage
	var ret1 DBusMessage

	cret = C.g_dbus_method_invocation_get_message(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(DBusMessage)

	return ret1
}

// MethodInfo gets information about the method call, if any.
//
// If this method invocation is a property Get, Set or GetAll call that has
// been redirected to the method call handler then nil will be returned. See
// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
// more information.
func (i dBusMethodInvocation) MethodInfo() *DBusMethodInfo {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusMethodInfo
	var ret1 *DBusMethodInfo

	cret = C.g_dbus_method_invocation_get_method_info(arg0)

	ret1 = WrapDBusMethodInfo(unsafe.Pointer(cret))

	return ret1
}

// MethodName gets the name of the method that was invoked.
func (i dBusMethodInvocation) MethodName() string {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_method_invocation_get_method_name(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// ObjectPath gets the object path the method was invoked on.
func (i dBusMethodInvocation) ObjectPath() string {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_method_invocation_get_object_path(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Parameters gets the parameters of the method invocation. If there are no
// input parameters then this will return a GVariant with 0 children rather
// than NULL.
func (i dBusMethodInvocation) Parameters() *glib.Variant {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret *C.GVariant
	var ret1 *glib.Variant

	cret = C.g_dbus_method_invocation_get_parameters(arg0)

	ret1 = glib.WrapVariant(unsafe.Pointer(cret))

	return ret1
}

// PropertyInfo gets information about the property that this method call is
// for, if any.
//
// This will only be set in the case of an invocation in response to a
// property Get or Set call that has been directed to the method call
// handler for an object on account of its property_get() or property_set()
// vtable pointers being unset.
//
// See BusInterfaceVTable for more information.
//
// If the call was GetAll, nil will be returned.
func (i dBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusPropertyInfo
	var ret1 *DBusPropertyInfo

	cret = C.g_dbus_method_invocation_get_property_info(arg0)

	ret1 = WrapDBusPropertyInfo(unsafe.Pointer(cret))

	return ret1
}

// Sender gets the bus name that invoked the method.
func (i dBusMethodInvocation) Sender() string {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_method_invocation_get_sender(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// UserData gets the @user_data #gpointer passed to
// g_dbus_connection_register_object().
func (i dBusMethodInvocation) UserData() interface{} {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var cret C.gpointer
	var ret1 interface{}

	cret = C.g_dbus_method_invocation_get_user_data(arg0)

	ret1 = C.gpointer(cret)

	return ret1
}

// ReturnDBusError finishes handling a D-Bus method call by returning an
// error.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (i dBusMethodInvocation) ReturnDBusError(errorName string, errorMessage string) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(arg2))

	C.g_dbus_method_invocation_return_dbus_error(arg0, errorName, errorMessage)
}

// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
// #GError instead of the error domain, error code and message.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (i dBusMethodInvocation) ReturnGerror(error error) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.GError

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GError)(gerror.New(unsafe.Pointer(error)))
	defer C.g_error_free(arg1)

	C.g_dbus_method_invocation_return_gerror(arg0, error)
}

// ReturnValue finishes handling a D-Bus method call by returning
// @parameters. If the @parameters GVariant is floating, it is consumed.
//
// It is an error if @parameters is not of the right format: it must be a
// tuple containing the out-parameters of the D-Bus method. Even if the
// method has a single out-parameter, it must be contained in a tuple. If
// the method has no out-parameters, @parameters may be nil or an empty
// tuple.
//
//    GDBusMethodInvocation *invocation = some_invocation;
//    g_autofree gchar *result_string = NULL;
//    g_autoptr (GError) error = NULL;
//
//    result_string = calculate_result (&error);
//
//    if (error != NULL)
//      g_dbus_method_invocation_return_gerror (invocation, error);
//    else
//      g_dbus_method_invocation_return_value (invocation,
//                                             g_variant_new ("(s)", result_string));
//
//    // Do not free @invocation here; returning a value does that
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
//
// Since 2.48, if the method call requested for a reply not to be sent then
// this call will sink @parameters and free @invocation, but otherwise do
// nothing (as per the recommendations of the D-Bus specification).
func (i dBusMethodInvocation) ReturnValue(parameters *glib.Variant) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.GVariant

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

	C.g_dbus_method_invocation_return_value(arg0, parameters)
}

// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
// but also takes a FDList.
//
// This method is only available on UNIX.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (i dBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.GVariant
	var arg2 *C.GUnixFDList

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	arg2 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_method_invocation_return_value_with_unix_fd_list(arg0, parameters, fdList)
}

// TakeError: like g_dbus_method_invocation_return_gerror() but takes
// ownership of @error so the caller does not need to free it.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (i dBusMethodInvocation) TakeError(error error) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.GError

	arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GError)(gerror.New(unsafe.Pointer(error)))

	C.g_dbus_method_invocation_take_error(arg0, error)
}

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with G-DBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer.
type DBusServer interface {
	gextras.Objector
	Initable

	// ClientAddress gets a D-Bus address
	// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
	// string that can be used by clients to connect to @server.
	ClientAddress() string
	// Flags gets the flags for @server.
	Flags() DBusServerFlags
	// Guid gets the GUID for @server.
	Guid() string
	// IsActive gets whether @server is active.
	IsActive() bool
	// Start starts @server.
	Start()
	// Stop stops @server.
	Stop()
}

// dBusServer implements the DBusServer interface.
type dBusServer struct {
	gextras.Objector
	Initable
}

var _ DBusServer = (*dBusServer)(nil)

// WrapDBusServer wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusServer(obj *externglib.Object) DBusServer {
	return DBusServer{
		Objector: obj,
		Initable: WrapInitable(obj),
	}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusServer(obj), nil
}

// NewDBusServerSync constructs a class DBusServer.
func NewDBusServerSync(address string, flags DBusServerFlags, guid string, observer DBusAuthObserver, cancellable Cancellable) (dBusServer DBusServer, err error) {
	var arg1 *C.gchar
	var arg2 C.GDBusServerFlags
	var arg3 *C.gchar
	var arg4 *C.GDBusAuthObserver
	var arg5 *C.GCancellable

	arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GDBusServerFlags)(flags)
	arg3 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var goerr error
	var cret C.GDBusServer
	var ret2 DBusServer

	cret = C.g_dbus_server_new_sync(address, flags, guid, observer, cancellable, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusServer)

	return goerr, ret2
}

// ClientAddress gets a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
// string that can be used by clients to connect to @server.
func (s dBusServer) ClientAddress() string {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_server_get_client_address(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Flags gets the flags for @server.
func (s dBusServer) Flags() DBusServerFlags {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	var cret C.GDBusServerFlags
	var ret1 DBusServerFlags

	cret = C.g_dbus_server_get_flags(arg0)

	ret1 = DBusServerFlags(cret)

	return ret1
}

// Guid gets the GUID for @server.
func (s dBusServer) Guid() string {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_server_get_guid(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// IsActive gets whether @server is active.
func (s dBusServer) IsActive() bool {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_dbus_server_is_active(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Start starts @server.
func (s dBusServer) Start() {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_start(arg0)
}

// Stop stops @server.
func (s dBusServer) Stop() {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_stop(arg0)
}

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu interface {
	MenuModel

	// Append: convenience function for appending a normal menu item to the end
	// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
	// flexible alternative.
	Append(label string, detailedAction string)
	// AppendItem appends @item to the end of @menu.
	//
	// See g_menu_insert_item() for more information.
	AppendItem(item MenuItem)
	// AppendSection: convenience function for appending a section menu item to
	// the end of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSection(label string, section MenuModel)
	// AppendSubmenu: convenience function for appending a submenu menu item to
	// the end of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSubmenu(label string, submenu MenuModel)
	// Freeze marks @menu as frozen.
	//
	// After the menu is frozen, it is an error to attempt to make any changes
	// to it. In effect this means that the #GMenu API must no longer be used.
	//
	// This function causes g_menu_model_is_mutable() to begin returning false,
	// which has some positive performance implications.
	Freeze()
	// Insert: convenience function for inserting a normal menu item into @menu.
	// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
	// alternative.
	Insert(position int, label string, detailedAction string)
	// InsertItem inserts @item into @menu.
	//
	// The "insertion" is actually done by copying all of the attribute and link
	// values of @item and using them to form a new item within @menu. As such,
	// @item itself is not really inserted, but rather, a menu item that is
	// exactly the same as the one presently described by @item.
	//
	// This means that @item is essentially useless after the insertion occurs.
	// Any changes you make to it are ignored unless it is inserted again (at
	// which point its updated values will be copied).
	//
	// You should probably just free @item once you're done.
	//
	// There are many convenience functions to take care of common cases. See
	// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as
	// well as "prepend" and "append" variants of each of these functions.
	InsertItem(position int, item MenuItem)
	// InsertSection: convenience function for inserting a section menu item
	// into @menu. Combine g_menu_item_new_section() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSection(position int, label string, section MenuModel)
	// InsertSubmenu: convenience function for inserting a submenu menu item
	// into @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSubmenu(position int, label string, submenu MenuModel)
	// Prepend: convenience function for prepending a normal menu item to the
	// start of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a
	// more flexible alternative.
	Prepend(label string, detailedAction string)
	// PrependItem prepends @item to the start of @menu.
	//
	// See g_menu_insert_item() for more information.
	PrependItem(item MenuItem)
	// PrependSection: convenience function for prepending a section menu item
	// to the start of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSection(label string, section MenuModel)
	// PrependSubmenu: convenience function for prepending a submenu menu item
	// to the start of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSubmenu(label string, submenu MenuModel)
	// Remove removes an item from the menu.
	//
	// @position gives the index of the item to remove.
	//
	// It is an error if position is not in range the range from 0 to one less
	// than the number of items in the menu.
	//
	// It is not possible to remove items by identity since items are added to
	// the menu simply by copying their links and attributes (ie: identity of
	// the item itself is not preserved).
	Remove(position int)
	// RemoveAll removes all items in the menu.
	RemoveAll()
}

// menu implements the Menu interface.
type menu struct {
	MenuModel
}

var _ Menu = (*menu)(nil)

// WrapMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenu(obj *externglib.Object) Menu {
	return Menu{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenu(obj), nil
}

// NewMenu constructs a class Menu.
func NewMenu() Menu {
	var cret C.GMenu
	var ret1 Menu

	cret = C.g_menu_new()

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Menu)

	return ret1
}

// Append: convenience function for appending a normal menu item to the end
// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (m menu) Append(label string, detailedAction string) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg2))

	C.g_menu_append(arg0, label, detailedAction)
}

// AppendItem appends @item to the end of @menu.
//
// See g_menu_insert_item() for more information.
func (m menu) AppendItem(item MenuItem) {
	var arg0 *C.GMenu
	var arg1 *C.GMenuItem

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_append_item(arg0, item)
}

// AppendSection: convenience function for appending a section menu item to
// the end of @menu. Combine g_menu_item_new_section() and
// g_menu_insert_item() for a more flexible alternative.
func (m menu) AppendSection(label string, section MenuModel) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_append_section(arg0, label, section)
}

// AppendSubmenu: convenience function for appending a submenu menu item to
// the end of @menu. Combine g_menu_item_new_submenu() and
// g_menu_insert_item() for a more flexible alternative.
func (m menu) AppendSubmenu(label string, submenu MenuModel) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_append_submenu(arg0, label, submenu)
}

// Freeze marks @menu as frozen.
//
// After the menu is frozen, it is an error to attempt to make any changes
// to it. In effect this means that the #GMenu API must no longer be used.
//
// This function causes g_menu_model_is_mutable() to begin returning false,
// which has some positive performance implications.
func (m menu) Freeze() {
	var arg0 *C.GMenu

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_freeze(arg0)
}

// Insert: convenience function for inserting a normal menu item into @menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (m menu) Insert(position int, label string, detailedAction string) {
	var arg0 *C.GMenu
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = C.gint(position)
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg3))

	C.g_menu_insert(arg0, position, label, detailedAction)
}

// InsertItem inserts @item into @menu.
//
// The "insertion" is actually done by copying all of the attribute and link
// values of @item and using them to form a new item within @menu. As such,
// @item itself is not really inserted, but rather, a menu item that is
// exactly the same as the one presently described by @item.
//
// This means that @item is essentially useless after the insertion occurs.
// Any changes you make to it are ignored unless it is inserted again (at
// which point its updated values will be copied).
//
// You should probably just free @item once you're done.
//
// There are many convenience functions to take care of common cases. See
// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as
// well as "prepend" and "append" variants of each of these functions.
func (m menu) InsertItem(position int, item MenuItem) {
	var arg0 *C.GMenu
	var arg1 C.gint
	var arg2 *C.GMenuItem

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = C.gint(position)
	arg2 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_insert_item(arg0, position, item)
}

// InsertSection: convenience function for inserting a section menu item
// into @menu. Combine g_menu_item_new_section() and g_menu_insert_item()
// for a more flexible alternative.
func (m menu) InsertSection(position int, label string, section MenuModel) {
	var arg0 *C.GMenu
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.GMenuModel

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = C.gint(position)
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_insert_section(arg0, position, label, section)
}

// InsertSubmenu: convenience function for inserting a submenu menu item
// into @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
// for a more flexible alternative.
func (m menu) InsertSubmenu(position int, label string, submenu MenuModel) {
	var arg0 *C.GMenu
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.GMenuModel

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = C.gint(position)
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_insert_submenu(arg0, position, label, submenu)
}

// Prepend: convenience function for prepending a normal menu item to the
// start of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a
// more flexible alternative.
func (m menu) Prepend(label string, detailedAction string) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg2))

	C.g_menu_prepend(arg0, label, detailedAction)
}

// PrependItem prepends @item to the start of @menu.
//
// See g_menu_insert_item() for more information.
func (m menu) PrependItem(item MenuItem) {
	var arg0 *C.GMenu
	var arg1 *C.GMenuItem

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_prepend_item(arg0, item)
}

// PrependSection: convenience function for prepending a section menu item
// to the start of @menu. Combine g_menu_item_new_section() and
// g_menu_insert_item() for a more flexible alternative.
func (m menu) PrependSection(label string, section MenuModel) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_prepend_section(arg0, label, section)
}

// PrependSubmenu: convenience function for prepending a submenu menu item
// to the start of @menu. Combine g_menu_item_new_submenu() and
// g_menu_insert_item() for a more flexible alternative.
func (m menu) PrependSubmenu(label string, submenu MenuModel) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_prepend_submenu(arg0, label, submenu)
}

// Remove removes an item from the menu.
//
// @position gives the index of the item to remove.
//
// It is an error if position is not in range the range from 0 to one less
// than the number of items in the menu.
//
// It is not possible to remove items by identity since items are added to
// the menu simply by copying their links and attributes (ie: identity of
// the item itself is not preserved).
func (m menu) Remove(position int) {
	var arg0 *C.GMenu
	var arg1 C.gint

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	arg1 = C.gint(position)

	C.g_menu_remove(arg0, position)
}

// RemoveAll removes all items in the menu.
func (m menu) RemoveAll() {
	var arg0 *C.GMenu

	arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_remove_all(arg0)
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem interface {
	gextras.Objector

	// AttributeValue queries the named @attribute on @menu_item.
	//
	// If @expected_type is specified and the attribute does not have this type,
	// nil is returned. nil is also returned if the attribute simply does not
	// exist.
	AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant
	// Link queries the named @link on @menu_item.
	Link(link string) MenuModel
	// SetActionAndTargetValue sets or unsets the "action" and "target"
	// attributes of @menu_item.
	//
	// If @action is nil then both the "action" and "target" attributes are
	// unset (and @target_value is ignored).
	//
	// If @action is non-nil then the "action" attribute is set. The "target"
	// attribute is then set to the value of @target_value if it is non-nil or
	// unset otherwise.
	//
	// Normal menu items (ie: not submenu, section or other custom item types)
	// are expected to have the "action" attribute set to identify the action
	// that they are associated with. The state type of the action help to
	// determine the disposition of the menu item. See #GAction and Group for an
	// overview of actions.
	//
	// In general, clicking on the menu item will result in activation of the
	// named action with the "target" attribute given as the parameter to the
	// action invocation. If the "target" attribute is not set then the action
	// is invoked with no parameter.
	//
	// If the action has no state then the menu item is usually drawn as a plain
	// menu item (ie: with no additional decoration).
	//
	// If the action has a boolean state then the menu item is usually drawn as
	// a toggle menu item (ie: with a checkmark or equivalent indication). The
	// item should be marked as 'toggled' or 'checked' when the boolean state is
	// true.
	//
	// If the action has a string state then the menu item is usually drawn as a
	// radio menu item (ie: with a radio bullet or equivalent indication). The
	// item should be marked as 'selected' when the string state is equal to the
	// value of the @target property.
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_detailed_action() for two equivalent calls that are
	// probably more convenient for most uses.
	SetActionAndTargetValue(action string, targetValue *glib.Variant)
	// SetAttributeValue sets or unsets an attribute on @menu_item.
	//
	// The attribute to set or unset is specified by @attribute. This can be one
	// of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
	// G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom attribute
	// name. Attribute names are restricted to lowercase characters, numbers and
	// '-'. Furthermore, the names must begin with a lowercase character, must
	// not end with a '-', and must not contain consecutive dashes.
	//
	// must consist only of lowercase ASCII characters, digits and '-'.
	//
	// If @value is non-nil then it is used as the new value for the attribute.
	// If @value is nil then the attribute is unset. If the @value #GVariant is
	// floating, it is consumed.
	//
	// See also g_menu_item_set_attribute() for a more convenient way to do the
	// same.
	SetAttributeValue(attribute string, value *glib.Variant)
	// SetDetailedAction sets the "action" and possibly the "target" attribute
	// of @menu_item.
	//
	// The format of @detailed_action is the same format parsed by
	// g_action_parse_detailed_name().
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_action_and_target_value() for more flexible (but slightly
	// less convenient) alternatives.
	//
	// See also g_menu_item_set_action_and_target_value() for a description of
	// the semantics of the action and target attributes.
	SetDetailedAction(detailedAction string)
	// SetIcon sets (or unsets) the icon on @menu_item.
	//
	// This call is the same as calling g_icon_serialize() and using the result
	// as the value to g_menu_item_set_attribute_value() for
	// G_MENU_ATTRIBUTE_ICON.
	//
	// This API is only intended for use with "noun" menu items; things like
	// bookmarks or applications in an "Open With" menu. Don't use it on menu
	// items corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
	//
	// If @icon is nil then the icon is unset.
	SetIcon(icon Icon)
	// SetLabel sets or unsets the "label" attribute of @menu_item.
	//
	// If @label is non-nil it is used as the label for the menu item. If it is
	// nil then the label attribute is unset.
	SetLabel(label string)
	// SetLink creates a link from @menu_item to @model if non-nil, or unsets
	// it.
	//
	// Links are used to establish a relationship between a particular menu item
	// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate a
	// submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
	// create a section. Other types of link can be used, but there is no
	// guarantee that clients will be able to make sense of them. Link types are
	// restricted to lowercase characters, numbers and '-'. Furthermore, the
	// names must begin with a lowercase character, must not end with a '-', and
	// must not contain consecutive dashes.
	SetLink(link string, model MenuModel)
	// SetSection sets or unsets the "section" link of @menu_item to @section.
	//
	// The effect of having one menu appear as a section of another is exactly
	// as it sounds: the items from @section become a direct part of the menu
	// that @menu_item is added to. See g_menu_item_new_section() for more
	// information about what it means for a menu item to be a section.
	SetSection(section MenuModel)
	// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
	//
	// If @submenu is non-nil, it is linked to. If it is nil then the link is
	// unset.
	//
	// The effect of having one menu appear as a submenu of another is exactly
	// as it sounds.
	SetSubmenu(submenu MenuModel)
}

// menuItem implements the MenuItem interface.
type menuItem struct {
	gextras.Objector
}

var _ MenuItem = (*menuItem)(nil)

// WrapMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuItem(obj *externglib.Object) MenuItem {
	return MenuItem{
		Objector: obj,
	}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuItem(obj), nil
}

// NewMenuItem constructs a class MenuItem.
func NewMenuItem(label string, detailedAction string) MenuItem {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.GMenuItem
	var ret1 MenuItem

	cret = C.g_menu_item_new(label, detailedAction)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(MenuItem)

	return ret1
}

// NewMenuItemFromModel constructs a class MenuItem.
func NewMenuItemFromModel(model MenuModel, itemIndex int) MenuItem {
	var arg1 *C.GMenuModel
	var arg2 C.gint

	arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	arg2 = C.gint(itemIndex)

	var cret C.GMenuItem
	var ret1 MenuItem

	cret = C.g_menu_item_new_from_model(model, itemIndex)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(MenuItem)

	return ret1
}

// NewMenuItemSection constructs a class MenuItem.
func NewMenuItemSection(label string, section MenuModel) MenuItem {
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	var cret C.GMenuItem
	var ret1 MenuItem

	cret = C.g_menu_item_new_section(label, section)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(MenuItem)

	return ret1
}

// NewMenuItemSubmenu constructs a class MenuItem.
func NewMenuItemSubmenu(label string, submenu MenuModel) MenuItem {
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	var cret C.GMenuItem
	var ret1 MenuItem

	cret = C.g_menu_item_new_submenu(label, submenu)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(MenuItem)

	return ret1
}

// AttributeValue queries the named @attribute on @menu_item.
//
// If @expected_type is specified and the attribute does not have this type,
// nil is returned. nil is also returned if the attribute simply does not
// exist.
func (m menuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar
	var arg2 *C.GVariantType

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	var cret *C.GVariant
	var ret1 *glib.Variant

	cret = C.g_menu_item_get_attribute_value(arg0, attribute, expectedType)

	ret1 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Link queries the named @link on @menu_item.
func (m menuItem) Link(link string) MenuModel {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GMenuModel
	var ret1 MenuModel

	cret = C.g_menu_item_get_link(arg0, link)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(MenuModel)

	return ret1
}

// SetActionAndTargetValue sets or unsets the "action" and "target"
// attributes of @menu_item.
//
// If @action is nil then both the "action" and "target" attributes are
// unset (and @target_value is ignored).
//
// If @action is non-nil then the "action" attribute is set. The "target"
// attribute is then set to the value of @target_value if it is non-nil or
// unset otherwise.
//
// Normal menu items (ie: not submenu, section or other custom item types)
// are expected to have the "action" attribute set to identify the action
// that they are associated with. The state type of the action help to
// determine the disposition of the menu item. See #GAction and Group for an
// overview of actions.
//
// In general, clicking on the menu item will result in activation of the
// named action with the "target" attribute given as the parameter to the
// action invocation. If the "target" attribute is not set then the action
// is invoked with no parameter.
//
// If the action has no state then the menu item is usually drawn as a plain
// menu item (ie: with no additional decoration).
//
// If the action has a boolean state then the menu item is usually drawn as
// a toggle menu item (ie: with a checkmark or equivalent indication). The
// item should be marked as 'toggled' or 'checked' when the boolean state is
// true.
//
// If the action has a string state then the menu item is usually drawn as a
// radio menu item (ie: with a radio bullet or equivalent indication). The
// item should be marked as 'selected' when the string state is equal to the
// value of the @target property.
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_detailed_action() for two equivalent calls that are
// probably more convenient for most uses.
func (m menuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(targetValue.Native()))

	C.g_menu_item_set_action_and_target_value(arg0, action, targetValue)
}

// SetAttributeValue sets or unsets an attribute on @menu_item.
//
// The attribute to set or unset is specified by @attribute. This can be one
// of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
// G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom attribute
// name. Attribute names are restricted to lowercase characters, numbers and
// '-'. Furthermore, the names must begin with a lowercase character, must
// not end with a '-', and must not contain consecutive dashes.
//
// must consist only of lowercase ASCII characters, digits and '-'.
//
// If @value is non-nil then it is used as the new value for the attribute.
// If @value is nil then the attribute is unset. If the @value #GVariant is
// floating, it is consumed.
//
// See also g_menu_item_set_attribute() for a more convenient way to do the
// same.
func (m menuItem) SetAttributeValue(attribute string, value *glib.Variant) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_menu_item_set_attribute_value(arg0, attribute, value)
}

// SetDetailedAction sets the "action" and possibly the "target" attribute
// of @menu_item.
//
// The format of @detailed_action is the same format parsed by
// g_action_parse_detailed_name().
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but slightly
// less convenient) alternatives.
//
// See also g_menu_item_set_action_and_target_value() for a description of
// the semantics of the action and target attributes.
func (m menuItem) SetDetailedAction(detailedAction string) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg1))

	C.g_menu_item_set_detailed_action(arg0, detailedAction)
}

// SetIcon sets (or unsets) the icon on @menu_item.
//
// This call is the same as calling g_icon_serialize() and using the result
// as the value to g_menu_item_set_attribute_value() for
// G_MENU_ATTRIBUTE_ICON.
//
// This API is only intended for use with "noun" menu items; things like
// bookmarks or applications in an "Open With" menu. Don't use it on menu
// items corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
//
// If @icon is nil then the icon is unset.
func (m menuItem) SetIcon(icon Icon) {
	var arg0 *C.GMenuItem
	var arg1 *C.GIcon

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_menu_item_set_icon(arg0, icon)
}

// SetLabel sets or unsets the "label" attribute of @menu_item.
//
// If @label is non-nil it is used as the label for the menu item. If it is
// nil then the label attribute is unset.
func (m menuItem) SetLabel(label string) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.g_menu_item_set_label(arg0, label)
}

// SetLink creates a link from @menu_item to @model if non-nil, or unsets
// it.
//
// Links are used to establish a relationship between a particular menu item
// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate a
// submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
// create a section. Other types of link can be used, but there is no
// guarantee that clients will be able to make sense of them. Link types are
// restricted to lowercase characters, numbers and '-'. Furthermore, the
// names must begin with a lowercase character, must not end with a '-', and
// must not contain consecutive dashes.
func (m menuItem) SetLink(link string, model MenuModel) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.g_menu_item_set_link(arg0, link, model)
}

// SetSection sets or unsets the "section" link of @menu_item to @section.
//
// The effect of having one menu appear as a section of another is exactly
// as it sounds: the items from @section become a direct part of the menu
// that @menu_item is added to. See g_menu_item_new_section() for more
// information about what it means for a menu item to be a section.
func (m menuItem) SetSection(section MenuModel) {
	var arg0 *C.GMenuItem
	var arg1 *C.GMenuModel

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_item_set_section(arg0, section)
}

// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
//
// If @submenu is non-nil, it is linked to. If it is nil then the link is
// unset.
//
// The effect of having one menu appear as a submenu of another is exactly
// as it sounds.
func (m menuItem) SetSubmenu(submenu MenuModel) {
	var arg0 *C.GMenuItem
	var arg1 *C.GMenuModel

	arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_item_set_submenu(arg0, submenu)
}

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification interface {
	gextras.Objector

	// AddButton adds a button to @notification that activates the action in
	// @detailed_action when clicked. That action must be an application-wide
	// action (starting with "app."). If @detailed_action contains a target, the
	// action will be activated with that target as its parameter.
	//
	// See g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	AddButton(label string, detailedAction string)
	// AddButtonWithTargetValue adds a button to @notification that activates
	// @action when clicked. @action must be an application-wide action (it must
	// start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	AddButtonWithTargetValue(label string, action string, target *glib.Variant)
	// SetBody sets the body of @notification to @body.
	SetBody(body string)
	// SetDefaultAction sets the default action of @notification to
	// @detailed_action. This action is activated when the notification is
	// clicked on.
	//
	// The action in @detailed_action must be an application-wide action (it
	// must start with "app."). If @detailed_action contains a target, the given
	// action will be activated with that target as its parameter. See
	// g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultAction(detailedAction string)
	// SetDefaultActionAndTargetValue sets the default action of @notification
	// to @action. This action is activated when the notification is clicked on.
	// It must be an application-wide action (start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultActionAndTargetValue(action string, target *glib.Variant)
	// SetIcon sets the icon of @notification to @icon.
	SetIcon(icon Icon)
	// SetPriority sets the priority of @notification to @priority. See Priority
	// for possible values.
	SetPriority(priority NotificationPriority)
	// SetTitle sets the title of @notification to @title.
	SetTitle(title string)
	// SetUrgent: deprecated in favor of g_notification_set_priority().
	SetUrgent(urgent bool)
}

// notification implements the Notification interface.
type notification struct {
	gextras.Objector
}

var _ Notification = (*notification)(nil)

// WrapNotification wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotification(obj *externglib.Object) Notification {
	return Notification{
		Objector: obj,
	}
}

func marshalNotification(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotification(obj), nil
}

// NewNotification constructs a class Notification.
func NewNotification(title string) Notification {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GNotification
	var ret1 Notification

	cret = C.g_notification_new(title)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Notification)

	return ret1
}

// AddButton adds a button to @notification that activates the action in
// @detailed_action when clicked. That action must be an application-wide
// action (starting with "app."). If @detailed_action contains a target, the
// action will be activated with that target as its parameter.
//
// See g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
func (n notification) AddButton(label string, detailedAction string) {
	var arg0 *C.GNotification
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg2))

	C.g_notification_add_button(arg0, label, detailedAction)
}

// AddButtonWithTargetValue adds a button to @notification that activates
// @action when clicked. @action must be an application-wide action (it must
// start with "app.").
//
// If @target is non-nil, @action will be activated with @target as its
// parameter.
func (n notification) AddButtonWithTargetValue(label string, action string, target *glib.Variant) {
	var arg0 *C.GNotification
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.GVariant

	arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GVariant)(unsafe.Pointer(target.Native()))

	C.g_notification_add_button_with_target_value(arg0, label, action, target)
}

// SetBody sets the body of @notification to @body.
func (n notification) SetBody(body string) {
	var arg0 *C.GNotification
	var arg1 *C.gchar

	arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	arg1 = (*C.gchar)(C.CString(body))
	defer C.free(unsafe.Pointer(arg1))

	C.g_notification_set_body(arg0, body)
}

// SetDefaultAction sets the default action of @notification to
// @detailed_action. This action is activated when the notification is
// clicked on.
//
// The action in @detailed_action must be an application-wide action (it
// must start with "app."). If @detailed_action contains a target, the given
// action will be activated with that target as its parameter. See
// g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
//
// When no default action is set, the application that the notification was
// sent on is activated.
func (n notification) SetDefaultAction(detailedAction string) {
	var arg0 *C.GNotification
	var arg1 *C.gchar

	arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg1))

	C.g_notification_set_default_action(arg0, detailedAction)
}

// SetDefaultActionAndTargetValue sets the default action of @notification
// to @action. This action is activated when the notification is clicked on.
// It must be an application-wide action (start with "app.").
//
// If @target is non-nil, @action will be activated with @target as its
// parameter.
//
// When no default action is set, the application that the notification was
// sent on is activated.
func (n notification) SetDefaultActionAndTargetValue(action string, target *glib.Variant) {
	var arg0 *C.GNotification
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(target.Native()))

	C.g_notification_set_default_action_and_target_value(arg0, action, target)
}

// SetIcon sets the icon of @notification to @icon.
func (n notification) SetIcon(icon Icon) {
	var arg0 *C.GNotification
	var arg1 *C.GIcon

	arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_notification_set_icon(arg0, icon)
}

// SetPriority sets the priority of @notification to @priority. See Priority
// for possible values.
func (n notification) SetPriority(priority NotificationPriority) {
	var arg0 *C.GNotification
	var arg1 C.GNotificationPriority

	arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	arg1 = (C.GNotificationPriority)(priority)

	C.g_notification_set_priority(arg0, priority)
}

// SetTitle sets the title of @notification to @title.
func (n notification) SetTitle(title string) {
	var arg0 *C.GNotification
	var arg1 *C.gchar

	arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.g_notification_set_title(arg0, title)
}

// SetUrgent: deprecated in favor of g_notification_set_priority().
func (n notification) SetUrgent(urgent bool) {
	var arg0 *C.GNotification
	var arg1 C.gboolean

	arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	if urgent {
		arg1 = C.gboolean(1)
	}

	C.g_notification_set_urgent(arg0, urgent)
}

// PropertyAction: a Action is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction interface {
	gextras.Objector
	Action
}

// propertyAction implements the PropertyAction interface.
type propertyAction struct {
	gextras.Objector
	Action
}

var _ PropertyAction = (*propertyAction)(nil)

// WrapPropertyAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapPropertyAction(obj *externglib.Object) PropertyAction {
	return PropertyAction{
		Objector: obj,
		Action:   WrapAction(obj),
	}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPropertyAction(obj), nil
}

// NewPropertyAction constructs a class PropertyAction.
func NewPropertyAction(name string, object gextras.Objector, propertyName string) PropertyAction {
	var arg1 *C.gchar
	var arg2 C.gpointer
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
	arg3 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg3))

	var cret C.GPropertyAction
	var ret1 PropertyAction

	cret = C.g_property_action_new(name, object, propertyName)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PropertyAction)

	return ret1
}

// SimpleAction: a Action is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of adding
// it to a ActionGroup.
//
// See also Action.
type SimpleAction interface {
	gextras.Objector
	Action

	// SetEnabled sets the action as enabled or not.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to modify its enabled flag.
	SetEnabled(enabled bool)
	// SetState sets the state of the action.
	//
	// This directly updates the 'state' property to the given value.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to directly modify the 'state' property.
	// Instead, they should call g_action_change_state() to request the change.
	//
	// If the @value GVariant is floating, it is consumed.
	SetState(value *glib.Variant)
	// SetStateHint sets the state hint for the action.
	//
	// See g_action_get_state_hint() for more information about action state
	// hints.
	SetStateHint(stateHint *glib.Variant)
}

// simpleAction implements the SimpleAction interface.
type simpleAction struct {
	gextras.Objector
	Action
}

var _ SimpleAction = (*simpleAction)(nil)

// WrapSimpleAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleAction(obj *externglib.Object) SimpleAction {
	return SimpleAction{
		Objector: obj,
		Action:   WrapAction(obj),
	}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAction(obj), nil
}

// NewSimpleAction constructs a class SimpleAction.
func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction {
	var arg1 *C.gchar
	var arg2 *C.GVariantType

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))

	var cret C.GSimpleAction
	var ret1 SimpleAction

	cret = C.g_simple_action_new(name, parameterType)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SimpleAction)

	return ret1
}

// NewSimpleActionStateful constructs a class SimpleAction.
func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) SimpleAction {
	var arg1 *C.gchar
	var arg2 *C.GVariantType
	var arg3 *C.GVariant

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))
	arg3 = (*C.GVariant)(unsafe.Pointer(state.Native()))

	var cret C.GSimpleAction
	var ret1 SimpleAction

	cret = C.g_simple_action_new_stateful(name, parameterType, state)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SimpleAction)

	return ret1
}

// SetEnabled sets the action as enabled or not.
//
// An action must be enabled in order to be activated or in order to have
// its state changed from outside callers.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to modify its enabled flag.
func (s simpleAction) SetEnabled(enabled bool) {
	var arg0 *C.GSimpleAction
	var arg1 C.gboolean

	arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	if enabled {
		arg1 = C.gboolean(1)
	}

	C.g_simple_action_set_enabled(arg0, enabled)
}

// SetState sets the state of the action.
//
// This directly updates the 'state' property to the given value.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to directly modify the 'state' property.
// Instead, they should call g_action_change_state() to request the change.
//
// If the @value GVariant is floating, it is consumed.
func (s simpleAction) SetState(value *glib.Variant) {
	var arg0 *C.GSimpleAction
	var arg1 *C.GVariant

	arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_simple_action_set_state(arg0, value)
}

// SetStateHint sets the state hint for the action.
//
// See g_action_get_state_hint() for more information about action state
// hints.
func (s simpleAction) SetStateHint(stateHint *glib.Variant) {
	var arg0 *C.GSimpleAction
	var arg1 *C.GVariant

	arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GVariant)(unsafe.Pointer(stateHint.Native()))

	C.g_simple_action_set_state_hint(arg0, stateHint)
}

// SimpleIOStream: GSimpleIOStream creates a OStream from an arbitrary Stream
// and Stream. This allows any pair of input and output streams to be used with
// OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream interface {
	IOStream
}

// simpleIOStream implements the SimpleIOStream interface.
type simpleIOStream struct {
	IOStream
}

var _ SimpleIOStream = (*simpleIOStream)(nil)

// WrapSimpleIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleIOStream(obj *externglib.Object) SimpleIOStream {
	return SimpleIOStream{
		IOStream: WrapIOStream(obj),
	}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleIOStream(obj), nil
}

// NewSimpleIOStream constructs a class SimpleIOStream.
func NewSimpleIOStream(inputStream InputStream, outputStream OutputStream) SimpleIOStream {
	var arg1 *C.GInputStream
	var arg2 *C.GOutputStream

	arg1 = (*C.GInputStream)(unsafe.Pointer(inputStream.Native()))
	arg2 = (*C.GOutputStream)(unsafe.Pointer(outputStream.Native()))

	var cret C.GSimpleIOStream
	var ret1 SimpleIOStream

	cret = C.g_simple_io_stream_new(inputStream, outputStream)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SimpleIOStream)

	return ret1
}

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission interface {
	Permission
}

// simplePermission implements the SimplePermission interface.
type simplePermission struct {
	Permission
}

var _ SimplePermission = (*simplePermission)(nil)

// WrapSimplePermission wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimplePermission(obj *externglib.Object) SimplePermission {
	return SimplePermission{
		Permission: WrapPermission(obj),
	}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimplePermission(obj), nil
}

// NewSimplePermission constructs a class SimplePermission.
func NewSimplePermission(allowed bool) SimplePermission {
	var arg1 C.gboolean

	if allowed {
		arg1 = C.gboolean(1)
	}

	var cret C.GSimplePermission
	var ret1 SimplePermission

	cret = C.g_simple_permission_new(allowed)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SimplePermission)

	return ret1
}

// Subprocess allows the creation of and interaction with child processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess interface {
	gextras.Objector
	Initable

	// Communicate: communicate with the subprocess until it terminates, and all
	// input and output has been completed.
	//
	// If @stdin_buf is given, the subprocess must have been created with
	// G_SUBPROCESS_FLAGS_STDIN_PIPE. The given data is fed to the stdin of the
	// subprocess and the pipe is closed (ie: EOF).
	//
	// At the same time (as not to cause blocking when dealing with large
	// amounts of data), if G_SUBPROCESS_FLAGS_STDOUT_PIPE or
	// G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those streams. The
	// data that was read is returned in @stdout and/or the @stderr.
	//
	// If the subprocess was created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
	// @stdout_buf will contain the data read from stdout. Otherwise, for
	// subprocesses not created with G_SUBPROCESS_FLAGS_STDOUT_PIPE, @stdout_buf
	// will be set to nil. Similar provisions apply to @stderr_buf and
	// G_SUBPROCESS_FLAGS_STDERR_PIPE.
	//
	// As usual, any output variable may be given as nil to ignore it.
	//
	// If you desire the stdout and stderr data to be interleaved, create the
	// subprocess with G_SUBPROCESS_FLAGS_STDOUT_PIPE and
	// G_SUBPROCESS_FLAGS_STDERR_MERGE. The merged result will be returned in
	// @stdout_buf and @stderr_buf will be set to nil.
	//
	// In case of any error (including cancellation), false will be returned
	// with @error set. Some or all of the stdin data may have been written. Any
	// stdout or stderr data that has been read will be discarded. None of the
	// out variables (aside from @error) will have been set to anything in
	// particular and should not be inspected.
	//
	// In the case that true is returned, the subprocess has exited and the exit
	// status inspection APIs (eg: g_subprocess_get_if_exited(),
	// g_subprocess_get_exit_status()) may be used.
	//
	// You should not attempt to use any of the subprocess pipes after starting
	// this function, since they may be left in strange states, even if the
	// operation was cancelled. You should especially not attempt to interact
	// with the pipes while the operation is in progress (either from another
	// thread or if using the asynchronous version).
	Communicate(stdinBuf *glib.Bytes, cancellable Cancellable) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, err error)
	// CommunicateAsync asynchronous version of g_subprocess_communicate().
	// Complete invocation with g_subprocess_communicate_finish().
	CommunicateAsync(stdinBuf *glib.Bytes, cancellable Cancellable, callback AsyncReadyCallback)
	// CommunicateFinish: complete an invocation of
	// g_subprocess_communicate_async().
	CommunicateFinish(result AsyncResult) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, err error)
	// CommunicateUTF8: like g_subprocess_communicate(), but validates the
	// output of the process as UTF-8, and returns it as a regular NUL
	// terminated string.
	//
	// On error, @stdout_buf and @stderr_buf will be set to undefined values and
	// should not be used.
	CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, err error)
	// CommunicateUTF8Async asynchronous version of
	// g_subprocess_communicate_utf8(). Complete invocation with
	// g_subprocess_communicate_utf8_finish().
	CommunicateUTF8Async(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback)
	// CommunicateUTF8Finish: complete an invocation of
	// g_subprocess_communicate_utf8_async().
	CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, err error)
	// ForceExit: use an operating-system specific method to attempt an
	// immediate, forceful termination of the process. There is no mechanism to
	// determine whether or not the request itself was successful; however, you
	// can use g_subprocess_wait() to monitor the status of the process after
	// calling this function.
	//
	// On Unix, this function sends SIGKILL.
	ForceExit()
	// ExitStatus: check the exit status of the subprocess, given that it exited
	// normally. This is the value passed to the exit() system call or the
	// return value from main.
	//
	// This is equivalent to the system WEXITSTATUS macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_exited() returned true.
	ExitStatus() int
	// Identifier: on UNIX, returns the process ID as a decimal string. On
	// Windows, returns the result of GetProcessId() also as a string. If the
	// subprocess has terminated, this will return nil.
	Identifier() string
	// IfExited: check if the given subprocess exited normally (ie: by way of
	// exit() or return from main()).
	//
	// This is equivalent to the system WIFEXITED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfExited() bool
	// IfSignaled: check if the given subprocess terminated in response to a
	// signal.
	//
	// This is equivalent to the system WIFSIGNALED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfSignaled() bool
	// Status gets the raw status code of the process, as from waitpid().
	//
	// This value has no particular meaning, but it can be used with the macros
	// defined by the system headers such as WIFEXITED. It can also be used with
	// g_spawn_check_exit_status().
	//
	// It is more likely that you want to use g_subprocess_get_if_exited()
	// followed by g_subprocess_get_exit_status().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Status() int
	// StderrPipe gets the Stream from which to read the stderr output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE.
	StderrPipe() InputStream
	// StdinPipe gets the Stream that you can write to in order to give data to
	// the stdin of @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE.
	StdinPipe() OutputStream
	// StdoutPipe gets the Stream from which to read the stdout output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE.
	StdoutPipe() InputStream
	// Successful checks if the process was "successful". A process is
	// considered successful if it exited cleanly with an exit status of 0,
	// either by way of the exit() system call or return from main().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Successful() bool
	// TermSig: get the signal number that caused the subprocess to terminate,
	// given that it terminated due to a signal.
	//
	// This is equivalent to the system WTERMSIG macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_signaled() returned true.
	TermSig() int
	// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
	// still running.
	//
	// This API is race-free. If the subprocess has terminated, it will not be
	// signalled.
	//
	// This API is not available on Windows.
	SendSignal(signalNum int)
	// Wait: synchronously wait for the subprocess to terminate.
	//
	// After the process terminates you can query its exit status with functions
	// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
	//
	// This function does not fail in the case of the subprocess having abnormal
	// termination. See g_subprocess_wait_check() for that.
	//
	// Cancelling @cancellable doesn't kill the subprocess. Call
	// g_subprocess_force_exit() if it is desirable.
	Wait(cancellable Cancellable) error
	// WaitAsync: wait for the subprocess to terminate.
	//
	// This is the asynchronous version of g_subprocess_wait().
	WaitAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
	WaitCheck(cancellable Cancellable) error
	// WaitCheckAsync combines g_subprocess_wait_async() with
	// g_spawn_check_exit_status().
	//
	// This is the asynchronous version of g_subprocess_wait_check().
	WaitCheckAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// WaitCheckFinish collects the result of a previous call to
	// g_subprocess_wait_check_async().
	WaitCheckFinish(result AsyncResult) error
	// WaitFinish collects the result of a previous call to
	// g_subprocess_wait_async().
	WaitFinish(result AsyncResult) error
}

// subprocess implements the Subprocess interface.
type subprocess struct {
	gextras.Objector
	Initable
}

var _ Subprocess = (*subprocess)(nil)

// WrapSubprocess wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocess(obj *externglib.Object) Subprocess {
	return Subprocess{
		Objector: obj,
		Initable: WrapInitable(obj),
	}
}

func marshalSubprocess(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocess(obj), nil
}

// NewSubprocessV constructs a class Subprocess.
func NewSubprocessV(argv []string, flags SubprocessFlags) (subprocess Subprocess, err error) {
	var arg1 **C.gchar
	var arg2 C.GSubprocessFlags

	arg1 = C.malloc(len(argv) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(argv)))

		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	arg2 = (C.GSubprocessFlags)(flags)

	var errout *C.GError
	var goerr error
	var cret C.GSubprocess
	var ret2 Subprocess

	cret = C.g_subprocess_newv(argv, flags, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Subprocess)

	return goerr, ret2
}

// Communicate: communicate with the subprocess until it terminates, and all
// input and output has been completed.
//
// If @stdin_buf is given, the subprocess must have been created with
// G_SUBPROCESS_FLAGS_STDIN_PIPE. The given data is fed to the stdin of the
// subprocess and the pipe is closed (ie: EOF).
//
// At the same time (as not to cause blocking when dealing with large
// amounts of data), if G_SUBPROCESS_FLAGS_STDOUT_PIPE or
// G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those streams. The
// data that was read is returned in @stdout and/or the @stderr.
//
// If the subprocess was created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// @stdout_buf will contain the data read from stdout. Otherwise, for
// subprocesses not created with G_SUBPROCESS_FLAGS_STDOUT_PIPE, @stdout_buf
// will be set to nil. Similar provisions apply to @stderr_buf and
// G_SUBPROCESS_FLAGS_STDERR_PIPE.
//
// As usual, any output variable may be given as nil to ignore it.
//
// If you desire the stdout and stderr data to be interleaved, create the
// subprocess with G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDERR_MERGE. The merged result will be returned in
// @stdout_buf and @stderr_buf will be set to nil.
//
// In case of any error (including cancellation), false will be returned
// with @error set. Some or all of the stdin data may have been written. Any
// stdout or stderr data that has been read will be discarded. None of the
// out variables (aside from @error) will have been set to anything in
// particular and should not be inspected.
//
// In the case that true is returned, the subprocess has exited and the exit
// status inspection APIs (eg: g_subprocess_get_if_exited(),
// g_subprocess_get_exit_status()) may be used.
//
// You should not attempt to use any of the subprocess pipes after starting
// this function, since they may be left in strange states, even if the
// operation was cancelled. You should especially not attempt to interact
// with the pipes while the operation is in progress (either from another
// thread or if using the asynchronous version).
func (s subprocess) Communicate(stdinBuf *glib.Bytes, cancellable Cancellable) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, err error) {
	var arg0 *C.GSubprocess
	var arg1 *C.GBytes
	var arg2 *C.GCancellable

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GBytes)(unsafe.Pointer(stdinBuf.Native()))
	arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var arg3 *C.GBytes
	var ret3 **glib.Bytes
	var arg4 *C.GBytes
	var ret4 **glib.Bytes
	var errout *C.GError
	var goerr error

	C.g_subprocess_communicate(arg0, stdinBuf, cancellable, &arg3, &arg4, &errout)

	*ret3 = glib.WrapBytes(unsafe.Pointer(arg3))
	runtime.SetFinalizer(*ret3, func(v **glib.Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})
	*ret4 = glib.WrapBytes(unsafe.Pointer(arg4))
	runtime.SetFinalizer(*ret4, func(v **glib.Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})
	goerr = gerror.Take(unsafe.Pointer(errout))

	return ret3, ret4, goerr
}

// CommunicateAsync asynchronous version of g_subprocess_communicate().
// Complete invocation with g_subprocess_communicate_finish().
func (s subprocess) CommunicateAsync(stdinBuf *glib.Bytes, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	C.g_subprocess_communicate_async(arg0, stdinBuf, cancellable, callback, userData)
}

// CommunicateFinish: complete an invocation of
// g_subprocess_communicate_async().
func (s subprocess) CommunicateFinish(result AsyncResult) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, err error) {
	var arg0 *C.GSubprocess
	var arg1 *C.GAsyncResult

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	var arg2 *C.GBytes
	var ret2 **glib.Bytes
	var arg3 *C.GBytes
	var ret3 **glib.Bytes
	var errout *C.GError
	var goerr error

	C.g_subprocess_communicate_finish(arg0, result, &arg2, &arg3, &errout)

	*ret2 = glib.WrapBytes(unsafe.Pointer(arg2))
	runtime.SetFinalizer(*ret2, func(v **glib.Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})
	*ret3 = glib.WrapBytes(unsafe.Pointer(arg3))
	runtime.SetFinalizer(*ret3, func(v **glib.Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})
	goerr = gerror.Take(unsafe.Pointer(errout))

	return ret2, ret3, goerr
}

// CommunicateUTF8: like g_subprocess_communicate(), but validates the
// output of the process as UTF-8, and returns it as a regular NUL
// terminated string.
//
// On error, @stdout_buf and @stderr_buf will be set to undefined values and
// should not be used.
func (s subprocess) CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, err error) {
	var arg0 *C.GSubprocess
	var arg1 *C.char
	var arg2 *C.GCancellable

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var arg3 *C.char
	var ret3 string
	var arg4 *C.char
	var ret4 string
	var errout *C.GError
	var goerr error

	C.g_subprocess_communicate_utf8(arg0, stdinBuf, cancellable, &arg3, &arg4, &errout)

	*ret3 = C.GoString(arg3)
	defer C.free(unsafe.Pointer(arg3))
	*ret4 = C.GoString(arg4)
	defer C.free(unsafe.Pointer(arg4))
	goerr = gerror.Take(unsafe.Pointer(errout))

	return ret3, ret4, goerr
}

// CommunicateUTF8Async asynchronous version of
// g_subprocess_communicate_utf8(). Complete invocation with
// g_subprocess_communicate_utf8_finish().
func (s subprocess) CommunicateUTF8Async(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	C.g_subprocess_communicate_utf8_async(arg0, stdinBuf, cancellable, callback, userData)
}

// CommunicateUTF8Finish: complete an invocation of
// g_subprocess_communicate_utf8_async().
func (s subprocess) CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, err error) {
	var arg0 *C.GSubprocess
	var arg1 *C.GAsyncResult

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	var arg2 *C.char
	var ret2 string
	var arg3 *C.char
	var ret3 string
	var errout *C.GError
	var goerr error

	C.g_subprocess_communicate_utf8_finish(arg0, result, &arg2, &arg3, &errout)

	*ret2 = C.GoString(arg2)
	defer C.free(unsafe.Pointer(arg2))
	*ret3 = C.GoString(arg3)
	defer C.free(unsafe.Pointer(arg3))
	goerr = gerror.Take(unsafe.Pointer(errout))

	return ret2, ret3, goerr
}

// ForceExit: use an operating-system specific method to attempt an
// immediate, forceful termination of the process. There is no mechanism to
// determine whether or not the request itself was successful; however, you
// can use g_subprocess_wait() to monitor the status of the process after
// calling this function.
//
// On Unix, this function sends SIGKILL.
func (s subprocess) ForceExit() {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	C.g_subprocess_force_exit(arg0)
}

// ExitStatus: check the exit status of the subprocess, given that it exited
// normally. This is the value passed to the exit() system call or the
// return value from main.
//
// This is equivalent to the system WEXITSTATUS macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_exited() returned true.
func (s subprocess) ExitStatus() int {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret C.gint
	var ret1 int

	cret = C.g_subprocess_get_exit_status(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// Identifier: on UNIX, returns the process ID as a decimal string. On
// Windows, returns the result of GetProcessId() also as a string. If the
// subprocess has terminated, this will return nil.
func (s subprocess) Identifier() string {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_subprocess_get_identifier(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// IfExited: check if the given subprocess exited normally (ie: by way of
// exit() or return from main()).
//
// This is equivalent to the system WIFEXITED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (s subprocess) IfExited() bool {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_subprocess_get_if_exited(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IfSignaled: check if the given subprocess terminated in response to a
// signal.
//
// This is equivalent to the system WIFSIGNALED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (s subprocess) IfSignaled() bool {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_subprocess_get_if_signaled(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Status gets the raw status code of the process, as from waitpid().
//
// This value has no particular meaning, but it can be used with the macros
// defined by the system headers such as WIFEXITED. It can also be used with
// g_spawn_check_exit_status().
//
// It is more likely that you want to use g_subprocess_get_if_exited()
// followed by g_subprocess_get_exit_status().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (s subprocess) Status() int {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret C.gint
	var ret1 int

	cret = C.g_subprocess_get_status(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// StderrPipe gets the Stream from which to read the stderr output of
// @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE.
func (s subprocess) StderrPipe() InputStream {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret *C.GInputStream
	var ret1 InputStream

	cret = C.g_subprocess_get_stderr_pipe(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(InputStream)

	return ret1
}

// StdinPipe gets the Stream that you can write to in order to give data to
// the stdin of @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE.
func (s subprocess) StdinPipe() OutputStream {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret *C.GOutputStream
	var ret1 OutputStream

	cret = C.g_subprocess_get_stdin_pipe(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(OutputStream)

	return ret1
}

// StdoutPipe gets the Stream from which to read the stdout output of
// @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE.
func (s subprocess) StdoutPipe() InputStream {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret *C.GInputStream
	var ret1 InputStream

	cret = C.g_subprocess_get_stdout_pipe(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(InputStream)

	return ret1
}

// Successful checks if the process was "successful". A process is
// considered successful if it exited cleanly with an exit status of 0,
// either by way of the exit() system call or return from main().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (s subprocess) Successful() bool {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_subprocess_get_successful(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// TermSig: get the signal number that caused the subprocess to terminate,
// given that it terminated due to a signal.
//
// This is equivalent to the system WTERMSIG macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_signaled() returned true.
func (s subprocess) TermSig() int {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var cret C.gint
	var ret1 int

	cret = C.g_subprocess_get_term_sig(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
// still running.
//
// This API is race-free. If the subprocess has terminated, it will not be
// signalled.
//
// This API is not available on Windows.
func (s subprocess) SendSignal(signalNum int) {
	var arg0 *C.GSubprocess
	var arg1 C.gint

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(signalNum)

	C.g_subprocess_send_signal(arg0, signalNum)
}

// Wait: synchronously wait for the subprocess to terminate.
//
// After the process terminates you can query its exit status with functions
// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
//
// This function does not fail in the case of the subprocess having abnormal
// termination. See g_subprocess_wait_check() for that.
//
// Cancelling @cancellable doesn't kill the subprocess. Call
// g_subprocess_force_exit() if it is desirable.
func (s subprocess) Wait(cancellable Cancellable) error {
	var arg0 *C.GSubprocess
	var arg1 *C.GCancellable

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var goerr error

	C.g_subprocess_wait(arg0, cancellable, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// WaitAsync: wait for the subprocess to terminate.
//
// This is the asynchronous version of g_subprocess_wait().
func (s subprocess) WaitAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	C.g_subprocess_wait_async(arg0, cancellable, callback, userData)
}

// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
func (s subprocess) WaitCheck(cancellable Cancellable) error {
	var arg0 *C.GSubprocess
	var arg1 *C.GCancellable

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var goerr error

	C.g_subprocess_wait_check(arg0, cancellable, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// WaitCheckAsync combines g_subprocess_wait_async() with
// g_spawn_check_exit_status().
//
// This is the asynchronous version of g_subprocess_wait_check().
func (s subprocess) WaitCheckAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	C.g_subprocess_wait_check_async(arg0, cancellable, callback, userData)
}

// WaitCheckFinish collects the result of a previous call to
// g_subprocess_wait_check_async().
func (s subprocess) WaitCheckFinish(result AsyncResult) error {
	var arg0 *C.GSubprocess
	var arg1 *C.GAsyncResult

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	var errout *C.GError
	var goerr error

	C.g_subprocess_wait_check_finish(arg0, result, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// WaitFinish collects the result of a previous call to
// g_subprocess_wait_async().
func (s subprocess) WaitFinish(result AsyncResult) error {
	var arg0 *C.GSubprocess
	var arg1 *C.GAsyncResult

	arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	var errout *C.GError
	var goerr error

	C.g_subprocess_wait_finish(arg0, result, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher interface {
	gextras.Objector

	// env returns the value of the environment variable @variable in the
	// environment of processes launched from this launcher.
	//
	// On UNIX, the returned string can be an arbitrary byte string. On Windows,
	// it will be UTF-8.
	env(variable string) string
	// SetChildSetup sets up a child setup function.
	//
	// The child setup function will be called after fork() but before exec() on
	// the child's side.
	//
	// @destroy_notify will not be automatically called on the child's side of
	// the fork(). It will only be called when the last reference on the
	// Launcher is dropped or when a new child setup function is given.
	//
	// nil can be given as @child_setup to disable the functionality.
	//
	// Child setup functions are only available on UNIX.
	SetChildSetup(childSetup glib.SpawnChildSetupFunc)
	// SetCwd sets the current working directory that processes will be launched
	// with.
	//
	// By default processes are launched with the current working directory of
	// the launching process at the time of launch.
	SetCwd(cwd string)
	// SetEnviron: replace the entire environment of processes launched from
	// this launcher with the given 'environ' variable.
	//
	// Typically you will build this variable by using g_listenv() to copy the
	// process 'environ' and using the functions g_environ_setenv(),
	// g_environ_unsetenv(), etc.
	//
	// As an alternative, you can use g_subprocess_launcher_setenv(),
	// g_subprocess_launcher_unsetenv(), etc.
	//
	// Pass an empty array to set an empty environment. Pass nil to inherit the
	// parent process environment. As of GLib 2.54, the parent process
	// environment will be copied when g_subprocess_launcher_set_environ() is
	// called. Previously, it was copied when the subprocess was executed. This
	// means the copied environment may now be modified (using
	// g_subprocess_launcher_setenv(), etc.) before launching the subprocess.
	//
	// On UNIX, all strings in this array can be arbitrary byte strings. On
	// Windows, they should be in UTF-8.
	SetEnviron(env []string)
	// SetFlags sets the flags on the launcher.
	//
	// The default flags are G_SUBPROCESS_FLAGS_NONE.
	//
	// You may not set flags that specify conflicting options for how to handle
	// a particular stdio stream (eg: specifying both
	// G_SUBPROCESS_FLAGS_STDIN_PIPE and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
	//
	// You may also not set a flag that conflicts with a previous call to a
	// function like g_subprocess_launcher_set_stdin_file_path() or
	// g_subprocess_launcher_take_stdout_fd().
	SetFlags(flags SubprocessFlags)
	// SetStderrFilePath sets the file path to use as the stderr for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '2>' at the shell.
	//
	// If you want to send both stdout and stderr to the same file then use
	// G_SUBPROCESS_FLAGS_STDERR_MERGE.
	//
	// You may not set a stderr file path if a stderr fd is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	SetStderrFilePath(path string)
	// SetStdinFilePath sets the file path to use as the stdin for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file must exist or spawning the process will fail.
	//
	// You may not set a stdin file path if a stdin fd is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdinFilePath(path string)
	// SetStdoutFilePath sets the file path to use as the stdout for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '>' at the shell.
	//
	// You may not set a stdout file path if a stdout fd is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdoutFilePath(path string)
	// Setenv sets the environment variable @variable in the environment of
	// processes launched from this launcher.
	//
	// On UNIX, both the variable's name and value can be arbitrary byte
	// strings, except that the variable's name cannot contain '='. On Windows,
	// they should be in UTF-8.
	Setenv(variable string, value string, overwrite bool)
	// Spawnv creates a #GSubprocess given a provided array of arguments.
	Spawnv(argv []string) (subprocess Subprocess, err error)
	// TakeFd: transfer an arbitrary file descriptor from parent process to the
	// child. This function takes "ownership" of the fd; it will be closed in
	// the parent when @self is freed.
	//
	// By default, all file descriptors from the parent will be closed. This
	// function allows you to create (for example) a custom pipe() or
	// socketpair() before launching the process, and choose the target
	// descriptor in the child.
	//
	// An example use case is GNUPG, which has a command line argument
	// --passphrase-fd providing a file descriptor number where it expects the
	// passphrase to be written.
	TakeFd(sourceFd int, targetFd int)
	// TakeStderrFd sets the file descriptor to use as the stderr for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stderr through to the stderr
	// of the parent process.
	//
	// The passed @fd belongs to the Launcher. It will be automatically closed
	// when the launcher is finalized. The file descriptor will also be closed
	// on the child side when executing the spawned process.
	//
	// You may not set a stderr fd if a stderr file path is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStderrFd(fd int)
	// TakeStdinFd sets the file descriptor to use as the stdin for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that if your intention is to have the stdin of the calling process
	// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better
	// way to go about doing that.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdin fd if a stdin file path is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdinFd(fd int)
	// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stdout through to the stdout
	// of the parent process.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdout fd if a stdout file path is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdoutFd(fd int)
	// Unsetenv removes the environment variable @variable from the environment
	// of processes launched from this launcher.
	//
	// On UNIX, the variable's name can be an arbitrary byte string not
	// containing '='. On Windows, it should be in UTF-8.
	Unsetenv(variable string)
}

// subprocessLauncher implements the SubprocessLauncher interface.
type subprocessLauncher struct {
	gextras.Objector
}

var _ SubprocessLauncher = (*subprocessLauncher)(nil)

// WrapSubprocessLauncher wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocessLauncher(obj *externglib.Object) SubprocessLauncher {
	return SubprocessLauncher{
		Objector: obj,
	}
}

func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocessLauncher(obj), nil
}

// NewSubprocessLauncher constructs a class SubprocessLauncher.
func NewSubprocessLauncher(flags SubprocessFlags) SubprocessLauncher {
	var arg1 C.GSubprocessFlags

	arg1 = (C.GSubprocessFlags)(flags)

	var cret C.GSubprocessLauncher
	var ret1 SubprocessLauncher

	cret = C.g_subprocess_launcher_new(flags)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SubprocessLauncher)

	return ret1
}

// env returns the value of the environment variable @variable in the
// environment of processes launched from this launcher.
//
// On UNIX, the returned string can be an arbitrary byte string. On Windows,
// it will be UTF-8.
func (s subprocessLauncher) env(variable string) string {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar
	var ret1 string

	cret = C.g_subprocess_launcher_getenv(arg0, variable)

	ret1 = C.GoString(cret)

	return ret1
}

// SetChildSetup sets up a child setup function.
//
// The child setup function will be called after fork() but before exec() on
// the child's side.
//
// @destroy_notify will not be automatically called on the child's side of
// the fork(). It will only be called when the last reference on the
// Launcher is dropped or when a new child setup function is given.
//
// nil can be given as @child_setup to disable the functionality.
//
// Child setup functions are only available on UNIX.
func (s subprocessLauncher) SetChildSetup(childSetup glib.SpawnChildSetupFunc) {
	var arg0 *C.GSubprocessLauncher

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))

	C.g_subprocess_launcher_set_child_setup(arg0, childSetup, userData, destroyNotify)
}

// SetCwd sets the current working directory that processes will be launched
// with.
//
// By default processes are launched with the current working directory of
// the launching process at the time of launch.
func (s subprocessLauncher) SetCwd(cwd string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(cwd))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_set_cwd(arg0, cwd)
}

// SetEnviron: replace the entire environment of processes launched from
// this launcher with the given 'environ' variable.
//
// Typically you will build this variable by using g_listenv() to copy the
// process 'environ' and using the functions g_environ_setenv(),
// g_environ_unsetenv(), etc.
//
// As an alternative, you can use g_subprocess_launcher_setenv(),
// g_subprocess_launcher_unsetenv(), etc.
//
// Pass an empty array to set an empty environment. Pass nil to inherit the
// parent process environment. As of GLib 2.54, the parent process
// environment will be copied when g_subprocess_launcher_set_environ() is
// called. Previously, it was copied when the subprocess was executed. This
// means the copied environment may now be modified (using
// g_subprocess_launcher_setenv(), etc.) before launching the subprocess.
//
// On UNIX, all strings in this array can be arbitrary byte strings. On
// Windows, they should be in UTF-8.
func (s subprocessLauncher) SetEnviron(env []string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 **C.gchar

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = C.malloc(len(env) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(env)))

		for i := range env {
			out[i] = (*C.gchar)(C.CString(env[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_subprocess_launcher_set_environ(arg0, env)
}

// SetFlags sets the flags on the launcher.
//
// The default flags are G_SUBPROCESS_FLAGS_NONE.
//
// You may not set flags that specify conflicting options for how to handle
// a particular stdio stream (eg: specifying both
// G_SUBPROCESS_FLAGS_STDIN_PIPE and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
//
// You may also not set a flag that conflicts with a previous call to a
// function like g_subprocess_launcher_set_stdin_file_path() or
// g_subprocess_launcher_take_stdout_fd().
func (s subprocessLauncher) SetFlags(flags SubprocessFlags) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.GSubprocessFlags

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = (C.GSubprocessFlags)(flags)

	C.g_subprocess_launcher_set_flags(arg0, flags)
}

// SetStderrFilePath sets the file path to use as the stderr for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as
// would be the case if using '2>' at the shell.
//
// If you want to send both stdout and stderr to the same file then use
// G_SUBPROCESS_FLAGS_STDERR_MERGE.
//
// You may not set a stderr file path if a stderr fd is already set or if
// the launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) SetStderrFilePath(path string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_set_stderr_file_path(arg0, path)
}

// SetStdinFilePath sets the file path to use as the stdin for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file must exist or spawning the process will fail.
//
// You may not set a stdin file path if a stdin fd is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) SetStdinFilePath(path string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_set_stdin_file_path(arg0, path)
}

// SetStdoutFilePath sets the file path to use as the stdout for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as
// would be the case if using '>' at the shell.
//
// You may not set a stdout file path if a stdout fd is already set or if
// the launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) SetStdoutFilePath(path string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_set_stdout_file_path(arg0, path)
}

// Setenv sets the environment variable @variable in the environment of
// processes launched from this launcher.
//
// On UNIX, both the variable's name and value can be arbitrary byte
// strings, except that the variable's name cannot contain '='. On Windows,
// they should be in UTF-8.
func (s subprocessLauncher) Setenv(variable string, value string, overwrite bool) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gboolean

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))
	if overwrite {
		arg3 = C.gboolean(1)
	}

	C.g_subprocess_launcher_setenv(arg0, variable, value, overwrite)
}

// Spawnv creates a #GSubprocess given a provided array of arguments.
func (s subprocessLauncher) Spawnv(argv []string) (subprocess Subprocess, err error) {
	var arg0 *C.GSubprocessLauncher
	var arg1 **C.gchar

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = C.malloc(len(argv) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(argv)))

		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	var errout *C.GError
	var goerr error
	var cret *C.GSubprocess
	var ret2 Subprocess

	cret = C.g_subprocess_launcher_spawnv(arg0, argv, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Subprocess)

	return goerr, ret2
}

// TakeFd: transfer an arbitrary file descriptor from parent process to the
// child. This function takes "ownership" of the fd; it will be closed in
// the parent when @self is freed.
//
// By default, all file descriptors from the parent will be closed. This
// function allows you to create (for example) a custom pipe() or
// socketpair() before launching the process, and choose the target
// descriptor in the child.
//
// An example use case is GNUPG, which has a command line argument
// --passphrase-fd providing a file descriptor number where it expects the
// passphrase to be written.
func (s subprocessLauncher) TakeFd(sourceFd int, targetFd int) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(sourceFd)
	arg2 = C.gint(targetFd)

	C.g_subprocess_launcher_take_fd(arg0, sourceFd, targetFd)
}

// TakeStderrFd sets the file descriptor to use as the stderr for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stderr through to the stderr
// of the parent process.
//
// The passed @fd belongs to the Launcher. It will be automatically closed
// when the launcher is finalized. The file descriptor will also be closed
// on the child side when executing the spawned process.
//
// You may not set a stderr fd if a stderr file path is already set or if
// the launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) TakeStderrFd(fd int) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.gint

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stderr_fd(arg0, fd)
}

// TakeStdinFd sets the file descriptor to use as the stdin for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that if your intention is to have the stdin of the calling process
// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better
// way to go about doing that.
//
// The passed @fd is noted but will not be touched in the current process.
// It is therefore necessary that it be kept open by the caller until the
// subprocess is spawned. The file descriptor will also not be explicitly
// closed on the child side, so it must be marked O_CLOEXEC if that's what
// you want.
//
// You may not set a stdin fd if a stdin file path is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) TakeStdinFd(fd int) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.gint

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdin_fd(arg0, fd)
}

// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stdout through to the stdout
// of the parent process.
//
// The passed @fd is noted but will not be touched in the current process.
// It is therefore necessary that it be kept open by the caller until the
// subprocess is spawned. The file descriptor will also not be explicitly
// closed on the child side, so it must be marked O_CLOEXEC if that's what
// you want.
//
// You may not set a stdout fd if a stdout file path is already set or if
// the launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) TakeStdoutFd(fd int) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.gint

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdout_fd(arg0, fd)
}

// Unsetenv removes the environment variable @variable from the environment
// of processes launched from this launcher.
//
// On UNIX, the variable's name can be an arbitrary byte string not
// containing '='. On Windows, it should be in UTF-8.
func (s subprocessLauncher) Unsetenv(variable string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_unsetenv(arg0, variable)
}

// TestDBus: a helper class for testing code which uses D-Bus without touching
// the user's session bus.
//
// Note that DBus modifies the users environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
//
//    [D-BUS Service]
//    Name=org.gtk.GDBus.Examples.ObjectManager
//    Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//
// You will also need to indicate this service directory in your test fixtures,
// so you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as:
//
//       -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//
//    Once you have a service definition file which is local to your source tree,
//
// you can proceed to set up a GTest fixture using the DBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found here:
// gdbus-test-fixture.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your
// schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas:
//
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
type TestDBus interface {
	gextras.Objector

	// AddServiceDir: add a path where dbus-daemon will look up .service files.
	// This can't be called after g_test_dbus_up().
	AddServiceDir(path string)
	// Down: stop the session bus started by g_test_dbus_up().
	//
	// This will wait for the singleton returned by g_bus_get() or
	// g_bus_get_sync() to be destroyed. This is done to ensure that the next
	// unit test won't get a leaked singleton from this test.
	Down()
	// BusAddress: get the address on which dbus-daemon is running. If
	// g_test_dbus_up() has not been called yet, nil is returned. This can be
	// used with g_dbus_connection_new_for_address().
	BusAddress() string
	// Flags: get the flags of the DBus object.
	Flags() TestDBusFlags
	// Stop: stop the session bus started by g_test_dbus_up().
	//
	// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
	// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests
	// wanting to verify behaviour after the session bus has been stopped can
	// use this function but should still call g_test_dbus_down() when done.
	Stop()
	// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After
	// this call, it is safe for unit tests to start sending messages on the
	// session bus.
	//
	// If this function is called from setup callback of g_test_add(),
	// g_test_dbus_down() must be called in its teardown callback.
	//
	// If this function is called from unit test's main(), then
	// g_test_dbus_down() must be called after g_test_run().
	Up()
}

// testDBus implements the TestDBus interface.
type testDBus struct {
	gextras.Objector
}

var _ TestDBus = (*testDBus)(nil)

// WrapTestDBus wraps a GObject to the right type. It is
// primarily used internally.
func WrapTestDBus(obj *externglib.Object) TestDBus {
	return TestDBus{
		Objector: obj,
	}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTestDBus(obj), nil
}

// NewTestDBus constructs a class TestDBus.
func NewTestDBus(flags TestDBusFlags) TestDBus {
	var arg1 C.GTestDBusFlags

	arg1 = (C.GTestDBusFlags)(flags)

	var cret C.GTestDBus
	var ret1 TestDBus

	cret = C.g_test_dbus_new(flags)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(TestDBus)

	return ret1
}

// AddServiceDir: add a path where dbus-daemon will look up .service files.
// This can't be called after g_test_dbus_up().
func (s testDBus) AddServiceDir(path string) {
	var arg0 *C.GTestDBus
	var arg1 *C.gchar

	arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_dbus_add_service_dir(arg0, path)
}

// Down: stop the session bus started by g_test_dbus_up().
//
// This will wait for the singleton returned by g_bus_get() or
// g_bus_get_sync() to be destroyed. This is done to ensure that the next
// unit test won't get a leaked singleton from this test.
func (s testDBus) Down() {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_down(arg0)
}

// BusAddress: get the address on which dbus-daemon is running. If
// g_test_dbus_up() has not been called yet, nil is returned. This can be
// used with g_dbus_connection_new_for_address().
func (s testDBus) BusAddress() string {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_test_dbus_get_bus_address(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Flags: get the flags of the DBus object.
func (s testDBus) Flags() TestDBusFlags {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	var cret C.GTestDBusFlags
	var ret1 TestDBusFlags

	cret = C.g_test_dbus_get_flags(arg0)

	ret1 = TestDBusFlags(cret)

	return ret1
}

// Stop: stop the session bus started by g_test_dbus_up().
//
// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests
// wanting to verify behaviour after the session bus has been stopped can
// use this function but should still call g_test_dbus_down() when done.
func (s testDBus) Stop() {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_stop(arg0)
}

// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After
// this call, it is safe for unit tests to start sending messages on the
// session bus.
//
// If this function is called from setup callback of g_test_add(),
// g_test_dbus_down() must be called in its teardown callback.
//
// If this function is called from unit test's main(), then
// g_test_dbus_down() must be called after g_test_run().
func (s testDBus) Up() {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_up(arg0)
}
