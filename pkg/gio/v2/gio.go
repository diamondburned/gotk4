// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_bus_type_get_type()), F: marshalBusType},
		{T: externglib.Type(C.g_converter_result_get_type()), F: marshalConverterResult},
		{T: externglib.Type(C.g_credentials_type_get_type()), F: marshalCredentialsType},
		{T: externglib.Type(C.g_dbus_error_get_type()), F: marshalDBusError},
		{T: externglib.Type(C.g_dbus_message_byte_order_get_type()), F: marshalDBusMessageByteOrder},
		{T: externglib.Type(C.g_dbus_message_header_field_get_type()), F: marshalDBusMessageHeaderField},
		{T: externglib.Type(C.g_dbus_message_type_get_type()), F: marshalDBusMessageType},
		{T: externglib.Type(C.g_data_stream_byte_order_get_type()), F: marshalDataStreamByteOrder},
		{T: externglib.Type(C.g_data_stream_newline_type_get_type()), F: marshalDataStreamNewlineType},
		{T: externglib.Type(C.g_drive_start_stop_type_get_type()), F: marshalDriveStartStopType},
		{T: externglib.Type(C.g_emblem_origin_get_type()), F: marshalEmblemOrigin},
		{T: externglib.Type(C.g_file_attribute_status_get_type()), F: marshalFileAttributeStatus},
		{T: externglib.Type(C.g_file_attribute_type_get_type()), F: marshalFileAttributeType},
		{T: externglib.Type(C.g_file_monitor_event_get_type()), F: marshalFileMonitorEvent},
		{T: externglib.Type(C.g_file_type_get_type()), F: marshalFileType},
		{T: externglib.Type(C.g_filesystem_preview_type_get_type()), F: marshalFilesystemPreviewType},
		{T: externglib.Type(C.g_io_error_enum_get_type()), F: marshalIOErrorEnum},
		{T: externglib.Type(C.g_io_module_scope_flags_get_type()), F: marshalIOModuleScopeFlags},
		{T: externglib.Type(C.g_memory_monitor_warning_level_get_type()), F: marshalMemoryMonitorWarningLevel},
		{T: externglib.Type(C.g_mount_operation_result_get_type()), F: marshalMountOperationResult},
		{T: externglib.Type(C.g_network_connectivity_get_type()), F: marshalNetworkConnectivity},
		{T: externglib.Type(C.g_notification_priority_get_type()), F: marshalNotificationPriority},
		{T: externglib.Type(C.g_password_save_get_type()), F: marshalPasswordSave},
		{T: externglib.Type(C.g_pollable_return_get_type()), F: marshalPollableReturn},
		{T: externglib.Type(C.g_resolver_error_get_type()), F: marshalResolverError},
		{T: externglib.Type(C.g_resolver_record_type_get_type()), F: marshalResolverRecordType},
		{T: externglib.Type(C.g_resource_error_get_type()), F: marshalResourceError},
		{T: externglib.Type(C.g_socket_client_event_get_type()), F: marshalSocketClientEvent},
		{T: externglib.Type(C.g_socket_family_get_type()), F: marshalSocketFamily},
		{T: externglib.Type(C.g_socket_listener_event_get_type()), F: marshalSocketListenerEvent},
		{T: externglib.Type(C.g_socket_protocol_get_type()), F: marshalSocketProtocol},
		{T: externglib.Type(C.g_socket_type_get_type()), F: marshalSocketType},
		{T: externglib.Type(C.g_tls_authentication_mode_get_type()), F: marshalTLSAuthenticationMode},
		{T: externglib.Type(C.g_tls_certificate_request_flags_get_type()), F: marshalTLSCertificateRequestFlags},
		{T: externglib.Type(C.g_tls_channel_binding_error_get_type()), F: marshalTLSChannelBindingError},
		{T: externglib.Type(C.g_tls_channel_binding_type_get_type()), F: marshalTLSChannelBindingType},
		{T: externglib.Type(C.g_tls_database_lookup_flags_get_type()), F: marshalTLSDatabaseLookupFlags},
		{T: externglib.Type(C.g_tls_error_get_type()), F: marshalTLSError},
		{T: externglib.Type(C.g_tls_interaction_result_get_type()), F: marshalTLSInteractionResult},
		{T: externglib.Type(C.g_tls_rehandshake_mode_get_type()), F: marshalTLSRehandshakeMode},
		{T: externglib.Type(C.g_unix_socket_address_type_get_type()), F: marshalUnixSocketAddressType},
		{T: externglib.Type(C.g_zlib_compressor_format_get_type()), F: marshalZlibCompressorFormat},
		{T: externglib.Type(C.g_app_info_create_flags_get_type()), F: marshalAppInfoCreateFlags},
		{T: externglib.Type(C.g_application_flags_get_type()), F: marshalApplicationFlags},
		{T: externglib.Type(C.g_ask_password_flags_get_type()), F: marshalAskPasswordFlags},
		{T: externglib.Type(C.g_bus_name_owner_flags_get_type()), F: marshalBusNameOwnerFlags},
		{T: externglib.Type(C.g_bus_name_watcher_flags_get_type()), F: marshalBusNameWatcherFlags},
		{T: externglib.Type(C.g_converter_flags_get_type()), F: marshalConverterFlags},
		{T: externglib.Type(C.g_dbus_call_flags_get_type()), F: marshalDBusCallFlags},
		{T: externglib.Type(C.g_dbus_capability_flags_get_type()), F: marshalDBusCapabilityFlags},
		{T: externglib.Type(C.g_dbus_connection_flags_get_type()), F: marshalDBusConnectionFlags},
		{T: externglib.Type(C.g_dbus_interface_skeleton_flags_get_type()), F: marshalDBusInterfaceSkeletonFlags},
		{T: externglib.Type(C.g_dbus_message_flags_get_type()), F: marshalDBusMessageFlags},
		{T: externglib.Type(C.g_dbus_object_manager_client_flags_get_type()), F: marshalDBusObjectManagerClientFlags},
		{T: externglib.Type(C.g_dbus_property_info_flags_get_type()), F: marshalDBusPropertyInfoFlags},
		{T: externglib.Type(C.g_dbus_proxy_flags_get_type()), F: marshalDBusProXYFlags},
		{T: externglib.Type(C.g_dbus_send_message_flags_get_type()), F: marshalDBusSendMessageFlags},
		{T: externglib.Type(C.g_dbus_server_flags_get_type()), F: marshalDBusServerFlags},
		{T: externglib.Type(C.g_dbus_signal_flags_get_type()), F: marshalDBusSignalFlags},
		{T: externglib.Type(C.g_dbus_subtree_flags_get_type()), F: marshalDBusSubtreeFlags},
		{T: externglib.Type(C.g_drive_start_flags_get_type()), F: marshalDriveStartFlags},
		{T: externglib.Type(C.g_file_attribute_info_flags_get_type()), F: marshalFileAttributeInfoFlags},
		{T: externglib.Type(C.g_file_copy_flags_get_type()), F: marshalFileCopyFlags},
		{T: externglib.Type(C.g_file_create_flags_get_type()), F: marshalFileCreateFlags},
		{T: externglib.Type(C.g_file_measure_flags_get_type()), F: marshalFileMeasureFlags},
		{T: externglib.Type(C.g_file_monitor_flags_get_type()), F: marshalFileMonitorFlags},
		{T: externglib.Type(C.g_file_query_info_flags_get_type()), F: marshalFileQueryInfoFlags},
		{T: externglib.Type(C.g_io_stream_splice_flags_get_type()), F: marshalIOStreamSpliceFlags},
		{T: externglib.Type(C.g_mount_mount_flags_get_type()), F: marshalMountMountFlags},
		{T: externglib.Type(C.g_mount_unmount_flags_get_type()), F: marshalMountUnmountFlags},
		{T: externglib.Type(C.g_output_stream_splice_flags_get_type()), F: marshalOutputStreamSpliceFlags},
		{T: externglib.Type(C.g_resolver_name_lookup_flags_get_type()), F: marshalResolverNameLookupFlags},
		{T: externglib.Type(C.g_resource_flags_get_type()), F: marshalResourceFlags},
		{T: externglib.Type(C.g_resource_lookup_flags_get_type()), F: marshalResourceLookupFlags},
		{T: externglib.Type(C.g_settings_bind_flags_get_type()), F: marshalSettingsBindFlags},
		{T: externglib.Type(C.g_socket_msg_flags_get_type()), F: marshalSocketMsgFlags},
		{T: externglib.Type(C.g_subprocess_flags_get_type()), F: marshalSubprocessFlags},
		{T: externglib.Type(C.g_test_dbus_flags_get_type()), F: marshalTestDBusFlags},
		{T: externglib.Type(C.g_tls_certificate_flags_get_type()), F: marshalTLSCertificateFlags},
		{T: externglib.Type(C.g_tls_database_verify_flags_get_type()), F: marshalTLSDatabaseVerifyFlags},
		{T: externglib.Type(C.g_tls_password_flags_get_type()), F: marshalTLSPasswordFlags},
		{T: externglib.Type(C.g_action_get_type()), F: marshalAction},
		{T: externglib.Type(C.g_action_group_get_type()), F: marshalActionGroup},
		{T: externglib.Type(C.g_action_map_get_type()), F: marshalActionMap},
		{T: externglib.Type(C.g_app_info_get_type()), F: marshalAppInfo},
		{T: externglib.Type(C.g_async_initable_get_type()), F: marshalAsyncInitable},
		{T: externglib.Type(C.g_async_result_get_type()), F: marshalAsyncResult},
		{T: externglib.Type(C.g_converter_get_type()), F: marshalConverter},
		{T: externglib.Type(C.g_dbus_interface_get_type()), F: marshalDBusInterface},
		{T: externglib.Type(C.g_dbus_object_get_type()), F: marshalDBusObject},
		{T: externglib.Type(C.g_dbus_object_manager_get_type()), F: marshalDBusObjectManager},
		{T: externglib.Type(C.g_datagram_based_get_type()), F: marshalDatagramBased},
		{T: externglib.Type(C.g_desktop_app_info_lookup_get_type()), F: marshalDesktopAppInfoLookup},
		{T: externglib.Type(C.g_drive_get_type()), F: marshalDrive},
		{T: externglib.Type(C.g_dtls_client_connection_get_type()), F: marshalDTLSClientConnection},
		{T: externglib.Type(C.g_dtls_connection_get_type()), F: marshalDTLSConnection},
		{T: externglib.Type(C.g_dtls_server_connection_get_type()), F: marshalDTLSServerConnection},
		{T: externglib.Type(C.g_file_get_type()), F: marshalFile},
		{T: externglib.Type(C.g_file_descriptor_based_get_type()), F: marshalFileDescriptorBased},
		{T: externglib.Type(C.g_icon_get_type()), F: marshalIcon},
		{T: externglib.Type(C.g_initable_get_type()), F: marshalInitable},
		{T: externglib.Type(C.g_list_model_get_type()), F: marshalListModel},
		{T: externglib.Type(C.g_loadable_icon_get_type()), F: marshalLoadableIcon},
		{T: externglib.Type(C.g_memory_monitor_get_type()), F: marshalMemoryMonitor},
		{T: externglib.Type(C.g_mount_get_type()), F: marshalMount},
		{T: externglib.Type(C.g_network_monitor_get_type()), F: marshalNetworkMonitor},
		{T: externglib.Type(C.g_pollable_input_stream_get_type()), F: marshalPollableInputStream},
		{T: externglib.Type(C.g_pollable_output_stream_get_type()), F: marshalPollableOutputStream},
		{T: externglib.Type(C.g_proxy_get_type()), F: marshalProXY},
		{T: externglib.Type(C.g_proxy_resolver_get_type()), F: marshalProXYResolver},
		{T: externglib.Type(C.g_remote_action_group_get_type()), F: marshalRemoteActionGroup},
		{T: externglib.Type(C.g_seekable_get_type()), F: marshalSeekable},
		{T: externglib.Type(C.g_socket_connectable_get_type()), F: marshalSocketConnectable},
		{T: externglib.Type(C.g_tls_backend_get_type()), F: marshalTLSBackend},
		{T: externglib.Type(C.g_tls_client_connection_get_type()), F: marshalTLSClientConnection},
		{T: externglib.Type(C.g_tls_file_database_get_type()), F: marshalTLSFileDatabase},
		{T: externglib.Type(C.g_tls_server_connection_get_type()), F: marshalTLSServerConnection},
		{T: externglib.Type(C.g_volume_get_type()), F: marshalVolume},
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
		{T: externglib.Type(C.g_app_launch_context_get_type()), F: marshalAppLaunchContext},
		{T: externglib.Type(C.g_application_get_type()), F: marshalApplication},
		{T: externglib.Type(C.g_application_command_line_get_type()), F: marshalApplicationCommandLine},
		{T: externglib.Type(C.g_buffered_input_stream_get_type()), F: marshalBufferedInputStream},
		{T: externglib.Type(C.g_buffered_output_stream_get_type()), F: marshalBufferedOutputStream},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIcon},
		{T: externglib.Type(C.g_cancellable_get_type()), F: marshalCancellable},
		{T: externglib.Type(C.g_charset_converter_get_type()), F: marshalCharsetConverter},
		{T: externglib.Type(C.g_converter_input_stream_get_type()), F: marshalConverterInputStream},
		{T: externglib.Type(C.g_converter_output_stream_get_type()), F: marshalConverterOutputStream},
		{T: externglib.Type(C.g_credentials_get_type()), F: marshalCredentials},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
		{T: externglib.Type(C.g_dbus_interface_skeleton_get_type()), F: marshalDBusInterfaceSkeleton},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
		{T: externglib.Type(C.g_dbus_object_manager_client_get_type()), F: marshalDBusObjectManagerClient},
		{T: externglib.Type(C.g_dbus_object_manager_server_get_type()), F: marshalDBusObjectManagerServer},
		{T: externglib.Type(C.g_dbus_object_proxy_get_type()), F: marshalDBusObjectProXY},
		{T: externglib.Type(C.g_dbus_object_skeleton_get_type()), F: marshalDBusObjectSkeleton},
		{T: externglib.Type(C.g_dbus_proxy_get_type()), F: marshalDBusProXY},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
		{T: externglib.Type(C.g_data_input_stream_get_type()), F: marshalDataInputStream},
		{T: externglib.Type(C.g_data_output_stream_get_type()), F: marshalDataOutputStream},
		{T: externglib.Type(C.g_desktop_app_info_get_type()), F: marshalDesktopAppInfo},
		{T: externglib.Type(C.g_emblem_get_type()), F: marshalEmblem},
		{T: externglib.Type(C.g_emblemed_icon_get_type()), F: marshalEmblemedIcon},
		{T: externglib.Type(C.g_file_enumerator_get_type()), F: marshalFileEnumerator},
		{T: externglib.Type(C.g_file_io_stream_get_type()), F: marshalFileIOStream},
		{T: externglib.Type(C.g_file_icon_get_type()), F: marshalFileIcon},
		{T: externglib.Type(C.g_file_info_get_type()), F: marshalFileInfo},
		{T: externglib.Type(C.g_file_input_stream_get_type()), F: marshalFileInputStream},
		{T: externglib.Type(C.g_file_monitor_get_type()), F: marshalFileMonitor},
		{T: externglib.Type(C.g_file_output_stream_get_type()), F: marshalFileOutputStream},
		{T: externglib.Type(C.g_filename_completer_get_type()), F: marshalFilenameCompleter},
		{T: externglib.Type(C.g_filter_input_stream_get_type()), F: marshalFilterInputStream},
		{T: externglib.Type(C.g_filter_output_stream_get_type()), F: marshalFilterOutputStream},
		{T: externglib.Type(C.g_io_stream_get_type()), F: marshalIOStream},
		{T: externglib.Type(C.g_inet_address_get_type()), F: marshalInetAddress},
		{T: externglib.Type(C.g_inet_address_mask_get_type()), F: marshalInetAddressMask},
		{T: externglib.Type(C.g_inet_socket_address_get_type()), F: marshalInetSocketAddress},
		{T: externglib.Type(C.g_input_stream_get_type()), F: marshalInputStream},
		{T: externglib.Type(C.g_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.g_memory_input_stream_get_type()), F: marshalMemoryInputStream},
		{T: externglib.Type(C.g_memory_output_stream_get_type()), F: marshalMemoryOutputStream},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.g_menu_attribute_iter_get_type()), F: marshalMenuAttributeIter},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.g_menu_link_iter_get_type()), F: marshalMenuLinkIter},
		{T: externglib.Type(C.g_menu_model_get_type()), F: marshalMenuModel},
		{T: externglib.Type(C.g_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.g_native_socket_address_get_type()), F: marshalNativeSocketAddress},
		{T: externglib.Type(C.g_native_volume_monitor_get_type()), F: marshalNativeVolumeMonitor},
		{T: externglib.Type(C.g_network_address_get_type()), F: marshalNetworkAddress},
		{T: externglib.Type(C.g_network_service_get_type()), F: marshalNetworkService},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
		{T: externglib.Type(C.g_output_stream_get_type()), F: marshalOutputStream},
		{T: externglib.Type(C.g_permission_get_type()), F: marshalPermission},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
		{T: externglib.Type(C.g_proxy_address_get_type()), F: marshalProXYAddress},
		{T: externglib.Type(C.g_proxy_address_enumerator_get_type()), F: marshalProXYAddressEnumerator},
		{T: externglib.Type(C.g_resolver_get_type()), F: marshalResolver},
		{T: externglib.Type(C.g_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
		{T: externglib.Type(C.g_simple_action_group_get_type()), F: marshalSimpleActionGroup},
		{T: externglib.Type(C.g_simple_async_result_get_type()), F: marshalSimpleAsyncResult},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
		{T: externglib.Type(C.g_simple_proxy_resolver_get_type()), F: marshalSimpleProXYResolver},
		{T: externglib.Type(C.g_socket_get_type()), F: marshalSocket},
		{T: externglib.Type(C.g_socket_address_get_type()), F: marshalSocketAddress},
		{T: externglib.Type(C.g_socket_address_enumerator_get_type()), F: marshalSocketAddressEnumerator},
		{T: externglib.Type(C.g_socket_client_get_type()), F: marshalSocketClient},
		{T: externglib.Type(C.g_socket_connection_get_type()), F: marshalSocketConnection},
		{T: externglib.Type(C.g_socket_control_message_get_type()), F: marshalSocketControlMessage},
		{T: externglib.Type(C.g_socket_listener_get_type()), F: marshalSocketListener},
		{T: externglib.Type(C.g_socket_service_get_type()), F: marshalSocketService},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
		{T: externglib.Type(C.g_task_get_type()), F: marshalTask},
		{T: externglib.Type(C.g_tcp_connection_get_type()), F: marshalTCPConnection},
		{T: externglib.Type(C.g_tcp_wrapper_connection_get_type()), F: marshalTCPWrapperConnection},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
		{T: externglib.Type(C.g_themed_icon_get_type()), F: marshalThemedIcon},
		{T: externglib.Type(C.g_threaded_socket_service_get_type()), F: marshalThreadedSocketService},
		{T: externglib.Type(C.g_tls_certificate_get_type()), F: marshalTLSCertificate},
		{T: externglib.Type(C.g_tls_connection_get_type()), F: marshalTLSConnection},
		{T: externglib.Type(C.g_tls_database_get_type()), F: marshalTLSDatabase},
		{T: externglib.Type(C.g_tls_interaction_get_type()), F: marshalTLSInteraction},
		{T: externglib.Type(C.g_tls_password_get_type()), F: marshalTLSPassword},
		{T: externglib.Type(C.g_unix_connection_get_type()), F: marshalUnixConnection},
		{T: externglib.Type(C.g_unix_credentials_message_get_type()), F: marshalUnixCredentialsMessage},
		{T: externglib.Type(C.g_unix_fd_list_get_type()), F: marshalUnixFDList},
		{T: externglib.Type(C.g_unix_fd_message_get_type()), F: marshalUnixFDMessage},
		{T: externglib.Type(C.g_unix_input_stream_get_type()), F: marshalUnixInputStream},
		{T: externglib.Type(C.g_unix_mount_monitor_get_type()), F: marshalUnixMountMonitor},
		{T: externglib.Type(C.g_unix_output_stream_get_type()), F: marshalUnixOutputStream},
		{T: externglib.Type(C.g_unix_socket_address_get_type()), F: marshalUnixSocketAddress},
		{T: externglib.Type(C.g_vfs_get_type()), F: marshalVFS},
		{T: externglib.Type(C.g_volume_monitor_get_type()), F: marshalVolumeMonitor},
		{T: externglib.Type(C.g_zlib_compressor_get_type()), F: marshalZlibCompressor},
		{T: externglib.Type(C.g_zlib_decompressor_get_type()), F: marshalZlibDecompressor},
		{T: externglib.Type(C.g_dbus_annotation_info_get_type()), F: marshalDBusAnnotationInfo},
		{T: externglib.Type(C.g_dbus_arg_info_get_type()), F: marshalDBusArgInfo},
		{T: externglib.Type(C.g_dbus_interface_info_get_type()), F: marshalDBusInterfaceInfo},
		{T: externglib.Type(C.g_dbus_method_info_get_type()), F: marshalDBusMethodInfo},
		{T: externglib.Type(C.g_dbus_node_info_get_type()), F: marshalDBusNodeInfo},
		{T: externglib.Type(C.g_dbus_property_info_get_type()), F: marshalDBusPropertyInfo},
		{T: externglib.Type(C.g_dbus_signal_info_get_type()), F: marshalDBusSignalInfo},
		{T: externglib.Type(C.g_file_attribute_info_list_get_type()), F: marshalFileAttributeInfoList},
		{T: externglib.Type(C.g_file_attribute_matcher_get_type()), F: marshalFileAttributeMatcher},
		{T: externglib.Type(C.g_resource_get_type()), F: marshalResource},
		{T: externglib.Type(C.g_settings_schema_get_type()), F: marshalSettingsSchema},
		{T: externglib.Type(C.g_settings_schema_key_get_type()), F: marshalSettingsSchemaKey},
		{T: externglib.Type(C.g_settings_schema_source_get_type()), F: marshalSettingsSchemaSource},
		{T: externglib.Type(C.g_srv_target_get_type()), F: marshalSrvTarget},
		{T: externglib.Type(C.g_unix_mount_entry_get_type()), F: marshalUnixMountEntry},
		{T: externglib.Type(C.g_unix_mount_point_get_type()), F: marshalUnixMountPoint},
	})
}

// BusType: an enumeration for well-known message buses.
type BusType int

const (
	// BusTypeStarter: an alias for the message bus that activated the process,
	// if any.
	BusTypeStarter BusType = -1
	// BusTypeNone: not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem: the system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession: the login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p uintptr) (interface{}, error) {
	return BusType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterResult results returned from g_converter_convert().
type ConverterResult int

const (
	// ConverterResultError: there was an error during conversion.
	ConverterResultError ConverterResult = 0
	// ConverterResultConverted: some data was consumed or produced
	ConverterResultConverted ConverterResult = 1
	// ConverterResultFinished: the conversion is finished
	ConverterResultFinished ConverterResult = 2
	// ConverterResultFlushed: flushing is finished
	ConverterResultFlushed ConverterResult = 3
)

func marshalConverterResult(p uintptr) (interface{}, error) {
	return ConverterResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CredentialsType: enumeration describing different kinds of native credential
// types.
type CredentialsType int

const (
	// CredentialsTypeInvalid indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = 0
	// CredentialsTypeLinuxUcred: the native credentials type is a `struct
	// ucred`.
	CredentialsTypeLinuxUcred CredentialsType = 1
	// CredentialsTypeFreebsdCmsgcred: the native credentials type is a `struct
	// cmsgcred`.
	CredentialsTypeFreebsdCmsgcred CredentialsType = 2
	// CredentialsTypeOpenbsdSockpeercred: the native credentials type is a
	// `struct sockpeercred`. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred CredentialsType = 3
	// CredentialsTypeSolarisUcred: the native credentials type is a `ucred_t`.
	// Added in 2.40.
	CredentialsTypeSolarisUcred CredentialsType = 4
	// CredentialsTypeNetbsdUnpcbid: the native credentials type is a `struct
	// unpcbid`. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid CredentialsType = 5
	// CredentialsTypeAppleXucred: the native credentials type is a `struct
	// xucred`. Added in 2.66.
	CredentialsTypeAppleXucred CredentialsType = 6
)

func marshalCredentialsType(p uintptr) (interface{}, error) {
	return CredentialsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusError: error codes for the G_DBUS_ERROR error domain.
type DBusError int

const (
	// DBusErrorFailed: a generic error; "something went wrong" - see the error
	// message for more.
	DBusErrorFailed DBusError = 0
	// DBusErrorNoMemory: there was not enough memory to complete an operation.
	DBusErrorNoMemory DBusError = 1
	// DBusErrorServiceUnknown: the bus doesn't know how to launch a service to
	// supply the bus name you wanted.
	DBusErrorServiceUnknown DBusError = 2
	// DBusErrorNameHasNoOwner: the bus name you referenced doesn't exist (i.e.
	// no application owns it).
	DBusErrorNameHasNoOwner DBusError = 3
	// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
	DBusErrorNoReply DBusError = 4
	// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
	DBusErrorIOError DBusError = 5
	// DBusErrorBadAddress: a D-Bus bus address was malformed.
	DBusErrorBadAddress DBusError = 6
	// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
	DBusErrorNotSupported DBusError = 7
	// DBusErrorLimitsExceeded: some limited resource is exhausted.
	DBusErrorLimitsExceeded DBusError = 8
	// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
	DBusErrorAccessDenied DBusError = 9
	// DBusErrorAuthFailed: authentication didn't work.
	DBusErrorAuthFailed DBusError = 10
	// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
	DBusErrorNoServer DBusError = 11
	// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimeout DBusError = 12
	// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
	DBusErrorNoNetwork DBusError = 13
	// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
	DBusErrorAddressInUse DBusError = 14
	// DBusErrorDisconnected: the connection is disconnected and you're trying
	// to use it.
	DBusErrorDisconnected DBusError = 15
	// DBusErrorInvalidArgs: invalid arguments passed to a method call.
	DBusErrorInvalidArgs DBusError = 16
	// DBusErrorFileNotFound: missing file.
	DBusErrorFileNotFound DBusError = 17
	// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
	DBusErrorFileExists DBusError = 18
	// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
	DBusErrorUnknownMethod DBusError = 19
	// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimedOut DBusError = 20
	// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
	DBusErrorMatchRuleNotFound DBusError = 21
	// DBusErrorMatchRuleInvalid: the match rule isn't syntactically valid.
	DBusErrorMatchRuleInvalid DBusError = 22
	// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
	DBusErrorSpawnExecFailed DBusError = 23
	// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
	DBusErrorSpawnForkFailed DBusError = 24
	// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
	DBusErrorSpawnChildExited DBusError = 25
	// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
	DBusErrorSpawnChildSignaled DBusError = 26
	// DBusErrorSpawnFailed: while starting a new process, something went wrong.
	DBusErrorSpawnFailed DBusError = 27
	// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
	DBusErrorSpawnSetupFailed DBusError = 28
	// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
	DBusErrorSpawnConfigInvalid DBusError = 29
	// DBusErrorSpawnServiceInvalid bus name was not valid.
	DBusErrorSpawnServiceInvalid DBusError = 30
	// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
	DBusErrorSpawnServiceNotFound DBusError = 31
	// DBusErrorSpawnPermissionsInvalid permissions are incorrect on the setuid
	// helper.
	DBusErrorSpawnPermissionsInvalid DBusError = 32
	// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
	DBusErrorSpawnFileInvalid DBusError = 33
	// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
	DBusErrorSpawnNoMemory DBusError = 34
	// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
	DBusErrorUnixProcessIDUnknown DBusError = 35
	// DBusErrorInvalidSignature: a type signature is not valid.
	DBusErrorInvalidSignature DBusError = 36
	// DBusErrorInvalidFileContent: a file contains invalid syntax or is
	// otherwise broken.
	DBusErrorInvalidFileContent DBusError = 37
	// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
	DBusErrorSelinuxSecurityContextUnknown DBusError = 38
	// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
	DBusErrorAdtAuditDataUnknown DBusError = 39
	// DBusErrorObjectPathInUse there's already an object with the requested
	// object path.
	DBusErrorObjectPathInUse DBusError = 40
	// DBusErrorUnknownObject: object you invoked a method on isn't known. Since
	// 2.42
	DBusErrorUnknownObject DBusError = 41
	// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42
	DBusErrorUnknownInterface DBusError = 42
	// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42
	DBusErrorUnknownProperty DBusError = 43
	// DBusErrorPropertyReadOnly: property you tried to set is read-only. Since
	// 2.42
	DBusErrorPropertyReadOnly DBusError = 44
)

func marshalDBusError(p uintptr) (interface{}, error) {
	return DBusError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
type DBusMessageByteOrder int

const (
	// DBusMessageByteOrderBigEndian: the byte order is big endian.
	DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
	// DBusMessageByteOrderLittleEndian: the byte order is little endian.
	DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
)

func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
	return DBusMessageByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageHeaderField: header fields used in BusMessage.
type DBusMessageHeaderField int

const (
	// DBusMessageHeaderFieldInvalid: not a valid header field.
	DBusMessageHeaderFieldInvalid DBusMessageHeaderField = 0
	// DBusMessageHeaderFieldPath: the object path.
	DBusMessageHeaderFieldPath DBusMessageHeaderField = 1
	// DBusMessageHeaderFieldInterface: the interface name.
	DBusMessageHeaderFieldInterface DBusMessageHeaderField = 2
	// DBusMessageHeaderFieldMember: the method or signal name.
	DBusMessageHeaderFieldMember DBusMessageHeaderField = 3
	// DBusMessageHeaderFieldErrorName: the name of the error that occurred.
	DBusMessageHeaderFieldErrorName DBusMessageHeaderField = 4
	// DBusMessageHeaderFieldReplySerial: the serial number the message is a
	// reply to.
	DBusMessageHeaderFieldReplySerial DBusMessageHeaderField = 5
	// DBusMessageHeaderFieldDestination: the name the message is intended for.
	DBusMessageHeaderFieldDestination DBusMessageHeaderField = 6
	// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
	DBusMessageHeaderFieldSender DBusMessageHeaderField = 7
	// DBusMessageHeaderFieldSignature: the signature of the message body.
	DBusMessageHeaderFieldSignature DBusMessageHeaderField = 8
	// DBusMessageHeaderFieldNumUnixFds: the number of UNIX file descriptors
	// that accompany the message.
	DBusMessageHeaderFieldNumUnixFds DBusMessageHeaderField = 9
)

func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
	return DBusMessageHeaderField(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageType: message types used in BusMessage.
type DBusMessageType int

const (
	// DBusMessageTypeInvalid: message is of invalid type.
	DBusMessageTypeInvalid DBusMessageType = 0
	// DBusMessageTypeMethodCall: method call.
	DBusMessageTypeMethodCall DBusMessageType = 1
	// DBusMessageTypeMethodReturn: method reply.
	DBusMessageTypeMethodReturn DBusMessageType = 2
	// DBusMessageTypeError: error reply.
	DBusMessageTypeError DBusMessageType = 3
	// DBusMessageTypeSignal: signal emission.
	DBusMessageTypeSignal DBusMessageType = 4
)

func marshalDBusMessageType(p uintptr) (interface{}, error) {
	return DBusMessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamByteOrder is used to ensure proper endianness of streaming data
// sources across various machine architectures.
type DataStreamByteOrder int

const (
	// DataStreamByteOrderBigEndian selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = 0
	// DataStreamByteOrderLittleEndian selects Little Endian byte order.
	DataStreamByteOrderLittleEndian DataStreamByteOrder = 1
	// DataStreamByteOrderHostEndian selects endianness based on host machine's
	// architecture.
	DataStreamByteOrderHostEndian DataStreamByteOrder = 2
)

func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
	return DataStreamByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamNewlineType is used when checking for or setting the line endings
// for a given file.
type DataStreamNewlineType int

const (
	// DataStreamNewlineTypeLf selects "LF" line endings, common on most modern
	// UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = 0
	// DataStreamNewlineTypeCr selects "CR" line endings.
	DataStreamNewlineTypeCr DataStreamNewlineType = 1
	// DataStreamNewlineTypeCrLf selects "CR, LF" line ending, common on
	// Microsoft Windows.
	DataStreamNewlineTypeCrLf DataStreamNewlineType = 2
	// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
	DataStreamNewlineTypeAny DataStreamNewlineType = 3
)

func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
	return DataStreamNewlineType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
type DriveStartStopType int

const (
	// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = 0
	// DriveStartStopTypeShutdown: the stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
	DriveStartStopTypeShutdown DriveStartStopType = 1
	// DriveStartStopTypeNetwork: the start/stop methods are used for
	// connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork DriveStartStopType = 2
	// DriveStartStopTypeMultidisk: the start/stop methods will
	// assemble/disassemble a virtual drive from several physical drives.
	DriveStartStopTypeMultidisk DriveStartStopType = 3
	// DriveStartStopTypePassword: the start/stop methods will unlock/lock the
	// disk (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command)
	DriveStartStopTypePassword DriveStartStopType = 4
)

func marshalDriveStartStopType(p uintptr) (interface{}, error) {
	return DriveStartStopType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EmblemOrigin: GEmblemOrigin is used to add information about the origin of
// the emblem to #GEmblem.
type EmblemOrigin int

const (
	// EmblemOriginUnknown: emblem of unknown origin
	EmblemOriginUnknown EmblemOrigin = 0
	// EmblemOriginDevice: emblem adds device-specific information
	EmblemOriginDevice EmblemOrigin = 1
	// EmblemOriginLivemetadata: emblem depicts live metadata, such as
	// "readonly"
	EmblemOriginLivemetadata EmblemOrigin = 2
	// EmblemOriginTag: emblem comes from a user-defined tag, e.g. set by
	// nautilus (in the future)
	EmblemOriginTag EmblemOrigin = 3
)

func marshalEmblemOrigin(p uintptr) (interface{}, error) {
	return EmblemOrigin(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
type FileAttributeStatus int

const (
	// FileAttributeStatusUnset: attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = 0
	// FileAttributeStatusSet: attribute value is set.
	FileAttributeStatusSet FileAttributeStatus = 1
	// FileAttributeStatusErrorSetting indicates an error in setting the value.
	FileAttributeStatusErrorSetting FileAttributeStatus = 2
)

func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
	return FileAttributeStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeType: the data types for file attributes.
type FileAttributeType int

const (
	// FileAttributeTypeInvalid indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = 0
	// FileAttributeTypeString: a null terminated UTF8 string.
	FileAttributeTypeString FileAttributeType = 1
	// FileAttributeTypeByteString: a zero terminated string of non-zero bytes.
	FileAttributeTypeByteString FileAttributeType = 2
	// FileAttributeTypeBoolean: a boolean value.
	FileAttributeTypeBoolean FileAttributeType = 3
	// FileAttributeTypeUint32: an unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32 FileAttributeType = 4
	// FileAttributeTypeInt32: a signed 4-byte/32-bit integer.
	FileAttributeTypeInt32 FileAttributeType = 5
	// FileAttributeTypeUint64: an unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64 FileAttributeType = 6
	// FileAttributeTypeInt64: a signed 8-byte/64-bit integer.
	FileAttributeTypeInt64 FileAttributeType = 7
	// FileAttributeTypeObject: a #GObject.
	FileAttributeTypeObject FileAttributeType = 8
	// FileAttributeTypeStringv: a nil terminated char **. Since 2.22
	FileAttributeTypeStringv FileAttributeType = 9
)

func marshalFileAttributeType(p uintptr) (interface{}, error) {
	return FileAttributeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorEvent specifies what type of event a monitor event is.
type FileMonitorEvent int

const (
	// FileMonitorEventChanged: a file changed.
	FileMonitorEventChanged FileMonitorEvent = 0
	// FileMonitorEventChangesDoneHint: a hint that this was probably the last
	// change in a set of changes.
	FileMonitorEventChangesDoneHint FileMonitorEvent = 1
	// FileMonitorEventDeleted: a file was deleted.
	FileMonitorEventDeleted FileMonitorEvent = 2
	// FileMonitorEventCreated: a file was created.
	FileMonitorEventCreated FileMonitorEvent = 3
	// FileMonitorEventAttributeChanged: a file attribute was changed.
	FileMonitorEventAttributeChanged FileMonitorEvent = 4
	// FileMonitorEventPreUnmount: the file location will soon be unmounted.
	FileMonitorEventPreUnmount FileMonitorEvent = 5
	// FileMonitorEventUnmounted: the file location was unmounted.
	FileMonitorEventUnmounted FileMonitorEvent = 6
	// FileMonitorEventMoved: the file was moved -- only sent if the
	// (deprecated) G_FILE_MONITOR_SEND_MOVED flag is set
	FileMonitorEventMoved FileMonitorEvent = 7
	// FileMonitorEventRenamed: the file was renamed within the current
	// directory -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set.
	// Since: 2.46.
	FileMonitorEventRenamed FileMonitorEvent = 8
	// FileMonitorEventMovedIn: the file was moved into the monitored directory
	// from another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
	FileMonitorEventMovedIn FileMonitorEvent = 9
	// FileMonitorEventMovedOut: the file was moved out of the monitored
	// directory to another location -- only sent if the
	// G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46
	FileMonitorEventMovedOut FileMonitorEvent = 10
)

func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
	return FileMonitorEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileType indicates the file's on-disk type.
//
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type; use
// Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a file is
// a symlink or not. This is due to the fact that NTFS does not have a single
// filesystem object type for symbolic links - it has files that symlink to
// files, and directories that symlink to directories. Type enumeration cannot
// precisely represent this important distinction, which is why all Windows
// symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
type FileType int

const (
	// FileTypeUnknown file's type is unknown.
	FileTypeUnknown FileType = 0
	// FileTypeRegular: file handle represents a regular file.
	FileTypeRegular FileType = 1
	// FileTypeDirectory: file handle represents a directory.
	FileTypeDirectory FileType = 2
	// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
	FileTypeSymbolicLink FileType = 3
	// FileTypeSpecial: file is a "special" file, such as a socket, fifo, block
	// device, or character device.
	FileTypeSpecial FileType = 4
	// FileTypeShortcut: file is a shortcut (Windows systems).
	FileTypeShortcut FileType = 5
	// FileTypeMountable: file is a mountable location.
	FileTypeMountable FileType = 6
)

func marshalFileType(p uintptr) (interface{}, error) {
	return FileType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilesystemPreviewType indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType int

const (
	// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = 0
	// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
	FilesystemPreviewTypeIfLocal FilesystemPreviewType = 1
	// FilesystemPreviewTypeNever: never preview files.
	FilesystemPreviewTypeNever FilesystemPreviewType = 2
)

func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
	return FilesystemPreviewType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOErrorEnum: error codes returned by GIO functions.
//
// Note that this domain may be extended in future GLib releases. In general,
// new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before. You
// should therefore avoid writing code like
//
//    if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
//      {
//        // Assume that this is EPRINTERONFIRE
//        ...
//      }
//
// but should instead treat all unrecognized error codes the same as
// IO_ERROR_FAILED.
//
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
type IOErrorEnum int

const (
	// IOErrorEnumFailed: generic error condition for when an operation fails
	// and no more specific OErrorEnum value is defined.
	IOErrorEnumFailed IOErrorEnum = 0
	// IOErrorEnumNotFound: file not found.
	IOErrorEnumNotFound IOErrorEnum = 1
	// IOErrorEnumExists: file already exists.
	IOErrorEnumExists IOErrorEnum = 2
	// IOErrorEnumIsDirectory: file is a directory.
	IOErrorEnumIsDirectory IOErrorEnum = 3
	// IOErrorEnumNotDirectory: file is not a directory.
	IOErrorEnumNotDirectory IOErrorEnum = 4
	// IOErrorEnumNotEmpty: file is a directory that isn't empty.
	IOErrorEnumNotEmpty IOErrorEnum = 5
	// IOErrorEnumNotRegularFile: file is not a regular file.
	IOErrorEnumNotRegularFile IOErrorEnum = 6
	// IOErrorEnumNotSymbolicLink: file is not a symbolic link.
	IOErrorEnumNotSymbolicLink IOErrorEnum = 7
	// IOErrorEnumNotMountableFile: file cannot be mounted.
	IOErrorEnumNotMountableFile IOErrorEnum = 8
	// IOErrorEnumFilenameTooLong: filename is too many characters.
	IOErrorEnumFilenameTooLong IOErrorEnum = 9
	// IOErrorEnumInvalidFilename: filename is invalid or contains invalid
	// characters.
	IOErrorEnumInvalidFilename IOErrorEnum = 10
	// IOErrorEnumTooManyLinks: file contains too many symbolic links.
	IOErrorEnumTooManyLinks IOErrorEnum = 11
	// IOErrorEnumNoSpace: no space left on drive.
	IOErrorEnumNoSpace IOErrorEnum = 12
	// IOErrorEnumInvalidArgument: invalid argument.
	IOErrorEnumInvalidArgument IOErrorEnum = 13
	// IOErrorEnumPermissionDenied: permission denied.
	IOErrorEnumPermissionDenied IOErrorEnum = 14
	// IOErrorEnumNotSupported: operation (or one of its parameters) not
	// supported
	IOErrorEnumNotSupported IOErrorEnum = 15
	// IOErrorEnumNotMounted: file isn't mounted.
	IOErrorEnumNotMounted IOErrorEnum = 16
	// IOErrorEnumAlreadyMounted: file is already mounted.
	IOErrorEnumAlreadyMounted IOErrorEnum = 17
	// IOErrorEnumClosed: file was closed.
	IOErrorEnumClosed IOErrorEnum = 18
	// IOErrorEnumCancelled: operation was cancelled. See #GCancellable.
	IOErrorEnumCancelled IOErrorEnum = 19
	// IOErrorEnumPending operations are still pending.
	IOErrorEnumPending IOErrorEnum = 20
	// IOErrorEnumReadOnly: file is read only.
	IOErrorEnumReadOnly IOErrorEnum = 21
	// IOErrorEnumCantCreateBackup: backup couldn't be created.
	IOErrorEnumCantCreateBackup IOErrorEnum = 22
	// IOErrorEnumWrongEtag file's Entity Tag was incorrect.
	IOErrorEnumWrongEtag IOErrorEnum = 23
	// IOErrorEnumTimedOut: operation timed out.
	IOErrorEnumTimedOut IOErrorEnum = 24
	// IOErrorEnumWouldRecurse: operation would be recursive.
	IOErrorEnumWouldRecurse IOErrorEnum = 25
	// IOErrorEnumBusy: file is busy.
	IOErrorEnumBusy IOErrorEnum = 26
	// IOErrorEnumWouldBlock: operation would block.
	IOErrorEnumWouldBlock IOErrorEnum = 27
	// IOErrorEnumHostNotFound: host couldn't be found (remote operations).
	IOErrorEnumHostNotFound IOErrorEnum = 28
	// IOErrorEnumWouldMerge: operation would merge files.
	IOErrorEnumWouldMerge IOErrorEnum = 29
	// IOErrorEnumFailedHandled: operation failed and a helper program has
	// already interacted with the user. Do not display any error dialog.
	IOErrorEnumFailedHandled IOErrorEnum = 30
	// IOErrorEnumTooManyOpenFiles: the current process has too many files open
	// and can't open any more. Duplicate descriptors do count toward this
	// limit. Since 2.20
	IOErrorEnumTooManyOpenFiles IOErrorEnum = 31
	// IOErrorEnumNotInitialized: the object has not been initialized. Since
	// 2.22
	IOErrorEnumNotInitialized IOErrorEnum = 32
	// IOErrorEnumAddressInUse: the requested address is already in use. Since
	// 2.22
	IOErrorEnumAddressInUse IOErrorEnum = 33
	// IOErrorEnumPartialInput: need more input to finish operation. Since 2.24
	IOErrorEnumPartialInput IOErrorEnum = 34
	// IOErrorEnumInvalidData: the input data was invalid. Since 2.24
	IOErrorEnumInvalidData IOErrorEnum = 35
	// IOErrorEnumDBusError: a remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
	IOErrorEnumDBusError IOErrorEnum = 36
	// IOErrorEnumHostUnreachable: host unreachable. Since 2.26
	IOErrorEnumHostUnreachable IOErrorEnum = 37
	// IOErrorEnumNetworkUnreachable: network unreachable. Since 2.26
	IOErrorEnumNetworkUnreachable IOErrorEnum = 38
	// IOErrorEnumConnectionRefused: connection refused. Since 2.26
	IOErrorEnumConnectionRefused IOErrorEnum = 39
	// IOErrorEnumProXYFailed: connection to proxy server failed. Since 2.26
	IOErrorEnumProXYFailed IOErrorEnum = 40
	// IOErrorEnumProXYAuthFailed: proxy authentication failed. Since 2.26
	IOErrorEnumProXYAuthFailed IOErrorEnum = 41
	// IOErrorEnumProXYNeedAuth: proxy server needs authentication. Since 2.26
	IOErrorEnumProXYNeedAuth IOErrorEnum = 42
	// IOErrorEnumProXYNotAllowed: proxy connection is not allowed by ruleset.
	// Since 2.26
	IOErrorEnumProXYNotAllowed IOErrorEnum = 43
	// IOErrorEnumBrokenPipe: broken pipe. Since 2.36
	IOErrorEnumBrokenPipe IOErrorEnum = 44
	// IOErrorEnumConnectionClosed: connection closed by peer. Note that this is
	// the same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection
	// closed" errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
	IOErrorEnumConnectionClosed IOErrorEnum = 44
	// IOErrorEnumNotConnected: transport endpoint is not connected. Since 2.44
	IOErrorEnumNotConnected IOErrorEnum = 45
	// IOErrorEnumMessageTooLarge: message too large. Since 2.48.
	IOErrorEnumMessageTooLarge IOErrorEnum = 46
)

func marshalIOErrorEnum(p uintptr) (interface{}, error) {
	return IOErrorEnum(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOModuleScopeFlags flags for use with g_io_module_scope_new().
type IOModuleScopeFlags int

const (
	// IOModuleScopeFlagsNone: no module scan flags
	IOModuleScopeFlagsNone IOModuleScopeFlags = 0
	// IOModuleScopeFlagsBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
	IOModuleScopeFlagsBlockDuplicates IOModuleScopeFlags = 1
)

func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
	return IOModuleScopeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MemoryMonitorWarningLevel: memory availability warning levels.
//
// Note that because new values might be added, it is recommended that
// applications check MonitorWarningLevel as ranges, for example:
//
//    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//      drop_caches ();
type MemoryMonitorWarningLevel int

const (
	// MemoryMonitorWarningLevelLow: memory on the device is low, processes
	// should free up unneeded resources (for example, in-memory caches) so they
	// can be used elsewhere.
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium: same as
	// @G_MEMORY_MONITOR_WARNING_LEVEL_LOW but the device has even less free
	// memory, so processes should try harder to free up unneeded resources. If
	// your process does not need to stay running, it is a good time for it to
	// quit.
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical: the system will soon start terminating
	// processes to reclaim memory, including background processes.
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p uintptr) (interface{}, error) {
	return MemoryMonitorWarningLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountOperationResult is returned as a result when a request for information
// is send by the mounting operation.
type MountOperationResult int

const (
	// MountOperationResultHandled: the request was fulfilled and the user
	// specified data is now available
	MountOperationResultHandled MountOperationResult = 0
	// MountOperationResultAborted: the user requested the mount operation to be
	// aborted
	MountOperationResultAborted MountOperationResult = 1
	// MountOperationResultUnhandled: the request was unhandled (i.e. not
	// implemented)
	MountOperationResultUnhandled MountOperationResult = 2
)

func marshalMountOperationResult(p uintptr) (interface{}, error) {
	return MountOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NetworkConnectivity: the host's network connectivity state, as reported by
// Monitor.
type NetworkConnectivity int

const (
	// NetworkConnectivityLocal: the host is not configured with a route to the
	// Internet; it may or may not be connected to a local network.
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited: the host is connected to a network, but does
	// not appear to be able to reach the full Internet, perhaps due to upstream
	// network problems.
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal: the host is behind a captive portal and cannot
	// reach the full Internet.
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull: the host is connected to a network, and appears
	// to be able to reach the full Internet.
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p uintptr) (interface{}, error) {
	return NetworkConnectivity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotificationPriority: priority levels for #GNotifications.
type NotificationPriority int

const (
	// NotificationPriorityNormal: the default priority, to be used for the
	// majority of notifications (for example email messages, software updates,
	// completed download/sync operations)
	NotificationPriorityNormal NotificationPriority = 0
	// NotificationPriorityLow: for notifications that do not require immediate
	// attention - typically used for contextual background information, such as
	// contact birthdays or local weather
	NotificationPriorityLow NotificationPriority = 1
	// NotificationPriorityHigh: for events that require more attention, usually
	// because responses are time-sensitive (for example chat and SMS messages
	// or alarms)
	NotificationPriorityHigh NotificationPriority = 2
	// NotificationPriorityUrgent: for urgent notifications, or notifications
	// that require a response in a short space of time (for example phone calls
	// or emergency warnings)
	NotificationPriorityUrgent NotificationPriority = 3
)

func marshalNotificationPriority(p uintptr) (interface{}, error) {
	return NotificationPriority(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PasswordSave is used to indicate the lifespan of a saved password.
//
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to, and
// later retrieves it again from there.
type PasswordSave int

const (
	// PasswordSaveNever: never save a password.
	PasswordSaveNever PasswordSave = 0
	// PasswordSaveForSession: save a password for the session.
	PasswordSaveForSession PasswordSave = 1
	// PasswordSavePermanently: save a password permanently.
	PasswordSavePermanently PasswordSave = 2
)

func marshalPasswordSave(p uintptr) (interface{}, error) {
	return PasswordSave(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PollableReturn: return value for various IO operations that signal errors via
// the return value and not necessarily via a #GError.
//
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for regularly
// happening errors like G_IO_ERROR_WOULD_BLOCK.
//
// In case of G_POLLABLE_RETURN_FAILED a #GError should be set for the operation
// to give details about the error that happened.
type PollableReturn int

const (
	// PollableReturnFailed: generic error condition for when an operation
	// fails.
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOk: the operation was successfully finished.
	PollableReturnOk PollableReturn = 1
	// PollableReturnWouldBlock: the operation would block.
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p uintptr) (interface{}, error) {
	return PollableReturn(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverError: an error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError int

const (
	// ResolverErrorNotFound: the requested name/address/service was not found
	ResolverErrorNotFound ResolverError = 0
	// ResolverErrorTemporaryFailure: the requested information could not be
	// looked up due to a network error or similar problem
	ResolverErrorTemporaryFailure ResolverError = 1
	// ResolverErrorInternal: unknown error
	ResolverErrorInternal ResolverError = 2
)

func marshalResolverError(p uintptr) (interface{}, error) {
	return ResolverError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverRecordType: the type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
//
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
// weight, a `guint16` with the port, and a string of the hostname.
//
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// `(qs)`, representing a `guint16` with the preference, and a string containing
// the mail exchanger hostname.
//
// G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// `(as)`, representing an array of the strings in the text record. Note: Most
// TXT records only contain a single string, but RFC 1035
// (https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record to
// contain multiple strings. The RFC which defines the interpretation of a
// specific TXT record will likely require concatenation of multiple strings if
// they are present, as with RFC 7208
// (https://tools.ietf.org/html/rfc7208#section-3.3).
//
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// `(ssuuuuu)`, representing a string containing the primary name server, a
// string containing the administrator, the serial as a `guint32`, the refresh
// interval as a `guint32`, the retry interval as a `guint32`, the expire
// timeout as a `guint32`, and the TTL as a `guint32`.
//
// G_RESOLVER_RECORD_NS records are returned as variants with the signature
// `(s)`, representing a string of the hostname of the name server.
type ResolverRecordType int

const (
	// ResolverRecordTypeSrv: look up DNS SRV records for a domain
	ResolverRecordTypeSrv ResolverRecordType = 1
	// ResolverRecordTypeMx: look up DNS MX records for a domain
	ResolverRecordTypeMx ResolverRecordType = 2
	// ResolverRecordTypeTxt: look up DNS TXT records for a name
	ResolverRecordTypeTxt ResolverRecordType = 3
	// ResolverRecordTypeSoa: look up DNS SOA records for a zone
	ResolverRecordTypeSoa ResolverRecordType = 4
	// ResolverRecordTypeNs: look up DNS NS records for a domain
	ResolverRecordTypeNs ResolverRecordType = 5
)

func marshalResolverRecordType(p uintptr) (interface{}, error) {
	return ResolverRecordType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceError: an error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError int

const (
	// ResourceErrorNotFound: no file was found at the requested path
	ResourceErrorNotFound ResourceError = 0
	// ResourceErrorInternal: unknown error
	ResourceErrorInternal ResourceError = 1
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketClientEvent describes an event occurring on a Client. See the
// Client::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketClientEvent int

const (
	// SocketClientEventResolving: the client is doing a DNS lookup.
	SocketClientEventResolving SocketClientEvent = 0
	// SocketClientEventResolved: the client has completed a DNS lookup.
	SocketClientEventResolved SocketClientEvent = 1
	// SocketClientEventConnecting: the client is connecting to a remote host
	// (either a proxy or the destination server).
	SocketClientEventConnecting SocketClientEvent = 2
	// SocketClientEventConnected: the client has connected to a remote host.
	SocketClientEventConnected SocketClientEvent = 3
	// SocketClientEventProXYNegotiating: the client is negotiating with a proxy
	// to connect to the destination server.
	SocketClientEventProXYNegotiating SocketClientEvent = 4
	// SocketClientEventProXYNegotiated: the client has negotiated with the
	// proxy server.
	SocketClientEventProXYNegotiated SocketClientEvent = 5
	// SocketClientEventTLSHandshaking: the client is performing a TLS
	// handshake.
	SocketClientEventTLSHandshaking SocketClientEvent = 6
	// SocketClientEventTLSHandshaked: the client has performed a TLS handshake.
	SocketClientEventTLSHandshaked SocketClientEvent = 7
	// SocketClientEventComplete: the client is done with a particular
	// Connectable.
	SocketClientEventComplete SocketClientEvent = 8
)

func marshalSocketClientEvent(p uintptr) (interface{}, error) {
	return SocketClientEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketFamily: the protocol family of a Address. (These values are identical
// to the system defines AF_INET, AF_INET6 and AF_UNIX, if available.)
type SocketFamily int

const (
	// SocketFamilyInvalid: no address family
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyUnix: the UNIX domain family
	SocketFamilyUnix SocketFamily = 1
	// SocketFamilyIPv4: the IPv4 family
	SocketFamilyIPv4 SocketFamily = 2
	// SocketFamilyIPv6: the IPv6 family
	SocketFamilyIPv6 SocketFamily = 10
)

func marshalSocketFamily(p uintptr) (interface{}, error) {
	return SocketFamily(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketListenerEvent describes an event occurring on a Listener. See the
// Listener::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketListenerEvent int

const (
	// SocketListenerEventBinding: the listener is about to bind a socket.
	SocketListenerEventBinding SocketListenerEvent = 0
	// SocketListenerEventBound: the listener has bound a socket.
	SocketListenerEventBound SocketListenerEvent = 1
	// SocketListenerEventListening: the listener is about to start listening on
	// this socket.
	SocketListenerEventListening SocketListenerEvent = 2
	// SocketListenerEventListened: the listener is now listening on this
	// socket.
	SocketListenerEventListened SocketListenerEvent = 3
)

func marshalSocketListenerEvent(p uintptr) (interface{}, error) {
	return SocketListenerEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketProtocol: a protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
//
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
type SocketProtocol int

const (
	// SocketProtocolUnknown: the protocol type is unknown
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault: the default protocol for the family/type
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTCP: TCP over IP
	SocketProtocolTCP SocketProtocol = 6
	// SocketProtocolUDP: UDP over IP
	SocketProtocolUDP SocketProtocol = 17
	// SocketProtocolSCTP: SCTP over IP
	SocketProtocolSCTP SocketProtocol = 132
)

func marshalSocketProtocol(p uintptr) (interface{}, error) {
	return SocketProtocol(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketType flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
type SocketType int

const (
	// SocketTypeInvalid: type unknown or wrong
	SocketTypeInvalid SocketType = 0
	// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream SocketType = 1
	// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP)
	SocketTypeDatagram SocketType = 2
	// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket SocketType = 3
)

func marshalSocketType(p uintptr) (interface{}, error) {
	return SocketType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSAuthenticationMode: the client authentication mode for a ServerConnection.
type TLSAuthenticationMode int

const (
	// TLSAuthenticationModeNone: client authentication not required
	TLSAuthenticationModeNone TLSAuthenticationMode = 0
	// TLSAuthenticationModeRequested: client authentication is requested
	TLSAuthenticationModeRequested TLSAuthenticationMode = 1
	// TLSAuthenticationModeRequired: client authentication is required
	TLSAuthenticationModeRequired TLSAuthenticationMode = 2
)

func marshalTLSAuthenticationMode(p uintptr) (interface{}, error) {
	return TLSAuthenticationMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSCertificateRequestFlags flags for g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
type TLSCertificateRequestFlags int

const (
	// TLSCertificateRequestFlagsNone: no flags
	TLSCertificateRequestFlagsNone TLSCertificateRequestFlags = 0
)

func marshalTLSCertificateRequestFlags(p uintptr) (interface{}, error) {
	return TLSCertificateRequestFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSChannelBindingError: an error code used with G_TLS_CHANNEL_BINDING_ERROR
// in a #GError to indicate a TLS channel binding retrieval error.
type TLSChannelBindingError int

const (
	// TLSChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
	TLSChannelBindingErrorNotImplemented TLSChannelBindingError = 0
	// TLSChannelBindingErrorInvalidState: the handshake is not yet complete on
	// the connection which is a strong requirement for any existing binding
	// type.
	TLSChannelBindingErrorInvalidState TLSChannelBindingError = 1
	// TLSChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
	TLSChannelBindingErrorNotAvailable TLSChannelBindingError = 2
	// TLSChannelBindingErrorNotSupported: binding type is not supported on the
	// current connection. This error could be triggered when requesting
	// `tls-server-end-point` binding data for a certificate which has no hash
	// function or uses multiple hash functions.
	TLSChannelBindingErrorNotSupported TLSChannelBindingError = 3
	// TLSChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
	TLSChannelBindingErrorGeneralError TLSChannelBindingError = 4
)

func marshalTLSChannelBindingError(p uintptr) (interface{}, error) {
	return TLSChannelBindingError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSChannelBindingType: the type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929. The
// `tls-unique-for-telnet` (https://tools.ietf.org/html/rfc5929#section-5)
// binding type is not currently implemented.
type TLSChannelBindingType int

const (
	// TLSChannelBindingTypeUnique: `tls-unique`
	// (https://tools.ietf.org/html/rfc5929#section-3) binding type
	TLSChannelBindingTypeUnique TLSChannelBindingType = 0
	// TLSChannelBindingTypeServerEndPoint: `tls-server-end-point`
	// (https://tools.ietf.org/html/rfc5929#section-4) binding type
	TLSChannelBindingTypeServerEndPoint TLSChannelBindingType = 1
)

func marshalTLSChannelBindingType(p uintptr) (interface{}, error) {
	return TLSChannelBindingType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSDatabaseLookupFlags flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
type TLSDatabaseLookupFlags int

const (
	// TLSDatabaseLookupFlagsNone: no lookup flags
	TLSDatabaseLookupFlagsNone TLSDatabaseLookupFlags = 0
	// TLSDatabaseLookupFlagsKeypair: restrict lookup to certificates that have
	// a private key.
	TLSDatabaseLookupFlagsKeypair TLSDatabaseLookupFlags = 1
)

func marshalTLSDatabaseLookupFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSError: an error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TLSError int

const (
	// TLSErrorUnavailable: no TLS provider is available
	TLSErrorUnavailable TLSError = 0
	// TLSErrorMisc miscellaneous TLS error
	TLSErrorMisc TLSError = 1
	// TLSErrorBadCertificate: the certificate presented could not be parsed or
	// failed validation.
	TLSErrorBadCertificate TLSError = 2
	// TLSErrorNotTLS: the TLS handshake failed because the peer does not seem
	// to be a TLS server.
	TLSErrorNotTLS TLSError = 3
	// TLSErrorHandshake: the TLS handshake failed because the peer's
	// certificate was not acceptable.
	TLSErrorHandshake TLSError = 4
	// TLSErrorCertificateRequired: the TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
	TLSErrorCertificateRequired TLSError = 5
	// TLSErrorEOF: the TLS connection was closed without proper notice, which
	// may indicate an attack. See g_tls_connection_set_require_close_notify().
	TLSErrorEOF TLSError = 6
	// TLSErrorInappropriateFallback: the TLS handshake failed because the
	// client sent the fallback SCSV, indicating a protocol downgrade attack.
	// Since: 2.60
	TLSErrorInappropriateFallback TLSError = 7
)

func marshalTLSError(p uintptr) (interface{}, error) {
	return TLSError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSInteractionResult is returned by various functions in Interaction when
// finishing an interaction request.
type TLSInteractionResult int

const (
	// TLSInteractionResultUnhandled: the interaction was unhandled (i.e. not
	// implemented).
	TLSInteractionResultUnhandled TLSInteractionResult = 0
	// TLSInteractionResultHandled: the interaction completed, and resulting
	// data is available.
	TLSInteractionResultHandled TLSInteractionResult = 1
	// TLSInteractionResultFailed: the interaction has failed, or was cancelled.
	// and the operation should be aborted.
	TLSInteractionResultFailed TLSInteractionResult = 2
)

func marshalTLSInteractionResult(p uintptr) (interface{}, error) {
	return TLSInteractionResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
type TLSRehandshakeMode int

const (
	// TLSRehandshakeModeNever: never allow rehandshaking
	TLSRehandshakeModeNever TLSRehandshakeMode = 0
	// TLSRehandshakeModeSafely: allow safe rehandshaking only
	TLSRehandshakeModeSafely TLSRehandshakeMode = 1
	// TLSRehandshakeModeUnsafely: allow unsafe rehandshaking
	TLSRehandshakeModeUnsafely TLSRehandshakeMode = 2
)

func marshalTLSRehandshakeMode(p uintptr) (interface{}, error) {
	return TLSRehandshakeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UnixSocketAddressType: the type of name used by a SocketAddress.
// G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain socket bound
// to a filesystem path. G_UNIX_SOCKET_ADDRESS_ANONYMOUS indicates a socket not
// bound to any name (eg, a client-side socket, or a socket created with
// socketpair()).
//
// For abstract sockets, there are two incompatible ways of naming them; the man
// pages suggest using the entire `struct sockaddr_un` as the name, padding the
// unused parts of the sun_path field with zeroes; this corresponds to
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED. However, many programs instead just
// use a portion of sun_path, and pass an appropriate smaller length to bind()
// or connect(). This is G_UNIX_SOCKET_ADDRESS_ABSTRACT.
type UnixSocketAddressType int

const (
	// UnixSocketAddressTypeInvalid: invalid
	UnixSocketAddressTypeInvalid UnixSocketAddressType = 0
	// UnixSocketAddressTypeAnonymous: anonymous
	UnixSocketAddressTypeAnonymous UnixSocketAddressType = 1
	// UnixSocketAddressTypePath: a filesystem path
	UnixSocketAddressTypePath UnixSocketAddressType = 2
	// UnixSocketAddressTypeAbstract: an abstract name
	UnixSocketAddressTypeAbstract UnixSocketAddressType = 3
	// UnixSocketAddressTypeAbstractPadded: an abstract name, 0-padded to the
	// full length of a unix socket name
	UnixSocketAddressTypeAbstractPadded UnixSocketAddressType = 4
)

func marshalUnixSocketAddressType(p uintptr) (interface{}, error) {
	return UnixSocketAddressType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ZlibCompressorFormat: used to select the type of data format to use for
// Decompressor and Compressor.
type ZlibCompressorFormat int

const (
	// ZlibCompressorFormatZlib: deflate compression with zlib header
	ZlibCompressorFormatZlib ZlibCompressorFormat = 0
	// ZlibCompressorFormatGzip: gzip file format
	ZlibCompressorFormatGzip ZlibCompressorFormat = 1
	// ZlibCompressorFormatRaw: deflate compression with no header
	ZlibCompressorFormatRaw ZlibCompressorFormat = 2
)

func marshalZlibCompressorFormat(p uintptr) (interface{}, error) {
	return ZlibCompressorFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppInfoCreateFlags flags used when creating a Info.
type AppInfoCreateFlags int

const (
	// AppInfoCreateFlagsNone: no flags.
	AppInfoCreateFlagsNone AppInfoCreateFlags = 0
	// AppInfoCreateFlagsNeedsTerminal: application opens in a terminal window.
	AppInfoCreateFlagsNeedsTerminal AppInfoCreateFlags = 1
	// AppInfoCreateFlagsSupportsUris: application supports URI arguments.
	AppInfoCreateFlagsSupportsUris AppInfoCreateFlags = 2
	// AppInfoCreateFlagsSupportsStartupNotification: application supports
	// startup notification. Since 2.26
	AppInfoCreateFlagsSupportsStartupNotification AppInfoCreateFlags = 4
)

func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
	return AppInfoCreateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationFlags flags used to define the behaviour of a #GApplication.
type ApplicationFlags int

const (
	// ApplicationFlagsFlagsNone: default
	ApplicationFlagsFlagsNone ApplicationFlags = 0
	// ApplicationFlagsIsService: run as a service. In this mode, registration
	// fails if the service is already running, and the application will
	// initially wait up to 10 seconds for an initial activation message to
	// arrive.
	ApplicationFlagsIsService ApplicationFlags = 1
	// ApplicationFlagsIsLauncher: don't try to become the primary instance.
	ApplicationFlagsIsLauncher ApplicationFlags = 2
	// ApplicationFlagsHandlesOpen: this application handles opening files (in
	// the primary instance). Note that this flag only affects the default
	// implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
	ApplicationFlagsHandlesOpen ApplicationFlags = 4
	// ApplicationFlagsHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
	ApplicationFlagsHandlesCommandLine ApplicationFlags = 8
	// ApplicationFlagsSendEnvironment: send the environment of the launching
	// process to the primary instance. Set this flag if your application is
	// expected to behave differently depending on certain environment
	// variables. For instance, an editor might be expected to use the
	// `GIT_COMMITTER_NAME` environment variable when editing a git commit
	// message. The environment is available to the #GApplication::command-line
	// signal handler, via g_application_command_line_getenv().
	ApplicationFlagsSendEnvironment ApplicationFlags = 16
	// ApplicationFlagsNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID is
	// given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
	ApplicationFlagsNonUnique ApplicationFlags = 32
	// ApplicationFlagsCanOverrideAppID: allow users to override the application
	// ID from the command line with `--gapplication-app-id`. Since: 2.48
	ApplicationFlagsCanOverrideAppID ApplicationFlags = 64
	// ApplicationFlagsAllowReplacement: allow another instance to take over the
	// bus name. Since: 2.60
	ApplicationFlagsAllowReplacement ApplicationFlags = 128
	// ApplicationFlagsReplace: take over from another instance. This flag is
	// usually set by passing `--gapplication-replace` on the commandline.
	// Since: 2.60
	ApplicationFlagsReplace ApplicationFlags = 256
)

func marshalApplicationFlags(p uintptr) (interface{}, error) {
	return ApplicationFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AskPasswordFlags PasswordFlags are used to request specific information from
// the user, or to notify the user of their choices in an authentication
// situation.
type AskPasswordFlags int

const (
	// AskPasswordFlagsNeedPassword: operation requires a password.
	AskPasswordFlagsNeedPassword AskPasswordFlags = 1
	// AskPasswordFlagsNeedUsername: operation requires a username.
	AskPasswordFlagsNeedUsername AskPasswordFlags = 2
	// AskPasswordFlagsNeedDomain: operation requires a domain.
	AskPasswordFlagsNeedDomain AskPasswordFlags = 4
	// AskPasswordFlagsSavingSupported: operation supports saving settings.
	AskPasswordFlagsSavingSupported AskPasswordFlags = 8
	// AskPasswordFlagsAnonymousSupported: operation supports anonymous users.
	AskPasswordFlagsAnonymousSupported AskPasswordFlags = 16
	// AskPasswordFlagsTcrypt: operation takes TCRYPT parameters (Since: 2.58)
	AskPasswordFlagsTcrypt AskPasswordFlags = 32
)

func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
	return AskPasswordFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameOwnerFlags flags used in g_bus_own_name().
type BusNameOwnerFlags int

const (
	// BusNameOwnerFlagsNone: no flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0
	// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 1
	// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the
	// name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 2
	// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns the
	// name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54)
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 4
)

func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
	return BusNameOwnerFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameWatcherFlags flags used in g_bus_watch_name().
type BusNameWatcherFlags int

const (
	// BusNameWatcherFlagsNone: no flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0
	// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 1
)

func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
	return BusNameWatcherFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterFlags flags used when calling a g_converter_convert().
type ConverterFlags int

const (
	// ConverterFlagsNone: no flags.
	ConverterFlagsNone ConverterFlags = 0
	// ConverterFlagsInputAtEnd: at end of input data
	ConverterFlagsInputAtEnd ConverterFlags = 1
	// ConverterFlagsFlush: flush data
	ConverterFlagsFlush ConverterFlags = 2
)

func marshalConverterFlags(p uintptr) (interface{}, error) {
	return ConverterFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCallFlags flags used in g_dbus_connection_call() and similar APIs.
type DBusCallFlags int

const (
	// DBusCallFlagsNone: no flags set.
	DBusCallFlagsNone DBusCallFlags = 0
	// DBusCallFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this method invocation.
	DBusCallFlagsNoAutoStart DBusCallFlags = 1
	// DBusCallFlagsAllowInteractiveAuthorization: the caller is prepared to
	// wait for interactive authorization. Since 2.46.
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 2
)

func marshalDBusCallFlags(p uintptr) (interface{}, error) {
	return DBusCallFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCapabilityFlags capabilities negotiated with the remote peer.
type DBusCapabilityFlags int

const (
	// DBusCapabilityFlagsNone: no flags set.
	DBusCapabilityFlagsNone DBusCapabilityFlags = 0
	// DBusCapabilityFlagsUnixFdPassing: the connection supports exchanging UNIX
	// file descriptors with the remote peer.
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 1
)

func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
	return DBusCapabilityFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusConnectionFlags flags used when creating a new BusConnection.
type DBusConnectionFlags int

const (
	// DBusConnectionFlagsNone: no flags set.
	DBusConnectionFlagsNone DBusConnectionFlags = 0
	// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
	DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 1
	// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
	DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 2
	// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 4
	// DBusConnectionFlagsMessageBusConnection pass this flag if connecting to a
	// peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
	DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 8
	// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
	DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 16
	// DBusConnectionFlagsAuthenticationRequireSameUser: when authenticating as
	// a server, require the UID of the peer to be the same as the UID of the
	// server. (Since: 2.68)
	DBusConnectionFlagsAuthenticationRequireSameUser DBusConnectionFlags = 32
)

func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
	return DBusConnectionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusInterfaceSkeletonFlags flags describing the behavior of a
// BusInterfaceSkeleton instance.
type DBusInterfaceSkeletonFlags int

const (
	// DBusInterfaceSkeletonFlagsNone: no flags set.
	DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0
	// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 1
)

func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
	return DBusInterfaceSkeletonFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageFlags: message flags used in BusMessage.
type DBusMessageFlags int

const (
	// DBusMessageFlagsNone: no flags set.
	DBusMessageFlagsNone DBusMessageFlags = 0
	// DBusMessageFlagsNoReplyExpected: a reply is not expected.
	DBusMessageFlagsNoReplyExpected DBusMessageFlags = 1
	// DBusMessageFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this message.
	DBusMessageFlagsNoAutoStart DBusMessageFlags = 2
	// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 4
)

func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
	return DBusMessageFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusObjectManagerClientFlags flags used when constructing a
// BusObjectManagerClient.
type DBusObjectManagerClientFlags int

const (
	// DBusObjectManagerClientFlagsNone: no flags set.
	DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0
	// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager is
	// for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 1
)

func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
	return DBusObjectManagerClientFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusPropertyInfoFlags flags describing the access control of a D-Bus
// property.
type DBusPropertyInfoFlags int

const (
	// DBusPropertyInfoFlagsNone: no flags set.
	DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0
	// DBusPropertyInfoFlagsReadable: property is readable.
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 1
	// DBusPropertyInfoFlagsWritable: property is writable.
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 2
)

func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
	return DBusPropertyInfoFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusProXYFlags flags used when constructing an instance of a BusProxy derived
// class.
type DBusProXYFlags int

const (
	// DBusProXYFlagsNone: no flags set.
	DBusProXYFlagsNone DBusProXYFlags = 0
	// DBusProXYFlagsDoNotLoadProperties: don't load properties.
	DBusProXYFlagsDoNotLoadProperties DBusProXYFlags = 1
	// DBusProXYFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
	DBusProXYFlagsDoNotConnectSignals DBusProXYFlags = 2
	// DBusProXYFlagsDoNotAutoStart: if the proxy is for a well-known name, do
	// not ask the bus to launch an owner during proxy initialization or a
	// method call. This flag is only meaningful in proxies for well-known
	// names.
	DBusProXYFlagsDoNotAutoStart DBusProXYFlags = 4
	// DBusProXYFlagsGetInvalidatedProperties: if set, the property value for
	// any __invalidated property__ will be (asynchronously) retrieved upon
	// receiving the `PropertiesChanged`
	// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
	DBusProXYFlagsGetInvalidatedProperties DBusProXYFlags = 8
	// DBusProXYFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call. This
	// flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
	DBusProXYFlagsDoNotAutoStartAtConstruction DBusProXYFlags = 16
)

func marshalDBusProXYFlags(p uintptr) (interface{}, error) {
	return DBusProXYFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSendMessageFlags flags used when sending BusMessages on a BusConnection.
type DBusSendMessageFlags int

const (
	// DBusSendMessageFlagsNone: no flags set.
	DBusSendMessageFlagsNone DBusSendMessageFlags = 0
	// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 1
)

func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
	return DBusSendMessageFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusServerFlags flags used when creating a BusServer.
type DBusServerFlags int

const (
	// DBusServerFlagsNone: no flags set.
	DBusServerFlagsNone DBusServerFlags = 0
	// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
	DBusServerFlagsRunInThread DBusServerFlags = 1
	// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 2
	// DBusServerFlagsAuthenticationRequireSameUser: require the UID of the peer
	// to be the same as the UID of the server when authenticating. (Since:
	// 2.68)
	DBusServerFlagsAuthenticationRequireSameUser DBusServerFlags = 4
)

func marshalDBusServerFlags(p uintptr) (interface{}, error) {
	return DBusServerFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSignalFlags flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
type DBusSignalFlags int

const (
	// DBusSignalFlagsNone: no flags set.
	DBusSignalFlagsNone DBusSignalFlags = 0
	// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
	DBusSignalFlagsNoMatchRule DBusSignalFlags = 1
	// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 2
	// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
	DBusSignalFlagsMatchArg0Path DBusSignalFlags = 4
)

func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
	return DBusSignalFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSubtreeFlags flags passed to g_dbus_connection_register_subtree().
type DBusSubtreeFlags int

const (
	// DBusSubtreeFlagsNone: no flags set.
	DBusSubtreeFlagsNone DBusSubtreeFlags = 0
	// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 1
)

func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
	return DBusSubtreeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartFlags flags used when starting a drive.
type DriveStartFlags int

const (
	// DriveStartFlagsNone: no flags set.
	DriveStartFlagsNone DriveStartFlags = 0
)

func marshalDriveStartFlags(p uintptr) (interface{}, error) {
	return DriveStartFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeInfoFlags flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags int

const (
	// FileAttributeInfoFlagsNone: no flags set.
	FileAttributeInfoFlagsNone FileAttributeInfoFlags = 0
	// FileAttributeInfoFlagsCopyWithFile: copy the attribute values when the
	// file is copied.
	FileAttributeInfoFlagsCopyWithFile FileAttributeInfoFlags = 1
	// FileAttributeInfoFlagsCopyWhenMoved: copy the attribute values when the
	// file is moved.
	FileAttributeInfoFlagsCopyWhenMoved FileAttributeInfoFlags = 2
)

func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
	return FileAttributeInfoFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCopyFlags flags used when copying or moving files.
type FileCopyFlags int

const (
	// FileCopyFlagsNone: no flags set.
	FileCopyFlagsNone FileCopyFlags = 0
	// FileCopyFlagsOverwrite: overwrite any existing files
	FileCopyFlagsOverwrite FileCopyFlags = 1
	// FileCopyFlagsBackup: make a backup of any existing files.
	FileCopyFlagsBackup FileCopyFlags = 2
	// FileCopyFlagsNofollowSymlinks: don't follow symlinks.
	FileCopyFlagsNofollowSymlinks FileCopyFlags = 4
	// FileCopyFlagsAllMetadata: copy all file metadata instead of just default
	// set used for copy (see Info).
	FileCopyFlagsAllMetadata FileCopyFlags = 8
	// FileCopyFlagsNoFallbackForMove: don't use copy and delete fallback if
	// native move not supported.
	FileCopyFlagsNoFallbackForMove FileCopyFlags = 16
	// FileCopyFlagsTargetDefaultPerms leaves target file with default perms,
	// instead of setting the source file perms.
	FileCopyFlagsTargetDefaultPerms FileCopyFlags = 32
)

func marshalFileCopyFlags(p uintptr) (interface{}, error) {
	return FileCopyFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCreateFlags flags used when an operation may create a file.
type FileCreateFlags int

const (
	// FileCreateFlagsNone: no flags set.
	FileCreateFlagsNone FileCreateFlags = 0
	// FileCreateFlagsPrivate: create a file that can only be accessed by the
	// current user.
	FileCreateFlagsPrivate FileCreateFlags = 1
	// FileCreateFlagsReplaceDestination: replace the destination as if it
	// didn't exist before. Don't try to keep any old permissions, replace
	// instead of following links. This is generally useful if you're doing a
	// "copy over" rather than a "save new version of" replace operation. You
	// can think of it as "unlink destination" before writing to it, although
	// the implementation may not be exactly like that. This flag can only be
	// used with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20
	FileCreateFlagsReplaceDestination FileCreateFlags = 2
)

func marshalFileCreateFlags(p uintptr) (interface{}, error) {
	return FileCreateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMeasureFlags flags that can be used with g_file_measure_disk_usage().
type FileMeasureFlags int

const (
	// FileMeasureFlagsNone: no flags set.
	FileMeasureFlagsNone FileMeasureFlags = 0
	// FileMeasureFlagsReportAnyError: report any error encountered while
	// traversing the directory tree. Normally errors are only reported for the
	// toplevel file.
	FileMeasureFlagsReportAnyError FileMeasureFlags = 2
	// FileMeasureFlagsApparentSize: tally usage based on apparent file sizes.
	// Normally, the block-size is used, if available, as this is a more
	// accurate representation of disk space used. Compare with `du
	// --apparent-size`.
	FileMeasureFlagsApparentSize FileMeasureFlags = 4
	// FileMeasureFlagsNoXdev: do not cross mount point boundaries. Compare with
	// `du -x`.
	FileMeasureFlagsNoXdev FileMeasureFlags = 8
)

func marshalFileMeasureFlags(p uintptr) (interface{}, error) {
	return FileMeasureFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorFlags flags used to set what a Monitor will watch for.
type FileMonitorFlags int

const (
	// FileMonitorFlagsNone: no flags set.
	FileMonitorFlagsNone FileMonitorFlags = 0
	// FileMonitorFlagsWatchMounts: watch for mount events.
	FileMonitorFlagsWatchMounts FileMonitorFlags = 1
	// FileMonitorFlagsSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorFlagsSendMoved FileMonitorFlags = 2
	// FileMonitorFlagsWatchHardLinks: watch for changes to the file made via
	// another hard link. Since 2.36.
	FileMonitorFlagsWatchHardLinks FileMonitorFlags = 4
	// FileMonitorFlagsWatchMoves: watch for rename operations on a monitored
	// directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
	FileMonitorFlagsWatchMoves FileMonitorFlags = 8
)

func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
	return FileMonitorFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileQueryInfoFlags flags used when querying a Info.
type FileQueryInfoFlags int

const (
	// FileQueryInfoFlagsNone: no flags set.
	FileQueryInfoFlagsNone FileQueryInfoFlags = 0
	// FileQueryInfoFlagsNofollowSymlinks: don't follow symlinks.
	FileQueryInfoFlagsNofollowSymlinks FileQueryInfoFlags = 1
)

func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
	return FileQueryInfoFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOStreamSpliceFlags gIOStreamSpliceFlags determine how streams should be
// spliced.
type IOStreamSpliceFlags int

const (
	// IOStreamSpliceFlagsNone: do not close either stream.
	IOStreamSpliceFlagsNone IOStreamSpliceFlags = 0
	// IOStreamSpliceFlagsCloseStream1: close the first stream after the splice.
	IOStreamSpliceFlagsCloseStream1 IOStreamSpliceFlags = 1
	// IOStreamSpliceFlagsCloseStream2: close the second stream after the
	// splice.
	IOStreamSpliceFlagsCloseStream2 IOStreamSpliceFlags = 2
	// IOStreamSpliceFlagsWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
	IOStreamSpliceFlagsWaitForBoth IOStreamSpliceFlags = 4
)

func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
	return IOStreamSpliceFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountMountFlags flags used when mounting a mount.
type MountMountFlags int

const (
	// MountMountFlagsNone: no flags set.
	MountMountFlagsNone MountMountFlags = 0
)

func marshalMountMountFlags(p uintptr) (interface{}, error) {
	return MountMountFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountUnmountFlags flags used when an unmounting a mount.
type MountUnmountFlags int

const (
	// MountUnmountFlagsNone: no flags set.
	MountUnmountFlagsNone MountUnmountFlags = 0
	// MountUnmountFlagsForce: unmount even if there are outstanding file
	// operations on the mount.
	MountUnmountFlagsForce MountUnmountFlags = 1
)

func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
	return MountUnmountFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// OutputStreamSpliceFlags gOutputStreamSpliceFlags determine how streams should
// be spliced.
type OutputStreamSpliceFlags int

const (
	// OutputStreamSpliceFlagsNone: do not close either stream.
	OutputStreamSpliceFlagsNone OutputStreamSpliceFlags = 0
	// OutputStreamSpliceFlagsCloseSource: close the source stream after the
	// splice.
	OutputStreamSpliceFlagsCloseSource OutputStreamSpliceFlags = 1
	// OutputStreamSpliceFlagsCloseTarget: close the target stream after the
	// splice.
	OutputStreamSpliceFlagsCloseTarget OutputStreamSpliceFlags = 2
)

func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
	return OutputStreamSpliceFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverNameLookupFlags flags to modify lookup behavior.
type ResolverNameLookupFlags int

const (
	// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name())
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0
	// ResolverNameLookupFlagsIPv4Only: only resolve ipv4 addresses
	ResolverNameLookupFlagsIPv4Only ResolverNameLookupFlags = 1
	// ResolverNameLookupFlagsIPv6Only: only resolve ipv6 addresses
	ResolverNameLookupFlagsIPv6Only ResolverNameLookupFlags = 2
)

func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
	return ResolverNameLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceFlags gResourceFlags give information about a particular file inside
// a resource bundle.
type ResourceFlags int

const (
	// ResourceFlagsNone: no flags set.
	ResourceFlagsNone ResourceFlags = 0
	// ResourceFlagsCompressed: the file is compressed.
	ResourceFlagsCompressed ResourceFlags = 1
)

func marshalResourceFlags(p uintptr) (interface{}, error) {
	return ResourceFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceLookupFlags gResourceLookupFlags determine how resource path lookups
// are handled.
type ResourceLookupFlags int

const (
	// ResourceLookupFlagsNone: no flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0
)

func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
	return ResourceLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SettingsBindFlags flags used when creating a binding. These flags determine
// in which direction the binding works. The default is to synchronize in both
// directions.
type SettingsBindFlags int

const (
	// SettingsBindFlagsDefault: equivalent to
	// `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
	SettingsBindFlagsDefault SettingsBindFlags = 0
	// SettingsBindFlagsGet: update the #GObject property when the setting
	// changes. It is an error to use this flag if the property is not writable.
	SettingsBindFlagsGet SettingsBindFlags = 1
	// SettingsBindFlagsSet: update the setting when the #GObject property
	// changes. It is an error to use this flag if the property is not readable.
	SettingsBindFlagsSet SettingsBindFlags = 2
	// SettingsBindFlagsNoSensitivity: do not try to bind a "sensitivity"
	// property to the writability of the setting
	SettingsBindFlagsNoSensitivity SettingsBindFlags = 4
	// SettingsBindFlagsGetNoChanges: when set in addition to SETTINGS_BIND_GET,
	// set the #GObject property value initially from the setting, but do not
	// listen for changes of the setting
	SettingsBindFlagsGetNoChanges SettingsBindFlags = 8
	// SettingsBindFlagsInvertBoolean: when passed to g_settings_bind(), uses a
	// pair of mapping functions that invert the boolean value when mapping
	// between the setting and the property. The setting and property must both
	// be booleans. You cannot pass this flag to g_settings_bind_with_mapping().
	SettingsBindFlagsInvertBoolean SettingsBindFlags = 16
)

func marshalSettingsBindFlags(p uintptr) (interface{}, error) {
	return SettingsBindFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketMsgFlags flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
type SocketMsgFlags int

const (
	// SocketMsgFlagsNone: no flags.
	SocketMsgFlagsNone SocketMsgFlags = 0
	// SocketMsgFlagsOob: request to send/receive out of band data.
	SocketMsgFlagsOob SocketMsgFlags = 1
	// SocketMsgFlagsPeek: read data from the socket without removing it from
	// the queue.
	SocketMsgFlagsPeek SocketMsgFlags = 2
	// SocketMsgFlagsDontroute: don't use a gateway to send out the packet, only
	// send to hosts on directly connected networks.
	SocketMsgFlagsDontroute SocketMsgFlags = 4
)

func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
	return SocketMsgFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubprocessFlags flags to define the behaviour of a #GSubprocess.
//
// Note that the default for stdin is to redirect from `/dev/null`. For stdout
// and stderr the default are for them to inherit the corresponding descriptor
// from the calling process.
//
// Note that it is a programmer error to mix 'incompatible' flags. For example,
// you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
type SubprocessFlags int

const (
	// SubprocessFlagsNone: no flags.
	SubprocessFlagsNone SubprocessFlags = 0
	// SubprocessFlagsStdinPipe: create a pipe for the stdin of the spawned
	// process that can be accessed with g_subprocess_get_stdin_pipe().
	SubprocessFlagsStdinPipe SubprocessFlags = 1
	// SubprocessFlagsStdinInherit: stdin is inherited from the calling process.
	SubprocessFlagsStdinInherit SubprocessFlags = 2
	// SubprocessFlagsStdoutPipe: create a pipe for the stdout of the spawned
	// process that can be accessed with g_subprocess_get_stdout_pipe().
	SubprocessFlagsStdoutPipe SubprocessFlags = 4
	// SubprocessFlagsStdoutSilence: silence the stdout of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStdoutSilence SubprocessFlags = 8
	// SubprocessFlagsStderrPipe: create a pipe for the stderr of the spawned
	// process that can be accessed with g_subprocess_get_stderr_pipe().
	SubprocessFlagsStderrPipe SubprocessFlags = 16
	// SubprocessFlagsStderrSilence: silence the stderr of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStderrSilence SubprocessFlags = 32
	// SubprocessFlagsStderrMerge: merge the stderr of the spawned process with
	// whatever the stdout happens to be. This is a good way of directing both
	// streams to a common log file, for example.
	SubprocessFlagsStderrMerge SubprocessFlags = 64
	// SubprocessFlagsInheritFds: spawned processes will inherit the file
	// descriptors of their parent, unless those descriptors have been
	// explicitly marked as close-on-exec. This flag has no effect over the
	// "standard" file descriptors (stdin, stdout, stderr).
	SubprocessFlagsInheritFds SubprocessFlags = 128
)

func marshalSubprocessFlags(p uintptr) (interface{}, error) {
	return SubprocessFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TestDBusFlags flags to define future DBus behaviour.
type TestDBusFlags int

const (
	// TestDBusFlagsNone: no flags.
	TestDBusFlagsNone TestDBusFlags = 0
)

func marshalTestDBusFlags(p uintptr) (interface{}, error) {
	return TestDBusFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSCertificateFlags: a set of flags describing TLS certification validation.
// This can be used to set which validation steps to perform (eg, with
// g_tls_client_connection_set_validation_flags()), or to describe why a
// particular certificate was rejected (eg, in Connection::accept-certificate).
type TLSCertificateFlags int

const (
	// TLSCertificateFlagsUnknownCa: the signing certificate authority is not
	// known.
	TLSCertificateFlagsUnknownCa TLSCertificateFlags = 1
	// TLSCertificateFlagsBadIdentity: the certificate does not match the
	// expected identity of the site that it was retrieved from.
	TLSCertificateFlagsBadIdentity TLSCertificateFlags = 2
	// TLSCertificateFlagsNotActivated: the certificate's activation time is
	// still in the future
	TLSCertificateFlagsNotActivated TLSCertificateFlags = 4
	// TLSCertificateFlagsExpired: the certificate has expired
	TLSCertificateFlagsExpired TLSCertificateFlags = 8
	// TLSCertificateFlagsRevoked: the certificate has been revoked according to
	// the Connection's certificate revocation list.
	TLSCertificateFlagsRevoked TLSCertificateFlags = 16
	// TLSCertificateFlagsInsecure: the certificate's algorithm is considered
	// insecure.
	TLSCertificateFlagsInsecure TLSCertificateFlags = 32
	// TLSCertificateFlagsGenericError: some other error occurred validating the
	// certificate
	TLSCertificateFlagsGenericError TLSCertificateFlags = 64
	// TLSCertificateFlagsValidateAll: the combination of all of the above flags
	TLSCertificateFlagsValidateAll TLSCertificateFlags = 127
)

func marshalTLSCertificateFlags(p uintptr) (interface{}, error) {
	return TLSCertificateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSDatabaseVerifyFlags flags for g_tls_database_verify_chain().
type TLSDatabaseVerifyFlags int

const (
	// TLSDatabaseVerifyFlagsNone: no verification flags
	TLSDatabaseVerifyFlagsNone TLSDatabaseVerifyFlags = 0
)

func marshalTLSDatabaseVerifyFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseVerifyFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSPasswordFlags various flags for the password.
type TLSPasswordFlags int

const (
	// TLSPasswordFlagsNone: no flags
	TLSPasswordFlagsNone TLSPasswordFlags = 0
	// TLSPasswordFlagsRetry: the password was wrong, and the user should retry.
	TLSPasswordFlagsRetry TLSPasswordFlags = 2
	// TLSPasswordFlagsManyTries: hint to the user that the password has been
	// wrong many times, and the user may not have many chances left.
	TLSPasswordFlagsManyTries TLSPasswordFlags = 4
	// TLSPasswordFlagsFinalTry: hint to the user that this is the last try to
	// get this password right.
	TLSPasswordFlagsFinalTry TLSPasswordFlags = 8
)

func marshalTLSPasswordFlags(p uintptr) (interface{}, error) {
	return TLSPasswordFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusGetFinish finishes an operation started with g_bus_get().
//
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
func BusGetFinish(res AsyncResult) (DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_bus_get_finish(_arg1, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// BusGetSync: synchronously connects to the message bus specified by @bus_type.
// Note that the returned object may shared with other callers, e.g. if two
// separate parts of a process calls this function with the same @bus_type, they
// will share the same object.
//
// This is a synchronous failable function. See g_bus_get() and
// g_bus_get_finish() for the asynchronous version.
//
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
func BusGetSync(busType BusType, cancellable Cancellable) (DBusConnection, error) {
	var _arg1 C.GBusType         // out
	var _arg2 *C.GCancellable    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (C.GBusType)(busType)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_bus_get_sync(_arg1, _arg2, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// BusUnownName stops owning a name.
//
// Note that there may still be D-Bus traffic to process (relating to owning and
// unowning the name) in the current thread-default Context after this function
// has returned. You should continue to iterate the Context until the Notify
// function passed to g_bus_own_name() is called, in order to avoid memory leaks
// through callbacks queued on the Context after its stopped being iterated.
func BusUnownName(ownerId uint) {
	var _arg1 C.guint // out

	_arg1 = (C.guint)(ownerId)

	C.g_bus_unown_name(_arg1)
}

// BusUnwatchName stops watching a name.
//
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_bus_watch_name() is called, in order to avoid
// memory leaks through callbacks queued on the Context after its stopped being
// iterated.
func BusUnwatchName(watcherId uint) {
	var _arg1 C.guint // out

	_arg1 = (C.guint)(watcherId)

	C.g_bus_unwatch_name(_arg1)
}

// ContentTypeCanBeExecutable checks if a content type can be executable. Note
// that for instance things like text files can be executables (i.e. scripts and
// batch files).
func ContentTypeCanBeExecutable(typ string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_can_be_executable(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeEquals compares two content types for equality.
func ContentTypeEquals(type1 string, type2 string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(type1))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(type2))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_content_type_equals(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeFromMIMEType tries to find a content type based on the mime type
// name.
func ContentTypeFromMIMEType(mimeType string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_from_mime_type(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ContentTypeGetDescription gets the human readable description of the content
// type.
func ContentTypeGetDescription(typ string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_description(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ContentTypeGetGenericIconName gets the generic icon name for a content type.
//
// See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on the generic icon name.
func ContentTypeGetGenericIconName(typ string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_generic_icon_name(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ContentTypeGetIcon gets the icon for a content type.
func ContentTypeGetIcon(typ string) Icon {
	var _arg1 *C.gchar // out
	var _cret *C.GIcon // in

	_arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_icon(_arg1)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

// ContentTypeGetMIMEDirs: get the list of directories which MIME data is loaded
// from. See g_content_type_set_mime_dirs() for details.
func ContentTypeGetMIMEDirs() []string {
	var _cret **C.gchar

	_cret = C.g_content_type_get_mime_dirs()

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

// ContentTypeGetMIMEType gets the mime type for the content type, if one is
// registered.
func ContentTypeGetMIMEType(typ string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_mime_type(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ContentTypeGetSymbolicIcon gets the symbolic icon for a content type.
func ContentTypeGetSymbolicIcon(typ string) Icon {
	var _arg1 *C.gchar // out
	var _cret *C.GIcon // in

	_arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_symbolic_icon(_arg1)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

// ContentTypeGuess guesses the content type based on example data. If the
// function is uncertain, @result_uncertain will be set to true. Either
// @filename or @data may be nil, in which case the guess will be based solely
// on the other argument.
func ContentTypeGuess(filename string, data []byte) (bool, string) {
	var _arg1 *C.gchar // out
	var _arg2 *C.guchar
	var _arg3 C.gsize
	var _arg4 C.gboolean // in
	var _cret *C.gchar   // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gsize(len(data))
	_arg2 = (*C.guchar)(unsafe.Pointer(&data[0]))

	_cret = C.g_content_type_guess(_arg1, _arg2, _arg3, &_arg4)

	var _resultUncertain bool // out
	var _utf8 string          // out

	if _arg4 {
		_resultUncertain = true
	}
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _resultUncertain, _utf8
}

// ContentTypeGuessForTree tries to guess the type of the tree with root @root,
// by looking at the files it contains. The result is an array of content types,
// with the best guess coming first.
//
// The types returned all have the form x-content/foo, e.g. x-content/audio-cdda
// (for audio CDs) or x-content/image-dcf (for a camera memory card). See the
// shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This function is useful in the implementation of
// g_mount_guess_content_type().
func ContentTypeGuessForTree(root File) []string {
	var _arg1 *C.GFile // out
	var _cret **C.gchar

	_arg1 = (*C.GFile)(unsafe.Pointer(root.Native()))

	_cret = C.g_content_type_guess_for_tree(_arg1)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ContentTypeIsA determines if @type is a subset of @supertype.
func ContentTypeIsA(typ string, supertype string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(supertype))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_content_type_is_a(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeIsMIMEType determines if @type is a subset of @mime_type.
// Convenience wrapper around g_content_type_is_a().
func ContentTypeIsMIMEType(typ string, mimeType string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_content_type_is_mime_type(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeIsUnknown checks if the content type is the generic "unknown"
// type. On UNIX this is the "application/octet-stream" mimetype, while on win32
// it is "*" and on OSX it is a dynamic type or octet-stream.
func ContentTypeIsUnknown(typ string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_is_unknown(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeSetMIMEDirs: set the list of directories used by GIO to load the
// MIME database. If @dirs is nil, the directories used are the default:
//
//    - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
//    - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
//
// This function is intended to be used when writing tests that depend on
// information stored in the MIME database, in order to control the data.
//
// Typically, in case your tests use G_TEST_OPTION_ISOLATE_DIRS, but they depend
// on the systems MIME database, you should call this function with @dirs set
// to nil before calling g_test_init(), for instance:
//
//      // Load MIME data from the system
//      g_content_type_set_mime_dirs (NULL);
//      // Isolate the environment
//      g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
//
//      
//
//      return g_test_run ();
func ContentTypeSetMIMEDirs(dirs []string) {
	var _arg1 **C.gchar

	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(dirs)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(dirs))
		for i := range dirs {
			out[i] = (*C.gchar)(C.CString(dirs[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_content_type_set_mime_dirs(_arg1)
}

// DBusAddressEscapeValue: escape @string so it can appear in a D-Bus address as
// the value part of a key-value pair.
//
// For instance, if @string is `/run/bus-for-:0`, this function would return
// `/run/bus-for-3A0`, which could be used in a D-Bus address like
// `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-3A0`.
func DBusAddressEscapeValue(_string string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_address_escape_value(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusAddressGetForBusSync: synchronously looks up the D-Bus address for the
// well-known message bus instance specified by @bus_type. This may involve
// using various platform specific mechanisms.
//
// The returned address will be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DBusAddressGetForBusSync(busType BusType, cancellable Cancellable) (string, error) {
	var _arg1 C.GBusType      // out
	var _arg2 *C.GCancellable // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg1 = (C.GBusType)(busType)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_address_get_for_bus_sync(_arg1, _arg2, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// DBusAddressGetStreamFinish finishes an operation started with
// g_dbus_address_get_stream().
//
// A server is not required to set a GUID, so @out_guid may be set to nil even
// on success.
func DBusAddressGetStreamFinish(res AsyncResult) (string, IOStream, error) {
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.gchar        // in
	var _cret *C.GIOStream    // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_address_get_stream_finish(_arg1, &_arg2, &_cerr)

	var _outGuid string    // out
	var _ioStream IOStream // out
	var _goerr error       // out

	_outGuid = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_ioStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outGuid, _ioStream, _goerr
}

// DBusAddressGetStreamSync: synchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// A server is not required to set a GUID, so @out_guid may be set to nil even
// on success.
//
// This is a synchronous failable function. See g_dbus_address_get_stream() for
// the asynchronous version.
func DBusAddressGetStreamSync(address string, cancellable Cancellable) (string, IOStream, error) {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // in
	var _arg3 *C.GCancellable // out
	var _cret *C.GIOStream    // in
	var _cerr *C.GError       // in

	_arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_address_get_stream_sync(_arg1, &_arg2, _arg3, &_cerr)

	var _outGuid string    // out
	var _ioStream IOStream // out
	var _goerr error       // out

	_outGuid = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_ioStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outGuid, _ioStream, _goerr
}

// DBusEscapeObjectPath: this is a language binding friendly version of
// g_dbus_escape_object_path_bytestring().
func DBusEscapeObjectPath(s string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(s))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_escape_object_path(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusEscapeObjectPathBytestring escapes @bytes for use in a D-Bus object path
// component. @bytes is an array of zero or more nonzero bytes in an unspecified
// encoding, followed by a single zero byte.
//
// The escaping method consists of replacing all non-alphanumeric characters
// (see g_ascii_isalnum()) with their hexadecimal value preceded by an
// underscore (`_`). For example: `foo.bar.baz` will become `foo_2ebar_2ebaz`.
//
// This method is appropriate to use when the input is nearly a valid object
// path component but is not when your input is far from being a valid object
// path component. Other escaping algorithms are also valid to use with D-Bus
// object paths.
//
// This can be reversed with g_dbus_unescape_object_path().
func DBusEscapeObjectPathBytestring(bytes []byte) string {
	var _arg1 *C.guint8
	var _cret *C.gchar // in

	{
		var zero byte
		bytes = append(bytes, zero)
	}
	_arg1 = (*C.guint8)(unsafe.Pointer(&bytes[0]))

	_cret = C.g_dbus_escape_object_path_bytestring(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusGenerateGuid: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DBusGenerateGuid() string {
	var _cret *C.gchar // in

	_cret = C.g_dbus_generate_guid()

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusGValueToGVariant converts a #GValue to a #GVariant of the type indicated
// by the @type parameter.
//
// The conversion is using the following rules:
//
// - TYPE_STRING: 's', 'o', 'g' or 'ay' - TYPE_STRV: 'as', 'ao' or 'aay' -
// TYPE_BOOLEAN: 'b' - TYPE_UCHAR: 'y' - TYPE_INT: 'i', 'n' - TYPE_UINT: 'u',
// 'q' - TYPE_INT64 'x' - TYPE_UINT64: 't' - TYPE_DOUBLE: 'd' - TYPE_VARIANT:
// Any Type
//
// This can fail if e.g. @gvalue is of type TYPE_STRING and @type is
// ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType (including
// e.g. TYPE_OBJECT and TYPE_BOXED derived-types) not in the table above.
//
// Note that if @gvalue is of type TYPE_VARIANT and its value is nil, the empty
// #GVariant instance (never nil) for @type is returned (e.g. 0 for scalar
// types, the empty string for string types, '/' for object path types, the
// empty array for any array type and so on).
//
// See the g_dbus_gvariant_to_gvalue() function for how to convert a #GVariant
// to a #GValue.
func DBusGValueToGVariant(gvalue **externglib.Value, typ *glib.VariantType) *glib.Variant {
	var _arg1 *C.GValue       // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GValue)(gvalue.GValue)
	_arg2 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	_cret = C.g_dbus_gvalue_to_gvariant(_arg1, _arg2)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// DBusGVariantToGValue converts a #GVariant to a #GValue. If @value is
// floating, it is consumed.
//
// The rules specified in the g_dbus_gvalue_to_gvariant() function are used -
// this function is essentially its reverse form. So, a #GVariant containing any
// basic or string array type will be converted to a #GValue containing a basic
// value or string array. Any other #GVariant (handle, variant, tuple, dict
// entry) will be converted to a #GValue containing that #GVariant.
//
// The conversion never fails - a valid #GValue is always returned in
// @out_gvalue.
func DBusGVariantToGValue(value *glib.Variant) *externglib.Value {
	var _arg1 *C.GVariant // out
	var _arg2 C.GValue    // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_dbus_gvariant_to_gvalue(_arg1, &_arg2)

	var _outGvalue *externglib.Value // out

	_outGvalue = externglib.ValueFromNative(unsafe.Pointer(_arg2))

	return _outGvalue
}

// DBusIsAddress checks if @string is a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This doesn't check if @string is actually supported by BusServer or
// BusConnection - use g_dbus_is_supported_address() to do more checks.
func DBusIsAddress(_string string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_address(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsGuid checks if @string is a D-Bus GUID.
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DBusIsGuid(_string string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_guid(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsInterfaceName checks if @string is a valid D-Bus interface name.
func DBusIsInterfaceName(_string string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_interface_name(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsMemberName checks if @string is a valid D-Bus member (e.g. signal or
// method) name.
func DBusIsMemberName(_string string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_member_name(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsName checks if @string is a valid D-Bus bus name (either unique or
// well-known).
func DBusIsName(_string string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_name(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsSupportedAddress: like g_dbus_is_address() but also checks if the
// library supports the transports in @string and that key/value pairs for each
// transport are valid. See the specification of the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DBusIsSupportedAddress(_string string) error {
	var _arg1 *C.gchar  // out
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_is_supported_address(_arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// DBusIsUniqueName checks if @string is a valid D-Bus unique bus name.
func DBusIsUniqueName(_string string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_unique_name(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusUnescapeObjectPath unescapes an string that was previously escaped with
// g_dbus_escape_object_path(). If the string is in a format that could not have
// been returned by g_dbus_escape_object_path(), this function returns nil.
//
// Encoding alphanumeric characters which do not need to be encoded is not
// allowed (e.g `_63` is not valid, the string should contain `c` instead).
func DBusUnescapeObjectPath(s string) []byte {
	var _arg1 *C.gchar // out
	var _cret *C.guint8

	_arg1 = (*C.gchar)(C.CString(s))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_unescape_object_path(_arg1)

	var _guint8s []byte

	{
		var i int
		var z C.guint8
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = (byte)(src[i])
		}
	}

	return _guint8s
}

// IOErrorFromErrno converts errno.h error codes into GIO error codes. The
// fallback value G_IO_ERROR_FAILED is returned for error codes not currently
// handled (but note that future GLib releases may return a more specific value
// instead).
//
// As errno is global and may be modified by intermediate function calls, you
// should save its value as soon as the call which sets it
func IOErrorFromErrno(errNo int) IOErrorEnum {
	var _arg1 C.gint         // out
	var _cret C.GIOErrorEnum // in

	_arg1 = (C.gint)(errNo)

	_cret = C.g_io_error_from_errno(_arg1)

	var _ioErrorEnum IOErrorEnum // out

	_ioErrorEnum = IOErrorEnum(_cret)

	return _ioErrorEnum
}

// IOModulesScanAllInDirectory scans all the modules in the specified directory,
// ensuring that any extension point implemented by a module is registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectory(dirname string) {
	var _arg1 *C.char // out

	_arg1 = (*C.char)(C.CString(dirname))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_io_modules_scan_all_in_directory(_arg1)
}

// IOModulesScanAllInDirectoryWithScope scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope) {
	var _arg1 *C.gchar          // out
	var _arg2 *C.GIOModuleScope // out

	_arg1 = (*C.gchar)(C.CString(dirname))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GIOModuleScope)(unsafe.Pointer(scope.Native()))

	C.g_io_modules_scan_all_in_directory_with_scope(_arg1, _arg2)
}

// IOSchedulerCancelAllJobs cancels all cancellable I/O jobs.
//
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
func IOSchedulerCancelAllJobs() {
	C.g_io_scheduler_cancel_all_jobs()
}

// PollableStreamRead tries to read from @stream, as with g_input_stream_read()
// (if @blocking is true) or g_pollable_input_stream_read_nonblocking() (if
// @blocking is false). This can be used to more easily share code between
// blocking and non-blocking implementations of a method.
//
// If @blocking is false, then @stream must be a InputStream for which
// g_pollable_input_stream_can_poll() returns true, or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// InputStream.
func PollableStreamRead(stream InputStream, buffer []byte, blocking bool, cancellable Cancellable) (int, error) {
	var _arg1 *C.GInputStream // out
	var _arg2 *C.void
	var _arg3 C.gsize
	var _arg4 C.gboolean      // out
	var _arg5 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	_arg3 = C.gsize(len(buffer))
	_arg2 = (*C.void)(unsafe.Pointer(&buffer[0]))
	if blocking {
		_arg4 = C.TRUE
	}
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_pollable_stream_read(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

// PollableStreamWrite tries to write to @stream, as with
// g_output_stream_write() (if @blocking is true) or
// g_pollable_output_stream_write_nonblocking() (if @blocking is false). This
// can be used to more easily share code between blocking and non-blocking
// implementations of a method.
//
// If @blocking is false, then @stream must be a OutputStream for which
// g_pollable_output_stream_can_poll() returns true or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// OutputStream.
func PollableStreamWrite(stream OutputStream, buffer []byte, blocking bool, cancellable Cancellable) (int, error) {
	var _arg1 *C.GOutputStream // out
	var _arg2 *C.void
	var _arg3 C.gsize
	var _arg4 C.gboolean      // out
	var _arg5 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
	_arg3 = C.gsize(len(buffer))
	_arg2 = (*C.void)(unsafe.Pointer(&buffer[0]))
	if blocking {
		_arg4 = C.TRUE
	}
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_pollable_stream_write(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

// PollableStreamWriteAll tries to write @count bytes to @stream, as with
// g_output_stream_write_all(), but using g_pollable_stream_write() rather than
// g_output_stream_write().
//
// On a successful write of @count bytes, true is returned, and @bytes_written
// is set to @count.
//
// If there is an error during the operation (including G_IO_ERROR_WOULD_BLOCK
// in the non-blocking case), false is returned and @error is set to indicate
// the error status, @bytes_written is updated to contain the number of bytes
// written into the stream before the error occurred.
//
// As with g_pollable_stream_write(), if @blocking is false, then @stream must
// be a OutputStream for which g_pollable_output_stream_can_poll() returns true
// or else the behavior is undefined. If @blocking is true, then @stream does
// not need to be a OutputStream.
func PollableStreamWriteAll(stream OutputStream, buffer []byte, blocking bool, cancellable Cancellable) (uint, error) {
	var _arg1 *C.GOutputStream // out
	var _arg2 *C.void
	var _arg3 C.gsize
	var _arg4 C.gboolean      // out
	var _arg5 C.gsize         // in
	var _arg6 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
	_arg3 = C.gsize(len(buffer))
	_arg2 = (*C.void)(unsafe.Pointer(&buffer[0]))
	if blocking {
		_arg4 = C.TRUE
	}
	_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_pollable_stream_write_all(_arg1, _arg2, _arg3, _arg4, &_arg5, _arg6, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = (uint)(_arg5)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

// ResourcesEnumerateChildren returns all the names of children at the specified
// @path in the set of globally registered resources. The return result is a nil
// terminated list of strings which should be released with g_strfreev().
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret **C.char
	var _cerr *C.GError // in

	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GResourceLookupFlags)(lookupFlags)

	_cret = C.g_resources_enumerate_children(_arg1, _arg2, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

// ResourcesGetInfo looks for a file at the specified @path in the set of
// globally registered resources and if found returns information about it.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (uint, uint32, error) {
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _arg3 C.gsize                // in
	var _arg4 C.guint32              // in
	var _cerr *C.GError              // in

	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GResourceLookupFlags)(lookupFlags)

	C.g_resources_get_info(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _size uint    // out
	var _flags uint32 // out
	var _goerr error  // out

	_size = (uint)(_arg3)
	_flags = (uint32)(_arg4)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _size, _flags, _goerr
}

// ResourcesOpenStream looks for a file at the specified @path in the set of
// globally registered resources and returns a Stream that lets you read the
// data.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) (InputStream, error) {
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret *C.GInputStream        // in
	var _cerr *C.GError              // in

	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GResourceLookupFlags)(lookupFlags)

	_cret = C.g_resources_open_stream(_arg1, _arg2, &_cerr)

	var _inputStream InputStream // out
	var _goerr error             // out

	_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _inputStream, _goerr
}

// ResourcesRegister registers the resource with the process-global set of
// resources. Once a resource is registered the files in it can be accessed with
// the global resource lookup functions like g_resources_lookup_data().
func ResourcesRegister(resource *Resource) {
	var _arg1 *C.GResource // out

	_arg1 = (*C.GResource)(unsafe.Pointer(resource.Native()))

	C.g_resources_register(_arg1)
}

// ResourcesUnregister unregisters the resource from the process-global set of
// resources.
func ResourcesUnregister(resource *Resource) {
	var _arg1 *C.GResource // out

	_arg1 = (*C.GResource)(unsafe.Pointer(resource.Native()))

	C.g_resources_unregister(_arg1)
}

// UnixIsMountPathSystemInternal determines if @mount_path is considered an
// implementation of the OS. This is primarily used for hiding mountable and
// mounted volumes that only are used in the OS and has little to no relevance
// to the casual user.
func UnixIsMountPathSystemInternal(mountPath string) bool {
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(C.CString(mountPath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_unix_is_mount_path_system_internal(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnixIsSystemDevicePath determines if @device_path is considered a block
// device path which is only used in implementation of the OS. This is primarily
// used for hiding mounted volumes that are intended as APIs for programs to
// read, and system administrators at a shell; rather than something that
// should, for example, appear in a GUI. For example, the Linux `/proc`
// filesystem.
//
// The list of device paths considered system ones may change over time.
func UnixIsSystemDevicePath(devicePath string) bool {
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(C.CString(devicePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_unix_is_system_device_path(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnixIsSystemFSType determines if @fs_type is considered a type of file system
// which is only used in implementation of the OS. This is primarily used for
// hiding mounted volumes that are intended as APIs for programs to read, and
// system administrators at a shell; rather than something that should, for
// example, appear in a GUI. For example, the Linux `/proc` filesystem.
//
// The list of file system types considered system ones may change over time.
func UnixIsSystemFSType(fsType string) bool {
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(C.CString(fsType))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_unix_is_system_fs_type(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnixMountAt gets a MountEntry for a given mount path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountAt(mountPath string) (uint64, *UnixMountEntry) {
	var _arg1 *C.char            // out
	var _arg2 C.guint64          // in
	var _cret *C.GUnixMountEntry // in

	_arg1 = (*C.char)(C.CString(mountPath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_unix_mount_at(_arg1, &_arg2)

	var _timeRead uint64                // out
	var _unixMountEntry *UnixMountEntry // out

	_timeRead = (uint64)(_arg2)
	_unixMountEntry = WrapUnixMountEntry(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_unixMountEntry, func(v *UnixMountEntry) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _timeRead, _unixMountEntry
}

// UnixMountCompare compares two unix mounts.
func UnixMountCompare(mount1 *UnixMountEntry, mount2 *UnixMountEntry) int {
	var _arg1 *C.GUnixMountEntry // out
	var _arg2 *C.GUnixMountEntry // out
	var _cret C.gint             // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mount1.Native()))
	_arg2 = (*C.GUnixMountEntry)(unsafe.Pointer(mount2.Native()))

	_cret = C.g_unix_mount_compare(_arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnixMountCopy makes a copy of @mount_entry.
func UnixMountCopy(mountEntry *UnixMountEntry) *UnixMountEntry {
	var _arg1 *C.GUnixMountEntry // out
	var _cret *C.GUnixMountEntry // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_copy(_arg1)

	var _unixMountEntry *UnixMountEntry // out

	_unixMountEntry = WrapUnixMountEntry(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_unixMountEntry, func(v *UnixMountEntry) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _unixMountEntry
}

// UnixMountFor gets a MountEntry for a given file path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountFor(filePath string) (uint64, *UnixMountEntry) {
	var _arg1 *C.char            // out
	var _arg2 C.guint64          // in
	var _cret *C.GUnixMountEntry // in

	_arg1 = (*C.char)(C.CString(filePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_unix_mount_for(_arg1, &_arg2)

	var _timeRead uint64                // out
	var _unixMountEntry *UnixMountEntry // out

	_timeRead = (uint64)(_arg2)
	_unixMountEntry = WrapUnixMountEntry(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_unixMountEntry, func(v *UnixMountEntry) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _timeRead, _unixMountEntry
}

// UnixMountFree frees a unix mount.
func UnixMountFree(mountEntry *UnixMountEntry) {
	var _arg1 *C.GUnixMountEntry // out

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	C.g_unix_mount_free(_arg1)
}

// UnixMountGetDevicePath gets the device path for a unix mount.
func UnixMountGetDevicePath(mountEntry *UnixMountEntry) string {
	var _arg1 *C.GUnixMountEntry // out
	var _cret *C.char            // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_get_device_path(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// UnixMountGetFSType gets the filesystem type for the unix mount.
func UnixMountGetFSType(mountEntry *UnixMountEntry) string {
	var _arg1 *C.GUnixMountEntry // out
	var _cret *C.char            // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_get_fs_type(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UnixMountGetMountPath gets the mount path for a unix mount.
func UnixMountGetMountPath(mountEntry *UnixMountEntry) string {
	var _arg1 *C.GUnixMountEntry // out
	var _cret *C.char            // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_get_mount_path(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// UnixMountGetOptions gets a comma-separated list of mount options for the unix
// mount. For example, `rw,relatime,seclabel,data=ordered`.
//
// This is similar to g_unix_mount_point_get_options(), but it takes a
// MountEntry as an argument.
func UnixMountGetOptions(mountEntry *UnixMountEntry) string {
	var _arg1 *C.GUnixMountEntry // out
	var _cret *C.char            // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_get_options(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UnixMountGetRootPath gets the root of the mount within the filesystem. This
// is useful e.g. for mounts created by bind operation, or btrfs subvolumes.
//
// For example, the root path is equal to "/" for mount created by "mount
// /dev/sda1 /mnt/foo" and "/bar" for "mount --bind /mnt/foo/bar /mnt/bar".
func UnixMountGetRootPath(mountEntry *UnixMountEntry) string {
	var _arg1 *C.GUnixMountEntry // out
	var _cret *C.char            // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_get_root_path(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UnixMountGuessCanEject guesses whether a Unix mount can be ejected.
func UnixMountGuessCanEject(mountEntry *UnixMountEntry) bool {
	var _arg1 *C.GUnixMountEntry // out
	var _cret C.gboolean         // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_guess_can_eject(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnixMountGuessIcon guesses the icon of a Unix mount.
func UnixMountGuessIcon(mountEntry *UnixMountEntry) Icon {
	var _arg1 *C.GUnixMountEntry // out
	var _cret *C.GIcon           // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_guess_icon(_arg1)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

// UnixMountGuessName guesses the name of a Unix mount. The result is a
// translated string.
func UnixMountGuessName(mountEntry *UnixMountEntry) string {
	var _arg1 *C.GUnixMountEntry // out
	var _cret *C.char            // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_guess_name(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UnixMountGuessShouldDisplay guesses whether a Unix mount should be displayed
// in the UI.
func UnixMountGuessShouldDisplay(mountEntry *UnixMountEntry) bool {
	var _arg1 *C.GUnixMountEntry // out
	var _cret C.gboolean         // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_guess_should_display(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnixMountGuessSymbolicIcon guesses the symbolic icon of a Unix mount.
func UnixMountGuessSymbolicIcon(mountEntry *UnixMountEntry) Icon {
	var _arg1 *C.GUnixMountEntry // out
	var _cret *C.GIcon           // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_guess_symbolic_icon(_arg1)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

// UnixMountIsReadonly checks if a unix mount is mounted read only.
func UnixMountIsReadonly(mountEntry *UnixMountEntry) bool {
	var _arg1 *C.GUnixMountEntry // out
	var _cret C.gboolean         // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_is_readonly(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnixMountIsSystemInternal checks if a Unix mount is a system mount. This is
// the Boolean OR of g_unix_is_system_fs_type(), g_unix_is_system_device_path()
// and g_unix_is_mount_path_system_internal() on @mount_entrys properties.
//
// The definition of what a system mount entry is may change over time as new
// file system types and device paths are ignored.
func UnixMountIsSystemInternal(mountEntry *UnixMountEntry) bool {
	var _arg1 *C.GUnixMountEntry // out
	var _cret C.gboolean         // in

	_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

	_cret = C.g_unix_mount_is_system_internal(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnixMountPointsChangedSince checks if the unix mount points have changed
// since a given unix time.
func UnixMountPointsChangedSince(time uint64) bool {
	var _arg1 C.guint64  // out
	var _cret C.gboolean // in

	_arg1 = (C.guint64)(time)

	_cret = C.g_unix_mount_points_changed_since(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnixMountsChangedSince checks if the unix mounts have changed since a given
// unix time.
func UnixMountsChangedSince(time uint64) bool {
	var _arg1 C.guint64  // out
	var _cret C.gboolean // in

	_arg1 = (C.guint64)(time)

	_cret = C.g_unix_mounts_changed_since(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActionOverrider contains methods that are overridable. This
// interface is a subset of the interface Action.
type ActionOverrider interface {
	// Activate activates the action.
	//
	// @parameter must be the correct type of parameter for the action (ie: the
	// parameter type given at construction time). If the parameter type was nil
	// then @parameter must also be nil.
	//
	// If the @parameter GVariant is floating, it is consumed.
	Activate(parameter *glib.Variant)
	// ChangeState: request for the state of @action to be changed to @value.
	//
	// The action must be stateful and @value must be of the correct type. See
	// g_action_get_state_type().
	//
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_get_state_hint().
	//
	// If the @value GVariant is floating, it is consumed.
	ChangeState(value *glib.Variant)
	// Enabled checks if @action is currently enabled.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	Enabled() bool
	// Name queries the name of @action.
	Name() string
	// ParameterType queries the type of the parameter that must be given when
	// activating @action.
	//
	// When activating the action using g_action_activate(), the #GVariant given
	// to that function must be of the type returned by this function.
	//
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	ParameterType() *glib.VariantType
	// State queries the current state of @action.
	//
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_get_state_type().
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	State() *glib.Variant
	// StateHint requests a hint about the valid range of values for the state
	// of @action.
	//
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	//
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	//
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	StateHint() *glib.Variant
	// StateType queries the type of the state of @action.
	//
	// If the action is stateful (e.g. created with
	// g_simple_action_new_stateful()) then this function returns the Type of
	// the state. This is the type of the initial value given as the state. All
	// calls to g_action_change_state() must give a #GVariant of this type and
	// g_action_get_state() will return a #GVariant of the same type.
	//
	// If the action is not stateful (e.g. created with g_simple_action_new())
	// then this function will return nil. In that case, g_action_get_state()
	// will return nil and you must not call g_action_change_state().
	StateType() *glib.VariantType
}

// Action represents a single named action.
//
// The main interface to an action is that it can be activated with
// g_action_activate(). This results in the 'activate' signal being emitted. An
// activation has a #GVariant parameter (which may be nil). The correct type for
// the parameter is determined by a static parameter type (which is given at
// construction time).
//
// An action may optionally have a state, in which case the state may be set
// with g_action_change_state(). This call takes a #GVariant. The correct type
// for the state is determined by a static state type (which is given at
// construction time).
//
// The state may have a hint associated with it, specifying its valid range.
//
// #GAction is merely the interface to the concept of an action, as described
// above. Various implementations of actions exist, including Action.
//
// In all cases, the implementing class is responsible for storing the name of
// the action, the parameter type, the enabled state, the optional state type
// and the state and emitting the appropriate signals when these change. The
// implementor is responsible for filtering calls to g_action_activate() and
// g_action_change_state() for type safety and for the state being enabled.
//
// Probably the only useful thing to do with a #GAction is to put it inside of a
// ActionGroup.
type Action interface {
	gextras.Objector

	// Activate activates the action.
	//
	// @parameter must be the correct type of parameter for the action (ie: the
	// parameter type given at construction time). If the parameter type was nil
	// then @parameter must also be nil.
	//
	// If the @parameter GVariant is floating, it is consumed.
	Activate(parameter *glib.Variant)
	// ChangeState: request for the state of @action to be changed to @value.
	//
	// The action must be stateful and @value must be of the correct type. See
	// g_action_get_state_type().
	//
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_get_state_hint().
	//
	// If the @value GVariant is floating, it is consumed.
	ChangeState(value *glib.Variant)
	// Enabled checks if @action is currently enabled.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	Enabled() bool
	// Name queries the name of @action.
	Name() string
	// ParameterType queries the type of the parameter that must be given when
	// activating @action.
	//
	// When activating the action using g_action_activate(), the #GVariant given
	// to that function must be of the type returned by this function.
	//
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	ParameterType() *glib.VariantType
	// State queries the current state of @action.
	//
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_get_state_type().
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	State() *glib.Variant
	// StateHint requests a hint about the valid range of values for the state
	// of @action.
	//
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	//
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	//
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	StateHint() *glib.Variant
	// StateType queries the type of the state of @action.
	//
	// If the action is stateful (e.g. created with
	// g_simple_action_new_stateful()) then this function returns the Type of
	// the state. This is the type of the initial value given as the state. All
	// calls to g_action_change_state() must give a #GVariant of this type and
	// g_action_get_state() will return a #GVariant of the same type.
	//
	// If the action is not stateful (e.g. created with g_simple_action_new())
	// then this function will return nil. In that case, g_action_get_state()
	// will return nil and you must not call g_action_change_state().
	StateType() *glib.VariantType
}

// action implements the Action interface.
type action struct {
	gextras.Objector
}

var _ Action = (*action)(nil)

// WrapAction wraps a GObject to a type that implements interface
// Action. It is primarily used internally.
func WrapAction(obj *externglib.Object) Action {
	return action{
		Objector: obj,
	}
}

func marshalAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAction(obj), nil
}

func (a action) Activate(parameter *glib.Variant) {
	var _arg0 *C.GAction  // out
	var _arg1 *C.GVariant // out

	_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

	C.g_action_activate(_arg0, _arg1)
}

func (a action) ChangeState(value *glib.Variant) {
	var _arg0 *C.GAction  // out
	var _arg1 *C.GVariant // out

	_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_action_change_state(_arg0, _arg1)
}

func (a action) Enabled() bool {
	var _arg0 *C.GAction // out
	var _cret C.gboolean // in

	_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

	_cret = C.g_action_get_enabled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a action) Name() string {
	var _arg0 *C.GAction // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

	_cret = C.g_action_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a action) ParameterType() *glib.VariantType {
	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

	_cret = C.g_action_get_parameter_type(_arg0)

	var _variantType *glib.VariantType // out

	_variantType = glib.WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

func (a action) State() *glib.Variant {
	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

	_cret = C.g_action_get_state(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (a action) StateHint() *glib.Variant {
	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

	_cret = C.g_action_get_state_hint(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (a action) StateType() *glib.VariantType {
	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

	_cret = C.g_action_get_state_type(_arg0)

	var _variantType *glib.VariantType // out

	_variantType = glib.WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

// ActionGroupOverrider contains methods that are overridable. This
// interface is a subset of the interface ActionGroup.
type ActionGroupOverrider interface {
	// ActionAdded emits the Group::action-added signal on @action_group.
	//
	// This function should only be called by Group implementations.
	ActionAdded(actionName string)
	// ActionEnabledChanged emits the Group::action-enabled-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	ActionEnabledChanged(actionName string, enabled bool)
	// ActionRemoved emits the Group::action-removed signal on @action_group.
	//
	// This function should only be called by Group implementations.
	ActionRemoved(actionName string)
	// ActionStateChanged emits the Group::action-state-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	ActionStateChanged(actionName string, state *glib.Variant)
	// ActivateAction: activate the named action within @action_group.
	//
	// If the action is expecting a parameter, then the correct type of
	// parameter must be given as @parameter. If the action is expecting no
	// parameters then @parameter must be nil. See
	// g_action_group_get_action_parameter_type().
	//
	// If the Group implementation supports asynchronous remote activation over
	// D-Bus, this call may return before the relevant D-Bus traffic has been
	// sent, or any replies have been received. In order to block on such
	// asynchronous activation calls, g_dbus_connection_flush() should be called
	// prior to the code, which depends on the result of the action activation.
	// Without flushing the D-Bus connection, there is no guarantee that the
	// action would have been activated.
	//
	// The following code which runs in a remote app instance, shows an example
	// of a "quit" action being activated on the primary app instance over
	// D-Bus. Here g_dbus_connection_flush() is called before `exit()`. Without
	// g_dbus_connection_flush(), the "quit" action may fail to be activated on
	// the primary instance.
	//
	//    // call "quit" action on primary instance
	//    g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
	//
	//    // make sure the action is activated now
	//    g_dbus_connection_flush (...);
	//
	//    g_debug ("application has been terminated. exiting.");
	//
	//    exit (0);
	ActivateAction(actionName string, parameter *glib.Variant)
	// ChangeActionState: request for the state of the named action within
	// @action_group to be changed to @value.
	//
	// The action must be stateful and @value must be of the correct type. See
	// g_action_group_get_action_state_type().
	//
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_group_get_action_state_hint().
	//
	// If the @value GVariant is floating, it is consumed.
	ChangeActionState(actionName string, value *glib.Variant)
	// ActionEnabled checks if the named action within @action_group is
	// currently enabled.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	ActionEnabled(actionName string) bool
	// ActionParameterType queries the type of the parameter that must be given
	// when activating the named action within @action_group.
	//
	// When activating the action using g_action_group_activate_action(), the
	// #GVariant given to that function must be of the type returned by this
	// function.
	//
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	//
	// The parameter type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different parameter type.
	ActionParameterType(actionName string) *glib.VariantType
	// ActionState queries the current state of the named action within
	// @action_group.
	//
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_group_get_action_state_type().
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	ActionState(actionName string) *glib.Variant
	// ActionStateHint requests a hint about the valid range of values for the
	// state of the named action within @action_group.
	//
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	//
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	//
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	ActionStateHint(actionName string) *glib.Variant
	// ActionStateType queries the type of the state of the named action within
	// @action_group.
	//
	// If the action is stateful then this function returns the Type of the
	// state. All calls to g_action_group_change_action_state() must give a
	// #GVariant of this type and g_action_group_get_action_state() will return
	// a #GVariant of the same type.
	//
	// If the action is not stateful then this function will return nil. In that
	// case, g_action_group_get_action_state() will return nil and you must not
	// call g_action_group_change_action_state().
	//
	// The state type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different state type.
	ActionStateType(actionName string) *glib.VariantType
	// HasAction checks if the named action exists within @action_group.
	HasAction(actionName string) bool
	// ListActions lists the actions contained within @action_group.
	//
	// The caller is responsible for freeing the list with g_strfreev() when it
	// is no longer required.
	ListActions() []string
	// QueryAction queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool)
}

// ActionGroup represents a group of actions. Actions can be used to expose
// functionality in a structured way, either from one part of a program to
// another, or to the outside world. Action groups are often used together with
// a Model that provides additional representation data for displaying the
// actions to the user, e.g. in a menu.
//
// The main way to interact with the actions in a GActionGroup is to activate
// them with g_action_group_activate_action(). Activating an action may require
// a #GVariant parameter. The required type of the parameter can be inquired
// with g_action_group_get_action_parameter_type(). Actions may be disabled, see
// g_action_group_get_action_enabled(). Activating a disabled action has no
// effect.
//
// Actions may optionally have a state in the form of a #GVariant. The current
// state of an action can be inquired with g_action_group_get_action_state().
// Activating a stateful action may change its state, but it is also possible to
// set the state by calling g_action_group_change_action_state().
//
// As typical example, consider a text editing application which has an option
// to change the current font to 'bold'. A good way to represent this would be a
// stateful action, with a boolean state. Activating the action would toggle the
// state.
//
// Each action in the group has a unique name (which is a string). All method
// calls, except g_action_group_list_actions() take the name of an action as an
// argument.
//
// The Group API is meant to be the 'public' API to the action group. The calls
// here are exactly the interaction that 'external forces' (eg: UI, incoming
// D-Bus messages, etc.) are supposed to have with actions. 'Internal' APIs (ie:
// ones meant only to be accessed by the action group implementation) are found
// on subclasses. This is why you will find - for example -
// g_action_group_get_action_enabled() but not an equivalent set() call.
//
// Signals are emitted on the action group in response to state changes on
// individual actions.
//
// Implementations of Group should provide implementations for the virtual
// functions g_action_group_list_actions() and g_action_group_query_action().
// The other virtual functions should not be implemented - their "wrappers" are
// actually implemented with calls to g_action_group_query_action().
type ActionGroup interface {
	gextras.Objector

	// ActionAdded emits the Group::action-added signal on @action_group.
	//
	// This function should only be called by Group implementations.
	ActionAdded(actionName string)
	// ActionEnabledChanged emits the Group::action-enabled-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	ActionEnabledChanged(actionName string, enabled bool)
	// ActionRemoved emits the Group::action-removed signal on @action_group.
	//
	// This function should only be called by Group implementations.
	ActionRemoved(actionName string)
	// ActionStateChanged emits the Group::action-state-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	ActionStateChanged(actionName string, state *glib.Variant)
	// ActivateAction: activate the named action within @action_group.
	//
	// If the action is expecting a parameter, then the correct type of
	// parameter must be given as @parameter. If the action is expecting no
	// parameters then @parameter must be nil. See
	// g_action_group_get_action_parameter_type().
	//
	// If the Group implementation supports asynchronous remote activation over
	// D-Bus, this call may return before the relevant D-Bus traffic has been
	// sent, or any replies have been received. In order to block on such
	// asynchronous activation calls, g_dbus_connection_flush() should be called
	// prior to the code, which depends on the result of the action activation.
	// Without flushing the D-Bus connection, there is no guarantee that the
	// action would have been activated.
	//
	// The following code which runs in a remote app instance, shows an example
	// of a "quit" action being activated on the primary app instance over
	// D-Bus. Here g_dbus_connection_flush() is called before `exit()`. Without
	// g_dbus_connection_flush(), the "quit" action may fail to be activated on
	// the primary instance.
	//
	//    // call "quit" action on primary instance
	//    g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
	//
	//    // make sure the action is activated now
	//    g_dbus_connection_flush (...);
	//
	//    g_debug ("application has been terminated. exiting.");
	//
	//    exit (0);
	ActivateAction(actionName string, parameter *glib.Variant)
	// ChangeActionState: request for the state of the named action within
	// @action_group to be changed to @value.
	//
	// The action must be stateful and @value must be of the correct type. See
	// g_action_group_get_action_state_type().
	//
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_group_get_action_state_hint().
	//
	// If the @value GVariant is floating, it is consumed.
	ChangeActionState(actionName string, value *glib.Variant)
	// ActionEnabled checks if the named action within @action_group is
	// currently enabled.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	ActionEnabled(actionName string) bool
	// ActionParameterType queries the type of the parameter that must be given
	// when activating the named action within @action_group.
	//
	// When activating the action using g_action_group_activate_action(), the
	// #GVariant given to that function must be of the type returned by this
	// function.
	//
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	//
	// The parameter type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different parameter type.
	ActionParameterType(actionName string) *glib.VariantType
	// ActionState queries the current state of the named action within
	// @action_group.
	//
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_group_get_action_state_type().
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	ActionState(actionName string) *glib.Variant
	// ActionStateHint requests a hint about the valid range of values for the
	// state of the named action within @action_group.
	//
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	//
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	//
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	ActionStateHint(actionName string) *glib.Variant
	// ActionStateType queries the type of the state of the named action within
	// @action_group.
	//
	// If the action is stateful then this function returns the Type of the
	// state. All calls to g_action_group_change_action_state() must give a
	// #GVariant of this type and g_action_group_get_action_state() will return
	// a #GVariant of the same type.
	//
	// If the action is not stateful then this function will return nil. In that
	// case, g_action_group_get_action_state() will return nil and you must not
	// call g_action_group_change_action_state().
	//
	// The state type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different state type.
	ActionStateType(actionName string) *glib.VariantType
	// HasAction checks if the named action exists within @action_group.
	HasAction(actionName string) bool
	// ListActions lists the actions contained within @action_group.
	//
	// The caller is responsible for freeing the list with g_strfreev() when it
	// is no longer required.
	ListActions() []string
	// QueryAction queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool)
}

// actionGroup implements the ActionGroup interface.
type actionGroup struct {
	gextras.Objector
}

var _ ActionGroup = (*actionGroup)(nil)

// WrapActionGroup wraps a GObject to a type that implements interface
// ActionGroup. It is primarily used internally.
func WrapActionGroup(obj *externglib.Object) ActionGroup {
	return actionGroup{
		Objector: obj,
	}
}

func marshalActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionGroup(obj), nil
}

func (a actionGroup) ActionAdded(actionName string) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_action_group_action_added(_arg0, _arg1)
}

func (a actionGroup) ActionEnabledChanged(actionName string, enabled bool) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	if enabled {
		_arg2 = C.TRUE
	}

	C.g_action_group_action_enabled_changed(_arg0, _arg1, _arg2)
}

func (a actionGroup) ActionRemoved(actionName string) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_action_group_action_removed(_arg0, _arg1)
}

func (a actionGroup) ActionStateChanged(actionName string, state *glib.Variant) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(state.Native()))

	C.g_action_group_action_state_changed(_arg0, _arg1, _arg2)
}

func (a actionGroup) ActivateAction(actionName string, parameter *glib.Variant) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

	C.g_action_group_activate_action(_arg0, _arg1, _arg2)
}

func (a actionGroup) ChangeActionState(actionName string, value *glib.Variant) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_action_group_change_action_state(_arg0, _arg1, _arg2)
}

func (a actionGroup) ActionEnabled(actionName string) bool {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_enabled(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a actionGroup) ActionParameterType(actionName string) *glib.VariantType {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_parameter_type(_arg0, _arg1)

	var _variantType *glib.VariantType // out

	_variantType = glib.WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

func (a actionGroup) ActionState(actionName string) *glib.Variant {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_state(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (a actionGroup) ActionStateHint(actionName string) *glib.Variant {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_state_hint(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (a actionGroup) ActionStateType(actionName string) *glib.VariantType {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_state_type(_arg0, _arg1)

	var _variantType *glib.VariantType // out

	_variantType = glib.WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

func (a actionGroup) HasAction(actionName string) bool {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_has_action(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a actionGroup) ListActions() []string {
	var _arg0 *C.GActionGroup // out
	var _cret **C.gchar

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))

	_cret = C.g_action_group_list_actions(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (a actionGroup) QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // in
	var _parameterType *glib.VariantType
	var _stateType *glib.VariantType
	var _stateHint *glib.Variant
	var _state *glib.Variant
	var _cret C.gboolean // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_query_action(_arg0, _arg1, &_arg2, (**C.GVariantType)(unsafe.Pointer(&_parameterType)), (**C.GVariantType)(unsafe.Pointer(&_stateType)), (**C.GVariant)(unsafe.Pointer(&_stateHint)), (**C.GVariant)(unsafe.Pointer(&_state)))

	var _enabled bool // out

	var _ok bool // out

	if _arg2 {
		_enabled = true
	}

	if _cret != 0 {
		_ok = true
	}

	return _enabled, _parameterType, _stateType, _stateHint, _state, _ok
}

// ActionMapOverrider contains methods that are overridable. This
// interface is a subset of the interface ActionMap.
type ActionMapOverrider interface {
	// AddAction adds an action to the @action_map.
	//
	// If the action map already contains an action with the same name as
	// @action then the old action is dropped from the action map.
	//
	// The action map takes its own reference on @action.
	AddAction(action Action)
	// LookupAction looks up the action with the name @action_name in
	// @action_map.
	//
	// If no such action exists, returns nil.
	LookupAction(actionName string) Action
	// RemoveAction removes the named action from the action map.
	//
	// If no action of this name is in the map then nothing happens.
	RemoveAction(actionName string)
}

// ActionMap: the GActionMap interface is implemented by Group implementations
// that operate by containing a number of named #GAction instances, such as
// ActionGroup.
//
// One useful application of this interface is to map the names of actions from
// various action groups to unique, prefixed names (e.g. by prepending "app." or
// "win."). This is the motivation for the 'Map' part of the interface name.
type ActionMap interface {
	gextras.Objector

	// AddAction adds an action to the @action_map.
	//
	// If the action map already contains an action with the same name as
	// @action then the old action is dropped from the action map.
	//
	// The action map takes its own reference on @action.
	AddAction(action Action)
	// LookupAction looks up the action with the name @action_name in
	// @action_map.
	//
	// If no such action exists, returns nil.
	LookupAction(actionName string) Action
	// RemoveAction removes the named action from the action map.
	//
	// If no action of this name is in the map then nothing happens.
	RemoveAction(actionName string)
}

// actionMap implements the ActionMap interface.
type actionMap struct {
	gextras.Objector
}

var _ ActionMap = (*actionMap)(nil)

// WrapActionMap wraps a GObject to a type that implements interface
// ActionMap. It is primarily used internally.
func WrapActionMap(obj *externglib.Object) ActionMap {
	return actionMap{
		Objector: obj,
	}
}

func marshalActionMap(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionMap(obj), nil
}

func (a actionMap) AddAction(action Action) {
	var _arg0 *C.GActionMap // out
	var _arg1 *C.GAction    // out

	_arg0 = (*C.GActionMap)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GAction)(unsafe.Pointer(action.Native()))

	C.g_action_map_add_action(_arg0, _arg1)
}

func (a actionMap) LookupAction(actionName string) Action {
	var _arg0 *C.GActionMap // out
	var _arg1 *C.gchar      // out
	var _cret *C.GAction    // in

	_arg0 = (*C.GActionMap)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_map_lookup_action(_arg0, _arg1)

	var _action Action // out

	_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

	return _action
}

func (a actionMap) RemoveAction(actionName string) {
	var _arg0 *C.GActionMap // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GActionMap)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_action_map_remove_action(_arg0, _arg1)
}

// AppInfoOverrider contains methods that are overridable. This
// interface is a subset of the interface AppInfo.
type AppInfoOverrider interface {
	// AddSupportsType adds a content type to the application information to
	// indicate the application is capable of opening files with the given
	// content type.
	AddSupportsType(contentType string) error
	// CanDelete obtains the information whether the Info can be deleted. See
	// g_app_info_delete().
	CanDelete() bool
	// CanRemoveSupportsType checks if a supported content type can be removed
	// from an application.
	CanRemoveSupportsType() bool
	// DoDelete tries to delete a Info.
	//
	// On some platforms, there may be a difference between user-defined Infos
	// which can be deleted, and system-wide ones which cannot. See
	// g_app_info_can_delete().
	DoDelete() bool
	// Dup creates a duplicate of a Info.
	Dup() AppInfo
	// Equal checks if two Infos are equal.
	//
	// Note that the check *may not* compare each individual field, and only
	// does an identity check. In case detecting changes in the contents is
	// needed, program code must additionally compare relevant fields.
	Equal(appinfo2 AppInfo) bool
	// Commandline gets the commandline with which the application will be
	// started.
	Commandline() string
	// Description gets a human-readable description of an installed
	// application.
	Description() string
	// DisplayName gets the display name of the application. The display name is
	// often more descriptive to the user than the name itself.
	DisplayName() string
	// Executable gets the executable's name for the installed application.
	Executable() string
	// Icon gets the icon for the application.
	Icon() Icon
	// ID gets the ID of an application. An id is a string that identifies the
	// application. The exact format of the id is platform dependent. For
	// instance, on Unix this is the desktop file id from the xdg menu
	// specification.
	//
	// Note that the returned ID may be nil, depending on how the @appinfo has
	// been constructed.
	ID() string
	// Name gets the installed name of the application.
	Name() string
	// SupportedTypes retrieves the list of content types that @app_info claims
	// to support. If this information is not provided by the environment, this
	// function will return nil. This function does not take in consideration
	// associations added with g_app_info_add_supports_type(), but only those
	// exported directly by the application.
	SupportedTypes() []string
	// LaunchUrisFinish finishes a g_app_info_launch_uris_async() operation.
	LaunchUrisFinish(result AsyncResult) error
	// RemoveSupportsType removes a supported type from an application, if
	// possible.
	RemoveSupportsType(contentType string) error
	// SetAsDefaultForExtension sets the application as the default handler for
	// the given file extension.
	SetAsDefaultForExtension(extension string) error
	// SetAsDefaultForType sets the application as the default handler for a
	// given type.
	SetAsDefaultForType(contentType string) error
	// SetAsLastUsedForType sets the application as the last used application
	// for a given type. This will make the application appear as first in the
	// list returned by g_app_info_get_recommended_for_type(), regardless of the
	// default application for that content type.
	SetAsLastUsedForType(contentType string) error
	// ShouldShow checks if the application info should be shown in menus that
	// list available applications.
	ShouldShow() bool
	// SupportsFiles checks if the application accepts files as arguments.
	SupportsFiles() bool
	// SupportsUris checks if the application supports reading files and
	// directories from URIs.
	SupportsUris() bool
}

// AppInfo: Info and LaunchContext are used for describing and launching
// applications installed on the system.
//
// As of GLib 2.20, URIs will always be converted to POSIX paths (using
// g_file_get_path()) when using g_app_info_launch() even if the application
// requested an URI and not a POSIX path. For example for a desktop-file based
// application with Exec key `totem U` and a single URI, `sftp://foo/file.avi`,
// then `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only
// work if a set of suitable GIO extensions (such as gvfs 2.26 compiled with
// FUSE support), is available and operational; if this is not the case, the URI
// will be passed unmodified to the application. Some URIs, such as `mailto:`,
// of course cannot be mapped to a POSIX path (in gvfs there's no FUSE mount for
// it); such URIs will be passed unmodified to the application.
//
// Specifically for gvfs 2.26 and later, the POSIX URI will be mapped back to
// the GIO URI in the #GFile constructors (since gvfs implements the #GVfs
// extension point). As such, if the application needs to examine the URI, it
// needs to use g_file_get_uri() or similar on #GFile. In other words, an
// application cannot assume that the URI passed to e.g.
// g_file_new_for_commandline_arg() is equal to the result of g_file_get_uri().
// The following snippet illustrates this:
//
//    GFile *f;
//    char *uri;
//
//    file = g_file_new_for_commandline_arg (uri_from_commandline);
//
//    uri = g_file_get_uri (file);
//    strcmp (uri, uri_from_commandline) == 0;
//    g_free (uri);
//
//    if (g_file_has_uri_scheme (file, "cdda"))
//      {
//        // do something special with uri
//      }
//    g_object_unref (file);
//
// This code will work when both `cdda://sr0/Track 1.wav` and
// `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the application. It
// should be noted that it's generally not safe for applications to rely on the
// format of a particular URIs. Different launcher applications (e.g. file
// managers) may have different ideas of what a given URI means.
type AppInfo interface {
	gextras.Objector

	// AddSupportsType adds a content type to the application information to
	// indicate the application is capable of opening files with the given
	// content type.
	AddSupportsType(contentType string) error
	// CanDelete obtains the information whether the Info can be deleted. See
	// g_app_info_delete().
	CanDelete() bool
	// CanRemoveSupportsType checks if a supported content type can be removed
	// from an application.
	CanRemoveSupportsType() bool
	// Delete tries to delete a Info.
	//
	// On some platforms, there may be a difference between user-defined Infos
	// which can be deleted, and system-wide ones which cannot. See
	// g_app_info_can_delete().
	Delete() bool
	// Dup creates a duplicate of a Info.
	Dup() AppInfo
	// Equal checks if two Infos are equal.
	//
	// Note that the check *may not* compare each individual field, and only
	// does an identity check. In case detecting changes in the contents is
	// needed, program code must additionally compare relevant fields.
	Equal(appinfo2 AppInfo) bool
	// Commandline gets the commandline with which the application will be
	// started.
	Commandline() string
	// Description gets a human-readable description of an installed
	// application.
	Description() string
	// DisplayName gets the display name of the application. The display name is
	// often more descriptive to the user than the name itself.
	DisplayName() string
	// Executable gets the executable's name for the installed application.
	Executable() string
	// Icon gets the icon for the application.
	Icon() Icon
	// ID gets the ID of an application. An id is a string that identifies the
	// application. The exact format of the id is platform dependent. For
	// instance, on Unix this is the desktop file id from the xdg menu
	// specification.
	//
	// Note that the returned ID may be nil, depending on how the @appinfo has
	// been constructed.
	ID() string
	// Name gets the installed name of the application.
	Name() string
	// SupportedTypes retrieves the list of content types that @app_info claims
	// to support. If this information is not provided by the environment, this
	// function will return nil. This function does not take in consideration
	// associations added with g_app_info_add_supports_type(), but only those
	// exported directly by the application.
	SupportedTypes() []string
	// LaunchUrisFinish finishes a g_app_info_launch_uris_async() operation.
	LaunchUrisFinish(result AsyncResult) error
	// RemoveSupportsType removes a supported type from an application, if
	// possible.
	RemoveSupportsType(contentType string) error
	// SetAsDefaultForExtension sets the application as the default handler for
	// the given file extension.
	SetAsDefaultForExtension(extension string) error
	// SetAsDefaultForType sets the application as the default handler for a
	// given type.
	SetAsDefaultForType(contentType string) error
	// SetAsLastUsedForType sets the application as the last used application
	// for a given type. This will make the application appear as first in the
	// list returned by g_app_info_get_recommended_for_type(), regardless of the
	// default application for that content type.
	SetAsLastUsedForType(contentType string) error
	// ShouldShow checks if the application info should be shown in menus that
	// list available applications.
	ShouldShow() bool
	// SupportsFiles checks if the application accepts files as arguments.
	SupportsFiles() bool
	// SupportsUris checks if the application supports reading files and
	// directories from URIs.
	SupportsUris() bool
}

// appInfo implements the AppInfo interface.
type appInfo struct {
	gextras.Objector
}

var _ AppInfo = (*appInfo)(nil)

// WrapAppInfo wraps a GObject to a type that implements interface
// AppInfo. It is primarily used internally.
func WrapAppInfo(obj *externglib.Object) AppInfo {
	return appInfo{
		Objector: obj,
	}
}

func marshalAppInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppInfo(obj), nil
}

func (a appInfo) AddSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_add_supports_type(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) CanDelete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_can_delete(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) CanRemoveSupportsType() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_can_remove_supports_type(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) Delete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_delete(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) Dup() AppInfo {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GAppInfo // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_dup(_arg0)

	var _appInfo AppInfo // out

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppInfo)

	return _appInfo
}

func (a appInfo) Equal(appinfo2 AppInfo) bool {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(appinfo2.Native()))

	_cret = C.g_app_info_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) Commandline() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_commandline(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (a appInfo) Description() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a appInfo) DisplayName() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a appInfo) Executable() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_executable(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (a appInfo) Icon() Icon {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GIcon    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (a appInfo) ID() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a appInfo) Name() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a appInfo) SupportedTypes() []string {
	var _arg0 *C.GAppInfo // out
	var _cret **C.char

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_supported_types(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (a appInfo) LaunchUrisFinish(result AsyncResult) error {
	var _arg0 *C.GAppInfo     // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_app_info_launch_uris_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) RemoveSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_remove_supports_type(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) SetAsDefaultForExtension(extension string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(extension))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_extension(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) SetAsDefaultForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_type(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) SetAsLastUsedForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_last_used_for_type(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) ShouldShow() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_should_show(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) SupportsFiles() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_supports_files(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) SupportsUris() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_supports_uris(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AsyncInitableOverrider contains methods that are overridable. This
// interface is a subset of the interface AsyncInitable.
type AsyncInitableOverrider interface {
	// InitFinish finishes asynchronous initialization and returns the result.
	// See g_async_initable_init_async().
	InitFinish(res AsyncResult) error
}

// AsyncInitable: this is the asynchronous version of #GInitable; it behaves the
// same in all ways except that initialization is asynchronous. For more details
// see the descriptions on #GInitable.
//
// A class may implement both the #GInitable and Initable interfaces.
//
// Users of objects implementing this are not intended to use the interface
// method directly; instead it will be used automatically in various ways. For C
// applications you generally just call g_async_initable_new_async() directly,
// or indirectly via a foo_thing_new_async() wrapper. This will call
// g_async_initable_init_async() under the cover, calling back with nil and a
// set GError on failure.
//
// A typical implementation might look something like this:
//
//    enum {
//       NOT_INITIALIZED,
//       INITIALIZING,
//       INITIALIZED
//    };
//
//    static void
//    _foo_ready_cb (Foo *self)
//    {
//      GList *l;
//
//      self->priv->state = INITIALIZED;
//
//      for (l = self->priv->init_results; l != NULL; l = l->next)
//        {
//          GTask *task = l->data;
//
//          if (self->priv->success)
//            g_task_return_boolean (task, TRUE);
//          else
//            g_task_return_new_error (task, ...);
//          g_object_unref (task);
//        }
//
//      g_list_free (self->priv->init_results);
//      self->priv->init_results = NULL;
//    }
//
//    static void
//    foo_init_async (GAsyncInitable       *initable,
//                    int                   io_priority,
//                    GCancellable         *cancellable,
//                    GAsyncReadyCallback   callback,
//                    gpointer              user_data)
//    {
//      Foo *self = FOO (initable);
//      GTask *task;
//
//      task = g_task_new (initable, cancellable, callback, user_data);
//      g_task_set_name (task, G_STRFUNC);
//
//      switch (self->priv->state)
//        {
//          case NOT_INITIALIZED:
//            _foo_get_ready (self);
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            self->priv->state = INITIALIZING;
//            break;
//          case INITIALIZING:
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            break;
//          case INITIALIZED:
//            if (!self->priv->success)
//              g_task_return_new_error (task, ...);
//            else
//              g_task_return_boolean (task, TRUE);
//            g_object_unref (task);
//            break;
//        }
//    }
//
//    static gboolean
//    foo_init_finish (GAsyncInitable       *initable,
//                     GAsyncResult         *result,
//                     GError              **error)
//    {
//      g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
//
//      return g_task_propagate_boolean (G_TASK (result), error);
//    }
//
//    static void
//    foo_async_initable_iface_init (gpointer g_iface,
//                                   gpointer data)
//    {
//      GAsyncInitableIface *iface = g_iface;
//
//      iface->init_async = foo_init_async;
//      iface->init_finish = foo_init_finish;
//    }
type AsyncInitable interface {
	gextras.Objector

	// InitFinish finishes asynchronous initialization and returns the result.
	// See g_async_initable_init_async().
	InitFinish(res AsyncResult) error
	// NewFinish finishes the async construction for the various
	// g_async_initable_new calls, returning the created object or nil on error.
	NewFinish(res AsyncResult) (gextras.Objector, error)
}

// asyncInitable implements the AsyncInitable interface.
type asyncInitable struct {
	gextras.Objector
}

var _ AsyncInitable = (*asyncInitable)(nil)

// WrapAsyncInitable wraps a GObject to a type that implements interface
// AsyncInitable. It is primarily used internally.
func WrapAsyncInitable(obj *externglib.Object) AsyncInitable {
	return asyncInitable{
		Objector: obj,
	}
}

func marshalAsyncInitable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAsyncInitable(obj), nil
}

func (i asyncInitable) InitFinish(res AsyncResult) error {
	var _arg0 *C.GAsyncInitable // out
	var _arg1 *C.GAsyncResult   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GAsyncInitable)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_async_initable_init_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (i asyncInitable) NewFinish(res AsyncResult) (gextras.Objector, error) {
	var _arg0 *C.GAsyncInitable // out
	var _arg1 *C.GAsyncResult   // out
	var _cret *C.GObject        // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GAsyncInitable)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_async_initable_new_finish(_arg0, _arg1, &_cerr)

	var _object gextras.Objector // out
	var _goerr error             // out

	_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gextras.Objector)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _object, _goerr
}

// AsyncResultOverrider contains methods that are overridable. This
// interface is a subset of the interface AsyncResult.
type AsyncResultOverrider interface {
	// SourceObject gets the source object from a Result.
	SourceObject() gextras.Objector
}

// AsyncResult provides a base class for implementing asynchronous function
// results.
//
// Asynchronous operations are broken up into two separate operations which are
// chained together by a ReadyCallback. To begin an asynchronous operation,
// provide a ReadyCallback to the asynchronous function. This callback will be
// triggered when the operation has completed, and must be run in a later
// iteration of the [thread-default main
// context][g-main-context-push-thread-default] from where the operation was
// initiated. It will be passed a Result instance filled with the details of the
// operation's success or failure, the object the asynchronous function was
// started for and any error codes returned. The asynchronous callback function
// is then expected to call the corresponding "_finish()" function, passing the
// object the function was called for, the Result instance, and (optionally) an
// @error to grab any error conditions that may have occurred.
//
// The "_finish()" function for an operation takes the generic result (of type
// Result) and returns the specific result that the operation in question yields
// (e.g. a Enumerator for a "enumerate children" operation). If the result or
// error status of the operation is not needed, there is no need to call the
// "_finish()" function; GIO will take care of cleaning up the result and error
// information after the ReadyCallback returns. You can pass nil for the
// ReadyCallback if you don't need to take any action at all after the operation
// completes. Applications may also take a reference to the Result and call
// "_finish()" later; however, the "_finish()" function may be called at most
// once.
//
// Example of a typical asynchronous operation flow:
//
//    void _theoretical_frobnitz_async (Theoretical         *t,
//                                      GCancellable        *c,
//                                      GAsyncReadyCallback  cb,
//                                      gpointer             u);
//
//    gboolean _theoretical_frobnitz_finish (Theoretical   *t,
//                                           GAsyncResult  *res,
//                                           GError       **e);
//
//    static void
//    frobnitz_result_func (GObject      *source_object,
//    		 GAsyncResult *res,
//    		 gpointer      user_data)
//    {
//      gboolean success = FALSE;
//
//      success = _theoretical_frobnitz_finish (source_object, res, NULL);
//
//      if (success)
//        g_printf ("Hurray!\n");
//      else
//        g_printf ("Uh oh!\n");
//
//      ...
//
//    }
//
//    int main (int argc, void *argv[])
//    {
//       ...
//
//       _theoretical_frobnitz_async (theoretical_data,
//                                    NULL,
//                                    frobnitz_result_func,
//                                    NULL);
//
//       ...
//    }
//
// The callback for an asynchronous operation is called only once, and is always
// called, even in the case of a cancelled operation. On cancellation the result
// is a G_IO_ERROR_CANCELLED error.
//
// I/O Priority
//
// Many I/O-related asynchronous operations have a priority parameter, which is
// used in certain cases to determine the order in which operations are
// executed. They are not used to determine system-wide I/O scheduling.
// Priorities are integers, with lower numbers indicating higher priority. It is
// recommended to choose priorities between G_PRIORITY_LOW and G_PRIORITY_HIGH,
// with G_PRIORITY_DEFAULT as a default.
type AsyncResult interface {
	gextras.Objector

	// SourceObject gets the source object from a Result.
	SourceObject() gextras.Objector
	// LegacyPropagateError: if @res is a AsyncResult, this is equivalent to
	// g_simple_async_result_propagate_error(). Otherwise it returns false.
	//
	// This can be used for legacy error handling in async *_finish() wrapper
	// functions that traditionally handled AsyncResult error returns themselves
	// rather than calling into the virtual method. This should not be used in
	// new code; Result errors that are set by virtual methods should also be
	// extracted by virtual methods, to enable subclasses to chain up correctly.
	LegacyPropagateError() error
}

// asyncResult implements the AsyncResult interface.
type asyncResult struct {
	gextras.Objector
}

var _ AsyncResult = (*asyncResult)(nil)

// WrapAsyncResult wraps a GObject to a type that implements interface
// AsyncResult. It is primarily used internally.
func WrapAsyncResult(obj *externglib.Object) AsyncResult {
	return asyncResult{
		Objector: obj,
	}
}

func marshalAsyncResult(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAsyncResult(obj), nil
}

func (r asyncResult) SourceObject() gextras.Objector {
	var _arg0 *C.GAsyncResult // out
	var _cret *C.GObject      // in

	_arg0 = (*C.GAsyncResult)(unsafe.Pointer(r.Native()))

	_cret = C.g_async_result_get_source_object(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (r asyncResult) LegacyPropagateError() error {
	var _arg0 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GAsyncResult)(unsafe.Pointer(r.Native()))

	C.g_async_result_legacy_propagate_error(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ConverterOverrider contains methods that are overridable. This
// interface is a subset of the interface Converter.
type ConverterOverrider interface {
	// Convert: this is the main operation used when converting data. It is to
	// be called multiple times in a loop, and each time it will do some work,
	// i.e. producing some output (in @outbuf) or consuming some input (from
	// @inbuf) or both. If its not possible to do any work an error is returned.
	//
	// Note that a single call may not consume all input (or any input at all).
	// Also a call may produce output even if given no input, due to state
	// stored in the converter producing output.
	//
	// If any data was either produced or consumed, and then an error happens,
	// then only the successful conversion is reported and the error is returned
	// on the next call.
	//
	// A full conversion loop involves calling this method repeatedly, each time
	// giving it new input and space output space. When there is no more input
	// data after the data in @inbuf, the flag G_CONVERTER_INPUT_AT_END must be
	// set. The loop will be (unless some error happens) returning
	// G_CONVERTER_CONVERTED each time until all data is consumed and all output
	// is produced, then G_CONVERTER_FINISHED is returned instead. Note, that
	// G_CONVERTER_FINISHED may be returned even if G_CONVERTER_INPUT_AT_END is
	// not set, for instance in a decompression converter where the end of data
	// is detectable from the data (and there might even be other data after the
	// end of the compressed data).
	//
	// When some data has successfully been converted @bytes_read and is set to
	// the number of bytes read from @inbuf, and @bytes_written is set to
	// indicate how many bytes was written to @outbuf. If there are more data to
	// output or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified)
	// then G_CONVERTER_CONVERTED is returned, and if no more data is to be
	// output then G_CONVERTER_FINISHED is returned.
	//
	// On error G_CONVERTER_ERROR is returned and @error is set accordingly.
	// Some errors need special handling:
	//
	// G_IO_ERROR_NO_SPACE is returned if there is not enough space to write the
	// resulting converted data, the application should call the function again
	// with a larger @outbuf to continue.
	//
	// G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough input to
	// fully determine what the conversion should produce, and the
	// G_CONVERTER_INPUT_AT_END flag is not set. This happens for example with
	// an incomplete multibyte sequence when converting text, or when a regexp
	// matches up to the end of the input (and may match further input). It may
	// also happen when @inbuf_size is zero and there is no more data to
	// produce.
	//
	// When this happens the application should read more input and then call
	// the function again. If further input shows that there is no more data
	// call the function again with the same data but with the
	// G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion to
	// finish as e.g. in the regexp match case (or, to fail again with
	// G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the input is
	// actually partial).
	//
	// After g_converter_convert() has returned G_CONVERTER_FINISHED the
	// converter object is in an invalid state where its not allowed to call
	// g_converter_convert() anymore. At this time you can only free the object
	// or call g_converter_reset() to reset it to the initial state.
	//
	// If the flag G_CONVERTER_FLUSH is set then conversion is modified to try
	// to write out all internal state to the output. The application has to
	// call the function multiple times with the flag set, and when the
	// available input has been consumed and all internal state has been
	// produced then G_CONVERTER_FLUSHED (or G_CONVERTER_FINISHED if really at
	// the end) is returned instead of G_CONVERTER_CONVERTED. This is somewhat
	// similar to what happens at the end of the input stream, but done in the
	// middle of the data.
	//
	// This has different meanings for different conversions. For instance in a
	// compression converter it would mean that we flush all the compression
	// state into output such that if you uncompress the compressed data you get
	// back all the input data. Doing this may make the final file larger due to
	// padding though. Another example is a regexp conversion, where if you at
	// the end of the flushed data have a match, but there is also a potential
	// longer match. In the non-flushed case we would ask for more input, but
	// when flushing we treat this as the end of input and do the match.
	//
	// Flushing is not always possible (like if a charset converter flushes at a
	// partial multibyte sequence). Converters are supposed to try to produce as
	// much output as possible and then return an error (typically
	// G_IO_ERROR_PARTIAL_INPUT).
	Convert(inbuf []byte, outbuf []byte, flags ConverterFlags) (bytesRead uint, bytesWritten uint, converterResult ConverterResult, goerr error)
	// Reset resets all internal state in the converter, making it behave as if
	// it was just created. If the converter has any internal state that would
	// produce output then that output is lost.
	Reset()
}

// Converter is implemented by objects that convert binary data in various ways.
// The conversion can be stateful and may fail at any place.
//
// Some example conversions are: character set conversion, compression,
// decompression and regular expression replace.
type Converter interface {
	gextras.Objector

	// Convert: this is the main operation used when converting data. It is to
	// be called multiple times in a loop, and each time it will do some work,
	// i.e. producing some output (in @outbuf) or consuming some input (from
	// @inbuf) or both. If its not possible to do any work an error is returned.
	//
	// Note that a single call may not consume all input (or any input at all).
	// Also a call may produce output even if given no input, due to state
	// stored in the converter producing output.
	//
	// If any data was either produced or consumed, and then an error happens,
	// then only the successful conversion is reported and the error is returned
	// on the next call.
	//
	// A full conversion loop involves calling this method repeatedly, each time
	// giving it new input and space output space. When there is no more input
	// data after the data in @inbuf, the flag G_CONVERTER_INPUT_AT_END must be
	// set. The loop will be (unless some error happens) returning
	// G_CONVERTER_CONVERTED each time until all data is consumed and all output
	// is produced, then G_CONVERTER_FINISHED is returned instead. Note, that
	// G_CONVERTER_FINISHED may be returned even if G_CONVERTER_INPUT_AT_END is
	// not set, for instance in a decompression converter where the end of data
	// is detectable from the data (and there might even be other data after the
	// end of the compressed data).
	//
	// When some data has successfully been converted @bytes_read and is set to
	// the number of bytes read from @inbuf, and @bytes_written is set to
	// indicate how many bytes was written to @outbuf. If there are more data to
	// output or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified)
	// then G_CONVERTER_CONVERTED is returned, and if no more data is to be
	// output then G_CONVERTER_FINISHED is returned.
	//
	// On error G_CONVERTER_ERROR is returned and @error is set accordingly.
	// Some errors need special handling:
	//
	// G_IO_ERROR_NO_SPACE is returned if there is not enough space to write the
	// resulting converted data, the application should call the function again
	// with a larger @outbuf to continue.
	//
	// G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough input to
	// fully determine what the conversion should produce, and the
	// G_CONVERTER_INPUT_AT_END flag is not set. This happens for example with
	// an incomplete multibyte sequence when converting text, or when a regexp
	// matches up to the end of the input (and may match further input). It may
	// also happen when @inbuf_size is zero and there is no more data to
	// produce.
	//
	// When this happens the application should read more input and then call
	// the function again. If further input shows that there is no more data
	// call the function again with the same data but with the
	// G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion to
	// finish as e.g. in the regexp match case (or, to fail again with
	// G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the input is
	// actually partial).
	//
	// After g_converter_convert() has returned G_CONVERTER_FINISHED the
	// converter object is in an invalid state where its not allowed to call
	// g_converter_convert() anymore. At this time you can only free the object
	// or call g_converter_reset() to reset it to the initial state.
	//
	// If the flag G_CONVERTER_FLUSH is set then conversion is modified to try
	// to write out all internal state to the output. The application has to
	// call the function multiple times with the flag set, and when the
	// available input has been consumed and all internal state has been
	// produced then G_CONVERTER_FLUSHED (or G_CONVERTER_FINISHED if really at
	// the end) is returned instead of G_CONVERTER_CONVERTED. This is somewhat
	// similar to what happens at the end of the input stream, but done in the
	// middle of the data.
	//
	// This has different meanings for different conversions. For instance in a
	// compression converter it would mean that we flush all the compression
	// state into output such that if you uncompress the compressed data you get
	// back all the input data. Doing this may make the final file larger due to
	// padding though. Another example is a regexp conversion, where if you at
	// the end of the flushed data have a match, but there is also a potential
	// longer match. In the non-flushed case we would ask for more input, but
	// when flushing we treat this as the end of input and do the match.
	//
	// Flushing is not always possible (like if a charset converter flushes at a
	// partial multibyte sequence). Converters are supposed to try to produce as
	// much output as possible and then return an error (typically
	// G_IO_ERROR_PARTIAL_INPUT).
	Convert(inbuf []byte, outbuf []byte, flags ConverterFlags) (bytesRead uint, bytesWritten uint, converterResult ConverterResult, goerr error)
	// Reset resets all internal state in the converter, making it behave as if
	// it was just created. If the converter has any internal state that would
	// produce output then that output is lost.
	Reset()
}

// converter implements the Converter interface.
type converter struct {
	gextras.Objector
}

var _ Converter = (*converter)(nil)

// WrapConverter wraps a GObject to a type that implements interface
// Converter. It is primarily used internally.
func WrapConverter(obj *externglib.Object) Converter {
	return converter{
		Objector: obj,
	}
}

func marshalConverter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConverter(obj), nil
}

func (c converter) Convert(inbuf []byte, outbuf []byte, flags ConverterFlags) (bytesRead uint, bytesWritten uint, converterResult ConverterResult, goerr error) {
	var _arg0 *C.GConverter // out
	var _arg1 *C.void
	var _arg2 C.gsize
	var _arg3 *C.void
	var _arg4 C.gsize
	var _arg5 C.GConverterFlags  // out
	var _arg6 C.gsize            // in
	var _arg7 C.gsize            // in
	var _cret C.GConverterResult // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GConverter)(unsafe.Pointer(c.Native()))
	_arg2 = C.gsize(len(inbuf))
	_arg1 = (*C.void)(unsafe.Pointer(&inbuf[0]))
	_arg4 = C.gsize(len(outbuf))
	_arg3 = (*C.void)(unsafe.Pointer(&outbuf[0]))
	_arg5 = (C.GConverterFlags)(flags)

	_cret = C.g_converter_convert(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, &_arg7, &_cerr)

	var _bytesRead uint                  // out
	var _bytesWritten uint               // out
	var _converterResult ConverterResult // out
	var _goerr error                     // out

	_bytesRead = (uint)(_arg6)
	_bytesWritten = (uint)(_arg7)
	_converterResult = ConverterResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesRead, _bytesWritten, _converterResult, _goerr
}

func (c converter) Reset() {
	var _arg0 *C.GConverter // out

	_arg0 = (*C.GConverter)(unsafe.Pointer(c.Native()))

	C.g_converter_reset(_arg0)
}

// DBusInterfaceOverrider contains methods that are overridable. This
// interface is a subset of the interface DBusInterface.
type DBusInterfaceOverrider interface {
	// DupObject gets the BusObject that @interface_ belongs to, if any.
	DupObject() DBusObject
	// Info gets D-Bus introspection information for the D-Bus interface
	// implemented by @interface_.
	Info() *DBusInterfaceInfo
	// SetObject sets the BusObject for @interface_ to @object.
	//
	// Note that @interface_ will hold a weak reference to @object.
	SetObject(object DBusObject)
}

// DBusInterface: the BusInterface type is the base type for D-Bus interfaces
// both on the service side (see BusInterfaceSkeleton) and client side (see
// BusProxy).
type DBusInterface interface {
	gextras.Objector

	// DupObject gets the BusObject that @interface_ belongs to, if any.
	DupObject() DBusObject
	// Info gets D-Bus introspection information for the D-Bus interface
	// implemented by @interface_.
	Info() *DBusInterfaceInfo
	// SetObject sets the BusObject for @interface_ to @object.
	//
	// Note that @interface_ will hold a weak reference to @object.
	SetObject(object DBusObject)
}

// dBusInterface implements the DBusInterface interface.
type dBusInterface struct {
	gextras.Objector
}

var _ DBusInterface = (*dBusInterface)(nil)

// WrapDBusInterface wraps a GObject to a type that implements interface
// DBusInterface. It is primarily used internally.
func WrapDBusInterface(obj *externglib.Object) DBusInterface {
	return dBusInterface{
		Objector: obj,
	}
}

func marshalDBusInterface(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusInterface(obj), nil
}

func (i dBusInterface) DupObject() DBusObject {
	var _arg0 *C.GDBusInterface // out
	var _cret *C.GDBusObject    // in

	_arg0 = (*C.GDBusInterface)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_interface_dup_object(_arg0)

	var _dBusObject DBusObject // out

	_dBusObject = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusObject)

	return _dBusObject
}

func (i dBusInterface) Info() *DBusInterfaceInfo {
	var _arg0 *C.GDBusInterface     // out
	var _cret *C.GDBusInterfaceInfo // in

	_arg0 = (*C.GDBusInterface)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_interface_get_info(_arg0)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	_dBusInterfaceInfo = WrapDBusInterfaceInfo(unsafe.Pointer(_cret))

	return _dBusInterfaceInfo
}

func (i dBusInterface) SetObject(object DBusObject) {
	var _arg0 *C.GDBusInterface // out
	var _arg1 *C.GDBusObject    // out

	_arg0 = (*C.GDBusInterface)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GDBusObject)(unsafe.Pointer(object.Native()))

	C.g_dbus_interface_set_object(_arg0, _arg1)
}

// DBusObjectOverrider contains methods that are overridable. This
// interface is a subset of the interface DBusObject.
type DBusObjectOverrider interface {
	// Interface gets the D-Bus interface with name @interface_name associated
	// with @object, if any.
	Interface(interfaceName string) DBusInterface
	// ObjectPath gets the object path for @object.
	ObjectPath() string

	InterfaceAdded(interface_ DBusInterface)

	InterfaceRemoved(interface_ DBusInterface)
}

// DBusObject: the BusObject type is the base type for D-Bus objects on both the
// service side (see BusObjectSkeleton) and the client side (see
// BusObjectProxy). It is essentially just a container of interfaces.
type DBusObject interface {
	gextras.Objector

	// Interface gets the D-Bus interface with name @interface_name associated
	// with @object, if any.
	Interface(interfaceName string) DBusInterface
	// ObjectPath gets the object path for @object.
	ObjectPath() string
}

// dBusObject implements the DBusObject interface.
type dBusObject struct {
	gextras.Objector
}

var _ DBusObject = (*dBusObject)(nil)

// WrapDBusObject wraps a GObject to a type that implements interface
// DBusObject. It is primarily used internally.
func WrapDBusObject(obj *externglib.Object) DBusObject {
	return dBusObject{
		Objector: obj,
	}
}

func marshalDBusObject(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObject(obj), nil
}

func (o dBusObject) Interface(interfaceName string) DBusInterface {
	var _arg0 *C.GDBusObject    // out
	var _arg1 *C.gchar          // out
	var _cret *C.GDBusInterface // in

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_get_interface(_arg0, _arg1)

	var _dBusInterface DBusInterface // out

	_dBusInterface = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusInterface)

	return _dBusInterface
}

func (o dBusObject) ObjectPath() string {
	var _arg0 *C.GDBusObject // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(o.Native()))

	_cret = C.g_dbus_object_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// DBusObjectManagerOverrider contains methods that are overridable. This
// interface is a subset of the interface DBusObjectManager.
type DBusObjectManagerOverrider interface {
	// Interface gets the interface proxy for @interface_name at @object_path,
	// if any.
	Interface(objectPath string, interfaceName string) DBusInterface
	// Object gets the BusObjectProxy at @object_path, if any.
	Object(objectPath string) DBusObject
	// ObjectPath gets the object path that @manager is for.
	ObjectPath() string

	InterfaceAdded(object DBusObject, interface_ DBusInterface)

	InterfaceRemoved(object DBusObject, interface_ DBusInterface)

	ObjectAdded(object DBusObject)

	ObjectRemoved(object DBusObject)
}

// DBusObjectManager: the BusObjectManager type is the base type for service-
// and client-side implementations of the standardized
// org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface.
//
// See BusObjectManagerClient for the client-side implementation and
// BusObjectManagerServer for the service-side implementation.
type DBusObjectManager interface {
	gextras.Objector

	// Interface gets the interface proxy for @interface_name at @object_path,
	// if any.
	Interface(objectPath string, interfaceName string) DBusInterface
	// Object gets the BusObjectProxy at @object_path, if any.
	Object(objectPath string) DBusObject
	// ObjectPath gets the object path that @manager is for.
	ObjectPath() string
}

// dBusObjectManager implements the DBusObjectManager interface.
type dBusObjectManager struct {
	gextras.Objector
}

var _ DBusObjectManager = (*dBusObjectManager)(nil)

// WrapDBusObjectManager wraps a GObject to a type that implements interface
// DBusObjectManager. It is primarily used internally.
func WrapDBusObjectManager(obj *externglib.Object) DBusObjectManager {
	return dBusObjectManager{
		Objector: obj,
	}
}

func marshalDBusObjectManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectManager(obj), nil
}

func (m dBusObjectManager) Interface(objectPath string, interfaceName string) DBusInterface {
	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _cret *C.GDBusInterface     // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_object_manager_get_interface(_arg0, _arg1, _arg2)

	var _dBusInterface DBusInterface // out

	_dBusInterface = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusInterface)

	return _dBusInterface
}

func (m dBusObjectManager) Object(objectPath string) DBusObject {
	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusObject        // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_manager_get_object(_arg0, _arg1)

	var _dBusObject DBusObject // out

	_dBusObject = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusObject)

	return _dBusObject
}

func (m dBusObjectManager) ObjectPath() string {
	var _arg0 *C.GDBusObjectManager // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_object_manager_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// DatagramBasedOverrider contains methods that are overridable. This
// interface is a subset of the interface DatagramBased.
type DatagramBasedOverrider interface {
	// ConditionCheck checks on the readiness of @datagram_based to perform
	// operations. The operations specified in @condition are checked for and
	// masked against the currently-satisfied conditions on @datagram_based. The
	// result is returned.
	//
	// G_IO_IN will be set in the return value if data is available to read with
	// g_datagram_based_receive_messages(), or if the connection is closed
	// remotely (EOS); and if the datagram_based has not been closed locally
	// using some implementation-specific method (such as g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if its a #GSocket).
	//
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if its a #GSocket, for
	// example), all calls to this function will return G_IO_ERROR_CLOSED.
	//
	// G_IO_OUT will be set if it is expected that at least one byte can be sent
	// using g_datagram_based_send_messages() without blocking. It will not be
	// set if the datagram_based has been closed locally.
	//
	// G_IO_HUP will be set if the connection has been closed locally.
	//
	// G_IO_ERR will be set if there was an asynchronous error in transmitting
	// data previously enqueued using g_datagram_based_send_messages().
	//
	// Note that on Windows, it is possible for an operation to return
	// G_IO_ERROR_WOULD_BLOCK even immediately after
	// g_datagram_based_condition_check() has claimed that the Based is ready
	// for writing. Rather than calling g_datagram_based_condition_check() and
	// then writing to the Based if it succeeds, it is generally better to
	// simply try writing right away, and try again later if the initial attempt
	// returns G_IO_ERROR_WOULD_BLOCK.
	//
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in @condition; these
	// conditions will always be set in the output if they are true. Apart from
	// these flags, the output is guaranteed to be masked by @condition.
	//
	// This call never blocks.
	ConditionCheck(condition glib.IOCondition) glib.IOCondition
	// ConditionWait waits for up to @timeout microseconds for condition to
	// become true on @datagram_based. If the condition is met, true is
	// returned.
	//
	// If @cancellable is cancelled before the condition is met, or if @timeout
	// is reached before the condition is met, then false is returned and @error
	// is set appropriately (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	ConditionWait(condition glib.IOCondition, timeout int64, cancellable Cancellable) error
	// ReceiveMessages: receive one or more data messages from @datagram_based
	// in one go.
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains a pointer to an
	// array of Vector structs describing the buffers that the data received in
	// each message will be written to.
	//
	// @flags modify how all messages are received. The commonly available
	// arguments for this are available in the MsgFlags enum, but the values
	// there are the same as the system values, and the flags are passed in
	// as-is, so you can pass in system-specific flags too. These flags affect
	// the overall receive operation. Flags affecting individual messages are
	// returned in Message.flags.
	//
	// The other members of Message are treated as described in its
	// documentation.
	//
	// If @timeout is negative the call will block until @num_messages have been
	// received, the connection is closed remotely (EOS), @cancellable is
	// cancelled, or an error occurs.
	//
	// If @timeout is 0 the call will return up to @num_messages without
	// blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
	// operating system to be received.
	//
	// If @timeout is positive the call will block on the same conditions as if
	// @timeout were negative. If the timeout is reached before any messages are
	// received, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the
	// number of messages received before timing out. (Note: This is effectively
	// the behaviour of `MSG_WAITFORONE` with recvmmsg().)
	//
	// To be notified when messages are available, wait for the G_IO_IN
	// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
	// from g_datagram_based_receive_messages() even if you were previously
	// notified of a G_IO_IN condition.
	//
	// If the remote peer closes the connection, any messages queued in the
	// underlying receive buffer will be returned, and subsequent calls to
	// g_datagram_based_receive_messages() will return 0 (with no error set).
	//
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if its a #GSocket, for
	// example), all calls to this function will return G_IO_ERROR_CLOSED.
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be received; otherwise the number of
	// messages successfully received before the error will be returned. If
	// @cancellable is cancelled, G_IO_ERROR_CANCELLED is returned as with any
	// other error.
	ReceiveMessages(messages []InputMessage, flags int, timeout int64, cancellable Cancellable) (int, error)
	// SendMessages: send one or more data messages from @datagram_based in one
	// go.
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains an address to
	// send the data to, and a pointer to an array of Vector structs to describe
	// the buffers that the data to be sent for each message will be gathered
	// from.
	//
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the MsgFlags enum, but the values there are the
	// same as the system values, and the flags are passed in as-is, so you can
	// pass in system-specific flags too.
	//
	// The other members of Message are treated as described in its
	// documentation.
	//
	// If @timeout is negative the call will block until @num_messages have been
	// sent, @cancellable is cancelled, or an error occurs.
	//
	// If @timeout is 0 the call will send up to @num_messages without blocking,
	// or will return G_IO_ERROR_WOULD_BLOCK if there is no space to send
	// messages.
	//
	// If @timeout is positive the call will block on the same conditions as if
	// @timeout were negative. If the timeout is reached before any messages are
	// sent, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the
	// number of messages sent before timing out.
	//
	// To be notified when messages can be sent, wait for the G_IO_OUT
	// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
	// from g_datagram_based_send_messages() even if you were previously
	// notified of a G_IO_OUT condition. (On Windows in particular, this is very
	// common due to the way the underlying APIs work.)
	//
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_write set, if its a #GSocket, for
	// example), all calls to this function will return G_IO_ERROR_CLOSED.
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be sent; otherwise the number of
	// messages successfully sent before the error will be returned. If
	// @cancellable is cancelled, G_IO_ERROR_CANCELLED is returned as with any
	// other error.
	SendMessages(messages []OutputMessage, flags int, timeout int64, cancellable Cancellable) (int, error)
}

// DatagramBased: a Based is a networking interface for representing
// datagram-based communications. It is a more or less direct mapping of the
// core parts of the BSD socket API in a portable GObject interface. It is
// implemented by #GSocket, which wraps the UNIX socket API on UNIX and winsock2
// on Windows.
//
// Based is entirely platform independent, and is intended to be used alongside
// higher-level networking APIs such as OStream.
//
// It uses vectored scatter/gather I/O by default, allowing for many messages to
// be sent or received in a single call. Where possible, implementations of the
// interface should take advantage of vectored I/O to minimise processing or
// system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
// possible. Callers should take advantage of scatter/gather I/O (the use of
// multiple buffers per message) to avoid unnecessary copying of data to
// assemble or disassemble a message.
//
// Each Based operation has a timeout parameter which may be negative for
// blocking behaviour, zero for non-blocking behaviour, or positive for timeout
// behaviour. A blocking operation blocks until finished or there is an error. A
// non-blocking operation will return immediately with a G_IO_ERROR_WOULD_BLOCK
// error if it cannot make progress. A timeout operation will block until the
// operation is complete or the timeout expires; if the timeout expires it will
// return what progress it made, or G_IO_ERROR_TIMED_OUT if no progress was
// made. To know when a call would successfully run you can call
// g_datagram_based_condition_check() or g_datagram_based_condition_wait(). You
// can also use g_datagram_based_create_source() and attach it to a Context to
// get callbacks when I/O is possible.
//
// When running a non-blocking operation applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// As with #GSocket, Baseds can be either connection oriented (for example,
// SCTP) or connectionless (for example, UDP). Baseds must be datagram-based,
// not stream-based. The interface does not cover connection establishment  use
// methods on the underlying type to establish a connection before sending and
// receiving data through the Based API. For connectionless socket types the
// target/source address is specified or received in each I/O operation.
//
// Like most other APIs in GLib, Based is not inherently thread safe. To use a
// Based concurrently from multiple threads, you must implement your own
// locking.
type DatagramBased interface {
	gextras.Objector

	// ConditionCheck checks on the readiness of @datagram_based to perform
	// operations. The operations specified in @condition are checked for and
	// masked against the currently-satisfied conditions on @datagram_based. The
	// result is returned.
	//
	// G_IO_IN will be set in the return value if data is available to read with
	// g_datagram_based_receive_messages(), or if the connection is closed
	// remotely (EOS); and if the datagram_based has not been closed locally
	// using some implementation-specific method (such as g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if its a #GSocket).
	//
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if its a #GSocket, for
	// example), all calls to this function will return G_IO_ERROR_CLOSED.
	//
	// G_IO_OUT will be set if it is expected that at least one byte can be sent
	// using g_datagram_based_send_messages() without blocking. It will not be
	// set if the datagram_based has been closed locally.
	//
	// G_IO_HUP will be set if the connection has been closed locally.
	//
	// G_IO_ERR will be set if there was an asynchronous error in transmitting
	// data previously enqueued using g_datagram_based_send_messages().
	//
	// Note that on Windows, it is possible for an operation to return
	// G_IO_ERROR_WOULD_BLOCK even immediately after
	// g_datagram_based_condition_check() has claimed that the Based is ready
	// for writing. Rather than calling g_datagram_based_condition_check() and
	// then writing to the Based if it succeeds, it is generally better to
	// simply try writing right away, and try again later if the initial attempt
	// returns G_IO_ERROR_WOULD_BLOCK.
	//
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in @condition; these
	// conditions will always be set in the output if they are true. Apart from
	// these flags, the output is guaranteed to be masked by @condition.
	//
	// This call never blocks.
	ConditionCheck(condition glib.IOCondition) glib.IOCondition
	// ConditionWait waits for up to @timeout microseconds for condition to
	// become true on @datagram_based. If the condition is met, true is
	// returned.
	//
	// If @cancellable is cancelled before the condition is met, or if @timeout
	// is reached before the condition is met, then false is returned and @error
	// is set appropriately (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	ConditionWait(condition glib.IOCondition, timeout int64, cancellable Cancellable) error
	// ReceiveMessages: receive one or more data messages from @datagram_based
	// in one go.
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains a pointer to an
	// array of Vector structs describing the buffers that the data received in
	// each message will be written to.
	//
	// @flags modify how all messages are received. The commonly available
	// arguments for this are available in the MsgFlags enum, but the values
	// there are the same as the system values, and the flags are passed in
	// as-is, so you can pass in system-specific flags too. These flags affect
	// the overall receive operation. Flags affecting individual messages are
	// returned in Message.flags.
	//
	// The other members of Message are treated as described in its
	// documentation.
	//
	// If @timeout is negative the call will block until @num_messages have been
	// received, the connection is closed remotely (EOS), @cancellable is
	// cancelled, or an error occurs.
	//
	// If @timeout is 0 the call will return up to @num_messages without
	// blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
	// operating system to be received.
	//
	// If @timeout is positive the call will block on the same conditions as if
	// @timeout were negative. If the timeout is reached before any messages are
	// received, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the
	// number of messages received before timing out. (Note: This is effectively
	// the behaviour of `MSG_WAITFORONE` with recvmmsg().)
	//
	// To be notified when messages are available, wait for the G_IO_IN
	// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
	// from g_datagram_based_receive_messages() even if you were previously
	// notified of a G_IO_IN condition.
	//
	// If the remote peer closes the connection, any messages queued in the
	// underlying receive buffer will be returned, and subsequent calls to
	// g_datagram_based_receive_messages() will return 0 (with no error set).
	//
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if its a #GSocket, for
	// example), all calls to this function will return G_IO_ERROR_CLOSED.
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be received; otherwise the number of
	// messages successfully received before the error will be returned. If
	// @cancellable is cancelled, G_IO_ERROR_CANCELLED is returned as with any
	// other error.
	ReceiveMessages(messages []InputMessage, flags int, timeout int64, cancellable Cancellable) (int, error)
	// SendMessages: send one or more data messages from @datagram_based in one
	// go.
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains an address to
	// send the data to, and a pointer to an array of Vector structs to describe
	// the buffers that the data to be sent for each message will be gathered
	// from.
	//
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the MsgFlags enum, but the values there are the
	// same as the system values, and the flags are passed in as-is, so you can
	// pass in system-specific flags too.
	//
	// The other members of Message are treated as described in its
	// documentation.
	//
	// If @timeout is negative the call will block until @num_messages have been
	// sent, @cancellable is cancelled, or an error occurs.
	//
	// If @timeout is 0 the call will send up to @num_messages without blocking,
	// or will return G_IO_ERROR_WOULD_BLOCK if there is no space to send
	// messages.
	//
	// If @timeout is positive the call will block on the same conditions as if
	// @timeout were negative. If the timeout is reached before any messages are
	// sent, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the
	// number of messages sent before timing out.
	//
	// To be notified when messages can be sent, wait for the G_IO_OUT
	// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
	// from g_datagram_based_send_messages() even if you were previously
	// notified of a G_IO_OUT condition. (On Windows in particular, this is very
	// common due to the way the underlying APIs work.)
	//
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_write set, if its a #GSocket, for
	// example), all calls to this function will return G_IO_ERROR_CLOSED.
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be sent; otherwise the number of
	// messages successfully sent before the error will be returned. If
	// @cancellable is cancelled, G_IO_ERROR_CANCELLED is returned as with any
	// other error.
	SendMessages(messages []OutputMessage, flags int, timeout int64, cancellable Cancellable) (int, error)
}

// datagramBased implements the DatagramBased interface.
type datagramBased struct {
	gextras.Objector
}

var _ DatagramBased = (*datagramBased)(nil)

// WrapDatagramBased wraps a GObject to a type that implements interface
// DatagramBased. It is primarily used internally.
func WrapDatagramBased(obj *externglib.Object) DatagramBased {
	return datagramBased{
		Objector: obj,
	}
}

func marshalDatagramBased(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDatagramBased(obj), nil
}

func (d datagramBased) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var _arg0 *C.GDatagramBased // out
	var _arg1 C.GIOCondition    // out
	var _cret C.GIOCondition    // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(d.Native()))
	_arg1 = (C.GIOCondition)(condition)

	_cret = C.g_datagram_based_condition_check(_arg0, _arg1)

	var _ioCondition glib.IOCondition // out

	_ioCondition = glib.IOCondition(_cret)

	return _ioCondition
}

func (d datagramBased) ConditionWait(condition glib.IOCondition, timeout int64, cancellable Cancellable) error {
	var _arg0 *C.GDatagramBased // out
	var _arg1 C.GIOCondition    // out
	var _arg2 C.gint64          // out
	var _arg3 *C.GCancellable   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(d.Native()))
	_arg1 = (C.GIOCondition)(condition)
	_arg2 = (C.gint64)(timeout)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_datagram_based_condition_wait(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (d datagramBased) ReceiveMessages(messages []InputMessage, flags int, timeout int64, cancellable Cancellable) (int, error) {
	var _arg0 *C.GDatagramBased // out
	var _arg1 *C.GInputMessage
	var _arg2 C.guint
	var _arg3 C.gint          // out
	var _arg4 C.gint64        // out
	var _arg5 *C.GCancellable // out
	var _cret C.gint          // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(d.Native()))
	_arg2 = C.guint(len(messages))
	_arg1 = (*C.GInputMessage)(unsafe.Pointer(&messages[0]))
	_arg3 = (C.gint)(flags)
	_arg4 = (C.gint64)(timeout)
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_datagram_based_receive_messages(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (d datagramBased) SendMessages(messages []OutputMessage, flags int, timeout int64, cancellable Cancellable) (int, error) {
	var _arg0 *C.GDatagramBased // out
	var _arg1 *C.GOutputMessage
	var _arg2 C.guint
	var _arg3 C.gint          // out
	var _arg4 C.gint64        // out
	var _arg5 *C.GCancellable // out
	var _cret C.gint          // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(d.Native()))
	_arg2 = C.guint(len(messages))
	_arg1 = (*C.GOutputMessage)(unsafe.Pointer(&messages[0]))
	_arg3 = (C.gint)(flags)
	_arg4 = (C.gint64)(timeout)
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_datagram_based_send_messages(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

// DesktopAppInfoLookupOverrider contains methods that are overridable. This
// interface is a subset of the interface DesktopAppInfoLookup.
type DesktopAppInfoLookupOverrider interface {
	// DefaultForURIScheme gets the default application for launching
	// applications using this URI scheme for a particular AppInfoLookup
	// implementation.
	//
	// The AppInfoLookup interface and this function is used to implement
	// g_app_info_get_default_for_uri_scheme() backends in a GIO module. There
	// is no reason for applications to use it directly. Applications should use
	// g_app_info_get_default_for_uri_scheme().
	DefaultForURIScheme(uriScheme string) AppInfo
}

// DesktopAppInfoLookup is an opaque data structure and can only be accessed
// using the following functions.
type DesktopAppInfoLookup interface {
	gextras.Objector

	// DefaultForURIScheme gets the default application for launching
	// applications using this URI scheme for a particular AppInfoLookup
	// implementation.
	//
	// The AppInfoLookup interface and this function is used to implement
	// g_app_info_get_default_for_uri_scheme() backends in a GIO module. There
	// is no reason for applications to use it directly. Applications should use
	// g_app_info_get_default_for_uri_scheme().
	DefaultForURIScheme(uriScheme string) AppInfo
}

// desktopAppInfoLookup implements the DesktopAppInfoLookup interface.
type desktopAppInfoLookup struct {
	gextras.Objector
}

var _ DesktopAppInfoLookup = (*desktopAppInfoLookup)(nil)

// WrapDesktopAppInfoLookup wraps a GObject to a type that implements interface
// DesktopAppInfoLookup. It is primarily used internally.
func WrapDesktopAppInfoLookup(obj *externglib.Object) DesktopAppInfoLookup {
	return desktopAppInfoLookup{
		Objector: obj,
	}
}

func marshalDesktopAppInfoLookup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDesktopAppInfoLookup(obj), nil
}

func (l desktopAppInfoLookup) DefaultForURIScheme(uriScheme string) AppInfo {
	var _arg0 *C.GDesktopAppInfoLookup // out
	var _arg1 *C.char                  // out
	var _cret *C.GAppInfo              // in

	_arg0 = (*C.GDesktopAppInfoLookup)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(uriScheme))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_desktop_app_info_lookup_get_default_for_uri_scheme(_arg0, _arg1)

	var _appInfo AppInfo // out

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppInfo)

	return _appInfo
}

// DriveOverrider contains methods that are overridable. This
// interface is a subset of the interface Drive.
type DriveOverrider interface {
	// CanEject checks if a drive can be ejected.
	CanEject() bool
	// CanPollForMedia checks if a drive can be polled for media changes.
	CanPollForMedia() bool
	// CanStart checks if a drive can be started.
	CanStart() bool
	// CanStartDegraded checks if a drive can be started degraded.
	CanStartDegraded() bool
	// CanStop checks if a drive can be stopped.
	CanStop() bool

	Changed()

	Disconnected()

	EjectButton()
	// EjectFinish finishes ejecting a drive.
	EjectFinish(result AsyncResult) error
	// EjectWithOperationFinish finishes ejecting a drive. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
	EjectWithOperationFinish(result AsyncResult) error
	// EnumerateIdentifiers gets the kinds of identifiers that @drive has. Use
	// g_drive_get_identifier() to obtain the identifiers themselves.
	EnumerateIdentifiers() []string
	// Icon gets the icon for @drive.
	Icon() Icon
	// Identifier gets the identifier of the given kind for @drive. The only
	// identifier currently available is DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
	Identifier(kind string) string
	// Name gets the name of @drive.
	Name() string
	// SortKey gets the sort key for @drive, if any.
	SortKey() string
	// StartStopType gets a hint about how a drive can be started/stopped.
	StartStopType() DriveStartStopType
	// SymbolicIcon gets the icon for @drive.
	SymbolicIcon() Icon
	// HasMedia checks if the @drive has media. Note that the OS may not be
	// polling the drive for media changes; see
	// g_drive_is_media_check_automatic() for more details.
	HasMedia() bool
	// HasVolumes: check if @drive has any mountable volumes.
	HasVolumes() bool
	// IsMediaCheckAutomatic checks if @drive is capable of automatically
	// detecting media changes.
	IsMediaCheckAutomatic() bool
	// IsMediaRemovable checks if the @drive supports removable media.
	IsMediaRemovable() bool
	// IsRemovable checks if the #GDrive and/or its media is considered
	// removable by the user. See g_drive_is_media_removable().
	IsRemovable() bool
	// PollForMediaFinish finishes an operation started with
	// g_drive_poll_for_media() on a drive.
	PollForMediaFinish(result AsyncResult) error
	// StartFinish finishes starting a drive.
	StartFinish(result AsyncResult) error

	StopButton()
	// StopFinish finishes stopping a drive.
	StopFinish(result AsyncResult) error
}

// Drive: #GDrive - this represent a piece of hardware connected to the machine.
// It's generally only created for removable hardware or hardware with removable
// media.
//
// #GDrive is a container class for #GVolume objects that stem from the same
// piece of media. As such, #GDrive abstracts a drive with (or without)
// removable media and provides operations for querying whether media is
// available, determining whether media change is automatically detected and
// ejecting the media.
//
// If the #GDrive reports that media isn't automatically detected, one can poll
// for media; typically one should not do this periodically as a poll for media
// operation is potentially expensive and may spin up the drive creating noise.
//
// #GDrive supports starting and stopping drives with authentication support for
// the former. This can be used to support a diverse set of use cases including
// connecting/disconnecting iSCSI devices, powering down external disk
// enclosures and starting/stopping multi-disk devices such as RAID devices.
// Note that the actual semantics and side-effects of starting/stopping a
// #GDrive may vary according to implementation. To choose the correct verbs in
// e.g. a file manager, use g_drive_get_start_stop_type().
//
// For porting from GnomeVFS note that there is no equivalent of #GDrive in that
// API.
type Drive interface {
	gextras.Objector

	// CanEject checks if a drive can be ejected.
	CanEject() bool
	// CanPollForMedia checks if a drive can be polled for media changes.
	CanPollForMedia() bool
	// CanStart checks if a drive can be started.
	CanStart() bool
	// CanStartDegraded checks if a drive can be started degraded.
	CanStartDegraded() bool
	// CanStop checks if a drive can be stopped.
	CanStop() bool
	// EjectFinish finishes ejecting a drive.
	EjectFinish(result AsyncResult) error
	// EjectWithOperationFinish finishes ejecting a drive. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
	EjectWithOperationFinish(result AsyncResult) error
	// EnumerateIdentifiers gets the kinds of identifiers that @drive has. Use
	// g_drive_get_identifier() to obtain the identifiers themselves.
	EnumerateIdentifiers() []string
	// Icon gets the icon for @drive.
	Icon() Icon
	// Identifier gets the identifier of the given kind for @drive. The only
	// identifier currently available is DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
	Identifier(kind string) string
	// Name gets the name of @drive.
	Name() string
	// SortKey gets the sort key for @drive, if any.
	SortKey() string
	// StartStopType gets a hint about how a drive can be started/stopped.
	StartStopType() DriveStartStopType
	// SymbolicIcon gets the icon for @drive.
	SymbolicIcon() Icon
	// HasMedia checks if the @drive has media. Note that the OS may not be
	// polling the drive for media changes; see
	// g_drive_is_media_check_automatic() for more details.
	HasMedia() bool
	// HasVolumes: check if @drive has any mountable volumes.
	HasVolumes() bool
	// IsMediaCheckAutomatic checks if @drive is capable of automatically
	// detecting media changes.
	IsMediaCheckAutomatic() bool
	// IsMediaRemovable checks if the @drive supports removable media.
	IsMediaRemovable() bool
	// IsRemovable checks if the #GDrive and/or its media is considered
	// removable by the user. See g_drive_is_media_removable().
	IsRemovable() bool
	// PollForMediaFinish finishes an operation started with
	// g_drive_poll_for_media() on a drive.
	PollForMediaFinish(result AsyncResult) error
	// StartFinish finishes starting a drive.
	StartFinish(result AsyncResult) error
	// StopFinish finishes stopping a drive.
	StopFinish(result AsyncResult) error
}

// drive implements the Drive interface.
type drive struct {
	gextras.Objector
}

var _ Drive = (*drive)(nil)

// WrapDrive wraps a GObject to a type that implements interface
// Drive. It is primarily used internally.
func WrapDrive(obj *externglib.Object) Drive {
	return drive{
		Objector: obj,
	}
}

func marshalDrive(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrive(obj), nil
}

func (d drive) CanEject() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_can_eject(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) CanPollForMedia() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_can_poll_for_media(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) CanStart() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_can_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) CanStartDegraded() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_can_start_degraded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) CanStop() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_can_stop(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) EjectFinish(result AsyncResult) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_drive_eject_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (d drive) EjectWithOperationFinish(result AsyncResult) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_drive_eject_with_operation_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (d drive) EnumerateIdentifiers() []string {
	var _arg0 *C.GDrive // out
	var _cret **C.char

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_enumerate_identifiers(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (d drive) Icon() Icon {
	var _arg0 *C.GDrive // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_get_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (d drive) Identifier(kind string) string {
	var _arg0 *C.GDrive // out
	var _arg1 *C.char   // out
	var _cret *C.char   // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.char)(C.CString(kind))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_drive_get_identifier(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (d drive) Name() string {
	var _arg0 *C.GDrive // out
	var _cret *C.char   // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (d drive) SortKey() string {
	var _arg0 *C.GDrive // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_get_sort_key(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (d drive) StartStopType() DriveStartStopType {
	var _arg0 *C.GDrive             // out
	var _cret C.GDriveStartStopType // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_get_start_stop_type(_arg0)

	var _driveStartStopType DriveStartStopType // out

	_driveStartStopType = DriveStartStopType(_cret)

	return _driveStartStopType
}

func (d drive) SymbolicIcon() Icon {
	var _arg0 *C.GDrive // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_get_symbolic_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (d drive) HasMedia() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_has_media(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) HasVolumes() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_has_volumes(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) IsMediaCheckAutomatic() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_is_media_check_automatic(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) IsMediaRemovable() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_is_media_removable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) IsRemovable() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

	_cret = C.g_drive_is_removable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d drive) PollForMediaFinish(result AsyncResult) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_drive_poll_for_media_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (d drive) StartFinish(result AsyncResult) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_drive_start_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (d drive) StopFinish(result AsyncResult) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_drive_stop_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// DTLSClientConnection is the client-side subclass of Connection, representing
// a client-side DTLS connection.
type DTLSClientConnection interface {
	DatagramBased
	DTLSConnection

	// ServerIdentity gets @conn's expected server identity
	ServerIdentity() SocketConnectable
	// ValidationFlags gets @conn's validation flags
	ValidationFlags() TLSCertificateFlags
	// SetServerIdentity sets @conn's expected server identity, which is used
	// both to tell servers on virtual hosts which certificate to present, and
	// also to let @conn know what name to look for in the certificate when
	// performing G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
	SetServerIdentity(identity SocketConnectable)
	// SetValidationFlags sets @conn's validation flags, to override the default
	// set of checks performed when validating a server certificate. By default,
	// G_TLS_CERTIFICATE_VALIDATE_ALL is used.
	SetValidationFlags(flags TLSCertificateFlags)
}

// dtlsClientConnection implements the DTLSClientConnection interface.
type dtlsClientConnection struct {
	DatagramBased
	DTLSConnection
}

var _ DTLSClientConnection = (*dtlsClientConnection)(nil)

// WrapDTLSClientConnection wraps a GObject to a type that implements interface
// DTLSClientConnection. It is primarily used internally.
func WrapDTLSClientConnection(obj *externglib.Object) DTLSClientConnection {
	return dtlsClientConnection{
		DatagramBased:  WrapDatagramBased(obj),
		DTLSConnection: WrapDTLSConnection(obj),
	}
}

func marshalDTLSClientConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDTLSClientConnection(obj), nil
}

func (c dtlsClientConnection) ServerIdentity() SocketConnectable {
	var _arg0 *C.GDtlsClientConnection // out
	var _cret *C.GSocketConnectable    // in

	_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_client_connection_get_server_identity(_arg0)

	var _socketConnectable SocketConnectable // out

	_socketConnectable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SocketConnectable)

	return _socketConnectable
}

func (c dtlsClientConnection) ValidationFlags() TLSCertificateFlags {
	var _arg0 *C.GDtlsClientConnection // out
	var _cret C.GTlsCertificateFlags   // in

	_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_client_connection_get_validation_flags(_arg0)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

func (c dtlsClientConnection) SetServerIdentity(identity SocketConnectable) {
	var _arg0 *C.GDtlsClientConnection // out
	var _arg1 *C.GSocketConnectable    // out

	_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(identity.Native()))

	C.g_dtls_client_connection_set_server_identity(_arg0, _arg1)
}

func (c dtlsClientConnection) SetValidationFlags(flags TLSCertificateFlags) {
	var _arg0 *C.GDtlsClientConnection // out
	var _arg1 C.GTlsCertificateFlags   // out

	_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GTlsCertificateFlags)(flags)

	C.g_dtls_client_connection_set_validation_flags(_arg0, _arg1)
}

// DTLSConnectionOverrider contains methods that are overridable. This
// interface is a subset of the interface DTLSConnection.
type DTLSConnectionOverrider interface {
	AcceptCertificate(peerCert TLSCertificate, errors TLSCertificateFlags) bool

	BindingData(typ TLSChannelBindingType, data []byte) error
	// NegotiatedProtocol gets the name of the application-layer protocol
	// negotiated during the handshake.
	//
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend does
	// not support ALPN, then this will be nil. See
	// g_dtls_connection_set_advertised_protocols().
	NegotiatedProtocol() string
	// Handshake attempts a TLS handshake on @conn.
	//
	// On the client side, it is never necessary to call this method; although
	// the connection needs to perform a handshake after connecting, Connection
	// will handle this for you automatically when you try to send or receive
	// data on the connection. You can call g_dtls_connection_handshake()
	// manually if you want to know whether the initial handshake succeeded or
	// failed (as opposed to just immediately trying to use @conn to read or
	// write, in which case, if it fails, it may not be possible to tell if it
	// failed before or after completing the handshake), but beware that servers
	// may reject client authentication after the handshake has completed, so a
	// successful handshake does not indicate the connection will be usable.
	//
	// Likewise, on the server side, although a handshake is necessary at the
	// beginning of the communication, you do not need to call this function
	// explicitly unless you want clearer error reporting.
	//
	// Previously, calling g_dtls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was deprecated
	// in GLib 2.60 because rehandshaking was removed from the TLS protocol in
	// TLS 1.3. Since GLib 2.64, calling this function after the initial
	// handshake will no longer do anything.
	//
	// Connection::accept_certificate may be emitted during the handshake.
	Handshake(cancellable Cancellable) error
	// HandshakeFinish: finish an asynchronous TLS handshake operation. See
	// g_dtls_connection_handshake() for more information.
	HandshakeFinish(result AsyncResult) error
	// SetAdvertisedProtocols sets the list of application-layer protocols to
	// advertise that the caller is willing to speak on this connection. The
	// Application-Layer Protocol Negotiation (ALPN) extension will be used to
	// negotiate a compatible protocol with the peer; use
	// g_dtls_connection_get_negotiated_protocol() to find the negotiated
	// protocol after the handshake. Specifying nil for the the value of
	// @protocols will disable ALPN negotiation.
	//
	// See IANA TLS ALPN Protocol IDs
	// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
	// for a list of registered protocol IDs.
	SetAdvertisedProtocols(protocols []string)
	// Shutdown: shut down part or all of a DTLS connection.
	//
	// If @shutdown_read is true then the receiving side of the connection is
	// shut down, and further reading is disallowed. Subsequent calls to
	// g_datagram_based_receive_messages() will return G_IO_ERROR_CLOSED.
	//
	// If @shutdown_write is true then the sending side of the connection is
	// shut down, and further writing is disallowed. Subsequent calls to
	// g_datagram_based_send_messages() will return G_IO_ERROR_CLOSED.
	//
	// It is allowed for both @shutdown_read and @shutdown_write to be TRUE 
	// this is equivalent to calling g_dtls_connection_close().
	//
	// If @cancellable is cancelled, the Connection may be left partially-closed
	// and any pending untransmitted data may be lost. Call
	// g_dtls_connection_shutdown() again to complete closing the Connection.
	Shutdown(shutdownRead bool, shutdownWrite bool, cancellable Cancellable) error
	// ShutdownFinish: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	ShutdownFinish(result AsyncResult) error
}

// DTLSConnection is the base DTLS connection class type, which wraps a Based
// and provides DTLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side DTLS,
// respectively.
//
// For TLS support, see Connection.
//
// As DTLS is datagram based, Connection implements Based, presenting a
// datagram-socket-like API for the encrypted connection. This operates over a
// base datagram connection, which is also a Based (Connection:base-socket).
//
// To close a DTLS connection, use g_dtls_connection_close().
//
// Neither ServerConnection or ClientConnection set the peer address on their
// base Based if it is a #GSocket  it is up to the caller to do that if they
// wish. If they do not, and g_socket_close() is called on the base socket, the
// Connection will not raise a G_IO_ERROR_NOT_CONNECTED error on further I/O.
type DTLSConnection interface {
	DatagramBased

	// Close: close the DTLS connection. This is equivalent to calling
	// g_dtls_connection_shutdown() to shut down both sides of the connection.
	//
	// Closing a Connection waits for all buffered but untransmitted data to be
	// sent before it completes. It then sends a `close_notify` DTLS alert to
	// the peer and may wait for a `close_notify` to be received from the peer.
	// It does not close the underlying Connection:base-socket; that must be
	// closed separately.
	//
	// Once @conn is closed, all other operations will return G_IO_ERROR_CLOSED.
	// Closing a Connection multiple times will not return an error.
	//
	// Connections will be automatically closed when the last reference is
	// dropped, but you might want to call this function to make sure resources
	// are released as early as possible.
	//
	// If @cancellable is cancelled, the Connection may be left partially-closed
	// and any pending untransmitted data may be lost. Call
	// g_dtls_connection_close() again to complete closing the Connection.
	Close(cancellable Cancellable) error
	// CloseFinish: finish an asynchronous TLS close operation. See
	// g_dtls_connection_close() for more information.
	CloseFinish(result AsyncResult) error
	// EmitAcceptCertificate: used by Connection implementations to emit the
	// Connection::accept-certificate signal.
	EmitAcceptCertificate(peerCert TLSCertificate, errors TLSCertificateFlags) bool
	// Certificate gets @conn's certificate, as set by
	// g_dtls_connection_set_certificate().
	Certificate() TLSCertificate
	// ChannelBindingData: query the TLS backend for TLS channel binding data of
	// @type for @conn.
	//
	// This call retrieves TLS channel binding data as specified in RFC 5056
	// (https://tools.ietf.org/html/rfc5056), RFC 5929
	// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding data
	// is returned in @data. The @data is resized by the callee using Array
	// buffer management and will be freed when the @data is destroyed by
	// g_byte_array_unref(). If @data is nil, it will only check whether TLS
	// backend is able to fetch the data (e.g. whether @type is supported by the
	// TLS backend). It does not guarantee that the data will be available
	// though. That could happen if TLS connection does not support @type or the
	// binding data is not available yet due to additional negotiation or input
	// required.
	ChannelBindingData(typ TLSChannelBindingType) ([]byte, error)
	// Database gets the certificate database that @conn uses to verify peer
	// certificates. See g_dtls_connection_set_database().
	Database() TLSDatabase
	// Interaction: get the object that will be used to interact with the user.
	// It will be used for things like prompting the user for passwords. If nil
	// is returned, then no user interaction will occur for this connection.
	Interaction() TLSInteraction
	// NegotiatedProtocol gets the name of the application-layer protocol
	// negotiated during the handshake.
	//
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend does
	// not support ALPN, then this will be nil. See
	// g_dtls_connection_set_advertised_protocols().
	NegotiatedProtocol() string
	// PeerCertificate gets @conn's peer's certificate after the handshake has
	// completed or failed. (It is not set during the emission of
	// Connection::accept-certificate.)
	PeerCertificate() TLSCertificate
	// PeerCertificateErrors gets the errors associated with validating @conn's
	// peer's certificate, after the handshake has completed or failed. (It is
	// not set during the emission of Connection::accept-certificate.)
	PeerCertificateErrors() TLSCertificateFlags
	// RehandshakeMode gets @conn rehandshaking mode. See
	// g_dtls_connection_set_rehandshake_mode() for details.
	RehandshakeMode() TLSRehandshakeMode
	// RequireCloseNotify tests whether or not @conn expects a proper TLS close
	// notification when the connection is closed. See
	// g_dtls_connection_set_require_close_notify() for details.
	RequireCloseNotify() bool
	// Handshake attempts a TLS handshake on @conn.
	//
	// On the client side, it is never necessary to call this method; although
	// the connection needs to perform a handshake after connecting, Connection
	// will handle this for you automatically when you try to send or receive
	// data on the connection. You can call g_dtls_connection_handshake()
	// manually if you want to know whether the initial handshake succeeded or
	// failed (as opposed to just immediately trying to use @conn to read or
	// write, in which case, if it fails, it may not be possible to tell if it
	// failed before or after completing the handshake), but beware that servers
	// may reject client authentication after the handshake has completed, so a
	// successful handshake does not indicate the connection will be usable.
	//
	// Likewise, on the server side, although a handshake is necessary at the
	// beginning of the communication, you do not need to call this function
	// explicitly unless you want clearer error reporting.
	//
	// Previously, calling g_dtls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was deprecated
	// in GLib 2.60 because rehandshaking was removed from the TLS protocol in
	// TLS 1.3. Since GLib 2.64, calling this function after the initial
	// handshake will no longer do anything.
	//
	// Connection::accept_certificate may be emitted during the handshake.
	Handshake(cancellable Cancellable) error
	// HandshakeFinish: finish an asynchronous TLS handshake operation. See
	// g_dtls_connection_handshake() for more information.
	HandshakeFinish(result AsyncResult) error
	// SetAdvertisedProtocols sets the list of application-layer protocols to
	// advertise that the caller is willing to speak on this connection. The
	// Application-Layer Protocol Negotiation (ALPN) extension will be used to
	// negotiate a compatible protocol with the peer; use
	// g_dtls_connection_get_negotiated_protocol() to find the negotiated
	// protocol after the handshake. Specifying nil for the the value of
	// @protocols will disable ALPN negotiation.
	//
	// See IANA TLS ALPN Protocol IDs
	// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
	// for a list of registered protocol IDs.
	SetAdvertisedProtocols(protocols []string)
	// SetCertificate: this sets the certificate that @conn will present to its
	// peer during the TLS handshake. For a ServerConnection, it is mandatory to
	// set this, and that will normally be done at construct time.
	//
	// For a ClientConnection, this is optional. If a handshake fails with
	// G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server requires a
	// certificate, and if you try connecting again, you should call this method
	// first. You can call g_dtls_client_connection_get_accepted_cas() on the
	// failed connection to get a list of Certificate Authorities that the
	// server will accept certificates from.
	//
	// (It is also possible that a server will allow the connection with or
	// without a certificate; in that case, if you don't provide a certificate,
	// you can tell that the server requested one by the fact that
	// g_dtls_client_connection_get_accepted_cas() will return non-nil.)
	SetCertificate(certificate TLSCertificate)
	// SetDatabase sets the certificate database that is used to verify peer
	// certificates. This is set to the default database by default. See
	// g_tls_backend_get_default_database(). If set to nil, then peer
	// certificate validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA
	// error (meaning Connection::accept-certificate will always be emitted on
	// client-side connections, unless that bit is not set in
	// ClientConnection:validation-flags).
	SetDatabase(database TLSDatabase)
	// SetInteraction: set the object that will be used to interact with the
	// user. It will be used for things like prompting the user for passwords.
	//
	// The @interaction argument will normally be a derived subclass of
	// Interaction. nil can also be provided if no user interaction should occur
	// for this connection.
	SetInteraction(interaction TLSInteraction)
	// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
	// longer supported and will have no effect. With TLS 1.3, rehandshaking has
	// been removed from the TLS protocol, replaced by separate post-handshake
	// authentication and rekey operations.
	SetRehandshakeMode(mode TLSRehandshakeMode)
	// SetRequireCloseNotify sets whether or not @conn expects a proper TLS
	// close notification before the connection is closed. If this is true (the
	// default), then @conn will expect to receive a TLS close notification from
	// its peer before the connection is closed, and will return a
	// G_TLS_ERROR_EOF error if the connection is closed without proper
	// notification (since this may indicate a network error, or
	// man-in-the-middle attack).
	//
	// In some protocols, the application will know whether or not the
	// connection was closed cleanly based on application-level data (because
	// the application-level data includes a length field, or is somehow
	// self-delimiting); in this case, the close notify is redundant and may be
	// omitted. You can use g_dtls_connection_set_require_close_notify() to tell
	// @conn to allow an "unannounced" connection close, in which case the close
	// will show up as a 0-length read, as in a non-TLS Based, and it is up to
	// the application to check that the data has been fully received.
	//
	// Note that this only affects the behavior when the peer closes the
	// connection; when the application calls g_dtls_connection_close_async() on
	// @conn itself, this will send a close notification regardless of the
	// setting of this property. If you explicitly want to do an unclean close,
	// you can close @conn's Connection:base-socket rather than closing @conn
	// itself.
	SetRequireCloseNotify(requireCloseNotify bool)
	// Shutdown: shut down part or all of a DTLS connection.
	//
	// If @shutdown_read is true then the receiving side of the connection is
	// shut down, and further reading is disallowed. Subsequent calls to
	// g_datagram_based_receive_messages() will return G_IO_ERROR_CLOSED.
	//
	// If @shutdown_write is true then the sending side of the connection is
	// shut down, and further writing is disallowed. Subsequent calls to
	// g_datagram_based_send_messages() will return G_IO_ERROR_CLOSED.
	//
	// It is allowed for both @shutdown_read and @shutdown_write to be TRUE 
	// this is equivalent to calling g_dtls_connection_close().
	//
	// If @cancellable is cancelled, the Connection may be left partially-closed
	// and any pending untransmitted data may be lost. Call
	// g_dtls_connection_shutdown() again to complete closing the Connection.
	Shutdown(shutdownRead bool, shutdownWrite bool, cancellable Cancellable) error
	// ShutdownFinish: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	ShutdownFinish(result AsyncResult) error
}

// dtlsConnection implements the DTLSConnection interface.
type dtlsConnection struct {
	DatagramBased
}

var _ DTLSConnection = (*dtlsConnection)(nil)

// WrapDTLSConnection wraps a GObject to a type that implements interface
// DTLSConnection. It is primarily used internally.
func WrapDTLSConnection(obj *externglib.Object) DTLSConnection {
	return dtlsConnection{
		DatagramBased: WrapDatagramBased(obj),
	}
}

func marshalDTLSConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDTLSConnection(obj), nil
}

func (c dtlsConnection) Close(cancellable Cancellable) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dtls_connection_close(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) CloseFinish(result AsyncResult) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_dtls_connection_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) EmitAcceptCertificate(peerCert TLSCertificate, errors TLSCertificateFlags) bool {
	var _arg0 *C.GDtlsConnection     // out
	var _arg1 *C.GTlsCertificate     // out
	var _arg2 C.GTlsCertificateFlags // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(peerCert.Native()))
	_arg2 = (C.GTlsCertificateFlags)(errors)

	_cret = C.g_dtls_connection_emit_accept_certificate(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dtlsConnection) Certificate() TLSCertificate {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_certificate(_arg0)

	var _tlsCertificate TLSCertificate // out

	_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

	return _tlsCertificate
}

func (c dtlsConnection) ChannelBindingData(typ TLSChannelBindingType) ([]byte, error) {
	var _arg0 *C.GDtlsConnection       // out
	var _arg1 C.GTlsChannelBindingType // out
	var _arg2 C.GByteArray
	var _cerr *C.GError // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GTlsChannelBindingType)(typ)

	C.g_dtls_connection_get_channel_binding_data(_arg0, _arg1, &_arg2, &_cerr)

	var _data []byte
	var _goerr error // out

	{
		var i int
		var z C.guint8
		for p := _arg2; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg2, i)
		_data = make([]byte, i)
		for i := range src {
			_data[i] = (byte)(src[i])
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _data, _goerr
}

func (c dtlsConnection) Database() TLSDatabase {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsDatabase    // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_database(_arg0)

	var _tlsDatabase TLSDatabase // out

	_tlsDatabase = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSDatabase)

	return _tlsDatabase
}

func (c dtlsConnection) Interaction() TLSInteraction {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsInteraction // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_interaction(_arg0)

	var _tlsInteraction TLSInteraction // out

	_tlsInteraction = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSInteraction)

	return _tlsInteraction
}

func (c dtlsConnection) NegotiatedProtocol() string {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_negotiated_protocol(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c dtlsConnection) PeerCertificate() TLSCertificate {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_peer_certificate(_arg0)

	var _tlsCertificate TLSCertificate // out

	_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

	return _tlsCertificate
}

func (c dtlsConnection) PeerCertificateErrors() TLSCertificateFlags {
	var _arg0 *C.GDtlsConnection     // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_peer_certificate_errors(_arg0)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

func (c dtlsConnection) RehandshakeMode() TLSRehandshakeMode {
	var _arg0 *C.GDtlsConnection    // out
	var _cret C.GTlsRehandshakeMode // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_rehandshake_mode(_arg0)

	var _tlsRehandshakeMode TLSRehandshakeMode // out

	_tlsRehandshakeMode = TLSRehandshakeMode(_cret)

	return _tlsRehandshakeMode
}

func (c dtlsConnection) RequireCloseNotify() bool {
	var _arg0 *C.GDtlsConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_require_close_notify(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dtlsConnection) Handshake(cancellable Cancellable) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dtls_connection_handshake(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) HandshakeFinish(result AsyncResult) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_dtls_connection_handshake_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) SetAdvertisedProtocols(protocols []string) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 **C.gchar

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(protocols)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(protocols))
		for i := range protocols {
			out[i] = (*C.gchar)(C.CString(protocols[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_dtls_connection_set_advertised_protocols(_arg0, _arg1)
}

func (c dtlsConnection) SetCertificate(certificate TLSCertificate) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GTlsCertificate // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))

	C.g_dtls_connection_set_certificate(_arg0, _arg1)
}

func (c dtlsConnection) SetDatabase(database TLSDatabase) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GTlsDatabase    // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(database.Native()))

	C.g_dtls_connection_set_database(_arg0, _arg1)
}

func (c dtlsConnection) SetInteraction(interaction TLSInteraction) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GTlsInteraction // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))

	C.g_dtls_connection_set_interaction(_arg0, _arg1)
}

func (c dtlsConnection) SetRehandshakeMode(mode TLSRehandshakeMode) {
	var _arg0 *C.GDtlsConnection    // out
	var _arg1 C.GTlsRehandshakeMode // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GTlsRehandshakeMode)(mode)

	C.g_dtls_connection_set_rehandshake_mode(_arg0, _arg1)
}

func (c dtlsConnection) SetRequireCloseNotify(requireCloseNotify bool) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	if requireCloseNotify {
		_arg1 = C.TRUE
	}

	C.g_dtls_connection_set_require_close_notify(_arg0, _arg1)
}

func (c dtlsConnection) Shutdown(shutdownRead bool, shutdownWrite bool, cancellable Cancellable) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 C.gboolean         // out
	var _arg2 C.gboolean         // out
	var _arg3 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	if shutdownRead {
		_arg1 = C.TRUE
	}
	if shutdownWrite {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dtls_connection_shutdown(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) ShutdownFinish(result AsyncResult) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_dtls_connection_shutdown_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// DTLSServerConnection is the server-side subclass of Connection, representing
// a server-side DTLS connection.
type DTLSServerConnection interface {
	DatagramBased
	DTLSConnection
}

// dtlsServerConnection implements the DTLSServerConnection interface.
type dtlsServerConnection struct {
	DatagramBased
	DTLSConnection
}

var _ DTLSServerConnection = (*dtlsServerConnection)(nil)

// WrapDTLSServerConnection wraps a GObject to a type that implements interface
// DTLSServerConnection. It is primarily used internally.
func WrapDTLSServerConnection(obj *externglib.Object) DTLSServerConnection {
	return dtlsServerConnection{
		DatagramBased:  WrapDatagramBased(obj),
		DTLSConnection: WrapDTLSConnection(obj),
	}
}

func marshalDTLSServerConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDTLSServerConnection(obj), nil
}

// FileOverrider contains methods that are overridable. This
// interface is a subset of the interface File.
type FileOverrider interface {
	// AppendTo gets an output stream for appending data to the file. If the
	// file doesn't already exist it is created.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// Some file systems don't allow all file names, and may return an
	// G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
	// G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible
	// too, and depend on what kind of filesystem the file is on.
	AppendTo(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error)
	// AppendToFinish finishes an asynchronous file append operation started
	// with g_file_append_to_async().
	AppendToFinish(res AsyncResult) (FileOutputStream, error)
	// CopyFinish finishes copying the file started with g_file_copy_async().
	CopyFinish(res AsyncResult) error
	// Create creates a new file and returns an output stream for writing to it.
	// The file must not already exist.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If a file or directory with this name already exists the
	// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
	// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
	// if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
	// Other errors are possible too, and depend on what kind of filesystem the
	// file is on.
	Create(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error)
	// CreateFinish finishes an asynchronous file create operation started with
	// g_file_create_async().
	CreateFinish(res AsyncResult) (FileOutputStream, error)
	// CreateReadwrite creates a new file and returns a stream for reading and
	// writing to it. The file must not already exist.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If a file or directory with this name already exists, the
	// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
	// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
	// if the name is too long, G_IO_ERROR_FILENAME_TOO_LONG will be returned.
	// Other errors are possible too, and depend on what kind of filesystem the
	// file is on.
	//
	// Note that in many non-local file cases read and write streams are not
	// supported, so make sure you really need to do read and write streaming,
	// rather than just opening for reading or writing.
	CreateReadwrite(flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error)
	// CreateReadwriteFinish finishes an asynchronous file create operation
	// started with g_file_create_readwrite_async().
	CreateReadwriteFinish(res AsyncResult) (FileIOStream, error)
	// DeleteFile deletes a file. If the @file is a directory, it will only be
	// deleted if it is empty. This has the same semantics as g_unlink().
	//
	// If @file doesnt exist, G_IO_ERROR_NOT_FOUND will be returned. This
	// allows for deletion to be implemented avoiding time-of-check to
	// time-of-use races
	// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
	//
	//    g_autoptr(GError) local_error = NULL;
	//    if (!g_file_delete (my_file, my_cancellable, &local_error) &&
	//        !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
	//      {
	//        // deletion failed for some reason other than the file not existing:
	//        // so report the error
	//        g_warning ("Failed to delete s: s",
	//                   g_file_peek_path (my_file), local_error->message);
	//      }
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	DeleteFile(cancellable Cancellable) error
	// DeleteFileFinish finishes deleting a file started with
	// g_file_delete_async().
	DeleteFileFinish(result AsyncResult) error
	// Dup duplicates a #GFile handle. This operation does not duplicate the
	// actual file or directory represented by the #GFile; see g_file_copy() if
	// attempting to copy a file.
	//
	// g_file_dup() is useful when a second handle is needed to the same
	// underlying file, for use in a separate thread (#GFile is not
	// thread-safe). For use within the same thread, use g_object_ref() to
	// increment the existing objects reference count.
	//
	// This call does no blocking I/O.
	Dup() File
	// EjectMountableFinish finishes an asynchronous eject operation started by
	// g_file_eject_mountable().
	EjectMountableFinish(result AsyncResult) error
	// EjectMountableWithOperationFinish finishes an asynchronous eject
	// operation started by g_file_eject_mountable_with_operation().
	EjectMountableWithOperationFinish(result AsyncResult) error
	// EnumerateChildren gets the requested information about the files in a
	// directory. The result is a Enumerator object that will give out Info
	// objects for all the files in the directory.
	//
	// The @attributes value is a string that specifies the file attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "standard::*" means all attributes in the standard namespace. An example
	// attribute query be "standard::*,owner::user". The standard attributes are
	// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is not a directory, the G_IO_ERROR_NOT_DIRECTORY
	// error will be returned. Other errors are possible too.
	EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileEnumerator, error)
	// EnumerateChildrenFinish finishes an async enumerate children operation.
	// See g_file_enumerate_children_async().
	EnumerateChildrenFinish(res AsyncResult) (FileEnumerator, error)
	// Equal checks if the two given #GFiles refer to the same file.
	//
	// Note that two #GFiles that differ can still refer to the same file on the
	// filesystem due to various forms of filename aliasing.
	//
	// This call does no blocking I/O.
	Equal(file2 File) bool
	// FindEnclosingMount gets a #GMount for the #GFile.
	//
	// #GMount is returned only for user interesting locations, see Monitor. If
	// the Iface for @file does not have a #mount, @error will be set to
	// G_IO_ERROR_NOT_FOUND and nil #will be returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	FindEnclosingMount(cancellable Cancellable) (Mount, error)
	// FindEnclosingMountFinish finishes an asynchronous find mount request. See
	// g_file_find_enclosing_mount_async().
	FindEnclosingMountFinish(res AsyncResult) (Mount, error)
	// Basename gets the base name (the last component of the path) for a given
	// #GFile.
	//
	// If called for the top level of a system (such as the filesystem root or a
	// uri like sftp://host/) it will return a single directory separator (and
	// on Windows, possibly a drive letter).
	//
	// The base name is a byte string (not UTF-8). It has no defined encoding or
	// rules other than it may not contain zero bytes. If you want to use
	// filenames in a user interface you should use the display name that you
	// can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
	// attribute with g_file_query_info().
	//
	// This call does no blocking I/O.
	Basename() string
	// ChildForDisplayName gets the child of @file for a given @display_name
	// (i.e. a UTF-8 version of the name). If this function fails, it returns
	// nil and @error will be set. This is very useful when constructing a
	// #GFile for a new file and the user entered the filename in the user
	// interface, for instance when you select a directory and type a filename
	// in the file selector.
	//
	// This call does no blocking I/O.
	ChildForDisplayName(displayName string) (File, error)
	// Parent gets the parent directory for the @file. If the @file represents
	// the root directory of the file system, then nil will be returned.
	//
	// This call does no blocking I/O.
	Parent() File
	// ParseName gets the parse name of the @file. A parse name is a UTF-8
	// string that describes the file such that one can get the #GFile back
	// using g_file_parse_name().
	//
	// This is generally used to show the #GFile as a nice full-pathname kind of
	// string in a user interface, like in a location entry.
	//
	// For local files with names that can safely be converted to UTF-8 the
	// pathname is used, otherwise the IRI is used (a form of URI that allows
	// UTF-8 characters unescaped).
	//
	// This call does no blocking I/O.
	ParseName() string
	// Path gets the local pathname for #GFile, if one exists. If non-nil, this
	// is guaranteed to be an absolute, canonical path. It might contain
	// symlinks.
	//
	// This call does no blocking I/O.
	Path() string
	// RelativePath gets the path for @descendant relative to @parent.
	//
	// This call does no blocking I/O.
	RelativePath(descendant File) string
	// URI gets the URI for the @file.
	//
	// This call does no blocking I/O.
	URI() string
	// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme
	// as:
	//
	//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
	//
	// Common schemes include "file", "http", "ftp", etc.
	//
	// The scheme can be different from the one used to construct the #GFile, in
	// that it might be replaced with one that is logically equivalent to the
	// #GFile.
	//
	// This call does no blocking I/O.
	URIScheme() string
	// HasURIScheme checks to see if a #GFile has a given URI scheme.
	//
	// This call does no blocking I/O.
	HasURIScheme(uriScheme string) bool
	// Hash creates a hash value for a #GFile.
	//
	// This call does no blocking I/O.
	Hash() uint
	// IsNative checks to see if a file is native to the platform.
	//
	// A native file is one expressed in the platform-native filename format,
	// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
	// as it might be on a locally mounted remote filesystem.
	//
	// On some systems non-native files may be available using the native
	// filesystem via a userspace filesystem (FUSE), in these cases this call
	// will return false, but g_file_get_path() will still return a native path.
	//
	// This call does no blocking I/O.
	IsNative() bool
	// MakeDirectory creates a directory. Note that this will only create a
	// child directory of the immediate parent directory of the path or URI
	// given by the #GFile. To recursively create directories, see
	// g_file_make_directory_with_parents(). This function will fail if the
	// parent directory does not exist, setting @error to G_IO_ERROR_NOT_FOUND.
	// If the file system doesn't support creating directories, this function
	// will fail, setting @error to G_IO_ERROR_NOT_SUPPORTED.
	//
	// For a local #GFile the newly created directory will have the default
	// (current) ownership and permissions of the current process.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	MakeDirectory(cancellable Cancellable) error
	// MakeDirectoryFinish finishes an asynchronous directory creation, started
	// with g_file_make_directory_async().
	MakeDirectoryFinish(result AsyncResult) error
	// MakeSymbolicLink creates a symbolic link named @file which contains the
	// string @symlink_value.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	MakeSymbolicLink(symlinkValue string, cancellable Cancellable) error
	// MeasureDiskUsageFinish collects the results from an earlier call to
	// g_file_measure_disk_usage_async(). See g_file_measure_disk_usage() for
	// more information.
	MeasureDiskUsageFinish(result AsyncResult) (diskUsage uint64, numDirs uint64, numFiles uint64, goerr error)
	// MonitorDir obtains a directory monitor for the given file. This may fail
	// if directory monitoring is not supported.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// It does not make sense for @flags to contain
	// G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
	// directories. It is not possible to monitor all the files in a directory
	// for changes made via hard links; if you want to do this then you must
	// register individual watches with g_file_monitor().
	MonitorDir(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error)
	// MonitorFile obtains a file monitor for the given file. If no file
	// notification mechanism exists, then regular polling of the file is used.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If @flags contains G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor will
	// also attempt to report changes made to the file via another filename (ie,
	// a hard link). Without this flag, you can only rely on changes made
	// through the filename contained in @file to be reported. Using this flag
	// may result in an increase in resource usage, and may not have any effect
	// depending on the Monitor backend and/or filesystem type.
	MonitorFile(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error)
	// MountEnclosingVolumeFinish finishes a mount operation started by
	// g_file_mount_enclosing_volume().
	MountEnclosingVolumeFinish(result AsyncResult) error
	// MountMountableFinish finishes a mount operation. See
	// g_file_mount_mountable() for details.
	//
	// Finish an asynchronous mount operation that was started with
	// g_file_mount_mountable().
	MountMountableFinish(result AsyncResult) (File, error)
	// OpenReadwrite opens an existing file for reading and writing. The result
	// is a IOStream that can be used to read and write the contents of the
	// file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
	// will be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on. Note that in many non-local file cases read
	// and write streams are not supported, so make sure you really need to do
	// read and write streaming, rather than just opening for reading or
	// writing.
	OpenReadwrite(cancellable Cancellable) (FileIOStream, error)
	// OpenReadwriteFinish finishes an asynchronous file read operation started
	// with g_file_open_readwrite_async().
	OpenReadwriteFinish(res AsyncResult) (FileIOStream, error)
	// PollMountableFinish finishes a poll operation. See
	// g_file_poll_mountable() for details.
	//
	// Finish an asynchronous poll operation that was polled with
	// g_file_poll_mountable().
	PollMountableFinish(result AsyncResult) error
	// PrefixMatches checks whether @file has the prefix specified by @prefix.
	//
	// In other words, if the names of initial elements of @file's pathname
	// match @prefix. Only full pathname elements are matched, so a path like
	// /foo is not considered a prefix of /foobar, only of /foo/bar.
	//
	// A #GFile is not a prefix of itself. If you want to check for equality,
	// use g_file_equal().
	//
	// This call does no I/O, as it works purely on names. As such it can
	// sometimes return false even if @file is inside a @prefix (from a
	// filesystem point of view), because the prefix of @file is an alias of
	// @prefix.
	PrefixMatches(file File) bool
	// QueryFilesystemInfo: similar to g_file_query_info(), but obtains
	// information about the filesystem the @file is on, rather than the file
	// itself. For instance the amount of space available and the type of the
	// filesystem.
	//
	// The @attributes value is a string that specifies the attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "filesystem::*" means all attributes in the filesystem namespace. The
	// standard namespace for filesystem attributes is "filesystem". Common
	// attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size
	// of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of
	// bytes available), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the
	// filesystem).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
	QueryFilesystemInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query.
	// See g_file_query_filesystem_info_async().
	QueryFilesystemInfoFinish(res AsyncResult) (FileInfo, error)
	// QueryInfo gets the requested information about specified @file. The
	// result is a Info object that contains key-value attributes (such as the
	// type or size of the file).
	//
	// The @attributes value is a string that specifies the file attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "standard::*" means all attributes in the standard namespace. An example
	// attribute query be "standard::*,owner::user". The standard attributes are
	// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// For symlinks, normally the information about the target of the symlink is
	// returned, rather than information about the symlink itself. However if
	// you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in @flags the information
	// about the symlink itself will be returned. Also, for symlinks that point
	// to non-existing files the information about the symlink itself will be
	// returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
	QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileInfo, error)
	// QueryInfoFinish finishes an asynchronous file info query. See
	// g_file_query_info_async().
	QueryInfoFinish(res AsyncResult) (FileInfo, error)
	// QuerySettableAttributes: obtain the list of settable attributes for the
	// file.
	//
	// Returns the type and full attribute name of all the attributes that can
	// be set on this file. This doesn't mean setting it will always succeed
	// though, you might get an access failure, or some specific file may not
	// support a specific attribute.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	QuerySettableAttributes(cancellable Cancellable) (*FileAttributeInfoList, error)
	// QueryWritableNamespaces: obtain the list of attribute namespaces where
	// new attributes can be created by a user. An example of this is extended
	// attributes (in the "xattr" namespace).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	QueryWritableNamespaces(cancellable Cancellable) (*FileAttributeInfoList, error)
	// ReadFinish finishes an asynchronous file read operation started with
	// g_file_read_async().
	ReadFinish(res AsyncResult) (FileInputStream, error)
	// ReadFn opens a file for reading. The result is a InputStream that can be
	// used to read the contents of the file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
	// will be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on.
	ReadFn(cancellable Cancellable) (FileInputStream, error)
	// Replace returns an output stream for overwriting the file, possibly
	// creating a backup copy of the file first. If the file doesn't exist, it
	// will be created.
	//
	// This will try to replace the file in the safest way possible so that any
	// errors during the writing will not affect an already existing copy of the
	// file. For instance, for local files it may write to a temporary file and
	// then atomically rename over the destination when the stream is closed.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If you pass in a non-nil @etag value and @file already exists, then this
	// value is compared to the current entity tag of the file, and if they
	// differ an G_IO_ERROR_WRONG_ETAG error is returned. This generally means
	// that the file has been changed since you last read it. You can get the
	// new etag from g_file_output_stream_get_etag() after you've finished
	// writing and closed the OutputStream. When you load a new file you can use
	// g_file_input_stream_query_info() to get the etag of the file.
	//
	// If @make_backup is true, this function will attempt to make a backup of
	// the current file before overwriting it. If this fails a
	// G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you want to
	// replace anyway, try again with @make_backup set to false.
	//
	// If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be
	// returned, and if the file is some other form of non-regular file then a
	// G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some file systems
	// don't allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME
	// error, and if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
	Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error)
	// ReplaceFinish finishes an asynchronous file replace operation started
	// with g_file_replace_async().
	ReplaceFinish(res AsyncResult) (FileOutputStream, error)
	// ReplaceReadwrite returns an output stream for overwriting the file in
	// readwrite mode, possibly creating a backup copy of the file first. If the
	// file doesn't exist, it will be created.
	//
	// For details about the behaviour, see g_file_replace() which does the same
	// thing but returns an output stream only.
	//
	// Note that in many non-local file cases read and write streams are not
	// supported, so make sure you really need to do read and write streaming,
	// rather than just opening for reading or writing.
	ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error)
	// ReplaceReadwriteFinish finishes an asynchronous file replace operation
	// started with g_file_replace_readwrite_async().
	ReplaceReadwriteFinish(res AsyncResult) (FileIOStream, error)
	// ResolveRelativePath resolves a relative path for @file to an absolute
	// path.
	//
	// This call does no blocking I/O.
	ResolveRelativePath(relativePath string) File
	// SetAttributesFinish finishes setting an attribute started in
	// g_file_set_attributes_async().
	SetAttributesFinish(result AsyncResult) (FileInfo, error)
	// SetAttributesFromInfo tries to set all attributes in the Info on the
	// target values, not stopping on the first error.
	//
	// If there is any error during this operation then @error will be set to
	// the first error. Error on particular fields are flagged by setting the
	// "status" field in the attribute value to
	// G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect
	// further errors.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributesFromInfo(info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetDisplayName renames @file to the specified display name.
	//
	// The display name is converted from UTF-8 to the correct encoding for the
	// target filesystem if possible and the @file is renamed to this.
	//
	// If you want to implement a rename operation in the user interface the
	// edit name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
	// initial value in the rename widget, and then the result after editing
	// should be passed to g_file_set_display_name().
	//
	// On success the resulting converted filename is returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetDisplayName(displayName string, cancellable Cancellable) (File, error)
	// SetDisplayNameFinish finishes setting a display name started with
	// g_file_set_display_name_async().
	SetDisplayNameFinish(res AsyncResult) (File, error)
	// StartMountableFinish finishes a start operation. See
	// g_file_start_mountable() for details.
	//
	// Finish an asynchronous start operation that was started with
	// g_file_start_mountable().
	StartMountableFinish(result AsyncResult) error
	// StopMountableFinish finishes a stop operation, see
	// g_file_stop_mountable() for details.
	//
	// Finish an asynchronous stop operation that was started with
	// g_file_stop_mountable().
	StopMountableFinish(result AsyncResult) error
	// Trash sends @file to the "Trashcan", if possible. This is similar to
	// deleting it, but the user can recover it before emptying the trashcan.
	// Not all file systems support trashing, so this call can return the
	// G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash`
	// unix mount option can be used to disable g_file_trash() support for
	// certain mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in
	// that case.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Trash(cancellable Cancellable) error
	// TrashFinish finishes an asynchronous file trashing operation, started
	// with g_file_trash_async().
	TrashFinish(result AsyncResult) error
	// UnmountMountableFinish finishes an unmount operation, see
	// g_file_unmount_mountable() for details.
	//
	// Finish an asynchronous unmount operation that was started with
	// g_file_unmount_mountable().
	UnmountMountableFinish(result AsyncResult) error
	// UnmountMountableWithOperationFinish finishes an unmount operation, see
	// g_file_unmount_mountable_with_operation() for details.
	//
	// Finish an asynchronous unmount operation that was started with
	// g_file_unmount_mountable_with_operation().
	UnmountMountableWithOperationFinish(result AsyncResult) error
}

// File is a high level abstraction for manipulating files on a virtual file
// system. #GFiles are lightweight, immutable objects that do no I/O upon
// creation. It is necessary to understand that #GFile objects do not represent
// files, merely an identifier for a file. All file content I/O is implemented
// as streaming operations (see Stream and Stream).
//
// To construct a #GFile, you can use: - g_file_new_for_path() if you have a
// path. - g_file_new_for_uri() if you have a URI. -
// g_file_new_for_commandline_arg() for a command line argument. -
// g_file_new_tmp() to create a temporary file from a template. -
// g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
// - g_file_new_build_filename() to create a file from path elements.
//
// One way to think of a #GFile is as an abstraction of a pathname. For normal
// files the system pathname is what is stored internally, but as #GFiles are
// extensible it could also be something else that corresponds to a pathname in
// a userspace implementation of a filesystem.
//
// #GFiles make up hierarchies of directories and files that correspond to the
// files on a filesystem. You can move through the file system with #GFile using
// g_file_get_parent() to get an identifier for the parent directory,
// g_file_get_child() to get a child within a directory,
// g_file_resolve_relative_path() to resolve a relative path between two
// #GFiles. There can be multiple hierarchies, so you may not end up at the same
// root if you repeatedly call g_file_get_parent() on two different files.
//
// All #GFiles have a basename (get with g_file_get_basename()). These names are
// byte strings that are used to identify the file on the filesystem (relative
// to its parent directory) and there is no guarantees that they have any
// particular charset encoding or even make any sense at all. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info(). This is guaranteed to be in UTF-8 and can be used in a
// user interface. But always store the real basename or the #GFile to use to
// actually access the file, because there is no way to go from a display name
// to the actual name.
//
// Using #GFile as an identifier has the same weaknesses as using a path in that
// there may be multiple aliases for the same file. For instance, hard or soft
// links may cause two different #GFiles to refer to the same file. Other
// possible causes for aliases are: case insensitive filesystems, short and long
// names on FAT/NTFS, or bind mounts in Linux. If you want to check if two
// #GFiles point to the same file you can query for the G_FILE_ATTRIBUTE_ID_FILE
// attribute. Note that #GFile does some trivial canonicalization of pathnames
// passed in, so that trivial differences in the path string used at creation
// (duplicated slashes, slash at end of path, "." or ".." path segments, etc)
// does not create different #GFiles.
//
// Many #GFile operations have both synchronous and asynchronous versions to
// suit your application. Asynchronous versions of synchronous functions simply
// have _async() appended to their function names. The asynchronous I/O
// functions call a ReadyCallback which is then used to finalize the operation,
// producing a GAsyncResult which is then passed to the function's matching
// _finish() operation.
//
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section][async-programming] for
// more.
//
// Some #GFile operations almost always take a noticeable amount of time, and so
// do not have synchronous analogs. Notable cases include: -
// g_file_mount_mountable() to mount a mountable file. -
// g_file_unmount_mountable_with_operation() to unmount a mountable file. -
// g_file_eject_mountable_with_operation() to eject a mountable file.
//
//
// Entity Tags
//
// One notable feature of #GFiles are entity tags, or "etags" for short. Entity
// tags are somewhat like a more abstract version of the traditional mtime, and
// can be used to quickly determine if the file has been modified from the
// version on the file system. See the HTTP 1.1 specification
// (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) for HTTP Etag
// headers, which are a very similar concept.
type File interface {
	gextras.Objector

	// AppendTo gets an output stream for appending data to the file. If the
	// file doesn't already exist it is created.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// Some file systems don't allow all file names, and may return an
	// G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
	// G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible
	// too, and depend on what kind of filesystem the file is on.
	AppendTo(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error)
	// AppendToFinish finishes an asynchronous file append operation started
	// with g_file_append_to_async().
	AppendToFinish(res AsyncResult) (FileOutputStream, error)
	// BuildAttributeListForCopy prepares the file attribute query string for
	// copying to @file.
	//
	// This function prepares an attribute query string to be passed to
	// g_file_query_info() to get a list of attributes normally copied with the
	// file (see g_file_copy_attributes() for the detailed description). This
	// function is used by the implementation of g_file_copy_attributes() and is
	// useful when one needs to query and set the attributes in two stages
	// (e.g., for recursive move of a directory).
	BuildAttributeListForCopy(flags FileCopyFlags, cancellable Cancellable) (string, error)
	// CopyAttributes copies the file attributes from @source to @destination.
	//
	// Normally only a subset of the file attributes are copied, those that are
	// copies in a normal file copy operation (which for instance does not
	// include e.g. owner). However if FILE_COPY_ALL_METADATA is specified in
	// @flags, then all the metadata that is possible to copy is copied. This is
	// useful when implementing move by copy + delete source.
	CopyAttributes(destination File, flags FileCopyFlags, cancellable Cancellable) error
	// CopyFinish finishes copying the file started with g_file_copy_async().
	CopyFinish(res AsyncResult) error
	// Create creates a new file and returns an output stream for writing to it.
	// The file must not already exist.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If a file or directory with this name already exists the
	// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
	// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
	// if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
	// Other errors are possible too, and depend on what kind of filesystem the
	// file is on.
	Create(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error)
	// CreateFinish finishes an asynchronous file create operation started with
	// g_file_create_async().
	CreateFinish(res AsyncResult) (FileOutputStream, error)
	// CreateReadwrite creates a new file and returns a stream for reading and
	// writing to it. The file must not already exist.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If a file or directory with this name already exists, the
	// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
	// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
	// if the name is too long, G_IO_ERROR_FILENAME_TOO_LONG will be returned.
	// Other errors are possible too, and depend on what kind of filesystem the
	// file is on.
	//
	// Note that in many non-local file cases read and write streams are not
	// supported, so make sure you really need to do read and write streaming,
	// rather than just opening for reading or writing.
	CreateReadwrite(flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error)
	// CreateReadwriteFinish finishes an asynchronous file create operation
	// started with g_file_create_readwrite_async().
	CreateReadwriteFinish(res AsyncResult) (FileIOStream, error)
	// Delete deletes a file. If the @file is a directory, it will only be
	// deleted if it is empty. This has the same semantics as g_unlink().
	//
	// If @file doesnt exist, G_IO_ERROR_NOT_FOUND will be returned. This
	// allows for deletion to be implemented avoiding time-of-check to
	// time-of-use races
	// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
	//
	//    g_autoptr(GError) local_error = NULL;
	//    if (!g_file_delete (my_file, my_cancellable, &local_error) &&
	//        !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
	//      {
	//        // deletion failed for some reason other than the file not existing:
	//        // so report the error
	//        g_warning ("Failed to delete s: s",
	//                   g_file_peek_path (my_file), local_error->message);
	//      }
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Delete(cancellable Cancellable) error
	// DeleteFinish finishes deleting a file started with g_file_delete_async().
	DeleteFinish(result AsyncResult) error
	// Dup duplicates a #GFile handle. This operation does not duplicate the
	// actual file or directory represented by the #GFile; see g_file_copy() if
	// attempting to copy a file.
	//
	// g_file_dup() is useful when a second handle is needed to the same
	// underlying file, for use in a separate thread (#GFile is not
	// thread-safe). For use within the same thread, use g_object_ref() to
	// increment the existing objects reference count.
	//
	// This call does no blocking I/O.
	Dup() File
	// EjectMountableFinish finishes an asynchronous eject operation started by
	// g_file_eject_mountable().
	EjectMountableFinish(result AsyncResult) error
	// EjectMountableWithOperationFinish finishes an asynchronous eject
	// operation started by g_file_eject_mountable_with_operation().
	EjectMountableWithOperationFinish(result AsyncResult) error
	// EnumerateChildren gets the requested information about the files in a
	// directory. The result is a Enumerator object that will give out Info
	// objects for all the files in the directory.
	//
	// The @attributes value is a string that specifies the file attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "standard::*" means all attributes in the standard namespace. An example
	// attribute query be "standard::*,owner::user". The standard attributes are
	// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is not a directory, the G_IO_ERROR_NOT_DIRECTORY
	// error will be returned. Other errors are possible too.
	EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileEnumerator, error)
	// EnumerateChildrenFinish finishes an async enumerate children operation.
	// See g_file_enumerate_children_async().
	EnumerateChildrenFinish(res AsyncResult) (FileEnumerator, error)
	// Equal checks if the two given #GFiles refer to the same file.
	//
	// Note that two #GFiles that differ can still refer to the same file on the
	// filesystem due to various forms of filename aliasing.
	//
	// This call does no blocking I/O.
	Equal(file2 File) bool
	// FindEnclosingMount gets a #GMount for the #GFile.
	//
	// #GMount is returned only for user interesting locations, see Monitor. If
	// the Iface for @file does not have a #mount, @error will be set to
	// G_IO_ERROR_NOT_FOUND and nil #will be returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	FindEnclosingMount(cancellable Cancellable) (Mount, error)
	// FindEnclosingMountFinish finishes an asynchronous find mount request. See
	// g_file_find_enclosing_mount_async().
	FindEnclosingMountFinish(res AsyncResult) (Mount, error)
	// Basename gets the base name (the last component of the path) for a given
	// #GFile.
	//
	// If called for the top level of a system (such as the filesystem root or a
	// uri like sftp://host/) it will return a single directory separator (and
	// on Windows, possibly a drive letter).
	//
	// The base name is a byte string (not UTF-8). It has no defined encoding or
	// rules other than it may not contain zero bytes. If you want to use
	// filenames in a user interface you should use the display name that you
	// can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
	// attribute with g_file_query_info().
	//
	// This call does no blocking I/O.
	Basename() string
	// Child gets a child of @file with basename equal to @name.
	//
	// Note that the file with that specific name might not exist, but you can
	// still have a #GFile that points to it. You can use this for instance to
	// create that file.
	//
	// This call does no blocking I/O.
	Child(name string) File
	// ChildForDisplayName gets the child of @file for a given @display_name
	// (i.e. a UTF-8 version of the name). If this function fails, it returns
	// nil and @error will be set. This is very useful when constructing a
	// #GFile for a new file and the user entered the filename in the user
	// interface, for instance when you select a directory and type a filename
	// in the file selector.
	//
	// This call does no blocking I/O.
	ChildForDisplayName(displayName string) (File, error)
	// Parent gets the parent directory for the @file. If the @file represents
	// the root directory of the file system, then nil will be returned.
	//
	// This call does no blocking I/O.
	Parent() File
	// ParseName gets the parse name of the @file. A parse name is a UTF-8
	// string that describes the file such that one can get the #GFile back
	// using g_file_parse_name().
	//
	// This is generally used to show the #GFile as a nice full-pathname kind of
	// string in a user interface, like in a location entry.
	//
	// For local files with names that can safely be converted to UTF-8 the
	// pathname is used, otherwise the IRI is used (a form of URI that allows
	// UTF-8 characters unescaped).
	//
	// This call does no blocking I/O.
	ParseName() string
	// Path gets the local pathname for #GFile, if one exists. If non-nil, this
	// is guaranteed to be an absolute, canonical path. It might contain
	// symlinks.
	//
	// This call does no blocking I/O.
	Path() string
	// RelativePath gets the path for @descendant relative to @parent.
	//
	// This call does no blocking I/O.
	RelativePath(descendant File) string
	// URI gets the URI for the @file.
	//
	// This call does no blocking I/O.
	URI() string
	// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme
	// as:
	//
	//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
	//
	// Common schemes include "file", "http", "ftp", etc.
	//
	// The scheme can be different from the one used to construct the #GFile, in
	// that it might be replaced with one that is logically equivalent to the
	// #GFile.
	//
	// This call does no blocking I/O.
	URIScheme() string
	// HasParent checks if @file has a parent, and optionally, if it is @parent.
	//
	// If @parent is nil then this function returns true if @file has any parent
	// at all. If @parent is non-nil then true is only returned if @file is an
	// immediate child of @parent.
	HasParent(parent File) bool
	// HasPrefix checks whether @file has the prefix specified by @prefix.
	//
	// In other words, if the names of initial elements of @file's pathname
	// match @prefix. Only full pathname elements are matched, so a path like
	// /foo is not considered a prefix of /foobar, only of /foo/bar.
	//
	// A #GFile is not a prefix of itself. If you want to check for equality,
	// use g_file_equal().
	//
	// This call does no I/O, as it works purely on names. As such it can
	// sometimes return false even if @file is inside a @prefix (from a
	// filesystem point of view), because the prefix of @file is an alias of
	// @prefix.
	HasPrefix(prefix File) bool
	// HasURIScheme checks to see if a #GFile has a given URI scheme.
	//
	// This call does no blocking I/O.
	HasURIScheme(uriScheme string) bool
	// Hash creates a hash value for a #GFile.
	//
	// This call does no blocking I/O.
	Hash() uint
	// IsNative checks to see if a file is native to the platform.
	//
	// A native file is one expressed in the platform-native filename format,
	// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
	// as it might be on a locally mounted remote filesystem.
	//
	// On some systems non-native files may be available using the native
	// filesystem via a userspace filesystem (FUSE), in these cases this call
	// will return false, but g_file_get_path() will still return a native path.
	//
	// This call does no blocking I/O.
	IsNative() bool
	// LoadContents loads the content of the file into memory. The data is
	// always zero-terminated, but this is not included in the resultant
	// @length. The returned @contents should be freed with g_free() when no
	// longer needed.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	LoadContents(cancellable Cancellable) ([]byte, string, error)
	// LoadContentsFinish finishes an asynchronous load of the @file's contents.
	// The contents are placed in @contents, and @length is set to the size of
	// the @contents string. The @contents should be freed with g_free() when no
	// longer needed. If @etag_out is present, it will be set to the new entity
	// tag for the @file.
	LoadContentsFinish(res AsyncResult) ([]byte, string, error)
	// LoadPartialContentsFinish finishes an asynchronous partial load operation
	// that was started with g_file_load_partial_contents_async(). The data is
	// always zero-terminated, but this is not included in the resultant
	// @length. The returned @contents should be freed with g_free() when no
	// longer needed.
	LoadPartialContentsFinish(res AsyncResult) ([]byte, string, error)
	// MakeDirectory creates a directory. Note that this will only create a
	// child directory of the immediate parent directory of the path or URI
	// given by the #GFile. To recursively create directories, see
	// g_file_make_directory_with_parents(). This function will fail if the
	// parent directory does not exist, setting @error to G_IO_ERROR_NOT_FOUND.
	// If the file system doesn't support creating directories, this function
	// will fail, setting @error to G_IO_ERROR_NOT_SUPPORTED.
	//
	// For a local #GFile the newly created directory will have the default
	// (current) ownership and permissions of the current process.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	MakeDirectory(cancellable Cancellable) error
	// MakeDirectoryFinish finishes an asynchronous directory creation, started
	// with g_file_make_directory_async().
	MakeDirectoryFinish(result AsyncResult) error
	// MakeDirectoryWithParents creates a directory and any parent directories
	// that may not exist similar to 'mkdir -p'. If the file system does not
	// support creating directories, this function will fail, setting @error to
	// G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists, this
	// function will fail setting @error to G_IO_ERROR_EXISTS, unlike the
	// similar g_mkdir_with_parents().
	//
	// For a local #GFile the newly created directories will have the default
	// (current) ownership and permissions of the current process.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	MakeDirectoryWithParents(cancellable Cancellable) error
	// MakeSymbolicLink creates a symbolic link named @file which contains the
	// string @symlink_value.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	MakeSymbolicLink(symlinkValue string, cancellable Cancellable) error
	// MeasureDiskUsageFinish collects the results from an earlier call to
	// g_file_measure_disk_usage_async(). See g_file_measure_disk_usage() for
	// more information.
	MeasureDiskUsageFinish(result AsyncResult) (diskUsage uint64, numDirs uint64, numFiles uint64, goerr error)
	// Monitor obtains a file or directory monitor for the given file, depending
	// on the type of the file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Monitor(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error)
	// MonitorDirectory obtains a directory monitor for the given file. This may
	// fail if directory monitoring is not supported.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// It does not make sense for @flags to contain
	// G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
	// directories. It is not possible to monitor all the files in a directory
	// for changes made via hard links; if you want to do this then you must
	// register individual watches with g_file_monitor().
	MonitorDirectory(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error)
	// MonitorFile obtains a file monitor for the given file. If no file
	// notification mechanism exists, then regular polling of the file is used.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If @flags contains G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor will
	// also attempt to report changes made to the file via another filename (ie,
	// a hard link). Without this flag, you can only rely on changes made
	// through the filename contained in @file to be reported. Using this flag
	// may result in an increase in resource usage, and may not have any effect
	// depending on the Monitor backend and/or filesystem type.
	MonitorFile(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error)
	// MountEnclosingVolumeFinish finishes a mount operation started by
	// g_file_mount_enclosing_volume().
	MountEnclosingVolumeFinish(result AsyncResult) error
	// MountMountableFinish finishes a mount operation. See
	// g_file_mount_mountable() for details.
	//
	// Finish an asynchronous mount operation that was started with
	// g_file_mount_mountable().
	MountMountableFinish(result AsyncResult) (File, error)
	// OpenReadwrite opens an existing file for reading and writing. The result
	// is a IOStream that can be used to read and write the contents of the
	// file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
	// will be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on. Note that in many non-local file cases read
	// and write streams are not supported, so make sure you really need to do
	// read and write streaming, rather than just opening for reading or
	// writing.
	OpenReadwrite(cancellable Cancellable) (FileIOStream, error)
	// OpenReadwriteFinish finishes an asynchronous file read operation started
	// with g_file_open_readwrite_async().
	OpenReadwriteFinish(res AsyncResult) (FileIOStream, error)
	// PeekPath: exactly like g_file_get_path(), but caches the result via
	// g_object_set_qdata_full(). This is useful for example in C applications
	// which mix `g_file_*` APIs with native ones. It also avoids an extra
	// duplicated string when possible, so will be generally more efficient.
	//
	// This call does no blocking I/O.
	PeekPath() string
	// PollMountableFinish finishes a poll operation. See
	// g_file_poll_mountable() for details.
	//
	// Finish an asynchronous poll operation that was polled with
	// g_file_poll_mountable().
	PollMountableFinish(result AsyncResult) error
	// QueryDefaultHandler returns the Info that is registered as the default
	// application to handle the file specified by @file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	QueryDefaultHandler(cancellable Cancellable) (AppInfo, error)
	// QueryDefaultHandlerFinish finishes a g_file_query_default_handler_async()
	// operation.
	QueryDefaultHandlerFinish(result AsyncResult) (AppInfo, error)
	// QueryExists: utility function to check if a particular file exists. This
	// is implemented using g_file_query_info() and as such does blocking I/O.
	//
	// Note that in many cases it is racy to first check for file existence
	// (https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) and then
	// execute something based on the outcome of that, because the file might
	// have been created or removed in between the operations. The general
	// approach to handling that is to not check, but just do the operation and
	// handle the errors as they come.
	//
	// As an example of race-free checking, take the case of reading a file, and
	// if it doesn't exist, creating it. There are two racy versions: read it,
	// and on error create it; and: check if it exists, if not create it. These
	// can both result in two processes creating the file (with perhaps a
	// partially written file as the result). The correct approach is to always
	// try to create the file with g_file_create() which will either atomically
	// create the file or fail with a G_IO_ERROR_EXISTS error.
	//
	// However, in many cases an existence check is useful in a user interface,
	// for instance to make a menu item sensitive/insensitive, so that you don't
	// have to fool users that something is possible and then just show an error
	// dialog. If you do this, you should make sure to also handle the errors
	// that can happen due to races when you execute the operation.
	QueryExists(cancellable Cancellable) bool
	// QueryFileType: utility function to inspect the Type of a file. This is
	// implemented using g_file_query_info() and as such does blocking I/O.
	//
	// The primary use case of this method is to check if a file is a regular
	// file, directory, or symlink.
	QueryFileType(flags FileQueryInfoFlags, cancellable Cancellable) FileType
	// QueryFilesystemInfo: similar to g_file_query_info(), but obtains
	// information about the filesystem the @file is on, rather than the file
	// itself. For instance the amount of space available and the type of the
	// filesystem.
	//
	// The @attributes value is a string that specifies the attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "filesystem::*" means all attributes in the filesystem namespace. The
	// standard namespace for filesystem attributes is "filesystem". Common
	// attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size
	// of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of
	// bytes available), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the
	// filesystem).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
	QueryFilesystemInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query.
	// See g_file_query_filesystem_info_async().
	QueryFilesystemInfoFinish(res AsyncResult) (FileInfo, error)
	// QueryInfo gets the requested information about specified @file. The
	// result is a Info object that contains key-value attributes (such as the
	// type or size of the file).
	//
	// The @attributes value is a string that specifies the file attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "standard::*" means all attributes in the standard namespace. An example
	// attribute query be "standard::*,owner::user". The standard attributes are
	// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// For symlinks, normally the information about the target of the symlink is
	// returned, rather than information about the symlink itself. However if
	// you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in @flags the information
	// about the symlink itself will be returned. Also, for symlinks that point
	// to non-existing files the information about the symlink itself will be
	// returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
	QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileInfo, error)
	// QueryInfoFinish finishes an asynchronous file info query. See
	// g_file_query_info_async().
	QueryInfoFinish(res AsyncResult) (FileInfo, error)
	// QuerySettableAttributes: obtain the list of settable attributes for the
	// file.
	//
	// Returns the type and full attribute name of all the attributes that can
	// be set on this file. This doesn't mean setting it will always succeed
	// though, you might get an access failure, or some specific file may not
	// support a specific attribute.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	QuerySettableAttributes(cancellable Cancellable) (*FileAttributeInfoList, error)
	// QueryWritableNamespaces: obtain the list of attribute namespaces where
	// new attributes can be created by a user. An example of this is extended
	// attributes (in the "xattr" namespace).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	QueryWritableNamespaces(cancellable Cancellable) (*FileAttributeInfoList, error)
	// Read opens a file for reading. The result is a InputStream that can be
	// used to read the contents of the file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
	// will be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on.
	Read(cancellable Cancellable) (FileInputStream, error)
	// ReadFinish finishes an asynchronous file read operation started with
	// g_file_read_async().
	ReadFinish(res AsyncResult) (FileInputStream, error)
	// Replace returns an output stream for overwriting the file, possibly
	// creating a backup copy of the file first. If the file doesn't exist, it
	// will be created.
	//
	// This will try to replace the file in the safest way possible so that any
	// errors during the writing will not affect an already existing copy of the
	// file. For instance, for local files it may write to a temporary file and
	// then atomically rename over the destination when the stream is closed.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If you pass in a non-nil @etag value and @file already exists, then this
	// value is compared to the current entity tag of the file, and if they
	// differ an G_IO_ERROR_WRONG_ETAG error is returned. This generally means
	// that the file has been changed since you last read it. You can get the
	// new etag from g_file_output_stream_get_etag() after you've finished
	// writing and closed the OutputStream. When you load a new file you can use
	// g_file_input_stream_query_info() to get the etag of the file.
	//
	// If @make_backup is true, this function will attempt to make a backup of
	// the current file before overwriting it. If this fails a
	// G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you want to
	// replace anyway, try again with @make_backup set to false.
	//
	// If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be
	// returned, and if the file is some other form of non-regular file then a
	// G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some file systems
	// don't allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME
	// error, and if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
	Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error)
	// ReplaceContents replaces the contents of @file with @contents of @length
	// bytes.
	//
	// If @etag is specified (not nil), any existing file must have that etag,
	// or the error G_IO_ERROR_WRONG_ETAG will be returned.
	//
	// If @make_backup is true, this function will attempt to make a backup of
	// @file. Internally, it uses g_file_replace(), so will try to replace the
	// file contents in the safest way possible. For example, atomic renames are
	// used when replacing local files contents.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// The returned @new_etag can be used to verify that the file hasn't changed
	// the next time it is saved over.
	ReplaceContents(contents []byte, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (string, error)
	// ReplaceContentsFinish finishes an asynchronous replace of the given
	// @file. See g_file_replace_contents_async(). Sets @new_etag to the new
	// entity tag for the document, if present.
	ReplaceContentsFinish(res AsyncResult) (string, error)
	// ReplaceFinish finishes an asynchronous file replace operation started
	// with g_file_replace_async().
	ReplaceFinish(res AsyncResult) (FileOutputStream, error)
	// ReplaceReadwrite returns an output stream for overwriting the file in
	// readwrite mode, possibly creating a backup copy of the file first. If the
	// file doesn't exist, it will be created.
	//
	// For details about the behaviour, see g_file_replace() which does the same
	// thing but returns an output stream only.
	//
	// Note that in many non-local file cases read and write streams are not
	// supported, so make sure you really need to do read and write streaming,
	// rather than just opening for reading or writing.
	ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error)
	// ReplaceReadwriteFinish finishes an asynchronous file replace operation
	// started with g_file_replace_readwrite_async().
	ReplaceReadwriteFinish(res AsyncResult) (FileIOStream, error)
	// ResolveRelativePath resolves a relative path for @file to an absolute
	// path.
	//
	// This call does no blocking I/O.
	ResolveRelativePath(relativePath string) File
	// SetAttributeByteString sets @attribute of type
	// G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value. If @attribute is of a
	// different type, this operation will fail, returning false.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeInt32 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_INT32 to
	// @value. If @attribute is of a different type, this operation will fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeInt64 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_INT64 to
	// @value. If @attribute is of a different type, this operation will fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeString sets @attribute of type G_FILE_ATTRIBUTE_TYPE_STRING
	// to @value. If @attribute is of a different type, this operation will
	// fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeUint32 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_UINT32
	// to @value. If @attribute is of a different type, this operation will
	// fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeUint64 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_UINT64
	// to @value. If @attribute is of a different type, this operation will
	// fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributesFinish finishes setting an attribute started in
	// g_file_set_attributes_async().
	SetAttributesFinish(result AsyncResult) (FileInfo, error)
	// SetAttributesFromInfo tries to set all attributes in the Info on the
	// target values, not stopping on the first error.
	//
	// If there is any error during this operation then @error will be set to
	// the first error. Error on particular fields are flagged by setting the
	// "status" field in the attribute value to
	// G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect
	// further errors.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributesFromInfo(info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetDisplayName renames @file to the specified display name.
	//
	// The display name is converted from UTF-8 to the correct encoding for the
	// target filesystem if possible and the @file is renamed to this.
	//
	// If you want to implement a rename operation in the user interface the
	// edit name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
	// initial value in the rename widget, and then the result after editing
	// should be passed to g_file_set_display_name().
	//
	// On success the resulting converted filename is returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetDisplayName(displayName string, cancellable Cancellable) (File, error)
	// SetDisplayNameFinish finishes setting a display name started with
	// g_file_set_display_name_async().
	SetDisplayNameFinish(res AsyncResult) (File, error)
	// StartMountableFinish finishes a start operation. See
	// g_file_start_mountable() for details.
	//
	// Finish an asynchronous start operation that was started with
	// g_file_start_mountable().
	StartMountableFinish(result AsyncResult) error
	// StopMountableFinish finishes a stop operation, see
	// g_file_stop_mountable() for details.
	//
	// Finish an asynchronous stop operation that was started with
	// g_file_stop_mountable().
	StopMountableFinish(result AsyncResult) error
	// SupportsThreadContexts checks if @file supports [thread-default
	// contexts][g-main-context-push-thread-default-context]. If this returns
	// false, you cannot perform asynchronous operations on @file in a thread
	// that has a thread-default context.
	SupportsThreadContexts() bool
	// Trash sends @file to the "Trashcan", if possible. This is similar to
	// deleting it, but the user can recover it before emptying the trashcan.
	// Not all file systems support trashing, so this call can return the
	// G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash`
	// unix mount option can be used to disable g_file_trash() support for
	// certain mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in
	// that case.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Trash(cancellable Cancellable) error
	// TrashFinish finishes an asynchronous file trashing operation, started
	// with g_file_trash_async().
	TrashFinish(result AsyncResult) error
	// UnmountMountableFinish finishes an unmount operation, see
	// g_file_unmount_mountable() for details.
	//
	// Finish an asynchronous unmount operation that was started with
	// g_file_unmount_mountable().
	UnmountMountableFinish(result AsyncResult) error
	// UnmountMountableWithOperationFinish finishes an unmount operation, see
	// g_file_unmount_mountable_with_operation() for details.
	//
	// Finish an asynchronous unmount operation that was started with
	// g_file_unmount_mountable_with_operation().
	UnmountMountableWithOperationFinish(result AsyncResult) error
}

// file implements the File interface.
type file struct {
	gextras.Objector
}

var _ File = (*file)(nil)

// WrapFile wraps a GObject to a type that implements interface
// File. It is primarily used internally.
func WrapFile(obj *externglib.Object) File {
	return file{
		Objector: obj,
	}
}

func marshalFile(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFile(obj), nil
}

func (f file) AppendTo(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg1 C.GFileCreateFlags   // out
	var _arg2 *C.GCancellable      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GFileCreateFlags)(flags)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_append_to(_arg0, _arg1, _arg2, &_cerr)

	var _fileOutputStream FileOutputStream // out
	var _goerr error                       // out

	_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileOutputStream, _goerr
}

func (f file) AppendToFinish(res AsyncResult) (FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_append_to_finish(_arg0, _arg1, &_cerr)

	var _fileOutputStream FileOutputStream // out
	var _goerr error                       // out

	_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileOutputStream, _goerr
}

func (f file) BuildAttributeListForCopy(flags FileCopyFlags, cancellable Cancellable) (string, error) {
	var _arg0 *C.GFile         // out
	var _arg1 C.GFileCopyFlags // out
	var _arg2 *C.GCancellable  // out
	var _cret *C.char          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GFileCopyFlags)(flags)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_build_attribute_list_for_copy(_arg0, _arg1, _arg2, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

func (s file) CopyAttributes(destination File, flags FileCopyFlags, cancellable Cancellable) error {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GFile         // out
	var _arg2 C.GFileCopyFlags // out
	var _arg3 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(destination.Native()))
	_arg2 = (C.GFileCopyFlags)(flags)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_copy_attributes(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) CopyFinish(res AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_file_copy_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) Create(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg1 C.GFileCreateFlags   // out
	var _arg2 *C.GCancellable      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GFileCreateFlags)(flags)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_create(_arg0, _arg1, _arg2, &_cerr)

	var _fileOutputStream FileOutputStream // out
	var _goerr error                       // out

	_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileOutputStream, _goerr
}

func (f file) CreateFinish(res AsyncResult) (FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_create_finish(_arg0, _arg1, &_cerr)

	var _fileOutputStream FileOutputStream // out
	var _goerr error                       // out

	_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileOutputStream, _goerr
}

func (f file) CreateReadwrite(flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error) {
	var _arg0 *C.GFile           // out
	var _arg1 C.GFileCreateFlags // out
	var _arg2 *C.GCancellable    // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GFileCreateFlags)(flags)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_create_readwrite(_arg0, _arg1, _arg2, &_cerr)

	var _fileIOStream FileIOStream // out
	var _goerr error               // out

	_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileIOStream, _goerr
}

func (f file) CreateReadwriteFinish(res AsyncResult) (FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_create_readwrite_finish(_arg0, _arg1, &_cerr)

	var _fileIOStream FileIOStream // out
	var _goerr error               // out

	_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileIOStream, _goerr
}

func (f file) Delete(cancellable Cancellable) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_delete(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) DeleteFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_delete_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) Dup() File {
	var _arg0 *C.GFile // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_dup(_arg0)

	var _ret File // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _ret
}

func (f file) EjectMountableFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_eject_mountable_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) EjectMountableWithOperationFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_eject_mountable_with_operation_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileEnumerator, error) {
	var _arg0 *C.GFile              // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _arg3 *C.GCancellable       // out
	var _cret *C.GFileEnumerator    // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GFileQueryInfoFlags)(flags)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_enumerate_children(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _fileEnumerator FileEnumerator // out
	var _goerr error                   // out

	_fileEnumerator = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileEnumerator)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileEnumerator, _goerr
}

func (f file) EnumerateChildrenFinish(res AsyncResult) (FileEnumerator, error) {
	var _arg0 *C.GFile           // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GFileEnumerator // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_enumerate_children_finish(_arg0, _arg1, &_cerr)

	var _fileEnumerator FileEnumerator // out
	var _goerr error                   // out

	_fileEnumerator = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileEnumerator)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileEnumerator, _goerr
}

func (f file) Equal(file2 File) bool {
	var _arg0 *C.GFile   // out
	var _arg1 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file2.Native()))

	_cret = C.g_file_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f file) FindEnclosingMount(cancellable Cancellable) (Mount, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cret *C.GMount       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_find_enclosing_mount(_arg0, _arg1, &_cerr)

	var _mount Mount // out
	var _goerr error // out

	_mount = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Mount)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _mount, _goerr
}

func (f file) FindEnclosingMountFinish(res AsyncResult) (Mount, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GMount       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_find_enclosing_mount_finish(_arg0, _arg1, &_cerr)

	var _mount Mount // out
	var _goerr error // out

	_mount = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Mount)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _mount, _goerr
}

func (f file) Basename() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_get_basename(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

func (f file) Child(name string) File {
	var _arg0 *C.GFile // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_get_child(_arg0, _arg1)

	var _ret File // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _ret
}

func (f file) ChildForDisplayName(displayName string) (File, error) {
	var _arg0 *C.GFile  // out
	var _arg1 *C.char   // out
	var _cret *C.GFile  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(displayName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_get_child_for_display_name(_arg0, _arg1, &_cerr)

	var _ret File    // out
	var _goerr error // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ret, _goerr
}

func (f file) Parent() File {
	var _arg0 *C.GFile // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_get_parent(_arg0)

	var _ret File // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _ret
}

func (f file) ParseName() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_get_parse_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (f file) Path() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_get_path(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

func (p file) RelativePath(descendant File) string {
	var _arg0 *C.GFile // out
	var _arg1 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(descendant.Native()))

	_cret = C.g_file_get_relative_path(_arg0, _arg1)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

func (f file) URI() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_get_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (f file) URIScheme() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_get_uri_scheme(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (f file) HasParent(parent File) bool {
	var _arg0 *C.GFile   // out
	var _arg1 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(parent.Native()))

	_cret = C.g_file_has_parent(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f file) HasPrefix(prefix File) bool {
	var _arg0 *C.GFile   // out
	var _arg1 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(prefix.Native()))

	_cret = C.g_file_has_prefix(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f file) HasURIScheme(uriScheme string) bool {
	var _arg0 *C.GFile   // out
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(uriScheme))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_has_uri_scheme(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f file) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_hash(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (f file) IsNative() bool {
	var _arg0 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_is_native(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f file) LoadContents(cancellable Cancellable) ([]byte, string, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _arg2 *C.char
	var _arg3 C.gsize   // in
	var _arg4 *C.char   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_load_contents(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)

	var _contents []byte
	var _etagOut string // out
	var _goerr error    // out

	_contents = unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3)
	runtime.SetFinalizer(&_contents, func(v *[]byte) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	_etagOut = C.GoString(_arg4)
	defer C.free(unsafe.Pointer(_arg4))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _contents, _etagOut, _goerr
}

func (f file) LoadContentsFinish(res AsyncResult) ([]byte, string, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char
	var _arg3 C.gsize   // in
	var _arg4 *C.char   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_file_load_contents_finish(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)

	var _contents []byte
	var _etagOut string // out
	var _goerr error    // out

	_contents = unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3)
	runtime.SetFinalizer(&_contents, func(v *[]byte) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	_etagOut = C.GoString(_arg4)
	defer C.free(unsafe.Pointer(_arg4))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _contents, _etagOut, _goerr
}

func (f file) LoadPartialContentsFinish(res AsyncResult) ([]byte, string, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char
	var _arg3 C.gsize   // in
	var _arg4 *C.char   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_file_load_partial_contents_finish(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)

	var _contents []byte
	var _etagOut string // out
	var _goerr error    // out

	_contents = unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3)
	runtime.SetFinalizer(&_contents, func(v *[]byte) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	_etagOut = C.GoString(_arg4)
	defer C.free(unsafe.Pointer(_arg4))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _contents, _etagOut, _goerr
}

func (f file) MakeDirectory(cancellable Cancellable) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_make_directory(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) MakeDirectoryFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_make_directory_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) MakeDirectoryWithParents(cancellable Cancellable) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_make_directory_with_parents(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) MakeSymbolicLink(symlinkValue string, cancellable Cancellable) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.char         // out
	var _arg2 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(symlinkValue))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_make_symbolic_link(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) MeasureDiskUsageFinish(result AsyncResult) (diskUsage uint64, numDirs uint64, numFiles uint64, goerr error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.guint64       // in
	var _arg3 C.guint64       // in
	var _arg4 C.guint64       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_measure_disk_usage_finish(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)

	var _diskUsage uint64 // out
	var _numDirs uint64   // out
	var _numFiles uint64  // out
	var _goerr error      // out

	_diskUsage = (uint64)(_arg2)
	_numDirs = (uint64)(_arg3)
	_numFiles = (uint64)(_arg4)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _diskUsage, _numDirs, _numFiles, _goerr
}

func (f file) Monitor(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error) {
	var _arg0 *C.GFile            // out
	var _arg1 C.GFileMonitorFlags // out
	var _arg2 *C.GCancellable     // out
	var _cret *C.GFileMonitor     // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GFileMonitorFlags)(flags)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_monitor(_arg0, _arg1, _arg2, &_cerr)

	var _fileMonitor FileMonitor // out
	var _goerr error             // out

	_fileMonitor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileMonitor)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileMonitor, _goerr
}

func (f file) MonitorDirectory(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error) {
	var _arg0 *C.GFile            // out
	var _arg1 C.GFileMonitorFlags // out
	var _arg2 *C.GCancellable     // out
	var _cret *C.GFileMonitor     // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GFileMonitorFlags)(flags)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_monitor_directory(_arg0, _arg1, _arg2, &_cerr)

	var _fileMonitor FileMonitor // out
	var _goerr error             // out

	_fileMonitor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileMonitor)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileMonitor, _goerr
}

func (f file) MonitorFile(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error) {
	var _arg0 *C.GFile            // out
	var _arg1 C.GFileMonitorFlags // out
	var _arg2 *C.GCancellable     // out
	var _cret *C.GFileMonitor     // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GFileMonitorFlags)(flags)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_monitor_file(_arg0, _arg1, _arg2, &_cerr)

	var _fileMonitor FileMonitor // out
	var _goerr error             // out

	_fileMonitor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileMonitor)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileMonitor, _goerr
}

func (l file) MountEnclosingVolumeFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_mount_enclosing_volume_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) MountMountableFinish(result AsyncResult) (File, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_file_mount_mountable_finish(_arg0, _arg1, &_cerr)

	var _ret File    // out
	var _goerr error // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ret, _goerr
}

func (f file) OpenReadwrite(cancellable Cancellable) (FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GCancellable  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_open_readwrite(_arg0, _arg1, &_cerr)

	var _fileIOStream FileIOStream // out
	var _goerr error               // out

	_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileIOStream, _goerr
}

func (f file) OpenReadwriteFinish(res AsyncResult) (FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_open_readwrite_finish(_arg0, _arg1, &_cerr)

	var _fileIOStream FileIOStream // out
	var _goerr error               // out

	_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileIOStream, _goerr
}

func (f file) PeekPath() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_peek_path(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (f file) PollMountableFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_poll_mountable_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) QueryDefaultHandler(cancellable Cancellable) (AppInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cret *C.GAppInfo     // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_query_default_handler(_arg0, _arg1, &_cerr)

	var _appInfo AppInfo // out
	var _goerr error     // out

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _appInfo, _goerr
}

func (f file) QueryDefaultHandlerFinish(result AsyncResult) (AppInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GAppInfo     // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_file_query_default_handler_finish(_arg0, _arg1, &_cerr)

	var _appInfo AppInfo // out
	var _goerr error     // out

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _appInfo, _goerr
}

func (f file) QueryExists(cancellable Cancellable) bool {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_query_exists(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f file) QueryFileType(flags FileQueryInfoFlags, cancellable Cancellable) FileType {
	var _arg0 *C.GFile              // out
	var _arg1 C.GFileQueryInfoFlags // out
	var _arg2 *C.GCancellable       // out
	var _cret C.GFileType           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GFileQueryInfoFlags)(flags)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_query_file_type(_arg0, _arg1, _arg2)

	var _fileType FileType // out

	_fileType = FileType(_cret)

	return _fileType
}

func (f file) QueryFilesystemInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.char         // out
	var _arg2 *C.GCancellable // out
	var _cret *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_query_filesystem_info(_arg0, _arg1, _arg2, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

func (f file) QueryFilesystemInfoFinish(res AsyncResult) (FileInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_query_filesystem_info_finish(_arg0, _arg1, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

func (f file) QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileInfo, error) {
	var _arg0 *C.GFile              // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _arg3 *C.GCancellable       // out
	var _cret *C.GFileInfo          // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GFileQueryInfoFlags)(flags)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_query_info(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

func (f file) QueryInfoFinish(res AsyncResult) (FileInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_query_info_finish(_arg0, _arg1, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

func (f file) QuerySettableAttributes(cancellable Cancellable) (*FileAttributeInfoList, error) {
	var _arg0 *C.GFile                  // out
	var _arg1 *C.GCancellable           // out
	var _cret *C.GFileAttributeInfoList // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_query_settable_attributes(_arg0, _arg1, &_cerr)

	var _fileAttributeInfoList *FileAttributeInfoList // out
	var _goerr error                                  // out

	_fileAttributeInfoList = WrapFileAttributeInfoList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileAttributeInfoList, _goerr
}

func (f file) QueryWritableNamespaces(cancellable Cancellable) (*FileAttributeInfoList, error) {
	var _arg0 *C.GFile                  // out
	var _arg1 *C.GCancellable           // out
	var _cret *C.GFileAttributeInfoList // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_query_writable_namespaces(_arg0, _arg1, &_cerr)

	var _fileAttributeInfoList *FileAttributeInfoList // out
	var _goerr error                                  // out

	_fileAttributeInfoList = WrapFileAttributeInfoList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileAttributeInfoList, _goerr
}

func (f file) Read(cancellable Cancellable) (FileInputStream, error) {
	var _arg0 *C.GFile            // out
	var _arg1 *C.GCancellable     // out
	var _cret *C.GFileInputStream // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_read(_arg0, _arg1, &_cerr)

	var _fileInputStream FileInputStream // out
	var _goerr error                     // out

	_fileInputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInputStream, _goerr
}

func (f file) ReadFinish(res AsyncResult) (FileInputStream, error) {
	var _arg0 *C.GFile            // out
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.GFileInputStream // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_read_finish(_arg0, _arg1, &_cerr)

	var _fileInputStream FileInputStream // out
	var _goerr error                     // out

	_fileInputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInputStream, _goerr
}

func (f file) Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg1 *C.char              // out
	var _arg2 C.gboolean           // out
	var _arg3 C.GFileCreateFlags   // out
	var _arg4 *C.GCancellable      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(etag))
	defer C.free(unsafe.Pointer(_arg1))
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = (C.GFileCreateFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_replace(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _fileOutputStream FileOutputStream // out
	var _goerr error                       // out

	_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileOutputStream, _goerr
}

func (f file) ReplaceContents(contents []byte, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (string, error) {
	var _arg0 *C.GFile // out
	var _arg1 *C.char
	var _arg2 C.gsize
	var _arg3 *C.char            // out
	var _arg4 C.gboolean         // out
	var _arg5 C.GFileCreateFlags // out
	var _arg6 *C.char            // in
	var _arg7 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg2 = C.gsize(len(contents))
	_arg1 = (*C.char)(unsafe.Pointer(&contents[0]))
	_arg3 = (*C.char)(C.CString(etag))
	defer C.free(unsafe.Pointer(_arg3))
	if makeBackup {
		_arg4 = C.TRUE
	}
	_arg5 = (C.GFileCreateFlags)(flags)
	_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_replace_contents(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, _arg7, &_cerr)

	var _newEtag string // out
	var _goerr error    // out

	_newEtag = C.GoString(_arg6)
	defer C.free(unsafe.Pointer(_arg6))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _newEtag, _goerr
}

func (f file) ReplaceContentsFinish(res AsyncResult) (string, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_file_replace_contents_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _newEtag string // out
	var _goerr error    // out

	_newEtag = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _newEtag, _goerr
}

func (f file) ReplaceFinish(res AsyncResult) (FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_replace_finish(_arg0, _arg1, &_cerr)

	var _fileOutputStream FileOutputStream // out
	var _goerr error                       // out

	_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileOutputStream, _goerr
}

func (f file) ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error) {
	var _arg0 *C.GFile           // out
	var _arg1 *C.char            // out
	var _arg2 C.gboolean         // out
	var _arg3 C.GFileCreateFlags // out
	var _arg4 *C.GCancellable    // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(etag))
	defer C.free(unsafe.Pointer(_arg1))
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = (C.GFileCreateFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_replace_readwrite(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _fileIOStream FileIOStream // out
	var _goerr error               // out

	_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileIOStream, _goerr
}

func (f file) ReplaceReadwriteFinish(res AsyncResult) (FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_replace_readwrite_finish(_arg0, _arg1, &_cerr)

	var _fileIOStream FileIOStream // out
	var _goerr error               // out

	_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileIOStream, _goerr
}

func (f file) ResolveRelativePath(relativePath string) File {
	var _arg0 *C.GFile // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(relativePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_resolve_relative_path(_arg0, _arg1)

	var _ret File // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _ret
}

func (f file) SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var _arg0 *C.GFile              // out
	var _arg1 *C.char               // out
	var _arg2 *C.char               // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _arg4 *C.GCancellable       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.GFileQueryInfoFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_set_attribute_byte_string(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var _arg0 *C.GFile              // out
	var _arg1 *C.char               // out
	var _arg2 C.gint32              // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _arg4 *C.GCancellable       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint32)(value)
	_arg3 = (C.GFileQueryInfoFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_set_attribute_int32(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var _arg0 *C.GFile              // out
	var _arg1 *C.char               // out
	var _arg2 C.gint64              // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _arg4 *C.GCancellable       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint64)(value)
	_arg3 = (C.GFileQueryInfoFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_set_attribute_int64(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var _arg0 *C.GFile              // out
	var _arg1 *C.char               // out
	var _arg2 *C.char               // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _arg4 *C.GCancellable       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.GFileQueryInfoFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_set_attribute_string(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var _arg0 *C.GFile              // out
	var _arg1 *C.char               // out
	var _arg2 C.guint32             // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _arg4 *C.GCancellable       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint32)(value)
	_arg3 = (C.GFileQueryInfoFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_set_attribute_uint32(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var _arg0 *C.GFile              // out
	var _arg1 *C.char               // out
	var _arg2 C.guint64             // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _arg4 *C.GCancellable       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint64)(value)
	_arg3 = (C.GFileQueryInfoFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_set_attribute_uint64(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) SetAttributesFinish(result AsyncResult) (FileInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_set_attributes_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _info FileInfo // out
	var _goerr error   // out

	_info = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg2))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _info, _goerr
}

func (f file) SetAttributesFromInfo(info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var _arg0 *C.GFile              // out
	var _arg1 *C.GFileInfo          // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _arg3 *C.GCancellable       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(info.Native()))
	_arg2 = (C.GFileQueryInfoFlags)(flags)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_set_attributes_from_info(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) SetDisplayName(displayName string, cancellable Cancellable) (File, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.char         // out
	var _arg2 *C.GCancellable // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(displayName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_set_display_name(_arg0, _arg1, _arg2, &_cerr)

	var _ret File    // out
	var _goerr error // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ret, _goerr
}

func (f file) SetDisplayNameFinish(res AsyncResult) (File, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_file_set_display_name_finish(_arg0, _arg1, &_cerr)

	var _ret File    // out
	var _goerr error // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ret, _goerr
}

func (f file) StartMountableFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_start_mountable_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) StopMountableFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_stop_mountable_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) SupportsThreadContexts() bool {
	var _arg0 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_supports_thread_contexts(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f file) Trash(cancellable Cancellable) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_trash(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) TrashFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_trash_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) UnmountMountableFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_unmount_mountable_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (f file) UnmountMountableWithOperationFinish(result AsyncResult) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_unmount_mountable_with_operation_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// FileDescriptorBasedOverrider contains methods that are overridable. This
// interface is a subset of the interface FileDescriptorBased.
type FileDescriptorBasedOverrider interface {
	// Fd gets the underlying file descriptor.
	Fd() int
}

// FileDescriptorBased is implemented by streams (implementations of Stream or
// Stream) that are based on file descriptors.
//
// Note that `<gio/gfiledescriptorbased.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type FileDescriptorBased interface {
	gextras.Objector

	// Fd gets the underlying file descriptor.
	Fd() int
}

// fileDescriptorBased implements the FileDescriptorBased interface.
type fileDescriptorBased struct {
	gextras.Objector
}

var _ FileDescriptorBased = (*fileDescriptorBased)(nil)

// WrapFileDescriptorBased wraps a GObject to a type that implements interface
// FileDescriptorBased. It is primarily used internally.
func WrapFileDescriptorBased(obj *externglib.Object) FileDescriptorBased {
	return fileDescriptorBased{
		Objector: obj,
	}
}

func marshalFileDescriptorBased(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileDescriptorBased(obj), nil
}

func (f fileDescriptorBased) Fd() int {
	var _arg0 *C.GFileDescriptorBased // out
	var _cret C.int                   // in

	_arg0 = (*C.GFileDescriptorBased)(unsafe.Pointer(f.Native()))

	_cret = C.g_file_descriptor_based_get_fd(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IconOverrider contains methods that are overridable. This
// interface is a subset of the interface Icon.
type IconOverrider interface {
	// Equal checks if two icons are equal.
	Equal(icon2 Icon) bool
	// Hash gets a hash for an icon.
	Hash() uint
	// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can
	// be retrieved back by calling g_icon_deserialize() on the returned value.
	// As serialization will avoid using raw icon data when possible, it only
	// makes sense to transfer the #GVariant between processes on the same
	// machine, (as opposed to over the network), and within the same file
	// system namespace.
	Serialize() *glib.Variant
}

// Icon is a very minimal interface for icons. It provides functions for
// checking the equality of two icons, hashing of icons and serializing an icon
// to and from strings.
//
// #GIcon does not provide the actual pixmap for the icon as this is out of
// GIO's scope, however implementations of #GIcon may contain the name of an
// icon (see Icon), or the path to an icon (see Icon).
//
// To obtain a hash of a #GIcon, see g_icon_hash().
//
// To check if two #GIcons are equal, see g_icon_equal().
//
// For serializing a #GIcon, use g_icon_serialize() and g_icon_deserialize().
//
// If you want to consume #GIcon (for example, in a toolkit) you must be
// prepared to handle at least the three following cases: Icon, Icon and Icon.
// It may also make sense to have fast-paths for other cases (like handling
// Pixbuf directly, for example) but all compliant #GIcon implementations
// outside of GIO must implement Icon.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that your new implementation also implements Icon.
// Additionally, you must provide an implementation of g_icon_serialize() that
// gives a result that is understood by g_icon_deserialize(), yielding one of
// the built-in icon types.
type Icon interface {
	gextras.Objector

	// Equal checks if two icons are equal.
	Equal(icon2 Icon) bool
	// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can
	// be retrieved back by calling g_icon_deserialize() on the returned value.
	// As serialization will avoid using raw icon data when possible, it only
	// makes sense to transfer the #GVariant between processes on the same
	// machine, (as opposed to over the network), and within the same file
	// system namespace.
	Serialize() *glib.Variant
	// String generates a textual representation of @icon that can be used for
	// serialization such as when passing @icon to a different process or saving
	// it to persistent storage. Use g_icon_new_for_string() to get @icon back
	// from the returned string.
	//
	// The encoding of the returned string is proprietary to #GIcon except in
	// the following two cases
	//
	// - If @icon is a Icon, the returned string is a native path (such as
	// `/path/to/my icon.png`) without escaping if the #GFile for @icon is a
	// native file. If the file is not native, the returned string is the result
	// of g_file_get_uri() (such as `sftp://path/to/my20icon.png`).
	//
	// - If @icon is a Icon with exactly one name and no fallbacks, the encoding
	// is simply the name (such as `network-server`).
	String() string
}

// icon implements the Icon interface.
type icon struct {
	gextras.Objector
}

var _ Icon = (*icon)(nil)

// WrapIcon wraps a GObject to a type that implements interface
// Icon. It is primarily used internally.
func WrapIcon(obj *externglib.Object) Icon {
	return icon{
		Objector: obj,
	}
}

func marshalIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIcon(obj), nil
}

func (i icon) Equal(icon2 Icon) bool {
	var _arg0 *C.GIcon   // out
	var _arg1 *C.GIcon   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon2.Native()))

	_cret = C.g_icon_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i icon) Serialize() *glib.Variant {
	var _arg0 *C.GIcon    // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(i.Native()))

	_cret = C.g_icon_serialize(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (i icon) String() string {
	var _arg0 *C.GIcon // out
	var _cret *C.gchar // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(i.Native()))

	_cret = C.g_icon_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// InitableOverrider contains methods that are overridable. This
// interface is a subset of the interface Initable.
type InitableOverrider interface {
	// Init initializes the object implementing the interface.
	//
	// This method is intended for language bindings. If writing in C,
	// g_initable_new() should typically be used instead.
	//
	// The object must be initialized before any real use after initial
	// construction, either with this function or g_async_initable_init_async().
	//
	// Implementations may also support cancellation. If @cancellable is not
	// nil, then initialization can be cancelled by triggering the cancellable
	// object from another thread. If the operation was cancelled, the error
	// G_IO_ERROR_CANCELLED will be returned. If @cancellable is not nil and the
	// object doesn't support cancellable initialization the error
	// G_IO_ERROR_NOT_SUPPORTED will be returned.
	//
	// If the object is not initialized, or initialization returns with an
	// error, then all operations on the object except g_object_ref() and
	// g_object_unref() are considered to be invalid, and have undefined
	// behaviour. See the [introduction][ginitable] for more details.
	//
	// Callers should not assume that a class which implements #GInitable can be
	// initialized multiple times, unless the class explicitly documents itself
	// as supporting this. Generally, a class implementation of init() can
	// assume (and assert) that it will only be called once. Previously, this
	// documentation recommended all #GInitable implementations should be
	// idempotent; that recommendation was relaxed in GLib 2.54.
	//
	// If a class explicitly supports being initialized multiple times, it is
	// recommended that the method is idempotent: multiple calls with the same
	// arguments should return the same results. Only the first call initializes
	// the object; further calls return the result of the first call.
	//
	// One reason why a class might need to support idempotent initialization is
	// if it is designed to be used via the singleton pattern, with a
	// Class.constructor that sometimes returns an existing instance. In this
	// pattern, a caller would expect to be able to call g_initable_init() on
	// the result of g_object_new(), regardless of whether it is in fact a new
	// instance.
	Init(cancellable Cancellable) error
}

// Initable is implemented by objects that can fail during initialization. If an
// object implements this interface then it must be initialized as the first
// thing after construction, either via g_initable_init() or
// g_async_initable_init_async() (the latter is only available if it also
// implements Initable).
//
// If the object is not initialized, or initialization returns with an error,
// then all operations on the object except g_object_ref() and g_object_unref()
// are considered to be invalid, and have undefined behaviour. They will often
// fail with g_critical() or g_warning(), but this must not be relied on.
//
// Users of objects implementing this are not intended to use the interface
// method directly, instead it will be used automatically in various ways. For C
// applications you generally just call g_initable_new() directly, or indirectly
// via a foo_thing_new() wrapper. This will call g_initable_init() under the
// cover, returning nil and setting a #GError on failure (at which point the
// instance is unreferenced).
//
// For bindings in languages where the native constructor supports exceptions
// the binding could check for objects implementing GInitable during normal
// construction and automatically initialize them, throwing an exception on
// failure.
type Initable interface {
	gextras.Objector

	// Init initializes the object implementing the interface.
	//
	// This method is intended for language bindings. If writing in C,
	// g_initable_new() should typically be used instead.
	//
	// The object must be initialized before any real use after initial
	// construction, either with this function or g_async_initable_init_async().
	//
	// Implementations may also support cancellation. If @cancellable is not
	// nil, then initialization can be cancelled by triggering the cancellable
	// object from another thread. If the operation was cancelled, the error
	// G_IO_ERROR_CANCELLED will be returned. If @cancellable is not nil and the
	// object doesn't support cancellable initialization the error
	// G_IO_ERROR_NOT_SUPPORTED will be returned.
	//
	// If the object is not initialized, or initialization returns with an
	// error, then all operations on the object except g_object_ref() and
	// g_object_unref() are considered to be invalid, and have undefined
	// behaviour. See the [introduction][ginitable] for more details.
	//
	// Callers should not assume that a class which implements #GInitable can be
	// initialized multiple times, unless the class explicitly documents itself
	// as supporting this. Generally, a class implementation of init() can
	// assume (and assert) that it will only be called once. Previously, this
	// documentation recommended all #GInitable implementations should be
	// idempotent; that recommendation was relaxed in GLib 2.54.
	//
	// If a class explicitly supports being initialized multiple times, it is
	// recommended that the method is idempotent: multiple calls with the same
	// arguments should return the same results. Only the first call initializes
	// the object; further calls return the result of the first call.
	//
	// One reason why a class might need to support idempotent initialization is
	// if it is designed to be used via the singleton pattern, with a
	// Class.constructor that sometimes returns an existing instance. In this
	// pattern, a caller would expect to be able to call g_initable_init() on
	// the result of g_object_new(), regardless of whether it is in fact a new
	// instance.
	Init(cancellable Cancellable) error
}

// initable implements the Initable interface.
type initable struct {
	gextras.Objector
}

var _ Initable = (*initable)(nil)

// WrapInitable wraps a GObject to a type that implements interface
// Initable. It is primarily used internally.
func WrapInitable(obj *externglib.Object) Initable {
	return initable{
		Objector: obj,
	}
}

func marshalInitable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInitable(obj), nil
}

func (i initable) Init(cancellable Cancellable) error {
	var _arg0 *C.GInitable    // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInitable)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_initable_init(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ListModelOverrider contains methods that are overridable. This
// interface is a subset of the interface ListModel.
type ListModelOverrider interface {
	// Item: get the item at @position. If @position is greater than the number
	// of items in @list, nil is returned.
	//
	// nil is never returned for an index that is smaller than the length of the
	// list. See g_list_model_get_n_items().
	Item(position uint) gextras.Objector
	// ItemType gets the type of the items in @list. All items returned from
	// g_list_model_get_type() are of that type or a subtype, or are an
	// implementation of that interface.
	//
	// The item type of a Model can not change during the life of the model.
	ItemType() externglib.Type
	// NItems gets the number of items in @list.
	//
	// Depending on the model implementation, calling this function may be less
	// efficient than iterating the list with increasing values for @position
	// until g_list_model_get_item() returns nil.
	NItems() uint
}

// ListModel is an interface that represents a mutable list of #GObjects. Its
// main intention is as a model for various widgets in user interfaces, such as
// list views, but it can also be used as a convenient method of returning lists
// of data, with support for updates.
//
// Each object in the list may also report changes in itself via some mechanism
// (normally the #GObject::notify signal). Taken together with the
// Model::items-changed signal, this provides for a list that can change its
// membership, and in which the members can change their individual properties.
//
// A good example would be the list of visible wireless network access points,
// where each access point can report dynamic properties such as signal
// strength.
//
// It is important to note that the Model itself does not report changes to the
// individual items. It only reports changes to the list membership. If you want
// to observe changes to the objects themselves then you need to connect signals
// to the objects that you are interested in.
//
// All items in a Model are of (or derived from) the same type.
// g_list_model_get_item_type() returns that type. The type may be an interface,
// in which case all objects in the list must implement it.
//
// The semantics are close to that of an array: g_list_model_get_n_items()
// returns the number of items in the list and g_list_model_get_item() returns
// an item at a (0-based) position. In order to allow implementations to
// calculate the list length lazily, you can also iterate over items: starting
// from 0, repeatedly call g_list_model_get_item() until it returns nil.
//
// An implementation may create objects lazily, but must take care to return the
// same object for a given position until all references to it are gone.
//
// On the other side, a consumer is expected only to hold references on objects
// that are currently "user visible", in order to facilitate the maximum level
// of laziness in the implementation of the list and to reduce the required
// number of signal connections at a given time.
//
// This interface is intended only to be used from a single thread. The thread
// in which it is appropriate to use it depends on the particular
// implementation, but typically it will be from the thread that owns the
// [thread-default main context][g-main-context-push-thread-default] in effect
// at the time that the model was created.
type ListModel interface {
	gextras.Objector

	// ItemType gets the type of the items in @list. All items returned from
	// g_list_model_get_type() are of that type or a subtype, or are an
	// implementation of that interface.
	//
	// The item type of a Model can not change during the life of the model.
	ItemType() externglib.Type
	// NItems gets the number of items in @list.
	//
	// Depending on the model implementation, calling this function may be less
	// efficient than iterating the list with increasing values for @position
	// until g_list_model_get_item() returns nil.
	NItems() uint
	// Object: get the item at @position. If @position is greater than the
	// number of items in @list, nil is returned.
	//
	// nil is never returned for an index that is smaller than the length of the
	// list. See g_list_model_get_n_items().
	Object(position uint) gextras.Objector
	// ItemsChanged emits the Model::items-changed signal on @list.
	//
	// This function should only be called by classes implementing Model. It has
	// to be called after the internal representation of @list has been updated,
	// because handlers connected to this signal might query the new state of
	// the list.
	//
	// Implementations must only make changes to the model (as visible to its
	// consumer) in places that will not cause problems for that consumer. For
	// models that are driven directly by a write API (such as Store), changes
	// can be reported in response to uses of that API. For models that
	// represent remote data, changes should only be made from a fresh mainloop
	// dispatch. It is particularly not permitted to make changes in response to
	// a call to the Model consumer API.
	//
	// Stated another way: in general, it is assumed that code making a series
	// of accesses to the model via the API, without returning to the mainloop,
	// and without calling other code, will continue to view the same contents
	// of the model.
	ItemsChanged(position uint, removed uint, added uint)
}

// listModel implements the ListModel interface.
type listModel struct {
	gextras.Objector
}

var _ ListModel = (*listModel)(nil)

// WrapListModel wraps a GObject to a type that implements interface
// ListModel. It is primarily used internally.
func WrapListModel(obj *externglib.Object) ListModel {
	return listModel{
		Objector: obj,
	}
}

func marshalListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListModel(obj), nil
}

func (l listModel) ItemType() externglib.Type {
	var _arg0 *C.GListModel // out
	var _cret C.GType       // in

	_arg0 = (*C.GListModel)(unsafe.Pointer(l.Native()))

	_cret = C.g_list_model_get_item_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (l listModel) NItems() uint {
	var _arg0 *C.GListModel // out
	var _cret C.guint       // in

	_arg0 = (*C.GListModel)(unsafe.Pointer(l.Native()))

	_cret = C.g_list_model_get_n_items(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (l listModel) Object(position uint) gextras.Objector {
	var _arg0 *C.GListModel // out
	var _arg1 C.guint       // out
	var _cret *C.GObject    // in

	_arg0 = (*C.GListModel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.guint)(position)

	_cret = C.g_list_model_get_object(_arg0, _arg1)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (l listModel) ItemsChanged(position uint, removed uint, added uint) {
	var _arg0 *C.GListModel // out
	var _arg1 C.guint       // out
	var _arg2 C.guint       // out
	var _arg3 C.guint       // out

	_arg0 = (*C.GListModel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.guint)(removed)
	_arg3 = (C.guint)(added)

	C.g_list_model_items_changed(_arg0, _arg1, _arg2, _arg3)
}

// LoadableIconOverrider contains methods that are overridable. This
// interface is a subset of the interface LoadableIcon.
type LoadableIconOverrider interface {
	// Load loads a loadable icon. For the asynchronous version of this
	// function, see g_loadable_icon_load_async().
	Load(size int, cancellable Cancellable) (string, InputStream, error)
	// LoadFinish finishes an asynchronous icon load started in
	// g_loadable_icon_load_async().
	LoadFinish(res AsyncResult) (string, InputStream, error)
}

// LoadableIcon extends the #GIcon interface and adds the ability to load icons
// from streams.
type LoadableIcon interface {
	Icon

	// Load loads a loadable icon. For the asynchronous version of this
	// function, see g_loadable_icon_load_async().
	Load(size int, cancellable Cancellable) (string, InputStream, error)
	// LoadFinish finishes an asynchronous icon load started in
	// g_loadable_icon_load_async().
	LoadFinish(res AsyncResult) (string, InputStream, error)
}

// loadableIcon implements the LoadableIcon interface.
type loadableIcon struct {
	Icon
}

var _ LoadableIcon = (*loadableIcon)(nil)

// WrapLoadableIcon wraps a GObject to a type that implements interface
// LoadableIcon. It is primarily used internally.
func WrapLoadableIcon(obj *externglib.Object) LoadableIcon {
	return loadableIcon{
		Icon: WrapIcon(obj),
	}
}

func marshalLoadableIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLoadableIcon(obj), nil
}

func (i loadableIcon) Load(size int, cancellable Cancellable) (string, InputStream, error) {
	var _arg0 *C.GLoadableIcon // out
	var _arg1 C.int            // out
	var _arg2 *C.char          // in
	var _arg3 *C.GCancellable  // out
	var _cret *C.GInputStream  // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(size)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_loadable_icon_load(_arg0, _arg1, &_arg2, _arg3, &_cerr)

	var _typ string              // out
	var _inputStream InputStream // out
	var _goerr error             // out

	_typ = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _typ, _inputStream, _goerr
}

func (i loadableIcon) LoadFinish(res AsyncResult) (string, InputStream, error) {
	var _arg0 *C.GLoadableIcon // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 *C.char          // in
	var _cret *C.GInputStream  // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_loadable_icon_load_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _typ string              // out
	var _inputStream InputStream // out
	var _goerr error             // out

	_typ = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _typ, _inputStream, _goerr
}

// MemoryMonitorOverrider contains methods that are overridable. This
// interface is a subset of the interface MemoryMonitor.
type MemoryMonitorOverrider interface {
	LowMemoryWarning(level MemoryMonitorWarningLevel)
}

// MemoryMonitor: Monitor will monitor system memory and suggest to the
// application when to free memory so as to leave more room for other
// applications. It is implemented on Linux using the Low Memory Monitor
// (https://gitlab.freedesktop.org/hadess/low-memory-monitor/) (API
// documentation (https://hadess.pages.freedesktop.org/low-memory-monitor/)).
//
// There is also an implementation for use inside Flatpak sandboxes.
//
// Possible actions to take when the signal is received are: - Free caches -
// Save files that haven't been looked at in a while to disk, ready to be
// reopened when needed - Run a garbage collection cycle - Try and compress
// fragmented allocations - Exit on idle if the process has no reason to stay
// around - Call `malloc_trim(3)` (man:malloc_trim) to return cached heap pages
// to the kernel (if supported by your libc)
//
// Note that some actions may not always improve system performance, and so
// should be profiled for your application. `malloc_trim()`, for example, may
// make future heap allocations slower (due to releasing cached heap pages back
// to the kernel).
//
// See MonitorWarningLevel for details on the various warning levels.
//
//    static void
//    warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
//    {
//      g_debug ("Warning level: d", level);
//      if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//        drop_caches ();
//    }
//
//    static GMemoryMonitor *
//    monitor_low_memory (void)
//    {
//      GMemoryMonitor *m;
//      m = g_memory_monitor_dup_default ();
//      g_signal_connect (G_OBJECT (m), "low-memory-warning",
//                        G_CALLBACK (warning_cb), NULL);
//      return m;
//    }
//
// Don't forget to disconnect the Monitor::low-memory-warning signal, and unref
// the Monitor itself when exiting.
type MemoryMonitor interface {
	Initable
}

// memoryMonitor implements the MemoryMonitor interface.
type memoryMonitor struct {
	Initable
}

var _ MemoryMonitor = (*memoryMonitor)(nil)

// WrapMemoryMonitor wraps a GObject to a type that implements interface
// MemoryMonitor. It is primarily used internally.
func WrapMemoryMonitor(obj *externglib.Object) MemoryMonitor {
	return memoryMonitor{
		Initable: WrapInitable(obj),
	}
}

func marshalMemoryMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMemoryMonitor(obj), nil
}

// MountOverrider contains methods that are overridable. This
// interface is a subset of the interface Mount.
type MountOverrider interface {
	// CanEject checks if @mount can be ejected.
	CanEject() bool
	// CanUnmount checks if @mount can be unmounted.
	CanUnmount() bool

	Changed()
	// EjectFinish finishes ejecting a mount. If any errors occurred during the
	// operation, @error will be set to contain the errors and false will be
	// returned.
	EjectFinish(result AsyncResult) error
	// EjectWithOperationFinish finishes ejecting a mount. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
	EjectWithOperationFinish(result AsyncResult) error
	// DefaultLocation gets the default location of @mount. The default location
	// of the given @mount is a path that reflects the main entry point for the
	// user (e.g. the home directory, or the root of the volume).
	DefaultLocation() File
	// Drive gets the drive for the @mount.
	//
	// This is a convenience method for getting the #GVolume and then using that
	// object to get the #GDrive.
	Drive() Drive
	// Icon gets the icon for @mount.
	Icon() Icon
	// Name gets the name of @mount.
	Name() string
	// Root gets the root directory on @mount.
	Root() File
	// SortKey gets the sort key for @mount, if any.
	SortKey() string
	// SymbolicIcon gets the symbolic icon for @mount.
	SymbolicIcon() Icon
	// UUID gets the UUID for the @mount. The reference is typically based on
	// the file system UUID for the mount in question and should be considered
	// an opaque string. Returns nil if there is no UUID available.
	UUID() string
	// Volume gets the volume for the @mount.
	Volume() Volume
	// GuessContentTypeFinish finishes guessing content types of @mount. If any
	// errors occurred during the operation, @error will be set to contain the
	// errors and false will be returned. In particular, you may get an
	// G_IO_ERROR_NOT_SUPPORTED if the mount does not support content guessing.
	GuessContentTypeFinish(result AsyncResult) ([]string, error)
	// GuessContentTypeSync tries to guess the type of content stored on @mount.
	// Returns one or more textual identifiers of well-known content types
	// (typically prefixed with "x-content/"), e.g. x-content/image-dcf for
	// camera memory cards. See the shared-mime-info
	// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
	// specification for more on x-content types.
	//
	// This is a synchronous operation and as such may block doing IO; see
	// g_mount_guess_content_type() for the asynchronous version.
	GuessContentTypeSync(forceRescan bool, cancellable Cancellable) ([]string, error)

	PreUnmount()
	// RemountFinish finishes remounting a mount. If any errors occurred during
	// the operation, @error will be set to contain the errors and false will be
	// returned.
	RemountFinish(result AsyncResult) error
	// UnmountFinish finishes unmounting a mount. If any errors occurred during
	// the operation, @error will be set to contain the errors and false will be
	// returned.
	UnmountFinish(result AsyncResult) error
	// UnmountWithOperationFinish finishes unmounting a mount. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
	UnmountWithOperationFinish(result AsyncResult) error

	Unmounted()
}

// Mount: the #GMount interface represents user-visible mounts. Note, when
// porting from GnomeVFS, #GMount is the moral equivalent of VFSVolume.
//
// #GMount is a "mounted" filesystem that you can access. Mounted is in quotes
// because it's not the same as a unix mount, it might be a gvfs mount, but you
// can still access the files on it if you use GIO. Might or might not be
// related to a volume object.
//
// Unmounting a #GMount instance is an asynchronous operation. For more
// information about asynchronous operations, see Result and #GTask. To unmount
// a #GMount instance, first call g_mount_unmount_with_operation() with (at
// least) the #GMount instance and a ReadyCallback. The callback will be fired
// when the operation has resolved (either with success or failure), and a
// Result structure will be passed to the callback. That callback should then
// call g_mount_unmount_with_operation_finish() with the #GMount and the Result
// data to see if the operation was completed successfully. If an @error is
// present when g_mount_unmount_with_operation_finish() is called, then it will
// be filled with any error information.
type Mount interface {
	gextras.Objector

	// CanEject checks if @mount can be ejected.
	CanEject() bool
	// CanUnmount checks if @mount can be unmounted.
	CanUnmount() bool
	// EjectFinish finishes ejecting a mount. If any errors occurred during the
	// operation, @error will be set to contain the errors and false will be
	// returned.
	EjectFinish(result AsyncResult) error
	// EjectWithOperationFinish finishes ejecting a mount. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
	EjectWithOperationFinish(result AsyncResult) error
	// DefaultLocation gets the default location of @mount. The default location
	// of the given @mount is a path that reflects the main entry point for the
	// user (e.g. the home directory, or the root of the volume).
	DefaultLocation() File
	// Drive gets the drive for the @mount.
	//
	// This is a convenience method for getting the #GVolume and then using that
	// object to get the #GDrive.
	Drive() Drive
	// Icon gets the icon for @mount.
	Icon() Icon
	// Name gets the name of @mount.
	Name() string
	// Root gets the root directory on @mount.
	Root() File
	// SortKey gets the sort key for @mount, if any.
	SortKey() string
	// SymbolicIcon gets the symbolic icon for @mount.
	SymbolicIcon() Icon
	// UUID gets the UUID for the @mount. The reference is typically based on
	// the file system UUID for the mount in question and should be considered
	// an opaque string. Returns nil if there is no UUID available.
	UUID() string
	// Volume gets the volume for the @mount.
	Volume() Volume
	// GuessContentTypeFinish finishes guessing content types of @mount. If any
	// errors occurred during the operation, @error will be set to contain the
	// errors and false will be returned. In particular, you may get an
	// G_IO_ERROR_NOT_SUPPORTED if the mount does not support content guessing.
	GuessContentTypeFinish(result AsyncResult) ([]string, error)
	// GuessContentTypeSync tries to guess the type of content stored on @mount.
	// Returns one or more textual identifiers of well-known content types
	// (typically prefixed with "x-content/"), e.g. x-content/image-dcf for
	// camera memory cards. See the shared-mime-info
	// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
	// specification for more on x-content types.
	//
	// This is a synchronous operation and as such may block doing IO; see
	// g_mount_guess_content_type() for the asynchronous version.
	GuessContentTypeSync(forceRescan bool, cancellable Cancellable) ([]string, error)
	// IsShadowed determines if @mount is shadowed. Applications or libraries
	// should avoid displaying @mount in the user interface if it is shadowed.
	//
	// A mount is said to be shadowed if there exists one or more user visible
	// objects (currently #GMount objects) with a root that is inside the root
	// of @mount.
	//
	// One application of shadow mounts is when exposing a single file system
	// that is used to address several logical volumes. In this situation, a
	// Monitor implementation would create two #GVolume objects (for example,
	// one for the camera functionality of the device and one for a SD card
	// reader on the device) with activation URIs
	// `gphoto2://[usb:001,002]/store1/` and `gphoto2://[usb:001,002]/store2/`.
	// When the underlying mount (with root `gphoto2://[usb:001,002]/`) is
	// mounted, said Monitor implementation would create two #GMount objects
	// (each with their root matching the corresponding volume activation root)
	// that would shadow the original mount.
	//
	// The proxy monitor in GVfs 2.26 and later, automatically creates and
	// manage shadow mounts (and shadows the underlying mount) if the activation
	// root on a #GVolume is set.
	IsShadowed() bool
	// RemountFinish finishes remounting a mount. If any errors occurred during
	// the operation, @error will be set to contain the errors and false will be
	// returned.
	RemountFinish(result AsyncResult) error
	// Shadow increments the shadow count on @mount. Usually used by Monitor
	// implementations when creating a shadow mount for @mount, see
	// g_mount_is_shadowed() for more information. The caller will need to emit
	// the #GMount::changed signal on @mount manually.
	Shadow()
	// UnmountFinish finishes unmounting a mount. If any errors occurred during
	// the operation, @error will be set to contain the errors and false will be
	// returned.
	UnmountFinish(result AsyncResult) error
	// UnmountWithOperationFinish finishes unmounting a mount. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
	UnmountWithOperationFinish(result AsyncResult) error
	// Unshadow decrements the shadow count on @mount. Usually used by Monitor
	// implementations when destroying a shadow mount for @mount, see
	// g_mount_is_shadowed() for more information. The caller will need to emit
	// the #GMount::changed signal on @mount manually.
	Unshadow()
}

// mount implements the Mount interface.
type mount struct {
	gextras.Objector
}

var _ Mount = (*mount)(nil)

// WrapMount wraps a GObject to a type that implements interface
// Mount. It is primarily used internally.
func WrapMount(obj *externglib.Object) Mount {
	return mount{
		Objector: obj,
	}
}

func marshalMount(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMount(obj), nil
}

func (m mount) CanEject() bool {
	var _arg0 *C.GMount  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_can_eject(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m mount) CanUnmount() bool {
	var _arg0 *C.GMount  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_can_unmount(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m mount) EjectFinish(result AsyncResult) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_mount_eject_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (m mount) EjectWithOperationFinish(result AsyncResult) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_mount_eject_with_operation_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (m mount) DefaultLocation() File {
	var _arg0 *C.GMount // out
	var _cret *C.GFile  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_get_default_location(_arg0)

	var _file File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _file
}

func (m mount) Drive() Drive {
	var _arg0 *C.GMount // out
	var _cret *C.GDrive // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_get_drive(_arg0)

	var _drive Drive // out

	_drive = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Drive)

	return _drive
}

func (m mount) Icon() Icon {
	var _arg0 *C.GMount // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_get_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (m mount) Name() string {
	var _arg0 *C.GMount // out
	var _cret *C.char   // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (m mount) Root() File {
	var _arg0 *C.GMount // out
	var _cret *C.GFile  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_get_root(_arg0)

	var _file File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _file
}

func (m mount) SortKey() string {
	var _arg0 *C.GMount // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_get_sort_key(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m mount) SymbolicIcon() Icon {
	var _arg0 *C.GMount // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_get_symbolic_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (m mount) UUID() string {
	var _arg0 *C.GMount // out
	var _cret *C.char   // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_get_uuid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (m mount) Volume() Volume {
	var _arg0 *C.GMount  // out
	var _cret *C.GVolume // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_get_volume(_arg0)

	var _volume Volume // out

	_volume = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Volume)

	return _volume
}

func (m mount) GuessContentTypeFinish(result AsyncResult) ([]string, error) {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cret **C.gchar
	var _cerr *C.GError // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_mount_guess_content_type_finish(_arg0, _arg1, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

func (m mount) GuessContentTypeSync(forceRescan bool, cancellable Cancellable) ([]string, error) {
	var _arg0 *C.GMount       // out
	var _arg1 C.gboolean      // out
	var _arg2 *C.GCancellable // out
	var _cret **C.gchar
	var _cerr *C.GError // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
	if forceRescan {
		_arg1 = C.TRUE
	}
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_mount_guess_content_type_sync(_arg0, _arg1, _arg2, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

func (m mount) IsShadowed() bool {
	var _arg0 *C.GMount  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	_cret = C.g_mount_is_shadowed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m mount) RemountFinish(result AsyncResult) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_mount_remount_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (m mount) Shadow() {
	var _arg0 *C.GMount // out

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	C.g_mount_shadow(_arg0)
}

func (m mount) UnmountFinish(result AsyncResult) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_mount_unmount_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (m mount) UnmountWithOperationFinish(result AsyncResult) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_mount_unmount_with_operation_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (m mount) Unshadow() {
	var _arg0 *C.GMount // out

	_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

	C.g_mount_unshadow(_arg0)
}

// NetworkMonitorOverrider contains methods that are overridable. This
// interface is a subset of the interface NetworkMonitor.
type NetworkMonitorOverrider interface {
	// CanReach attempts to determine whether or not the host pointed to by
	// @connectable can be reached, without actually trying to connect to it.
	//
	// This may return true even when Monitor:network-available is false, if,
	// for example, @monitor can determine that @connectable refers to a host on
	// a local network.
	//
	// If @monitor believes that an attempt to connect to @connectable will
	// succeed, it will return true. Otherwise, it will return false and set
	// @error to an appropriate error (such as G_IO_ERROR_HOST_UNREACHABLE).
	//
	// Note that although this does not attempt to connect to @connectable, it
	// may still block for a brief period of time (eg, trying to do multicast
	// DNS on the local network), so if you do not want to block, you should use
	// g_network_monitor_can_reach_async().
	CanReach(connectable SocketConnectable, cancellable Cancellable) error
	// CanReachFinish finishes an async network connectivity test. See
	// g_network_monitor_can_reach_async().
	CanReachFinish(result AsyncResult) error

	NetworkChanged(networkAvailable bool)
}

// NetworkMonitor provides an easy-to-use cross-platform API for monitoring
// network connectivity. On Linux, the available implementations are based on
// the kernel's netlink interface and on NetworkManager.
//
// There is also an implementation for use inside Flatpak sandboxes.
type NetworkMonitor interface {
	Initable

	// CanReach attempts to determine whether or not the host pointed to by
	// @connectable can be reached, without actually trying to connect to it.
	//
	// This may return true even when Monitor:network-available is false, if,
	// for example, @monitor can determine that @connectable refers to a host on
	// a local network.
	//
	// If @monitor believes that an attempt to connect to @connectable will
	// succeed, it will return true. Otherwise, it will return false and set
	// @error to an appropriate error (such as G_IO_ERROR_HOST_UNREACHABLE).
	//
	// Note that although this does not attempt to connect to @connectable, it
	// may still block for a brief period of time (eg, trying to do multicast
	// DNS on the local network), so if you do not want to block, you should use
	// g_network_monitor_can_reach_async().
	CanReach(connectable SocketConnectable, cancellable Cancellable) error
	// CanReachFinish finishes an async network connectivity test. See
	// g_network_monitor_can_reach_async().
	CanReachFinish(result AsyncResult) error
	// Connectivity gets a more detailed networking state than
	// g_network_monitor_get_network_available().
	//
	// If Monitor:network-available is false, then the connectivity state will
	// be G_NETWORK_CONNECTIVITY_LOCAL.
	//
	// If Monitor:network-available is true, then the connectivity state will be
	// G_NETWORK_CONNECTIVITY_FULL (if there is full Internet connectivity),
	// G_NETWORK_CONNECTIVITY_LIMITED (if the host has a default route, but
	// appears to be unable to actually reach the full Internet), or
	// G_NETWORK_CONNECTIVITY_PORTAL (if the host is trapped behind a "captive
	// portal" that requires some sort of login or acknowledgement before
	// allowing full Internet access).
	//
	// Note that in the case of G_NETWORK_CONNECTIVITY_LIMITED and
	// G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
	// reachable but others are not. In this case, applications can attempt to
	// connect to remote servers, but should gracefully fall back to their
	// "offline" behavior if the connection attempt fails.
	Connectivity() NetworkConnectivity
	// NetworkAvailable checks if the network is available. "Available" here
	// means that the system has a default route available for at least one of
	// IPv4 or IPv6. It does not necessarily imply that the public Internet is
	// reachable. See Monitor:network-available for more details.
	NetworkAvailable() bool
	// NetworkMetered checks if the network is metered. See
	// Monitor:network-metered for more details.
	NetworkMetered() bool
}

// networkMonitor implements the NetworkMonitor interface.
type networkMonitor struct {
	Initable
}

var _ NetworkMonitor = (*networkMonitor)(nil)

// WrapNetworkMonitor wraps a GObject to a type that implements interface
// NetworkMonitor. It is primarily used internally.
func WrapNetworkMonitor(obj *externglib.Object) NetworkMonitor {
	return networkMonitor{
		Initable: WrapInitable(obj),
	}
}

func marshalNetworkMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNetworkMonitor(obj), nil
}

func (m networkMonitor) CanReach(connectable SocketConnectable, cancellable Cancellable) error {
	var _arg0 *C.GNetworkMonitor    // out
	var _arg1 *C.GSocketConnectable // out
	var _arg2 *C.GCancellable       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(connectable.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_network_monitor_can_reach(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (m networkMonitor) CanReachFinish(result AsyncResult) error {
	var _arg0 *C.GNetworkMonitor // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_network_monitor_can_reach_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (m networkMonitor) Connectivity() NetworkConnectivity {
	var _arg0 *C.GNetworkMonitor     // out
	var _cret C.GNetworkConnectivity // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.g_network_monitor_get_connectivity(_arg0)

	var _networkConnectivity NetworkConnectivity // out

	_networkConnectivity = NetworkConnectivity(_cret)

	return _networkConnectivity
}

func (m networkMonitor) NetworkAvailable() bool {
	var _arg0 *C.GNetworkMonitor // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.g_network_monitor_get_network_available(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m networkMonitor) NetworkMetered() bool {
	var _arg0 *C.GNetworkMonitor // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.g_network_monitor_get_network_metered(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PollableInputStreamOverrider contains methods that are overridable. This
// interface is a subset of the interface PollableInputStream.
type PollableInputStreamOverrider interface {
	// CanPoll checks if @stream is actually pollable. Some classes may
	// implement InputStream but have only certain instances of that class be
	// pollable. If this method returns false, then the behavior of other
	// InputStream methods is undefined.
	//
	// For any given stream, the value returned by this method is constant; a
	// stream cannot switch from pollable to non-pollable or vice versa.
	CanPoll() bool
	// IsReadable checks if @stream can be read.
	//
	// Note that some stream types may not be able to implement this 100%
	// reliably, and it is possible that a call to g_input_stream_read() after
	// this returns true would still block. To guarantee non-blocking behavior,
	// you should always use g_pollable_input_stream_read_nonblocking(), which
	// will return a G_IO_ERROR_WOULD_BLOCK error rather than blocking.
	IsReadable() bool
	// ReadNonblocking attempts to read up to @count bytes from @stream into
	// @buffer, as with g_input_stream_read(). If @stream is not currently
	// readable, this will immediately return G_IO_ERROR_WOULD_BLOCK, and you
	// can use g_pollable_input_stream_create_source() to create a #GSource that
	// will be triggered when @stream is readable.
	//
	// Note that since this method never blocks, you cannot actually use
	// @cancellable to cancel it. However, it will return an error if
	// @cancellable has already been cancelled when you call, which may happen
	// if you call this method after a source triggers due to having been
	// cancelled.
	ReadNonblocking(buffer []byte) (int, error)
}

// PollableInputStream is implemented by Streams that can be polled for
// readiness to read. This can be used when interfacing with a non-GIO API that
// expects UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
type PollableInputStream interface {
	InputStream

	// CanPoll checks if @stream is actually pollable. Some classes may
	// implement InputStream but have only certain instances of that class be
	// pollable. If this method returns false, then the behavior of other
	// InputStream methods is undefined.
	//
	// For any given stream, the value returned by this method is constant; a
	// stream cannot switch from pollable to non-pollable or vice versa.
	CanPoll() bool
	// IsReadable checks if @stream can be read.
	//
	// Note that some stream types may not be able to implement this 100%
	// reliably, and it is possible that a call to g_input_stream_read() after
	// this returns true would still block. To guarantee non-blocking behavior,
	// you should always use g_pollable_input_stream_read_nonblocking(), which
	// will return a G_IO_ERROR_WOULD_BLOCK error rather than blocking.
	IsReadable() bool
	// ReadNonblocking attempts to read up to @count bytes from @stream into
	// @buffer, as with g_input_stream_read(). If @stream is not currently
	// readable, this will immediately return G_IO_ERROR_WOULD_BLOCK, and you
	// can use g_pollable_input_stream_create_source() to create a #GSource that
	// will be triggered when @stream is readable.
	//
	// Note that since this method never blocks, you cannot actually use
	// @cancellable to cancel it. However, it will return an error if
	// @cancellable has already been cancelled when you call, which may happen
	// if you call this method after a source triggers due to having been
	// cancelled.
	ReadNonblocking(buffer []byte, cancellable Cancellable) (int, error)
}

// pollableInputStream implements the PollableInputStream interface.
type pollableInputStream struct {
	InputStream
}

var _ PollableInputStream = (*pollableInputStream)(nil)

// WrapPollableInputStream wraps a GObject to a type that implements interface
// PollableInputStream. It is primarily used internally.
func WrapPollableInputStream(obj *externglib.Object) PollableInputStream {
	return pollableInputStream{
		InputStream: WrapInputStream(obj),
	}
}

func marshalPollableInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPollableInputStream(obj), nil
}

func (s pollableInputStream) CanPoll() bool {
	var _arg0 *C.GPollableInputStream // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_pollable_input_stream_can_poll(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s pollableInputStream) IsReadable() bool {
	var _arg0 *C.GPollableInputStream // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_pollable_input_stream_is_readable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s pollableInputStream) ReadNonblocking(buffer []byte, cancellable Cancellable) (int, error) {
	var _arg0 *C.GPollableInputStream // out
	var _arg1 *C.void
	var _arg2 C.gsize
	var _arg3 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_pollable_input_stream_read_nonblocking(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

// PollableOutputStreamOverrider contains methods that are overridable. This
// interface is a subset of the interface PollableOutputStream.
type PollableOutputStreamOverrider interface {
	// CanPoll checks if @stream is actually pollable. Some classes may
	// implement OutputStream but have only certain instances of that class be
	// pollable. If this method returns false, then the behavior of other
	// OutputStream methods is undefined.
	//
	// For any given stream, the value returned by this method is constant; a
	// stream cannot switch from pollable to non-pollable or vice versa.
	CanPoll() bool
	// IsWritable checks if @stream can be written.
	//
	// Note that some stream types may not be able to implement this 100%
	// reliably, and it is possible that a call to g_output_stream_write() after
	// this returns true would still block. To guarantee non-blocking behavior,
	// you should always use g_pollable_output_stream_write_nonblocking(), which
	// will return a G_IO_ERROR_WOULD_BLOCK error rather than blocking.
	IsWritable() bool
	// WriteNonblocking attempts to write up to @count bytes from @buffer to
	// @stream, as with g_output_stream_write(). If @stream is not currently
	// writable, this will immediately return G_IO_ERROR_WOULD_BLOCK, and you
	// can use g_pollable_output_stream_create_source() to create a #GSource
	// that will be triggered when @stream is writable.
	//
	// Note that since this method never blocks, you cannot actually use
	// @cancellable to cancel it. However, it will return an error if
	// @cancellable has already been cancelled when you call, which may happen
	// if you call this method after a source triggers due to having been
	// cancelled.
	//
	// Also note that if G_IO_ERROR_WOULD_BLOCK is returned some underlying
	// transports like D/TLS require that you re-send the same @buffer and
	// @count in the next write call.
	WriteNonblocking(buffer []byte) (int, error)
	// WritevNonblocking attempts to write the bytes contained in the @n_vectors
	// @vectors to @stream, as with g_output_stream_writev(). If @stream is not
	// currently writable, this will immediately return
	// %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can use
	// g_pollable_output_stream_create_source() to create a #GSource that will
	// be triggered when @stream is writable. @error will *not* be set in that
	// case.
	//
	// Note that since this method never blocks, you cannot actually use
	// @cancellable to cancel it. However, it will return an error if
	// @cancellable has already been cancelled when you call, which may happen
	// if you call this method after a source triggers due to having been
	// cancelled.
	//
	// Also note that if G_POLLABLE_RETURN_WOULD_BLOCK is returned some
	// underlying transports like D/TLS require that you re-send the same
	// @vectors and @n_vectors in the next write call.
	WritevNonblocking(vectors []OutputVector) (uint, PollableReturn, error)
}

// PollableOutputStream is implemented by Streams that can be polled for
// readiness to write. This can be used when interfacing with a non-GIO API that
// expects UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
type PollableOutputStream interface {
	OutputStream

	// CanPoll checks if @stream is actually pollable. Some classes may
	// implement OutputStream but have only certain instances of that class be
	// pollable. If this method returns false, then the behavior of other
	// OutputStream methods is undefined.
	//
	// For any given stream, the value returned by this method is constant; a
	// stream cannot switch from pollable to non-pollable or vice versa.
	CanPoll() bool
	// IsWritable checks if @stream can be written.
	//
	// Note that some stream types may not be able to implement this 100%
	// reliably, and it is possible that a call to g_output_stream_write() after
	// this returns true would still block. To guarantee non-blocking behavior,
	// you should always use g_pollable_output_stream_write_nonblocking(), which
	// will return a G_IO_ERROR_WOULD_BLOCK error rather than blocking.
	IsWritable() bool
	// WriteNonblocking attempts to write up to @count bytes from @buffer to
	// @stream, as with g_output_stream_write(). If @stream is not currently
	// writable, this will immediately return G_IO_ERROR_WOULD_BLOCK, and you
	// can use g_pollable_output_stream_create_source() to create a #GSource
	// that will be triggered when @stream is writable.
	//
	// Note that since this method never blocks, you cannot actually use
	// @cancellable to cancel it. However, it will return an error if
	// @cancellable has already been cancelled when you call, which may happen
	// if you call this method after a source triggers due to having been
	// cancelled.
	//
	// Also note that if G_IO_ERROR_WOULD_BLOCK is returned some underlying
	// transports like D/TLS require that you re-send the same @buffer and
	// @count in the next write call.
	WriteNonblocking(buffer []byte, cancellable Cancellable) (int, error)
	// WritevNonblocking attempts to write the bytes contained in the @n_vectors
	// @vectors to @stream, as with g_output_stream_writev(). If @stream is not
	// currently writable, this will immediately return
	// %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can use
	// g_pollable_output_stream_create_source() to create a #GSource that will
	// be triggered when @stream is writable. @error will *not* be set in that
	// case.
	//
	// Note that since this method never blocks, you cannot actually use
	// @cancellable to cancel it. However, it will return an error if
	// @cancellable has already been cancelled when you call, which may happen
	// if you call this method after a source triggers due to having been
	// cancelled.
	//
	// Also note that if G_POLLABLE_RETURN_WOULD_BLOCK is returned some
	// underlying transports like D/TLS require that you re-send the same
	// @vectors and @n_vectors in the next write call.
	WritevNonblocking(vectors []OutputVector, cancellable Cancellable) (uint, PollableReturn, error)
}

// pollableOutputStream implements the PollableOutputStream interface.
type pollableOutputStream struct {
	OutputStream
}

var _ PollableOutputStream = (*pollableOutputStream)(nil)

// WrapPollableOutputStream wraps a GObject to a type that implements interface
// PollableOutputStream. It is primarily used internally.
func WrapPollableOutputStream(obj *externglib.Object) PollableOutputStream {
	return pollableOutputStream{
		OutputStream: WrapOutputStream(obj),
	}
}

func marshalPollableOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPollableOutputStream(obj), nil
}

func (s pollableOutputStream) CanPoll() bool {
	var _arg0 *C.GPollableOutputStream // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_pollable_output_stream_can_poll(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s pollableOutputStream) IsWritable() bool {
	var _arg0 *C.GPollableOutputStream // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_pollable_output_stream_is_writable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s pollableOutputStream) WriteNonblocking(buffer []byte, cancellable Cancellable) (int, error) {
	var _arg0 *C.GPollableOutputStream // out
	var _arg1 *C.void
	var _arg2 C.gsize
	var _arg3 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_pollable_output_stream_write_nonblocking(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s pollableOutputStream) WritevNonblocking(vectors []OutputVector, cancellable Cancellable) (uint, PollableReturn, error) {
	var _arg0 *C.GPollableOutputStream // out
	var _arg1 *C.GOutputVector
	var _arg2 C.gsize
	var _arg3 C.gsize           // in
	var _arg4 *C.GCancellable   // out
	var _cret C.GPollableReturn // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(vectors))
	_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_pollable_output_stream_writev_nonblocking(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

	var _bytesWritten uint             // out
	var _pollableReturn PollableReturn // out
	var _goerr error                   // out

	_bytesWritten = (uint)(_arg3)
	_pollableReturn = PollableReturn(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _pollableReturn, _goerr
}

// ProXYOverrider contains methods that are overridable. This
// interface is a subset of the interface ProXY.
type ProXYOverrider interface {
	// ConnectProXY: given @connection to communicate with a proxy (eg, a
	// Connection that is connected to the proxy server), this does the
	// necessary handshake to connect to @proxy_address, and if required, wraps
	// the OStream to handle proxy payload.
	ConnectProXY(connection IOStream, proxyAddress ProXYAddress, cancellable Cancellable) (IOStream, error)
	// ConnectFinish: see g_proxy_connect().
	ConnectFinish(result AsyncResult) (IOStream, error)
	// SupportsHostname: some proxy protocols expect to be passed a hostname,
	// which they will resolve to an IP address themselves. Others, like SOCKS4,
	// do not allow this. This function will return false if @proxy is
	// implementing such a protocol. When false is returned, the caller should
	// resolve the destination hostname first, and then pass a Address
	// containing the stringified IP address to g_proxy_connect() or
	// g_proxy_connect_async().
	SupportsHostname() bool
}

// ProXY: a #GProxy handles connecting to a remote host via a given type of
// proxy server. It is implemented by the 'gio-proxy' extension point. The
// extensions are named after their proxy protocol name. As an example, a SOCKS5
// proxy implementation can be retrieved with the name 'socks5' using the
// function g_io_extension_point_get_extension_by_name().
type ProXY interface {
	gextras.Objector

	// ConnectProXY: given @connection to communicate with a proxy (eg, a
	// Connection that is connected to the proxy server), this does the
	// necessary handshake to connect to @proxy_address, and if required, wraps
	// the OStream to handle proxy payload.
	ConnectProXY(connection IOStream, proxyAddress ProXYAddress, cancellable Cancellable) (IOStream, error)
	// ConnectFinish: see g_proxy_connect().
	ConnectFinish(result AsyncResult) (IOStream, error)
	// SupportsHostname: some proxy protocols expect to be passed a hostname,
	// which they will resolve to an IP address themselves. Others, like SOCKS4,
	// do not allow this. This function will return false if @proxy is
	// implementing such a protocol. When false is returned, the caller should
	// resolve the destination hostname first, and then pass a Address
	// containing the stringified IP address to g_proxy_connect() or
	// g_proxy_connect_async().
	SupportsHostname() bool
}

// proXY implements the ProXY interface.
type proXY struct {
	gextras.Objector
}

var _ ProXY = (*proXY)(nil)

// WrapProXY wraps a GObject to a type that implements interface
// ProXY. It is primarily used internally.
func WrapProXY(obj *externglib.Object) ProXY {
	return proXY{
		Objector: obj,
	}
}

func marshalProXY(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProXY(obj), nil
}

func (p proXY) ConnectProXY(connection IOStream, proxyAddress ProXYAddress, cancellable Cancellable) (IOStream, error) {
	var _arg0 *C.GProxy        // out
	var _arg1 *C.GIOStream     // out
	var _arg2 *C.GProxyAddress // out
	var _arg3 *C.GCancellable  // out
	var _cret *C.GIOStream     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GProxy)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(connection.Native()))
	_arg2 = (*C.GProxyAddress)(unsafe.Pointer(proxyAddress.Native()))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_proxy_connect(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _ioStream IOStream // out
	var _goerr error       // out

	_ioStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ioStream, _goerr
}

func (p proXY) ConnectFinish(result AsyncResult) (IOStream, error) {
	var _arg0 *C.GProxy       // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GIOStream    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GProxy)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_proxy_connect_finish(_arg0, _arg1, &_cerr)

	var _ioStream IOStream // out
	var _goerr error       // out

	_ioStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IOStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ioStream, _goerr
}

func (p proXY) SupportsHostname() bool {
	var _arg0 *C.GProxy  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_proxy_supports_hostname(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProXYResolverOverrider contains methods that are overridable. This
// interface is a subset of the interface ProXYResolver.
type ProXYResolverOverrider interface {
	// IsSupported checks if @resolver can be used on this system. (This is used
	// internally; g_proxy_resolver_get_default() will only return a proxy
	// resolver that returns true for this method.)
	IsSupported() bool
	// Lookup looks into the system proxy configuration to determine what proxy,
	// if any, to use to connect to @uri. The returned proxy URIs are of the
	// form `<protocol>://[user[:password]@]host:port` or `direct://`, where
	// <protocol> could be http, rtsp, socks or other proxying protocol.
	//
	// If you don't know what network protocol is being used on the socket, you
	// should use `none` as the URI protocol. In this case, the resolver might
	// still return a generic proxy type (such as SOCKS), but would not return
	// protocol-specific proxy types (such as http).
	//
	// `direct://` is used when no proxy is needed. Direct connection should not
	// be attempted unless it is part of the returned array of proxies.
	Lookup(uri string, cancellable Cancellable) ([]string, error)
	// LookupFinish: call this function to obtain the array of proxy URIs when
	// g_proxy_resolver_lookup_async() is complete. See
	// g_proxy_resolver_lookup() for more details.
	LookupFinish(result AsyncResult) ([]string, error)
}

// ProXYResolver provides synchronous and asynchronous network proxy resolution.
// Resolver is used within Client through the method
// g_socket_connectable_proxy_enumerate().
//
// Implementations of Resolver based on libproxy and GNOME settings can be found
// in glib-networking. GIO comes with an implementation for use inside Flatpak
// portals.
type ProXYResolver interface {
	gextras.Objector

	// IsSupported checks if @resolver can be used on this system. (This is used
	// internally; g_proxy_resolver_get_default() will only return a proxy
	// resolver that returns true for this method.)
	IsSupported() bool
	// Lookup looks into the system proxy configuration to determine what proxy,
	// if any, to use to connect to @uri. The returned proxy URIs are of the
	// form `<protocol>://[user[:password]@]host:port` or `direct://`, where
	// <protocol> could be http, rtsp, socks or other proxying protocol.
	//
	// If you don't know what network protocol is being used on the socket, you
	// should use `none` as the URI protocol. In this case, the resolver might
	// still return a generic proxy type (such as SOCKS), but would not return
	// protocol-specific proxy types (such as http).
	//
	// `direct://` is used when no proxy is needed. Direct connection should not
	// be attempted unless it is part of the returned array of proxies.
	Lookup(uri string, cancellable Cancellable) ([]string, error)
	// LookupFinish: call this function to obtain the array of proxy URIs when
	// g_proxy_resolver_lookup_async() is complete. See
	// g_proxy_resolver_lookup() for more details.
	LookupFinish(result AsyncResult) ([]string, error)
}

// proXYResolver implements the ProXYResolver interface.
type proXYResolver struct {
	gextras.Objector
}

var _ ProXYResolver = (*proXYResolver)(nil)

// WrapProXYResolver wraps a GObject to a type that implements interface
// ProXYResolver. It is primarily used internally.
func WrapProXYResolver(obj *externglib.Object) ProXYResolver {
	return proXYResolver{
		Objector: obj,
	}
}

func marshalProXYResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProXYResolver(obj), nil
}

func (r proXYResolver) IsSupported() bool {
	var _arg0 *C.GProxyResolver // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(r.Native()))

	_cret = C.g_proxy_resolver_is_supported(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r proXYResolver) Lookup(uri string, cancellable Cancellable) ([]string, error) {
	var _arg0 *C.GProxyResolver // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GCancellable   // out
	var _cret **C.gchar
	var _cerr *C.GError // in

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_proxy_resolver_lookup(_arg0, _arg1, _arg2, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

func (r proXYResolver) LookupFinish(result AsyncResult) ([]string, error) {
	var _arg0 *C.GProxyResolver // out
	var _arg1 *C.GAsyncResult   // out
	var _cret **C.gchar
	var _cerr *C.GError // in

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_proxy_resolver_lookup_finish(_arg0, _arg1, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

// RemoteActionGroupOverrider contains methods that are overridable. This
// interface is a subset of the interface RemoteActionGroup.
type RemoteActionGroupOverrider interface {
	// ActivateActionFull activates the remote action.
	//
	// This is the same as g_action_group_activate_action() except that it
	// allows for provision of "platform data" to be sent along with the
	// activation request. This typically contains details such as the user
	// interaction timestamp or startup notification information.
	//
	// @platform_data must be non-nil and must have the type
	// G_VARIANT_TYPE_VARDICT. If it is floating, it will be consumed.
	ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant)
	// ChangeActionStateFull changes the state of a remote action.
	//
	// This is the same as g_action_group_change_action_state() except that it
	// allows for provision of "platform data" to be sent along with the state
	// change request. This typically contains details such as the user
	// interaction timestamp or startup notification information.
	//
	// @platform_data must be non-nil and must have the type
	// G_VARIANT_TYPE_VARDICT. If it is floating, it will be consumed.
	ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant)
}

// RemoteActionGroup: the GRemoteActionGroup interface is implemented by Group
// instances that either transmit action invocations to other processes or
// receive action invocations in the local process from other processes.
//
// The interface has `_full` variants of the two methods on Group used to
// activate actions: g_action_group_activate_action() and
// g_action_group_change_action_state(). These variants allow a "platform data"
// #GVariant to be specified: a dictionary providing context for the action
// invocation (for example: timestamps, startup notification IDs, etc).
//
// BusActionGroup implements ActionGroup. This provides a mechanism to send
// platform data for action invocations over D-Bus.
//
// Additionally, g_dbus_connection_export_action_group() will check if the
// exported Group implements ActionGroup and use the `_full` variants of the
// calls if available. This provides a mechanism by which to receive platform
// data for action invocations that arrive by way of D-Bus.
type RemoteActionGroup interface {
	ActionGroup

	// ActivateActionFull activates the remote action.
	//
	// This is the same as g_action_group_activate_action() except that it
	// allows for provision of "platform data" to be sent along with the
	// activation request. This typically contains details such as the user
	// interaction timestamp or startup notification information.
	//
	// @platform_data must be non-nil and must have the type
	// G_VARIANT_TYPE_VARDICT. If it is floating, it will be consumed.
	ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant)
	// ChangeActionStateFull changes the state of a remote action.
	//
	// This is the same as g_action_group_change_action_state() except that it
	// allows for provision of "platform data" to be sent along with the state
	// change request. This typically contains details such as the user
	// interaction timestamp or startup notification information.
	//
	// @platform_data must be non-nil and must have the type
	// G_VARIANT_TYPE_VARDICT. If it is floating, it will be consumed.
	ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant)
}

// remoteActionGroup implements the RemoteActionGroup interface.
type remoteActionGroup struct {
	ActionGroup
}

var _ RemoteActionGroup = (*remoteActionGroup)(nil)

// WrapRemoteActionGroup wraps a GObject to a type that implements interface
// RemoteActionGroup. It is primarily used internally.
func WrapRemoteActionGroup(obj *externglib.Object) RemoteActionGroup {
	return remoteActionGroup{
		ActionGroup: WrapActionGroup(obj),
	}
}

func marshalRemoteActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRemoteActionGroup(obj), nil
}

func (r remoteActionGroup) ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant) {
	var _arg0 *C.GRemoteActionGroup // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GVariant           // out
	var _arg3 *C.GVariant           // out

	_arg0 = (*C.GRemoteActionGroup)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))
	_arg3 = (*C.GVariant)(unsafe.Pointer(platformData.Native()))

	C.g_remote_action_group_activate_action_full(_arg0, _arg1, _arg2, _arg3)
}

func (r remoteActionGroup) ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant) {
	var _arg0 *C.GRemoteActionGroup // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GVariant           // out
	var _arg3 *C.GVariant           // out

	_arg0 = (*C.GRemoteActionGroup)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))
	_arg3 = (*C.GVariant)(unsafe.Pointer(platformData.Native()))

	C.g_remote_action_group_change_action_state_full(_arg0, _arg1, _arg2, _arg3)
}

// SeekableOverrider contains methods that are overridable. This
// interface is a subset of the interface Seekable.
type SeekableOverrider interface {
	// CanSeek tests if the stream supports the Iface.
	CanSeek() bool
	// CanTruncate tests if the length of the stream can be adjusted with
	// g_seekable_truncate().
	CanTruncate() bool
	// Seek seeks in the stream by the given @offset, modified by @type.
	//
	// Attempting to seek past the end of the stream will have different results
	// depending on if the stream is fixed-sized or resizable. If the stream is
	// resizable then seeking past the end and then writing will result in zeros
	// filling the empty space. Seeking past the end of a resizable stream and
	// reading will result in EOF. Seeking past the end of a fixed-sized stream
	// will fail.
	//
	// Any operation that would result in a negative offset will fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Seek(offset int64, typ glib.SeekType, cancellable Cancellable) error
	// Tell tells the current position within the stream.
	Tell() int64
	// TruncateFn sets the length of the stream to @offset. If the stream was
	// previously larger than @offset, the extra data is discarded. If the
	// stream was previously shorter than @offset, it is extended with NUL
	// ('\0') bytes.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	TruncateFn(offset int64, cancellable Cancellable) error
}

// Seekable is implemented by streams (implementations of Stream or Stream) that
// support seeking.
//
// Seekable streams largely fall into two categories: resizable and fixed-size.
//
// #GSeekable on fixed-sized streams is approximately the same as POSIX lseek()
// on a block device (for example: attempting to seek past the end of the device
// is an error). Fixed streams typically cannot be truncated.
//
// #GSeekable on resizable streams is approximately the same as POSIX lseek() on
// a normal file. Seeking past the end and writing data will usually cause the
// stream to resize by introducing zero bytes.
type Seekable interface {
	gextras.Objector

	// CanSeek tests if the stream supports the Iface.
	CanSeek() bool
	// CanTruncate tests if the length of the stream can be adjusted with
	// g_seekable_truncate().
	CanTruncate() bool
	// Seek seeks in the stream by the given @offset, modified by @type.
	//
	// Attempting to seek past the end of the stream will have different results
	// depending on if the stream is fixed-sized or resizable. If the stream is
	// resizable then seeking past the end and then writing will result in zeros
	// filling the empty space. Seeking past the end of a resizable stream and
	// reading will result in EOF. Seeking past the end of a fixed-sized stream
	// will fail.
	//
	// Any operation that would result in a negative offset will fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Seek(offset int64, typ glib.SeekType, cancellable Cancellable) error
	// Tell tells the current position within the stream.
	Tell() int64
	// Truncate sets the length of the stream to @offset. If the stream was
	// previously larger than @offset, the extra data is discarded. If the
	// stream was previously shorter than @offset, it is extended with NUL
	// ('\0') bytes.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	Truncate(offset int64, cancellable Cancellable) error
}

// seekable implements the Seekable interface.
type seekable struct {
	gextras.Objector
}

var _ Seekable = (*seekable)(nil)

// WrapSeekable wraps a GObject to a type that implements interface
// Seekable. It is primarily used internally.
func WrapSeekable(obj *externglib.Object) Seekable {
	return seekable{
		Objector: obj,
	}
}

func marshalSeekable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeekable(obj), nil
}

func (s seekable) CanSeek() bool {
	var _arg0 *C.GSeekable // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))

	_cret = C.g_seekable_can_seek(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s seekable) CanTruncate() bool {
	var _arg0 *C.GSeekable // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))

	_cret = C.g_seekable_can_truncate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s seekable) Seek(offset int64, typ glib.SeekType, cancellable Cancellable) error {
	var _arg0 *C.GSeekable    // out
	var _arg1 C.goffset       // out
	var _arg2 C.GSeekType     // out
	var _arg3 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))
	_arg1 = (C.goffset)(offset)
	_arg2 = (C.GSeekType)(typ)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_seekable_seek(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s seekable) Tell() int64 {
	var _arg0 *C.GSeekable // out
	var _cret C.goffset    // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))

	_cret = C.g_seekable_tell(_arg0)

	var _gint64 int64 // out

	_gint64 = (int64)(_cret)

	return _gint64
}

func (s seekable) Truncate(offset int64, cancellable Cancellable) error {
	var _arg0 *C.GSeekable    // out
	var _arg1 C.goffset       // out
	var _arg2 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))
	_arg1 = (C.goffset)(offset)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_seekable_truncate(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SocketConnectableOverrider contains methods that are overridable. This
// interface is a subset of the interface SocketConnectable.
type SocketConnectableOverrider interface {
	// Enumerate creates a AddressEnumerator for @connectable.
	Enumerate() SocketAddressEnumerator
	// ProXYEnumerate creates a AddressEnumerator for @connectable that will
	// return a Address for each of its addresses that you must connect to via a
	// proxy.
	//
	// If @connectable does not implement
	// g_socket_connectable_proxy_enumerate(), this will fall back to calling
	// g_socket_connectable_enumerate().
	ProXYEnumerate() SocketAddressEnumerator
	// String: format a Connectable as a string. This is a human-readable format
	// for use in debugging output, and is not a stable serialization format. It
	// is not suitable for use in user interfaces as it exposes too much
	// information for a user.
	//
	// If the Connectable implementation does not support string formatting, the
	// implementations type name will be returned as a fallback.
	String() string
}

// SocketConnectable objects that describe one or more potential socket
// endpoints implement Connectable. Callers can then use
// g_socket_connectable_enumerate() to get a AddressEnumerator to try out each
// socket address in turn until one succeeds, as shown in the sample code below.
//
//    MyConnectionType *
//    connect_to_host (const char    *hostname,
//                     guint16        port,
//                     GCancellable  *cancellable,
//                     GError       **error)
//    {
//      MyConnection *conn = NULL;
//      GSocketConnectable *addr;
//      GSocketAddressEnumerator *enumerator;
//      GSocketAddress *sockaddr;
//      GError *conn_error = NULL;
//
//      addr = g_network_address_new (hostname, port);
//      enumerator = g_socket_connectable_enumerate (addr);
//      g_object_unref (addr);
//
//      // Try each sockaddr until we succeed. Record the first connection error,
//      // but not any further ones (since they'll probably be basically the same
//      // as the first).
//      while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
//        {
//          conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
//          g_object_unref (sockaddr);
//        }
//      g_object_unref (enumerator);
//
//      if (conn)
//        {
//          if (conn_error)
//            {
//              // We couldn't connect to the first address, but we succeeded
//              // in connecting to a later address.
//              g_error_free (conn_error);
//            }
//          return conn;
//        }
//      else if (error)
//        {
//          /// Either initial lookup failed, or else the caller cancelled us.
//          if (conn_error)
//            g_error_free (conn_error);
//          return NULL;
//        }
//      else
//        {
//          g_error_propagate (error, conn_error);
//          return NULL;
//        }
//    }
type SocketConnectable interface {
	gextras.Objector

	// Enumerate creates a AddressEnumerator for @connectable.
	Enumerate() SocketAddressEnumerator
	// ProXYEnumerate creates a AddressEnumerator for @connectable that will
	// return a Address for each of its addresses that you must connect to via a
	// proxy.
	//
	// If @connectable does not implement
	// g_socket_connectable_proxy_enumerate(), this will fall back to calling
	// g_socket_connectable_enumerate().
	ProXYEnumerate() SocketAddressEnumerator
	// String: format a Connectable as a string. This is a human-readable format
	// for use in debugging output, and is not a stable serialization format. It
	// is not suitable for use in user interfaces as it exposes too much
	// information for a user.
	//
	// If the Connectable implementation does not support string formatting, the
	// implementations type name will be returned as a fallback.
	String() string
}

// socketConnectable implements the SocketConnectable interface.
type socketConnectable struct {
	gextras.Objector
}

var _ SocketConnectable = (*socketConnectable)(nil)

// WrapSocketConnectable wraps a GObject to a type that implements interface
// SocketConnectable. It is primarily used internally.
func WrapSocketConnectable(obj *externglib.Object) SocketConnectable {
	return socketConnectable{
		Objector: obj,
	}
}

func marshalSocketConnectable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketConnectable(obj), nil
}

func (c socketConnectable) Enumerate() SocketAddressEnumerator {
	var _arg0 *C.GSocketConnectable       // out
	var _cret *C.GSocketAddressEnumerator // in

	_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_connectable_enumerate(_arg0)

	var _socketAddressEnumerator SocketAddressEnumerator // out

	_socketAddressEnumerator = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddressEnumerator)

	return _socketAddressEnumerator
}

func (c socketConnectable) ProXYEnumerate() SocketAddressEnumerator {
	var _arg0 *C.GSocketConnectable       // out
	var _cret *C.GSocketAddressEnumerator // in

	_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_connectable_proxy_enumerate(_arg0)

	var _socketAddressEnumerator SocketAddressEnumerator // out

	_socketAddressEnumerator = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddressEnumerator)

	return _socketAddressEnumerator
}

func (c socketConnectable) String() string {
	var _arg0 *C.GSocketConnectable // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_connectable_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TLSBackendOverrider contains methods that are overridable. This
// interface is a subset of the interface TLSBackend.
type TLSBackendOverrider interface {
	// DefaultDatabase gets the default Database used to verify TLS connections.
	DefaultDatabase() TLSDatabase
	// SupportsDTLS checks if DTLS is supported. DTLS support may not be
	// available even if TLS support is available, and vice-versa.
	SupportsDTLS() bool
	// SupportsTLS checks if TLS is supported; if this returns false for the
	// default Backend, it means no "real" TLS backend is available.
	SupportsTLS() bool
}

// TLSBackend: TLS (Transport Layer Security, aka SSL) and DTLS backend.
type TLSBackend interface {
	gextras.Objector

	// CertificateType gets the #GType of @backend's Certificate implementation.
	CertificateType() externglib.Type
	// ClientConnectionType gets the #GType of @backend's ClientConnection
	// implementation.
	ClientConnectionType() externglib.Type
	// DefaultDatabase gets the default Database used to verify TLS connections.
	DefaultDatabase() TLSDatabase
	// DTLSClientConnectionType gets the #GType of @backends ClientConnection
	// implementation.
	DTLSClientConnectionType() externglib.Type
	// DTLSServerConnectionType gets the #GType of @backends ServerConnection
	// implementation.
	DTLSServerConnectionType() externglib.Type
	// FileDatabaseType gets the #GType of @backend's FileDatabase
	// implementation.
	FileDatabaseType() externglib.Type
	// ServerConnectionType gets the #GType of @backend's ServerConnection
	// implementation.
	ServerConnectionType() externglib.Type
	// SetDefaultDatabase: set the default Database used to verify TLS
	// connections
	//
	// Any subsequent call to g_tls_backend_get_default_database() will return
	// the database set in this call. Existing databases and connections are not
	// modified.
	//
	// Setting a nil default database will reset to using the system default
	// database as if g_tls_backend_set_default_database() had never been
	// called.
	SetDefaultDatabase(database TLSDatabase)
	// SupportsDTLS checks if DTLS is supported. DTLS support may not be
	// available even if TLS support is available, and vice-versa.
	SupportsDTLS() bool
	// SupportsTLS checks if TLS is supported; if this returns false for the
	// default Backend, it means no "real" TLS backend is available.
	SupportsTLS() bool
}

// tlsBackend implements the TLSBackend interface.
type tlsBackend struct {
	gextras.Objector
}

var _ TLSBackend = (*tlsBackend)(nil)

// WrapTLSBackend wraps a GObject to a type that implements interface
// TLSBackend. It is primarily used internally.
func WrapTLSBackend(obj *externglib.Object) TLSBackend {
	return tlsBackend{
		Objector: obj,
	}
}

func marshalTLSBackend(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSBackend(obj), nil
}

func (b tlsBackend) CertificateType() externglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

	_cret = C.g_tls_backend_get_certificate_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (b tlsBackend) ClientConnectionType() externglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

	_cret = C.g_tls_backend_get_client_connection_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (b tlsBackend) DefaultDatabase() TLSDatabase {
	var _arg0 *C.GTlsBackend  // out
	var _cret *C.GTlsDatabase // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

	_cret = C.g_tls_backend_get_default_database(_arg0)

	var _tlsDatabase TLSDatabase // out

	_tlsDatabase = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSDatabase)

	return _tlsDatabase
}

func (b tlsBackend) DTLSClientConnectionType() externglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

	_cret = C.g_tls_backend_get_dtls_client_connection_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (b tlsBackend) DTLSServerConnectionType() externglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

	_cret = C.g_tls_backend_get_dtls_server_connection_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (b tlsBackend) FileDatabaseType() externglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

	_cret = C.g_tls_backend_get_file_database_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (b tlsBackend) ServerConnectionType() externglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

	_cret = C.g_tls_backend_get_server_connection_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (b tlsBackend) SetDefaultDatabase(database TLSDatabase) {
	var _arg0 *C.GTlsBackend  // out
	var _arg1 *C.GTlsDatabase // out

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(database.Native()))

	C.g_tls_backend_set_default_database(_arg0, _arg1)
}

func (b tlsBackend) SupportsDTLS() bool {
	var _arg0 *C.GTlsBackend // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

	_cret = C.g_tls_backend_supports_dtls(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b tlsBackend) SupportsTLS() bool {
	var _arg0 *C.GTlsBackend // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

	_cret = C.g_tls_backend_supports_tls(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TLSClientConnectionOverrider contains methods that are overridable. This
// interface is a subset of the interface TLSClientConnection.
type TLSClientConnectionOverrider interface {
	// CopySessionState: possibly copies session state from one connection to
	// another, for use in TLS session resumption. This is not normally needed,
	// but may be used when the same session needs to be used between different
	// endpoints, as is required by some protocols, such as FTP over TLS.
	// @source should have already completed a handshake and, since TLS 1.3, it
	// should have been used to read data at least once. @conn should not have
	// completed a handshake.
	//
	// It is not possible to know whether a call to this function will actually
	// do anything. Because session resumption is normally used only for
	// performance benefit, the TLS backend might not implement this function.
	// Even if implemented, it may not actually succeed in allowing @conn to
	// resume @source's TLS session, because the server may not have sent a
	// session resumption token to @source, or it may refuse to accept the token
	// from @conn. There is no way to know whether a call to this function is
	// actually successful.
	//
	// Using this function is not required to benefit from session resumption.
	// If the TLS backend supports session resumption, the session will be
	// resumed automatically if it is possible to do so without weakening the
	// privacy guarantees normally provided by TLS, without need to call this
	// function. For example, with TLS 1.3, a session ticket will be
	// automatically copied from any ClientConnection that has previously
	// received session tickets from the server, provided a ticket is available
	// that has not previously been used for session resumption, since session
	// ticket reuse would be a privacy weakness. Using this function causes the
	// ticket to be copied without regard for privacy considerations.
	CopySessionState(source TLSClientConnection)
}

// TLSClientConnection is the client-side subclass of Connection, representing a
// client-side TLS connection.
type TLSClientConnection interface {
	TLSConnection

	// CopySessionState: possibly copies session state from one connection to
	// another, for use in TLS session resumption. This is not normally needed,
	// but may be used when the same session needs to be used between different
	// endpoints, as is required by some protocols, such as FTP over TLS.
	// @source should have already completed a handshake and, since TLS 1.3, it
	// should have been used to read data at least once. @conn should not have
	// completed a handshake.
	//
	// It is not possible to know whether a call to this function will actually
	// do anything. Because session resumption is normally used only for
	// performance benefit, the TLS backend might not implement this function.
	// Even if implemented, it may not actually succeed in allowing @conn to
	// resume @source's TLS session, because the server may not have sent a
	// session resumption token to @source, or it may refuse to accept the token
	// from @conn. There is no way to know whether a call to this function is
	// actually successful.
	//
	// Using this function is not required to benefit from session resumption.
	// If the TLS backend supports session resumption, the session will be
	// resumed automatically if it is possible to do so without weakening the
	// privacy guarantees normally provided by TLS, without need to call this
	// function. For example, with TLS 1.3, a session ticket will be
	// automatically copied from any ClientConnection that has previously
	// received session tickets from the server, provided a ticket is available
	// that has not previously been used for session resumption, since session
	// ticket reuse would be a privacy weakness. Using this function causes the
	// ticket to be copied without regard for privacy considerations.
	CopySessionState(source TLSClientConnection)
	// ServerIdentity gets @conn's expected server identity
	ServerIdentity() SocketConnectable
	// UseSSL3: SSL 3.0 is no longer supported. See
	// g_tls_client_connection_set_use_ssl3() for details.
	UseSSL3() bool
	// ValidationFlags gets @conn's validation flags
	ValidationFlags() TLSCertificateFlags
	// SetServerIdentity sets @conn's expected server identity, which is used
	// both to tell servers on virtual hosts which certificate to present, and
	// also to let @conn know what name to look for in the certificate when
	// performing G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
	SetServerIdentity(identity SocketConnectable)
	// SetUseSSL3: since GLib 2.42.1, SSL 3.0 is no longer supported.
	//
	// From GLib 2.42.1 through GLib 2.62, this function could be used to force
	// use of TLS 1.0, the lowest-supported TLS protocol version at the time. In
	// the past, this was needed to connect to broken TLS servers that exhibited
	// protocol version intolerance. Such servers are no longer common, and
	// using TLS 1.0 is no longer considered acceptable.
	//
	// Since GLib 2.64, this function does nothing.
	SetUseSSL3(useSsl3 bool)
	// SetValidationFlags sets @conn's validation flags, to override the default
	// set of checks performed when validating a server certificate. By default,
	// G_TLS_CERTIFICATE_VALIDATE_ALL is used.
	SetValidationFlags(flags TLSCertificateFlags)
}

// tlsClientConnection implements the TLSClientConnection interface.
type tlsClientConnection struct {
	TLSConnection
}

var _ TLSClientConnection = (*tlsClientConnection)(nil)

// WrapTLSClientConnection wraps a GObject to a type that implements interface
// TLSClientConnection. It is primarily used internally.
func WrapTLSClientConnection(obj *externglib.Object) TLSClientConnection {
	return tlsClientConnection{
		TLSConnection: WrapTLSConnection(obj),
	}
}

func marshalTLSClientConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSClientConnection(obj), nil
}

func (c tlsClientConnection) CopySessionState(source TLSClientConnection) {
	var _arg0 *C.GTlsClientConnection // out
	var _arg1 *C.GTlsClientConnection // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsClientConnection)(unsafe.Pointer(source.Native()))

	C.g_tls_client_connection_copy_session_state(_arg0, _arg1)
}

func (c tlsClientConnection) ServerIdentity() SocketConnectable {
	var _arg0 *C.GTlsClientConnection // out
	var _cret *C.GSocketConnectable   // in

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_client_connection_get_server_identity(_arg0)

	var _socketConnectable SocketConnectable // out

	_socketConnectable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SocketConnectable)

	return _socketConnectable
}

func (c tlsClientConnection) UseSSL3() bool {
	var _arg0 *C.GTlsClientConnection // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_client_connection_get_use_ssl3(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c tlsClientConnection) ValidationFlags() TLSCertificateFlags {
	var _arg0 *C.GTlsClientConnection // out
	var _cret C.GTlsCertificateFlags  // in

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_client_connection_get_validation_flags(_arg0)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

func (c tlsClientConnection) SetServerIdentity(identity SocketConnectable) {
	var _arg0 *C.GTlsClientConnection // out
	var _arg1 *C.GSocketConnectable   // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(identity.Native()))

	C.g_tls_client_connection_set_server_identity(_arg0, _arg1)
}

func (c tlsClientConnection) SetUseSSL3(useSsl3 bool) {
	var _arg0 *C.GTlsClientConnection // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))
	if useSsl3 {
		_arg1 = C.TRUE
	}

	C.g_tls_client_connection_set_use_ssl3(_arg0, _arg1)
}

func (c tlsClientConnection) SetValidationFlags(flags TLSCertificateFlags) {
	var _arg0 *C.GTlsClientConnection // out
	var _arg1 C.GTlsCertificateFlags  // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GTlsCertificateFlags)(flags)

	C.g_tls_client_connection_set_validation_flags(_arg0, _arg1)
}

// TLSFileDatabase is implemented by Database objects which load their
// certificate information from a file. It is an interface which TLS library
// specific subtypes implement.
type TLSFileDatabase interface {
	TLSDatabase
}

// tlsFileDatabase implements the TLSFileDatabase interface.
type tlsFileDatabase struct {
	TLSDatabase
}

var _ TLSFileDatabase = (*tlsFileDatabase)(nil)

// WrapTLSFileDatabase wraps a GObject to a type that implements interface
// TLSFileDatabase. It is primarily used internally.
func WrapTLSFileDatabase(obj *externglib.Object) TLSFileDatabase {
	return tlsFileDatabase{
		TLSDatabase: WrapTLSDatabase(obj),
	}
}

func marshalTLSFileDatabase(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSFileDatabase(obj), nil
}

// TLSServerConnection is the server-side subclass of Connection, representing a
// server-side TLS connection.
type TLSServerConnection interface {
	TLSConnection
}

// tlsServerConnection implements the TLSServerConnection interface.
type tlsServerConnection struct {
	TLSConnection
}

var _ TLSServerConnection = (*tlsServerConnection)(nil)

// WrapTLSServerConnection wraps a GObject to a type that implements interface
// TLSServerConnection. It is primarily used internally.
func WrapTLSServerConnection(obj *externglib.Object) TLSServerConnection {
	return tlsServerConnection{
		TLSConnection: WrapTLSConnection(obj),
	}
}

func marshalTLSServerConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSServerConnection(obj), nil
}

// VolumeOverrider contains methods that are overridable. This
// interface is a subset of the interface Volume.
type VolumeOverrider interface {
	// CanEject checks if a volume can be ejected.
	CanEject() bool
	// CanMount checks if a volume can be mounted.
	CanMount() bool

	Changed()
	// EjectFinish finishes ejecting a volume. If any errors occurred during the
	// operation, @error will be set to contain the errors and false will be
	// returned.
	EjectFinish(result AsyncResult) error
	// EjectWithOperationFinish finishes ejecting a volume. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
	EjectWithOperationFinish(result AsyncResult) error
	// EnumerateIdentifiers gets the kinds of [identifiers][volume-identifier]
	// that @volume has. Use g_volume_get_identifier() to obtain the identifiers
	// themselves.
	EnumerateIdentifiers() []string
	// ActivationRoot gets the activation root for a #GVolume if it is known
	// ahead of mount time. Returns nil otherwise. If not nil and if @volume is
	// mounted, then the result of g_mount_get_root() on the #GMount object
	// obtained from g_volume_get_mount() will always either be equal or a
	// prefix of what this function returns. In other words, in code
	//
	//    (g_file_has_prefix (volume_activation_root, mount_root) ||
	//     g_file_equal (volume_activation_root, mount_root))
	//
	// will always be true.
	//
	// Activation roots are typically used in Monitor implementations to find
	// the underlying mount to shadow, see g_mount_is_shadowed() for more
	// details.
	ActivationRoot() File
	// Drive gets the drive for the @volume.
	Drive() Drive
	// Icon gets the icon for @volume.
	Icon() Icon
	// Identifier gets the identifier of the given kind for @volume. See the
	// [introduction][volume-identifier] for more information about volume
	// identifiers.
	Identifier(kind string) string
	// Mount gets the mount for the @volume.
	Mount() Mount
	// Name gets the name of @volume.
	Name() string
	// SortKey gets the sort key for @volume, if any.
	SortKey() string
	// SymbolicIcon gets the symbolic icon for @volume.
	SymbolicIcon() Icon
	// UUID gets the UUID for the @volume. The reference is typically based on
	// the file system UUID for the volume in question and should be considered
	// an opaque string. Returns nil if there is no UUID available.
	UUID() string
	// MountFinish finishes mounting a volume. If any errors occurred during the
	// operation, @error will be set to contain the errors and false will be
	// returned.
	//
	// If the mount operation succeeded, g_volume_get_mount() on @volume is
	// guaranteed to return the mount right after calling this function; there's
	// no need to listen for the 'mount-added' signal on Monitor.
	MountFinish(result AsyncResult) error

	Removed()
	// ShouldAutomount returns whether the volume should be automatically
	// mounted.
	ShouldAutomount() bool
}

// Volume: the #GVolume interface represents user-visible objects that can be
// mounted. Note, when porting from GnomeVFS, #GVolume is the moral equivalent
// of VFSDrive.
//
// Mounting a #GVolume instance is an asynchronous operation. For more
// information about asynchronous operations, see Result and #GTask. To mount a
// #GVolume, first call g_volume_mount() with (at least) the #GVolume instance,
// optionally a Operation object and a ReadyCallback.
//
// Typically, one will only want to pass nil for the Operation if automounting
// all volumes when a desktop session starts since it's not desirable to put up
// a lot of dialogs asking for credentials.
//
// The callback will be fired when the operation has resolved (either with
// success or failure), and a Result instance will be passed to the callback.
// That callback should then call g_volume_mount_finish() with the #GVolume
// instance and the Result data to see if the operation was completed
// successfully. If an @error is present when g_volume_mount_finish() is called,
// then it will be filled with any error information.
//
//
// Volume Identifiers
//
// It is sometimes necessary to directly access the underlying operating system
// object behind a volume (e.g. for passing a volume to an application via the
// commandline). For this purpose, GIO allows to obtain an 'identifier' for the
// volume. There can be different kinds of identifiers, such as Hal UDIs,
// filesystem labels, traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO
// uses predefined strings as names for the different kinds of identifiers:
// VOLUME_IDENTIFIER_KIND_UUID, VOLUME_IDENTIFIER_KIND_LABEL, etc. Use
// g_volume_get_identifier() to obtain an identifier for a volume.
//
//    Note that VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available when the gvfs hal volume monitor is in use. Other volume monitors will generally be able to provide the VOLUME_IDENTIFIER_KIND_UNIX_DEVICE identifier, which can be used to obtain a hal device by means of libhal_manager_find_device_string_match().
type Volume interface {
	gextras.Objector

	// CanEject checks if a volume can be ejected.
	CanEject() bool
	// CanMount checks if a volume can be mounted.
	CanMount() bool
	// EjectFinish finishes ejecting a volume. If any errors occurred during the
	// operation, @error will be set to contain the errors and false will be
	// returned.
	EjectFinish(result AsyncResult) error
	// EjectWithOperationFinish finishes ejecting a volume. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
	EjectWithOperationFinish(result AsyncResult) error
	// EnumerateIdentifiers gets the kinds of [identifiers][volume-identifier]
	// that @volume has. Use g_volume_get_identifier() to obtain the identifiers
	// themselves.
	EnumerateIdentifiers() []string
	// ActivationRoot gets the activation root for a #GVolume if it is known
	// ahead of mount time. Returns nil otherwise. If not nil and if @volume is
	// mounted, then the result of g_mount_get_root() on the #GMount object
	// obtained from g_volume_get_mount() will always either be equal or a
	// prefix of what this function returns. In other words, in code
	//
	//    (g_file_has_prefix (volume_activation_root, mount_root) ||
	//     g_file_equal (volume_activation_root, mount_root))
	//
	// will always be true.
	//
	// Activation roots are typically used in Monitor implementations to find
	// the underlying mount to shadow, see g_mount_is_shadowed() for more
	// details.
	ActivationRoot() File
	// Drive gets the drive for the @volume.
	Drive() Drive
	// Icon gets the icon for @volume.
	Icon() Icon
	// Identifier gets the identifier of the given kind for @volume. See the
	// [introduction][volume-identifier] for more information about volume
	// identifiers.
	Identifier(kind string) string
	// Mount gets the mount for the @volume.
	Mount() Mount
	// Name gets the name of @volume.
	Name() string
	// SortKey gets the sort key for @volume, if any.
	SortKey() string
	// SymbolicIcon gets the symbolic icon for @volume.
	SymbolicIcon() Icon
	// UUID gets the UUID for the @volume. The reference is typically based on
	// the file system UUID for the volume in question and should be considered
	// an opaque string. Returns nil if there is no UUID available.
	UUID() string
	// MountFinish finishes mounting a volume. If any errors occurred during the
	// operation, @error will be set to contain the errors and false will be
	// returned.
	//
	// If the mount operation succeeded, g_volume_get_mount() on @volume is
	// guaranteed to return the mount right after calling this function; there's
	// no need to listen for the 'mount-added' signal on Monitor.
	MountFinish(result AsyncResult) error
	// ShouldAutomount returns whether the volume should be automatically
	// mounted.
	ShouldAutomount() bool
}

// volume implements the Volume interface.
type volume struct {
	gextras.Objector
}

var _ Volume = (*volume)(nil)

// WrapVolume wraps a GObject to a type that implements interface
// Volume. It is primarily used internally.
func WrapVolume(obj *externglib.Object) Volume {
	return volume{
		Objector: obj,
	}
}

func marshalVolume(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVolume(obj), nil
}

func (v volume) CanEject() bool {
	var _arg0 *C.GVolume // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_can_eject(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (v volume) CanMount() bool {
	var _arg0 *C.GVolume // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_can_mount(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (v volume) EjectFinish(result AsyncResult) error {
	var _arg0 *C.GVolume      // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_volume_eject_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (v volume) EjectWithOperationFinish(result AsyncResult) error {
	var _arg0 *C.GVolume      // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_volume_eject_with_operation_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (v volume) EnumerateIdentifiers() []string {
	var _arg0 *C.GVolume // out
	var _cret **C.char

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_enumerate_identifiers(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (v volume) ActivationRoot() File {
	var _arg0 *C.GVolume // out
	var _cret *C.GFile   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_get_activation_root(_arg0)

	var _file File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _file
}

func (v volume) Drive() Drive {
	var _arg0 *C.GVolume // out
	var _cret *C.GDrive  // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_get_drive(_arg0)

	var _drive Drive // out

	_drive = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Drive)

	return _drive
}

func (v volume) Icon() Icon {
	var _arg0 *C.GVolume // out
	var _cret *C.GIcon   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_get_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (v volume) Identifier(kind string) string {
	var _arg0 *C.GVolume // out
	var _arg1 *C.char    // out
	var _cret *C.char    // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.char)(C.CString(kind))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_get_identifier(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (v volume) Mount() Mount {
	var _arg0 *C.GVolume // out
	var _cret *C.GMount  // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_get_mount(_arg0)

	var _mount Mount // out

	_mount = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Mount)

	return _mount
}

func (v volume) Name() string {
	var _arg0 *C.GVolume // out
	var _cret *C.char    // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (v volume) SortKey() string {
	var _arg0 *C.GVolume // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_get_sort_key(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (v volume) SymbolicIcon() Icon {
	var _arg0 *C.GVolume // out
	var _cret *C.GIcon   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_get_symbolic_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (v volume) UUID() string {
	var _arg0 *C.GVolume // out
	var _cret *C.char    // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_get_uuid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (v volume) MountFinish(result AsyncResult) error {
	var _arg0 *C.GVolume      // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_volume_mount_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (v volume) ShouldAutomount() bool {
	var _arg0 *C.GVolume // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

	_cret = C.g_volume_should_automount(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor interface {
	gextras.Objector
}

// appInfoMonitor implements the AppInfoMonitor class.
type appInfoMonitor struct {
	gextras.Objector
}

var _ AppInfoMonitor = (*appInfoMonitor)(nil)

// WrapAppInfoMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppInfoMonitor(obj *externglib.Object) AppInfoMonitor {
	return appInfoMonitor{
		Objector: obj,
	}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppInfoMonitor(obj), nil
}

// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
type AppLaunchContext interface {
	gextras.Objector

	// Environment gets the complete environment variable list to be passed to
	// the child process when @context is used to launch an application. This is
	// a nil-terminated array of strings, where each string has the form
	// `KEY=VALUE`.
	Environment() []string
	// LaunchFailed: called when an application has failed to launch, so that it
	// can cancel the application startup notification started in
	// g_app_launch_context_get_startup_notify_id().
	LaunchFailed(startupNotifyId string)
	// Setenv arranges for @variable to be set to @value in the child's
	// environment when @context is used to launch an application.
	Setenv(variable string, value string)
	// Unsetenv arranges for @variable to be unset in the child's environment
	// when @context is used to launch an application.
	Unsetenv(variable string)
}

// appLaunchContext implements the AppLaunchContext class.
type appLaunchContext struct {
	gextras.Objector
}

var _ AppLaunchContext = (*appLaunchContext)(nil)

// WrapAppLaunchContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppLaunchContext(obj *externglib.Object) AppLaunchContext {
	return appLaunchContext{
		Objector: obj,
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppLaunchContext(obj), nil
}

// NewAppLaunchContext creates a new application launch context. This is not
// normally used, instead you instantiate a subclass of this, such as
// AppLaunchContext.
func NewAppLaunchContext() AppLaunchContext {
	var _cret *C.GAppLaunchContext // in

	_cret = C.g_app_launch_context_new()

	var _appLaunchContext AppLaunchContext // out

	_appLaunchContext = WrapAppLaunchContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appLaunchContext
}

func (c appLaunchContext) Environment() []string {
	var _arg0 *C.GAppLaunchContext // out
	var _cret **C.char

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_app_launch_context_get_environment(_arg0)

	var _filenames []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

func (c appLaunchContext) LaunchFailed(startupNotifyId string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(startupNotifyId))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_launch_context_launch_failed(_arg0, _arg1)
}

func (c appLaunchContext) Setenv(variable string, value string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out
	var _arg2 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_app_launch_context_setenv(_arg0, _arg1, _arg2)
}

func (c appLaunchContext) Unsetenv(variable string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_launch_context_unsetenv(_arg0, _arg1)
}

// Application: a #GApplication is the foundation of an application. It wraps
// some low-level platform-specific services and is intended to act as the
// foundation for higher-level application classes such as Application or
// Application. In general, you should not use this class outside of a higher
// level framework.
//
// GApplication provides convenient life cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using g_application_hold() and g_application_release(). If it drops to zero,
// the application exits. Higher-level classes such as Application employ the
// use count to ensure that the application stays alive as long as it has any
// opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent, but
// corresponds roughly to a graphical desktop login. When your application is
// launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
//
// The use of #GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a #GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling g_application_run(). All checks for uniqueness are
// done internally. If the application is the primary instance then the startup
// signal is emitted and the mainloop runs. If the application is not the
// primary instance then a signal is sent to the primary instance and
// g_application_run() promptly returns. See the code examples below.
//
// If used, the expected form of an application identifier is the same as that
// of of a D-Bus well-known bus name
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: `com.example.MyApp`,
// `org.example.internal_apps.Calculator`, `org._7_zip.Archiver`. For details on
// valid application identifiers, see g_application_id_is_valid().
//
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application is
// scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with the
// shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is not
// running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in g_application_register()).
// Unfortunately, this means that you cannot use g_application_get_is_remote()
// to decide if you want to register object paths.
//
// GApplication also implements the Group and Map interfaces and lets you easily
// export actions by adding them with g_action_map_add_action(). When invoking
// an action by calling g_action_group_activate_action() on the application, it
// is always invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the BusActionGroup wrapper to conveniently
// access them remotely. GIO provides a BusMenuModel wrapper for remote access
// to exported Models.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the application,
// GApplication passes some platform data from the launching instance to the
// primary instance, in the form of a #GVariant dictionary mapping strings to
// variants. To use platform data, override the @before_emit or @after_emit
// virtual functions in your #GApplication subclass. When dealing with
// CommandLine objects, the platform data is directly available via
// g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
//
// As the name indicates, the platform data may vary depending on the operating
// system, but it always includes the current directory (key "cwd"), and
// optionally the environment (ie the set of environment variables and their
// values) of the calling process (key "environ"). The environment is only added
// to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// #GApplication subclasses can add their own platform data by overriding the
// @add_platform_data virtual function. For instance, Application adds startup
// notification data in this way.
//
// To parse commandline arguments you may handle the #GApplication::command-line
// signal or override the local_command_line() vfunc, to parse them in either
// the primary instance or the local instance, respectively.
//
// For an example of opening files with a GApplication, see
// gapplication-example-open.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication, see
// gapplication-example-actions.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with GApplication, see
// gapplication-example-dbushooks.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).
type Application interface {
	gextras.Objector
	ActionGroup
	ActionMap

	// Activate activates the application.
	//
	// In essence, this results in the #GApplication::activate signal being
	// emitted in the primary instance.
	//
	// The application must be registered before calling this function.
	Activate()
	// AddMainOption: add an option to be handled by @application.
	//
	// Calling this function is the equivalent of calling
	// g_application_add_main_option_entries() with a single Entry that has its
	// arg_data member set to nil.
	//
	// The parsed arguments will be packed into a Dict which is passed to
	// #GApplication::handle-local-options. If
	// G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also be sent to
	// the primary instance. See g_application_add_main_option_entries() for
	// more details.
	//
	// See Entry for more documentation of the arguments.
	AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string)
	// AddMainOptionEntries adds main option entries to be handled by
	// @application.
	//
	// This function is comparable to g_option_context_add_main_entries().
	//
	// After the commandline arguments are parsed, the
	// #GApplication::handle-local-options signal will be emitted. At this
	// point, the application can inspect the values pointed to by @arg_data in
	// the given Entrys.
	//
	// Unlike Context, #GApplication supports giving a nil @arg_data for a
	// non-callback Entry. This results in the argument in question being packed
	// into a Dict which is also passed to #GApplication::handle-local-options,
	// where it can be inspected and modified. If
	// G_APPLICATION_HANDLES_COMMAND_LINE is set, then the resulting dictionary
	// is sent to the primary instance, where
	// g_application_command_line_get_options_dict() will return it. This
	// "packing" is done according to the type of the argument -- booleans for
	// normal flags, strings for strings, bytestrings for filenames, etc. The
	// packing only occurs if the flag is given (ie: we do not pack a "false"
	// #GVariant in the case that a flag is missing).
	//
	// In general, it is recommended that all commandline arguments are parsed
	// locally. The options dictionary should then be used to transmit the
	// result of the parsing to the primary instance, where
	// g_variant_dict_lookup() can be used. For local options, it is possible to
	// either use @arg_data in the usual way, or to consult (and potentially
	// remove) the option from the options dictionary.
	//
	// This function is new in GLib 2.40. Before then, the only real choice was
	// to send all of the commandline arguments (options and all) to the primary
	// instance for handling. #GApplication ignored them completely on the local
	// side. Calling this function "opts in" to the new behaviour, and in
	// particular, means that unrecognised options will be treated as errors.
	// Unrecognised options have never been ignored when
	// G_APPLICATION_HANDLES_COMMAND_LINE is unset.
	//
	// If #GApplication::handle-local-options needs to see the list of
	// filenames, then the use of G_OPTION_REMAINING is recommended. If
	// @arg_data is nil then G_OPTION_REMAINING can be used as a key into the
	// options dictionary. If you do use G_OPTION_REMAINING then you need to
	// handle these arguments for yourself because once they are consumed, they
	// will no longer be visible to the default handling (which treats them as
	// filenames to be opened).
	//
	// It is important to use the proper GVariant format when retrieving the
	// options with g_variant_dict_lookup(): - for G_OPTION_ARG_NONE, use `b` -
	// for G_OPTION_ARG_STRING, use `&s` - for G_OPTION_ARG_INT, use `i` - for
	// G_OPTION_ARG_INT64, use `x` - for G_OPTION_ARG_DOUBLE, use `d` - for
	// G_OPTION_ARG_FILENAME, use `^&ay` - for G_OPTION_ARG_STRING_ARRAY, use
	// `^a&s` - for G_OPTION_ARG_FILENAME_ARRAY, use `^a&ay`
	AddMainOptionEntries(entries []glib.OptionEntry)
	// AddOptionGroup adds a Group to the commandline handling of @application.
	//
	// This function is comparable to g_option_context_add_group().
	//
	// Unlike g_application_add_main_option_entries(), this function does not
	// deal with nil @arg_data and never transmits options to the primary
	// instance.
	//
	// The reason for that is because, by the time the options arrive at the
	// primary instance, it is typically too late to do anything with them.
	// Taking the GTK option group as an example: GTK will already have been
	// initialised by the time the #GApplication::command-line handler runs. In
	// the case that this is not the first-running instance of the application,
	// the existing instance may already have been running for a very long time.
	//
	// This means that the options from Group are only really usable in the case
	// that the instance of the application being run is the first instance.
	// Passing options like `--display=` or `--gdk-debug=` on future runs will
	// have no effect on the existing primary instance.
	//
	// Calling this function will cause the options in the supplied option group
	// to be parsed, but it does not cause you to be "opted in" to the new
	// functionality whereby unrecognised options are rejected even if
	// G_APPLICATION_HANDLES_COMMAND_LINE was given.
	AddOptionGroup(group *glib.OptionGroup)
	// BindBusyProperty marks @application as busy (see
	// g_application_mark_busy()) while @property on @object is true.
	//
	// The binding holds a reference to @application while it is active, but not
	// to @object. Instead, the binding is destroyed when @object is finalized.
	BindBusyProperty(object gextras.Objector, property string)
	// ApplicationID gets the unique identifier for @application.
	ApplicationID() string
	// DBusConnection gets the BusConnection being used by the application, or
	// nil.
	//
	// If #GApplication is using its D-Bus backend then this function will
	// return the BusConnection being used for uniqueness and communication with
	// the desktop environment and other instances of the application.
	//
	// If #GApplication is not using D-Bus then this function will return nil.
	// This includes the situation where the D-Bus backend would normally be in
	// use but we were unable to connect to the bus.
	//
	// This function must not be called before the application has been
	// registered. See g_application_get_is_registered().
	DBusConnection() DBusConnection
	// DBusObjectPath gets the D-Bus object path being used by the application,
	// or nil.
	//
	// If #GApplication is using its D-Bus backend then this function will
	// return the D-Bus object path that #GApplication is using. If the
	// application is the primary instance then there is an object published at
	// this path. If the application is not the primary instance then the result
	// of this function is undefined.
	//
	// If #GApplication is not using D-Bus then this function will return nil.
	// This includes the situation where the D-Bus backend would normally be in
	// use but we were unable to connect to the bus.
	//
	// This function must not be called before the application has been
	// registered. See g_application_get_is_registered().
	DBusObjectPath() string
	// Flags gets the flags for @application.
	//
	// See Flags.
	Flags() ApplicationFlags
	// InactivityTimeout gets the current inactivity timeout for the
	// application.
	//
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	InactivityTimeout() uint
	// IsBusy gets the application's current busy state, as set through
	// g_application_mark_busy() or g_application_bind_busy_property().
	IsBusy() bool
	// IsRegistered checks if @application is registered.
	//
	// An application is registered if g_application_register() has been
	// successfully called.
	IsRegistered() bool
	// IsRemote checks if @application is remote.
	//
	// If @application is remote then it means that another instance of
	// application already exists (the 'primary' instance). Calls to perform
	// actions on @application will result in the actions being performed by the
	// primary instance.
	//
	// The value of this property cannot be accessed before
	// g_application_register() has been called. See
	// g_application_get_is_registered().
	IsRemote() bool
	// ResourceBasePath gets the resource base path of @application.
	//
	// See g_application_set_resource_base_path() for more information.
	ResourceBasePath() string
	// Hold increases the use count of @application.
	//
	// Use this function to indicate that the application has a reason to
	// continue to run. For example, g_application_hold() is called by GTK+ when
	// a toplevel window is on the screen.
	//
	// To cancel the hold, call g_application_release().
	Hold()
	// MarkBusy increases the busy count of @application.
	//
	// Use this function to indicate that the application is busy, for instance
	// while a long running operation is pending.
	//
	// The busy state will be exposed to other processes, so a session shell
	// will use that information to indicate the state to the user (e.g. with a
	// spinner).
	//
	// To cancel the busy indication, use g_application_unmark_busy().
	MarkBusy()
	// Open opens the given files.
	//
	// In essence, this results in the #GApplication::open signal being emitted
	// in the primary instance.
	//
	// @n_files must be greater than zero.
	//
	// @hint is simply passed through to the ::open signal. It is intended to be
	// used by applications that have multiple modes for opening files (eg:
	// "view" vs "edit", etc). Unless you have a need for this functionality,
	// you should use "".
	//
	// The application must be registered before calling this function and it
	// must have the G_APPLICATION_HANDLES_OPEN flag set.
	Open(files []File, hint string)
	// Quit: immediately quits the application.
	//
	// Upon return to the mainloop, g_application_run() will return, calling
	// only the 'shutdown' function before doing so.
	//
	// The hold count is ignored. Take care if your code has called
	// g_application_hold() on the application and is therefore still expecting
	// it to exist. (Note that you may have called g_application_hold()
	// indirectly, for example through gtk_application_add_window().)
	//
	// The result of calling g_application_run() again after it returns is
	// unspecified.
	Quit()
	// Register attempts registration of the application.
	//
	// This is the point at which the application discovers if it is the primary
	// instance or merely acting as a remote for an already-existing primary
	// instance. This is implemented by attempting to acquire the application
	// identifier as a unique bus name on the session bus using GDBus.
	//
	// If there is no application ID or if G_APPLICATION_NON_UNIQUE was given,
	// then this process will always become the primary instance.
	//
	// Due to the internal architecture of GDBus, method calls can be dispatched
	// at any time (even if a main loop is not running). For this reason, you
	// must ensure that any object paths that you wish to register are
	// registered before calling this function.
	//
	// If the application has already been registered then true is returned with
	// no work performed.
	//
	// The #GApplication::startup signal is emitted if registration succeeds and
	// @application is the primary instance (including the non-unique case).
	//
	// In the event of an error (such as @cancellable being cancelled, or a
	// failure to connect to the session bus), false is returned and @error is
	// set appropriately.
	//
	// Note: the return value of this function is not an indicator that this
	// instance is or is not the primary instance of the application. See
	// g_application_get_is_remote() for that.
	Register(cancellable Cancellable) error
	// Release: decrease the use count of @application.
	//
	// When the use count reaches zero, the application will stop running.
	//
	// Never call this function except to cancel the effect of a previous call
	// to g_application_hold().
	Release()
	// Run runs the application.
	//
	// This function is intended to be run from main() and its return value is
	// intended to be returned by main(). Although you are expected to pass the
	// @argc, @argv parameters from main() to this function, it is possible to
	// pass nil if @argv is not available or commandline handling is not
	// required. Note that on Windows, @argc and @argv are ignored, and
	// g_win32_get_command_line() is called internally (for proper support of
	// Unicode commandline arguments).
	//
	// #GApplication will attempt to parse the commandline arguments. You can
	// add commandline flags to the list of recognised options by way of
	// g_application_add_main_option_entries(). After this, the
	// #GApplication::handle-local-options signal is emitted, from which the
	// application can inspect the values of its Entrys.
	//
	// #GApplication::handle-local-options is a good place to handle options
	// such as `--version`, where an immediate reply from the local process is
	// desired (instead of communicating with an already-running instance). A
	// #GApplication::handle-local-options handler can stop further processing
	// by returning a non-negative value, which then becomes the exit status of
	// the process.
	//
	// What happens next depends on the flags: if
	// G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
	// commandline arguments are sent to the primary instance, where a
	// #GApplication::command-line signal is emitted. Otherwise, the remaining
	// commandline arguments are assumed to be a list of files. If there are no
	// files listed, the application is activated via the
	// #GApplication::activate signal. If there are one or more files, and
	// G_APPLICATION_HANDLES_OPEN was specified then the files are opened via
	// the #GApplication::open signal.
	//
	// If you are interested in doing more complicated local handling of the
	// commandline then you should implement your own #GApplication subclass and
	// override local_command_line(). In this case, you most likely want to
	// return true from your local_command_line() implementation to suppress the
	// default handling. See
	// [gapplication-example-cmdline2.c][gapplication-example-cmdline2] for an
	// example.
	//
	// If, after the above is done, the use count of the application is zero
	// then the exit status is returned immediately. If the use count is
	// non-zero then the default main context is iterated until the use count
	// falls to zero, at which point 0 is returned.
	//
	// If the G_APPLICATION_IS_SERVICE flag is set, then the service will run
	// for as much as 10 seconds with a use count of zero while waiting for the
	// message that caused the activation to arrive. After that, if the use
	// count falls to zero the application will exit immediately, except in the
	// case that g_application_set_inactivity_timeout() is in use.
	//
	// This function sets the prgname (g_set_prgname()), if not already set, to
	// the basename of argv[0].
	//
	// Much like g_main_loop_run(), this function will acquire the main context
	// for the duration that the application is running.
	//
	// Since 2.40, applications that are not explicitly flagged as services or
	// launchers (ie: neither G_APPLICATION_IS_SERVICE or
	// G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
	// default handler for local_command_line) if "--gapplication-service" was
	// given in the command line. If this flag is present then normal
	// commandline processing is interrupted and the G_APPLICATION_IS_SERVICE
	// flag is set. This provides a "compromise" solution whereby running an
	// application directly from the commandline will invoke it in the normal
	// way (which can be useful for debugging) while still allowing applications
	// to be D-Bus activated in service mode. The D-Bus service file should
	// invoke the executable with "--gapplication-service" as the sole
	// commandline argument. This approach is suitable for use by most graphical
	// applications but should not be used from applications like editors that
	// need precise control over when processes invoked via the commandline will
	// exit and what their exit status will be.
	Run(argv []string) int
	// SendNotification sends a notification on behalf of @application to the
	// desktop shell. There is no guarantee that the notification is displayed
	// immediately, or even at all.
	//
	// Notifications may persist after the application exits. It will be
	// D-Bus-activated when the notification or one of its actions is activated.
	//
	// Modifying @notification after this call has no effect. However, the
	// object can be reused for a later call to this function.
	//
	// @id may be any string that uniquely identifies the event for the
	// application. It does not need to be in any special format. For example,
	// "new-message" might be appropriate for a notification about new messages.
	//
	// If a previous notification was sent with the same @id, it will be
	// replaced with @notification and shown again as if it was a new
	// notification. This works even for notifications sent from a previous
	// execution of the application, as long as @id is the same string.
	//
	// @id may be nil, but it is impossible to replace or withdraw notifications
	// without an id.
	//
	// If @notification is no longer relevant, it can be withdrawn with
	// g_application_withdraw_notification().
	SendNotification(id string, notification Notification)
	// SetActionGroup: this used to be how actions were associated with a
	// #GApplication. Now there is Map for that.
	SetActionGroup(actionGroup ActionGroup)
	// SetApplicationID sets the unique identifier for @application.
	//
	// The application id can only be modified if @application has not yet been
	// registered.
	//
	// If non-nil, the application id must be valid. See
	// g_application_id_is_valid().
	SetApplicationID(applicationId string)
	// SetDefault sets or unsets the default application for the process, as
	// returned by g_application_get_default().
	//
	// This function does not take its own reference on @application. If
	// @application is destroyed then the default application will revert back
	// to nil.
	SetDefault()
	// SetFlags sets the flags for @application.
	//
	// The flags can only be modified if @application has not yet been
	// registered.
	//
	// See Flags.
	SetFlags(flags ApplicationFlags)
	// SetInactivityTimeout sets the current inactivity timeout for the
	// application.
	//
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	//
	// This call has no side effects of its own. The value set here is only used
	// for next time g_application_release() drops the use count to zero. Any
	// timeouts currently in progress are not impacted.
	SetInactivityTimeout(inactivityTimeout uint)
	// SetOptionContextDescription adds a description to the @application option
	// context.
	//
	// See g_option_context_set_description() for more information.
	SetOptionContextDescription(description string)
	// SetOptionContextParameterString sets the parameter string to be used by
	// the commandline handling of @application.
	//
	// This function registers the argument to be passed to
	// g_option_context_new() when the internal Context of @application is
	// created.
	//
	// See g_option_context_new() for more information about @parameter_string.
	SetOptionContextParameterString(parameterString string)
	// SetOptionContextSummary adds a summary to the @application option
	// context.
	//
	// See g_option_context_set_summary() for more information.
	SetOptionContextSummary(summary string)
	// SetResourceBasePath sets (or unsets) the base resource path of
	// @application.
	//
	// The path is used to automatically load various [application
	// resources][gresource] such as menu layouts and action descriptions. The
	// various types of resources will be found at fixed names relative to the
	// given base path.
	//
	// By default, the resource base path is determined from the application ID
	// by prefixing '/' and replacing each '.' with '/'. This is done at the
	// time that the #GApplication object is constructed. Changes to the
	// application ID after that point will not have an impact on the resource
	// base path.
	//
	// As an example, if the application has an ID of "org.example.app" then the
	// default resource base path will be "/org/example/app". If this is a
	// Application (and you have not manually changed the path) then Gtk will
	// then search for the menus of the application at
	// "/org/example/app/gtk/menus.ui".
	//
	// See #GResource for more information about adding resources to your
	// application.
	//
	// You can disable automatic resource loading functionality by setting the
	// path to nil.
	//
	// Changing the resource base path once the application is running is not
	// recommended. The point at which the resource path is consulted for
	// forming paths for various purposes is unspecified. When writing a
	// sub-class of #GApplication you should either set the
	// #GApplication:resource-base-path property at construction time, or call
	// this function during the instance initialization. Alternatively, you can
	// call this function in the Class.startup virtual function, before chaining
	// up to the parent implementation.
	SetResourceBasePath(resourcePath string)
	// UnbindBusyProperty destroys a binding between @property and the busy
	// state of @application that was previously created with
	// g_application_bind_busy_property().
	UnbindBusyProperty(object gextras.Objector, property string)
	// UnmarkBusy decreases the busy count of @application.
	//
	// When the busy count reaches zero, the new state will be propagated to
	// other processes.
	//
	// This function must only be called to cancel the effect of a previous call
	// to g_application_mark_busy().
	UnmarkBusy()
	// WithdrawNotification withdraws a notification that was sent with
	// g_application_send_notification().
	//
	// This call does nothing if a notification with @id doesn't exist or the
	// notification was never sent.
	//
	// This function works even for notifications sent in previous executions of
	// this application, as long @id is the same as it was for the sent
	// notification.
	//
	// Note that notifications are dismissed when the user clicks on one of the
	// buttons in a notification or triggers its default action, so there is no
	// need to explicitly withdraw the notification in that case.
	WithdrawNotification(id string)
}

// application implements the Application class.
type application struct {
	gextras.Objector
	ActionGroup
	ActionMap
}

var _ Application = (*application)(nil)

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return application{
		Objector:    obj,
		ActionGroup: WrapActionGroup(obj),
		ActionMap:   WrapActionMap(obj),
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

// NewApplication creates a new #GApplication instance.
//
// If non-nil, the application id must be valid. See
// g_application_id_is_valid().
//
// If no application ID is given then some features of #GApplication (most
// notably application uniqueness) will be disabled.
func NewApplication(applicationId string, flags ApplicationFlags) Application {
	var _arg1 *C.gchar            // out
	var _arg2 C.GApplicationFlags // out
	var _cret *C.GApplication     // in

	_arg1 = (*C.gchar)(C.CString(applicationId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GApplicationFlags)(flags)

	_cret = C.g_application_new(_arg1, _arg2)

	var _application Application // out

	_application = WrapApplication(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _application
}

func (a application) Activate() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	C.g_application_activate(_arg0)
}

func (a application) AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.char         // out
	var _arg2 C.char          // out
	var _arg3 C.GOptionFlags  // out
	var _arg4 C.GOptionArg    // out
	var _arg5 *C.char         // out
	var _arg6 *C.char         // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(longName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.char)(shortName)
	_arg3 = (C.GOptionFlags)(flags)
	_arg4 = (C.GOptionArg)(arg)
	_arg5 = (*C.char)(C.CString(description))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.char)(C.CString(argDescription))
	defer C.free(unsafe.Pointer(_arg6))

	C.g_application_add_main_option(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (a application) AddMainOptionEntries(entries []glib.OptionEntry) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GOptionEntry

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	{
		var zero glib.OptionEntry
		entries = append(entries, zero)
	}
	_arg1 = (*C.GOptionEntry)(unsafe.Pointer(&entries[0]))

	C.g_application_add_main_option_entries(_arg0, _arg1)
}

func (a application) AddOptionGroup(group *glib.OptionGroup) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GOptionGroup // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GOptionGroup)(unsafe.Pointer(group.Native()))

	C.g_application_add_option_group(_arg0, _arg1)
}

func (a application) BindBusyProperty(object gextras.Objector, property string) {
	var _arg0 *C.GApplication // out
	var _arg1 C.gpointer      // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg2 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_application_bind_busy_property(_arg0, _arg1, _arg2)
}

func (a application) ApplicationID() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	_cret = C.g_application_get_application_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a application) DBusConnection() DBusConnection {
	var _arg0 *C.GApplication    // out
	var _cret *C.GDBusConnection // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	_cret = C.g_application_get_dbus_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

	return _dBusConnection
}

func (a application) DBusObjectPath() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	_cret = C.g_application_get_dbus_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a application) Flags() ApplicationFlags {
	var _arg0 *C.GApplication     // out
	var _cret C.GApplicationFlags // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	_cret = C.g_application_get_flags(_arg0)

	var _applicationFlags ApplicationFlags // out

	_applicationFlags = ApplicationFlags(_cret)

	return _applicationFlags
}

func (a application) InactivityTimeout() uint {
	var _arg0 *C.GApplication // out
	var _cret C.guint         // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	_cret = C.g_application_get_inactivity_timeout(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (a application) IsBusy() bool {
	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	_cret = C.g_application_get_is_busy(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a application) IsRegistered() bool {
	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	_cret = C.g_application_get_is_registered(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a application) IsRemote() bool {
	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	_cret = C.g_application_get_is_remote(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a application) ResourceBasePath() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	_cret = C.g_application_get_resource_base_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a application) Hold() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	C.g_application_hold(_arg0)
}

func (a application) MarkBusy() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	C.g_application_mark_busy(_arg0)
}

func (a application) Open(files []File, hint string) {
	var _arg0 *C.GApplication // out
	var _arg1 **C.GFile
	var _arg2 C.gint
	var _arg3 *C.gchar // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg2 = C.gint(len(files))
	_arg1 = (**C.GFile)(C.malloc(C.ulong(len(files)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(files))
		for i := range files {
			out[i] = (*C.GFile)(unsafe.Pointer(files[i].Native()))
		}
	}
	_arg3 = (*C.gchar)(C.CString(hint))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_application_open(_arg0, _arg1, _arg2, _arg3)
}

func (a application) Quit() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	C.g_application_quit(_arg0)
}

func (a application) Register(cancellable Cancellable) error {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_application_register(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a application) Release() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	C.g_application_release(_arg0)
}

func (a application) Run(argv []string) int {
	var _arg0 *C.GApplication // out
	var _arg2 **C.char
	var _arg1 C.int
	var _cret C.int // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = C.int(len(argv))
	_arg2 = (**C.char)(C.malloc(C.ulong(len(argv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_application_run(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (a application) SendNotification(id string, notification Notification) {
	var _arg0 *C.GApplication  // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GNotification // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GNotification)(unsafe.Pointer(notification.Native()))

	C.g_application_send_notification(_arg0, _arg1, _arg2)
}

func (a application) SetActionGroup(actionGroup ActionGroup) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GActionGroup // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GActionGroup)(unsafe.Pointer(actionGroup.Native()))

	C.g_application_set_action_group(_arg0, _arg1)
}

func (a application) SetApplicationID(applicationId string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(applicationId))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_set_application_id(_arg0, _arg1)
}

func (a application) SetDefault() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	C.g_application_set_default(_arg0)
}

func (a application) SetFlags(flags ApplicationFlags) {
	var _arg0 *C.GApplication     // out
	var _arg1 C.GApplicationFlags // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (C.GApplicationFlags)(flags)

	C.g_application_set_flags(_arg0, _arg1)
}

func (a application) SetInactivityTimeout(inactivityTimeout uint) {
	var _arg0 *C.GApplication // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (C.guint)(inactivityTimeout)

	C.g_application_set_inactivity_timeout(_arg0, _arg1)
}

func (a application) SetOptionContextDescription(description string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_set_option_context_description(_arg0, _arg1)
}

func (a application) SetOptionContextParameterString(parameterString string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(parameterString))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_set_option_context_parameter_string(_arg0, _arg1)
}

func (a application) SetOptionContextSummary(summary string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(summary))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_set_option_context_summary(_arg0, _arg1)
}

func (a application) SetResourceBasePath(resourcePath string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_set_resource_base_path(_arg0, _arg1)
}

func (a application) UnbindBusyProperty(object gextras.Objector, property string) {
	var _arg0 *C.GApplication // out
	var _arg1 C.gpointer      // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg2 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_application_unbind_busy_property(_arg0, _arg1, _arg2)
}

func (a application) UnmarkBusy() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

	C.g_application_unmark_busy(_arg0)
}

func (a application) WithdrawNotification(id string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_withdraw_notification(_arg0, _arg1)
}

// ApplicationCommandLine represents a command-line invocation of an
// application. It is created by #GApplication and emitted in the
// #GApplication::command-line signal and virtual function.
//
// The class contains the list of arguments that the program was invoked with.
// It is also possible to query if the commandline invocation was local (ie: the
// current process is running in direct response to the invocation) or remote
// (ie: some other process forwarded the commandline to this process).
//
// The GApplicationCommandLine object can provide the @argc and @argv parameters
// for use with the Context command-line parsing API, with the
// g_application_command_line_get_arguments() function. See
// [gapplication-example-cmdline3.c][gapplication-example-cmdline3] for an
// example.
//
// The exit status of the originally-invoked process may be set and messages can
// be printed to stdout or stderr of that process. The lifecycle of the
// originally-invoked process is tied to the lifecycle of this object (ie: the
// process exits when the last reference is dropped).
//
// The main use for CommandLine (and the #GApplication::command-line signal) is
// 'Emacs server' like use cases: You can set the `EDITOR` environment variable
// to have e.g. git use your favourite editor to edit commit messages, and if
// you already have an instance of the editor running, the editing will happen
// in the running instance, instead of opening a new one. An important aspect of
// this use case is that the process that gets started by git does not return
// until the editing is done.
//
// Normally, the commandline is completely handled in the
// #GApplication::command-line handler. The launching instance exits once the
// signal handler in the primary instance has returned, and the return value of
// the signal handler becomes the exit status of the launching instance.
//
//    static gboolean
//    my_cmdline_handler (gpointer data)
//    {
//      GApplicationCommandLine *cmdline = data;
//
//      // do the heavy lifting in an idle
//
//      g_application_command_line_set_exit_status (cmdline, 0);
//      g_object_unref (cmdline); // this releases the application
//
//      return G_SOURCE_REMOVE;
//    }
//
//    static int
//    command_line (GApplication            *application,
//                  GApplicationCommandLine *cmdline)
//    {
//      // keep the application running until we are done with this commandline
//      g_application_hold (application);
//
//      g_object_set_data_full (G_OBJECT (cmdline),
//                              "application", application,
//                              (GDestroyNotify)g_application_release);
//
//      g_object_ref (cmdline);
//      g_idle_add (my_cmdline_handler, cmdline);
//
//      return 0;
//    }
//
// In this example the commandline is not completely handled before the
// #GApplication::command-line handler returns. Instead, we keep a reference to
// the CommandLine object and handle it later (in this example, in an idle).
// Note that it is necessary to hold the application until you are done with the
// commandline.
//
// The complete example can be found here: gapplication-example-cmdline3.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline3.c)
type ApplicationCommandLine interface {
	gextras.Objector

	// CreateFileForArg creates a #GFile corresponding to a filename that was
	// given as part of the invocation of @cmdline.
	//
	// This differs from g_file_new_for_commandline_arg() in that it resolves
	// relative pathnames using the current working directory of the invoking
	// process rather than the local process.
	CreateFileForArg(arg string) File
	// Cwd gets the working directory of the command line invocation. The string
	// may contain non-utf8 data.
	//
	// It is possible that the remote application did not send a working
	// directory, so this may be nil.
	//
	// The return value should not be modified or freed and is valid for as long
	// as @cmdline exists.
	Cwd() string
	// Environ gets the contents of the 'environ' variable of the command line
	// invocation, as would be returned by g_get_environ(), ie as a
	// nil-terminated list of strings in the form 'NAME=VALUE'. The strings may
	// contain non-utf8 data.
	//
	// The remote application usually does not send an environment. Use
	// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
	// is possible that the environment is still not available (due to
	// invocation messages from other applications).
	//
	// The return value should not be modified or freed and is valid for as long
	// as @cmdline exists.
	//
	// See g_application_command_line_getenv() if you are only interested in the
	// value of a single environment variable.
	Environ() []string
	// ExitStatus gets the exit status of @cmdline. See
	// g_application_command_line_set_exit_status() for more information.
	ExitStatus() int
	// IsRemote determines if @cmdline represents a remote invocation.
	IsRemote() bool
	// OptionsDict gets the options there were passed to
	// g_application_command_line().
	//
	// If you did not override local_command_line() then these are the same
	// options that were parsed according to the Entrys added to the application
	// with g_application_add_main_option_entries() and possibly modified from
	// your GApplication::handle-local-options handler.
	//
	// If no options were sent then an empty dictionary is returned so that you
	// don't need to check for nil.
	OptionsDict() *glib.VariantDict
	// PlatformData gets the platform data associated with the invocation of
	// @cmdline.
	//
	// This is a #GVariant dictionary containing information about the context
	// in which the invocation occurred. It typically contains information like
	// the current working directory and the startup notification ID.
	//
	// For local invocation, it will be nil.
	PlatformData() *glib.Variant
	// Stdin gets the stdin of the invoking process.
	//
	// The Stream can be used to read data passed to the standard input of the
	// invoking process. This doesn't work on all platforms. Presently, it is
	// only available on UNIX when using a D-Bus daemon capable of passing file
	// descriptors. If stdin is not available then nil will be returned. In the
	// future, support may be expanded to other platforms.
	//
	// You must only call this function once per commandline invocation.
	Stdin() InputStream
	// env gets the value of a particular environment variable of the command
	// line invocation, as would be returned by g_getenv(). The strings may
	// contain non-utf8 data.
	//
	// The remote application usually does not send an environment. Use
	// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
	// is possible that the environment is still not available (due to
	// invocation messages from other applications).
	//
	// The return value should not be modified or freed and is valid for as long
	// as @cmdline exists.
	env(name string) string
	// SetExitStatus sets the exit status that will be used when the invoking
	// process exits.
	//
	// The return value of the #GApplication::command-line signal is passed to
	// this function when the handler returns. This is the usual way of setting
	// the exit status.
	//
	// In the event that you want the remote invocation to continue running and
	// want to decide on the exit status in the future, you can use this call.
	// For the case of a remote invocation, the remote process will typically
	// exit when the last reference is dropped on @cmdline. The exit status of
	// the remote process will be equal to the last value that was set with this
	// function.
	//
	// In the case that the commandline invocation is local, the situation is
	// slightly more complicated. If the commandline invocation results in the
	// mainloop running (ie: because the use-count of the application increased
	// to a non-zero value) then the application is considered to have been
	// 'successful' in a certain sense, and the exit status is always zero. If
	// the application use count is zero, though, the exit status of the local
	// CommandLine is used.
	SetExitStatus(exitStatus int)
}

// applicationCommandLine implements the ApplicationCommandLine class.
type applicationCommandLine struct {
	gextras.Objector
}

var _ ApplicationCommandLine = (*applicationCommandLine)(nil)

// WrapApplicationCommandLine wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplicationCommandLine(obj *externglib.Object) ApplicationCommandLine {
	return applicationCommandLine{
		Objector: obj,
	}
}

func marshalApplicationCommandLine(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplicationCommandLine(obj), nil
}

func (c applicationCommandLine) CreateFileForArg(arg string) File {
	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 *C.gchar                   // out
	var _cret *C.GFile                   // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(arg))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_application_command_line_create_file_for_arg(_arg0, _arg1)

	var _file File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _file
}

func (c applicationCommandLine) Cwd() string {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret *C.gchar                   // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

	_cret = C.g_application_command_line_get_cwd(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (c applicationCommandLine) Environ() []string {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret **C.gchar

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

	_cret = C.g_application_command_line_get_environ(_arg0)

	var _filenames []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
		}
	}

	return _filenames
}

func (c applicationCommandLine) ExitStatus() int {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret C.int                      // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

	_cret = C.g_application_command_line_get_exit_status(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c applicationCommandLine) IsRemote() bool {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

	_cret = C.g_application_command_line_get_is_remote(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c applicationCommandLine) OptionsDict() *glib.VariantDict {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret *C.GVariantDict            // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

	_cret = C.g_application_command_line_get_options_dict(_arg0)

	var _variantDict *glib.VariantDict // out

	_variantDict = glib.WrapVariantDict(unsafe.Pointer(_cret))

	return _variantDict
}

func (c applicationCommandLine) PlatformData() *glib.Variant {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret *C.GVariant                // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

	_cret = C.g_application_command_line_get_platform_data(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (c applicationCommandLine) Stdin() InputStream {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret *C.GInputStream            // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

	_cret = C.g_application_command_line_get_stdin(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)

	return _inputStream
}

func (c applicationCommandLine) env(name string) string {
	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 *C.gchar                   // out
	var _cret *C.gchar                   // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_application_command_line_getenv(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c applicationCommandLine) SetExitStatus(exitStatus int) {
	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 C.int                      // out

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(exitStatus)

	C.g_application_command_line_set_exit_status(_arg0, _arg1)
}

// BufferedInputStream: buffered input stream implements InputStream and
// provides for buffered reads.
//
// By default, InputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered input stream, use g_buffered_input_stream_new(), or
// g_buffered_input_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_input_stream_get_buffer_size(). To change the size of a buffered
// input stream's buffer, use g_buffered_input_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedInputStream interface {
	FilterInputStream
	Seekable

	// Fill tries to read @count bytes from the stream into the buffer. Will
	// block during this read.
	//
	// If @count is zero, returns zero and does nothing. A value of @count
	// larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes read into the buffer is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. near the end of a file. Zero is returned on end of file (or
	// if @count is zero), but never otherwise.
	//
	// If @count is -1 then the attempted read size is equal to the number of
	// bytes that are required to fill the buffer.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	//
	// For the asynchronous, non-blocking, version of this function, see
	// g_buffered_input_stream_fill_async().
	Fill(count int, cancellable Cancellable) (int, error)
	// FillFinish finishes an asynchronous read.
	FillFinish(result AsyncResult) (int, error)
	// Available gets the size of the available data within the stream.
	Available() uint
	// BufferSize gets the size of the input buffer.
	BufferSize() uint
	// Peek peeks in the buffer, copying data of size @count into @buffer,
	// offset @offset bytes.
	Peek(buffer []byte, offset uint) uint
	// ReadByte tries to read a single byte from the stream or the buffer. Will
	// block during this read.
	//
	// On success, the byte read from the stream is returned. On end of stream
	// -1 is returned but it's not an exceptional error and @error is not set.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	ReadByte(cancellable Cancellable) (int, error)
	// SetBufferSize sets the size of the internal buffer of @stream to @size,
	// or to the size of the contents of the buffer. The buffer can never be
	// resized smaller than its current contents.
	SetBufferSize(size uint)
}

// bufferedInputStream implements the BufferedInputStream class.
type bufferedInputStream struct {
	FilterInputStream
	Seekable
}

var _ BufferedInputStream = (*bufferedInputStream)(nil)

// WrapBufferedInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapBufferedInputStream(obj *externglib.Object) BufferedInputStream {
	return bufferedInputStream{
		FilterInputStream: WrapFilterInputStream(obj),
		Seekable:          WrapSeekable(obj),
	}
}

func marshalBufferedInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBufferedInputStream(obj), nil
}

// NewBufferedInputStream creates a new Stream from the given @base_stream, with
// a buffer set to the default size (4 kilobytes).
func NewBufferedInputStream(baseStream InputStream) BufferedInputStream {
	var _arg1 *C.GInputStream // out
	var _cret *C.GInputStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(baseStream.Native()))

	_cret = C.g_buffered_input_stream_new(_arg1)

	var _bufferedInputStream BufferedInputStream // out

	_bufferedInputStream = WrapBufferedInputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferedInputStream
}

// NewBufferedInputStreamSized creates a new InputStream from the given
// @base_stream, with a buffer set to @size.
func NewBufferedInputStreamSized(baseStream InputStream, size uint) BufferedInputStream {
	var _arg1 *C.GInputStream // out
	var _arg2 C.gsize         // out
	var _cret *C.GInputStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(baseStream.Native()))
	_arg2 = (C.gsize)(size)

	_cret = C.g_buffered_input_stream_new_sized(_arg1, _arg2)

	var _bufferedInputStream BufferedInputStream // out

	_bufferedInputStream = WrapBufferedInputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferedInputStream
}

func (s bufferedInputStream) Fill(count int, cancellable Cancellable) (int, error) {
	var _arg0 *C.GBufferedInputStream // out
	var _arg1 C.gssize                // out
	var _arg2 *C.GCancellable         // out
	var _cret C.gssize                // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gssize)(count)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_buffered_input_stream_fill(_arg0, _arg1, _arg2, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s bufferedInputStream) FillFinish(result AsyncResult) (int, error) {
	var _arg0 *C.GBufferedInputStream // out
	var _arg1 *C.GAsyncResult         // out
	var _cret C.gssize                // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_buffered_input_stream_fill_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s bufferedInputStream) Available() uint {
	var _arg0 *C.GBufferedInputStream // out
	var _cret C.gsize                 // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_buffered_input_stream_get_available(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (s bufferedInputStream) BufferSize() uint {
	var _arg0 *C.GBufferedInputStream // out
	var _cret C.gsize                 // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_buffered_input_stream_get_buffer_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (s bufferedInputStream) Peek(buffer []byte, offset uint) uint {
	var _arg0 *C.GBufferedInputStream // out
	var _arg1 *C.void
	var _arg3 C.gsize
	var _arg2 C.gsize // out
	var _cret C.gsize // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
	_arg3 = C.gsize(len(buffer))
	_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	_arg2 = (C.gsize)(offset)

	_cret = C.g_buffered_input_stream_peek(_arg0, _arg1, _arg2, _arg3)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (s bufferedInputStream) ReadByte(cancellable Cancellable) (int, error) {
	var _arg0 *C.GBufferedInputStream // out
	var _arg1 *C.GCancellable         // out
	var _cret C.int                   // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_buffered_input_stream_read_byte(_arg0, _arg1, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (s bufferedInputStream) SetBufferSize(size uint) {
	var _arg0 *C.GBufferedInputStream // out
	var _arg1 C.gsize                 // out

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gsize)(size)

	C.g_buffered_input_stream_set_buffer_size(_arg0, _arg1)
}

// BufferedOutputStream: buffered output stream implements OutputStream and
// provides for buffered writes.
//
// By default, OutputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered output stream, use g_buffered_output_stream_new(), or
// g_buffered_output_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_output_stream_get_buffer_size(). To change the size of a buffered
// output stream's buffer, use g_buffered_output_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedOutputStream interface {
	FilterOutputStream
	Seekable

	// AutoGrow checks if the buffer automatically grows as data is added.
	AutoGrow() bool
	// BufferSize gets the size of the buffer in the @stream.
	BufferSize() uint
	// SetAutoGrow sets whether or not the @stream's buffer should automatically
	// grow. If @auto_grow is true, then each write will just make the buffer
	// larger, and you must manually flush the buffer to actually write out the
	// data to the underlying stream.
	SetAutoGrow(autoGrow bool)
	// SetBufferSize sets the size of the internal buffer to @size.
	SetBufferSize(size uint)
}

// bufferedOutputStream implements the BufferedOutputStream class.
type bufferedOutputStream struct {
	FilterOutputStream
	Seekable
}

var _ BufferedOutputStream = (*bufferedOutputStream)(nil)

// WrapBufferedOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapBufferedOutputStream(obj *externglib.Object) BufferedOutputStream {
	return bufferedOutputStream{
		FilterOutputStream: WrapFilterOutputStream(obj),
		Seekable:           WrapSeekable(obj),
	}
}

func marshalBufferedOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBufferedOutputStream(obj), nil
}

// NewBufferedOutputStream creates a new buffered output stream for a base
// stream.
func NewBufferedOutputStream(baseStream OutputStream) BufferedOutputStream {
	var _arg1 *C.GOutputStream // out
	var _cret *C.GOutputStream // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(baseStream.Native()))

	_cret = C.g_buffered_output_stream_new(_arg1)

	var _bufferedOutputStream BufferedOutputStream // out

	_bufferedOutputStream = WrapBufferedOutputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferedOutputStream
}

// NewBufferedOutputStreamSized creates a new buffered output stream with a
// given buffer size.
func NewBufferedOutputStreamSized(baseStream OutputStream, size uint) BufferedOutputStream {
	var _arg1 *C.GOutputStream // out
	var _arg2 C.gsize          // out
	var _cret *C.GOutputStream // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(baseStream.Native()))
	_arg2 = (C.gsize)(size)

	_cret = C.g_buffered_output_stream_new_sized(_arg1, _arg2)

	var _bufferedOutputStream BufferedOutputStream // out

	_bufferedOutputStream = WrapBufferedOutputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferedOutputStream
}

func (s bufferedOutputStream) AutoGrow() bool {
	var _arg0 *C.GBufferedOutputStream // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_buffered_output_stream_get_auto_grow(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s bufferedOutputStream) BufferSize() uint {
	var _arg0 *C.GBufferedOutputStream // out
	var _cret C.gsize                  // in

	_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_buffered_output_stream_get_buffer_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (s bufferedOutputStream) SetAutoGrow(autoGrow bool) {
	var _arg0 *C.GBufferedOutputStream // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(s.Native()))
	if autoGrow {
		_arg1 = C.TRUE
	}

	C.g_buffered_output_stream_set_auto_grow(_arg0, _arg1)
}

func (s bufferedOutputStream) SetBufferSize(size uint) {
	var _arg0 *C.GBufferedOutputStream // out
	var _arg1 C.gsize                  // out

	_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gsize)(size)

	C.g_buffered_output_stream_set_buffer_size(_arg0, _arg1)
}

// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
type BytesIcon interface {
	gextras.Objector
	Icon
	LoadableIcon
}

// bytesIcon implements the BytesIcon class.
type bytesIcon struct {
	gextras.Objector
	Icon
	LoadableIcon
}

var _ BytesIcon = (*bytesIcon)(nil)

// WrapBytesIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapBytesIcon(obj *externglib.Object) BytesIcon {
	return bytesIcon{
		Objector:     obj,
		Icon:         WrapIcon(obj),
		LoadableIcon: WrapLoadableIcon(obj),
	}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBytesIcon(obj), nil
}

// Cancellable: GCancellable is a thread-safe operation cancellation stack used
// throughout GIO to allow for cancellation of synchronous and asynchronous
// operations.
type Cancellable interface {
	gextras.Objector

	// Cancel: will set @cancellable to cancelled, and will emit the
	// #GCancellable::cancelled signal. (However, see the warning about race
	// conditions in the documentation for that signal if you are planning to
	// connect to it.)
	//
	// This function is thread-safe. In other words, you can safely call it from
	// a thread other than the one running the operation that was passed the
	// @cancellable.
	//
	// If @cancellable is nil, this function returns immediately for
	// convenience.
	//
	// The convention within GIO is that cancelling an asynchronous operation
	// causes it to complete asynchronously. That is, if you cancel the
	// operation from the same thread in which it is running, then the
	// operation's ReadyCallback will not be invoked until the application
	// returns to the main loop.
	Cancel()
	// Disconnect disconnects a handler from a cancellable instance similar to
	// g_signal_handler_disconnect(). Additionally, in the event that a signal
	// handler is currently running, this call will block until the handler has
	// finished. Calling this function from a #GCancellable::cancelled signal
	// handler will therefore result in a deadlock.
	//
	// This avoids a race condition where a thread cancels at the same time as
	// the cancellable operation is finished and the signal handler is removed.
	// See #GCancellable::cancelled for details on how to use this.
	//
	// If @cancellable is nil or @handler_id is `0` this function does nothing.
	Disconnect(handlerId uint32)
	// Fd gets the file descriptor for a cancellable job. This can be used to
	// implement cancellable operations on Unix systems. The returned fd will
	// turn readable when @cancellable is cancelled.
	//
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done with
	// g_cancellable_reset().
	//
	// After a successful return from this function, you should use
	// g_cancellable_release_fd() to free up resources allocated for the
	// returned file descriptor.
	//
	// See also g_cancellable_make_pollfd().
	Fd() int
	// IsCancelled checks if a cancellable job has been cancelled.
	IsCancelled() bool
	// MakePollfd creates a FD corresponding to @cancellable; this can be passed
	// to g_poll() and used to poll for cancellation. This is useful both for
	// unix systems without a native poll and for portability to windows.
	//
	// When this function returns true, you should use
	// g_cancellable_release_fd() to free up resources allocated for the
	// @pollfd. After a false return, do not call g_cancellable_release_fd().
	//
	// If this function returns false, either no @cancellable was given or
	// resource limits prevent this function from allocating the necessary
	// structures for polling. (On Linux, you will likely have reached the
	// maximum number of file descriptors.) The suggested way to handle these
	// cases is to ignore the @cancellable.
	//
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done with
	// g_cancellable_reset().
	MakePollfd(pollfd *glib.PollFD) bool
	// PopCurrent pops @cancellable off the cancellable stack (verifying that
	// @cancellable is on the top of the stack).
	PopCurrent()
	// PushCurrent pushes @cancellable onto the cancellable stack. The current
	// cancellable can then be received using g_cancellable_get_current().
	//
	// This is useful when implementing cancellable operations in code that does
	// not allow you to pass down the cancellable object.
	//
	// This is typically called automatically by e.g. #GFile operations, so you
	// rarely have to call this yourself.
	PushCurrent()
	// ReleaseFd releases a resources previously allocated by
	// g_cancellable_get_fd() or g_cancellable_make_pollfd().
	//
	// For compatibility reasons with older releases, calling this function is
	// not strictly required, the resources will be automatically freed when the
	// @cancellable is finalized. However, the @cancellable will block scarce
	// file descriptors until it is finalized if this function is not called.
	// This can cause the application to run out of file descriptors when many
	// #GCancellables are used at the same time.
	ReleaseFd()
	// Reset resets @cancellable to its uncancelled state.
	//
	// If cancellable is currently in use by any cancellable operation then the
	// behavior of this function is undefined.
	//
	// Note that it is generally not a good idea to reuse an existing
	// cancellable for more operations after it has been cancelled once, as this
	// function might tempt you to do. The recommended practice is to drop the
	// reference to a cancellable after cancelling it, and let it die with the
	// outstanding async operations. You should create a fresh cancellable for
	// further async operations.
	Reset()
	// SetErrorIfCancelled: if the @cancellable is cancelled, sets the error to
	// notify that the operation was cancelled.
	SetErrorIfCancelled() error
}

// cancellable implements the Cancellable class.
type cancellable struct {
	gextras.Objector
}

var _ Cancellable = (*cancellable)(nil)

// WrapCancellable wraps a GObject to the right type. It is
// primarily used internally.
func WrapCancellable(obj *externglib.Object) Cancellable {
	return cancellable{
		Objector: obj,
	}
}

func marshalCancellable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCancellable(obj), nil
}

// NewCancellable creates a new #GCancellable object.
//
// Applications that want to start one or more operations that should be
// cancellable should create a #GCancellable and pass it to the operations.
//
// One #GCancellable can be used in multiple consecutive operations or in
// multiple concurrent operations.
func NewCancellable() Cancellable {
	var _cret *C.GCancellable // in

	_cret = C.g_cancellable_new()

	var _cancellable Cancellable // out

	_cancellable = WrapCancellable(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cancellable
}

func (c cancellable) Cancel() {
	var _arg0 *C.GCancellable // out

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

	C.g_cancellable_cancel(_arg0)
}

func (c cancellable) Disconnect(handlerId uint32) {
	var _arg0 *C.GCancellable // out
	var _arg1 C.gulong        // out

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gulong)(handlerId)

	C.g_cancellable_disconnect(_arg0, _arg1)
}

func (c cancellable) Fd() int {
	var _arg0 *C.GCancellable // out
	var _cret C.int           // in

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

	_cret = C.g_cancellable_get_fd(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c cancellable) IsCancelled() bool {
	var _arg0 *C.GCancellable // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

	_cret = C.g_cancellable_is_cancelled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cancellable) MakePollfd(pollfd *glib.PollFD) bool {
	var _arg0 *C.GCancellable // out
	var _arg1 *C.GPollFD      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GPollFD)(unsafe.Pointer(pollfd.Native()))

	_cret = C.g_cancellable_make_pollfd(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cancellable) PopCurrent() {
	var _arg0 *C.GCancellable // out

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

	C.g_cancellable_pop_current(_arg0)
}

func (c cancellable) PushCurrent() {
	var _arg0 *C.GCancellable // out

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

	C.g_cancellable_push_current(_arg0)
}

func (c cancellable) ReleaseFd() {
	var _arg0 *C.GCancellable // out

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

	C.g_cancellable_release_fd(_arg0)
}

func (c cancellable) Reset() {
	var _arg0 *C.GCancellable // out

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

	C.g_cancellable_reset(_arg0)
}

func (c cancellable) SetErrorIfCancelled() error {
	var _arg0 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

	C.g_cancellable_set_error_if_cancelled(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// CharsetConverter is an implementation of #GConverter based on GIConv.
type CharsetConverter interface {
	gextras.Objector
	Converter
	Initable

	// NumFallbacks gets the number of fallbacks that @converter has applied so
	// far.
	NumFallbacks() uint
	// UseFallback gets the Converter:use-fallback property.
	UseFallback() bool
	// SetUseFallback sets the Converter:use-fallback property.
	SetUseFallback(useFallback bool)
}

// charsetConverter implements the CharsetConverter class.
type charsetConverter struct {
	gextras.Objector
	Converter
	Initable
}

var _ CharsetConverter = (*charsetConverter)(nil)

// WrapCharsetConverter wraps a GObject to the right type. It is
// primarily used internally.
func WrapCharsetConverter(obj *externglib.Object) CharsetConverter {
	return charsetConverter{
		Objector:  obj,
		Converter: WrapConverter(obj),
		Initable:  WrapInitable(obj),
	}
}

func marshalCharsetConverter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCharsetConverter(obj), nil
}

// NewCharsetConverter creates a new Converter.
func NewCharsetConverter(toCharset string, fromCharset string) (CharsetConverter, error) {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _cret *C.GCharsetConverter // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(C.CString(toCharset))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(fromCharset))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_charset_converter_new(_arg1, _arg2, &_cerr)

	var _charsetConverter CharsetConverter // out
	var _goerr error                       // out

	_charsetConverter = WrapCharsetConverter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _charsetConverter, _goerr
}

func (c charsetConverter) NumFallbacks() uint {
	var _arg0 *C.GCharsetConverter // out
	var _cret C.guint              // in

	_arg0 = (*C.GCharsetConverter)(unsafe.Pointer(c.Native()))

	_cret = C.g_charset_converter_get_num_fallbacks(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (c charsetConverter) UseFallback() bool {
	var _arg0 *C.GCharsetConverter // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GCharsetConverter)(unsafe.Pointer(c.Native()))

	_cret = C.g_charset_converter_get_use_fallback(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c charsetConverter) SetUseFallback(useFallback bool) {
	var _arg0 *C.GCharsetConverter // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GCharsetConverter)(unsafe.Pointer(c.Native()))
	if useFallback {
		_arg1 = C.TRUE
	}

	C.g_charset_converter_set_use_fallback(_arg0, _arg1)
}

// ConverterInputStream: converter input stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, InputStream implements InputStream.
type ConverterInputStream interface {
	FilterInputStream
	PollableInputStream

	// Converter gets the #GConverter that is used by @converter_stream.
	Converter() Converter
}

// converterInputStream implements the ConverterInputStream class.
type converterInputStream struct {
	FilterInputStream
	PollableInputStream
}

var _ ConverterInputStream = (*converterInputStream)(nil)

// WrapConverterInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapConverterInputStream(obj *externglib.Object) ConverterInputStream {
	return converterInputStream{
		FilterInputStream:   WrapFilterInputStream(obj),
		PollableInputStream: WrapPollableInputStream(obj),
	}
}

func marshalConverterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConverterInputStream(obj), nil
}

// NewConverterInputStream creates a new converter input stream for the
// @base_stream.
func NewConverterInputStream(baseStream InputStream, converter Converter) ConverterInputStream {
	var _arg1 *C.GInputStream // out
	var _arg2 *C.GConverter   // out
	var _cret *C.GInputStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(baseStream.Native()))
	_arg2 = (*C.GConverter)(unsafe.Pointer(converter.Native()))

	_cret = C.g_converter_input_stream_new(_arg1, _arg2)

	var _converterInputStream ConverterInputStream // out

	_converterInputStream = WrapConverterInputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _converterInputStream
}

func (c converterInputStream) Converter() Converter {
	var _arg0 *C.GConverterInputStream // out
	var _cret *C.GConverter            // in

	_arg0 = (*C.GConverterInputStream)(unsafe.Pointer(c.Native()))

	_cret = C.g_converter_input_stream_get_converter(_arg0)

	var _converter Converter // out

	_converter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Converter)

	return _converter
}

// ConverterOutputStream: converter output stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, OutputStream implements OutputStream.
type ConverterOutputStream interface {
	FilterOutputStream
	PollableOutputStream

	// Converter gets the #GConverter that is used by @converter_stream.
	Converter() Converter
}

// converterOutputStream implements the ConverterOutputStream class.
type converterOutputStream struct {
	FilterOutputStream
	PollableOutputStream
}

var _ ConverterOutputStream = (*converterOutputStream)(nil)

// WrapConverterOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapConverterOutputStream(obj *externglib.Object) ConverterOutputStream {
	return converterOutputStream{
		FilterOutputStream:   WrapFilterOutputStream(obj),
		PollableOutputStream: WrapPollableOutputStream(obj),
	}
}

func marshalConverterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConverterOutputStream(obj), nil
}

// NewConverterOutputStream creates a new converter output stream for the
// @base_stream.
func NewConverterOutputStream(baseStream OutputStream, converter Converter) ConverterOutputStream {
	var _arg1 *C.GOutputStream // out
	var _arg2 *C.GConverter    // out
	var _cret *C.GOutputStream // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(baseStream.Native()))
	_arg2 = (*C.GConverter)(unsafe.Pointer(converter.Native()))

	_cret = C.g_converter_output_stream_new(_arg1, _arg2)

	var _converterOutputStream ConverterOutputStream // out

	_converterOutputStream = WrapConverterOutputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _converterOutputStream
}

func (c converterOutputStream) Converter() Converter {
	var _arg0 *C.GConverterOutputStream // out
	var _cret *C.GConverter             // in

	_arg0 = (*C.GConverterOutputStream)(unsafe.Pointer(c.Native()))

	_cret = C.g_converter_output_stream_get_converter(_arg0)

	var _converter Converter // out

	_converter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Converter)

	return _converter
}

// Credentials: the #GCredentials type is a reference-counted wrapper for native
// credentials. This information is typically used for identifying,
// authenticating and authorizing other processes.
//
// Some operating systems supports looking up the credentials of the remote peer
// of a communication endpoint - see e.g. g_socket_get_credentials().
//
// Some operating systems supports securely sending and receiving credentials
// over a Unix Domain Socket, see CredentialsMessage,
// g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials() for details.
//
// On Linux, the native credential type is a `struct ucred` - see the unix(7)
// man page for details. This corresponds to G_CREDENTIALS_TYPE_LINUX_UCRED.
//
// On Apple operating systems (including iOS, tvOS, and macOS), the native
// credential type is a `struct xucred`. This corresponds to
// G_CREDENTIALS_TYPE_APPLE_XUCRED.
//
// On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is
// a `struct cmsgcred`. This corresponds to G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
//
// On NetBSD, the native credential type is a `struct unpcbid`. This corresponds
// to G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
//
// On OpenBSD, the native credential type is a `struct sockpeercred`. This
// corresponds to G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
//
// On Solaris (including OpenSolaris and its derivatives), the native credential
// type is a `ucred_t`. This corresponds to G_CREDENTIALS_TYPE_SOLARIS_UCRED.
type Credentials interface {
	gextras.Objector

	// UnixPid tries to get the UNIX process identifier from @credentials. This
	// method is only available on UNIX platforms.
	//
	// This operation can fail if #GCredentials is not supported on the OS or if
	// the native credentials type does not contain information about the UNIX
	// process ID (for example this is the case for
	// G_CREDENTIALS_TYPE_APPLE_XUCRED).
	UnixPid() (int, error)
	// UnixUser tries to get the UNIX user identifier from @credentials. This
	// method is only available on UNIX platforms.
	//
	// This operation can fail if #GCredentials is not supported on the OS or if
	// the native credentials type does not contain information about the UNIX
	// user.
	UnixUser() (uint, error)
	// IsSameUser checks if @credentials and @other_credentials is the same
	// user.
	//
	// This operation can fail if #GCredentials is not supported on the the OS.
	IsSameUser(otherCredentials Credentials) error
	// SetUnixUser tries to set the UNIX user identifier on @credentials. This
	// method is only available on UNIX platforms.
	//
	// This operation can fail if #GCredentials is not supported on the OS or if
	// the native credentials type does not contain information about the UNIX
	// user. It can also fail if the OS does not allow the use of "spoofed"
	// credentials.
	SetUnixUser(uid uint) error
	// String creates a human-readable textual representation of @credentials
	// that can be used in logging and debug messages. The format of the
	// returned string may change in future GLib release.
	String() string
}

// credentials implements the Credentials class.
type credentials struct {
	gextras.Objector
}

var _ Credentials = (*credentials)(nil)

// WrapCredentials wraps a GObject to the right type. It is
// primarily used internally.
func WrapCredentials(obj *externglib.Object) Credentials {
	return credentials{
		Objector: obj,
	}
}

func marshalCredentials(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCredentials(obj), nil
}

// NewCredentials creates a new #GCredentials object with credentials matching
// the the current process.
func NewCredentials() Credentials {
	var _cret *C.GCredentials // in

	_cret = C.g_credentials_new()

	var _credentials Credentials // out

	_credentials = WrapCredentials(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _credentials
}

func (c credentials) UnixPid() (int, error) {
	var _arg0 *C.GCredentials // out
	var _cret C.pid_t         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))

	_cret = C.g_credentials_get_unix_pid(_arg0, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (c credentials) UnixUser() (uint, error) {
	var _arg0 *C.GCredentials // out
	var _cret C.uid_t         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))

	_cret = C.g_credentials_get_unix_user(_arg0, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

func (c credentials) IsSameUser(otherCredentials Credentials) error {
	var _arg0 *C.GCredentials // out
	var _arg1 *C.GCredentials // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCredentials)(unsafe.Pointer(otherCredentials.Native()))

	C.g_credentials_is_same_user(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c credentials) SetUnixUser(uid uint) error {
	var _arg0 *C.GCredentials // out
	var _arg1 C.uid_t         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))
	_arg1 = (C.uid_t)(uid)

	C.g_credentials_set_unix_user(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c credentials) String() string {
	var _arg0 *C.GCredentials // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))

	_cret = C.g_credentials_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup interface {
	gextras.Objector
	ActionGroup
	RemoteActionGroup
}

// dBusActionGroup implements the DBusActionGroup class.
type dBusActionGroup struct {
	gextras.Objector
	ActionGroup
	RemoteActionGroup
}

var _ DBusActionGroup = (*dBusActionGroup)(nil)

// WrapDBusActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusActionGroup(obj *externglib.Object) DBusActionGroup {
	return dBusActionGroup{
		Objector:          obj,
		ActionGroup:       WrapActionGroup(obj),
		RemoteActionGroup: WrapRemoteActionGroup(obj),
	}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusActionGroup(obj), nil
}

// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
type DBusAuthObserver interface {
	gextras.Objector

	// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
	// @observer.
	AllowMechanism(mechanism string) bool
	// AuthorizeAuthenticatedPeer emits the
	// BusAuthObserver::authorize-authenticated-peer signal on @observer.
	AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool
}

// dBusAuthObserver implements the DBusAuthObserver class.
type dBusAuthObserver struct {
	gextras.Objector
}

var _ DBusAuthObserver = (*dBusAuthObserver)(nil)

// WrapDBusAuthObserver wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusAuthObserver(obj *externglib.Object) DBusAuthObserver {
	return dBusAuthObserver{
		Objector: obj,
	}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusAuthObserver(obj), nil
}

// NewDBusAuthObserver creates a new BusAuthObserver object.
func NewDBusAuthObserver() DBusAuthObserver {
	var _cret *C.GDBusAuthObserver // in

	_cret = C.g_dbus_auth_observer_new()

	var _dBusAuthObserver DBusAuthObserver // out

	_dBusAuthObserver = WrapDBusAuthObserver(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusAuthObserver
}

func (o dBusAuthObserver) AllowMechanism(mechanism string) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.gchar             // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(mechanism))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_auth_observer_allow_mechanism(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o dBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.GIOStream         // out
	var _arg2 *C.GCredentials      // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.GCredentials)(unsafe.Pointer(credentials.Native()))

	_cret = C.g_dbus_auth_observer_authorize_authenticated_peer(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
//
// An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
//
// An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
//
// An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
//
// An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection interface {
	gextras.Objector
	AsyncInitable
	Initable

	// CallFinish finishes an operation started with g_dbus_connection_call().
	CallFinish(res AsyncResult) (*glib.Variant, error)
	// CallSync: synchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//    g_dbus_connection_call_sync (connection,
	//                                 "org.freedesktop.StringThings",
	//                                 "/org/freedesktop/StringThings",
	//                                 "org.freedesktop.StringThings",
	//                                 "TwoStrings",
	//                                 g_variant_new ("(ss)",
	//                                                "Thing One",
	//                                                "Thing Two"),
	//                                 NULL,
	//                                 G_DBUS_CALL_FLAGS_NONE,
	//                                 -1,
	//                                 NULL,
	//                                 &error);
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_connection_call() for the asynchronous version of this method.
	CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error)
	// CallWithUnixFdListFinish finishes an operation started with
	// g_dbus_connection_call_with_unix_fd_list().
	//
	// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values
	// in the body of the message. For example, if g_variant_get_handle()
	// returns 5, that is intended to be a reference to the file descriptor that
	// can be accessed by `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
	//
	// When designing D-Bus APIs that are intended to be interoperable, please
	// note that non-GDBus implementations of D-Bus can usually only access file
	// descriptors if they are referenced in this way by a value of type
	// G_VARIANT_TYPE_HANDLE in the body of the message.
	CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error)
	// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes
	// and returns FDList objects. See
	// g_dbus_connection_call_with_unix_fd_list() and
	// g_dbus_connection_call_with_unix_fd_list_finish() for more details.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error)
	// CloseFinish finishes an operation started with g_dbus_connection_close().
	CloseFinish(res AsyncResult) error
	// CloseSync: synchronously closes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_close() for the
	// asynchronous version of this method and more details about what it does.
	CloseSync(cancellable Cancellable) error
	// EmitSignal emits a signal.
	//
	// If the parameters GVariant is floating, it is consumed.
	//
	// This can only fail if @parameters is not compatible with the D-Bus
	// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
	// (G_IO_ERROR_CLOSED).
	EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error
	// ExportActionGroup exports @action_group on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// A given object path can only have one action group exported on it. If
	// this constraint is violated, the export will fail and 0 will be returned
	// (with @error set accordingly).
	//
	// You can unexport the action group using
	// g_dbus_connection_unexport_action_group() with the return value of this
	// function.
	//
	// The thread default main context is taken at the time of this call. All
	// incoming action activations and state change requests are reported from
	// this context. Any changes on the action group that cause it to emit
	// signals must also come from this same context. Since incoming action
	// activations and state change requests are rather likely to cause changes
	// on the action group, this effectively limits a given action group to
	// being exported from only one main context.
	ExportActionGroup(objectPath string, actionGroup ActionGroup) (uint, error)
	// ExportMenuModel exports @menu on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// An object path can only have one menu model exported on it. If this
	// constraint is violated, the export will fail and 0 will be returned (with
	// @error set accordingly).
	//
	// You can unexport the menu model using
	// g_dbus_connection_unexport_menu_model() with the return value of this
	// function.
	ExportMenuModel(objectPath string, menu MenuModel) (uint, error)
	// FlushFinish finishes an operation started with g_dbus_connection_flush().
	FlushFinish(res AsyncResult) error
	// FlushSync: synchronously flushes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_flush() for the
	// asynchronous version of this method and more details about what it does.
	FlushSync(cancellable Cancellable) error
	// Capabilities gets the capabilities negotiated with the remote peer
	Capabilities() DBusCapabilityFlags
	// ExitOnClose gets whether the process is terminated when @connection is
	// closed by the remote peer. See BusConnection:exit-on-close for more
	// details.
	ExitOnClose() bool
	// Flags gets the flags used to construct this connection
	Flags() DBusConnectionFlags
	// Guid: the GUID of the peer performing the role of server when
	// authenticating. See BusConnection:guid for more details.
	Guid() string
	// LastSerial retrieves the last serial number assigned to a BusMessage on
	// the current thread. This includes messages sent via both low-level API
	// such as g_dbus_connection_send_message() as well as high-level API such
	// as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
	// g_dbus_proxy_call().
	LastSerial() uint32
	// PeerCredentials gets the credentials of the authenticated peer. This will
	// always return nil unless @connection acted as a server (e.g.
	// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and
	// the client passed credentials as part of the authentication process.
	//
	// In a message bus setup, the message bus is always the server and each
	// application is a client. So this method will always return nil for
	// message bus clients.
	PeerCredentials() Credentials
	// Stream gets the underlying stream used for IO.
	//
	// While the BusConnection is active, it will interact with this stream from
	// a worker thread, so it is not safe to interact with the stream directly.
	Stream() IOStream
	// UniqueName gets the unique name of @connection as assigned by the message
	// bus. This can also be used to figure out if @connection is a message bus
	// connection.
	UniqueName() string
	// IsClosed gets whether @connection is closed.
	IsClosed() bool
	// RemoveFilter removes a filter.
	//
	// Note that since filters run in a different thread, there is a race
	// condition where it is possible that the filter will be running even after
	// calling g_dbus_connection_remove_filter(), so you cannot just free data
	// that the filter might be using. Instead, you should pass a Notify to
	// g_dbus_connection_add_filter(), which will be called when it is
	// guaranteed that the data is no longer needed.
	RemoveFilter(filterId uint)
	// SendMessage: asynchronously sends @message to the peer represented by
	// @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport. While it has a `volatile` qualifier,
	// this is a historical artifact and the argument passed to it should not be
	// `volatile`.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @message is not well-formed, the operation fails
	// with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessage(message DBusMessage, flags DBusSendMessageFlags) (uint32, error)
	// SendMessageWithReplyFinish finishes an operation started with
	// g_dbus_connection_send_message_with_reply().
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	SendMessageWithReplyFinish(res AsyncResult) (DBusMessage, error)
	// SendMessageWithReplySync: synchronously sends @message to the peer
	// represented by @connection and blocks the calling thread until a reply is
	// received or the timeout is reached. See
	// g_dbus_connection_send_message_with_reply() for the asynchronous version
	// of this method.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport. While it has a `volatile` qualifier,
	// this is a historical artifact and the argument passed to it should not be
	// `volatile`.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (uint32, DBusMessage, error)
	// SetExitOnClose sets whether the process should be terminated when
	// @connection is closed by the remote peer. See BusConnection:exit-on-close
	// for more details.
	//
	// Note that this function should be used with care. Most modern UNIX
	// desktops tie the notion of a user session with the session bus, and
	// expect all of a user's applications to quit when their bus connection
	// goes away. If you are setting @exit_on_close to false for the shared
	// session bus connection, you should make sure that your application exits
	// when the user session ends.
	SetExitOnClose(exitOnClose bool)
	// SignalUnsubscribe unsubscribes from signals.
	//
	// Note that there may still be D-Bus traffic to process (relating to this
	// signal subscription) in the current thread-default Context after this
	// function has returned. You should continue to iterate the Context until
	// the Notify function passed to g_dbus_connection_signal_subscribe() is
	// called, in order to avoid memory leaks through callbacks queued on the
	// Context after its stopped being iterated.
	SignalUnsubscribe(subscriptionId uint)
	// StartMessageProcessing: if @connection was created with
	// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
	// processing messages. Does nothing on if @connection wasn't created with
	// this flag or if the method has already been called.
	StartMessageProcessing()
	// UnexportActionGroup reverses the effect of a previous call to
	// g_dbus_connection_export_action_group().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_action_group() or to call it with the same ID
	// more than once.
	UnexportActionGroup(exportId uint)
	// UnexportMenuModel reverses the effect of a previous call to
	// g_dbus_connection_export_menu_model().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_menu_model() or to call it with the same ID more
	// than once.
	UnexportMenuModel(exportId uint)
	// UnregisterObject unregisters an object.
	UnregisterObject(registrationId uint) bool
	// UnregisterSubtree unregisters a subtree.
	UnregisterSubtree(registrationId uint) bool
}

// dBusConnection implements the DBusConnection class.
type dBusConnection struct {
	gextras.Objector
	AsyncInitable
	Initable
}

var _ DBusConnection = (*dBusConnection)(nil)

// WrapDBusConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusConnection(obj *externglib.Object) DBusConnection {
	return dBusConnection{
		Objector:      obj,
		AsyncInitable: WrapAsyncInitable(obj),
		Initable:      WrapInitable(obj),
	}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusConnection(obj), nil
}

// NewDBusConnectionFinish finishes an operation started with
// g_dbus_connection_new().
func NewDBusConnectionFinish(res AsyncResult) (DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_new_finish(_arg1, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = WrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressFinish finishes an operation started with
// g_dbus_connection_new_for_address().
func NewDBusConnectionForAddressFinish(res AsyncResult) (DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_new_for_address_finish(_arg1, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = WrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressSync: synchronously connects and sets up a D-Bus
// client connection for exchanging D-Bus messages with an endpoint specified by
// @address which must be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This constructor can only be used to initiate client-side connections - use
// g_dbus_connection_new_sync() if you need to act as the server. In particular,
// @flags cannot contain the G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
//
// This is a synchronous failable constructor. See
// g_dbus_connection_new_for_address() for the asynchronous version.
//
// If @observer is not nil it may be used to control the authentication process.
func NewDBusConnectionForAddressSync(address string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (DBusConnection, error) {
	var _arg1 *C.gchar               // out
	var _arg2 C.GDBusConnectionFlags // out
	var _arg3 *C.GDBusAuthObserver   // out
	var _arg4 *C.GCancellable        // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	_arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GDBusConnectionFlags)(flags)
	_arg3 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_new_for_address_sync(_arg1, _arg2, _arg3, _arg4, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = WrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionSync: synchronously sets up a D-Bus connection for
// exchanging D-Bus messages with the end represented by @stream.
//
// If @stream is a Connection, then the corresponding #GSocket will be put into
// non-blocking mode.
//
// The D-Bus connection will interact with @stream from a worker thread. As a
// result, the caller should not interact with @stream after this method has
// been called, except by calling g_object_unref() on it.
//
// If @observer is not nil it may be used to control the authentication process.
//
// This is a synchronous failable constructor. See g_dbus_connection_new() for
// the asynchronous version.
func NewDBusConnectionSync(stream IOStream, guid string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (DBusConnection, error) {
	var _arg1 *C.GIOStream           // out
	var _arg2 *C.gchar               // out
	var _arg3 C.GDBusConnectionFlags // out
	var _arg4 *C.GDBusAuthObserver   // out
	var _arg5 *C.GCancellable        // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.GDBusConnectionFlags)(flags)
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = WrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

func (c dBusConnection) CallFinish(res AsyncResult) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_call_finish(_arg0, _arg1, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

func (c dBusConnection) CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _arg9 *C.GCancellable    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	_arg7 = (C.GDBusCallFlags)(flags)
	_arg8 = (C.gint)(timeoutMsec)
	_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

func (c dBusConnection) CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GUnixFDList     // in
	var _arg2 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_call_with_unix_fd_list_finish(_arg0, &_arg1, _arg2, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1))).(UnixFDList)
	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

func (c dBusConnection) CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _arg9 *C.GUnixFDList     // out
	var _arg10 *C.GUnixFDList    // in
	var _arg11 *C.GCancellable   // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	_arg7 = (C.GDBusCallFlags)(flags)
	_arg8 = (C.gint)(timeoutMsec)
	_arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	_arg11 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_call_with_unix_fd_list_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_arg10, _arg11, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg10))).(UnixFDList)
	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

func (c dBusConnection) CloseFinish(res AsyncResult) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_dbus_connection_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) CloseSync(cancellable Cancellable) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dbus_connection_close_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(destinationBusName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

	C.g_dbus_connection_emit_signal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) ExportActionGroup(objectPath string, actionGroup ActionGroup) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GActionGroup    // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer(actionGroup.Native()))

	_cret = C.g_dbus_connection_export_action_group(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

func (c dBusConnection) ExportMenuModel(objectPath string, menu MenuModel) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GMenuModel      // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(menu.Native()))

	_cret = C.g_dbus_connection_export_menu_model(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

func (c dBusConnection) FlushFinish(res AsyncResult) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_dbus_connection_flush_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) FlushSync(cancellable Cancellable) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dbus_connection_flush_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) Capabilities() DBusCapabilityFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusCapabilityFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_capabilities(_arg0)

	var _dBusCapabilityFlags DBusCapabilityFlags // out

	_dBusCapabilityFlags = DBusCapabilityFlags(_cret)

	return _dBusCapabilityFlags
}

func (c dBusConnection) ExitOnClose() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_exit_on_close(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dBusConnection) Flags() DBusConnectionFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusConnectionFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_flags(_arg0)

	var _dBusConnectionFlags DBusConnectionFlags // out

	_dBusConnectionFlags = DBusConnectionFlags(_cret)

	return _dBusConnectionFlags
}

func (c dBusConnection) Guid() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c dBusConnection) LastSerial() uint32 {
	var _arg0 *C.GDBusConnection // out
	var _cret C.guint32          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_last_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

func (c dBusConnection) PeerCredentials() Credentials {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GCredentials    // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_peer_credentials(_arg0)

	var _credentials Credentials // out

	_credentials = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Credentials)

	return _credentials
}

func (c dBusConnection) Stream() IOStream {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GIOStream       // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_stream(_arg0)

	var _ioStream IOStream // out

	_ioStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IOStream)

	return _ioStream
}

func (c dBusConnection) UniqueName() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_unique_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c dBusConnection) IsClosed() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dBusConnection) RemoveFilter(filterId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(filterId)

	C.g_dbus_connection_remove_filter(_arg0, _arg1)
}

func (c dBusConnection) SendMessage(message DBusMessage, flags DBusSendMessageFlags) (uint32, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.guint32               // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = (C.GDBusSendMessageFlags)(flags)

	C.g_dbus_connection_send_message(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _outSerial uint32 // out
	var _goerr error      // out

	_outSerial = (uint32)(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outSerial, _goerr
}

func (c dBusConnection) SendMessageWithReplyFinish(res AsyncResult) (DBusMessage, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusMessage    // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_send_message_with_reply_finish(_arg0, _arg1, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

func (c dBusConnection) SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (uint32, DBusMessage, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg4 C.guint32               // in
	var _arg5 *C.GCancellable         // out
	var _cret *C.GDBusMessage         // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = (C.GDBusSendMessageFlags)(flags)
	_arg3 = (C.gint)(timeoutMsec)
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_send_message_with_reply_sync(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, &_cerr)

	var _outSerial uint32        // out
	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_outSerial = (uint32)(_arg4)
	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outSerial, _dBusMessage, _goerr
}

func (c dBusConnection) SetExitOnClose(exitOnClose bool) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	if exitOnClose {
		_arg1 = C.TRUE
	}

	C.g_dbus_connection_set_exit_on_close(_arg0, _arg1)
}

func (c dBusConnection) SignalUnsubscribe(subscriptionId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(subscriptionId)

	C.g_dbus_connection_signal_unsubscribe(_arg0, _arg1)
}

func (c dBusConnection) StartMessageProcessing() {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	C.g_dbus_connection_start_message_processing(_arg0)
}

func (c dBusConnection) UnexportActionGroup(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(exportId)

	C.g_dbus_connection_unexport_action_group(_arg0, _arg1)
}

func (c dBusConnection) UnexportMenuModel(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(exportId)

	C.g_dbus_connection_unexport_menu_model(_arg0, _arg1)
}

func (c dBusConnection) UnregisterObject(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(registrationId)

	_cret = C.g_dbus_connection_unregister_object(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dBusConnection) UnregisterSubtree(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(registrationId)

	_cret = C.g_dbus_connection_unregister_subtree(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusInterfaceSkeleton: abstract base class for D-Bus interfaces on the
// service side.
type DBusInterfaceSkeleton interface {
	gextras.Objector
	DBusInterface

	// Export exports @interface_ at @object_path on @connection.
	//
	// This can be called multiple times to export the same @interface_ onto
	// multiple connections however the @object_path provided must be the same
	// for all connections.
	//
	// Use g_dbus_interface_skeleton_unexport() to unexport the object.
	Export(connection DBusConnection, objectPath string) error
	// Flush: if @interface_ has outstanding changes, request for these changes
	// to be emitted immediately.
	//
	// For example, an exported D-Bus interface may queue up property changes
	// and emit the `org.freedesktop.DBus.Properties.PropertiesChanged` signal
	// later (e.g. in an idle handler). This technique is useful for collapsing
	// multiple property changes into one.
	Flush()
	// Connection gets the first connection that @interface_ is exported on, if
	// any.
	Connection() DBusConnection
	// Flags gets the BusInterfaceSkeletonFlags that describes what the behavior
	// of @interface_
	Flags() DBusInterfaceSkeletonFlags
	// Info gets D-Bus introspection information for the D-Bus interface
	// implemented by @interface_.
	Info() *DBusInterfaceInfo
	// ObjectPath gets the object path that @interface_ is exported on, if any.
	ObjectPath() string
	// Properties gets all D-Bus properties for @interface_.
	Properties() *glib.Variant
	// HasConnection checks if @interface_ is exported on @connection.
	HasConnection(connection DBusConnection) bool
	// SetFlags sets flags describing what the behavior of @skeleton should be.
	SetFlags(flags DBusInterfaceSkeletonFlags)
	// Unexport stops exporting @interface_ on all connections it is exported
	// on.
	//
	// To unexport @interface_ from only a single connection, use
	// g_dbus_interface_skeleton_unexport_from_connection()
	Unexport()
	// UnexportFromConnection stops exporting @interface_ on @connection.
	//
	// To stop exporting on all connections the interface is exported on, use
	// g_dbus_interface_skeleton_unexport().
	UnexportFromConnection(connection DBusConnection)
}

// dBusInterfaceSkeleton implements the DBusInterfaceSkeleton class.
type dBusInterfaceSkeleton struct {
	gextras.Objector
	DBusInterface
}

var _ DBusInterfaceSkeleton = (*dBusInterfaceSkeleton)(nil)

// WrapDBusInterfaceSkeleton wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusInterfaceSkeleton(obj *externglib.Object) DBusInterfaceSkeleton {
	return dBusInterfaceSkeleton{
		Objector:      obj,
		DBusInterface: WrapDBusInterface(obj),
	}
}

func marshalDBusInterfaceSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusInterfaceSkeleton(obj), nil
}

func (i dBusInterfaceSkeleton) Export(connection DBusConnection, objectPath string) error {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _arg1 *C.GDBusConnection        // out
	var _arg2 *C.gchar                  // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_dbus_interface_skeleton_export(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (i dBusInterfaceSkeleton) Flush() {
	var _arg0 *C.GDBusInterfaceSkeleton // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

	C.g_dbus_interface_skeleton_flush(_arg0)
}

func (i dBusInterfaceSkeleton) Connection() DBusConnection {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GDBusConnection        // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_interface_skeleton_get_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

	return _dBusConnection
}

func (i dBusInterfaceSkeleton) Flags() DBusInterfaceSkeletonFlags {
	var _arg0 *C.GDBusInterfaceSkeleton     // out
	var _cret C.GDBusInterfaceSkeletonFlags // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_interface_skeleton_get_flags(_arg0)

	var _dBusInterfaceSkeletonFlags DBusInterfaceSkeletonFlags // out

	_dBusInterfaceSkeletonFlags = DBusInterfaceSkeletonFlags(_cret)

	return _dBusInterfaceSkeletonFlags
}

func (i dBusInterfaceSkeleton) Info() *DBusInterfaceInfo {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GDBusInterfaceInfo     // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_interface_skeleton_get_info(_arg0)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	_dBusInterfaceInfo = WrapDBusInterfaceInfo(unsafe.Pointer(_cret))

	return _dBusInterfaceInfo
}

func (i dBusInterfaceSkeleton) ObjectPath() string {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.gchar                  // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_interface_skeleton_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusInterfaceSkeleton) Properties() *glib.Variant {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GVariant               // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_interface_skeleton_get_properties(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (i dBusInterfaceSkeleton) HasConnection(connection DBusConnection) bool {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _arg1 *C.GDBusConnection        // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	_cret = C.g_dbus_interface_skeleton_has_connection(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i dBusInterfaceSkeleton) SetFlags(flags DBusInterfaceSkeletonFlags) {
	var _arg0 *C.GDBusInterfaceSkeleton     // out
	var _arg1 C.GDBusInterfaceSkeletonFlags // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GDBusInterfaceSkeletonFlags)(flags)

	C.g_dbus_interface_skeleton_set_flags(_arg0, _arg1)
}

func (i dBusInterfaceSkeleton) Unexport() {
	var _arg0 *C.GDBusInterfaceSkeleton // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

	C.g_dbus_interface_skeleton_unexport(_arg0)
}

func (i dBusInterfaceSkeleton) UnexportFromConnection(connection DBusConnection) {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _arg1 *C.GDBusConnection        // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	C.g_dbus_interface_skeleton_unexport_from_connection(_arg0, _arg1)
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel interface {
	MenuModel
}

// dBusMenuModel implements the DBusMenuModel class.
type dBusMenuModel struct {
	MenuModel
}

var _ DBusMenuModel = (*dBusMenuModel)(nil)

// WrapDBusMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMenuModel(obj *externglib.Object) DBusMenuModel {
	return dBusMenuModel{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMenuModel(obj), nil
}

// DBusMessage: a type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage interface {
	gextras.Objector

	// Copy copies @message. The copy is a deep copy and the returned BusMessage
	// is completely identical except that it is guaranteed to not be locked.
	//
	// This operation can fail if e.g. @message contains file descriptors and
	// the per-process or system-wide open files limit is reached.
	Copy() (DBusMessage, error)
	// Arg0: convenience to get the first item in the body of @message.
	Arg0() string
	// Body gets the body of a message.
	Body() *glib.Variant
	// ByteOrder gets the byte order of @message.
	ByteOrder() DBusMessageByteOrder
	// Destination: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	Destination() string
	// ErrorName: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	ErrorName() string
	// Flags gets the flags for @message.
	Flags() DBusMessageFlags
	// Header gets a header field on @message.
	//
	// The caller is responsible for checking the type of the returned #GVariant
	// matches what is expected.
	Header(headerField DBusMessageHeaderField) *glib.Variant
	// HeaderFields gets an array of all header fields on @message that are set.
	HeaderFields() []byte
	// Interface: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	Interface() string
	// Locked checks whether @message is locked. To monitor changes to this
	// value, conncet to the #GObject::notify signal to listen for changes on
	// the BusMessage:locked property.
	Locked() bool
	// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	Member() string
	// MessageType gets the type of @message.
	MessageType() DBusMessageType
	// NumUnixFds: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	NumUnixFds() uint32
	// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
	// field.
	Path() string
	// ReplySerial: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	ReplySerial() uint32
	// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	Sender() string
	// Serial gets the serial for @message.
	Serial() uint32
	// Signature: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	Signature() string
	// UnixFdList gets the UNIX file descriptors associated with @message, if
	// any.
	//
	// This method is only available on UNIX.
	//
	// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values
	// in the body of the message. For example, if g_variant_get_handle()
	// returns 5, that is intended to be a reference to the file descriptor that
	// can be accessed by `g_unix_fd_list_get (list, 5, ...)`.
	UnixFdList() UnixFDList
	// Lock: if @message is locked, does nothing. Otherwise locks the message.
	Lock()
	// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
	// @method_call_message.
	NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage
	// NewMethodReply creates a new BusMessage that is a reply to
	// @method_call_message.
	NewMethodReply() DBusMessage
	// Print produces a human-readable multi-line description of @message.
	//
	// The contents of the description has no ABI guarantees, the contents and
	// formatting is subject to change at any time. Typical output looks
	// something like this:
	//
	//    Flags:   none
	//    Version: 0
	//    Serial:  4
	//    Headers:
	//      path -> objectpath '/org/gtk/GDBus/TestObject'
	//      interface -> 'org.gtk.GDBus.TestInterface'
	//      member -> 'GimmeStdout'
	//      destination -> ':1.146'
	//    Body: ()
	//    UNIX File Descriptors:
	//      (none)
	//
	// or
	//
	//    Flags:   no-reply-expected
	//    Version: 0
	//    Serial:  477
	//    Headers:
	//      reply-serial -> uint32 4
	//      destination -> ':1.159'
	//      sender -> ':1.146'
	//      num-unix-fds -> uint32 1
	//    Body: ()
	//    UNIX File Descriptors:
	//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
	Print(indent uint) string
	// SetBody sets the body @message. As a side-effect the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type
	// string of @body (or cleared if @body is nil).
	//
	// If @body is floating, @message assumes ownership of @body.
	SetBody(body *glib.Variant)
	// SetByteOrder sets the byte order of @message.
	SetByteOrder(byteOrder DBusMessageByteOrder)
	// SetDestination: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	SetDestination(value string)
	// SetErrorName: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	SetErrorName(value string)
	// SetFlags sets the flags to set on @message.
	SetFlags(flags DBusMessageFlags)
	// SetHeader sets a header field on @message.
	//
	// If @value is floating, @message assumes ownership of @value.
	SetHeader(headerField DBusMessageHeaderField, value *glib.Variant)
	// SetInterface: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	SetInterface(value string)
	// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	SetMember(value string)
	// SetMessageType sets @message to be of @type.
	SetMessageType(typ DBusMessageType)
	// SetNumUnixFds: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	SetNumUnixFds(value uint32)
	// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
	// header field.
	SetPath(value string)
	// SetReplySerial: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	SetReplySerial(value uint32)
	// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	SetSender(value string)
	// SetSerial sets the serial for @message.
	SetSerial(serial uint32)
	// SetSignature: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	SetSignature(value string)
	// SetUnixFdList sets the UNIX file descriptors associated with @message. As
	// a side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field
	// is set to the number of fds in @fd_list (or cleared if @fd_list is nil).
	//
	// This method is only available on UNIX.
	//
	// When designing D-Bus APIs that are intended to be interoperable, please
	// note that non-GDBus implementations of D-Bus can usually only access file
	// descriptors if they are referenced by a value of type
	// G_VARIANT_TYPE_HANDLE in the body of the message.
	SetUnixFdList(fdList UnixFDList)
	// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
	// nothing and returns false.
	//
	// Otherwise this method encodes the error in @message as a #GError using
	// g_dbus_error_set_dbus_error() using the information in the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well
	// as the first string item in @message's body.
	ToGerror() error
}

// dBusMessage implements the DBusMessage class.
type dBusMessage struct {
	gextras.Objector
}

var _ DBusMessage = (*dBusMessage)(nil)

// WrapDBusMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMessage(obj *externglib.Object) DBusMessage {
	return dBusMessage{
		Objector: obj,
	}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMessage(obj), nil
}

// NewDBusMessage creates a new empty BusMessage.
func NewDBusMessage() DBusMessage {
	var _cret *C.GDBusMessage // in

	_cret = C.g_dbus_message_new()

	var _dBusMessage DBusMessage // out

	_dBusMessage = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// NewDBusMessageFromBlob creates a new BusMessage from the data stored at
// @blob. The byte order that the message was in can be retrieved using
// g_dbus_message_get_byte_order().
//
// If the @blob cannot be parsed, contains invalid fields, or contains invalid
// headers, G_IO_ERROR_INVALID_ARGUMENT will be returned.
func NewDBusMessageFromBlob(blob []byte, capabilities DBusCapabilityFlags) (DBusMessage, error) {
	var _arg1 *C.guchar
	var _arg2 C.gsize
	var _arg3 C.GDBusCapabilityFlags // out
	var _cret *C.GDBusMessage        // in
	var _cerr *C.GError              // in

	_arg2 = C.gsize(len(blob))
	_arg1 = (*C.guchar)(unsafe.Pointer(&blob[0]))
	_arg3 = (C.GDBusCapabilityFlags)(capabilities)

	_cret = C.g_dbus_message_new_from_blob(_arg1, _arg2, _arg3, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

// NewDBusMessageMethodCall creates a new BusMessage for a method call.
func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(method))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_dbus_message_new_method_call(_arg1, _arg2, _arg3, _arg4)

	var _dBusMessage DBusMessage // out

	_dBusMessage = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// NewDBusMessageSignal creates a new BusMessage for a signal emission.
func NewDBusMessageSignal(path string, interface_ string, signal string) DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(signal))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_message_new_signal(_arg1, _arg2, _arg3)

	var _dBusMessage DBusMessage // out

	_dBusMessage = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

func (m dBusMessage) Copy() (DBusMessage, error) {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_copy(_arg0, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

func (m dBusMessage) Arg0() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_arg0(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Body() *glib.Variant {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_body(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

func (m dBusMessage) ByteOrder() DBusMessageByteOrder {
	var _arg0 *C.GDBusMessage         // out
	var _cret C.GDBusMessageByteOrder // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_byte_order(_arg0)

	var _dBusMessageByteOrder DBusMessageByteOrder // out

	_dBusMessageByteOrder = DBusMessageByteOrder(_cret)

	return _dBusMessageByteOrder
}

func (m dBusMessage) Destination() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_destination(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) ErrorName() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_error_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Flags() DBusMessageFlags {
	var _arg0 *C.GDBusMessage     // out
	var _cret C.GDBusMessageFlags // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_flags(_arg0)

	var _dBusMessageFlags DBusMessageFlags // out

	_dBusMessageFlags = DBusMessageFlags(_cret)

	return _dBusMessageFlags
}

func (m dBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _cret *C.GVariant               // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageHeaderField)(headerField)

	_cret = C.g_dbus_message_get_header(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

func (m dBusMessage) HeaderFields() []byte {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.guchar

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_header_fields(_arg0)

	var _guint8s []byte

	{
		var i int
		var z C.guchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = (byte)(src[i])
		}
	}

	return _guint8s
}

func (m dBusMessage) Interface() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_interface(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Locked() bool {
	var _arg0 *C.GDBusMessage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m dBusMessage) Member() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_member(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) MessageType() DBusMessageType {
	var _arg0 *C.GDBusMessage    // out
	var _cret C.GDBusMessageType // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_message_type(_arg0)

	var _dBusMessageType DBusMessageType // out

	_dBusMessageType = DBusMessageType(_cret)

	return _dBusMessageType
}

func (m dBusMessage) NumUnixFds() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_num_unix_fds(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

func (m dBusMessage) Path() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) ReplySerial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_reply_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

func (m dBusMessage) Sender() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Serial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

func (m dBusMessage) Signature() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_signature(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) UnixFdList() UnixFDList {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GUnixFDList  // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_unix_fd_list(_arg0)

	var _unixFDList UnixFDList // out

	_unixFDList = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(UnixFDList)

	return _unixFDList
}

func (m dBusMessage) Lock() {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	C.g_dbus_message_lock(_arg0)
}

func (m dBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_message_new_method_error_literal(_arg0, _arg1, _arg2)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (m dBusMessage) NewMethodReply() DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_new_method_reply(_arg0)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (m dBusMessage) Print(indent uint) string {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint         // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(indent)

	_cret = C.g_dbus_message_print(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (m dBusMessage) SetBody(body *glib.Variant) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(body.Native()))

	C.g_dbus_message_set_body(_arg0, _arg1)
}

func (m dBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder) {
	var _arg0 *C.GDBusMessage         // out
	var _arg1 C.GDBusMessageByteOrder // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageByteOrder)(byteOrder)

	C.g_dbus_message_set_byte_order(_arg0, _arg1)
}

func (m dBusMessage) SetDestination(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_destination(_arg0, _arg1)
}

func (m dBusMessage) SetErrorName(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_error_name(_arg0, _arg1)
}

func (m dBusMessage) SetFlags(flags DBusMessageFlags) {
	var _arg0 *C.GDBusMessage     // out
	var _arg1 C.GDBusMessageFlags // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageFlags)(flags)

	C.g_dbus_message_set_flags(_arg0, _arg1)
}

func (m dBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant) {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _arg2 *C.GVariant               // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageHeaderField)(headerField)
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_dbus_message_set_header(_arg0, _arg1, _arg2)
}

func (m dBusMessage) SetInterface(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_interface(_arg0, _arg1)
}

func (m dBusMessage) SetMember(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_member(_arg0, _arg1)
}

func (m dBusMessage) SetMessageType(typ DBusMessageType) {
	var _arg0 *C.GDBusMessage    // out
	var _arg1 C.GDBusMessageType // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageType)(typ)

	C.g_dbus_message_set_message_type(_arg0, _arg1)
}

func (m dBusMessage) SetNumUnixFds(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint32)(value)

	C.g_dbus_message_set_num_unix_fds(_arg0, _arg1)
}

func (m dBusMessage) SetPath(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_path(_arg0, _arg1)
}

func (m dBusMessage) SetReplySerial(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint32)(value)

	C.g_dbus_message_set_reply_serial(_arg0, _arg1)
}

func (m dBusMessage) SetSender(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_sender(_arg0, _arg1)
}

func (m dBusMessage) SetSerial(serial uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint32)(serial)

	C.g_dbus_message_set_serial(_arg0, _arg1)
}

func (m dBusMessage) SetSignature(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_signature(_arg0, _arg1)
}

func (m dBusMessage) SetUnixFdList(fdList UnixFDList) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GUnixFDList  // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_message_set_unix_fd_list(_arg0, _arg1)
}

func (m dBusMessage) ToGerror() error {
	var _arg0 *C.GDBusMessage // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	C.g_dbus_message_to_gerror(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation interface {
	gextras.Objector

	// Connection gets the BusConnection the method was invoked on.
	Connection() DBusConnection
	// InterfaceName gets the name of the D-Bus interface the method was invoked
	// on.
	//
	// If this method call is a property Get, Set or GetAll call that has been
	// redirected to the method call handler then
	// "org.freedesktop.DBus.Properties" will be returned. See
	// BusInterfaceVTable for more information.
	InterfaceName() string
	// Message gets the BusMessage for the method invocation. This is useful if
	// you need to use low-level protocol features, such as UNIX file descriptor
	// passing, that cannot be properly expressed in the #GVariant API.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	Message() DBusMessage
	// MethodInfo gets information about the method call, if any.
	//
	// If this method invocation is a property Get, Set or GetAll call that has
	// been redirected to the method call handler then nil will be returned. See
	// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
	// more information.
	MethodInfo() *DBusMethodInfo
	// MethodName gets the name of the method that was invoked.
	MethodName() string
	// ObjectPath gets the object path the method was invoked on.
	ObjectPath() string
	// Parameters gets the parameters of the method invocation. If there are no
	// input parameters then this will return a GVariant with 0 children rather
	// than NULL.
	Parameters() *glib.Variant
	// PropertyInfo gets information about the property that this method call is
	// for, if any.
	//
	// This will only be set in the case of an invocation in response to a
	// property Get or Set call that has been directed to the method call
	// handler for an object on account of its property_get() or property_set()
	// vtable pointers being unset.
	//
	// See BusInterfaceVTable for more information.
	//
	// If the call was GetAll, nil will be returned.
	PropertyInfo() *DBusPropertyInfo
	// Sender gets the bus name that invoked the method.
	Sender() string
	// ReturnDBusError finishes handling a D-Bus method call by returning an
	// error.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnDBusError(errorName string, errorMessage string)
	// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
	// #GError instead of the error domain, error code and message.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnGerror(err error)
	// ReturnValue finishes handling a D-Bus method call by returning
	// @parameters. If the @parameters GVariant is floating, it is consumed.
	//
	// It is an error if @parameters is not of the right format: it must be a
	// tuple containing the out-parameters of the D-Bus method. Even if the
	// method has a single out-parameter, it must be contained in a tuple. If
	// the method has no out-parameters, @parameters may be nil or an empty
	// tuple.
	//
	//    GDBusMethodInvocation *invocation = some_invocation;
	//    g_autofree gchar *result_string = NULL;
	//    g_autoptr (GError) error = NULL;
	//
	//    result_string = calculate_result (&error);
	//
	//    if (error != NULL)
	//      g_dbus_method_invocation_return_gerror (invocation, error);
	//    else
	//      g_dbus_method_invocation_return_value (invocation,
	//                                             g_variant_new ("(s)", result_string));
	//
	//    // Do not free @invocation here; returning a value does that
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	//
	// Since 2.48, if the method call requested for a reply not to be sent then
	// this call will sink @parameters and free @invocation, but otherwise do
	// nothing (as per the recommendations of the D-Bus specification).
	ReturnValue(parameters *glib.Variant)
	// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
	// but also takes a FDList.
	//
	// This method is only available on UNIX.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList)
}

// dBusMethodInvocation implements the DBusMethodInvocation class.
type dBusMethodInvocation struct {
	gextras.Objector
}

var _ DBusMethodInvocation = (*dBusMethodInvocation)(nil)

// WrapDBusMethodInvocation wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMethodInvocation(obj *externglib.Object) DBusMethodInvocation {
	return dBusMethodInvocation{
		Objector: obj,
	}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMethodInvocation(obj), nil
}

func (i dBusMethodInvocation) Connection() DBusConnection {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusConnection       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

	return _dBusConnection
}

func (i dBusMethodInvocation) InterfaceName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_interface_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) Message() DBusMessage {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMessage          // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_message(_arg0)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (i dBusMethodInvocation) MethodInfo() *DBusMethodInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMethodInfo       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_method_info(_arg0)

	var _dBusMethodInfo *DBusMethodInfo // out

	_dBusMethodInfo = WrapDBusMethodInfo(unsafe.Pointer(_cret))

	return _dBusMethodInfo
}

func (i dBusMethodInvocation) MethodName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_method_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) ObjectPath() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) Parameters() *glib.Variant {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GVariant              // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_parameters(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

func (i dBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusPropertyInfo     // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_property_info(_arg0)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	_dBusPropertyInfo = WrapDBusPropertyInfo(unsafe.Pointer(_cret))

	return _dBusPropertyInfo
}

func (i dBusMethodInvocation) Sender() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) ReturnDBusError(errorName string, errorMessage string) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.gchar                 // out
	var _arg2 *C.gchar                 // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_dbus_method_invocation_return_dbus_error(_arg0, _arg1, _arg2)
}

func (i dBusMethodInvocation) ReturnGerror(err error) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GError                // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))
	defer C.g_error_free(_arg1)

	C.g_dbus_method_invocation_return_gerror(_arg0, _arg1)
}

func (i dBusMethodInvocation) ReturnValue(parameters *glib.Variant) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

	C.g_dbus_method_invocation_return_value(_arg0, _arg1)
}

func (i dBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out
	var _arg2 *C.GUnixFDList           // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg2 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_method_invocation_return_value_with_unix_fd_list(_arg0, _arg1, _arg2)
}

// DBusObjectManagerClient is used to create, monitor and delete object proxies
// for remote objects exported by a BusObjectManagerServer (or any code
// implementing the org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
//
// Once an instance of this type has been created, you can connect to the
// BusObjectManager::object-added and BusObjectManager::object-removed signals
// and inspect the BusObjectProxy objects returned by
// g_dbus_object_manager_get_objects().
//
// If the name for a BusObjectManagerClient is not owned by anyone at object
// construction time, the default behavior is to request the message bus to
// launch an owner for the name. This behavior can be disabled using the
// G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START flag. It's also worth
// noting that this only works if the name of interest is activatable in the
// first place. E.g. in some cases it is not possible to launch an owner for the
// requested name. In this case, BusObjectManagerClient object construction
// still succeeds but there will be no object proxies (e.g.
// g_dbus_object_manager_get_objects() returns the empty list) and the
// BusObjectManagerClient:name-owner property is nil.
//
// The owner of the requested name can come and go (for example consider a
// system service being restarted)  BusObjectManagerClient handles this case
// too; simply connect to the #GObject::notify signal to watch for changes on
// the BusObjectManagerClient:name-owner property. When the name owner vanishes,
// the behavior is that BusObjectManagerClient:name-owner is set to nil (this
// includes emission of the #GObject::notify signal) and then
// BusObjectManager::object-removed signals are synthesized for all currently
// existing object proxies. Since BusObjectManagerClient:name-owner is nil when
// this happens, you can use this information to disambiguate a synthesized
// signal from a genuine signal caused by object removal on the remote
// BusObjectManager. Similarly, when a new name owner appears,
// BusObjectManager::object-added signals are synthesized while
// BusObjectManagerClient:name-owner is still nil. Only when all object proxies
// have been added, the BusObjectManagerClient:name-owner is set to the new name
// owner (this includes emission of the #GObject::notify signal). Furthermore,
// you are guaranteed that BusObjectManagerClient:name-owner will alternate
// between a name owner (e.g. `:1.42`) and nil even in the case where the name
// of interest is atomically replaced
//
// Ultimately, BusObjectManagerClient is used to obtain BusProxy instances. All
// signals (including the org.freedesktop.DBus.Properties::PropertiesChanged
// signal) delivered to BusProxy instances are guaranteed to originate from the
// name owner. This guarantee along with the behavior described above, means
// that certain race conditions including the "half the proxy is from the old
// owner and the other half is from the new owner" problem cannot happen.
//
// To avoid having the application connect to signals on the returned
// BusObjectProxy and BusProxy objects, the BusObject::interface-added,
// BusObject::interface-removed, BusProxy::g-properties-changed and
// BusProxy::g-signal signals are also emitted on the BusObjectManagerClient
// instance managing these objects. The signals emitted are
// BusObjectManager::interface-added, BusObjectManager::interface-removed,
// BusObjectManagerClient::interface-proxy-properties-changed and
// BusObjectManagerClient::interface-proxy-signal.
//
// Note that all callbacks and signals are emitted in the [thread-default main
// context][g-main-context-push-thread-default] that the BusObjectManagerClient
// object was constructed in. Additionally, the BusObjectProxy and BusProxy
// objects originating from the BusObjectManagerClient object will be created in
// the same context and, consequently, will deliver signals in the same main
// loop.
type DBusObjectManagerClient interface {
	gextras.Objector
	AsyncInitable
	DBusObjectManager
	Initable

	// Connection gets the BusConnection used by @manager.
	Connection() DBusConnection
	// Flags gets the flags that @manager was constructed with.
	Flags() DBusObjectManagerClientFlags
	// Name gets the name that @manager is for, or nil if not a message bus
	// connection.
	Name() string
	// NameOwner: the unique name that owns the name that @manager is for or nil
	// if no-one currently owns that name. You can connect to the
	// #GObject::notify signal to track changes to the
	// BusObjectManagerClient:name-owner property.
	NameOwner() string
}

// dBusObjectManagerClient implements the DBusObjectManagerClient class.
type dBusObjectManagerClient struct {
	gextras.Objector
	AsyncInitable
	DBusObjectManager
	Initable
}

var _ DBusObjectManagerClient = (*dBusObjectManagerClient)(nil)

// WrapDBusObjectManagerClient wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectManagerClient(obj *externglib.Object) DBusObjectManagerClient {
	return dBusObjectManagerClient{
		Objector:          obj,
		AsyncInitable:     WrapAsyncInitable(obj),
		DBusObjectManager: WrapDBusObjectManager(obj),
		Initable:          WrapInitable(obj),
	}
}

func marshalDBusObjectManagerClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectManagerClient(obj), nil
}

// NewDBusObjectManagerClientFinish finishes an operation started with
// g_dbus_object_manager_client_new().
func NewDBusObjectManagerClientFinish(res AsyncResult) (DBusObjectManagerClient, error) {
	var _arg1 *C.GAsyncResult       // out
	var _cret *C.GDBusObjectManager // in
	var _cerr *C.GError             // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_object_manager_client_new_finish(_arg1, &_cerr)

	var _dBusObjectManagerClient DBusObjectManagerClient // out
	var _goerr error                                     // out

	_dBusObjectManagerClient = WrapDBusObjectManagerClient(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusObjectManagerClient, _goerr
}

// NewDBusObjectManagerClientForBusFinish finishes an operation started with
// g_dbus_object_manager_client_new_for_bus().
func NewDBusObjectManagerClientForBusFinish(res AsyncResult) (DBusObjectManagerClient, error) {
	var _arg1 *C.GAsyncResult       // out
	var _cret *C.GDBusObjectManager // in
	var _cerr *C.GError             // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_object_manager_client_new_for_bus_finish(_arg1, &_cerr)

	var _dBusObjectManagerClient DBusObjectManagerClient // out
	var _goerr error                                     // out

	_dBusObjectManagerClient = WrapDBusObjectManagerClient(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusObjectManagerClient, _goerr
}

func (m dBusObjectManagerClient) Connection() DBusConnection {
	var _arg0 *C.GDBusObjectManagerClient // out
	var _cret *C.GDBusConnection          // in

	_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_object_manager_client_get_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

	return _dBusConnection
}

func (m dBusObjectManagerClient) Flags() DBusObjectManagerClientFlags {
	var _arg0 *C.GDBusObjectManagerClient     // out
	var _cret C.GDBusObjectManagerClientFlags // in

	_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_object_manager_client_get_flags(_arg0)

	var _dBusObjectManagerClientFlags DBusObjectManagerClientFlags // out

	_dBusObjectManagerClientFlags = DBusObjectManagerClientFlags(_cret)

	return _dBusObjectManagerClientFlags
}

func (m dBusObjectManagerClient) Name() string {
	var _arg0 *C.GDBusObjectManagerClient // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_object_manager_client_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusObjectManagerClient) NameOwner() string {
	var _arg0 *C.GDBusObjectManagerClient // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_object_manager_client_get_name_owner(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusObjectManagerServer is used to export BusObject instances using the
// standardized org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface. For example, remote D-Bus clients can get all objects and
// properties in a single call. Additionally, any change in the object hierarchy
// is broadcast using signals. This means that D-Bus clients can keep caches up
// to date by only listening to D-Bus signals.
//
// The recommended path to export an object manager at is the path form of the
// well-known name of a D-Bus service, or below. For example, if a D-Bus service
// is available at the well-known name `net.example.ExampleService1`, the object
// manager should typically be exported at `/net/example/ExampleService1`, or
// below (to allow for multiple object managers in a service).
//
// It is supported, but not recommended, to export an object manager at the root
// path, `/`.
//
// See BusObjectManagerClient for the client-side code that is intended to be
// used with BusObjectManagerServer or any D-Bus object implementing the
// org.freedesktop.DBus.ObjectManager interface.
type DBusObjectManagerServer interface {
	gextras.Objector
	DBusObjectManager

	// Export exports @object on @manager.
	//
	// If there is already a BusObject exported at the object path, then the old
	// object is removed.
	//
	// The object path for @object must be in the hierarchy rooted by the object
	// path for @manager.
	//
	// Note that @manager will take a reference on @object for as long as it is
	// exported.
	Export(object DBusObjectSkeleton)
	// ExportUniquely: like g_dbus_object_manager_server_export() but appends a
	// string of the form _N (with N being a natural number) to @object's object
	// path if an object with the given path already exists. As such, the
	// BusObjectProxy:g-object-path property of @object may be modified.
	ExportUniquely(object DBusObjectSkeleton)
	// Connection gets the BusConnection used by @manager.
	Connection() DBusConnection
	// IsExported returns whether @object is currently exported on @manager.
	IsExported(object DBusObjectSkeleton) bool
	// SetConnection exports all objects managed by @manager on @connection. If
	// @connection is nil, stops exporting objects.
	SetConnection(connection DBusConnection)
	// Unexport: if @manager has an object at @path, removes the object.
	// Otherwise does nothing.
	//
	// Note that @object_path must be in the hierarchy rooted by the object path
	// for @manager.
	Unexport(objectPath string) bool
}

// dBusObjectManagerServer implements the DBusObjectManagerServer class.
type dBusObjectManagerServer struct {
	gextras.Objector
	DBusObjectManager
}

var _ DBusObjectManagerServer = (*dBusObjectManagerServer)(nil)

// WrapDBusObjectManagerServer wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectManagerServer(obj *externglib.Object) DBusObjectManagerServer {
	return dBusObjectManagerServer{
		Objector:          obj,
		DBusObjectManager: WrapDBusObjectManager(obj),
	}
}

func marshalDBusObjectManagerServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectManagerServer(obj), nil
}

// NewDBusObjectManagerServer creates a new BusObjectManagerServer object.
//
// The returned server isn't yet exported on any connection. To do so, use
// g_dbus_object_manager_server_set_connection(). Normally you want to export
// all of your objects before doing so to avoid InterfacesAdded
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// signals being emitted.
func NewDBusObjectManagerServer(objectPath string) DBusObjectManagerServer {
	var _arg1 *C.gchar                    // out
	var _cret *C.GDBusObjectManagerServer // in

	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_manager_server_new(_arg1)

	var _dBusObjectManagerServer DBusObjectManagerServer // out

	_dBusObjectManagerServer = WrapDBusObjectManagerServer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusObjectManagerServer
}

func (m dBusObjectManagerServer) Export(object DBusObjectSkeleton) {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.GDBusObjectSkeleton      // out

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(object.Native()))

	C.g_dbus_object_manager_server_export(_arg0, _arg1)
}

func (m dBusObjectManagerServer) ExportUniquely(object DBusObjectSkeleton) {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.GDBusObjectSkeleton      // out

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(object.Native()))

	C.g_dbus_object_manager_server_export_uniquely(_arg0, _arg1)
}

func (m dBusObjectManagerServer) Connection() DBusConnection {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _cret *C.GDBusConnection          // in

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_object_manager_server_get_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)

	return _dBusConnection
}

func (m dBusObjectManagerServer) IsExported(object DBusObjectSkeleton) bool {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.GDBusObjectSkeleton      // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(object.Native()))

	_cret = C.g_dbus_object_manager_server_is_exported(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m dBusObjectManagerServer) SetConnection(connection DBusConnection) {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.GDBusConnection          // out

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

	C.g_dbus_object_manager_server_set_connection(_arg0, _arg1)
}

func (m dBusObjectManagerServer) Unexport(objectPath string) bool {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.gchar                    // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_manager_server_unexport(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusObjectProXY: a BusObjectProxy is an object used to represent a remote
// object with one or more D-Bus interfaces. Normally, you don't instantiate a
// BusObjectProxy yourself - typically BusObjectManagerClient is used to obtain
// it.
type DBusObjectProXY interface {
	gextras.Objector
	DBusObject

	// Connection gets the connection that @proxy is for.
	Connection() DBusConnection
}

// dBusObjectProXY implements the DBusObjectProXY class.
type dBusObjectProXY struct {
	gextras.Objector
	DBusObject
}

var _ DBusObjectProXY = (*dBusObjectProXY)(nil)

// WrapDBusObjectProXY wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectProXY(obj *externglib.Object) DBusObjectProXY {
	return dBusObjectProXY{
		Objector:   obj,
		DBusObject: WrapDBusObject(obj),
	}
}

func marshalDBusObjectProXY(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectProXY(obj), nil
}

// NewDBusObjectProXY creates a new BusObjectProxy for the given connection and
// object path.
func NewDBusObjectProXY(connection DBusConnection, objectPath string) DBusObjectProXY {
	var _arg1 *C.GDBusConnection  // out
	var _arg2 *C.gchar            // out
	var _cret *C.GDBusObjectProxy // in

	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_object_proxy_new(_arg1, _arg2)

	var _dBusObjectProxy DBusObjectProXY // out

	_dBusObjectProxy = WrapDBusObjectProXY(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusObjectProxy
}

func (p dBusObjectProXY) Connection() DBusConnection {
	var _arg0 *C.GDBusObjectProxy // out
	var _cret *C.GDBusConnection  // in

	_arg0 = (*C.GDBusObjectProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_object_proxy_get_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

	return _dBusConnection
}

// DBusObjectSkeleton: a BusObjectSkeleton instance is essentially a group of
// D-Bus interfaces. The set of exported interfaces on the object may be dynamic
// and change at runtime.
//
// This type is intended to be used with BusObjectManager.
type DBusObjectSkeleton interface {
	gextras.Objector
	DBusObject

	// AddInterface adds @interface_ to @object.
	//
	// If @object already contains a BusInterfaceSkeleton with the same
	// interface name, it is removed before @interface_ is added.
	//
	// Note that @object takes its own reference on @interface_ and holds it
	// until removed.
	AddInterface(interface_ DBusInterfaceSkeleton)
	// Flush: this method simply calls g_dbus_interface_skeleton_flush() on all
	// interfaces belonging to @object. See that method for when flushing is
	// useful.
	Flush()
	// RemoveInterface removes @interface_ from @object.
	RemoveInterface(interface_ DBusInterfaceSkeleton)
	// RemoveInterfaceByName removes the BusInterface with @interface_name from
	// @object.
	//
	// If no D-Bus interface of the given interface exists, this function does
	// nothing.
	RemoveInterfaceByName(interfaceName string)
	// SetObjectPath sets the object path for @object.
	SetObjectPath(objectPath string)
}

// dBusObjectSkeleton implements the DBusObjectSkeleton class.
type dBusObjectSkeleton struct {
	gextras.Objector
	DBusObject
}

var _ DBusObjectSkeleton = (*dBusObjectSkeleton)(nil)

// WrapDBusObjectSkeleton wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectSkeleton(obj *externglib.Object) DBusObjectSkeleton {
	return dBusObjectSkeleton{
		Objector:   obj,
		DBusObject: WrapDBusObject(obj),
	}
}

func marshalDBusObjectSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectSkeleton(obj), nil
}

// NewDBusObjectSkeleton creates a new BusObjectSkeleton.
func NewDBusObjectSkeleton(objectPath string) DBusObjectSkeleton {
	var _arg1 *C.gchar               // out
	var _cret *C.GDBusObjectSkeleton // in

	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_skeleton_new(_arg1)

	var _dBusObjectSkeleton DBusObjectSkeleton // out

	_dBusObjectSkeleton = WrapDBusObjectSkeleton(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusObjectSkeleton
}

func (o dBusObjectSkeleton) AddInterface(interface_ DBusInterfaceSkeleton) {
	var _arg0 *C.GDBusObjectSkeleton    // out
	var _arg1 *C.GDBusInterfaceSkeleton // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(interface_.Native()))

	C.g_dbus_object_skeleton_add_interface(_arg0, _arg1)
}

func (o dBusObjectSkeleton) Flush() {
	var _arg0 *C.GDBusObjectSkeleton // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))

	C.g_dbus_object_skeleton_flush(_arg0)
}

func (o dBusObjectSkeleton) RemoveInterface(interface_ DBusInterfaceSkeleton) {
	var _arg0 *C.GDBusObjectSkeleton    // out
	var _arg1 *C.GDBusInterfaceSkeleton // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(interface_.Native()))

	C.g_dbus_object_skeleton_remove_interface(_arg0, _arg1)
}

func (o dBusObjectSkeleton) RemoveInterfaceByName(interfaceName string) {
	var _arg0 *C.GDBusObjectSkeleton // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_object_skeleton_remove_interface_by_name(_arg0, _arg1)
}

func (o dBusObjectSkeleton) SetObjectPath(objectPath string) {
	var _arg0 *C.GDBusObjectSkeleton // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_object_skeleton_set_object_path(_arg0, _arg1)
}

// DBusProXY is a base class used for proxies to access a D-Bus interface on a
// remote object. A BusProxy can be constructed for both well-known and unique
// names.
//
// By default, BusProxy will cache all properties (and listen to changes) of the
// remote object, and proxy all signals that get emitted. This behaviour can be
// changed by passing suitable BusProxyFlags when the proxy is created. If the
// proxy is for a well-known name, the property cache is flushed when the name
// owner vanishes and reloaded when a name owner appears.
//
// The unique name owner of the proxy's name is tracked and can be read from
// BusProxy:g-name-owner. Connect to the #GObject::notify signal to get notified
// of changes. Additionally, only signals and property changes emitted from the
// current name owner are considered and calls are always sent to the current
// name owner. This avoids a number of race conditions when the name is lost by
// one owner and claimed by another. However, if no name owner currently exists,
// then calls will be sent to the well-known name which may result in the
// message bus launching an owner (unless G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// is set).
//
// The generic BusProxy::g-properties-changed and BusProxy::g-signal signals are
// not very convenient to work with. Therefore, the recommended way of working
// with proxies is to subclass BusProxy, and have more natural properties and
// signals in your derived class. This [example][gdbus-example-gdbus-codegen]
// shows how this can easily be done using the [gdbus-codegen][gdbus-codegen]
// tool.
//
// A BusProxy instance can be used from multiple threads but note that all
// signals (e.g. BusProxy::g-signal, BusProxy::g-properties-changed and
// #GObject::notify) are emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread where the instance
// was constructed.
//
// An example using a proxy for a well-known name can be found in
// gdbus-example-watch-proxy.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c)
type DBusProXY interface {
	gextras.Objector
	AsyncInitable
	DBusInterface
	Initable

	// CallFinish finishes an operation started with g_dbus_proxy_call().
	CallFinish(res AsyncResult) (*glib.Variant, error)
	// CallSync: synchronously invokes the @method_name method on @proxy.
	//
	// If @method_name contains any dots, then @name is split into interface and
	// method name parts. This allows using @proxy for invoking methods on other
	// interfaces.
	//
	// If the BusConnection associated with @proxy is disconnected then the
	// operation will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled,
	// the operation will fail with G_IO_ERROR_CANCELLED. If @parameters
	// contains a value not compatible with the D-Bus protocol, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//    g_dbus_proxy_call_sync (proxy,
	//                            "TwoStrings",
	//                            g_variant_new ("(ss)",
	//                                           "Thing One",
	//                                           "Thing Two"),
	//                            G_DBUS_CALL_FLAGS_NONE,
	//                            -1,
	//                            NULL,
	//                            &error);
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_proxy_call() for the asynchronous version of this method.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @method_name is referenced by it, then the return value is checked
	// against the return type.
	CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error)
	// CallWithUnixFdListFinish finishes an operation started with
	// g_dbus_proxy_call_with_unix_fd_list().
	CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error)
	// CallWithUnixFdListSync: like g_dbus_proxy_call_sync() but also takes and
	// returns FDList objects.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error)
	// CachedProperty looks up the value for a property from the cache. This
	// call does no blocking IO.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @property_name is referenced by it, then @value is checked against the
	// type of the property.
	CachedProperty(propertyName string) *glib.Variant
	// CachedPropertyNames gets the names of all cached properties on @proxy.
	CachedPropertyNames() []string
	// Connection gets the connection @proxy is for.
	Connection() DBusConnection
	// DefaultTimeout gets the timeout to use if -1 (specifying default timeout)
	// is passed as @timeout_msec in the g_dbus_proxy_call() and
	// g_dbus_proxy_call_sync() functions.
	//
	// See the BusProxy:g-default-timeout property for more details.
	DefaultTimeout() int
	// Flags gets the flags that @proxy was constructed with.
	Flags() DBusProXYFlags
	// InterfaceInfo returns the BusInterfaceInfo, if any, specifying the
	// interface that @proxy conforms to. See the BusProxy:g-interface-info
	// property for more details.
	InterfaceInfo() *DBusInterfaceInfo
	// InterfaceName gets the D-Bus interface name @proxy is for.
	InterfaceName() string
	// Name gets the name that @proxy was constructed for.
	Name() string
	// NameOwner: the unique name that owns the name that @proxy is for or nil
	// if no-one currently owns that name. You may connect to the
	// #GObject::notify signal to track changes to the BusProxy:g-name-owner
	// property.
	NameOwner() string
	// ObjectPath gets the object path @proxy is for.
	ObjectPath() string
	// SetCachedProperty: if @value is not nil, sets the cached value for the
	// property with name @property_name to the value in @value.
	//
	// If @value is nil, then the cached value is removed from the property
	// cache.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @property_name is referenced by it, then @value is checked against the
	// type of the property.
	//
	// If the @value #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.
	//
	//    g_dbus_proxy_set_cached_property (proxy,
	//                                      "SomeProperty",
	//                                      g_variant_new ("(si)",
	//                                                    "A String",
	//                                                    42));
	//
	// Normally you will not need to use this method since @proxy is tracking
	// changes using the `org.freedesktop.DBus.Properties.PropertiesChanged`
	// D-Bus signal. However, for performance reasons an object may decide to
	// not use this signal for some properties and instead use a proprietary
	// out-of-band mechanism to transmit changes.
	//
	// As a concrete example, consider an object with a property
	// `ChatroomParticipants` which is an array of strings. Instead of
	// transmitting the same (long) array every time the property changes, it is
	// more efficient to only transmit the delta using e.g. signals
	// `ChatroomParticipantJoined(String name)` and
	// `ChatroomParticipantParted(String name)`.
	SetCachedProperty(propertyName string, value *glib.Variant)
	// SetDefaultTimeout sets the timeout to use if -1 (specifying default
	// timeout) is passed as @timeout_msec in the g_dbus_proxy_call() and
	// g_dbus_proxy_call_sync() functions.
	//
	// See the BusProxy:g-default-timeout property for more details.
	SetDefaultTimeout(timeoutMsec int)
	// SetInterfaceInfo: ensure that interactions with @proxy conform to the
	// given interface. See the BusProxy:g-interface-info property for more
	// details.
	SetInterfaceInfo(info *DBusInterfaceInfo)
}

// dBusProXY implements the DBusProXY class.
type dBusProXY struct {
	gextras.Objector
	AsyncInitable
	DBusInterface
	Initable
}

var _ DBusProXY = (*dBusProXY)(nil)

// WrapDBusProXY wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusProXY(obj *externglib.Object) DBusProXY {
	return dBusProXY{
		Objector:      obj,
		AsyncInitable: WrapAsyncInitable(obj),
		DBusInterface: WrapDBusInterface(obj),
		Initable:      WrapInitable(obj),
	}
}

func marshalDBusProXY(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusProXY(obj), nil
}

// NewDBusProXYFinish finishes creating a BusProxy.
func NewDBusProXYFinish(res AsyncResult) (DBusProXY, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GDBusProxy   // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_proxy_new_finish(_arg1, &_cerr)

	var _dBusProxy DBusProXY // out
	var _goerr error         // out

	_dBusProxy = WrapDBusProXY(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusProxy, _goerr
}

// NewDBusProXYForBusFinish finishes creating a BusProxy.
func NewDBusProXYForBusFinish(res AsyncResult) (DBusProXY, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GDBusProxy   // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_proxy_new_for_bus_finish(_arg1, &_cerr)

	var _dBusProxy DBusProXY // out
	var _goerr error         // out

	_dBusProxy = WrapDBusProXY(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusProxy, _goerr
}

// NewDBusProXYForBusSync: like g_dbus_proxy_new_sync() but takes a Type instead
// of a BusConnection.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
func NewDBusProXYForBusSync(busType BusType, flags DBusProXYFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable Cancellable) (DBusProXY, error) {
	var _arg1 C.GBusType            // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _arg7 *C.GCancellable       // out
	var _cret *C.GDBusProxy         // in
	var _cerr *C.GError             // in

	_arg1 = (C.GBusType)(busType)
	_arg2 = (C.GDBusProxyFlags)(flags)
	_arg3 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(info.Native()))
	_arg4 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_proxy_new_for_bus_sync(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)

	var _dBusProxy DBusProXY // out
	var _goerr error         // out

	_dBusProxy = WrapDBusProXY(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusProxy, _goerr
}

// NewDBusProXYSync creates a proxy for accessing @interface_name on the remote
// object at @object_path owned by @name at @connection and synchronously loads
// D-Bus properties unless the G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is
// used.
//
// If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets
// up match rules for signals. Connect to the BusProxy::g-signal signal to
// handle signals from the remote object.
//
// If both G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
// G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
// guaranteed to return immediately without blocking.
//
// If @name is a well-known name and the G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// and G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION flags aren't set and
// no name owner currently exists, the message bus will be requested to launch a
// name owner for the name.
//
// This is a synchronous failable constructor. See g_dbus_proxy_new() and
// g_dbus_proxy_new_finish() for the asynchronous version.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
func NewDBusProXYSync(connection DBusConnection, flags DBusProXYFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable Cancellable) (DBusProXY, error) {
	var _arg1 *C.GDBusConnection    // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _arg7 *C.GCancellable       // out
	var _cret *C.GDBusProxy         // in
	var _cerr *C.GError             // in

	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	_arg2 = (C.GDBusProxyFlags)(flags)
	_arg3 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(info.Native()))
	_arg4 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_proxy_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)

	var _dBusProxy DBusProXY // out
	var _goerr error         // out

	_dBusProxy = WrapDBusProXY(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusProxy, _goerr
}

func (p dBusProXY) CallFinish(res AsyncResult) (*glib.Variant, error) {
	var _arg0 *C.GDBusProxy   // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GVariant     // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_proxy_call_finish(_arg0, _arg1, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

func (p dBusProXY) CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error) {
	var _arg0 *C.GDBusProxy    // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out
	var _arg3 C.GDBusCallFlags // out
	var _arg4 C.gint           // out
	var _arg5 *C.GCancellable  // out
	var _cret *C.GVariant      // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg3 = (C.GDBusCallFlags)(flags)
	_arg4 = (C.gint)(timeoutMsec)
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_proxy_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

func (p dBusProXY) CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusProxy   // out
	var _arg1 *C.GUnixFDList  // in
	var _arg2 *C.GAsyncResult // out
	var _cret *C.GVariant     // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	_arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_proxy_call_with_unix_fd_list_finish(_arg0, &_arg1, _arg2, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1))).(UnixFDList)
	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

func (p dBusProXY) CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusProxy    // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out
	var _arg3 C.GDBusCallFlags // out
	var _arg4 C.gint           // out
	var _arg5 *C.GUnixFDList   // out
	var _arg6 *C.GUnixFDList   // in
	var _arg7 *C.GCancellable  // out
	var _cret *C.GVariant      // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg3 = (C.GDBusCallFlags)(flags)
	_arg4 = (C.gint)(timeoutMsec)
	_arg5 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_proxy_call_with_unix_fd_list_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, _arg7, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg6))).(UnixFDList)
	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

func (p dBusProXY) CachedProperty(propertyName string) *glib.Variant {
	var _arg0 *C.GDBusProxy // out
	var _arg1 *C.gchar      // out
	var _cret *C.GVariant   // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_proxy_get_cached_property(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (p dBusProXY) CachedPropertyNames() []string {
	var _arg0 *C.GDBusProxy // out
	var _cret **C.gchar

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_proxy_get_cached_property_names(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (p dBusProXY) Connection() DBusConnection {
	var _arg0 *C.GDBusProxy      // out
	var _cret *C.GDBusConnection // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_proxy_get_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

	return _dBusConnection
}

func (p dBusProXY) DefaultTimeout() int {
	var _arg0 *C.GDBusProxy // out
	var _cret C.gint        // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_proxy_get_default_timeout(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (p dBusProXY) Flags() DBusProXYFlags {
	var _arg0 *C.GDBusProxy     // out
	var _cret C.GDBusProxyFlags // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_proxy_get_flags(_arg0)

	var _dBusProxyFlags DBusProXYFlags // out

	_dBusProxyFlags = DBusProXYFlags(_cret)

	return _dBusProxyFlags
}

func (p dBusProXY) InterfaceInfo() *DBusInterfaceInfo {
	var _arg0 *C.GDBusProxy         // out
	var _cret *C.GDBusInterfaceInfo // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_proxy_get_interface_info(_arg0)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	_dBusInterfaceInfo = WrapDBusInterfaceInfo(unsafe.Pointer(_cret))

	return _dBusInterfaceInfo
}

func (p dBusProXY) InterfaceName() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_proxy_get_interface_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p dBusProXY) Name() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_proxy_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p dBusProXY) NameOwner() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_proxy_get_name_owner(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (p dBusProXY) ObjectPath() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	_cret = C.g_dbus_proxy_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p dBusProXY) SetCachedProperty(propertyName string, value *glib.Variant) {
	var _arg0 *C.GDBusProxy // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GVariant   // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_dbus_proxy_set_cached_property(_arg0, _arg1, _arg2)
}

func (p dBusProXY) SetDefaultTimeout(timeoutMsec int) {
	var _arg0 *C.GDBusProxy // out
	var _arg1 C.gint        // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(timeoutMsec)

	C.g_dbus_proxy_set_default_timeout(_arg0, _arg1)
}

func (p dBusProXY) SetInterfaceInfo(info *DBusInterfaceInfo) {
	var _arg0 *C.GDBusProxy         // out
	var _arg1 *C.GDBusInterfaceInfo // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(info.Native()))

	C.g_dbus_proxy_set_interface_info(_arg0, _arg1)
}

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with GDBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer. Since GLib 2.68 this can be achieved more simply by
// passing the G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the
// server.
type DBusServer interface {
	gextras.Objector
	Initable

	// ClientAddress gets a D-Bus address
	// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
	// string that can be used by clients to connect to @server.
	ClientAddress() string
	// Flags gets the flags for @server.
	Flags() DBusServerFlags
	// Guid gets the GUID for @server.
	Guid() string
	// IsActive gets whether @server is active.
	IsActive() bool
	// Start starts @server.
	Start()
	// Stop stops @server.
	Stop()
}

// dBusServer implements the DBusServer class.
type dBusServer struct {
	gextras.Objector
	Initable
}

var _ DBusServer = (*dBusServer)(nil)

// WrapDBusServer wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusServer(obj *externglib.Object) DBusServer {
	return dBusServer{
		Objector: obj,
		Initable: WrapInitable(obj),
	}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusServer(obj), nil
}

// NewDBusServerSync creates a new D-Bus server that listens on the first
// address in @address that works.
//
// Once constructed, you can use g_dbus_server_get_client_address() to get a
// D-Bus address string that clients can use to connect.
//
// To have control over the available authentication mechanisms and the users
// that are authorized to connect, it is strongly recommended to provide a
// non-nil BusAuthObserver.
//
// Connect to the BusServer::new-connection signal to handle incoming
// connections.
//
// The returned BusServer isn't active - you have to start it with
// g_dbus_server_start().
//
// BusServer is used in this [example][gdbus-peer-to-peer].
//
// This is a synchronous failable constructor. There is currently no
// asynchronous version.
func NewDBusServerSync(address string, flags DBusServerFlags, guid string, observer DBusAuthObserver, cancellable Cancellable) (DBusServer, error) {
	var _arg1 *C.gchar             // out
	var _arg2 C.GDBusServerFlags   // out
	var _arg3 *C.gchar             // out
	var _arg4 *C.GDBusAuthObserver // out
	var _arg5 *C.GCancellable      // out
	var _cret *C.GDBusServer       // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GDBusServerFlags)(flags)
	_arg3 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_server_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusServer DBusServer // out
	var _goerr error           // out

	_dBusServer = WrapDBusServer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusServer, _goerr
}

func (s dBusServer) ClientAddress() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_get_client_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s dBusServer) Flags() DBusServerFlags {
	var _arg0 *C.GDBusServer     // out
	var _cret C.GDBusServerFlags // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_get_flags(_arg0)

	var _dBusServerFlags DBusServerFlags // out

	_dBusServerFlags = DBusServerFlags(_cret)

	return _dBusServerFlags
}

func (s dBusServer) Guid() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s dBusServer) IsActive() bool {
	var _arg0 *C.GDBusServer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s dBusServer) Start() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_start(_arg0)
}

func (s dBusServer) Stop() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_stop(_arg0)
}

// DataInputStream: data input stream implements Stream and includes functions
// for reading structured data directly from a binary input stream.
type DataInputStream interface {
	BufferedInputStream
	Seekable

	// ByteOrder gets the byte order for the data input stream.
	ByteOrder() DataStreamByteOrder
	// NewlineType gets the current newline type for the @stream.
	NewlineType() DataStreamNewlineType
	// ReadByte reads an unsigned 8-bit/1-byte value from @stream.
	ReadByte(cancellable Cancellable) (byte, error)
	// ReadInt16 reads a 16-bit/2-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	ReadInt16(cancellable Cancellable) (int16, error)
	// ReadInt32 reads a signed 32-bit/4-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadInt32(cancellable Cancellable) (int32, error)
	// ReadInt64 reads a 64-bit/8-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadInt64(cancellable Cancellable) (int64, error)
	// ReadLine reads a line from the data input stream. Note that no encoding
	// checks or conversion is performed; the input is not guaranteed to be
	// UTF-8, and may in fact have embedded NUL characters.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadLine(cancellable Cancellable) (uint, []byte, error)
	// ReadLineFinish: finish an asynchronous call started by
	// g_data_input_stream_read_line_async(). Note the warning about string
	// encoding in g_data_input_stream_read_line() applies here as well.
	ReadLineFinish(result AsyncResult) (uint, []byte, error)
	// ReadLineFinishUTF8: finish an asynchronous call started by
	// g_data_input_stream_read_line_async().
	ReadLineFinishUTF8(result AsyncResult) (uint, string, error)
	// ReadLineUTF8 reads a UTF-8 encoded line from the data input stream.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadLineUTF8(cancellable Cancellable) (uint, string, error)
	// ReadUint16 reads an unsigned 16-bit/2-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	ReadUint16(cancellable Cancellable) (uint16, error)
	// ReadUint32 reads an unsigned 32-bit/4-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadUint32(cancellable Cancellable) (uint32, error)
	// ReadUint64 reads an unsigned 64-bit/8-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadUint64(cancellable Cancellable) (uint64, error)
	// ReadUntil reads a string from the data input stream, up to the first
	// occurrence of any of the stop characters.
	//
	// Note that, in contrast to g_data_input_stream_read_until_async(), this
	// function consumes the stop character that it finds.
	//
	// Don't use this function in new code. Its functionality is inconsistent
	// with g_data_input_stream_read_until_async(). Both functions will be
	// marked as deprecated in a future release. Use
	// g_data_input_stream_read_upto() instead, but note that that function does
	// not consume the stop character.
	ReadUntil(stopChars string, cancellable Cancellable) (uint, string, error)
	// ReadUntilFinish: finish an asynchronous call started by
	// g_data_input_stream_read_until_async().
	ReadUntilFinish(result AsyncResult) (uint, string, error)
	// ReadUpto reads a string from the data input stream, up to the first
	// occurrence of any of the stop characters.
	//
	// In contrast to g_data_input_stream_read_until(), this function does not
	// consume the stop character. You have to use
	// g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto() again.
	//
	// Note that @stop_chars may contain '\0' if @stop_chars_len is specified.
	//
	// The returned string will always be nul-terminated on success.
	ReadUpto(stopChars string, stopCharsLen int, cancellable Cancellable) (uint, string, error)
	// ReadUptoFinish: finish an asynchronous call started by
	// g_data_input_stream_read_upto_async().
	//
	// Note that this function does not consume the stop character. You have to
	// use g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto_async() again.
	//
	// The returned string will always be nul-terminated on success.
	ReadUptoFinish(result AsyncResult) (uint, string, error)
	// SetByteOrder: this function sets the byte order for the given @stream.
	// All subsequent reads from the @stream will be read in the given @order.
	SetByteOrder(order DataStreamByteOrder)
	// SetNewlineType sets the newline type for the @stream.
	//
	// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a
	// read chunk ends in "CR" we must read an additional byte to know if this
	// is "CR" or "CR LF", and this might block if there is no more data
	// available.
	SetNewlineType(typ DataStreamNewlineType)
}

// dataInputStream implements the DataInputStream class.
type dataInputStream struct {
	BufferedInputStream
	Seekable
}

var _ DataInputStream = (*dataInputStream)(nil)

// WrapDataInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapDataInputStream(obj *externglib.Object) DataInputStream {
	return dataInputStream{
		BufferedInputStream: WrapBufferedInputStream(obj),
		Seekable:            WrapSeekable(obj),
	}
}

func marshalDataInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDataInputStream(obj), nil
}

// NewDataInputStream creates a new data input stream for the @base_stream.
func NewDataInputStream(baseStream InputStream) DataInputStream {
	var _arg1 *C.GInputStream     // out
	var _cret *C.GDataInputStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(baseStream.Native()))

	_cret = C.g_data_input_stream_new(_arg1)

	var _dataInputStream DataInputStream // out

	_dataInputStream = WrapDataInputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dataInputStream
}

func (s dataInputStream) ByteOrder() DataStreamByteOrder {
	var _arg0 *C.GDataInputStream    // out
	var _cret C.GDataStreamByteOrder // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_data_input_stream_get_byte_order(_arg0)

	var _dataStreamByteOrder DataStreamByteOrder // out

	_dataStreamByteOrder = DataStreamByteOrder(_cret)

	return _dataStreamByteOrder
}

func (s dataInputStream) NewlineType() DataStreamNewlineType {
	var _arg0 *C.GDataInputStream      // out
	var _cret C.GDataStreamNewlineType // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_data_input_stream_get_newline_type(_arg0)

	var _dataStreamNewlineType DataStreamNewlineType // out

	_dataStreamNewlineType = DataStreamNewlineType(_cret)

	return _dataStreamNewlineType
}

func (s dataInputStream) ReadByte(cancellable Cancellable) (byte, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.guchar            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_byte(_arg0, _arg1, &_cerr)

	var _guint8 byte // out
	var _goerr error // out

	_guint8 = (byte)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint8, _goerr
}

func (s dataInputStream) ReadInt16(cancellable Cancellable) (int16, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.gint16            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_int16(_arg0, _arg1, &_cerr)

	var _gint16 int16 // out
	var _goerr error  // out

	_gint16 = (int16)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint16, _goerr
}

func (s dataInputStream) ReadInt32(cancellable Cancellable) (int32, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.gint32            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_int32(_arg0, _arg1, &_cerr)

	var _gint32 int32 // out
	var _goerr error  // out

	_gint32 = (int32)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint32, _goerr
}

func (s dataInputStream) ReadInt64(cancellable Cancellable) (int64, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.gint64            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_int64(_arg0, _arg1, &_cerr)

	var _gint64 int64 // out
	var _goerr error  // out

	_gint64 = (int64)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint64, _goerr
}

func (s dataInputStream) ReadLine(cancellable Cancellable) (uint, []byte, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 C.gsize             // in
	var _arg2 *C.GCancellable     // out
	var _cret *C.char
	var _cerr *C.GError // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_line(_arg0, &_arg1, _arg2, &_cerr)

	var _length uint // out
	var _guint8s []byte
	var _goerr error // out

	_length = (uint)(_arg1)
	{
		var i int
		var z C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = (byte)(src[i])
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _guint8s, _goerr
}

func (s dataInputStream) ReadLineFinish(result AsyncResult) (uint, []byte, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _arg2 C.gsize             // in
	var _cret *C.char
	var _cerr *C.GError // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_data_input_stream_read_line_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _length uint // out
	var _guint8s []byte
	var _goerr error // out

	_length = (uint)(_arg2)
	{
		var i int
		var z C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = (byte)(src[i])
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _guint8s, _goerr
}

func (s dataInputStream) ReadLineFinishUTF8(result AsyncResult) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _arg2 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_data_input_stream_read_line_finish_utf8(_arg0, _arg1, &_arg2, &_cerr)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = (uint)(_arg2)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _utf8, _goerr
}

func (s dataInputStream) ReadLineUTF8(cancellable Cancellable) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 C.gsize             // in
	var _arg2 *C.GCancellable     // out
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_line_utf8(_arg0, &_arg1, _arg2, &_cerr)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = (uint)(_arg1)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _utf8, _goerr
}

func (s dataInputStream) ReadUint16(cancellable Cancellable) (uint16, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.guint16           // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_uint16(_arg0, _arg1, &_cerr)

	var _guint16 uint16 // out
	var _goerr error    // out

	_guint16 = (uint16)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint16, _goerr
}

func (s dataInputStream) ReadUint32(cancellable Cancellable) (uint32, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.guint32           // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_uint32(_arg0, _arg1, &_cerr)

	var _guint32 uint32 // out
	var _goerr error    // out

	_guint32 = (uint32)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint32, _goerr
}

func (s dataInputStream) ReadUint64(cancellable Cancellable) (uint64, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.guint64           // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_uint64(_arg0, _arg1, &_cerr)

	var _guint64 uint64 // out
	var _goerr error    // out

	_guint64 = (uint64)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint64, _goerr
}

func (s dataInputStream) ReadUntil(stopChars string, cancellable Cancellable) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gsize             // in
	var _arg3 *C.GCancellable     // out
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(stopChars))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_until(_arg0, _arg1, &_arg2, _arg3, &_cerr)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = (uint)(_arg2)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _utf8, _goerr
}

func (s dataInputStream) ReadUntilFinish(result AsyncResult) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _arg2 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_data_input_stream_read_until_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = (uint)(_arg2)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _utf8, _goerr
}

func (s dataInputStream) ReadUpto(stopChars string, stopCharsLen int, cancellable Cancellable) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gssize            // out
	var _arg3 C.gsize             // in
	var _arg4 *C.GCancellable     // out
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(stopChars))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(stopCharsLen)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_data_input_stream_read_upto(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = (uint)(_arg3)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _utf8, _goerr
}

func (s dataInputStream) ReadUptoFinish(result AsyncResult) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _arg2 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_data_input_stream_read_upto_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = (uint)(_arg2)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _utf8, _goerr
}

func (s dataInputStream) SetByteOrder(order DataStreamByteOrder) {
	var _arg0 *C.GDataInputStream    // out
	var _arg1 C.GDataStreamByteOrder // out

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GDataStreamByteOrder)(order)

	C.g_data_input_stream_set_byte_order(_arg0, _arg1)
}

func (s dataInputStream) SetNewlineType(typ DataStreamNewlineType) {
	var _arg0 *C.GDataInputStream      // out
	var _arg1 C.GDataStreamNewlineType // out

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GDataStreamNewlineType)(typ)

	C.g_data_input_stream_set_newline_type(_arg0, _arg1)
}

// DataOutputStream: data output stream implements Stream and includes functions
// for writing data directly to an output stream.
type DataOutputStream interface {
	FilterOutputStream
	Seekable

	// ByteOrder gets the byte order for the stream.
	ByteOrder() DataStreamByteOrder
	// PutByte puts a byte into the output stream.
	PutByte(data byte, cancellable Cancellable) error
	// PutInt16 puts a signed 16-bit integer into the output stream.
	PutInt16(data int16, cancellable Cancellable) error
	// PutInt32 puts a signed 32-bit integer into the output stream.
	PutInt32(data int32, cancellable Cancellable) error
	// PutInt64 puts a signed 64-bit integer into the stream.
	PutInt64(data int64, cancellable Cancellable) error
	// PutString puts a string into the output stream.
	PutString(str string, cancellable Cancellable) error
	// PutUint16 puts an unsigned 16-bit integer into the output stream.
	PutUint16(data uint16, cancellable Cancellable) error
	// PutUint32 puts an unsigned 32-bit integer into the stream.
	PutUint32(data uint32, cancellable Cancellable) error
	// PutUint64 puts an unsigned 64-bit integer into the stream.
	PutUint64(data uint64, cancellable Cancellable) error
	// SetByteOrder sets the byte order of the data output stream to @order.
	SetByteOrder(order DataStreamByteOrder)
}

// dataOutputStream implements the DataOutputStream class.
type dataOutputStream struct {
	FilterOutputStream
	Seekable
}

var _ DataOutputStream = (*dataOutputStream)(nil)

// WrapDataOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapDataOutputStream(obj *externglib.Object) DataOutputStream {
	return dataOutputStream{
		FilterOutputStream: WrapFilterOutputStream(obj),
		Seekable:           WrapSeekable(obj),
	}
}

func marshalDataOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDataOutputStream(obj), nil
}

// NewDataOutputStream creates a new data output stream for @base_stream.
func NewDataOutputStream(baseStream OutputStream) DataOutputStream {
	var _arg1 *C.GOutputStream     // out
	var _cret *C.GDataOutputStream // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(baseStream.Native()))

	_cret = C.g_data_output_stream_new(_arg1)

	var _dataOutputStream DataOutputStream // out

	_dataOutputStream = WrapDataOutputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dataOutputStream
}

func (s dataOutputStream) ByteOrder() DataStreamByteOrder {
	var _arg0 *C.GDataOutputStream   // out
	var _cret C.GDataStreamByteOrder // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_data_output_stream_get_byte_order(_arg0)

	var _dataStreamByteOrder DataStreamByteOrder // out

	_dataStreamByteOrder = DataStreamByteOrder(_cret)

	return _dataStreamByteOrder
}

func (s dataOutputStream) PutByte(data byte, cancellable Cancellable) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg1 C.guchar             // out
	var _arg2 *C.GCancellable      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guchar)(data)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_data_output_stream_put_byte(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s dataOutputStream) PutInt16(data int16, cancellable Cancellable) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg1 C.gint16             // out
	var _arg2 *C.GCancellable      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint16)(data)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_data_output_stream_put_int16(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s dataOutputStream) PutInt32(data int32, cancellable Cancellable) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg1 C.gint32             // out
	var _arg2 *C.GCancellable      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint32)(data)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_data_output_stream_put_int32(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s dataOutputStream) PutInt64(data int64, cancellable Cancellable) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg1 C.gint64             // out
	var _arg2 *C.GCancellable      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint64)(data)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_data_output_stream_put_int64(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s dataOutputStream) PutString(str string, cancellable Cancellable) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg1 *C.char              // out
	var _arg2 *C.GCancellable      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_data_output_stream_put_string(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s dataOutputStream) PutUint16(data uint16, cancellable Cancellable) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg1 C.guint16            // out
	var _arg2 *C.GCancellable      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint16)(data)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_data_output_stream_put_uint16(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s dataOutputStream) PutUint32(data uint32, cancellable Cancellable) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg1 C.guint32            // out
	var _arg2 *C.GCancellable      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint32)(data)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_data_output_stream_put_uint32(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s dataOutputStream) PutUint64(data uint64, cancellable Cancellable) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg1 C.guint64            // out
	var _arg2 *C.GCancellable      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint64)(data)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_data_output_stream_put_uint64(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s dataOutputStream) SetByteOrder(order DataStreamByteOrder) {
	var _arg0 *C.GDataOutputStream   // out
	var _arg1 C.GDataStreamByteOrder // out

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GDataStreamByteOrder)(order)

	C.g_data_output_stream_set_byte_order(_arg0, _arg1)
}

// DesktopAppInfo is an implementation of Info based on desktop files.
//
// Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type DesktopAppInfo interface {
	gextras.Objector
	AppInfo

	// ActionName gets the user-visible display name of the "additional
	// application action" specified by @action_name.
	//
	// This corresponds to the "Name" key within the keyfile group for the
	// action.
	ActionName(actionName string) string
	// Boolean looks up a boolean value in the keyfile backing @info.
	//
	// The @key is looked up in the "Desktop Entry" group.
	Boolean(key string) bool
	// Categories gets the categories from the desktop file.
	Categories() string
	// Filename: when @info was created from a known filename, return it. In
	// some situations such as the AppInfo returned from
	// g_desktop_app_info_new_from_keyfile(), this function will return nil.
	Filename() string
	// GenericName gets the generic name from the desktop file.
	GenericName() string
	// IsHidden: a desktop file is hidden if the Hidden key in it is set to
	// True.
	IsHidden() bool
	// Keywords gets the keywords from the desktop file.
	Keywords() []string
	// LocaleString looks up a localized string value in the keyfile backing
	// @info translated to the current locale.
	//
	// The @key is looked up in the "Desktop Entry" group.
	LocaleString(key string) string
	// Nodisplay gets the value of the NoDisplay key, which helps determine if
	// the application info should be shown in menus. See
	// KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().
	Nodisplay() bool
	// ShowIn checks if the application info should be shown in menus that list
	// available applications for a specific name of the desktop, based on the
	// `OnlyShowIn` and `NotShowIn` keys.
	//
	// @desktop_env should typically be given as nil, in which case the
	// `XDG_CURRENT_DESKTOP` environment variable is consulted. If you want to
	// override the default mechanism then you may specify @desktop_env, but
	// this is not recommended.
	//
	// Note that g_app_info_should_show() for @info will include this check
	// (with nil for @desktop_env) as well as additional checks.
	ShowIn(desktopEnv string) bool
	// StartupWmClass retrieves the StartupWMClass field from @info. This
	// represents the WM_CLASS property of the main window of the application,
	// if launched through @info.
	StartupWmClass() string
	// String looks up a string value in the keyfile backing @info.
	//
	// The @key is looked up in the "Desktop Entry" group.
	String(key string) string
	// HasKey returns whether @key exists in the "Desktop Entry" group of the
	// keyfile backing @info.
	HasKey(key string) bool
	// LaunchAction activates the named application action.
	//
	// You may only call this function on action names that were returned from
	// g_desktop_app_info_list_actions().
	//
	// Note that if the main entry of the desktop file indicates that the
	// application supports startup notification, and @launch_context is
	// non-nil, then startup notification will be used when activating the
	// action (and as such, invocation of the action on the receiving side must
	// signal the end of startup notification when it is completed). This is the
	// expected behaviour of applications declaring additional actions, as per
	// the desktop file specification.
	//
	// As with g_app_info_launch() there is no way to detect failures that occur
	// while using this function.
	LaunchAction(actionName string, launchContext AppLaunchContext)
	// ListActions returns the list of "additional application actions"
	// supported on the desktop file, as per the desktop file specification.
	//
	// As per the specification, this is the list of actions that are explicitly
	// listed in the "Actions" key of the [Desktop Entry] group.
	ListActions() []string
}

// desktopAppInfo implements the DesktopAppInfo class.
type desktopAppInfo struct {
	gextras.Objector
	AppInfo
}

var _ DesktopAppInfo = (*desktopAppInfo)(nil)

// WrapDesktopAppInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapDesktopAppInfo(obj *externglib.Object) DesktopAppInfo {
	return desktopAppInfo{
		Objector: obj,
		AppInfo:  WrapAppInfo(obj),
	}
}

func marshalDesktopAppInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDesktopAppInfo(obj), nil
}

// NewDesktopAppInfo creates a new AppInfo based on a desktop file id.
//
// A desktop file id is the basename of the desktop file, including the .desktop
// extension. GIO is looking for a desktop file with this name in the
// `applications` subdirectories of the XDG data directories (i.e. the
// directories specified in the `XDG_DATA_HOME` and `XDG_DATA_DIRS` environment
// variables). GIO also supports the prefix-to-subdirectory mapping that is
// described in the Menu Spec
// (http://standards.freedesktop.org/menu-spec/latest/) (i.e. a desktop id of
// kde-foo.desktop will match `/usr/share/applications/kde/foo.desktop`).
func NewDesktopAppInfo(desktopId string) DesktopAppInfo {
	var _arg1 *C.char            // out
	var _cret *C.GDesktopAppInfo // in

	_arg1 = (*C.char)(C.CString(desktopId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_desktop_app_info_new(_arg1)

	var _desktopAppInfo DesktopAppInfo // out

	_desktopAppInfo = WrapDesktopAppInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _desktopAppInfo
}

// NewDesktopAppInfoFromFilename creates a new AppInfo.
func NewDesktopAppInfoFromFilename(filename string) DesktopAppInfo {
	var _arg1 *C.char            // out
	var _cret *C.GDesktopAppInfo // in

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_desktop_app_info_new_from_filename(_arg1)

	var _desktopAppInfo DesktopAppInfo // out

	_desktopAppInfo = WrapDesktopAppInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _desktopAppInfo
}

// NewDesktopAppInfoFromKeyfile creates a new AppInfo.
func NewDesktopAppInfoFromKeyfile(keyFile *glib.KeyFile) DesktopAppInfo {
	var _arg1 *C.GKeyFile        // out
	var _cret *C.GDesktopAppInfo // in

	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))

	_cret = C.g_desktop_app_info_new_from_keyfile(_arg1)

	var _desktopAppInfo DesktopAppInfo // out

	_desktopAppInfo = WrapDesktopAppInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _desktopAppInfo
}

func (i desktopAppInfo) ActionName(actionName string) string {
	var _arg0 *C.GDesktopAppInfo // out
	var _arg1 *C.gchar           // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_desktop_app_info_get_action_name(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (i desktopAppInfo) Boolean(key string) bool {
	var _arg0 *C.GDesktopAppInfo // out
	var _arg1 *C.char            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_desktop_app_info_get_boolean(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i desktopAppInfo) Categories() string {
	var _arg0 *C.GDesktopAppInfo // out
	var _cret *C.char            // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_desktop_app_info_get_categories(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i desktopAppInfo) Filename() string {
	var _arg0 *C.GDesktopAppInfo // out
	var _cret *C.char            // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_desktop_app_info_get_filename(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (i desktopAppInfo) GenericName() string {
	var _arg0 *C.GDesktopAppInfo // out
	var _cret *C.char            // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_desktop_app_info_get_generic_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i desktopAppInfo) IsHidden() bool {
	var _arg0 *C.GDesktopAppInfo // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_desktop_app_info_get_is_hidden(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i desktopAppInfo) Keywords() []string {
	var _arg0 *C.GDesktopAppInfo // out
	var _cret **C.char

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_desktop_app_info_get_keywords(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (i desktopAppInfo) LocaleString(key string) string {
	var _arg0 *C.GDesktopAppInfo // out
	var _arg1 *C.char            // out
	var _cret *C.char            // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_desktop_app_info_get_locale_string(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (i desktopAppInfo) Nodisplay() bool {
	var _arg0 *C.GDesktopAppInfo // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_desktop_app_info_get_nodisplay(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i desktopAppInfo) ShowIn(desktopEnv string) bool {
	var _arg0 *C.GDesktopAppInfo // out
	var _arg1 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(desktopEnv))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_desktop_app_info_get_show_in(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i desktopAppInfo) StartupWmClass() string {
	var _arg0 *C.GDesktopAppInfo // out
	var _cret *C.char            // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_desktop_app_info_get_startup_wm_class(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i desktopAppInfo) String(key string) string {
	var _arg0 *C.GDesktopAppInfo // out
	var _arg1 *C.char            // out
	var _cret *C.char            // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_desktop_app_info_get_string(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (i desktopAppInfo) HasKey(key string) bool {
	var _arg0 *C.GDesktopAppInfo // out
	var _arg1 *C.char            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_desktop_app_info_has_key(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i desktopAppInfo) LaunchAction(actionName string, launchContext AppLaunchContext) {
	var _arg0 *C.GDesktopAppInfo   // out
	var _arg1 *C.gchar             // out
	var _arg2 *C.GAppLaunchContext // out

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(launchContext.Native()))

	C.g_desktop_app_info_launch_action(_arg0, _arg1, _arg2)
}

func (i desktopAppInfo) ListActions() []string {
	var _arg0 *C.GDesktopAppInfo // out
	var _cret **C.gchar

	_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_desktop_app_info_list_actions(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

// Emblem is an implementation of #GIcon that supports having an emblem, which
// is an icon with additional properties. It can than be added to a Icon.
//
// Currently, only metainformation about the emblem's origin is supported. More
// may be added in the future.
type Emblem interface {
	gextras.Objector
	Icon

	// GetIcon gives back the icon from @emblem.
	GetIcon() Icon
	// Origin gets the origin of the emblem.
	Origin() EmblemOrigin
}

// emblem implements the Emblem class.
type emblem struct {
	gextras.Objector
	Icon
}

var _ Emblem = (*emblem)(nil)

// WrapEmblem wraps a GObject to the right type. It is
// primarily used internally.
func WrapEmblem(obj *externglib.Object) Emblem {
	return emblem{
		Objector: obj,
		Icon:     WrapIcon(obj),
	}
}

func marshalEmblem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEmblem(obj), nil
}

// NewEmblem creates a new emblem for @icon.
func NewEmblem(icon Icon) Emblem {
	var _arg1 *C.GIcon   // out
	var _cret *C.GEmblem // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	_cret = C.g_emblem_new(_arg1)

	var _emblem Emblem // out

	_emblem = WrapEmblem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _emblem
}

// NewEmblemWithOrigin creates a new emblem for @icon.
func NewEmblemWithOrigin(icon Icon, origin EmblemOrigin) Emblem {
	var _arg1 *C.GIcon        // out
	var _arg2 C.GEmblemOrigin // out
	var _cret *C.GEmblem      // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg2 = (C.GEmblemOrigin)(origin)

	_cret = C.g_emblem_new_with_origin(_arg1, _arg2)

	var _emblem Emblem // out

	_emblem = WrapEmblem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _emblem
}

func (e emblem) GetIcon() Icon {
	var _arg0 *C.GEmblem // out
	var _cret *C.GIcon   // in

	_arg0 = (*C.GEmblem)(unsafe.Pointer(e.Native()))

	_cret = C.g_emblem_get_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (e emblem) Origin() EmblemOrigin {
	var _arg0 *C.GEmblem      // out
	var _cret C.GEmblemOrigin // in

	_arg0 = (*C.GEmblem)(unsafe.Pointer(e.Native()))

	_cret = C.g_emblem_get_origin(_arg0)

	var _emblemOrigin EmblemOrigin // out

	_emblemOrigin = EmblemOrigin(_cret)

	return _emblemOrigin
}

// EmblemedIcon is an implementation of #GIcon that supports adding an emblem to
// an icon. Adding multiple emblems to an icon is ensured via
// g_emblemed_icon_add_emblem().
//
// Note that Icon allows no control over the position of the emblems. See also
// #GEmblem for more information.
type EmblemedIcon interface {
	gextras.Objector
	Icon

	// AddEmblem adds @emblem to the #GList of #GEmblems.
	AddEmblem(emblem Emblem)
	// ClearEmblems removes all the emblems from @icon.
	ClearEmblems()
	// GetIcon gets the main icon for @emblemed.
	GetIcon() Icon
}

// emblemedIcon implements the EmblemedIcon class.
type emblemedIcon struct {
	gextras.Objector
	Icon
}

var _ EmblemedIcon = (*emblemedIcon)(nil)

// WrapEmblemedIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapEmblemedIcon(obj *externglib.Object) EmblemedIcon {
	return emblemedIcon{
		Objector: obj,
		Icon:     WrapIcon(obj),
	}
}

func marshalEmblemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEmblemedIcon(obj), nil
}

// NewEmblemedIcon creates a new emblemed icon for @icon with the emblem
// @emblem.
func NewEmblemedIcon(icon Icon, emblem Emblem) EmblemedIcon {
	var _arg1 *C.GIcon   // out
	var _arg2 *C.GEmblem // out
	var _cret *C.GIcon   // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg2 = (*C.GEmblem)(unsafe.Pointer(emblem.Native()))

	_cret = C.g_emblemed_icon_new(_arg1, _arg2)

	var _emblemedIcon EmblemedIcon // out

	_emblemedIcon = WrapEmblemedIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _emblemedIcon
}

func (e emblemedIcon) AddEmblem(emblem Emblem) {
	var _arg0 *C.GEmblemedIcon // out
	var _arg1 *C.GEmblem       // out

	_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GEmblem)(unsafe.Pointer(emblem.Native()))

	C.g_emblemed_icon_add_emblem(_arg0, _arg1)
}

func (e emblemedIcon) ClearEmblems() {
	var _arg0 *C.GEmblemedIcon // out

	_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(e.Native()))

	C.g_emblemed_icon_clear_emblems(_arg0)
}

func (e emblemedIcon) GetIcon() Icon {
	var _arg0 *C.GEmblemedIcon // out
	var _cret *C.GIcon         // in

	_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(e.Native()))

	_cret = C.g_emblemed_icon_get_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

// FileEnumerator allows you to operate on a set of #GFiles, returning a Info
// structure for each file enumerated (e.g. g_file_enumerate_children() will
// return a Enumerator for each of the children within a directory).
//
// To get the next file's information from a Enumerator, use
// g_file_enumerator_next_file() or its asynchronous version,
// g_file_enumerator_next_files_async(). Note that the asynchronous version will
// return a list of Infos, whereas the synchronous will only return the next
// file in the enumerator.
//
// The ordering of returned files is unspecified for non-Unix platforms; for
// more information, see g_dir_read_name(). On Unix, when operating on local
// files, returned files will be sorted by inode number. Effectively you can
// assume that the ordering of returned files will be stable between successive
// calls (and applications) assuming the directory is unchanged.
//
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your application code.
//
// To close a Enumerator, use g_file_enumerator_close(), or its asynchronous
// version, g_file_enumerator_close_async(). Once a Enumerator is closed, no
// further actions may be performed on it, and it should be freed with
// g_object_unref().
type FileEnumerator interface {
	gextras.Objector

	// Close releases all resources used by this enumerator, making the
	// enumerator return G_IO_ERROR_CLOSED on all calls.
	//
	// This will be automatically called when the last reference is dropped, but
	// you might want to call this function to make sure resources are released
	// as early as possible.
	Close(cancellable Cancellable) error
	// CloseFinish finishes closing a file enumerator, started from
	// g_file_enumerator_close_async().
	//
	// If the file enumerator was already closed when
	// g_file_enumerator_close_async() was called, then this function will
	// report G_IO_ERROR_CLOSED in @error, and return false. If the file
	// enumerator had pending operation when the close operation was started,
	// then this function will report G_IO_ERROR_PENDING, and return false. If
	// @cancellable was not nil, then the operation may have been cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and false will
	// be returned.
	CloseFinish(result AsyncResult) error
	// Child: return a new #GFile which refers to the file named by @info in the
	// source directory of @enumerator. This function is primarily intended to
	// be used inside loops with g_file_enumerator_next_file().
	//
	// This is a convenience method that's equivalent to:
	//
	//    gchar *name = g_file_info_get_name (info);
	//    GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
	//                                     name);
	Child(info FileInfo) File
	// Container: get the #GFile container which is being enumerated.
	Container() File
	// HasPending checks if the file enumerator has pending operations.
	HasPending() bool
	// IsClosed checks if the file enumerator has been closed.
	IsClosed() bool
	// Iterate: this is a version of g_file_enumerator_next_file() that's easier
	// to use correctly from C programs. With g_file_enumerator_next_file(), the
	// gboolean return value signifies "end of iteration or error", which
	// requires allocation of a temporary #GError.
	//
	// In contrast, with this function, a false return from
	// g_file_enumerator_iterate() *always* means "error". End of iteration is
	// signaled by @out_info or @out_child being nil.
	//
	// Another crucial difference is that the references for @out_info and
	// @out_child are owned by @direnum (they are cached as hidden properties).
	// You must not unref them in your own code. This makes memory management
	// significantly easier for C code in combination with loops.
	//
	// Finally, this function optionally allows retrieving a #GFile as well.
	//
	// You must specify at least one of @out_info or @out_child.
	//
	// The code pattern for correctly using g_file_enumerator_iterate() from C
	// is:
	//
	//    direnum = g_file_enumerate_children (file, ...);
	//    while (TRUE)
	//      {
	//        GFileInfo *info;
	//        if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
	//          goto out;
	//        if (!info)
	//          break;
	//        ... do stuff with "info"; do not unref it! ...
	//      }
	//
	//    out:
	//      g_object_unref (direnum); // Note: frees the last @info
	Iterate(cancellable Cancellable) (FileInfo, File, error)
	// NextFile returns information for the next file in the enumerated object.
	// Will block until the information is available. The Info returned from
	// this function will contain attributes that match the attribute string
	// that was passed when the Enumerator was created.
	//
	// See the documentation of Enumerator for information about the order of
	// returned files.
	//
	// On error, returns nil and sets @error to the error. If the enumerator is
	// at the end, nil will be returned and @error will be unset.
	NextFile(cancellable Cancellable) (FileInfo, error)
	// SetPending sets the file enumerator as having pending operations.
	SetPending(pending bool)
}

// fileEnumerator implements the FileEnumerator class.
type fileEnumerator struct {
	gextras.Objector
}

var _ FileEnumerator = (*fileEnumerator)(nil)

// WrapFileEnumerator wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileEnumerator(obj *externglib.Object) FileEnumerator {
	return fileEnumerator{
		Objector: obj,
	}
}

func marshalFileEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileEnumerator(obj), nil
}

func (e fileEnumerator) Close(cancellable Cancellable) error {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_enumerator_close(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (e fileEnumerator) CloseFinish(result AsyncResult) error {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_file_enumerator_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (e fileEnumerator) Child(info FileInfo) File {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GFileInfo       // out
	var _cret *C.GFile           // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(info.Native()))

	_cret = C.g_file_enumerator_get_child(_arg0, _arg1)

	var _file File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _file
}

func (e fileEnumerator) Container() File {
	var _arg0 *C.GFileEnumerator // out
	var _cret *C.GFile           // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))

	_cret = C.g_file_enumerator_get_container(_arg0)

	var _file File // out

	_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(File)

	return _file
}

func (e fileEnumerator) HasPending() bool {
	var _arg0 *C.GFileEnumerator // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))

	_cret = C.g_file_enumerator_has_pending(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e fileEnumerator) IsClosed() bool {
	var _arg0 *C.GFileEnumerator // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))

	_cret = C.g_file_enumerator_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d fileEnumerator) Iterate(cancellable Cancellable) (FileInfo, File, error) {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GFileInfo       // in
	var _arg2 *C.GFile           // in
	var _arg3 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(d.Native()))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_file_enumerator_iterate(_arg0, &_arg1, &_arg2, _arg3, &_cerr)

	var _outInfo FileInfo // out
	var _outChild File    // out
	var _goerr error      // out

	_outInfo = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(FileInfo)
	_outChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(File)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outInfo, _outChild, _goerr
}

func (e fileEnumerator) NextFile(cancellable Cancellable) (FileInfo, error) {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GCancellable    // out
	var _cret *C.GFileInfo       // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_enumerator_next_file(_arg0, _arg1, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

func (e fileEnumerator) SetPending(pending bool) {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
	if pending {
		_arg1 = C.TRUE
	}

	C.g_file_enumerator_set_pending(_arg0, _arg1)
}

// FileIOStream: GFileIOStream provides io streams that both read and write to
// the same file handle.
//
// GFileIOStream implements #GSeekable, which allows the io stream to jump to
// arbitrary positions in the file and to truncate the file, provided the
// filesystem of the file supports these operations.
//
// To find the position of a file io stream, use g_seekable_tell().
//
// To find out if a file io stream supports seeking, use g_seekable_can_seek().
// To position a file io stream, use g_seekable_seek(). To find out if a file io
// stream supports truncating, use g_seekable_can_truncate(). To truncate a file
// io stream, use g_seekable_truncate().
//
// The default implementation of all the IOStream operations and the
// implementation of #GSeekable just call into the same operations on the output
// stream.
type FileIOStream interface {
	IOStream
	Seekable

	// Etag gets the entity tag for the file when it has been written. This must
	// be called after the stream has been written and closed, as the etag can
	// change while writing.
	Etag() string
	// QueryInfo queries a file io stream for the given @attributes. This
	// function blocks while querying the stream. For the asynchronous version
	// of this function, see g_file_io_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally, and
	// any other operations on the stream will fail with G_IO_ERROR_PENDING.
	//
	// Can fail if the stream was already closed (with @error being set to
	// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
	// stream's interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED). I
	// all cases of failure, nil will be returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and nil will
	// be returned.
	QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// QueryInfoFinish finalizes the asynchronous query started by
	// g_file_io_stream_query_info_async().
	QueryInfoFinish(result AsyncResult) (FileInfo, error)
}

// fileIOStream implements the FileIOStream class.
type fileIOStream struct {
	IOStream
	Seekable
}

var _ FileIOStream = (*fileIOStream)(nil)

// WrapFileIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileIOStream(obj *externglib.Object) FileIOStream {
	return fileIOStream{
		IOStream: WrapIOStream(obj),
		Seekable: WrapSeekable(obj),
	}
}

func marshalFileIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileIOStream(obj), nil
}

func (s fileIOStream) Etag() string {
	var _arg0 *C.GFileIOStream // out
	var _cret *C.char          // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_file_io_stream_get_etag(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (s fileIOStream) QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var _arg0 *C.GFileIOStream // out
	var _arg1 *C.char          // out
	var _arg2 *C.GCancellable  // out
	var _cret *C.GFileInfo     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_io_stream_query_info(_arg0, _arg1, _arg2, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

func (s fileIOStream) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var _arg0 *C.GFileIOStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileInfo     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_file_io_stream_query_info_finish(_arg0, _arg1, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

// FileIcon specifies an icon by pointing to an image file to be used as icon.
type FileIcon interface {
	gextras.Objector
	Icon
	LoadableIcon

	// File gets the #GFile associated with the given @icon.
	File() File
}

// fileIcon implements the FileIcon class.
type fileIcon struct {
	gextras.Objector
	Icon
	LoadableIcon
}

var _ FileIcon = (*fileIcon)(nil)

// WrapFileIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileIcon(obj *externglib.Object) FileIcon {
	return fileIcon{
		Objector:     obj,
		Icon:         WrapIcon(obj),
		LoadableIcon: WrapLoadableIcon(obj),
	}
}

func marshalFileIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileIcon(obj), nil
}

// NewFileIcon creates a new icon for a file.
func NewFileIcon(file File) FileIcon {
	var _arg1 *C.GFile // out
	var _cret *C.GIcon // in

	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	_cret = C.g_file_icon_new(_arg1)

	var _fileIcon FileIcon // out

	_fileIcon = WrapFileIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileIcon
}

func (i fileIcon) File() File {
	var _arg0 *C.GFileIcon // out
	var _cret *C.GFile     // in

	_arg0 = (*C.GFileIcon)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_icon_get_file(_arg0)

	var _file File // out

	_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(File)

	return _file
}

// FileInfo: functionality for manipulating basic metadata for files. Info
// implements methods for getting information that all files should contain, and
// allows for manipulation of extended attributes.
//
// See [GFileAttribute][gio-GFileAttribute] for more information on how GIO
// handles file attributes.
//
// To obtain a Info for a #GFile, use g_file_query_info() (or its async
// variant). To obtain a Info for a file input or output stream, use
// g_file_input_stream_query_info() or g_file_output_stream_query_info() (or
// their async variants).
//
// To change the actual attributes of a file, you should then set the attribute
// in the Info and call g_file_set_attributes_from_info() or
// g_file_set_attributes_async() on a GFile.
//
// However, not all attributes can be changed in the file. For instance, the
// actual size of a file cannot be changed via g_file_info_set_size(). You may
// call g_file_query_settable_attributes() and
// g_file_query_writable_namespaces() to discover the settable attributes of a
// particular file at runtime.
//
// AttributeMatcher allows for searching through a Info for attributes.
type FileInfo interface {
	gextras.Objector

	// ClearStatus clears the status information from @info.
	ClearStatus()
	// CopyInto: first clears all of the [GFileAttribute][gio-GFileAttribute] of
	// @dest_info, and then copies all of the file attributes from @src_info to
	// @dest_info.
	CopyInto(destInfo FileInfo)
	// Dup duplicates a file info structure.
	Dup() FileInfo
	// AttributeAsString gets the value of a attribute, formatted as a string.
	// This escapes things as needed to make the string valid UTF-8.
	AttributeAsString(attribute string) string
	// AttributeBoolean gets the value of a boolean attribute. If the attribute
	// does not contain a boolean value, false will be returned.
	AttributeBoolean(attribute string) bool
	// AttributeByteString gets the value of a byte string attribute. If the
	// attribute does not contain a byte string, nil will be returned.
	AttributeByteString(attribute string) string
	// AttributeInt32 gets a signed 32-bit integer contained within the
	// attribute. If the attribute does not contain a signed 32-bit integer, or
	// is invalid, 0 will be returned.
	AttributeInt32(attribute string) int32
	// AttributeInt64 gets a signed 64-bit integer contained within the
	// attribute. If the attribute does not contain a signed 64-bit integer, or
	// is invalid, 0 will be returned.
	AttributeInt64(attribute string) int64
	// AttributeObject gets the value of a #GObject attribute. If the attribute
	// does not contain a #GObject, nil will be returned.
	AttributeObject(attribute string) gextras.Objector
	// AttributeStatus gets the attribute status for an attribute key.
	AttributeStatus(attribute string) FileAttributeStatus
	// AttributeString gets the value of a string attribute. If the attribute
	// does not contain a string, nil will be returned.
	AttributeString(attribute string) string
	// AttributeStringv gets the value of a stringv attribute. If the attribute
	// does not contain a stringv, nil will be returned.
	AttributeStringv(attribute string) []string
	// AttributeType gets the attribute type for an attribute key.
	AttributeType(attribute string) FileAttributeType
	// AttributeUint32 gets an unsigned 32-bit integer contained within the
	// attribute. If the attribute does not contain an unsigned 32-bit integer,
	// or is invalid, 0 will be returned.
	AttributeUint32(attribute string) uint32
	// AttributeUint64 gets a unsigned 64-bit integer contained within the
	// attribute. If the attribute does not contain an unsigned 64-bit integer,
	// or is invalid, 0 will be returned.
	AttributeUint64(attribute string) uint64
	// ContentType gets the file's content type.
	ContentType() string
	// DisplayName gets a display name for a file. This is guaranteed to always
	// be set.
	DisplayName() string
	// EditName gets the edit name for a file.
	EditName() string
	// Etag gets the [entity tag][gfile-etag] for a given Info. See
	// G_FILE_ATTRIBUTE_ETAG_VALUE.
	Etag() string
	// FileType gets a file's type (whether it is a regular file, symlink, etc).
	// This is different from the file's content type, see
	// g_file_info_get_content_type().
	FileType() FileType
	// Icon gets the icon for a file.
	Icon() Icon
	// IsBackup checks if a file is a backup file.
	IsBackup() bool
	// IsHidden checks if a file is hidden.
	IsHidden() bool
	// IsSymlink checks if a file is a symlink.
	IsSymlink() bool
	// ModificationTime gets the modification time of the current @info and sets
	// it in @result.
	ModificationTime() glib.TimeVal
	// Name gets the name for a file. This is guaranteed to always be set.
	Name() string
	// Size gets the file's size (in bytes). The size is retrieved through the
	// value of the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
	// from #guint64 to #goffset before returning the result.
	Size() int64
	// SortOrder gets the value of the sort_order attribute from the Info. See
	// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	SortOrder() int32
	// SymbolicIcon gets the symbolic icon for a file.
	SymbolicIcon() Icon
	// SymlinkTarget gets the symlink target for a given Info.
	SymlinkTarget() string
	// HasAttribute checks if a file info structure has an attribute named
	// @attribute.
	HasAttribute(attribute string) bool
	// HasNamespace checks if a file info structure has an attribute in the
	// specified @name_space.
	HasNamespace(nameSpace string) bool
	// ListAttributes lists the file info structure's attributes.
	ListAttributes(nameSpace string) []string
	// RemoveAttribute removes all cases of @attribute from @info if it exists.
	RemoveAttribute(attribute string)
	// SetAttributeBoolean sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeBoolean(attribute string, attrValue bool)
	// SetAttributeByteString sets the @attribute to contain the given
	// @attr_value, if possible.
	SetAttributeByteString(attribute string, attrValue string)
	// SetAttributeInt32 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt32(attribute string, attrValue int32)
	// SetAttributeInt64 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt64(attribute string, attrValue int64)
	// SetAttributeMask sets @mask on @info to match specific attribute types.
	SetAttributeMask(mask *FileAttributeMatcher)
	// SetAttributeObject sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeObject(attribute string, attrValue gextras.Objector)
	// SetAttributeStatus sets the attribute status for an attribute key. This
	// is only needed by external code that implement
	// g_file_set_attributes_from_info() or similar functions.
	//
	// The attribute must exist in @info for this to work. Otherwise false is
	// returned and @info is unchanged.
	SetAttributeStatus(attribute string, status FileAttributeStatus) bool
	// SetAttributeString sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeString(attribute string, attrValue string)
	// SetAttributeStringv sets the @attribute to contain the given @attr_value,
	// if possible.
	//
	// Sinze: 2.22
	SetAttributeStringv(attribute string, attrValue []string)
	// SetAttributeUint32 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint32(attribute string, attrValue uint32)
	// SetAttributeUint64 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint64(attribute string, attrValue uint64)
	// SetContentType sets the content type attribute for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
	SetContentType(contentType string)
	// SetDisplayName sets the display name for the current Info. See
	// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
	SetDisplayName(displayName string)
	// SetEditName sets the edit name for the current file. See
	// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
	SetEditName(editName string)
	// SetFileType sets the file type in a Info to @type. See
	// G_FILE_ATTRIBUTE_STANDARD_TYPE.
	SetFileType(typ FileType)
	// SetIcon sets the icon for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_ICON.
	SetIcon(icon Icon)
	// SetIsHidden sets the "is_hidden" attribute in a Info according to
	// @is_hidden. See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
	SetIsHidden(isHidden bool)
	// SetIsSymlink sets the "is_symlink" attribute in a Info according to
	// @is_symlink. See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
	SetIsSymlink(isSymlink bool)
	// SetModificationTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
	// given time value.
	SetModificationTime(mtime *glib.TimeVal)
	// SetName sets the name attribute for the current Info. See
	// G_FILE_ATTRIBUTE_STANDARD_NAME.
	SetName(name string)
	// SetSize sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file
	// info to the given size.
	SetSize(size int64)
	// SetSortOrder sets the sort order attribute in the file info structure.
	// See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	SetSortOrder(sortOrder int32)
	// SetSymbolicIcon sets the symbolic icon for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
	SetSymbolicIcon(icon Icon)
	// SetSymlinkTarget sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET
	// attribute in the file info to the given symlink target.
	SetSymlinkTarget(symlinkTarget string)
	// UnsetAttributeMask unsets a mask set by g_file_info_set_attribute_mask(),
	// if one is set.
	UnsetAttributeMask()
}

// fileInfo implements the FileInfo class.
type fileInfo struct {
	gextras.Objector
}

var _ FileInfo = (*fileInfo)(nil)

// WrapFileInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileInfo(obj *externglib.Object) FileInfo {
	return fileInfo{
		Objector: obj,
	}
}

func marshalFileInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileInfo(obj), nil
}

// NewFileInfo creates a new file info structure.
func NewFileInfo() FileInfo {
	var _cret *C.GFileInfo // in

	_cret = C.g_file_info_new()

	var _fileInfo FileInfo // out

	_fileInfo = WrapFileInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileInfo
}

func (i fileInfo) ClearStatus() {
	var _arg0 *C.GFileInfo // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_clear_status(_arg0)
}

func (s fileInfo) CopyInto(destInfo FileInfo) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GFileInfo // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(destInfo.Native()))

	C.g_file_info_copy_into(_arg0, _arg1)
}

func (o fileInfo) Dup() FileInfo {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GFileInfo // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(o.Native()))

	_cret = C.g_file_info_dup(_arg0)

	var _fileInfo FileInfo // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)

	return _fileInfo
}

func (i fileInfo) AttributeAsString(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_as_string(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (i fileInfo) AttributeBoolean(attribute string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_boolean(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i fileInfo) AttributeByteString(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_byte_string(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i fileInfo) AttributeInt32(attribute string) int32 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gint32     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_int32(_arg0, _arg1)

	var _gint32 int32 // out

	_gint32 = (int32)(_cret)

	return _gint32
}

func (i fileInfo) AttributeInt64(attribute string) int64 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gint64     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_int64(_arg0, _arg1)

	var _gint64 int64 // out

	_gint64 = (int64)(_cret)

	return _gint64
}

func (i fileInfo) AttributeObject(attribute string) gextras.Objector {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.GObject   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_object(_arg0, _arg1)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (i fileInfo) AttributeStatus(attribute string) FileAttributeStatus {
	var _arg0 *C.GFileInfo           // out
	var _arg1 *C.char                // out
	var _cret C.GFileAttributeStatus // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_status(_arg0, _arg1)

	var _fileAttributeStatus FileAttributeStatus // out

	_fileAttributeStatus = FileAttributeStatus(_cret)

	return _fileAttributeStatus
}

func (i fileInfo) AttributeString(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_string(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i fileInfo) AttributeStringv(attribute string) []string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret **C.char

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_stringv(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (i fileInfo) AttributeType(attribute string) FileAttributeType {
	var _arg0 *C.GFileInfo         // out
	var _arg1 *C.char              // out
	var _cret C.GFileAttributeType // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_type(_arg0, _arg1)

	var _fileAttributeType FileAttributeType // out

	_fileAttributeType = FileAttributeType(_cret)

	return _fileAttributeType
}

func (i fileInfo) AttributeUint32(attribute string) uint32 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.guint32    // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_uint32(_arg0, _arg1)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

func (i fileInfo) AttributeUint64(attribute string) uint64 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.guint64    // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_uint64(_arg0, _arg1)

	var _guint64 uint64 // out

	_guint64 = (uint64)(_cret)

	return _guint64
}

func (i fileInfo) ContentType() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_content_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i fileInfo) DisplayName() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i fileInfo) EditName() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_edit_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i fileInfo) Etag() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_etag(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i fileInfo) FileType() FileType {
	var _arg0 *C.GFileInfo // out
	var _cret C.GFileType  // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_file_type(_arg0)

	var _fileType FileType // out

	_fileType = FileType(_cret)

	return _fileType
}

func (i fileInfo) Icon() Icon {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GIcon     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (i fileInfo) IsBackup() bool {
	var _arg0 *C.GFileInfo // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_is_backup(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i fileInfo) IsHidden() bool {
	var _arg0 *C.GFileInfo // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_is_hidden(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i fileInfo) IsSymlink() bool {
	var _arg0 *C.GFileInfo // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_is_symlink(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i fileInfo) ModificationTime() glib.TimeVal {
	var _arg0 *C.GFileInfo // out
	var _result glib.TimeVal

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_modification_time(_arg0, (*C.GTimeVal)(unsafe.Pointer(&_result)))

	return _result
}

func (i fileInfo) Name() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_name(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (i fileInfo) Size() int64 {
	var _arg0 *C.GFileInfo // out
	var _cret C.goffset    // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_size(_arg0)

	var _gint64 int64 // out

	_gint64 = (int64)(_cret)

	return _gint64
}

func (i fileInfo) SortOrder() int32 {
	var _arg0 *C.GFileInfo // out
	var _cret C.gint32     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_sort_order(_arg0)

	var _gint32 int32 // out

	_gint32 = (int32)(_cret)

	return _gint32
}

func (i fileInfo) SymbolicIcon() Icon {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GIcon     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_symbolic_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (i fileInfo) SymlinkTarget() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_file_info_get_symlink_target(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i fileInfo) HasAttribute(attribute string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_has_attribute(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i fileInfo) HasNamespace(nameSpace string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(nameSpace))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_has_namespace(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i fileInfo) ListAttributes(nameSpace string) []string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret **C.char

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(nameSpace))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_list_attributes(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (i fileInfo) RemoveAttribute(attribute string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_remove_attribute(_arg0, _arg1)
}

func (i fileInfo) SetAttributeBoolean(attribute string, attrValue bool) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	if attrValue {
		_arg2 = C.TRUE
	}

	C.g_file_info_set_attribute_boolean(_arg0, _arg1, _arg2)
}

func (i fileInfo) SetAttributeByteString(attribute string, attrValue string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(attrValue))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_file_info_set_attribute_byte_string(_arg0, _arg1, _arg2)
}

func (i fileInfo) SetAttributeInt32(attribute string, attrValue int32) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.gint32     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint32)(attrValue)

	C.g_file_info_set_attribute_int32(_arg0, _arg1, _arg2)
}

func (i fileInfo) SetAttributeInt64(attribute string, attrValue int64) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.gint64     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint64)(attrValue)

	C.g_file_info_set_attribute_int64(_arg0, _arg1, _arg2)
}

func (i fileInfo) SetAttributeMask(mask *FileAttributeMatcher) {
	var _arg0 *C.GFileInfo             // out
	var _arg1 *C.GFileAttributeMatcher // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GFileAttributeMatcher)(unsafe.Pointer(mask.Native()))

	C.g_file_info_set_attribute_mask(_arg0, _arg1)
}

func (i fileInfo) SetAttributeObject(attribute string, attrValue gextras.Objector) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.GObject   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(attrValue.Native()))

	C.g_file_info_set_attribute_object(_arg0, _arg1, _arg2)
}

func (i fileInfo) SetAttributeStatus(attribute string, status FileAttributeStatus) bool {
	var _arg0 *C.GFileInfo           // out
	var _arg1 *C.char                // out
	var _arg2 C.GFileAttributeStatus // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GFileAttributeStatus)(status)

	_cret = C.g_file_info_set_attribute_status(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i fileInfo) SetAttributeString(attribute string, attrValue string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(attrValue))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_file_info_set_attribute_string(_arg0, _arg1, _arg2)
}

func (i fileInfo) SetAttributeStringv(attribute string, attrValue []string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 **C.char

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.char)(C.malloc(C.ulong(len(attrValue)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(attrValue))
		for i := range attrValue {
			out[i] = (*C.gchar)(C.CString(attrValue[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_file_info_set_attribute_stringv(_arg0, _arg1, _arg2)
}

func (i fileInfo) SetAttributeUint32(attribute string, attrValue uint32) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.guint32    // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint32)(attrValue)

	C.g_file_info_set_attribute_uint32(_arg0, _arg1, _arg2)
}

func (i fileInfo) SetAttributeUint64(attribute string, attrValue uint64) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.guint64    // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint64)(attrValue)

	C.g_file_info_set_attribute_uint64(_arg0, _arg1, _arg2)
}

func (i fileInfo) SetContentType(contentType string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_content_type(_arg0, _arg1)
}

func (i fileInfo) SetDisplayName(displayName string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(displayName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_display_name(_arg0, _arg1)
}

func (i fileInfo) SetEditName(editName string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(editName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_edit_name(_arg0, _arg1)
}

func (i fileInfo) SetFileType(typ FileType) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.GFileType  // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GFileType)(typ)

	C.g_file_info_set_file_type(_arg0, _arg1)
}

func (i fileInfo) SetIcon(icon Icon) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_file_info_set_icon(_arg0, _arg1)
}

func (i fileInfo) SetIsHidden(isHidden bool) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	if isHidden {
		_arg1 = C.TRUE
	}

	C.g_file_info_set_is_hidden(_arg0, _arg1)
}

func (i fileInfo) SetIsSymlink(isSymlink bool) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	if isSymlink {
		_arg1 = C.TRUE
	}

	C.g_file_info_set_is_symlink(_arg0, _arg1)
}

func (i fileInfo) SetModificationTime(mtime *glib.TimeVal) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GTimeVal  // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GTimeVal)(unsafe.Pointer(mtime.Native()))

	C.g_file_info_set_modification_time(_arg0, _arg1)
}

func (i fileInfo) SetName(name string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_name(_arg0, _arg1)
}

func (i fileInfo) SetSize(size int64) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.goffset    // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (C.goffset)(size)

	C.g_file_info_set_size(_arg0, _arg1)
}

func (i fileInfo) SetSortOrder(sortOrder int32) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.gint32     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint32)(sortOrder)

	C.g_file_info_set_sort_order(_arg0, _arg1)
}

func (i fileInfo) SetSymbolicIcon(icon Icon) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_file_info_set_symbolic_icon(_arg0, _arg1)
}

func (i fileInfo) SetSymlinkTarget(symlinkTarget string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(symlinkTarget))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_symlink_target(_arg0, _arg1)
}

func (i fileInfo) UnsetAttributeMask() {
	var _arg0 *C.GFileInfo // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_unset_attribute_mask(_arg0)
}

// FileInputStream: GFileInputStream provides input streams that take their
// content from a file.
//
// GFileInputStream implements #GSeekable, which allows the input stream to jump
// to arbitrary positions in the file, provided the filesystem of the file
// allows it. To find the position of a file input stream, use
// g_seekable_tell(). To find out if a file input stream supports seeking, use
// g_seekable_can_seek(). To position a file input stream, use
// g_seekable_seek().
type FileInputStream interface {
	InputStream
	Seekable

	// QueryInfo queries a file input stream the given @attributes. This
	// function blocks while querying the stream. For the asynchronous
	// (non-blocking) version of this function, see
	// g_file_input_stream_query_info_async(). While the stream is blocked, the
	// stream will set the pending flag internally, and any other operations on
	// the stream will fail with G_IO_ERROR_PENDING.
	QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// QueryInfoFinish finishes an asynchronous info query operation.
	QueryInfoFinish(result AsyncResult) (FileInfo, error)
}

// fileInputStream implements the FileInputStream class.
type fileInputStream struct {
	InputStream
	Seekable
}

var _ FileInputStream = (*fileInputStream)(nil)

// WrapFileInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileInputStream(obj *externglib.Object) FileInputStream {
	return fileInputStream{
		InputStream: WrapInputStream(obj),
		Seekable:    WrapSeekable(obj),
	}
}

func marshalFileInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileInputStream(obj), nil
}

func (s fileInputStream) QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var _arg0 *C.GFileInputStream // out
	var _arg1 *C.char             // out
	var _arg2 *C.GCancellable     // out
	var _cret *C.GFileInfo        // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_input_stream_query_info(_arg0, _arg1, _arg2, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

func (s fileInputStream) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var _arg0 *C.GFileInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.GFileInfo        // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_file_input_stream_query_info_finish(_arg0, _arg1, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

// FileMonitor monitors a file or directory for changes.
//
// To obtain a Monitor for a file or directory, use g_file_monitor(),
// g_file_monitor_file(), or g_file_monitor_directory().
//
// To get informed about changes to the file or directory you are monitoring,
// connect to the Monitor::changed signal. The signal will be emitted in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that the monitor was created in (though if the global default main
// context is blocked, this may cause notifications to be blocked even if the
// thread-default context is still running).
type FileMonitor interface {
	gextras.Objector

	// Cancel cancels a file monitor.
	Cancel() bool
	// EmitEvent emits the Monitor::changed signal if a change has taken place.
	// Should be called from file monitor implementations only.
	//
	// Implementations are responsible to call this method from the
	// [thread-default main context][g-main-context-push-thread-default] of the
	// thread that the monitor was created in.
	EmitEvent(child File, otherFile File, eventType FileMonitorEvent)
	// IsCancelled returns whether the monitor is canceled.
	IsCancelled() bool
	// SetRateLimit sets the rate limit to which the @monitor will report
	// consecutive change events to the same file.
	SetRateLimit(limitMsecs int)
}

// fileMonitor implements the FileMonitor class.
type fileMonitor struct {
	gextras.Objector
}

var _ FileMonitor = (*fileMonitor)(nil)

// WrapFileMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileMonitor(obj *externglib.Object) FileMonitor {
	return fileMonitor{
		Objector: obj,
	}
}

func marshalFileMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileMonitor(obj), nil
}

func (m fileMonitor) Cancel() bool {
	var _arg0 *C.GFileMonitor // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.g_file_monitor_cancel(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m fileMonitor) EmitEvent(child File, otherFile File, eventType FileMonitorEvent) {
	var _arg0 *C.GFileMonitor     // out
	var _arg1 *C.GFile            // out
	var _arg2 *C.GFile            // out
	var _arg3 C.GFileMonitorEvent // out

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GFile)(unsafe.Pointer(otherFile.Native()))
	_arg3 = (C.GFileMonitorEvent)(eventType)

	C.g_file_monitor_emit_event(_arg0, _arg1, _arg2, _arg3)
}

func (m fileMonitor) IsCancelled() bool {
	var _arg0 *C.GFileMonitor // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.g_file_monitor_is_cancelled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m fileMonitor) SetRateLimit(limitMsecs int) {
	var _arg0 *C.GFileMonitor // out
	var _arg1 C.gint          // out

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(limitMsecs)

	C.g_file_monitor_set_rate_limit(_arg0, _arg1)
}

// FileOutputStream: GFileOutputStream provides output streams that write their
// content to a file.
//
// GFileOutputStream implements #GSeekable, which allows the output stream to
// jump to arbitrary positions in the file and to truncate the file, provided
// the filesystem of the file supports these operations.
//
// To find the position of a file output stream, use g_seekable_tell(). To find
// out if a file output stream supports seeking, use g_seekable_can_seek().To
// position a file output stream, use g_seekable_seek(). To find out if a file
// output stream supports truncating, use g_seekable_can_truncate(). To truncate
// a file output stream, use g_seekable_truncate().
type FileOutputStream interface {
	OutputStream
	Seekable

	// Etag gets the entity tag for the file when it has been written. This must
	// be called after the stream has been written and closed, as the etag can
	// change while writing.
	Etag() string
	// QueryInfo queries a file output stream for the given @attributes. This
	// function blocks while querying the stream. For the asynchronous version
	// of this function, see g_file_output_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally, and
	// any other operations on the stream will fail with G_IO_ERROR_PENDING.
	//
	// Can fail if the stream was already closed (with @error being set to
	// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
	// stream's interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED).
	// In all cases of failure, nil will be returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and nil will
	// be returned.
	QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// QueryInfoFinish finalizes the asynchronous query started by
	// g_file_output_stream_query_info_async().
	QueryInfoFinish(result AsyncResult) (FileInfo, error)
}

// fileOutputStream implements the FileOutputStream class.
type fileOutputStream struct {
	OutputStream
	Seekable
}

var _ FileOutputStream = (*fileOutputStream)(nil)

// WrapFileOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileOutputStream(obj *externglib.Object) FileOutputStream {
	return fileOutputStream{
		OutputStream: WrapOutputStream(obj),
		Seekable:     WrapSeekable(obj),
	}
}

func marshalFileOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileOutputStream(obj), nil
}

func (s fileOutputStream) Etag() string {
	var _arg0 *C.GFileOutputStream // out
	var _cret *C.char              // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_file_output_stream_get_etag(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (s fileOutputStream) QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var _arg0 *C.GFileOutputStream // out
	var _arg1 *C.char              // out
	var _arg2 *C.GCancellable      // out
	var _cret *C.GFileInfo         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_file_output_stream_query_info(_arg0, _arg1, _arg2, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

func (s fileOutputStream) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var _arg0 *C.GFileOutputStream // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileInfo         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_file_output_stream_query_info_finish(_arg0, _arg1, &_cerr)

	var _fileInfo FileInfo // out
	var _goerr error       // out

	_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fileInfo, _goerr
}

// FilenameCompleter completes partial file and directory names given a partial
// string by looking in the file system for clues. Can return a list of possible
// completion strings for widget implementations.
type FilenameCompleter interface {
	gextras.Objector

	// CompletionSuffix obtains a completion for @initial_text from @completer.
	CompletionSuffix(initialText string) string
	// Completions gets an array of completion strings for a given initial text.
	Completions(initialText string) []string
	// SetDirsOnly: if @dirs_only is true, @completer will only complete
	// directory names, and not file names.
	SetDirsOnly(dirsOnly bool)
}

// filenameCompleter implements the FilenameCompleter class.
type filenameCompleter struct {
	gextras.Objector
}

var _ FilenameCompleter = (*filenameCompleter)(nil)

// WrapFilenameCompleter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilenameCompleter(obj *externglib.Object) FilenameCompleter {
	return filenameCompleter{
		Objector: obj,
	}
}

func marshalFilenameCompleter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilenameCompleter(obj), nil
}

// NewFilenameCompleter creates a new filename completer.
func NewFilenameCompleter() FilenameCompleter {
	var _cret *C.GFilenameCompleter // in

	_cret = C.g_filename_completer_new()

	var _filenameCompleter FilenameCompleter // out

	_filenameCompleter = WrapFilenameCompleter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _filenameCompleter
}

func (c filenameCompleter) CompletionSuffix(initialText string) string {
	var _arg0 *C.GFilenameCompleter // out
	var _arg1 *C.char               // out
	var _cret *C.char               // in

	_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(initialText))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_completer_get_completion_suffix(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (c filenameCompleter) Completions(initialText string) []string {
	var _arg0 *C.GFilenameCompleter // out
	var _arg1 *C.char               // out
	var _cret **C.char

	_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(initialText))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_completer_get_completions(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (c filenameCompleter) SetDirsOnly(dirsOnly bool) {
	var _arg0 *C.GFilenameCompleter // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(c.Native()))
	if dirsOnly {
		_arg1 = C.TRUE
	}

	C.g_filename_completer_set_dirs_only(_arg0, _arg1)
}

// FilterInputStream: base class for input stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterInputStream interface {
	InputStream

	// BaseStream gets the base stream for the filter stream.
	BaseStream() InputStream
	// CloseBaseStream returns whether the base stream will be closed when
	// @stream is closed.
	CloseBaseStream() bool
	// SetCloseBaseStream sets whether the base stream will be closed when
	// @stream is closed.
	SetCloseBaseStream(closeBase bool)
}

// filterInputStream implements the FilterInputStream class.
type filterInputStream struct {
	InputStream
}

var _ FilterInputStream = (*filterInputStream)(nil)

// WrapFilterInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilterInputStream(obj *externglib.Object) FilterInputStream {
	return filterInputStream{
		InputStream: WrapInputStream(obj),
	}
}

func marshalFilterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilterInputStream(obj), nil
}

func (s filterInputStream) BaseStream() InputStream {
	var _arg0 *C.GFilterInputStream // out
	var _cret *C.GInputStream       // in

	_arg0 = (*C.GFilterInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_filter_input_stream_get_base_stream(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

	return _inputStream
}

func (s filterInputStream) CloseBaseStream() bool {
	var _arg0 *C.GFilterInputStream // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GFilterInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_filter_input_stream_get_close_base_stream(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s filterInputStream) SetCloseBaseStream(closeBase bool) {
	var _arg0 *C.GFilterInputStream // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GFilterInputStream)(unsafe.Pointer(s.Native()))
	if closeBase {
		_arg1 = C.TRUE
	}

	C.g_filter_input_stream_set_close_base_stream(_arg0, _arg1)
}

// FilterOutputStream: base class for output stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterOutputStream interface {
	OutputStream

	// BaseStream gets the base stream for the filter stream.
	BaseStream() OutputStream
	// CloseBaseStream returns whether the base stream will be closed when
	// @stream is closed.
	CloseBaseStream() bool
	// SetCloseBaseStream sets whether the base stream will be closed when
	// @stream is closed.
	SetCloseBaseStream(closeBase bool)
}

// filterOutputStream implements the FilterOutputStream class.
type filterOutputStream struct {
	OutputStream
}

var _ FilterOutputStream = (*filterOutputStream)(nil)

// WrapFilterOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilterOutputStream(obj *externglib.Object) FilterOutputStream {
	return filterOutputStream{
		OutputStream: WrapOutputStream(obj),
	}
}

func marshalFilterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilterOutputStream(obj), nil
}

func (s filterOutputStream) BaseStream() OutputStream {
	var _arg0 *C.GFilterOutputStream // out
	var _cret *C.GOutputStream       // in

	_arg0 = (*C.GFilterOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_filter_output_stream_get_base_stream(_arg0)

	var _outputStream OutputStream // out

	_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(OutputStream)

	return _outputStream
}

func (s filterOutputStream) CloseBaseStream() bool {
	var _arg0 *C.GFilterOutputStream // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GFilterOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_filter_output_stream_get_close_base_stream(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s filterOutputStream) SetCloseBaseStream(closeBase bool) {
	var _arg0 *C.GFilterOutputStream // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GFilterOutputStream)(unsafe.Pointer(s.Native()))
	if closeBase {
		_arg1 = C.TRUE
	}

	C.g_filter_output_stream_set_close_base_stream(_arg0, _arg1)
}

// IOStream: GIOStream represents an object that has both read and write
// streams. Generally the two streams act as separate input and output streams,
// but they share some common resources and state. For instance, for seekable
// streams, both streams may use the same position.
//
// Examples of OStream objects are Connection, which represents a two-way
// network connection; and IOStream, which represents a file handle opened in
// read-write mode.
//
// To do the actual reading and writing you need to get the substreams with
// g_io_stream_get_input_stream() and g_io_stream_get_output_stream().
//
// The OStream object owns the input and the output streams, not the other way
// around, so keeping the substreams alive will not keep the OStream object
// alive. If the OStream object is freed it will be closed, thus closing the
// substreams, so even if the substreams stay alive they will always return
// G_IO_ERROR_CLOSED for all operations.
//
// To close a stream use g_io_stream_close() which will close the common stream
// object and also the individual substreams. You can also close the substreams
// themselves. In most cases this only marks the substream as closed, so further
// I/O on it fails but common state in the OStream may still be open. However,
// some streams may support "half-closed" states where one direction of the
// stream is actually shut down.
//
// Operations on OStreams cannot be started while another operation on the
// OStream or its substreams is in progress. Specifically, an application can
// read from the Stream and write to the Stream simultaneously (either in
// separate threads, or as asynchronous operations in the same thread), but an
// application cannot start any OStream operation while there is a OStream,
// Stream or Stream operation in progress, and an application cant start any
// Stream or Stream operation while there is a OStream operation in progress.
//
// This is a product of individual stream operations being associated with a
// given Context (the thread-default context at the time the operation was
// started), rather than entire streams being associated with a single Context.
//
// GIO may run operations on OStreams from other (worker) threads, and this may
// be exposed to application code in the behaviour of wrapper streams, such as
// InputStream or Connection. With such wrapper APIs, application code may only
// run operations on the base (wrapped) stream when the wrapper stream is idle.
// Note that the semantics of such operations may not be well-defined due to the
// state the wrapper stream leaves the base stream in (though they are
// guaranteed not to crash).
type IOStream interface {
	gextras.Objector

	// ClearPending clears the pending flag on @stream.
	ClearPending()
	// Close closes the stream, releasing resources related to it. This will
	// also close the individual input and output streams, if they are not
	// already closed.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Closing a stream will automatically flush any outstanding buffers in the
	// stream.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user, otherwise there
	// might be a loss of data as all data might not be written.
	//
	// If @cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but some streams
	// can use a faster close that doesn't block to e.g. check errors.
	//
	// The default implementation of this method just calls close on the
	// individual input/output streams.
	Close(cancellable Cancellable) error
	// CloseFinish closes a stream.
	CloseFinish(result AsyncResult) error
	// InputStream gets the input stream for this object. This is used for
	// reading.
	InputStream() InputStream
	// OutputStream gets the output stream for this object. This is used for
	// writing.
	OutputStream() OutputStream
	// HasPending checks if a stream has pending actions.
	HasPending() bool
	// IsClosed checks if a stream is closed.
	IsClosed() bool
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	SetPending() error
}

// ioStream implements the IOStream class.
type ioStream struct {
	gextras.Objector
}

var _ IOStream = (*ioStream)(nil)

// WrapIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapIOStream(obj *externglib.Object) IOStream {
	return ioStream{
		Objector: obj,
	}
}

func marshalIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIOStream(obj), nil
}

func (s ioStream) ClearPending() {
	var _arg0 *C.GIOStream // out

	_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

	C.g_io_stream_clear_pending(_arg0)
}

func (s ioStream) Close(cancellable Cancellable) error {
	var _arg0 *C.GIOStream    // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_io_stream_close(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s ioStream) CloseFinish(result AsyncResult) error {
	var _arg0 *C.GIOStream    // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_io_stream_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s ioStream) InputStream() InputStream {
	var _arg0 *C.GIOStream    // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_io_stream_get_input_stream(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

	return _inputStream
}

func (s ioStream) OutputStream() OutputStream {
	var _arg0 *C.GIOStream     // out
	var _cret *C.GOutputStream // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_io_stream_get_output_stream(_arg0)

	var _outputStream OutputStream // out

	_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(OutputStream)

	return _outputStream
}

func (s ioStream) HasPending() bool {
	var _arg0 *C.GIOStream // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_io_stream_has_pending(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s ioStream) IsClosed() bool {
	var _arg0 *C.GIOStream // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_io_stream_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s ioStream) SetPending() error {
	var _arg0 *C.GIOStream // out
	var _cerr *C.GError    // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

	C.g_io_stream_set_pending(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// InetAddress represents an IPv4 or IPv6 internet address. Use
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to look up
// the Address for a hostname. Use g_resolver_lookup_by_address() or
// g_resolver_lookup_by_address_async() to look up the hostname for a Address.
//
// To actually connect to a remote host, you will need a SocketAddress (which
// includes a Address as well as a port number).
type InetAddress interface {
	gextras.Objector

	// Equal checks if two Address instances are equal, e.g. the same address.
	Equal(otherAddress InetAddress) bool
	// Family gets @address's family
	Family() SocketFamily
	// IsAny tests whether @address is the "any" address for its family.
	IsAny() bool
	// IsLinkLocal tests whether @address is a link-local address (that is, if
	// it identifies a host on a local network that is not connected to the
	// Internet).
	IsLinkLocal() bool
	// IsLoopback tests whether @address is the loopback address for its family.
	IsLoopback() bool
	// IsMcGlobal tests whether @address is a global multicast address.
	IsMcGlobal() bool
	// IsMcLinkLocal tests whether @address is a link-local multicast address.
	IsMcLinkLocal() bool
	// IsMcNodeLocal tests whether @address is a node-local multicast address.
	IsMcNodeLocal() bool
	// IsMcOrgLocal tests whether @address is an organization-local multicast
	// address.
	IsMcOrgLocal() bool
	// IsMcSiteLocal tests whether @address is a site-local multicast address.
	IsMcSiteLocal() bool
	// IsMulticast tests whether @address is a multicast address.
	IsMulticast() bool
	// IsSiteLocal tests whether @address is a site-local address such as
	// 10.0.0.1 (that is, the address identifies a host on a local network that
	// can not be reached directly from the Internet, but which may have
	// outgoing Internet connectivity via a NAT or firewall).
	IsSiteLocal() bool
	// NativeSize gets the size of the native raw binary address for @address.
	// This is the size of the data that you get from g_inet_address_to_bytes().
	NativeSize() uint
	// String converts @address to string form.
	String() string
}

// inetAddress implements the InetAddress class.
type inetAddress struct {
	gextras.Objector
}

var _ InetAddress = (*inetAddress)(nil)

// WrapInetAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetAddress(obj *externglib.Object) InetAddress {
	return inetAddress{
		Objector: obj,
	}
}

func marshalInetAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetAddress(obj), nil
}

// NewInetAddressAny creates a Address for the "any" address (unassigned/"don't
// care") for @family.
func NewInetAddressAny(family SocketFamily) InetAddress {
	var _arg1 C.GSocketFamily // out
	var _cret *C.GInetAddress // in

	_arg1 = (C.GSocketFamily)(family)

	_cret = C.g_inet_address_new_any(_arg1)

	var _inetAddress InetAddress // out

	_inetAddress = WrapInetAddress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _inetAddress
}

// NewInetAddressFromString parses @string as an IP address and creates a new
// Address.
func NewInetAddressFromString(_string string) InetAddress {
	var _arg1 *C.gchar        // out
	var _cret *C.GInetAddress // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_inet_address_new_from_string(_arg1)

	var _inetAddress InetAddress // out

	_inetAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InetAddress)

	return _inetAddress
}

// NewInetAddressLoopback creates a Address for the loopback address for
// @family.
func NewInetAddressLoopback(family SocketFamily) InetAddress {
	var _arg1 C.GSocketFamily // out
	var _cret *C.GInetAddress // in

	_arg1 = (C.GSocketFamily)(family)

	_cret = C.g_inet_address_new_loopback(_arg1)

	var _inetAddress InetAddress // out

	_inetAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InetAddress)

	return _inetAddress
}

func (a inetAddress) Equal(otherAddress InetAddress) bool {
	var _arg0 *C.GInetAddress // out
	var _arg1 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(otherAddress.Native()))

	_cret = C.g_inet_address_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) Family() SocketFamily {
	var _arg0 *C.GInetAddress // out
	var _cret C.GSocketFamily // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_family(_arg0)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

func (a inetAddress) IsAny() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_any(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) IsLinkLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_link_local(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) IsLoopback() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_loopback(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) IsMcGlobal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_mc_global(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) IsMcLinkLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_mc_link_local(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) IsMcNodeLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_mc_node_local(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) IsMcOrgLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_mc_org_local(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) IsMcSiteLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_mc_site_local(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) IsMulticast() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_multicast(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) IsSiteLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_is_site_local(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a inetAddress) NativeSize() uint {
	var _arg0 *C.GInetAddress // out
	var _cret C.gsize         // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_get_native_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (a inetAddress) String() string {
	var _arg0 *C.GInetAddress // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_address_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// InetAddressMask represents a range of IPv4 or IPv6 addresses described by a
// base address and a length indicating how many bits of the base address are
// relevant for matching purposes. These are often given in string form. Eg,
// "10.0.0.0/8", or "fe80::/10".
type InetAddressMask interface {
	gextras.Objector
	Initable

	// Equal tests if @mask and @mask2 are the same mask.
	Equal(mask2 InetAddressMask) bool
	// Address gets @mask's base address
	Address() InetAddress
	// Family gets the Family of @mask's address
	Family() SocketFamily
	// Length gets @mask's length
	Length() uint
	// Matches tests if @address falls within the range described by @mask.
	Matches(address InetAddress) bool
	// String converts @mask back to its corresponding string form.
	String() string
}

// inetAddressMask implements the InetAddressMask class.
type inetAddressMask struct {
	gextras.Objector
	Initable
}

var _ InetAddressMask = (*inetAddressMask)(nil)

// WrapInetAddressMask wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetAddressMask(obj *externglib.Object) InetAddressMask {
	return inetAddressMask{
		Objector: obj,
		Initable: WrapInitable(obj),
	}
}

func marshalInetAddressMask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetAddressMask(obj), nil
}

// NewInetAddressMask creates a new AddressMask representing all addresses whose
// first @length bits match @addr.
func NewInetAddressMask(addr InetAddress, length uint) (InetAddressMask, error) {
	var _arg1 *C.GInetAddress     // out
	var _arg2 C.guint             // out
	var _cret *C.GInetAddressMask // in
	var _cerr *C.GError           // in

	_arg1 = (*C.GInetAddress)(unsafe.Pointer(addr.Native()))
	_arg2 = (C.guint)(length)

	_cret = C.g_inet_address_mask_new(_arg1, _arg2, &_cerr)

	var _inetAddressMask InetAddressMask // out
	var _goerr error                     // out

	_inetAddressMask = WrapInetAddressMask(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _inetAddressMask, _goerr
}

// NewInetAddressMaskFromString parses @mask_string as an IP address and
// (optional) length, and creates a new AddressMask. The length, if present, is
// delimited by a "/". If it is not present, then the length is assumed to be
// the full length of the address.
func NewInetAddressMaskFromString(maskString string) (InetAddressMask, error) {
	var _arg1 *C.gchar            // out
	var _cret *C.GInetAddressMask // in
	var _cerr *C.GError           // in

	_arg1 = (*C.gchar)(C.CString(maskString))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_inet_address_mask_new_from_string(_arg1, &_cerr)

	var _inetAddressMask InetAddressMask // out
	var _goerr error                     // out

	_inetAddressMask = WrapInetAddressMask(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _inetAddressMask, _goerr
}

func (m inetAddressMask) Equal(mask2 InetAddressMask) bool {
	var _arg0 *C.GInetAddressMask // out
	var _arg1 *C.GInetAddressMask // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GInetAddressMask)(unsafe.Pointer(mask2.Native()))

	_cret = C.g_inet_address_mask_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m inetAddressMask) Address() InetAddress {
	var _arg0 *C.GInetAddressMask // out
	var _cret *C.GInetAddress     // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))

	_cret = C.g_inet_address_mask_get_address(_arg0)

	var _inetAddress InetAddress // out

	_inetAddress = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InetAddress)

	return _inetAddress
}

func (m inetAddressMask) Family() SocketFamily {
	var _arg0 *C.GInetAddressMask // out
	var _cret C.GSocketFamily     // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))

	_cret = C.g_inet_address_mask_get_family(_arg0)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

func (m inetAddressMask) Length() uint {
	var _arg0 *C.GInetAddressMask // out
	var _cret C.guint             // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))

	_cret = C.g_inet_address_mask_get_length(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (m inetAddressMask) Matches(address InetAddress) bool {
	var _arg0 *C.GInetAddressMask // out
	var _arg1 *C.GInetAddress     // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(address.Native()))

	_cret = C.g_inet_address_mask_matches(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m inetAddressMask) String() string {
	var _arg0 *C.GInetAddressMask // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))

	_cret = C.g_inet_address_mask_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// InetSocketAddress: an IPv4 or IPv6 socket address; that is, the combination
// of a Address and a port number.
type InetSocketAddress interface {
	SocketAddress
	SocketConnectable

	// Address gets @address's Address.
	Address() InetAddress
	// Flowinfo gets the `sin6_flowinfo` field from @address, which must be an
	// IPv6 address.
	Flowinfo() uint32
	// Port gets @address's port.
	Port() uint16
	// ScopeID gets the `sin6_scope_id` field from @address, which must be an
	// IPv6 address.
	ScopeID() uint32
}

// inetSocketAddress implements the InetSocketAddress class.
type inetSocketAddress struct {
	SocketAddress
	SocketConnectable
}

var _ InetSocketAddress = (*inetSocketAddress)(nil)

// WrapInetSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetSocketAddress(obj *externglib.Object) InetSocketAddress {
	return inetSocketAddress{
		SocketAddress:     WrapSocketAddress(obj),
		SocketConnectable: WrapSocketConnectable(obj),
	}
}

func marshalInetSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetSocketAddress(obj), nil
}

// NewInetSocketAddress creates a new SocketAddress for @address and @port.
func NewInetSocketAddress(address InetAddress, port uint16) InetSocketAddress {
	var _arg1 *C.GInetAddress   // out
	var _arg2 C.guint16         // out
	var _cret *C.GSocketAddress // in

	_arg1 = (*C.GInetAddress)(unsafe.Pointer(address.Native()))
	_arg2 = (C.guint16)(port)

	_cret = C.g_inet_socket_address_new(_arg1, _arg2)

	var _inetSocketAddress InetSocketAddress // out

	_inetSocketAddress = WrapInetSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _inetSocketAddress
}

// NewInetSocketAddressFromString creates a new SocketAddress for @address and
// @port.
//
// If @address is an IPv6 address, it can also contain a scope ID (separated
// from the address by a `%`).
func NewInetSocketAddressFromString(address string, port uint) InetSocketAddress {
	var _arg1 *C.char           // out
	var _arg2 C.guint           // out
	var _cret *C.GSocketAddress // in

	_arg1 = (*C.char)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(port)

	_cret = C.g_inet_socket_address_new_from_string(_arg1, _arg2)

	var _inetSocketAddress InetSocketAddress // out

	_inetSocketAddress = WrapInetSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _inetSocketAddress
}

func (a inetSocketAddress) Address() InetAddress {
	var _arg0 *C.GInetSocketAddress // out
	var _cret *C.GInetAddress       // in

	_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_socket_address_get_address(_arg0)

	var _inetAddress InetAddress // out

	_inetAddress = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InetAddress)

	return _inetAddress
}

func (a inetSocketAddress) Flowinfo() uint32 {
	var _arg0 *C.GInetSocketAddress // out
	var _cret C.guint32             // in

	_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_socket_address_get_flowinfo(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

func (a inetSocketAddress) Port() uint16 {
	var _arg0 *C.GInetSocketAddress // out
	var _cret C.guint16             // in

	_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_socket_address_get_port(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

func (a inetSocketAddress) ScopeID() uint32 {
	var _arg0 *C.GInetSocketAddress // out
	var _cret C.guint32             // in

	_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_inet_socket_address_get_scope_id(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// InputStream has functions to read from a stream (g_input_stream_read()), to
// close a stream (g_input_stream_close()) and to skip some content
// (g_input_stream_skip()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type InputStream interface {
	gextras.Objector

	// ClearPending clears the pending flag on @stream.
	ClearPending()
	// Close closes the stream, releasing resources related to it.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but some streams
	// can use a faster close that doesn't block to e.g. check errors.
	Close(cancellable Cancellable) error
	// CloseFinish finishes closing a stream asynchronously, started from
	// g_input_stream_close_async().
	CloseFinish(result AsyncResult) error
	// HasPending checks if an input stream has pending actions.
	HasPending() bool
	// IsClosed checks if an input stream is closed.
	IsClosed() bool
	// Read tries to read @count bytes from the stream into the buffer starting
	// at @buffer. Will block during this read.
	//
	// If count is zero returns zero and does nothing. A value of @count larger
	// than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes read into the buffer is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. near the end of a file. Zero is returned on end of file (or
	// if @count is zero), but never otherwise.
	//
	// The returned @buffer is not a nul-terminated string, it can contain nul
	// bytes at any position, and this function doesn't nul-terminate the
	// @buffer.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	Read(cancellable Cancellable) ([]byte, int, error)
	// ReadAll tries to read @count bytes from the stream into the buffer
	// starting at @buffer. Will block during this read.
	//
	// This function is similar to g_input_stream_read(), except it tries to
	// read as many bytes as requested, only stopping on an error or end of
	// stream.
	//
	// On a successful read of @count bytes, or if we reached the end of the
	// stream, true is returned, and @bytes_read is set to the number of bytes
	// read into @buffer.
	//
	// If there is an error during the operation false is returned and @error is
	// set to indicate the error status.
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_read will be set to the number of bytes that were successfully
	// read before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_input_stream_read().
	ReadAll(cancellable Cancellable) ([]byte, uint, error)
	// ReadAllFinish finishes an asynchronous stream read operation started with
	// g_input_stream_read_all_async().
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_read will be set to the number of bytes that were successfully
	// read before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_input_stream_read_async().
	ReadAllFinish(result AsyncResult) (uint, error)
	// ReadFinish finishes an asynchronous stream read operation.
	ReadFinish(result AsyncResult) (int, error)
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	SetPending() error
	// Skip tries to skip @count bytes from the stream. Will block during the
	// operation.
	//
	// This is identical to g_input_stream_read(), from a behaviour standpoint,
	// but the bytes that are skipped are not returned to the user. Some streams
	// have an implementation that is more efficient than reading the data.
	//
	// This function is optional for inherited classes, as the default
	// implementation emulates it using read.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	Skip(count uint, cancellable Cancellable) (int, error)
	// SkipFinish finishes a stream skip operation.
	SkipFinish(result AsyncResult) (int, error)
}

// inputStream implements the InputStream class.
type inputStream struct {
	gextras.Objector
}

var _ InputStream = (*inputStream)(nil)

// WrapInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapInputStream(obj *externglib.Object) InputStream {
	return inputStream{
		Objector: obj,
	}
}

func marshalInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInputStream(obj), nil
}

func (s inputStream) ClearPending() {
	var _arg0 *C.GInputStream // out

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

	C.g_input_stream_clear_pending(_arg0)
}

func (s inputStream) Close(cancellable Cancellable) error {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_input_stream_close(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s inputStream) CloseFinish(result AsyncResult) error {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_input_stream_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s inputStream) HasPending() bool {
	var _arg0 *C.GInputStream // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_input_stream_has_pending(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s inputStream) IsClosed() bool {
	var _arg0 *C.GInputStream // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_input_stream_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s inputStream) Read(cancellable Cancellable) ([]byte, int, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 C.void
	var _arg2 C.gsize         // in
	var _arg3 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_input_stream_read(_arg0, &_arg1, &_arg2, _arg3, &_cerr)

	var _buffer []byte
	var _gssize int  // out
	var _goerr error // out

	{
		src := unsafe.Slice(_arg1, _arg2)
		_buffer = make([]byte, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_buffer[i] = (byte)(src[i])
		}
	}
	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _buffer, _gssize, _goerr
}

func (s inputStream) ReadAll(cancellable Cancellable) ([]byte, uint, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 C.void
	var _arg2 C.gsize         // in
	var _arg3 C.gsize         // in
	var _arg4 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_input_stream_read_all(_arg0, &_arg1, &_arg2, &_arg3, _arg4, &_cerr)

	var _buffer []byte
	var _bytesRead uint // out
	var _goerr error    // out

	{
		src := unsafe.Slice(_arg1, _arg2)
		_buffer = make([]byte, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_buffer[i] = (byte)(src[i])
		}
	}
	_bytesRead = (uint)(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _buffer, _bytesRead, _goerr
}

func (s inputStream) ReadAllFinish(result AsyncResult) (uint, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.gsize         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_input_stream_read_all_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _bytesRead uint // out
	var _goerr error    // out

	_bytesRead = (uint)(_arg2)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesRead, _goerr
}

func (s inputStream) ReadFinish(result AsyncResult) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_input_stream_read_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s inputStream) SetPending() error {
	var _arg0 *C.GInputStream // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

	C.g_input_stream_set_pending(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s inputStream) Skip(count uint, cancellable Cancellable) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 C.gsize         // out
	var _arg2 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gsize)(count)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_input_stream_skip(_arg0, _arg1, _arg2, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s inputStream) SkipFinish(result AsyncResult) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_input_stream_skip_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

// ListStore is a simple implementation of Model that stores all items in
// memory.
//
// It provides insertions, deletions, and lookups in logarithmic time with a
// fast path for the common case of iterating the list linearly.
type ListStore interface {
	gextras.Objector
	ListModel

	// Append appends @item to @store. @item must be of type Store:item-type.
	//
	// This function takes a ref on @item.
	//
	// Use g_list_store_splice() to append multiple items at the same time
	// efficiently.
	Append(item gextras.Objector)
	// Find looks up the given @item in the list store by looping over the items
	// until the first occurrence of @item. If @item was not found, then
	// @position will not be set, and this method will return false.
	//
	// If you need to compare the two items with a custom comparison function,
	// use g_list_store_find_with_equal_func() with a custom Func instead.
	Find(item gextras.Objector) (uint, bool)
	// Insert inserts @item into @store at @position. @item must be of type
	// Store:item-type or derived from it. @position must be smaller than the
	// length of the list, or equal to it to append.
	//
	// This function takes a ref on @item.
	//
	// Use g_list_store_splice() to insert multiple items at the same time
	// efficiently.
	Insert(position uint, item gextras.Objector)
	// Remove removes the item from @store that is at @position. @position must
	// be smaller than the current length of the list.
	//
	// Use g_list_store_splice() to remove multiple items at the same time
	// efficiently.
	Remove(position uint)
	// RemoveAll removes all items from @store.
	RemoveAll()
	// Splice changes @store by removing @n_removals items and adding
	// @n_additions items to it. @additions must contain @n_additions items of
	// type Store:item-type. nil is not permitted.
	//
	// This function is more efficient than g_list_store_insert() and
	// g_list_store_remove(), because it only emits Model::items-changed once
	// for the change.
	//
	// This function takes a ref on each item in @additions.
	//
	// The parameters @position and @n_removals must be correct (ie: @position +
	// @n_removals must be less than or equal to the length of the list at the
	// time this function is called).
	Splice(position uint, nRemovals uint, additions []gextras.Objector)
}

// listStore implements the ListStore class.
type listStore struct {
	gextras.Objector
	ListModel
}

var _ ListStore = (*listStore)(nil)

// WrapListStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapListStore(obj *externglib.Object) ListStore {
	return listStore{
		Objector:  obj,
		ListModel: WrapListModel(obj),
	}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListStore(obj), nil
}

// NewListStore creates a new Store with items of type @item_type. @item_type
// must be a subclass of #GObject.
func NewListStore(itemType externglib.Type) ListStore {
	var _arg1 C.GType       // out
	var _cret *C.GListStore // in

	_arg1 = C.GType(itemType)

	_cret = C.g_list_store_new(_arg1)

	var _listStore ListStore // out

	_listStore = WrapListStore(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _listStore
}

func (s listStore) Append(item gextras.Objector) {
	var _arg0 *C.GListStore // out
	var _arg1 C.gpointer    // out

	_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(item.Native()))

	C.g_list_store_append(_arg0, _arg1)
}

func (s listStore) Find(item gextras.Objector) (uint, bool) {
	var _arg0 *C.GListStore // out
	var _arg1 C.gpointer    // out
	var _arg2 C.guint       // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(item.Native()))

	_cret = C.g_list_store_find(_arg0, _arg1, &_arg2)

	var _position uint // out
	var _ok bool       // out

	_position = (uint)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _position, _ok
}

func (s listStore) Insert(position uint, item gextras.Objector) {
	var _arg0 *C.GListStore // out
	var _arg1 C.guint       // out
	var _arg2 C.gpointer    // out

	_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (*C.GObject)(unsafe.Pointer(item.Native()))

	C.g_list_store_insert(_arg0, _arg1, _arg2)
}

func (s listStore) Remove(position uint) {
	var _arg0 *C.GListStore // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)

	C.g_list_store_remove(_arg0, _arg1)
}

func (s listStore) RemoveAll() {
	var _arg0 *C.GListStore // out

	_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))

	C.g_list_store_remove_all(_arg0)
}

func (s listStore) Splice(position uint, nRemovals uint, additions []gextras.Objector) {
	var _arg0 *C.GListStore // out
	var _arg1 C.guint       // out
	var _arg2 C.guint       // out
	var _arg3 *C.gpointer
	var _arg4 C.guint

	_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.guint)(nRemovals)
	_arg4 = C.guint(len(additions))
	_arg3 = (*C.gpointer)(C.malloc(C.ulong(len(additions)) * C.ulong(C.sizeof_GObject)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(additions))
		for i := range additions {
			out[i] = (*C.GObject)(unsafe.Pointer(additions[i].Native()))
		}
	}

	C.g_list_store_splice(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// MemoryInputStream is a class for using arbitrary memory chunks as input for
// GIO streaming input operations.
//
// As of GLib 2.34, InputStream implements InputStream.
type MemoryInputStream interface {
	InputStream
	PollableInputStream
	Seekable
}

// memoryInputStream implements the MemoryInputStream class.
type memoryInputStream struct {
	InputStream
	PollableInputStream
	Seekable
}

var _ MemoryInputStream = (*memoryInputStream)(nil)

// WrapMemoryInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapMemoryInputStream(obj *externglib.Object) MemoryInputStream {
	return memoryInputStream{
		InputStream:         WrapInputStream(obj),
		PollableInputStream: WrapPollableInputStream(obj),
		Seekable:            WrapSeekable(obj),
	}
}

func marshalMemoryInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMemoryInputStream(obj), nil
}

// NewMemoryInputStream creates a new empty InputStream.
func NewMemoryInputStream() MemoryInputStream {
	var _cret *C.GInputStream // in

	_cret = C.g_memory_input_stream_new()

	var _memoryInputStream MemoryInputStream // out

	_memoryInputStream = WrapMemoryInputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _memoryInputStream
}

// MemoryOutputStream is a class for using arbitrary memory chunks as output for
// GIO streaming output operations.
//
// As of GLib 2.34, OutputStream trivially implements OutputStream: it always
// polls as ready.
type MemoryOutputStream interface {
	OutputStream
	PollableOutputStream
	Seekable

	// DataSize returns the number of bytes from the start up to including the
	// last byte written in the stream that has not been truncated away.
	DataSize() uint
	// Size gets the size of the currently allocated data area (available from
	// g_memory_output_stream_get_data()).
	//
	// You probably don't want to use this function on resizable streams. See
	// g_memory_output_stream_get_data_size() instead. For resizable streams the
	// size returned by this function is an implementation detail and may be
	// change at any time in response to operations on the stream.
	//
	// If the stream is fixed-sized (ie: no realloc was passed to
	// g_memory_output_stream_new()) then this is the maximum size of the stream
	// and further writes will return G_IO_ERROR_NO_SPACE.
	//
	// In any case, if you want the number of bytes currently written to the
	// stream, use g_memory_output_stream_get_data_size().
	Size() uint
}

// memoryOutputStream implements the MemoryOutputStream class.
type memoryOutputStream struct {
	OutputStream
	PollableOutputStream
	Seekable
}

var _ MemoryOutputStream = (*memoryOutputStream)(nil)

// WrapMemoryOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapMemoryOutputStream(obj *externglib.Object) MemoryOutputStream {
	return memoryOutputStream{
		OutputStream:         WrapOutputStream(obj),
		PollableOutputStream: WrapPollableOutputStream(obj),
		Seekable:             WrapSeekable(obj),
	}
}

func marshalMemoryOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMemoryOutputStream(obj), nil
}

// NewMemoryOutputStreamResizable creates a new OutputStream, using g_realloc()
// and g_free() for memory allocation.
func NewMemoryOutputStreamResizable() MemoryOutputStream {
	var _cret *C.GOutputStream // in

	_cret = C.g_memory_output_stream_new_resizable()

	var _memoryOutputStream MemoryOutputStream // out

	_memoryOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MemoryOutputStream)

	return _memoryOutputStream
}

func (o memoryOutputStream) DataSize() uint {
	var _arg0 *C.GMemoryOutputStream // out
	var _cret C.gsize                // in

	_arg0 = (*C.GMemoryOutputStream)(unsafe.Pointer(o.Native()))

	_cret = C.g_memory_output_stream_get_data_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (o memoryOutputStream) Size() uint {
	var _arg0 *C.GMemoryOutputStream // out
	var _cret C.gsize                // in

	_arg0 = (*C.GMemoryOutputStream)(unsafe.Pointer(o.Native()))

	_cret = C.g_memory_output_stream_get_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu interface {
	MenuModel

	// Append: convenience function for appending a normal menu item to the end
	// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
	// flexible alternative.
	Append(label string, detailedAction string)
	// AppendItem appends @item to the end of @menu.
	//
	// See g_menu_insert_item() for more information.
	AppendItem(item MenuItem)
	// AppendSection: convenience function for appending a section menu item to
	// the end of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSection(label string, section MenuModel)
	// AppendSubmenu: convenience function for appending a submenu menu item to
	// the end of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSubmenu(label string, submenu MenuModel)
	// Freeze marks @menu as frozen.
	//
	// After the menu is frozen, it is an error to attempt to make any changes
	// to it. In effect this means that the #GMenu API must no longer be used.
	//
	// This function causes g_menu_model_is_mutable() to begin returning false,
	// which has some positive performance implications.
	Freeze()
	// Insert: convenience function for inserting a normal menu item into @menu.
	// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
	// alternative.
	Insert(position int, label string, detailedAction string)
	// InsertItem inserts @item into @menu.
	//
	// The "insertion" is actually done by copying all of the attribute and link
	// values of @item and using them to form a new item within @menu. As such,
	// @item itself is not really inserted, but rather, a menu item that is
	// exactly the same as the one presently described by @item.
	//
	// This means that @item is essentially useless after the insertion occurs.
	// Any changes you make to it are ignored unless it is inserted again (at
	// which point its updated values will be copied).
	//
	// You should probably just free @item once you're done.
	//
	// There are many convenience functions to take care of common cases. See
	// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as
	// well as "prepend" and "append" variants of each of these functions.
	InsertItem(position int, item MenuItem)
	// InsertSection: convenience function for inserting a section menu item
	// into @menu. Combine g_menu_item_new_section() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSection(position int, label string, section MenuModel)
	// InsertSubmenu: convenience function for inserting a submenu menu item
	// into @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSubmenu(position int, label string, submenu MenuModel)
	// Prepend: convenience function for prepending a normal menu item to the
	// start of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a
	// more flexible alternative.
	Prepend(label string, detailedAction string)
	// PrependItem prepends @item to the start of @menu.
	//
	// See g_menu_insert_item() for more information.
	PrependItem(item MenuItem)
	// PrependSection: convenience function for prepending a section menu item
	// to the start of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSection(label string, section MenuModel)
	// PrependSubmenu: convenience function for prepending a submenu menu item
	// to the start of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSubmenu(label string, submenu MenuModel)
	// Remove removes an item from the menu.
	//
	// @position gives the index of the item to remove.
	//
	// It is an error if position is not in range the range from 0 to one less
	// than the number of items in the menu.
	//
	// It is not possible to remove items by identity since items are added to
	// the menu simply by copying their links and attributes (ie: identity of
	// the item itself is not preserved).
	Remove(position int)
	// RemoveAll removes all items in the menu.
	RemoveAll()
}

// menu implements the Menu class.
type menu struct {
	MenuModel
}

var _ Menu = (*menu)(nil)

// WrapMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenu(obj *externglib.Object) Menu {
	return menu{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenu(obj), nil
}

// NewMenu creates a new #GMenu.
//
// The new menu has no items.
func NewMenu() Menu {
	var _cret *C.GMenu // in

	_cret = C.g_menu_new()

	var _menu Menu // out

	_menu = WrapMenu(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menu
}

func (m menu) Append(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_append(_arg0, _arg1, _arg2)
}

func (m menu) AppendItem(item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_append_item(_arg0, _arg1)
}

func (m menu) AppendSection(label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_append_section(_arg0, _arg1, _arg2)
}

func (m menu) AppendSubmenu(label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_append_submenu(_arg0, _arg1, _arg2)
}

func (m menu) Freeze() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_freeze(_arg0)
}

func (m menu) Insert(position int, label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_menu_insert(_arg0, _arg1, _arg2, _arg3)
}

func (m menu) InsertItem(position int, item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 C.gint       // out
	var _arg2 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(position)
	_arg2 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_insert_item(_arg0, _arg1, _arg2)
}

func (m menu) InsertSection(position int, label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_insert_section(_arg0, _arg1, _arg2, _arg3)
}

func (m menu) InsertSubmenu(position int, label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_insert_submenu(_arg0, _arg1, _arg2, _arg3)
}

func (m menu) Prepend(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_prepend(_arg0, _arg1, _arg2)
}

func (m menu) PrependItem(item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_prepend_item(_arg0, _arg1)
}

func (m menu) PrependSection(label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_prepend_section(_arg0, _arg1, _arg2)
}

func (m menu) PrependSubmenu(label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_prepend_submenu(_arg0, _arg1, _arg2)
}

func (m menu) Remove(position int) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(position)

	C.g_menu_remove(_arg0, _arg1)
}

func (m menu) RemoveAll() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_remove_all(_arg0)
}

// MenuAttributeIter is an opaque structure type. You must access it using the
// functions below.
type MenuAttributeIter interface {
	gextras.Objector

	// Name gets the name of the attribute at the current iterator position, as
	// a string.
	//
	// The iterator is not advanced.
	Name() string
	// GetNext: this function combines g_menu_attribute_iter_next() with
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) attribute. If
	// that fails, then false is returned and there are no other effects.
	//
	// If successful, @name and @value are set to the name and value of the
	// attribute that has just been advanced to. At this point,
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value()
	// will return the same values again.
	//
	// The value returned in @name remains valid for as long as the iterator
	// remains at the current position. The value returned in @value must be
	// unreffed using g_variant_unref() when it is no longer in use.
	GetNext() (string, *glib.Variant, bool)
	// Value gets the value of the attribute at the current iterator position.
	//
	// The iterator is not advanced.
	Value() *glib.Variant
	// Next attempts to advance the iterator to the next (possibly first)
	// attribute.
	//
	// true is returned on success, or false if there are no more attributes.
	//
	// You must call this function when you first acquire the iterator to
	// advance it to the first attribute (and determine if the first attribute
	// exists at all).
	Next() bool
}

// menuAttributeIter implements the MenuAttributeIter class.
type menuAttributeIter struct {
	gextras.Objector
}

var _ MenuAttributeIter = (*menuAttributeIter)(nil)

// WrapMenuAttributeIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuAttributeIter(obj *externglib.Object) MenuAttributeIter {
	return menuAttributeIter{
		Objector: obj,
	}
}

func marshalMenuAttributeIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuAttributeIter(obj), nil
}

func (i menuAttributeIter) Name() string {
	var _arg0 *C.GMenuAttributeIter // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_menu_attribute_iter_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i menuAttributeIter) GetNext() (string, *glib.Variant, bool) {
	var _arg0 *C.GMenuAttributeIter // out
	var _arg1 *C.gchar              // in
	var _value *glib.Variant
	var _cret C.gboolean // in

	_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_menu_attribute_iter_get_next(_arg0, &_arg1, (**C.GVariant)(unsafe.Pointer(&_value)))

	var _outName string // out

	var _ok bool // out

	_outName = C.GoString(_arg1)

	if _cret != 0 {
		_ok = true
	}

	return _outName, _value, _ok
}

func (i menuAttributeIter) Value() *glib.Variant {
	var _arg0 *C.GMenuAttributeIter // out
	var _cret *C.GVariant           // in

	_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_menu_attribute_iter_get_value(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (i menuAttributeIter) Next() bool {
	var _arg0 *C.GMenuAttributeIter // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_menu_attribute_iter_next(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem interface {
	gextras.Objector

	// AttributeValue queries the named @attribute on @menu_item.
	//
	// If @expected_type is specified and the attribute does not have this type,
	// nil is returned. nil is also returned if the attribute simply does not
	// exist.
	AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant
	// Link queries the named @link on @menu_item.
	Link(link string) MenuModel
	// SetActionAndTargetValue sets or unsets the "action" and "target"
	// attributes of @menu_item.
	//
	// If @action is nil then both the "action" and "target" attributes are
	// unset (and @target_value is ignored).
	//
	// If @action is non-nil then the "action" attribute is set. The "target"
	// attribute is then set to the value of @target_value if it is non-nil or
	// unset otherwise.
	//
	// Normal menu items (ie: not submenu, section or other custom item types)
	// are expected to have the "action" attribute set to identify the action
	// that they are associated with. The state type of the action help to
	// determine the disposition of the menu item. See #GAction and Group for an
	// overview of actions.
	//
	// In general, clicking on the menu item will result in activation of the
	// named action with the "target" attribute given as the parameter to the
	// action invocation. If the "target" attribute is not set then the action
	// is invoked with no parameter.
	//
	// If the action has no state then the menu item is usually drawn as a plain
	// menu item (ie: with no additional decoration).
	//
	// If the action has a boolean state then the menu item is usually drawn as
	// a toggle menu item (ie: with a checkmark or equivalent indication). The
	// item should be marked as 'toggled' or 'checked' when the boolean state is
	// true.
	//
	// If the action has a string state then the menu item is usually drawn as a
	// radio menu item (ie: with a radio bullet or equivalent indication). The
	// item should be marked as 'selected' when the string state is equal to the
	// value of the @target property.
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_detailed_action() for two equivalent calls that are
	// probably more convenient for most uses.
	SetActionAndTargetValue(action string, targetValue *glib.Variant)
	// SetAttributeValue sets or unsets an attribute on @menu_item.
	//
	// The attribute to set or unset is specified by @attribute. This can be one
	// of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
	// G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom attribute
	// name. Attribute names are restricted to lowercase characters, numbers and
	// '-'. Furthermore, the names must begin with a lowercase character, must
	// not end with a '-', and must not contain consecutive dashes.
	//
	// must consist only of lowercase ASCII characters, digits and '-'.
	//
	// If @value is non-nil then it is used as the new value for the attribute.
	// If @value is nil then the attribute is unset. If the @value #GVariant is
	// floating, it is consumed.
	//
	// See also g_menu_item_set_attribute() for a more convenient way to do the
	// same.
	SetAttributeValue(attribute string, value *glib.Variant)
	// SetDetailedAction sets the "action" and possibly the "target" attribute
	// of @menu_item.
	//
	// The format of @detailed_action is the same format parsed by
	// g_action_parse_detailed_name().
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_action_and_target_value() for more flexible (but slightly
	// less convenient) alternatives.
	//
	// See also g_menu_item_set_action_and_target_value() for a description of
	// the semantics of the action and target attributes.
	SetDetailedAction(detailedAction string)
	// SetIcon sets (or unsets) the icon on @menu_item.
	//
	// This call is the same as calling g_icon_serialize() and using the result
	// as the value to g_menu_item_set_attribute_value() for
	// G_MENU_ATTRIBUTE_ICON.
	//
	// This API is only intended for use with "noun" menu items; things like
	// bookmarks or applications in an "Open With" menu. Don't use it on menu
	// items corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
	//
	// If @icon is nil then the icon is unset.
	SetIcon(icon Icon)
	// SetLabel sets or unsets the "label" attribute of @menu_item.
	//
	// If @label is non-nil it is used as the label for the menu item. If it is
	// nil then the label attribute is unset.
	SetLabel(label string)
	// SetLink creates a link from @menu_item to @model if non-nil, or unsets
	// it.
	//
	// Links are used to establish a relationship between a particular menu item
	// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate a
	// submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
	// create a section. Other types of link can be used, but there is no
	// guarantee that clients will be able to make sense of them. Link types are
	// restricted to lowercase characters, numbers and '-'. Furthermore, the
	// names must begin with a lowercase character, must not end with a '-', and
	// must not contain consecutive dashes.
	SetLink(link string, model MenuModel)
	// SetSection sets or unsets the "section" link of @menu_item to @section.
	//
	// The effect of having one menu appear as a section of another is exactly
	// as it sounds: the items from @section become a direct part of the menu
	// that @menu_item is added to. See g_menu_item_new_section() for more
	// information about what it means for a menu item to be a section.
	SetSection(section MenuModel)
	// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
	//
	// If @submenu is non-nil, it is linked to. If it is nil then the link is
	// unset.
	//
	// The effect of having one menu appear as a submenu of another is exactly
	// as it sounds.
	SetSubmenu(submenu MenuModel)
}

// menuItem implements the MenuItem class.
type menuItem struct {
	gextras.Objector
}

var _ MenuItem = (*menuItem)(nil)

// WrapMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuItem(obj *externglib.Object) MenuItem {
	return menuItem{
		Objector: obj,
	}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuItem(obj), nil
}

// NewMenuItem creates a new Item.
//
// If @label is non-nil it is used to set the "label" attribute of the new item.
//
// If @detailed_action is non-nil it is used to set the "action" and possibly
// the "target" attribute of the new item. See g_menu_item_set_detailed_action()
// for more information.
func NewMenuItem(label string, detailedAction string) MenuItem {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GMenuItem // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_menu_item_new(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = WrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemFromModel creates a Item as an exact copy of an existing menu item
// in a Model.
//
// @item_index must be valid (ie: be sure to call g_menu_model_get_n_items()
// first).
func NewMenuItemFromModel(model MenuModel, itemIndex int) MenuItem {
	var _arg1 *C.GMenuModel // out
	var _arg2 C.gint        // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	_arg2 = (C.gint)(itemIndex)

	_cret = C.g_menu_item_new_from_model(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = WrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemSection creates a new Item representing a section.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_section().
//
// The effect of having one menu appear as a section of another is exactly as it
// sounds: the items from @section become a direct part of the menu that
// @menu_item is added to.
//
// Visual separation is typically displayed between two non-empty sections. If
// @label is non-nil then it will be encorporated into this visual indication.
// This allows for labeled subsections of a menu.
//
// As a simple example, consider a typical "Edit" menu from a simple program. It
// probably contains an "Undo" and "Redo" item, followed by a separator,
// followed by "Cut", "Copy" and "Paste".
//
// This would be accomplished by creating three #GMenu instances. The first
// would be populated with the "Undo" and "Redo" items, and the second with the
// "Cut", "Copy" and "Paste" items. The first and second menus would then be
// added as submenus of the third. In XML format, this would look something like
// the following:
//
//    <menu id='edit-menu'>
//      <section>
//        <item label='Undo'/>
//        <item label='Redo'/>
//      </section>
//      <section>
//        <item label='Cut'/>
//        <item label='Copy'/>
//        <item label='Paste'/>
//      </section>
//    </menu>
//
// The following example is exactly equivalent. It is more illustrative of the
// exact relationship between the menus and items (keeping in mind that the
// 'link' element defines a new menu that is linked to the containing one). The
// style of the second example is more verbose and difficult to read (and
// therefore not recommended except for the purpose of understanding what is
// really going on).
//
//    <menu id='edit-menu'>
//      <item>
//        <link name='section'>
//          <item label='Undo'/>
//          <item label='Redo'/>
//        </link>
//      </item>
//      <item>
//        <link name='section'>
//          <item label='Cut'/>
//          <item label='Copy'/>
//          <item label='Paste'/>
//        </link>
//      </item>
//    </menu>
func NewMenuItemSection(label string, section MenuModel) MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	_cret = C.g_menu_item_new_section(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = WrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemSubmenu creates a new Item representing a submenu.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_submenu().
func NewMenuItemSubmenu(label string, submenu MenuModel) MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	_cret = C.g_menu_item_new_submenu(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = WrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

func (m menuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _arg0 *C.GMenuItem    // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	_cret = C.g_menu_item_get_attribute_value(_arg0, _arg1, _arg2)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (m menuItem) Link(link string) MenuModel {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_menu_item_get_link(_arg0, _arg1)

	var _menuModel MenuModel // out

	_menuModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuModel)

	return _menuModel
}

func (m menuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(targetValue.Native()))

	C.g_menu_item_set_action_and_target_value(_arg0, _arg1, _arg2)
}

func (m menuItem) SetAttributeValue(attribute string, value *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_menu_item_set_attribute_value(_arg0, _arg1, _arg2)
}

func (m menuItem) SetDetailedAction(detailedAction string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_detailed_action(_arg0, _arg1)
}

func (m menuItem) SetIcon(icon Icon) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_menu_item_set_icon(_arg0, _arg1)
}

func (m menuItem) SetLabel(label string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_label(_arg0, _arg1)
}

func (m menuItem) SetLink(link string, model MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.g_menu_item_set_link(_arg0, _arg1, _arg2)
}

func (m menuItem) SetSection(section MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_item_set_section(_arg0, _arg1)
}

func (m menuItem) SetSubmenu(submenu MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_item_set_submenu(_arg0, _arg1)
}

// MenuLinkIter is an opaque structure type. You must access it using the
// functions below.
type MenuLinkIter interface {
	gextras.Objector

	// Name gets the name of the link at the current iterator position.
	//
	// The iterator is not advanced.
	Name() string
	// GetNext: this function combines g_menu_link_iter_next() with
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) link. If that
	// fails, then false is returned and there are no other effects.
	//
	// If successful, @out_link and @value are set to the name and Model of the
	// link that has just been advanced to. At this point,
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return
	// the same values again.
	//
	// The value returned in @out_link remains valid for as long as the iterator
	// remains at the current position. The value returned in @value must be
	// unreffed using g_object_unref() when it is no longer in use.
	GetNext() (string, MenuModel, bool)
	// Value gets the linked Model at the current iterator position.
	//
	// The iterator is not advanced.
	Value() MenuModel
	// Next attempts to advance the iterator to the next (possibly first) link.
	//
	// true is returned on success, or false if there are no more links.
	//
	// You must call this function when you first acquire the iterator to
	// advance it to the first link (and determine if the first link exists at
	// all).
	Next() bool
}

// menuLinkIter implements the MenuLinkIter class.
type menuLinkIter struct {
	gextras.Objector
}

var _ MenuLinkIter = (*menuLinkIter)(nil)

// WrapMenuLinkIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuLinkIter(obj *externglib.Object) MenuLinkIter {
	return menuLinkIter{
		Objector: obj,
	}
}

func marshalMenuLinkIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuLinkIter(obj), nil
}

func (i menuLinkIter) Name() string {
	var _arg0 *C.GMenuLinkIter // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_menu_link_iter_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i menuLinkIter) GetNext() (string, MenuModel, bool) {
	var _arg0 *C.GMenuLinkIter // out
	var _arg1 *C.gchar         // in
	var _arg2 *C.GMenuModel    // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_menu_link_iter_get_next(_arg0, &_arg1, &_arg2)

	var _outLink string  // out
	var _value MenuModel // out
	var _ok bool         // out

	_outLink = C.GoString(_arg1)
	_value = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg2))).(MenuModel)
	if _cret != 0 {
		_ok = true
	}

	return _outLink, _value, _ok
}

func (i menuLinkIter) Value() MenuModel {
	var _arg0 *C.GMenuLinkIter // out
	var _cret *C.GMenuModel    // in

	_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_menu_link_iter_get_value(_arg0)

	var _menuModel MenuModel // out

	_menuModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuModel)

	return _menuModel
}

func (i menuLinkIter) Next() bool {
	var _arg0 *C.GMenuLinkIter // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_menu_link_iter_next(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MenuModel represents the contents of a menu -- an ordered list of menu items.
// The items are associated with actions, which can be activated through them.
// Items can be grouped in sections, and may have submenus associated with them.
// Both items and sections usually have some representation data, such as labels
// or icons. The type of the associated action (ie whether it is stateful, and
// what kind of state it has) can influence the representation of the item.
//
// The conceptual model of menus in Model is hierarchical: sections and submenus
// are again represented by Models. Menus themselves do not define their own
// roles. Rather, the role of a particular Model is defined by the item that
// references it (or, in the case of the 'root' menu, is defined by the context
// in which it is used).
//
// As an example, consider the visible portions of this menu:
//
//
// An example menu
//
// ! (menu-example.png)
//
// There are 8 "menus" visible in the screenshot: one menubar, two submenus and
// 5 sections:
//
// - the toplevel menubar (containing 4 items) - the View submenu (containing 3
// sections) - the first section of the View submenu (containing 2 items) - the
// second section of the View submenu (containing 1 item) - the final section of
// the View submenu (containing 1 item) - the Highlight Mode submenu (containing
// 2 sections) - the Sources section (containing 2 items) - the Markup section
// (containing 2 items)
//
// The [example][menu-model] illustrates the conceptual connection between these
// 8 menus. Each large block in the figure represents a menu and the smaller
// blocks within the large block represent items in that menu. Some items
// contain references to other menus.
//
//
// A menu example
//
// ! (menu-model.png)
//
// Notice that the separators visible in the [example][menu-example] appear
// nowhere in the [menu model][menu-model]. This is because separators are not
// explicitly represented in the menu model. Instead, a separator is inserted
// between any two non-empty sections of a menu. Section items can have labels
// just like any other item. In that case, a display system may show a section
// header instead of a separator.
//
// The motivation for this abstract model of application controls is that modern
// user interfaces tend to make these controls available outside the
// application. Examples include global menus, jumplists, dash boards, etc. To
// support such uses, it is necessary to 'export' information about actions and
// their representation in menus, which is exactly what the [GActionGroup
// exporter][gio-GActionGroup-exporter] and the [GMenuModel
// exporter][gio-GMenuModel-exporter] do for Group and Model. The client-side
// counterparts to make use of the exported information are BusActionGroup and
// BusMenuModel.
//
// The API of Model is very generic, with iterators for the attributes and links
// of an item, see g_menu_model_iterate_item_attributes() and
// g_menu_model_iterate_item_links(). The 'standard' attributes and link types
// have predefined names: G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, G_MENU_LINK_SECTION and G_MENU_LINK_SUBMENU.
//
// Items in a Model represent active controls if they refer to an action that
// can get activated when the user interacts with the menu item. The reference
// to the action is encoded by the string id in the G_MENU_ATTRIBUTE_ACTION
// attribute. An action id uniquely identifies an action in an action group.
// Which action group(s) provide actions depends on the context in which the
// menu model is used. E.g. when the model is exported as the application menu
// of a Application, actions can be application-wide or window-specific (and
// thus come from two different action groups). By convention, the
// application-wide actions have names that start with "app.", while the names
// of window-specific actions start with "win.".
//
// While a wide variety of stateful actions is possible, the following is the
// minimum that is expected to be supported by all users of exported menu
// information: - an action with no parameter type and no state - an action with
// no parameter type and boolean state - an action with string parameter type
// and string state
//
//
// Stateless
//
// A stateless action typically corresponds to an ordinary menu item.
//
// Selecting such a menu item will activate the action (with no parameter).
//
//
// Boolean State
//
// An action with a boolean state will most typically be used with a "toggle" or
// "switch" menu item. The state can be set directly, but activating the action
// (with no parameter) results in the state being toggled.
//
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as "checked" when the state is true.
//
//
// String Parameter and State
//
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of radio
// menu items. Activating the action with a string parameter is equivalent to
// setting that parameter as the state.
//
// Radio menu items, in addition to being associated with the action, will have
// a target value. Selecting that menu item will result in activation of the
// action with the target value as the parameter. The menu item should be
// rendered as "selected" when the state of the action is equal to the target
// value of the menu item.
type MenuModel interface {
	gextras.Objector

	// ItemAttributeValue queries the item at position @item_index in @model for
	// the attribute specified by @attribute.
	//
	// If @expected_type is non-nil then it specifies the expected type of the
	// attribute. If it is nil then any type will be accepted.
	//
	// If the attribute exists and matches @expected_type (or if the expected
	// type is unspecified) then the value is returned.
	//
	// If the attribute does not exist, or does not match the expected type then
	// nil is returned.
	ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant
	// ItemLink queries the item at position @item_index in @model for the link
	// specified by @link.
	//
	// If the link exists, the linked Model is returned. If the link does not
	// exist, nil is returned.
	ItemLink(itemIndex int, link string) MenuModel
	// NItems: query the number of items in @model.
	NItems() int
	// IsMutable queries if @model is mutable.
	//
	// An immutable Model will never emit the Model::items-changed signal.
	// Consumers of the model may make optimisations accordingly.
	IsMutable() bool
	// ItemsChanged requests emission of the Model::items-changed signal on
	// @model.
	//
	// This function should never be called except by Model subclasses. Any
	// other calls to this function will very likely lead to a violation of the
	// interface of the model.
	//
	// The implementation should update its internal representation of the menu
	// before emitting the signal. The implementation should further expect to
	// receive queries about the new state of the menu (and particularly added
	// menu items) while signal handlers are running.
	//
	// The implementation must dispatch this call directly from a mainloop entry
	// and not in response to calls -- particularly those from the Model API.
	// Said another way: the menu must not change while user code is running
	// without returning to the mainloop.
	ItemsChanged(position int, removed int, added int)
	// IterateItemAttributes creates a AttributeIter to iterate over the
	// attributes of the item at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemAttributes(itemIndex int) MenuAttributeIter
	// IterateItemLinks creates a LinkIter to iterate over the links of the item
	// at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemLinks(itemIndex int) MenuLinkIter
}

// menuModel implements the MenuModel class.
type menuModel struct {
	gextras.Objector
}

var _ MenuModel = (*menuModel)(nil)

// WrapMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuModel(obj *externglib.Object) MenuModel {
	return menuModel{
		Objector: obj,
	}
}

func marshalMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuModel(obj), nil
}

func (m menuModel) ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _arg0 *C.GMenuModel   // out
	var _arg1 C.gint          // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(itemIndex)
	_arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	_cret = C.g_menu_model_get_item_attribute_value(_arg0, _arg1, _arg2, _arg3)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (m menuModel) ItemLink(itemIndex int, link string) MenuModel {
	var _arg0 *C.GMenuModel // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(itemIndex)
	_arg2 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_menu_model_get_item_link(_arg0, _arg1, _arg2)

	var _menuModel MenuModel // out

	_menuModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuModel)

	return _menuModel
}

func (m menuModel) NItems() int {
	var _arg0 *C.GMenuModel // out
	var _cret C.gint        // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))

	_cret = C.g_menu_model_get_n_items(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (m menuModel) IsMutable() bool {
	var _arg0 *C.GMenuModel // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))

	_cret = C.g_menu_model_is_mutable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m menuModel) ItemsChanged(position int, removed int, added int) {
	var _arg0 *C.GMenuModel // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // out
	var _arg3 C.gint        // out

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(position)
	_arg2 = (C.gint)(removed)
	_arg3 = (C.gint)(added)

	C.g_menu_model_items_changed(_arg0, _arg1, _arg2, _arg3)
}

func (m menuModel) IterateItemAttributes(itemIndex int) MenuAttributeIter {
	var _arg0 *C.GMenuModel         // out
	var _arg1 C.gint                // out
	var _cret *C.GMenuAttributeIter // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(itemIndex)

	_cret = C.g_menu_model_iterate_item_attributes(_arg0, _arg1)

	var _menuAttributeIter MenuAttributeIter // out

	_menuAttributeIter = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuAttributeIter)

	return _menuAttributeIter
}

func (m menuModel) IterateItemLinks(itemIndex int) MenuLinkIter {
	var _arg0 *C.GMenuModel    // out
	var _arg1 C.gint           // out
	var _cret *C.GMenuLinkIter // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(itemIndex)

	_cret = C.g_menu_model_iterate_item_links(_arg0, _arg1)

	var _menuLinkIter MenuLinkIter // out

	_menuLinkIter = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuLinkIter)

	return _menuLinkIter
}

// MountOperation provides a mechanism for interacting with the user. It can be
// used for authenticating mountable operations, such as loop mounting files,
// hard drive partitions or server locations. It can also be used to ask the
// user questions or show a list of applications preventing unmount or eject
// operations from completing.
//
// Note that Operation is used for more than just #GMount objects  for example
// it is also used in g_drive_start() and g_drive_stop().
//
// Users should instantiate a subclass of this that implements all the various
// callbacks to show the required dialogs, such as MountOperation. If no user
// interaction is desired (for example when automounting filesystems at login
// time), usually nil can be passed, see each method taking a Operation for
// details.
//
// The term TCRYPT is used to mean compatible with TrueCrypt and VeraCrypt.
// TrueCrypt (https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system
// for encrypting file containers, partitions or whole disks, typically used
// with Windows. VeraCrypt (https://www.veracrypt.fr/) is a maintained fork of
// TrueCrypt with various improvements and auditing fixes.
type MountOperation interface {
	gextras.Objector

	// Anonymous: check to see whether the mount operation is being used for an
	// anonymous user.
	Anonymous() bool
	// Choice gets a choice from the mount operation.
	Choice() int
	// Domain gets the domain of the mount operation.
	Domain() string
	// IsTcryptHiddenVolume: check to see whether the mount operation is being
	// used for a TCRYPT hidden volume.
	IsTcryptHiddenVolume() bool
	// IsTcryptSystemVolume: check to see whether the mount operation is being
	// used for a TCRYPT system volume.
	IsTcryptSystemVolume() bool
	// Password gets a password from the mount operation.
	Password() string
	// PasswordSave gets the state of saving passwords for the mount operation.
	PasswordSave() PasswordSave
	// Pim gets a PIM from the mount operation.
	Pim() uint
	// Username: get the user name from the mount operation.
	Username() string
	// Reply emits the Operation::reply signal.
	Reply(result MountOperationResult)
	// SetAnonymous sets the mount operation to use an anonymous user if
	// @anonymous is true.
	SetAnonymous(anonymous bool)
	// SetChoice sets a default choice for the mount operation.
	SetChoice(choice int)
	// SetDomain sets the mount operation's domain.
	SetDomain(domain string)
	// SetIsTcryptHiddenVolume sets the mount operation to use a hidden volume
	// if @hidden_volume is true.
	SetIsTcryptHiddenVolume(hiddenVolume bool)
	// SetIsTcryptSystemVolume sets the mount operation to use a system volume
	// if @system_volume is true.
	SetIsTcryptSystemVolume(systemVolume bool)
	// SetPassword sets the mount operation's password to @password.
	SetPassword(password string)
	// SetPasswordSave sets the state of saving passwords for the mount
	// operation.
	SetPasswordSave(save PasswordSave)
	// SetPim sets the mount operation's PIM to @pim.
	SetPim(pim uint)
	// SetUsername sets the user name within @op to @username.
	SetUsername(username string)
}

// mountOperation implements the MountOperation class.
type mountOperation struct {
	gextras.Objector
}

var _ MountOperation = (*mountOperation)(nil)

// WrapMountOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapMountOperation(obj *externglib.Object) MountOperation {
	return mountOperation{
		Objector: obj,
	}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMountOperation(obj), nil
}

// NewMountOperation creates a new mount operation.
func NewMountOperation() MountOperation {
	var _cret *C.GMountOperation // in

	_cret = C.g_mount_operation_new()

	var _mountOperation MountOperation // out

	_mountOperation = WrapMountOperation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mountOperation
}

func (o mountOperation) Anonymous() bool {
	var _arg0 *C.GMountOperation // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.g_mount_operation_get_anonymous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o mountOperation) Choice() int {
	var _arg0 *C.GMountOperation // out
	var _cret C.int              // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.g_mount_operation_get_choice(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (o mountOperation) Domain() string {
	var _arg0 *C.GMountOperation // out
	var _cret *C.char            // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.g_mount_operation_get_domain(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (o mountOperation) IsTcryptHiddenVolume() bool {
	var _arg0 *C.GMountOperation // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.g_mount_operation_get_is_tcrypt_hidden_volume(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o mountOperation) IsTcryptSystemVolume() bool {
	var _arg0 *C.GMountOperation // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.g_mount_operation_get_is_tcrypt_system_volume(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o mountOperation) Password() string {
	var _arg0 *C.GMountOperation // out
	var _cret *C.char            // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.g_mount_operation_get_password(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (o mountOperation) PasswordSave() PasswordSave {
	var _arg0 *C.GMountOperation // out
	var _cret C.GPasswordSave    // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.g_mount_operation_get_password_save(_arg0)

	var _passwordSave PasswordSave // out

	_passwordSave = PasswordSave(_cret)

	return _passwordSave
}

func (o mountOperation) Pim() uint {
	var _arg0 *C.GMountOperation // out
	var _cret C.guint            // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.g_mount_operation_get_pim(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (o mountOperation) Username() string {
	var _arg0 *C.GMountOperation // out
	var _cret *C.char            // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.g_mount_operation_get_username(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (o mountOperation) Reply(result MountOperationResult) {
	var _arg0 *C.GMountOperation      // out
	var _arg1 C.GMountOperationResult // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GMountOperationResult)(result)

	C.g_mount_operation_reply(_arg0, _arg1)
}

func (o mountOperation) SetAnonymous(anonymous bool) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	if anonymous {
		_arg1 = C.TRUE
	}

	C.g_mount_operation_set_anonymous(_arg0, _arg1)
}

func (o mountOperation) SetChoice(choice int) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.int              // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.int)(choice)

	C.g_mount_operation_set_choice(_arg0, _arg1)
}

func (o mountOperation) SetDomain(domain string) {
	var _arg0 *C.GMountOperation // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_mount_operation_set_domain(_arg0, _arg1)
}

func (o mountOperation) SetIsTcryptHiddenVolume(hiddenVolume bool) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	if hiddenVolume {
		_arg1 = C.TRUE
	}

	C.g_mount_operation_set_is_tcrypt_hidden_volume(_arg0, _arg1)
}

func (o mountOperation) SetIsTcryptSystemVolume(systemVolume bool) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	if systemVolume {
		_arg1 = C.TRUE
	}

	C.g_mount_operation_set_is_tcrypt_system_volume(_arg0, _arg1)
}

func (o mountOperation) SetPassword(password string) {
	var _arg0 *C.GMountOperation // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(password))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_mount_operation_set_password(_arg0, _arg1)
}

func (o mountOperation) SetPasswordSave(save PasswordSave) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.GPasswordSave    // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GPasswordSave)(save)

	C.g_mount_operation_set_password_save(_arg0, _arg1)
}

func (o mountOperation) SetPim(pim uint) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.guint)(pim)

	C.g_mount_operation_set_pim(_arg0, _arg1)
}

func (o mountOperation) SetUsername(username string) {
	var _arg0 *C.GMountOperation // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(username))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_mount_operation_set_username(_arg0, _arg1)
}

// NativeSocketAddress: a socket address of some unknown native type.
type NativeSocketAddress interface {
	SocketAddress
	SocketConnectable
}

// nativeSocketAddress implements the NativeSocketAddress class.
type nativeSocketAddress struct {
	SocketAddress
	SocketConnectable
}

var _ NativeSocketAddress = (*nativeSocketAddress)(nil)

// WrapNativeSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeSocketAddress(obj *externglib.Object) NativeSocketAddress {
	return nativeSocketAddress{
		SocketAddress:     WrapSocketAddress(obj),
		SocketConnectable: WrapSocketConnectable(obj),
	}
}

func marshalNativeSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeSocketAddress(obj), nil
}

type NativeVolumeMonitor interface {
	VolumeMonitor
}

// nativeVolumeMonitor implements the NativeVolumeMonitor class.
type nativeVolumeMonitor struct {
	VolumeMonitor
}

var _ NativeVolumeMonitor = (*nativeVolumeMonitor)(nil)

// WrapNativeVolumeMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeVolumeMonitor(obj *externglib.Object) NativeVolumeMonitor {
	return nativeVolumeMonitor{
		VolumeMonitor: WrapVolumeMonitor(obj),
	}
}

func marshalNativeVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeVolumeMonitor(obj), nil
}

// NetworkAddress provides an easy way to resolve a hostname and then attempt to
// connect to that host, handling the possibility of multiple IP addresses and
// multiple address families.
//
// The enumeration results of resolved addresses *may* be cached as long as this
// object is kept alive which may have unexpected results if alive for too long.
//
// See Connectable for an example of using the connectable interface.
type NetworkAddress interface {
	gextras.Objector
	SocketConnectable

	// Hostname gets @addr's hostname. This might be either UTF-8 or
	// ASCII-encoded, depending on what @addr was created with.
	Hostname() string
	// Port gets @addr's port number
	Port() uint16
	// Scheme gets @addr's scheme
	Scheme() string
}

// networkAddress implements the NetworkAddress class.
type networkAddress struct {
	gextras.Objector
	SocketConnectable
}

var _ NetworkAddress = (*networkAddress)(nil)

// WrapNetworkAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapNetworkAddress(obj *externglib.Object) NetworkAddress {
	return networkAddress{
		Objector:          obj,
		SocketConnectable: WrapSocketConnectable(obj),
	}
}

func marshalNetworkAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNetworkAddress(obj), nil
}

// NewNetworkAddress creates a new Connectable for connecting to the given
// @hostname and @port.
//
// Note that depending on the configuration of the machine, a @hostname of
// `localhost` may refer to the IPv4 loopback address only, or to both IPv4 and
// IPv6; use g_network_address_new_loopback() to create a Address that is
// guaranteed to resolve to both addresses.
func NewNetworkAddress(hostname string, port uint16) NetworkAddress {
	var _arg1 *C.gchar              // out
	var _arg2 C.guint16             // out
	var _cret *C.GSocketConnectable // in

	_arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint16)(port)

	_cret = C.g_network_address_new(_arg1, _arg2)

	var _networkAddress NetworkAddress // out

	_networkAddress = WrapNetworkAddress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _networkAddress
}

// NewNetworkAddressLoopback creates a new Connectable for connecting to the
// local host over a loopback connection to the given @port. This is intended
// for use in connecting to local services which may be running on IPv4 or IPv6.
//
// The connectable will return IPv4 and IPv6 loopback addresses, regardless of
// how the host resolves `localhost`. By contrast, g_network_address_new() will
// often only return an IPv4 address when resolving `localhost`, and an IPv6
// address for `localhost6`.
//
// g_network_address_get_hostname() will always return `localhost` for a Address
// created with this constructor.
func NewNetworkAddressLoopback(port uint16) NetworkAddress {
	var _arg1 C.guint16             // out
	var _cret *C.GSocketConnectable // in

	_arg1 = (C.guint16)(port)

	_cret = C.g_network_address_new_loopback(_arg1)

	var _networkAddress NetworkAddress // out

	_networkAddress = WrapNetworkAddress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _networkAddress
}

func (a networkAddress) Hostname() string {
	var _arg0 *C.GNetworkAddress // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_network_address_get_hostname(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a networkAddress) Port() uint16 {
	var _arg0 *C.GNetworkAddress // out
	var _cret C.guint16          // in

	_arg0 = (*C.GNetworkAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_network_address_get_port(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

func (a networkAddress) Scheme() string {
	var _arg0 *C.GNetworkAddress // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_network_address_get_scheme(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// NetworkService: like Address does with hostnames, Service provides an easy
// way to resolve a SRV record, and then attempt to connect to one of the hosts
// that implements that service, handling service priority/weighting, multiple
// IP addresses, and multiple address families.
//
// See Target for more information about SRV records, and see Connectable for an
// example of using the connectable interface.
type NetworkService interface {
	gextras.Objector
	SocketConnectable

	// Domain gets the domain that @srv serves. This might be either UTF-8 or
	// ASCII-encoded, depending on what @srv was created with.
	Domain() string
	// Protocol gets @srv's protocol name (eg, "tcp").
	Protocol() string
	// Scheme gets the URI scheme used to resolve proxies. By default, the
	// service name is used as scheme.
	Scheme() string
	// Service gets @srv's service name (eg, "ldap").
	Service() string
	// SetScheme set's the URI scheme used to resolve proxies. By default, the
	// service name is used as scheme.
	SetScheme(scheme string)
}

// networkService implements the NetworkService class.
type networkService struct {
	gextras.Objector
	SocketConnectable
}

var _ NetworkService = (*networkService)(nil)

// WrapNetworkService wraps a GObject to the right type. It is
// primarily used internally.
func WrapNetworkService(obj *externglib.Object) NetworkService {
	return networkService{
		Objector:          obj,
		SocketConnectable: WrapSocketConnectable(obj),
	}
}

func marshalNetworkService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNetworkService(obj), nil
}

// NewNetworkService creates a new Service representing the given @service,
// @protocol, and @domain. This will initially be unresolved; use the
// Connectable interface to resolve it.
func NewNetworkService(service string, protocol string, domain string) NetworkService {
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _cret *C.GSocketConnectable // in

	_arg1 = (*C.gchar)(C.CString(service))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(protocol))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_network_service_new(_arg1, _arg2, _arg3)

	var _networkService NetworkService // out

	_networkService = WrapNetworkService(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _networkService
}

func (s networkService) Domain() string {
	var _arg0 *C.GNetworkService // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))

	_cret = C.g_network_service_get_domain(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s networkService) Protocol() string {
	var _arg0 *C.GNetworkService // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))

	_cret = C.g_network_service_get_protocol(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s networkService) Scheme() string {
	var _arg0 *C.GNetworkService // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))

	_cret = C.g_network_service_get_scheme(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s networkService) Service() string {
	var _arg0 *C.GNetworkService // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))

	_cret = C.g_network_service_get_service(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s networkService) SetScheme(scheme string) {
	var _arg0 *C.GNetworkService // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_network_service_set_scheme(_arg0, _arg1)
}

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification interface {
	gextras.Objector

	// AddButton adds a button to @notification that activates the action in
	// @detailed_action when clicked. That action must be an application-wide
	// action (starting with "app."). If @detailed_action contains a target, the
	// action will be activated with that target as its parameter.
	//
	// See g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	AddButton(label string, detailedAction string)
	// AddButtonWithTargetValue adds a button to @notification that activates
	// @action when clicked. @action must be an application-wide action (it must
	// start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	AddButtonWithTargetValue(label string, action string, target *glib.Variant)
	// SetBody sets the body of @notification to @body.
	SetBody(body string)
	// SetDefaultAction sets the default action of @notification to
	// @detailed_action. This action is activated when the notification is
	// clicked on.
	//
	// The action in @detailed_action must be an application-wide action (it
	// must start with "app."). If @detailed_action contains a target, the given
	// action will be activated with that target as its parameter. See
	// g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultAction(detailedAction string)
	// SetDefaultActionAndTargetValue sets the default action of @notification
	// to @action. This action is activated when the notification is clicked on.
	// It must be an application-wide action (start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultActionAndTargetValue(action string, target *glib.Variant)
	// SetIcon sets the icon of @notification to @icon.
	SetIcon(icon Icon)
	// SetPriority sets the priority of @notification to @priority. See Priority
	// for possible values.
	SetPriority(priority NotificationPriority)
	// SetTitle sets the title of @notification to @title.
	SetTitle(title string)
	// SetUrgent: deprecated in favor of g_notification_set_priority().
	SetUrgent(urgent bool)
}

// notification implements the Notification class.
type notification struct {
	gextras.Objector
}

var _ Notification = (*notification)(nil)

// WrapNotification wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotification(obj *externglib.Object) Notification {
	return notification{
		Objector: obj,
	}
}

func marshalNotification(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotification(obj), nil
}

// NewNotification creates a new #GNotification with @title as its title.
//
// After populating @notification with more details, it can be sent to the
// desktop shell with g_application_send_notification(). Changing any properties
// after this call will not have any effect until resending @notification.
func NewNotification(title string) Notification {
	var _arg1 *C.gchar         // out
	var _cret *C.GNotification // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_notification_new(_arg1)

	var _notification Notification // out

	_notification = WrapNotification(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _notification
}

func (n notification) AddButton(label string, detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_notification_add_button(_arg0, _arg1, _arg2)
}

func (n notification) AddButtonWithTargetValue(label string, action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariant)(unsafe.Pointer(target.Native()))

	C.g_notification_add_button_with_target_value(_arg0, _arg1, _arg2, _arg3)
}

func (n notification) SetBody(body string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(body))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_body(_arg0, _arg1)
}

func (n notification) SetDefaultAction(detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_default_action(_arg0, _arg1)
}

func (n notification) SetDefaultActionAndTargetValue(action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(target.Native()))

	C.g_notification_set_default_action_and_target_value(_arg0, _arg1, _arg2)
}

func (n notification) SetIcon(icon Icon) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.GIcon         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_notification_set_icon(_arg0, _arg1)
}

func (n notification) SetPriority(priority NotificationPriority) {
	var _arg0 *C.GNotification        // out
	var _arg1 C.GNotificationPriority // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (C.GNotificationPriority)(priority)

	C.g_notification_set_priority(_arg0, _arg1)
}

func (n notification) SetTitle(title string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_title(_arg0, _arg1)
}

func (n notification) SetUrgent(urgent bool) {
	var _arg0 *C.GNotification // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	if urgent {
		_arg1 = C.TRUE
	}

	C.g_notification_set_urgent(_arg0, _arg1)
}

// OutputStream has functions to write to a stream (g_output_stream_write()), to
// close a stream (g_output_stream_close()) and to flush pending writes
// (g_output_stream_flush()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type OutputStream interface {
	gextras.Objector

	// ClearPending clears the pending flag on @stream.
	ClearPending()
	// Close closes the stream, releasing resources related to it.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Closing a stream will automatically flush any outstanding buffers in the
	// stream.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user, otherwise there
	// might be a loss of data as all data might not be written.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but there some
	// streams can use a faster close that doesn't block to e.g. check errors.
	// On cancellation (as with any error) there is no guarantee that all
	// written data will reach the target.
	Close(cancellable Cancellable) error
	// CloseFinish closes an output stream.
	CloseFinish(result AsyncResult) error
	// Flush forces a write of all user-space buffered data for the given
	// @stream. Will block during the operation. Closing the stream will
	// implicitly cause a flush.
	//
	// This function is optional for inherited classes.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Flush(cancellable Cancellable) error
	// FlushFinish finishes flushing an output stream.
	FlushFinish(result AsyncResult) error
	// HasPending checks if an output stream has pending actions.
	HasPending() bool
	// IsClosed checks if an output stream has already been closed.
	IsClosed() bool
	// IsClosing checks if an output stream is being closed. This can be used
	// inside e.g. a flush implementation to see if the flush (or other i/o
	// operation) is called from within the closing operation.
	IsClosing() bool
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	SetPending() error
	// Splice splices an input stream into an output stream.
	Splice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error)
	// SpliceFinish finishes an asynchronous stream splice operation.
	SpliceFinish(result AsyncResult) (int, error)
	// Write tries to write @count bytes from @buffer into the stream. Will
	// block during the operation.
	//
	// If count is 0, returns 0 and does nothing. A value of @count larger than
	// G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes written to the stream is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. on a partial I/O error, or if there is not enough storage in
	// the stream. All writes block until at least one byte is written or an
	// error occurs; 0 is never returned (unless @count is 0).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	Write(buffer []byte, cancellable Cancellable) (int, error)
	// WriteAll tries to write @count bytes from @buffer into the stream. Will
	// block during the operation.
	//
	// This function is similar to g_output_stream_write(), except it tries to
	// write as many bytes as requested, only stopping on an error.
	//
	// On a successful write of @count bytes, true is returned, and
	// @bytes_written is set to @count.
	//
	// If there is an error during the operation false is returned and @error is
	// set to indicate the error status.
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_written will be set to the number of bytes that were successfully
	// written before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_output_stream_write().
	WriteAll(buffer []byte, cancellable Cancellable) (uint, error)
	// WriteAllFinish finishes an asynchronous stream write operation started
	// with g_output_stream_write_all_async().
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_written will be set to the number of bytes that were successfully
	// written before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_output_stream_write_async().
	WriteAllFinish(result AsyncResult) (uint, error)
	// WriteBytesFinish finishes a stream write-from-#GBytes operation.
	WriteBytesFinish(result AsyncResult) (int, error)
	// WriteFinish finishes a stream write operation.
	WriteFinish(result AsyncResult) (int, error)
	// Writev tries to write the bytes contained in the @n_vectors @vectors into
	// the stream. Will block during the operation.
	//
	// If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0
	// and does nothing.
	//
	// On success, the number of bytes written to the stream is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. on a partial I/O error, or if there is not enough storage in
	// the stream. All writes block until at least one byte is written or an
	// error occurs; 0 is never returned (unless @n_vectors is 0 or the sum of
	// all bytes in @vectors is 0).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// Some implementations of g_output_stream_writev() may have limitations on
	// the aggregate buffer size, and will return G_IO_ERROR_INVALID_ARGUMENT if
	// these are exceeded. For example, when writing to a local file on UNIX
	// platforms, the aggregate buffer size must not exceed G_MAXSSIZE bytes.
	Writev(vectors []OutputVector, cancellable Cancellable) (uint, error)
	// WritevAll tries to write the bytes contained in the @n_vectors @vectors
	// into the stream. Will block during the operation.
	//
	// This function is similar to g_output_stream_writev(), except it tries to
	// write as many bytes as requested, only stopping on an error.
	//
	// On a successful write of all @n_vectors vectors, true is returned, and
	// @bytes_written is set to the sum of all the sizes of @vectors.
	//
	// If there is an error during the operation false is returned and @error is
	// set to indicate the error status.
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_written will be set to the number of bytes that were successfully
	// written before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_output_stream_write().
	//
	// The content of the individual elements of @vectors might be changed by
	// this function.
	WritevAll(vectors []OutputVector, cancellable Cancellable) (uint, error)
	// WritevAllFinish finishes an asynchronous stream write operation started
	// with g_output_stream_writev_all_async().
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_written will be set to the number of bytes that were successfully
	// written before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_output_stream_writev_async().
	WritevAllFinish(result AsyncResult) (uint, error)
	// WritevFinish finishes a stream writev operation.
	WritevFinish(result AsyncResult) (uint, error)
}

// outputStream implements the OutputStream class.
type outputStream struct {
	gextras.Objector
}

var _ OutputStream = (*outputStream)(nil)

// WrapOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapOutputStream(obj *externglib.Object) OutputStream {
	return outputStream{
		Objector: obj,
	}
}

func marshalOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOutputStream(obj), nil
}

func (s outputStream) ClearPending() {
	var _arg0 *C.GOutputStream // out

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	C.g_output_stream_clear_pending(_arg0)
}

func (s outputStream) Close(cancellable Cancellable) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_close(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) CloseFinish(result AsyncResult) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) Flush(cancellable Cancellable) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_flush(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) FlushFinish(result AsyncResult) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_flush_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) HasPending() bool {
	var _arg0 *C.GOutputStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_output_stream_has_pending(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s outputStream) IsClosed() bool {
	var _arg0 *C.GOutputStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_output_stream_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s outputStream) IsClosing() bool {
	var _arg0 *C.GOutputStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_output_stream_is_closing(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s outputStream) SetPending() error {
	var _arg0 *C.GOutputStream // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	C.g_output_stream_set_pending(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) Splice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error) {
	var _arg0 *C.GOutputStream           // out
	var _arg1 *C.GInputStream            // out
	var _arg2 C.GOutputStreamSpliceFlags // out
	var _arg3 *C.GCancellable            // out
	var _cret C.gssize                   // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInputStream)(unsafe.Pointer(source.Native()))
	_arg2 = (C.GOutputStreamSpliceFlags)(flags)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_output_stream_splice(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) SpliceFinish(result AsyncResult) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_output_stream_splice_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) Write(buffer []byte, cancellable Cancellable) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.void
	var _arg2 C.gsize
	var _arg3 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_output_stream_write(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) WriteAll(buffer []byte, cancellable Cancellable) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.void
	var _arg2 C.gsize
	var _arg3 C.gsize         // in
	var _arg4 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_write_all(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = (uint)(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WriteAllFinish(result AsyncResult) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_write_all_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = (uint)(_arg2)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WriteBytesFinish(result AsyncResult) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_output_stream_write_bytes_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) WriteFinish(result AsyncResult) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_output_stream_write_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) Writev(vectors []OutputVector, cancellable Cancellable) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GOutputVector
	var _arg2 C.gsize
	var _arg3 C.gsize         // in
	var _arg4 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(vectors))
	_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_writev(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = (uint)(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WritevAll(vectors []OutputVector, cancellable Cancellable) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GOutputVector
	var _arg2 C.gsize
	var _arg3 C.gsize         // in
	var _arg4 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(vectors))
	_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_writev_all(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = (uint)(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WritevAllFinish(result AsyncResult) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_writev_all_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = (uint)(_arg2)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WritevFinish(result AsyncResult) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_writev_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = (uint)(_arg2)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

// Permission: a #GPermission represents the status of the caller's permission
// to perform a certain action.
//
// You can query if the action is currently allowed and if it is possible to
// acquire the permission so that the action will be allowed in the future.
//
// There is also an API to actually acquire the permission and one to release
// it.
//
// As an example, a #GPermission might represent the ability for the user to
// write to a #GSettings object. This #GPermission object could then be used to
// decide if it is appropriate to show a "Click here to unlock" button in a
// dialog and to provide the mechanism to invoke when that button is clicked.
type Permission interface {
	gextras.Objector

	// Acquire attempts to acquire the permission represented by @permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. A simple example is that a
	// dialog may appear asking the user to enter their password.
	//
	// You should check with g_permission_get_can_acquire() before calling this
	// function.
	//
	// If the permission is acquired then true is returned. Otherwise, false is
	// returned and @error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that user
	// interaction is required). See g_permission_acquire_async() for the
	// non-blocking version.
	Acquire(cancellable Cancellable) error
	// AcquireFinish collects the result of attempting to acquire the permission
	// represented by @permission.
	//
	// This is the second half of the asynchronous version of
	// g_permission_acquire().
	AcquireFinish(result AsyncResult) error
	// Allowed gets the value of the 'allowed' property. This property is true
	// if the caller currently has permission to perform the action that
	// @permission represents the permission to perform.
	Allowed() bool
	// CanAcquire gets the value of the 'can-acquire' property. This property is
	// true if it is generally possible to acquire the permission by calling
	// g_permission_acquire().
	CanAcquire() bool
	// CanRelease gets the value of the 'can-release' property. This property is
	// true if it is generally possible to release the permission by calling
	// g_permission_release().
	CanRelease() bool
	// ImplUpdate: this function is called by the #GPermission implementation to
	// update the properties of the permission. You should never call this
	// function except from a #GPermission implementation.
	//
	// GObject notify signals are generated, as appropriate.
	ImplUpdate(allowed bool, canAcquire bool, canRelease bool)
	// Release attempts to release the permission represented by @permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. In most cases the permission
	// will be dropped immediately without further action.
	//
	// You should check with g_permission_get_can_release() before calling this
	// function.
	//
	// If the permission is released then true is returned. Otherwise, false is
	// returned and @error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that user
	// interaction is required). See g_permission_release_async() for the
	// non-blocking version.
	Release(cancellable Cancellable) error
	// ReleaseFinish collects the result of attempting to release the permission
	// represented by @permission.
	//
	// This is the second half of the asynchronous version of
	// g_permission_release().
	ReleaseFinish(result AsyncResult) error
}

// permission implements the Permission class.
type permission struct {
	gextras.Objector
}

var _ Permission = (*permission)(nil)

// WrapPermission wraps a GObject to the right type. It is
// primarily used internally.
func WrapPermission(obj *externglib.Object) Permission {
	return permission{
		Objector: obj,
	}
}

func marshalPermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPermission(obj), nil
}

func (p permission) Acquire(cancellable Cancellable) error {
	var _arg0 *C.GPermission  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_permission_acquire(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (p permission) AcquireFinish(result AsyncResult) error {
	var _arg0 *C.GPermission  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_permission_acquire_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (p permission) Allowed() bool {
	var _arg0 *C.GPermission // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))

	_cret = C.g_permission_get_allowed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p permission) CanAcquire() bool {
	var _arg0 *C.GPermission // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))

	_cret = C.g_permission_get_can_acquire(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p permission) CanRelease() bool {
	var _arg0 *C.GPermission // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))

	_cret = C.g_permission_get_can_release(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p permission) ImplUpdate(allowed bool, canAcquire bool, canRelease bool) {
	var _arg0 *C.GPermission // out
	var _arg1 C.gboolean     // out
	var _arg2 C.gboolean     // out
	var _arg3 C.gboolean     // out

	_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
	if allowed {
		_arg1 = C.TRUE
	}
	if canAcquire {
		_arg2 = C.TRUE
	}
	if canRelease {
		_arg3 = C.TRUE
	}

	C.g_permission_impl_update(_arg0, _arg1, _arg2, _arg3)
}

func (p permission) Release(cancellable Cancellable) error {
	var _arg0 *C.GPermission  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_permission_release(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (p permission) ReleaseFinish(result AsyncResult) error {
	var _arg0 *C.GPermission  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_permission_release_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// PropertyAction: a Action is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction interface {
	gextras.Objector
	Action
}

// propertyAction implements the PropertyAction class.
type propertyAction struct {
	gextras.Objector
	Action
}

var _ PropertyAction = (*propertyAction)(nil)

// WrapPropertyAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapPropertyAction(obj *externglib.Object) PropertyAction {
	return propertyAction{
		Objector: obj,
		Action:   WrapAction(obj),
	}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPropertyAction(obj), nil
}

// NewPropertyAction creates a #GAction corresponding to the value of property
// @property_name on @object.
//
// The property must be existent and readable and writable (and not
// construct-only).
//
// This function takes a reference on @object and doesn't release it until the
// action is destroyed.
func NewPropertyAction(name string, object gextras.Objector, propertyName string) PropertyAction {
	var _arg1 *C.gchar           // out
	var _arg2 C.gpointer         // out
	var _arg3 *C.gchar           // out
	var _cret *C.GPropertyAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_property_action_new(_arg1, _arg2, _arg3)

	var _propertyAction PropertyAction // out

	_propertyAction = WrapPropertyAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _propertyAction
}

// ProXYAddress: support for proxied SocketAddress.
type ProXYAddress interface {
	InetSocketAddress
	SocketConnectable

	// DestinationHostname gets @proxy's destination hostname; that is, the name
	// of the host that will be connected to via the proxy, not the name of the
	// proxy itself.
	DestinationHostname() string
	// DestinationPort gets @proxy's destination port; that is, the port on the
	// destination host that will be connected to via the proxy, not the port
	// number of the proxy itself.
	DestinationPort() uint16
	// DestinationProtocol gets the protocol that is being spoken to the
	// destination server; eg, "http" or "ftp".
	DestinationProtocol() string
	// Password gets @proxy's password.
	Password() string
	// Protocol gets @proxy's protocol. eg, "socks" or "http"
	Protocol() string
	// URI gets the proxy URI that @proxy was constructed from.
	URI() string
	// Username gets @proxy's username.
	Username() string
}

// proXYAddress implements the ProXYAddress class.
type proXYAddress struct {
	InetSocketAddress
	SocketConnectable
}

var _ ProXYAddress = (*proXYAddress)(nil)

// WrapProXYAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapProXYAddress(obj *externglib.Object) ProXYAddress {
	return proXYAddress{
		InetSocketAddress: WrapInetSocketAddress(obj),
		SocketConnectable: WrapSocketConnectable(obj),
	}
}

func marshalProXYAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProXYAddress(obj), nil
}

// NewProXYAddress creates a new Address for @inetaddr with @protocol that
// should tunnel through @dest_hostname and @dest_port.
//
// (Note that this method doesn't set the Address:uri or
// Address:destination-protocol fields; use g_object_new() directly if you want
// to set those.)
func NewProXYAddress(inetaddr InetAddress, port uint16, protocol string, destHostname string, destPort uint16, username string, password string) ProXYAddress {
	var _arg1 *C.GInetAddress   // out
	var _arg2 C.guint16         // out
	var _arg3 *C.gchar          // out
	var _arg4 *C.gchar          // out
	var _arg5 C.guint16         // out
	var _arg6 *C.gchar          // out
	var _arg7 *C.gchar          // out
	var _cret *C.GSocketAddress // in

	_arg1 = (*C.GInetAddress)(unsafe.Pointer(inetaddr.Native()))
	_arg2 = (C.guint16)(port)
	_arg3 = (*C.gchar)(C.CString(protocol))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(destHostname))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (C.guint16)(destPort)
	_arg6 = (*C.gchar)(C.CString(username))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (*C.gchar)(C.CString(password))
	defer C.free(unsafe.Pointer(_arg7))

	_cret = C.g_proxy_address_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)

	var _proxyAddress ProXYAddress // out

	_proxyAddress = WrapProXYAddress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _proxyAddress
}

func (p proXYAddress) DestinationHostname() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

	_cret = C.g_proxy_address_get_destination_hostname(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p proXYAddress) DestinationPort() uint16 {
	var _arg0 *C.GProxyAddress // out
	var _cret C.guint16        // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

	_cret = C.g_proxy_address_get_destination_port(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

func (p proXYAddress) DestinationProtocol() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

	_cret = C.g_proxy_address_get_destination_protocol(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p proXYAddress) Password() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

	_cret = C.g_proxy_address_get_password(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p proXYAddress) Protocol() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

	_cret = C.g_proxy_address_get_protocol(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p proXYAddress) URI() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

	_cret = C.g_proxy_address_get_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p proXYAddress) Username() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

	_cret = C.g_proxy_address_get_username(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ProXYAddressEnumerator is a wrapper around AddressEnumerator which takes the
// Address instances returned by the AddressEnumerator and wraps them in Address
// instances, using the given AddressEnumerator:proxy-resolver.
//
// This enumerator will be returned (for example, by
// g_socket_connectable_enumerate()) as appropriate when a proxy is configured;
// there should be no need to manually wrap a AddressEnumerator instance with
// one.
type ProXYAddressEnumerator interface {
	SocketAddressEnumerator
}

// proXYAddressEnumerator implements the ProXYAddressEnumerator class.
type proXYAddressEnumerator struct {
	SocketAddressEnumerator
}

var _ ProXYAddressEnumerator = (*proXYAddressEnumerator)(nil)

// WrapProXYAddressEnumerator wraps a GObject to the right type. It is
// primarily used internally.
func WrapProXYAddressEnumerator(obj *externglib.Object) ProXYAddressEnumerator {
	return proXYAddressEnumerator{
		SocketAddressEnumerator: WrapSocketAddressEnumerator(obj),
	}
}

func marshalProXYAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProXYAddressEnumerator(obj), nil
}

// Resolver provides cancellable synchronous and asynchronous DNS resolution,
// for hostnames (g_resolver_lookup_by_address(), g_resolver_lookup_by_name()
// and their async variants) and SRV (service) records
// (g_resolver_lookup_service()).
//
// Address and Service provide wrappers around #GResolver functionality that
// also implement Connectable, making it easy to connect to a remote
// host/service.
type Resolver interface {
	gextras.Objector

	// LookupByAddress: synchronously reverse-resolves @address to determine its
	// associated hostname.
	//
	// If the DNS resolution fails, @error (if non-nil) will be set to a value
	// from Error.
	//
	// If @cancellable is non-nil, it can be used to cancel the operation, in
	// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	LookupByAddress(address InetAddress, cancellable Cancellable) (string, error)
	// LookupByAddressFinish retrieves the result of a previous call to
	// g_resolver_lookup_by_address_async().
	//
	// If the DNS resolution failed, @error (if non-nil) will be set to a value
	// from Error. If the operation was cancelled, @error will be set to
	// G_IO_ERROR_CANCELLED.
	LookupByAddressFinish(result AsyncResult) (string, error)
	// SetDefault sets @resolver to be the application's default resolver
	// (reffing @resolver, and unreffing the previous default resolver, if any).
	// Future calls to g_resolver_get_default() will return this resolver.
	//
	// This can be used if an application wants to perform any sort of DNS
	// caching or "pinning"; it can implement its own #GResolver that calls the
	// original default resolver for DNS operations, and implements its own
	// cache policies on top of that, and then set itself as the default
	// resolver for all later code to use.
	SetDefault()
}

// resolver implements the Resolver class.
type resolver struct {
	gextras.Objector
}

var _ Resolver = (*resolver)(nil)

// WrapResolver wraps a GObject to the right type. It is
// primarily used internally.
func WrapResolver(obj *externglib.Object) Resolver {
	return resolver{
		Objector: obj,
	}
}

func marshalResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapResolver(obj), nil
}

func (r resolver) LookupByAddress(address InetAddress, cancellable Cancellable) (string, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GInetAddress // out
	var _arg2 *C.GCancellable // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(address.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_resolver_lookup_by_address(_arg0, _arg1, _arg2, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

func (r resolver) LookupByAddressFinish(result AsyncResult) (string, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_resolver_lookup_by_address_finish(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

func (r resolver) SetDefault() {
	var _arg0 *C.GResolver // out

	_arg0 = (*C.GResolver)(unsafe.Pointer(r.Native()))

	C.g_resolver_set_default(_arg0)
}

// Settings: the #GSettings class provides a convenient API for storing and
// retrieving application settings.
//
// Reads and writes can be considered to be non-blocking. Reading settings with
// #GSettings is typically extremely fast: on approximately the same order of
// magnitude (but slower than) a Table lookup. Writing settings is also
// extremely fast in terms of time to return to your application, but can be
// extremely expensive for other threads and other processes. Many settings
// backends (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings a lot of
// work can be avoided. For dconf, the D-Bus service doesn't even need to be
// started in this case. For this reason, you should only ever modify #GSettings
// keys in response to explicit user action. Particular care should be paid to
// ensure that modifications are not made during startup -- for example, when
// setting the initial value of preferences widgets. The built-in
// g_settings_bind() functionality is careful not to write settings in response
// to notify signals as a result of modifications that it makes to widgets.
//
// When creating a GSettings instance, you have to specify a schema that
// describes the keys in your settings and their types and default values, as
// well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings are
// stored in the conceptual global tree of settings. However, schemas can also
// be '[relocatable][gsettings-relocatable]', i.e. not equipped with a fixed
// path. This is useful e.g. when the schema describes an 'account', and you
// want to be able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character ('/') and must
// not contain two sequential slash characters. Paths should be chosen based on
// a domain name associated with the program or library to which the settings
// belong. Examples of paths are "/org/gtk/settings/file-chooser/" and
// "/ca/desrt/dconf-editor/". Paths should not start with "/apps/", "/desktop/"
// or "/system/" as they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not restrict
// keys to basic types like strings and numbers. GSettings stores values as
// #GVariant, and allows any Type for keys. Key names are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be localized,
// but the localized values are stored in gettext catalogs and looked up with
// the domain that is specified in the `gettext-domain` attribute of the
// <schemalist> or <schema> elements and the category that is specified in the
// `l10n` attribute of the <default> element. The string which is translated
// includes all text in the <default> element, including any surrounding
// quotation marks.
//
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the <default> element  it is recommended to
// add these comments to aid translators understand the meaning and implications
// of the default value. An optional translation `context` attribute can be set
// on the <default> element to disambiguate multiple defaults which use the same
// string.
//
// For example:
//
//    <!-- Translators: A list of words which are not allowed to be typed, in
//         GVariant serialization syntax.
//         See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
//    <default l10n='messages' context='Banned words'>['bad', 'words']</default>
//
// Translations of default values must remain syntactically valid serialized
// #GVariants (e.g. retaining any surrounding quotation marks) or runtime errors
// will occur.
//
// GSettings uses schemas in a compact binary form that is created by the
// [glib-compile-schemas][glib-compile-schemas] utility. The input is a schema
// description in an XML format.
//
// A DTD for the gschema XML format can be found here: gschema.dtd
// (https://git.gnome.org/browse/glib/tree/gio/gschema.dtd)
//
// The [glib-compile-schemas][glib-compile-schemas] tool expects schema files to
// have the extension `.gschema.xml`.
//
// At runtime, schemas are identified by their id (as specified in the id
// attribute of the <schema> element). The convention for schema ids is to use a
// dotted name, similar in style to a D-Bus bus name, e.g.
// "org.gnome.SessionManager". In particular, if the settings are for a specific
// service that owns a D-Bus bus name, the D-Bus bus name and schema id should
// match. For schemas which deal with settings not associated with one named
// application, the id should not use StudlyCaps, e.g.
// "org.gnome.font-rendering".
//
// In addition to #GVariant types, keys can have types that have enumerated
// types. These can be described by a <choice>, <enum> or <flags> element, as
// seen in the [example][schema-enumerated]. The underlying type of such a key
// is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
// g_settings_get_flags(), g_settings_set_flags() access the numeric values
// corresponding to the string value of enum and flags keys.
//
// An example for default value:
//
//    <schemalist>
//      <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
//
//        <key name="greeting" type="s">
//          <default l10n="messages">"Hello, earthlings"</default>
//          <summary>A greeting</summary>
//          <description>
//            Greeting of the invading martians
//          </description>
//        </key>
//
//        <key name="box" type="(ii)">
//          <default>(20,30)</default>
//        </key>
//
//        <key name="empty-string" type="s">
//          <default>""</default>
//          <summary>Empty strings have to be provided in GVariant form</summary>
//        </key>
//
//      </schema>
//    </schemalist>
//
// An example for ranges, choices and enumerated types:
//
//    <schemalist>
//
//      <enum id="org.gtk.Test.myenum">
//        <value nick="first" value="1"/>
//        <value nick="second" value="2"/>
//      </enum>
//
//      <flags id="org.gtk.Test.myflags">
//        <value nick="flag1" value="1"/>
//        <value nick="flag2" value="2"/>
//        <value nick="flag3" value="4"/>
//      </flags>
//
//      <schema id="org.gtk.Test">
//
//        <key name="key-with-range" type="i">
//          <range min="1" max="100"/>
//          <default>10</default>
//        </key>
//
//        <key name="key-with-choices" type="s">
//          <choices>
//            <choice value='Elisabeth'/>
//            <choice value='Annabeth'/>
//            <choice value='Joe'/>
//          </choices>
//          <aliases>
//            <alias value='Anna' target='Annabeth'/>
//            <alias value='Beth' target='Elisabeth'/>
//          </aliases>
//          <default>'Joe'</default>
//        </key>
//
//        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
//          <default>'first'</default>
//        </key>
//
//        <key name='flags-key' flags='org.gtk.Test.myflags'>
//          <default>["flag1","flag2"]</default>
//        </key>
//      </schema>
//    </schemalist>
//
//
// Vendor overrides
//
// Default values are defined in the schemas that get installed by an
// application. Sometimes, it is necessary for a vendor or distributor to adjust
// these defaults. Since patching the XML source for the schema is inconvenient
// and error-prone, [glib-compile-schemas][glib-compile-schemas] reads so-called
// vendor override' files. These are keyfiles in the same directory as the XML
// schema sources which can override default values. The schema id serves as the
// group name in the key file, and the values are expected in serialized
// GVariant form, as in the following example:
//
//    [org.gtk.Example]
//    key1='string'
//    key2=1.5
//
// glib-compile-schemas expects schema files to have the extension
// `.gschema.override`.
//
//
// Binding
//
// A very convenient feature of GSettings lets you bind #GObject properties
// directly to settings, using g_settings_bind(). Once a GObject property has
// been bound to a setting, changes on either side are automatically propagated
// to the other side. GSettings handles details like mapping between GObject and
// GVariant types, and preventing infinite cycles.
//
// This makes it very easy to hook up a preferences dialog to the underlying
// settings. To make this even more convenient, GSettings looks for a boolean
// property with the name "sensitivity" and automatically binds it to the
// writability of the bound setting. If this 'magic' gets in the way, it can be
// suppressed with the SETTINGS_BIND_NO_SENSITIVITY flag.
//
//
// Relocatable schemas
//
// A relocatable schema is one with no `path` attribute specified on its
// <schema> element. By using g_settings_new_with_path(), a #GSettings object
// can be instantiated for a relocatable schema, assigning a path to the
// instance. Paths passed to g_settings_new_with_path() will typically be
// constructed dynamically from a constant prefix plus some form of instance
// identifier; but they must still be valid GSettings paths. Paths could also be
// constant and used with a globally installed schema originating from a
// dependency library.
//
// For example, a relocatable schema could be used to store geometry information
// for different windows in an application. If the schema ID was
// `org.foo.MyApp.Window`, it could be instantiated for paths
// `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
// `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known they
// can be specified as <child> elements in the parent schema, e.g.:
//
//    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
//      <child name="main" schema="org.foo.MyApp.Window"/>
//    </schema>
//
//
// Build system integration
//
// GSettings comes with autotools integration to simplify compiling and
// installing schemas. To add GSettings support to an application, add the
// following to your `configure.ac`:
//
//    GLIB_GSETTINGS
//
// In the appropriate `Makefile.am`, use the following snippet to compile and
// install the named schema:
//
//    gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
//    EXTRA_DIST = $(gsettings_SCHEMAS)
//
//    @GSETTINGS_RULES@
//
// No changes are needed to the build system to mark a schema XML file for
// translation. Assuming it sets the `gettext-domain` attribute, a schema may be
// marked for translation by adding it to `POTFILES.in`, assuming gettext 0.19
// is in use (the preferred method for translation):
//
//    data/org.foo.MyApp.gschema.xml
//
// Alternatively, if intltool 0.50.1 is in use:
//
//    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
//
// GSettings will use gettext to look up translations for the <summary> and
// <description> elements, and also any <default> elements which have a `l10n`
// attribute set. Translations must not be included in the `.gschema.xml` file
// by the build system, for example by using intltool XML rules with a
// `.gschema.xml.in` template.
//
// If an enumerated type defined in a C header file is to be used in a GSettings
// schema, it can either be defined manually using an <enum> element in the
// schema XML, or it can be extracted automatically from the C header. This
// approach is preferred, as it ensures the two representations are always
// synchronised. To do so, add the following to the relevant `Makefile.am`:
//
//    gsettings_ENUM_NAMESPACE = org.foo.MyApp
//    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
//
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
type Settings interface {
	gextras.Objector

	// Apply applies any changes that have been made to the settings. This
	// function does nothing unless @settings is in 'delay-apply' mode; see
	// g_settings_delay(). In the normal case settings are always applied
	// immediately.
	Apply()
	// Bind: create a binding between the @key in the @settings object and the
	// property @property of @object.
	//
	// The binding uses the default GIO mapping functions to map between the
	// settings and property values. These functions handle booleans, numeric
	// types and string types in a straightforward way. Use
	// g_settings_bind_with_mapping() if you need a custom mapping, or map
	// between types that are not supported by the default mapping functions.
	//
	// Unless the @flags include G_SETTINGS_BIND_NO_SENSITIVITY, this function
	// also establishes a binding between the writability of @key and the
	// "sensitive" property of @object (if @object has a boolean property by
	// that name). See g_settings_bind_writable() for more details about
	// writable bindings.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	Bind(key string, object gextras.Objector, property string, flags SettingsBindFlags)
	// BindWritable: create a binding between the writability of @key in the
	// @settings object and the property @property of @object. The property must
	// be boolean; "sensitive" or "visible" properties of widgets are the most
	// likely candidates.
	//
	// Writable bindings are always uni-directional; changes of the writability
	// of the setting will be propagated to the object property, not the other
	// way.
	//
	// When the @inverted argument is true, the binding inverts the value as it
	// passes from the setting to the object, i.e. @property will be set to true
	// if the key is not writable.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	BindWritable(key string, object gextras.Objector, property string, inverted bool)
	// CreateAction creates a #GAction corresponding to a given #GSettings key.
	//
	// The action has the same name as the key.
	//
	// The value of the key becomes the state of the action and the action is
	// enabled when the key is writable. Changing the state of the action
	// results in the key being written to. Changes to the value or writability
	// of the key cause appropriate change notifications to be emitted for the
	// action.
	//
	// For boolean-valued keys, action activations take no parameter and result
	// in the toggling of the value. For all other types, activations take the
	// new value for the key (which must have the correct type).
	CreateAction(key string) Action
	// Delay changes the #GSettings object into 'delay-apply' mode. In this
	// mode, changes to @settings are not immediately propagated to the backend,
	// but kept locally until g_settings_apply() is called.
	Delay()
	// Boolean gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for booleans.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// boolean type in the schema for @settings.
	Boolean(key string) bool
	// Child creates a child settings object which has a base path of
	// `base-path/@name`, where `base-path` is the base path of @settings.
	//
	// The schema for the child settings object must have been declared in the
	// schema of @settings using a <child> element.
	Child(name string) Settings
	// DefaultValue gets the "default value" of a key.
	//
	// This is the value that would be read if g_settings_reset() were to be
	// called on the key.
	//
	// Note that this may be a different value than returned by
	// g_settings_schema_key_get_default_value() if the system administrator has
	// provided a default value.
	//
	// Comparing the return values of g_settings_get_default_value() and
	// g_settings_get_value() is not sufficient for determining if a value has
	// been set because the user may have explicitly set the value to something
	// that happens to be equal to the default. The difference here is that if
	// the default changes in the future, the user's key will still be set.
	//
	// This function may be useful for adding an indication to a UI of what the
	// default value was before the user set it.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	DefaultValue(key string) *glib.Variant
	// Double gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for doubles.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// 'double' type in the schema for @settings.
	Double(key string) float64
	// Enum gets the value that is stored in @settings for @key and converts it
	// to the enum value that it represents.
	//
	// In order to use this function the type of the value must be a string and
	// it must be marked in the schema file as an enumerated type.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as an enumerated type.
	//
	// If the value stored in the configuration database is not a valid value
	// for the enumerated type then this function will return the default value.
	Enum(key string) int
	// Flags gets the value that is stored in @settings for @key and converts it
	// to the flags value that it represents.
	//
	// In order to use this function the type of the value must be an array of
	// strings and it must be marked in the schema file as a flags type.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as a flags type.
	//
	// If the value stored in the configuration database is not a valid value
	// for the flags type then this function will return the default value.
	Flags(key string) uint
	// HasUnapplied returns whether the #GSettings object has any unapplied
	// changes. This can only be the case if it is in 'delayed-apply' mode.
	HasUnapplied() bool
	// Int gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 32-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int32 type in the schema for @settings.
	Int(key string) int
	// Int64 gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 64-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int64 type in the schema for @settings.
	Int64(key string) int64
	// Range queries the range of a key.
	Range(key string) *glib.Variant
	// String gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for strings.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// string type in the schema for @settings.
	String(key string) string
	// Strv: a convenience variant of g_settings_get() for string arrays.
	//
	// It is a programmer error to give a @key that isn't specified as having an
	// array of strings type in the schema for @settings.
	Strv(key string) []string
	// Uint gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 32-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint32 type in the schema for @settings.
	Uint(key string) uint
	// Uint64 gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 64-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint64 type in the schema for @settings.
	Uint64(key string) uint64
	// UserValue checks the "user value" of a key, if there is one.
	//
	// The user value of a key is the last value that was set by the user.
	//
	// After calling g_settings_reset() this function should always return nil
	// (assuming something is not wrong with the system configuration).
	//
	// It is possible that g_settings_get_value() will return a different value
	// than this function. This can happen in the case that the user set a value
	// for a key that was subsequently locked down by the system administrator
	// -- this function will return the user's old value.
	//
	// This function may be useful for adding a "reset" option to a UI or for
	// providing indication that a particular value has been changed.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	UserValue(key string) *glib.Variant
	// Value gets the value that is stored in @settings for @key.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	Value(key string) *glib.Variant
	// IsWritable finds out if a key can be written or not
	IsWritable(name string) bool
	// ListChildren gets the list of children on @settings.
	//
	// The list is exactly the list of strings for which it is not an error to
	// call g_settings_get_child().
	//
	// There is little reason to call this function from "normal" code, since
	// you should already know what children are in your schema. This function
	// may still be useful there for introspection reasons, however.
	//
	// You should free the return value with g_strfreev() when you are done with
	// it.
	ListChildren() []string
	// ListKeys introspects the list of keys on @settings.
	//
	// You should probably not be calling this function from "normal" code
	// (since you should already know what keys are in your schema). This
	// function is intended for introspection reasons.
	//
	// You should free the return value with g_strfreev() when you are done with
	// it.
	ListKeys() []string
	// RangeCheck checks if the given @value is of the correct type and within
	// the permitted range for @key.
	RangeCheck(key string, value *glib.Variant) bool
	// Reset resets @key to its default value.
	//
	// This call resets the key, as much as possible, to its default value. That
	// might be the value specified in the schema or the one set by the
	// administrator.
	Reset(key string)
	// Revert reverts all non-applied changes to the settings. This function
	// does nothing unless @settings is in 'delay-apply' mode; see
	// g_settings_delay(). In the normal case settings are always applied
	// immediately.
	//
	// Change notifications will be emitted for affected keys.
	Revert()
	// SetBoolean sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for booleans.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// boolean type in the schema for @settings.
	SetBoolean(key string, value bool) bool
	// SetDouble sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for doubles.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// 'double' type in the schema for @settings.
	SetDouble(key string, value float64) bool
	// SetEnum looks up the enumerated type nick for @value and writes it to
	// @key, within @settings.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as an enumerated type, or for
	// @value not to be a valid value for the named type.
	//
	// After performing the write, accessing @key directly with
	// g_settings_get_string() will return the 'nick' associated with @value.
	SetEnum(key string, value int) bool
	// SetFlags looks up the flags type nicks for the bits specified by @value,
	// puts them in an array of strings and writes the array to @key, within
	// @settings.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as a flags type, or for @value to
	// contain any bits that are not value for the named type.
	//
	// After performing the write, accessing @key directly with
	// g_settings_get_strv() will return an array of 'nicks'; one for each bit
	// in @value.
	SetFlags(key string, value uint) bool
	// SetInt sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 32-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int32 type in the schema for @settings.
	SetInt(key string, value int) bool
	// SetInt64 sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 64-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int64 type in the schema for @settings.
	SetInt64(key string, value int64) bool
	// SetString sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for strings.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// string type in the schema for @settings.
	SetString(key string, value string) bool
	// SetStrv sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for string arrays. If @value is
	// nil, then @key is set to be the empty array.
	//
	// It is a programmer error to give a @key that isn't specified as having an
	// array of strings type in the schema for @settings.
	SetStrv(key string, value []string) bool
	// SetUint sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 32-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint32 type in the schema for @settings.
	SetUint(key string, value uint) bool
	// SetUint64 sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 64-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint64 type in the schema for @settings.
	SetUint64(key string, value uint64) bool
	// SetValue sets @key in @settings to @value.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or for @value to have the incorrect type, per the
	// schema.
	//
	// If @value is floating then this function consumes the reference.
	SetValue(key string, value *glib.Variant) bool
}

// settings implements the Settings class.
type settings struct {
	gextras.Objector
}

var _ Settings = (*settings)(nil)

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return settings{
		Objector: obj,
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

// NewSettings creates a new #GSettings object with the schema specified by
// @schema_id.
//
// It is an error for the schema to not exist: schemas are an essential part of
// a program, as they provide type information. If schemas need to be
// dynamically loaded (for example, from an optional runtime dependency),
// g_settings_schema_source_lookup() can be used to test for their existence
// before loading them.
//
// Signals on the newly created #GSettings object will be dispatched via the
// thread-default Context in effect at the time of the call to g_settings_new().
// The new #GSettings will hold a reference on the context. See
// g_main_context_push_thread_default().
func NewSettings(schemaId string) Settings {
	var _arg1 *C.gchar     // out
	var _cret *C.GSettings // in

	_arg1 = (*C.gchar)(C.CString(schemaId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_new(_arg1)

	var _settings Settings // out

	_settings = WrapSettings(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _settings
}

// NewSettingsWithPath creates a new #GSettings object with the relocatable
// schema specified by @schema_id and a given path.
//
// You only need to do this if you want to directly create a settings object
// with a schema that doesn't have a specified path of its own. That's quite
// rare.
//
// It is a programmer error to call this function for a schema that has an
// explicitly specified path.
//
// It is a programmer error if @path is not a valid path. A valid path begins
// and ends with '/' and does not contain two consecutive '/' characters.
func NewSettingsWithPath(schemaId string, path string) Settings {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GSettings // in

	_arg1 = (*C.gchar)(C.CString(schemaId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_settings_new_with_path(_arg1, _arg2)

	var _settings Settings // out

	_settings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Settings)

	return _settings
}

func (s settings) Apply() {
	var _arg0 *C.GSettings // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	C.g_settings_apply(_arg0)
}

func (s settings) Bind(key string, object gextras.Objector, property string, flags SettingsBindFlags) {
	var _arg0 *C.GSettings         // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gpointer           // out
	var _arg3 *C.gchar             // out
	var _arg4 C.GSettingsBindFlags // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.GSettingsBindFlags)(flags)

	C.g_settings_bind(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s settings) BindWritable(key string, object gextras.Objector, property string, inverted bool) {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gpointer   // out
	var _arg3 *C.gchar     // out
	var _arg4 C.gboolean   // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg3))
	if inverted {
		_arg4 = C.TRUE
	}

	C.g_settings_bind_writable(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s settings) CreateAction(key string) Action {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GAction   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_create_action(_arg0, _arg1)

	var _action Action // out

	_action = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Action)

	return _action
}

func (s settings) Delay() {
	var _arg0 *C.GSettings // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	C.g_settings_delay(_arg0)
}

func (s settings) Boolean(key string) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_boolean(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) Child(name string) Settings {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GSettings // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_child(_arg0, _arg1)

	var _ret Settings // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Settings)

	return _ret
}

func (s settings) DefaultValue(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_default_value(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (s settings) Double(key string) float64 {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gdouble    // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_double(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s settings) Enum(key string) int {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gint       // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_enum(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s settings) Flags(key string) uint {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.guint      // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_flags(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s settings) HasUnapplied() bool {
	var _arg0 *C.GSettings // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_get_has_unapplied(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) Int(key string) int {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gint       // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_int(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s settings) Int64(key string) int64 {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gint64     // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_int64(_arg0, _arg1)

	var _gint64 int64 // out

	_gint64 = (int64)(_cret)

	return _gint64
}

func (s settings) Range(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_range(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (s settings) String(key string) string {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_string(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (s settings) Strv(key string) []string {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret **C.gchar

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_strv(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (s settings) Uint(key string) uint {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.guint      // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_uint(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s settings) Uint64(key string) uint64 {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.guint64    // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_uint64(_arg0, _arg1)

	var _guint64 uint64 // out

	_guint64 = (uint64)(_cret)

	return _guint64
}

func (s settings) UserValue(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_user_value(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (s settings) Value(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_value(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

func (s settings) IsWritable(name string) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_is_writable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) ListChildren() []string {
	var _arg0 *C.GSettings // out
	var _cret **C.gchar

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_list_children(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (s settings) ListKeys() []string {
	var _arg0 *C.GSettings // out
	var _cret **C.gchar

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_list_keys(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (s settings) RangeCheck(key string, value *glib.Variant) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	_cret = C.g_settings_range_check(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) Reset(key string) {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_settings_reset(_arg0, _arg1)
}

func (s settings) Revert() {
	var _arg0 *C.GSettings // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	C.g_settings_revert(_arg0)
}

func (s settings) SetBoolean(key string, value bool) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	if value {
		_arg2 = C.TRUE
	}

	_cret = C.g_settings_set_boolean(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetDouble(key string, value float64) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gdouble    // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gdouble)(value)

	_cret = C.g_settings_set_double(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetEnum(key string, value int) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(value)

	_cret = C.g_settings_set_enum(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetFlags(key string, value uint) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(value)

	_cret = C.g_settings_set_flags(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetInt(key string, value int) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(value)

	_cret = C.g_settings_set_int(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetInt64(key string, value int64) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gint64     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint64)(value)

	_cret = C.g_settings_set_int64(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetString(key string, value string) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_settings_set_string(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetStrv(key string, value []string) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 **C.gchar
	var _cret C.gboolean // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(value)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(value))
		for i := range value {
			out[i] = (*C.gchar)(C.CString(value[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_settings_set_strv(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetUint(key string, value uint) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(value)

	_cret = C.g_settings_set_uint(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetUint64(key string, value uint64) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.guint64    // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint64)(value)

	_cret = C.g_settings_set_uint64(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s settings) SetValue(key string, value *glib.Variant) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	_cret = C.g_settings_set_value(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SimpleAction: a Action is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of adding
// it to a ActionGroup.
//
// See also Action.
type SimpleAction interface {
	gextras.Objector
	Action

	// SetEnabled sets the action as enabled or not.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to modify its enabled flag.
	SetEnabled(enabled bool)
	// SetState sets the state of the action.
	//
	// This directly updates the 'state' property to the given value.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to directly modify the 'state' property.
	// Instead, they should call g_action_change_state() to request the change.
	//
	// If the @value GVariant is floating, it is consumed.
	SetState(value *glib.Variant)
	// SetStateHint sets the state hint for the action.
	//
	// See g_action_get_state_hint() for more information about action state
	// hints.
	SetStateHint(stateHint *glib.Variant)
}

// simpleAction implements the SimpleAction class.
type simpleAction struct {
	gextras.Objector
	Action
}

var _ SimpleAction = (*simpleAction)(nil)

// WrapSimpleAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleAction(obj *externglib.Object) SimpleAction {
	return simpleAction{
		Objector: obj,
		Action:   WrapAction(obj),
	}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAction(obj), nil
}

// NewSimpleAction creates a new action.
//
// The created action is stateless. See g_simple_action_new_stateful() to create
// an action that has state.
func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))

	_cret = C.g_simple_action_new(_arg1, _arg2)

	var _simpleAction SimpleAction // out

	_simpleAction = WrapSimpleAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleAction
}

// NewSimpleActionStateful creates a new stateful action.
//
// All future state values must have the same Type as the initial @state.
//
// If the @state #GVariant is floating, it is consumed.
func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _arg3 *C.GVariant      // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))
	_arg3 = (*C.GVariant)(unsafe.Pointer(state.Native()))

	_cret = C.g_simple_action_new_stateful(_arg1, _arg2, _arg3)

	var _simpleAction SimpleAction // out

	_simpleAction = WrapSimpleAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleAction
}

func (s simpleAction) SetEnabled(enabled bool) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.g_simple_action_set_enabled(_arg0, _arg1)
}

func (s simpleAction) SetState(value *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_simple_action_set_state(_arg0, _arg1)
}

func (s simpleAction) SetStateHint(stateHint *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(stateHint.Native()))

	C.g_simple_action_set_state_hint(_arg0, _arg1)
}

// SimpleActionGroup is a hash table filled with #GAction objects, implementing
// the Group and Map interfaces.
type SimpleActionGroup interface {
	gextras.Objector
	ActionGroup
	ActionMap

	// Insert adds an action to the action group.
	//
	// If the action group already contains an action with the same name as
	// @action then the old action is dropped from the group.
	//
	// The action group takes its own reference on @action.
	Insert(action Action)
	// Lookup looks up the action with the name @action_name in the group.
	//
	// If no such action exists, returns nil.
	Lookup(actionName string) Action
	// Remove removes the named action from the action group.
	//
	// If no action of this name is in the group then nothing happens.
	Remove(actionName string)
}

// simpleActionGroup implements the SimpleActionGroup class.
type simpleActionGroup struct {
	gextras.Objector
	ActionGroup
	ActionMap
}

var _ SimpleActionGroup = (*simpleActionGroup)(nil)

// WrapSimpleActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleActionGroup(obj *externglib.Object) SimpleActionGroup {
	return simpleActionGroup{
		Objector:    obj,
		ActionGroup: WrapActionGroup(obj),
		ActionMap:   WrapActionMap(obj),
	}
}

func marshalSimpleActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleActionGroup(obj), nil
}

// NewSimpleActionGroup creates a new, empty, ActionGroup.
func NewSimpleActionGroup() SimpleActionGroup {
	var _cret *C.GSimpleActionGroup // in

	_cret = C.g_simple_action_group_new()

	var _simpleActionGroup SimpleActionGroup // out

	_simpleActionGroup = WrapSimpleActionGroup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleActionGroup
}

func (s simpleActionGroup) Insert(action Action) {
	var _arg0 *C.GSimpleActionGroup // out
	var _arg1 *C.GAction            // out

	_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAction)(unsafe.Pointer(action.Native()))

	C.g_simple_action_group_insert(_arg0, _arg1)
}

func (s simpleActionGroup) Lookup(actionName string) Action {
	var _arg0 *C.GSimpleActionGroup // out
	var _arg1 *C.gchar              // out
	var _cret *C.GAction            // in

	_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_simple_action_group_lookup(_arg0, _arg1)

	var _action Action // out

	_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

	return _action
}

func (s simpleActionGroup) Remove(actionName string) {
	var _arg0 *C.GSimpleActionGroup // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_simple_action_group_remove(_arg0, _arg1)
}

// SimpleAsyncResult as of GLib 2.46, AsyncResult is deprecated in favor of
// #GTask, which provides a simpler API.
//
// AsyncResult implements Result.
//
// GSimpleAsyncResult handles ReadyCallbacks, error reporting, operation
// cancellation and the final state of an operation, completely transparent to
// the application. Results can be returned as a pointer e.g. for functions that
// return data that is collected asynchronously, a boolean value for checking
// the success or failure of an operation, or a #gssize for operations which
// return the number of bytes modified by the operation; all of the simple
// return cases are covered.
//
// Most of the time, an application will not need to know of the details of this
// API; it is handled transparently, and any necessary operations are handled by
// Result's interface. However, if implementing a new GIO module, for writing
// language bindings, or for complex applications that need better control of
// how asynchronous operations are completed, it is important to understand this
// functionality.
//
// GSimpleAsyncResults are tagged with the calling function to ensure that
// asynchronous functions and their finishing functions are used together
// correctly.
//
// To create a new AsyncResult, call g_simple_async_result_new(). If the result
// needs to be created for a #GError, use g_simple_async_result_new_from_error()
// or g_simple_async_result_new_take_error(). If a #GError is not available
// (e.g. the asynchronous operation's doesn't take a #GError argument), but the
// result still needs to be created for an error condition, use
// g_simple_async_result_new_error() (or g_simple_async_result_set_error_va() if
// your application or binding requires passing a variable argument list
// directly), and the error can then be propagated through the use of
// g_simple_async_result_propagate_error().
//
// An asynchronous operation can be made to ignore a cancellation event by
// calling g_simple_async_result_set_handle_cancellation() with a AsyncResult
// for the operation and false. This is useful for operations that are dangerous
// to cancel, such as close (which would cause a leak if cancelled before being
// run).
//
// GSimpleAsyncResult can integrate into GLib's event loop, Loop, or it can use
// #GThreads. g_simple_async_result_complete() will finish an I/O task directly
// from the point where it is called. g_simple_async_result_complete_in_idle()
// will finish it from an idle handler in the [thread-default main
// context][g-main-context-push-thread-default] where the AsyncResult was
// created. g_simple_async_result_run_in_thread() will run the job in a separate
// thread and then use g_simple_async_result_complete_in_idle() to deliver the
// result.
//
// To set the results of an asynchronous function,
// g_simple_async_result_set_op_res_gpointer(),
// g_simple_async_result_set_op_res_gboolean(), and
// g_simple_async_result_set_op_res_gssize() are provided, setting the
// operation's result to a gpointer, gboolean, or gssize, respectively.
//
// Likewise, to get the result of an asynchronous function,
// g_simple_async_result_get_op_res_gpointer(),
// g_simple_async_result_get_op_res_gboolean(), and
// g_simple_async_result_get_op_res_gssize() are provided, getting the
// operation's result as a gpointer, gboolean, and gssize, respectively.
//
// For the details of the requirements implementations must respect, see Result.
// A typical implementation of an asynchronous operation using
// GSimpleAsyncResult looks something like this:
//
//    static void
//    baked_cb (Cake    *cake,
//              gpointer user_data)
//    {
//      // In this example, this callback is not given a reference to the cake,
//      // so the GSimpleAsyncResult has to take a reference to it.
//      GSimpleAsyncResult *result = user_data;
//
//      if (cake == NULL)
//        g_simple_async_result_set_error (result,
//                                         BAKER_ERRORS,
//                                         BAKER_ERROR_NO_FLOUR,
//                                         "Go to the supermarket");
//      else
//        g_simple_async_result_set_op_res_gpointer (result,
//                                                   g_object_ref (cake),
//                                                   g_object_unref);
//
//
//      // In this example, we assume that baked_cb is called as a callback from
//      // the mainloop, so it's safe to complete the operation synchronously here.
//      // If, however, _baker_prepare_cake () might call its callback without
//      // first returning to the mainloop  inadvisable, but some APIs do so 
//      // we would need to use g_simple_async_result_complete_in_idle().
//      g_simple_async_result_complete (result);
//      g_object_unref (result);
//    }
//
//    void
//    baker_bake_cake_async (Baker              *self,
//                           guint               radius,
//                           GAsyncReadyCallback callback,
//                           gpointer            user_data)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      if (radius < 3)
//        {
//          g_simple_async_report_error_in_idle (G_OBJECT (self),
//                                               callback,
//                                               user_data,
//                                               BAKER_ERRORS,
//                                               BAKER_ERROR_TOO_SMALL,
//                                               "ucm radius cakes are silly",
//                                               radius);
//          return;
//        }
//
//      simple = g_simple_async_result_new (G_OBJECT (self),
//                                          callback,
//                                          user_data,
//                                          baker_bake_cake_async);
//      cake = _baker_get_cached_cake (self, radius);
//
//      if (cake != NULL)
//        {
//          g_simple_async_result_set_op_res_gpointer (simple,
//                                                     g_object_ref (cake),
//                                                     g_object_unref);
//          g_simple_async_result_complete_in_idle (simple);
//          g_object_unref (simple);
//          // Drop the reference returned by _baker_get_cached_cake();
//          // the GSimpleAsyncResult has taken its own reference.
//          g_object_unref (cake);
//          return;
//        }
//
//      _baker_prepare_cake (self, radius, baked_cb, simple);
//    }
//
//    Cake *
//    baker_bake_cake_finish (Baker        *self,
//                            GAsyncResult *result,
//                            GError      **error)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      g_return_val_if_fail (g_simple_async_result_is_valid (result,
//                                                            G_OBJECT (self),
//                                                            baker_bake_cake_async),
//                            NULL);
//
//      simple = (GSimpleAsyncResult *) result;
//
//      if (g_simple_async_result_propagate_error (simple, error))
//        return NULL;
//
//      cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//      return g_object_ref (cake);
//    }
type SimpleAsyncResult interface {
	gextras.Objector
	AsyncResult

	// Complete completes an asynchronous I/O job immediately. Must be called in
	// the thread where the asynchronous result was to be delivered, as it
	// invokes the callback directly. If you are in a different thread use
	// g_simple_async_result_complete_in_idle().
	//
	// Calling this function takes a reference to @simple for as long as is
	// needed to complete the call.
	Complete()
	// CompleteInIdle completes an asynchronous function in an idle handler in
	// the [thread-default main context][g-main-context-push-thread-default] of
	// the thread that @simple was initially created in (and re-pushes that
	// context around the invocation of the callback).
	//
	// Calling this function takes a reference to @simple for as long as is
	// needed to complete the call.
	CompleteInIdle()
	// OpResGboolean gets the operation result boolean from within the
	// asynchronous result.
	OpResGboolean() bool
	// OpResGssize gets a gssize from the asynchronous result.
	OpResGssize() int
	// PropagateError propagates an error from within the simple asynchronous
	// result to a given destination.
	//
	// If the #GCancellable given to a prior call to
	// g_simple_async_result_set_check_cancellable() is cancelled then this
	// function will return true with @dest set appropriately.
	PropagateError() error
	// SetCheckCancellable sets a #GCancellable to check before dispatching
	// results.
	//
	// This function has one very specific purpose: the provided cancellable is
	// checked at the time of g_simple_async_result_propagate_error() If it is
	// cancelled, these functions will return an "Operation was cancelled" error
	// (G_IO_ERROR_CANCELLED).
	//
	// Implementors of cancellable asynchronous functions should use this in
	// order to provide a guarantee to their callers that cancelling an async
	// operation will reliably result in an error being returned for that
	// operation (even if a positive result for the operation has already been
	// sent as an idle to the main context to be dispatched).
	//
	// The checking described above is done regardless of any call to the
	// unrelated g_simple_async_result_set_handle_cancellation() function.
	SetCheckCancellable(checkCancellable Cancellable)
	// SetFromError sets the result from a #GError.
	SetFromError(err error)
	// SetHandleCancellation sets whether to handle cancellation within the
	// asynchronous operation.
	//
	// This function has nothing to do with
	// g_simple_async_result_set_check_cancellable(). It only refers to the
	// #GCancellable passed to g_simple_async_result_run_in_thread().
	SetHandleCancellation(handleCancellation bool)
	// SetOpResGboolean sets the operation result to a boolean within the
	// asynchronous result.
	SetOpResGboolean(opRes bool)
	// SetOpResGssize sets the operation result within the asynchronous result
	// to the given @op_res.
	SetOpResGssize(opRes int)
}

// simpleAsyncResult implements the SimpleAsyncResult class.
type simpleAsyncResult struct {
	gextras.Objector
	AsyncResult
}

var _ SimpleAsyncResult = (*simpleAsyncResult)(nil)

// WrapSimpleAsyncResult wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleAsyncResult(obj *externglib.Object) SimpleAsyncResult {
	return simpleAsyncResult{
		Objector:    obj,
		AsyncResult: WrapAsyncResult(obj),
	}
}

func marshalSimpleAsyncResult(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAsyncResult(obj), nil
}

func (s simpleAsyncResult) Complete() {
	var _arg0 *C.GSimpleAsyncResult // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

	C.g_simple_async_result_complete(_arg0)
}

func (s simpleAsyncResult) CompleteInIdle() {
	var _arg0 *C.GSimpleAsyncResult // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

	C.g_simple_async_result_complete_in_idle(_arg0)
}

func (s simpleAsyncResult) OpResGboolean() bool {
	var _arg0 *C.GSimpleAsyncResult // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

	_cret = C.g_simple_async_result_get_op_res_gboolean(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s simpleAsyncResult) OpResGssize() int {
	var _arg0 *C.GSimpleAsyncResult // out
	var _cret C.gssize              // in

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

	_cret = C.g_simple_async_result_get_op_res_gssize(_arg0)

	var _gssize int // out

	_gssize = (int)(_cret)

	return _gssize
}

func (s simpleAsyncResult) PropagateError() error {
	var _arg0 *C.GSimpleAsyncResult // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

	C.g_simple_async_result_propagate_error(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s simpleAsyncResult) SetCheckCancellable(checkCancellable Cancellable) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 *C.GCancellable       // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(checkCancellable.Native()))

	C.g_simple_async_result_set_check_cancellable(_arg0, _arg1)
}

func (s simpleAsyncResult) SetFromError(err error) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 *C.GError             // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))
	defer C.g_error_free(_arg1)

	C.g_simple_async_result_set_from_error(_arg0, _arg1)
}

func (s simpleAsyncResult) SetHandleCancellation(handleCancellation bool) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
	if handleCancellation {
		_arg1 = C.TRUE
	}

	C.g_simple_async_result_set_handle_cancellation(_arg0, _arg1)
}

func (s simpleAsyncResult) SetOpResGboolean(opRes bool) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
	if opRes {
		_arg1 = C.TRUE
	}

	C.g_simple_async_result_set_op_res_gboolean(_arg0, _arg1)
}

func (s simpleAsyncResult) SetOpResGssize(opRes int) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 C.gssize              // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gssize)(opRes)

	C.g_simple_async_result_set_op_res_gssize(_arg0, _arg1)
}

// SimpleIOStream: GSimpleIOStream creates a OStream from an arbitrary Stream
// and Stream. This allows any pair of input and output streams to be used with
// OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream interface {
	IOStream
}

// simpleIOStream implements the SimpleIOStream class.
type simpleIOStream struct {
	IOStream
}

var _ SimpleIOStream = (*simpleIOStream)(nil)

// WrapSimpleIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleIOStream(obj *externglib.Object) SimpleIOStream {
	return simpleIOStream{
		IOStream: WrapIOStream(obj),
	}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleIOStream(obj), nil
}

// NewSimpleIOStream creates a new IOStream wrapping @input_stream and
// @output_stream. See also OStream.
func NewSimpleIOStream(inputStream InputStream, outputStream OutputStream) SimpleIOStream {
	var _arg1 *C.GInputStream  // out
	var _arg2 *C.GOutputStream // out
	var _cret *C.GIOStream     // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(inputStream.Native()))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer(outputStream.Native()))

	_cret = C.g_simple_io_stream_new(_arg1, _arg2)

	var _simpleIOStream SimpleIOStream // out

	_simpleIOStream = WrapSimpleIOStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleIOStream
}

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission interface {
	Permission
}

// simplePermission implements the SimplePermission class.
type simplePermission struct {
	Permission
}

var _ SimplePermission = (*simplePermission)(nil)

// WrapSimplePermission wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimplePermission(obj *externglib.Object) SimplePermission {
	return simplePermission{
		Permission: WrapPermission(obj),
	}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimplePermission(obj), nil
}

// NewSimplePermission creates a new #GPermission instance that represents an
// action that is either always or never allowed.
func NewSimplePermission(allowed bool) SimplePermission {
	var _arg1 C.gboolean     // out
	var _cret *C.GPermission // in

	if allowed {
		_arg1 = C.TRUE
	}

	_cret = C.g_simple_permission_new(_arg1)

	var _simplePermission SimplePermission // out

	_simplePermission = WrapSimplePermission(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simplePermission
}

// SimpleProXYResolver is a simple Resolver implementation that handles a single
// default proxy, multiple URI-scheme-specific proxies, and a list of hosts that
// proxies should not be used for.
//
// ProxyResolver is never the default proxy resolver, but it can be used as the
// base class for another proxy resolver implementation, or it can be created
// and used manually, such as with g_socket_client_set_proxy_resolver().
type SimpleProXYResolver interface {
	gextras.Objector
	ProXYResolver

	// SetDefaultProXY sets the default proxy on @resolver, to be used for any
	// URIs that don't match ProxyResolver:ignore-hosts or a proxy set via
	// g_simple_proxy_resolver_set_uri_proxy().
	//
	// If @default_proxy starts with "socks://", ProxyResolver will treat it as
	// referring to all three of the socks5, socks4a, and socks4 proxy types.
	SetDefaultProXY(defaultProxy string)
	// SetIgnoreHosts sets the list of ignored hosts.
	//
	// See ProxyResolver:ignore-hosts for more details on how the @ignore_hosts
	// argument is interpreted.
	SetIgnoreHosts(ignoreHosts *string)
	// SetURIProXY adds a URI-scheme-specific proxy to @resolver; URIs whose
	// scheme matches @uri_scheme (and which don't match
	// ProxyResolver:ignore-hosts) will be proxied via @proxy.
	//
	// As with ProxyResolver:default-proxy, if @proxy starts with "socks://",
	// ProxyResolver will treat it as referring to all three of the socks5,
	// socks4a, and socks4 proxy types.
	SetURIProXY(uriScheme string, proxy string)
}

// simpleProXYResolver implements the SimpleProXYResolver class.
type simpleProXYResolver struct {
	gextras.Objector
	ProXYResolver
}

var _ SimpleProXYResolver = (*simpleProXYResolver)(nil)

// WrapSimpleProXYResolver wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleProXYResolver(obj *externglib.Object) SimpleProXYResolver {
	return simpleProXYResolver{
		Objector:      obj,
		ProXYResolver: WrapProXYResolver(obj),
	}
}

func marshalSimpleProXYResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleProXYResolver(obj), nil
}

func (r simpleProXYResolver) SetDefaultProXY(defaultProxy string) {
	var _arg0 *C.GSimpleProxyResolver // out
	var _arg1 *C.gchar                // out

	_arg0 = (*C.GSimpleProxyResolver)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(defaultProxy))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_simple_proxy_resolver_set_default_proxy(_arg0, _arg1)
}

func (r simpleProXYResolver) SetIgnoreHosts(ignoreHosts *string) {
	var _arg0 *C.GSimpleProxyResolver // out
	var _arg1 **C.gchar               // out

	_arg0 = (*C.GSimpleProxyResolver)(unsafe.Pointer(r.Native()))
	_arg1 = (**C.gchar)(C.CString(ignoreHosts))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_simple_proxy_resolver_set_ignore_hosts(_arg0, _arg1)
}

func (r simpleProXYResolver) SetURIProXY(uriScheme string, proxy string) {
	var _arg0 *C.GSimpleProxyResolver // out
	var _arg1 *C.gchar                // out
	var _arg2 *C.gchar                // out

	_arg0 = (*C.GSimpleProxyResolver)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(uriScheme))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(proxy))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_simple_proxy_resolver_set_uri_proxy(_arg0, _arg1, _arg2)
}

// Socket: a #GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API. It
// supports both the UNIX socket implementations and winsock2 on Windows.
//
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful.
//
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return nil.
//
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which dont take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation.
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
type Socket interface {
	gextras.Objector
	DatagramBased
	Initable

	// Accept: accept incoming connections on a connection-based socket. This
	// removes the first outstanding connection request from the listening
	// socket and creates a #GSocket object for it.
	//
	// The @socket must be bound to a local address with g_socket_bind() and
	// must be listening for incoming connections (g_socket_listen()).
	//
	// If there are no outstanding connections then the operation will block or
	// return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be
	// notified of an incoming connection, wait for the G_IO_IN condition.
	Accept(cancellable Cancellable) (Socket, error)
	// Bind: when a socket is created it is attached to an address family, but
	// it doesn't have an address in this family. g_socket_bind() assigns the
	// address (sometimes called name) of the socket.
	//
	// It is generally required to bind to a local address before you can
	// receive connections. (See g_socket_listen() and g_socket_accept() ). In
	// certain situations, you may also want to bind a socket that will be used
	// to initiate connections, though this is not normally required.
	//
	// If @socket is a TCP socket, then @allow_reuse controls the setting of the
	// `SO_REUSEADDR` socket option; normally it should be true for server
	// sockets (sockets that you will eventually call g_socket_accept() on), and
	// false for client sockets. (Failing to set this flag on a server socket
	// may cause g_socket_bind() to return G_IO_ERROR_ADDRESS_IN_USE if the
	// server program is stopped and then immediately restarted.)
	//
	// If @socket is a UDP socket, then @allow_reuse determines whether or not
	// other UDP sockets can be bound to the same address at the same time. In
	// particular, you can have several UDP sockets bound to the same address,
	// and they will all receive all of the multicast and broadcast packets sent
	// to that address. (The behavior of unicast UDP packets to an address with
	// multiple listeners is not defined.)
	Bind(address SocketAddress, allowReuse bool) error
	// CheckConnectResult checks and resets the pending connect error for the
	// socket. This is used to check for errors when g_socket_connect() is used
	// in non-blocking mode.
	CheckConnectResult() error
	// Close closes the socket, shutting down any active connection.
	//
	// Closing a socket does not wait for all outstanding I/O operations to
	// finish, so the caller should not rely on them to be guaranteed to
	// complete even if the close returns with no error.
	//
	// Once the socket is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a socket multiple times will not return an
	// error.
	//
	// Sockets will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Beware that due to the way that TCP works, it is possible for
	// recently-sent data to be lost if either you close a socket while the
	// G_IO_IN condition is set, or else if the remote connection tries to send
	// something to you after you close the socket but before it has finished
	// reading all of the data you sent. There is no easy generic way to avoid
	// this problem; the easiest fix is to design the network protocol such that
	// the client will never send data "out of turn". Another solution is for
	// the server to half-close the connection by calling g_socket_shutdown()
	// with only the @shutdown_write flag set, and then wait for the client to
	// notice this and close its side of the connection, after which the server
	// can safely call g_socket_close(). (This is what Connection does if you
	// call g_tcp_connection_set_graceful_disconnect(). But of course, this only
	// works if the client will close its connection after the server does.)
	Close() error
	// ConditionCheck checks on the readiness of @socket to perform operations.
	// The operations specified in @condition are checked for and masked against
	// the currently-satisfied conditions on @socket. The result is returned.
	//
	// Note that on Windows, it is possible for an operation to return
	// G_IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check()
	// has claimed that the socket is ready for writing. Rather than calling
	// g_socket_condition_check() and then writing to the socket if it succeeds,
	// it is generally better to simply try writing to the socket right away,
	// and try again later if the initial attempt returns
	// G_IO_ERROR_WOULD_BLOCK.
	//
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
	// conditions will always be set in the output if they are true.
	//
	// This call never blocks.
	ConditionCheck(condition glib.IOCondition) glib.IOCondition
	// ConditionTimedWait waits for up to @timeout_us microseconds for
	// @condition to become true on @socket. If the condition is met, true is
	// returned.
	//
	// If @cancellable is cancelled before the condition is met, or if
	// @timeout_us (or the socket's #GSocket:timeout) is reached before the
	// condition is met, then false is returned and @error, if non-nil, is set
	// to the appropriate value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	//
	// If you don't want a timeout, use g_socket_condition_wait().
	// (Alternatively, you can pass -1 for @timeout_us.)
	//
	// Note that although @timeout_us is in microseconds for consistency with
	// other GLib APIs, this function actually only has millisecond resolution,
	// and the behavior is undefined if @timeout_us is not an exact number of
	// milliseconds.
	ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) error
	// ConditionWait waits for @condition to become true on @socket. When the
	// condition is met, true is returned.
	//
	// If @cancellable is cancelled before the condition is met, or if the
	// socket has a timeout set and it is reached before the condition is met,
	// then false is returned and @error, if non-nil, is set to the appropriate
	// value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	//
	// See also g_socket_condition_timed_wait().
	ConditionWait(condition glib.IOCondition, cancellable Cancellable) error
	// ConnectSocket: connect the socket to the specified remote address.
	//
	// For connection oriented socket this generally means we attempt to make a
	// connection to the @address. For a connection-less socket it sets the
	// default address for g_socket_send() and discards all incoming datagrams
	// from other sources.
	//
	// Generally connection oriented sockets can only connect once, but
	// connection-less sockets can connect multiple times to change the default
	// address.
	//
	// If the connect call needs to do network I/O it will block, unless
	// non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned and the
	// user can be notified of the connection finishing by waiting for the
	// G_IO_OUT condition. The result of the connection must then be checked
	// with g_socket_check_connect_result().
	ConnectSocket(address SocketAddress, cancellable Cancellable) error
	// ConnectionFactoryCreateConnection creates a Connection subclass of the
	// right type for @socket.
	ConnectionFactoryCreateConnection() SocketConnection
	// AvailableBytes: get the amount of data pending in the OS input buffer,
	// without blocking.
	//
	// If @socket is a UDP or SCTP socket, this will return the size of just the
	// next packet, even if additional packets are buffered after that one.
	//
	// Note that on Windows, this function is rather inefficient in the UDP
	// case, and so if you know any plausible upper bound on the size of the
	// incoming packet, it is better to just do a g_socket_receive() with a
	// buffer of that size, rather than calling g_socket_get_available_bytes()
	// first and then doing a receive of exactly the right size.
	AvailableBytes() int
	// Blocking gets the blocking mode of the socket. For details on blocking
	// I/O, see g_socket_set_blocking().
	Blocking() bool
	// Broadcast gets the broadcast setting on @socket; if true, it is possible
	// to send packets to broadcast addresses.
	Broadcast() bool
	// Credentials returns the credentials of the foreign process connected to
	// this socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX
	// sockets).
	//
	// If this operation isn't supported on the OS, the method fails with the
	// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading
	// the SO_PEERCRED option on the underlying socket.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - OpenBSD since GLib 2.30 - Solaris, Illumos and
	// OpenSolaris since GLib 2.40 - NetBSD since GLib 2.42 - macOS, tvOS, iOS
	// since GLib 2.66
	//
	// Other ways to obtain credentials from a foreign peer includes the
	// CredentialsMessage type and g_unix_connection_send_credentials() /
	// g_unix_connection_receive_credentials() functions.
	Credentials() (Credentials, error)
	// Family gets the socket family of the socket.
	Family() SocketFamily
	// Fd returns the underlying OS socket object. On unix this is a socket file
	// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
	// useful for doing platform specific or otherwise unusual operations on the
	// socket.
	Fd() int
	// Keepalive gets the keepalive mode of the socket. For details on this, see
	// g_socket_set_keepalive().
	Keepalive() bool
	// ListenBacklog gets the listen backlog setting of the socket. For details
	// on this, see g_socket_set_listen_backlog().
	ListenBacklog() int
	// LocalAddress: try to get the local address of a bound socket. This is
	// only useful if the socket has been bound to a local address, either
	// explicitly or implicitly when connecting.
	LocalAddress() (SocketAddress, error)
	// MulticastLoopback gets the multicast loopback setting on @socket; if true
	// (the default), outgoing multicast packets will be looped back to
	// multicast listeners on the same host.
	MulticastLoopback() bool
	// MulticastTTL gets the multicast time-to-live setting on @socket; see
	// g_socket_set_multicast_ttl() for more details.
	MulticastTTL() uint
	// Option gets the value of an integer-valued option on @socket, as with
	// getsockopt(). (If you need to fetch a non-integer-valued option, you will
	// need to call getsockopt() directly.)
	//
	// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
	// headers that will define most of the standard/portable socket options.
	// For unusual socket protocols or platform-dependent options, you may need
	// to include additional headers.
	//
	// Note that even for socket options that are a single byte in size, @value
	// is still a pointer to a #gint variable, not a #guchar;
	// g_socket_get_option() will handle the conversion internally.
	Option(level int, optname int) (int, error)
	// Protocol gets the socket protocol id the socket was created with. In case
	// the protocol is unknown, -1 is returned.
	Protocol() SocketProtocol
	// RemoteAddress: try to get the remote address of a connected socket. This
	// is only useful for connection oriented sockets that have been connected.
	RemoteAddress() (SocketAddress, error)
	// SocketType gets the socket type of the socket.
	SocketType() SocketType
	// Timeout gets the timeout setting of the socket. For details on this, see
	// g_socket_set_timeout().
	Timeout() uint
	// TTL gets the unicast time-to-live setting on @socket; see
	// g_socket_set_ttl() for more details.
	TTL() uint
	// IsClosed checks whether a socket is closed.
	IsClosed() bool
	// IsConnected: check whether the socket is connected. This is only useful
	// for connection-oriented sockets.
	//
	// If using g_socket_shutdown(), this function will return true until the
	// socket has been shut down for reading and writing. If you do a
	// non-blocking connect, this function will not return true until after you
	// call g_socket_check_connect_result().
	IsConnected() bool
	// JoinMulticastGroup registers @socket to receive multicast messages sent
	// to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have
	// been bound to an appropriate interface and port with g_socket_bind().
	//
	// If @iface is nil, the system will automatically pick an interface to bind
	// to based on @group.
	//
	// If @source_specific is true, source-specific multicast as defined in RFC
	// 4604 is used. Note that on older platforms this may fail with a
	// G_IO_ERROR_NOT_SUPPORTED error.
	//
	// To bind to a given source-specific multicast address, use
	// g_socket_join_multicast_group_ssm() instead.
	JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) error
	// JoinMulticastGroupSSM registers @socket to receive multicast messages
	// sent to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must
	// have been bound to an appropriate interface and port with
	// g_socket_bind().
	//
	// If @iface is nil, the system will automatically pick an interface to bind
	// to based on @group.
	//
	// If @source_specific is not nil, use source-specific multicast as defined
	// in RFC 4604. Note that on older platforms this may fail with a
	// G_IO_ERROR_NOT_SUPPORTED error.
	//
	// Note that this function can be called multiple times for the same @group
	// with different @source_specific in order to receive multicast packets
	// from more than one source.
	JoinMulticastGroupSSM(group InetAddress, sourceSpecific InetAddress, iface string) error
	// LeaveMulticastGroup removes @socket from the multicast group defined by
	// @group, @iface, and @source_specific (which must all have the same values
	// they had when you joined the group).
	//
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	//
	// To unbind to a given source-specific multicast address, use
	// g_socket_leave_multicast_group_ssm() instead.
	LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) error
	// LeaveMulticastGroupSSM removes @socket from the multicast group defined
	// by @group, @iface, and @source_specific (which must all have the same
	// values they had when you joined the group).
	//
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	LeaveMulticastGroupSSM(group InetAddress, sourceSpecific InetAddress, iface string) error
	// Listen marks the socket as a server socket, i.e. a socket that is used to
	// accept incoming requests using g_socket_accept().
	//
	// Before calling this the socket must be bound to a local address using
	// g_socket_bind().
	//
	// To set the maximum amount of outstanding clients, use
	// g_socket_set_listen_backlog().
	Listen() error
	// Receive: receive data (up to @size bytes) from a socket. This is mainly
	// used by connection-oriented sockets; it is identical to
	// g_socket_receive_from() with @address set to nil.
	//
	// For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
	// g_socket_receive() will always read either 0 or 1 complete messages from
	// the socket. If the received message is too large to fit in @buffer, then
	// the data beyond @size bytes will be discarded, without any explicit
	// indication that this has occurred.
	//
	// For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
	// number of bytes, up to @size. If more than @size bytes have been
	// received, the additional data will be returned in future calls to
	// g_socket_receive().
	//
	// If the socket is in blocking mode the call will block until there is some
	// data to receive, the connection is closed, or there is an error. If there
	// is no data available and the socket is in non-blocking mode, a
	// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data
	// is available, wait for the G_IO_IN condition.
	//
	// On error -1 is returned and @error is set accordingly.
	Receive(cancellable Cancellable) ([]byte, int, error)
	// ReceiveFrom: receive data (up to @size bytes) from a socket.
	//
	// If @address is non-nil then @address will be set equal to the source
	// address of the received packet. @address is owned by the caller.
	//
	// See g_socket_receive() for additional information.
	ReceiveFrom(cancellable Cancellable) (SocketAddress, []byte, int, error)
	// ReceiveMessages: receive multiple data messages from @socket in one go.
	// This is the most complicated and fully-featured version of this call. For
	// easier use, see g_socket_receive(), g_socket_receive_from(), and
	// g_socket_receive_message().
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains a pointer to an
	// array of Vector structs describing the buffers that the data received in
	// each message will be written to. Using multiple Vectors is more
	// memory-efficient than manually copying data out of a single buffer to
	// multiple sources, and more system-call-efficient than making multiple
	// calls to g_socket_receive(), such as in scenarios where a lot of data
	// packets need to be received (e.g. high-bandwidth video streaming over
	// RTP/UDP).
	//
	// @flags modify how all messages are received. The commonly available
	// arguments for this are available in the MsgFlags enum, but the values
	// there are the same as the system values, and the flags are passed in
	// as-is, so you can pass in system-specific flags too. These flags affect
	// the overall receive operation. Flags affecting individual messages are
	// returned in Message.flags.
	//
	// The other members of Message are treated as described in its
	// documentation.
	//
	// If #GSocket:blocking is true the call will block until @num_messages have
	// been received, or the end of the stream is reached.
	//
	// If #GSocket:blocking is false the call will return up to @num_messages
	// without blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in
	// the operating system to be received.
	//
	// In blocking mode, if #GSocket:timeout is positive and is reached before
	// any messages are received, G_IO_ERROR_TIMED_OUT is returned, otherwise up
	// to @num_messages are returned. (Note: This is effectively the behaviour
	// of `MSG_WAITFORONE` with recvmmsg().)
	//
	// To be notified when messages are available, wait for the G_IO_IN
	// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
	// from g_socket_receive_messages() even if you were previously notified of
	// a G_IO_IN condition.
	//
	// If the remote peer closes the connection, any messages queued in the
	// operating system will be returned, and subsequent calls to
	// g_socket_receive_messages() will return 0 (with no error set).
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be received; otherwise the number of
	// messages successfully received before the error will be returned.
	ReceiveMessages(messages []InputMessage, flags int, cancellable Cancellable) (int, error)
	// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
	// except that the choice of blocking or non-blocking behavior is determined
	// by the @blocking argument rather than by @socket's properties.
	ReceiveWithBlocking(blocking bool, cancellable Cancellable) ([]byte, int, error)
	// Send tries to send @size bytes from @buffer on the socket. This is mainly
	// used by connection-oriented sockets; it is identical to
	// g_socket_send_to() with @address set to nil.
	//
	// If the socket is in blocking mode the call will block until there is
	// space for the data in the socket queue. If there is no space available
	// and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
	// will be returned. To be notified when space is available, wait for the
	// G_IO_OUT condition. Note though that you may still receive
	// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
	// notified of a G_IO_OUT condition. (On Windows in particular, this is very
	// common due to the way the underlying APIs work.)
	//
	// On error -1 is returned and @error is set accordingly.
	Send(buffer []byte, cancellable Cancellable) (int, error)
	// SendMessage: send data to @address on @socket. For sending multiple
	// messages see g_socket_send_messages(); for easier use, see
	// g_socket_send() and g_socket_send_to().
	//
	// If @address is nil then the message is sent to the default receiver (set
	// by g_socket_connect()).
	//
	// @vectors must point to an array of Vector structs and @num_vectors must
	// be the length of this array. (If @num_vectors is -1, then @vectors is
	// assumed to be terminated by a Vector with a nil buffer pointer.) The
	// Vector structs describe the buffers that the sent data will be gathered
	// from. Using multiple Vectors is more memory-efficient than manually
	// copying data from multiple sources into a single buffer, and more
	// network-efficient than making multiple calls to g_socket_send().
	//
	// @messages, if non-nil, is taken to point to an array of @num_messages
	// ControlMessage instances. These correspond to the control messages to be
	// sent on the socket. If @num_messages is -1 then @messages is treated as a
	// nil-terminated array.
	//
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the MsgFlags enum, but the values there are the
	// same as the system values, and the flags are passed in as-is, so you can
	// pass in system-specific flags too.
	//
	// If the socket is in blocking mode the call will block until there is
	// space for the data in the socket queue. If there is no space available
	// and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
	// will be returned. To be notified when space is available, wait for the
	// G_IO_OUT condition. Note though that you may still receive
	// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
	// notified of a G_IO_OUT condition. (On Windows in particular, this is very
	// common due to the way the underlying APIs work.)
	//
	// The sum of the sizes of each Vector in vectors must not be greater than
	// G_MAXSSIZE. If the message can be larger than this, then it is mandatory
	// to use the g_socket_send_message_with_timeout() function.
	//
	// On error -1 is returned and @error is set accordingly.
	SendMessage(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, cancellable Cancellable) (int, error)
	// SendMessageWithTimeout: this behaves exactly the same as
	// g_socket_send_message(), except that the choice of timeout behavior is
	// determined by the @timeout_us argument rather than by @socket's
	// properties.
	//
	// On error G_POLLABLE_RETURN_FAILED is returned and @error is set
	// accordingly, or if the socket is currently not writable
	// G_POLLABLE_RETURN_WOULD_BLOCK is returned. @bytes_written will contain 0
	// in both cases.
	SendMessageWithTimeout(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, timeoutUs int64, cancellable Cancellable) (uint, PollableReturn, error)
	// SendMessages: send multiple data messages from @socket in one go. This is
	// the most complicated and fully-featured version of this call. For easier
	// use, see g_socket_send(), g_socket_send_to(), and
	// g_socket_send_message().
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains an address to
	// send the data to, and a pointer to an array of Vector structs to describe
	// the buffers that the data to be sent for each message will be gathered
	// from. Using multiple Vectors is more memory-efficient than manually
	// copying data from multiple sources into a single buffer, and more
	// network-efficient than making multiple calls to g_socket_send(). Sending
	// multiple messages in one go avoids the overhead of making a lot of
	// syscalls in scenarios where a lot of data packets need to be sent (e.g.
	// high-bandwidth video streaming over RTP/UDP), or where the same data
	// needs to be sent to multiple recipients.
	//
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the MsgFlags enum, but the values there are the
	// same as the system values, and the flags are passed in as-is, so you can
	// pass in system-specific flags too.
	//
	// If the socket is in blocking mode the call will block until there is
	// space for all the data in the socket queue. If there is no space
	// available and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK
	// error will be returned if no data was written at all, otherwise the
	// number of messages sent will be returned. To be notified when space is
	// available, wait for the G_IO_OUT condition. Note though that you may
	// still receive G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you
	// were previously notified of a G_IO_OUT condition. (On Windows in
	// particular, this is very common due to the way the underlying APIs work.)
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be sent; otherwise the number of
	// messages successfully sent before the error will be returned.
	SendMessages(messages []OutputMessage, flags int, cancellable Cancellable) (int, error)
	// SendTo tries to send @size bytes from @buffer to @address. If @address is
	// nil then the message is sent to the default receiver (set by
	// g_socket_connect()).
	//
	// See g_socket_send() for additional information.
	SendTo(address SocketAddress, buffer []byte, cancellable Cancellable) (int, error)
	// SendWithBlocking: this behaves exactly the same as g_socket_send(),
	// except that the choice of blocking or non-blocking behavior is determined
	// by the @blocking argument rather than by @socket's properties.
	SendWithBlocking(buffer []byte, blocking bool, cancellable Cancellable) (int, error)
	// SetBlocking sets the blocking mode of the socket. In blocking mode all
	// operations (which dont take an explicit blocking parameter) block until
	// they succeed or there is an error. In non-blocking mode all functions
	// return results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
	//
	// All sockets are created in blocking mode. However, note that the platform
	// level socket is always non-blocking, and blocking mode is a GSocket level
	// feature.
	SetBlocking(blocking bool)
	// SetBroadcast sets whether @socket should allow sending to broadcast
	// addresses. This is false by default.
	SetBroadcast(broadcast bool)
	// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying
	// socket. When this flag is set on a socket, the system will attempt to
	// verify that the remote socket endpoint is still present if a sufficiently
	// long period of time passes with no data being exchanged. If the system is
	// unable to verify the presence of the remote endpoint, it will
	// automatically close the connection.
	//
	// This option is only functional on certain kinds of sockets. (Notably,
	// G_SOCKET_PROTOCOL_TCP sockets.)
	//
	// The exact time between pings is system- and protocol-dependent, but will
	// normally be at least two hours. Most commonly, you would set this flag on
	// a server socket if you want to allow clients to remain idle for long
	// periods of time, but also want to ensure that connections are eventually
	// garbage-collected if clients crash or become unreachable.
	SetKeepalive(keepalive bool)
	// SetListenBacklog sets the maximum number of outstanding connections
	// allowed when listening on this socket. If more clients than this are
	// connecting to the socket and the application is not handling them on time
	// then the new connections will be refused.
	//
	// Note that this must be called before g_socket_listen() and has no effect
	// if called after that.
	SetListenBacklog(backlog int)
	// SetMulticastLoopback sets whether outgoing multicast packets will be
	// received by sockets listening on that multicast address on the same host.
	// This is true by default.
	SetMulticastLoopback(loopback bool)
	// SetMulticastTTL sets the time-to-live for outgoing multicast datagrams on
	// @socket. By default, this is 1, meaning that multicast packets will not
	// leave the local network.
	SetMulticastTTL(ttl uint)
	// SetOption sets the value of an integer-valued option on @socket, as with
	// setsockopt(). (If you need to set a non-integer-valued option, you will
	// need to call setsockopt() directly.)
	//
	// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
	// headers that will define most of the standard/portable socket options.
	// For unusual socket protocols or platform-dependent options, you may need
	// to include additional headers.
	SetOption(level int, optname int, value int) error
	// SetTimeout sets the time in seconds after which I/O operations on @socket
	// will time out if they have not yet completed.
	//
	// On a blocking socket, this means that any blocking #GSocket operation
	// will time out after @timeout seconds of inactivity, returning
	// G_IO_ERROR_TIMED_OUT.
	//
	// On a non-blocking socket, calls to g_socket_condition_wait() will also
	// fail with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
	// g_socket_create_source() will trigger after @timeout seconds of
	// inactivity, with the requested condition set, at which point calling
	// g_socket_receive(), g_socket_send(), g_socket_check_connect_result(),
	// etc, will fail with G_IO_ERROR_TIMED_OUT.
	//
	// If @timeout is 0 (the default), operations will never time out on their
	// own.
	//
	// Note that if an I/O operation is interrupted by a signal, this may cause
	// the timeout to be reset.
	SetTimeout(timeout uint)
	// SetTTL sets the time-to-live for outgoing unicast packets on @socket. By
	// default the platform-specific default value is used.
	SetTTL(ttl uint)
	// Shutdown: shut down part or all of a full-duplex connection.
	//
	// If @shutdown_read is true then the receiving side of the connection is
	// shut down, and further reading is disallowed.
	//
	// If @shutdown_write is true then the sending side of the connection is
	// shut down, and further writing is disallowed.
	//
	// It is allowed for both @shutdown_read and @shutdown_write to be true.
	//
	// One example where it is useful to shut down only one side of a connection
	// is graceful disconnect for TCP connections where you close the sending
	// side, then wait for the other side to close the connection, thus ensuring
	// that the other side saw all sent data.
	Shutdown(shutdownRead bool, shutdownWrite bool) error
	// SpeaksIPv4 checks if a socket is capable of speaking IPv4.
	//
	// IPv4 sockets are capable of speaking IPv4. On some operating systems and
	// under some combinations of circumstances IPv6 sockets are also capable of
	// speaking IPv4. See RFC 3493 section 3.7 for more information.
	//
	// No other types of sockets are currently considered as being capable of
	// speaking IPv4.
	SpeaksIPv4() bool
}

// socket implements the Socket class.
type socket struct {
	gextras.Objector
	DatagramBased
	Initable
}

var _ Socket = (*socket)(nil)

// WrapSocket wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocket(obj *externglib.Object) Socket {
	return socket{
		Objector:      obj,
		DatagramBased: WrapDatagramBased(obj),
		Initable:      WrapInitable(obj),
	}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocket(obj), nil
}

// NewSocket creates a new #GSocket with the defined family, type and protocol.
// If @protocol is 0 (G_SOCKET_PROTOCOL_DEFAULT) the default protocol type for
// the family and type is used.
//
// The @protocol is a family and type specific int that specifies what kind of
// protocol to use. Protocol lists several common ones. Many families only
// support one protocol, and use 0 for this, others support several and using 0
// means to use the default protocol for the family and type.
//
// The protocol id is passed directly to the operating system, so you can use
// protocols not listed in Protocol if you know the protocol number used for it.
func NewSocket(family SocketFamily, typ SocketType, protocol SocketProtocol) (Socket, error) {
	var _arg1 C.GSocketFamily   // out
	var _arg2 C.GSocketType     // out
	var _arg3 C.GSocketProtocol // out
	var _cret *C.GSocket        // in
	var _cerr *C.GError         // in

	_arg1 = (C.GSocketFamily)(family)
	_arg2 = (C.GSocketType)(typ)
	_arg3 = (C.GSocketProtocol)(protocol)

	_cret = C.g_socket_new(_arg1, _arg2, _arg3, &_cerr)

	var _socket Socket // out
	var _goerr error   // out

	_socket = WrapSocket(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socket, _goerr
}

// NewSocketFromFd creates a new #GSocket from a native file descriptor or
// winsock SOCKET handle.
//
// This reads all the settings from the file descriptor so that all properties
// should work. Note that the file descriptor will be set to non-blocking mode,
// independent on the blocking mode of the #GSocket.
//
// On success, the returned #GSocket takes ownership of @fd. On failure, the
// caller must close @fd themselves.
//
// Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
// descriptor. Instead, a GError will be set with code G_IO_ERROR_FAILED
func NewSocketFromFd(fd int) (Socket, error) {
	var _arg1 C.gint     // out
	var _cret *C.GSocket // in
	var _cerr *C.GError  // in

	_arg1 = (C.gint)(fd)

	_cret = C.g_socket_new_from_fd(_arg1, &_cerr)

	var _socket Socket // out
	var _goerr error   // out

	_socket = WrapSocket(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socket, _goerr
}

func (s socket) Accept(cancellable Cancellable) (Socket, error) {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GCancellable // out
	var _cret *C.GSocket      // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_accept(_arg0, _arg1, &_cerr)

	var _ret Socket  // out
	var _goerr error // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ret, _goerr
}

func (s socket) Bind(address SocketAddress, allowReuse bool) error {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 C.gboolean        // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	if allowReuse {
		_arg2 = C.TRUE
	}

	C.g_socket_bind(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) CheckConnectResult() error {
	var _arg0 *C.GSocket // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	C.g_socket_check_connect_result(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) Close() error {
	var _arg0 *C.GSocket // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	C.g_socket_close(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var _arg0 *C.GSocket     // out
	var _arg1 C.GIOCondition // out
	var _cret C.GIOCondition // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GIOCondition)(condition)

	_cret = C.g_socket_condition_check(_arg0, _arg1)

	var _ioCondition glib.IOCondition // out

	_ioCondition = glib.IOCondition(_cret)

	return _ioCondition
}

func (s socket) ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) error {
	var _arg0 *C.GSocket      // out
	var _arg1 C.GIOCondition  // out
	var _arg2 C.gint64        // out
	var _arg3 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GIOCondition)(condition)
	_arg2 = (C.gint64)(timeoutUs)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_socket_condition_timed_wait(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ConditionWait(condition glib.IOCondition, cancellable Cancellable) error {
	var _arg0 *C.GSocket      // out
	var _arg1 C.GIOCondition  // out
	var _arg2 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GIOCondition)(condition)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_socket_condition_wait(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ConnectSocket(address SocketAddress, cancellable Cancellable) error {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.GCancellable   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_socket_connect(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ConnectionFactoryCreateConnection() SocketConnection {
	var _arg0 *C.GSocket           // out
	var _cret *C.GSocketConnection // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_connection_factory_create_connection(_arg0)

	var _socketConnection SocketConnection // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)

	return _socketConnection
}

func (s socket) AvailableBytes() int {
	var _arg0 *C.GSocket // out
	var _cret C.gssize   // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_available_bytes(_arg0)

	var _gssize int // out

	_gssize = (int)(_cret)

	return _gssize
}

func (s socket) Blocking() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_blocking(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) Broadcast() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_broadcast(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) Credentials() (Credentials, error) {
	var _arg0 *C.GSocket      // out
	var _cret *C.GCredentials // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_credentials(_arg0, &_cerr)

	var _credentials Credentials // out
	var _goerr error             // out

	_credentials = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Credentials)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _credentials, _goerr
}

func (s socket) Family() SocketFamily {
	var _arg0 *C.GSocket      // out
	var _cret C.GSocketFamily // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_family(_arg0)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

func (s socket) Fd() int {
	var _arg0 *C.GSocket // out
	var _cret C.int      // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_fd(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s socket) Keepalive() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_keepalive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) ListenBacklog() int {
	var _arg0 *C.GSocket // out
	var _cret C.gint     // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_listen_backlog(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s socket) LocalAddress() (SocketAddress, error) {
	var _arg0 *C.GSocket        // out
	var _cret *C.GSocketAddress // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_local_address(_arg0, &_cerr)

	var _socketAddress SocketAddress // out
	var _goerr error                 // out

	_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketAddress, _goerr
}

func (s socket) MulticastLoopback() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_multicast_loopback(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) MulticastTTL() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_multicast_ttl(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s socket) Option(level int, optname int) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(level)
	_arg2 = (C.gint)(optname)

	C.g_socket_get_option(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _value int   // out
	var _goerr error // out

	_value = (int)(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _value, _goerr
}

func (s socket) Protocol() SocketProtocol {
	var _arg0 *C.GSocket        // out
	var _cret C.GSocketProtocol // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_protocol(_arg0)

	var _socketProtocol SocketProtocol // out

	_socketProtocol = SocketProtocol(_cret)

	return _socketProtocol
}

func (s socket) RemoteAddress() (SocketAddress, error) {
	var _arg0 *C.GSocket        // out
	var _cret *C.GSocketAddress // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_remote_address(_arg0, &_cerr)

	var _socketAddress SocketAddress // out
	var _goerr error                 // out

	_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketAddress, _goerr
}

func (s socket) SocketType() SocketType {
	var _arg0 *C.GSocket    // out
	var _cret C.GSocketType // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_socket_type(_arg0)

	var _socketType SocketType // out

	_socketType = SocketType(_cret)

	return _socketType
}

func (s socket) Timeout() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_timeout(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s socket) TTL() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_ttl(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s socket) IsClosed() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) IsConnected() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_is_connected(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 C.gboolean      // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
	if sourceSpecific {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_socket_join_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) JoinMulticastGroupSSM(group InetAddress, sourceSpecific InetAddress, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 *C.GInetAddress // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
	_arg2 = (*C.GInetAddress)(unsafe.Pointer(sourceSpecific.Native()))
	_arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_socket_join_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 C.gboolean      // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
	if sourceSpecific {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_socket_leave_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) LeaveMulticastGroupSSM(group InetAddress, sourceSpecific InetAddress, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 *C.GInetAddress // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
	_arg2 = (*C.GInetAddress)(unsafe.Pointer(sourceSpecific.Native()))
	_arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_socket_leave_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) Listen() error {
	var _arg0 *C.GSocket // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	C.g_socket_listen(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) Receive(cancellable Cancellable) ([]byte, int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gchar
	var _arg2 C.gsize         // in
	var _arg3 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_receive(_arg0, &_arg1, &_arg2, _arg3, &_cerr)

	var _buffer []byte
	var _gssize int  // out
	var _goerr error // out

	{
		src := unsafe.Slice(_arg1, _arg2)
		_buffer = make([]byte, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_buffer[i] = (byte)(src[i])
		}
	}
	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _buffer, _gssize, _goerr
}

func (s socket) ReceiveFrom(cancellable Cancellable) (SocketAddress, []byte, int, error) {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // in
	var _arg2 C.gchar
	var _arg3 C.gsize         // in
	var _arg4 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_receive_from(_arg0, &_arg1, &_arg2, &_arg3, _arg4, &_cerr)

	var _address SocketAddress // out
	var _buffer []byte
	var _gssize int  // out
	var _goerr error // out

	_address = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1))).(SocketAddress)
	{
		src := unsafe.Slice(_arg2, _arg3)
		_buffer = make([]byte, _arg3)
		for i := 0; i < int(_arg3); i++ {
			_buffer[i] = (byte)(src[i])
		}
	}
	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _address, _buffer, _gssize, _goerr
}

func (s socket) ReceiveMessages(messages []InputMessage, flags int, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 *C.GInputMessage
	var _arg2 C.guint
	var _arg3 C.gint          // out
	var _arg4 *C.GCancellable // out
	var _cret C.gint          // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg2 = C.guint(len(messages))
	_arg1 = (*C.GInputMessage)(unsafe.Pointer(&messages[0]))
	_arg3 = (C.gint)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_receive_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (s socket) ReceiveWithBlocking(blocking bool, cancellable Cancellable) ([]byte, int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gchar
	var _arg2 C.gsize         // in
	var _arg3 C.gboolean      // out
	var _arg4 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if blocking {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_receive_with_blocking(_arg0, &_arg1, &_arg2, _arg3, _arg4, &_cerr)

	var _buffer []byte
	var _gssize int  // out
	var _goerr error // out

	{
		src := unsafe.Slice(_arg1, _arg2)
		_buffer = make([]byte, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_buffer[i] = (byte)(src[i])
		}
	}
	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _buffer, _gssize, _goerr
}

func (s socket) Send(buffer []byte, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 *C.gchar
	var _arg2 C.gsize
	var _arg3 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s socket) SendMessage(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.GOutputVector
	var _arg3 C.gint
	var _arg4 **C.GSocketControlMessage
	var _arg5 C.gint
	var _arg6 C.gint          // out
	var _arg7 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg3 = C.gint(len(vectors))
	_arg2 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg5 = C.gint(len(messages))
	_arg4 = (**C.GSocketControlMessage)(C.malloc(C.ulong(len(messages)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(messages))
		for i := range messages {
			out[i] = (*C.GSocketControlMessage)(unsafe.Pointer(messages[i].Native()))
		}
	}
	_arg6 = (C.gint)(flags)
	_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_message(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s socket) SendMessageWithTimeout(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, timeoutUs int64, cancellable Cancellable) (uint, PollableReturn, error) {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.GOutputVector
	var _arg3 C.gint
	var _arg4 **C.GSocketControlMessage
	var _arg5 C.gint
	var _arg6 C.gint            // out
	var _arg7 C.gint64          // out
	var _arg8 C.gsize           // in
	var _arg9 *C.GCancellable   // out
	var _cret C.GPollableReturn // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg3 = C.gint(len(vectors))
	_arg2 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg5 = C.gint(len(messages))
	_arg4 = (**C.GSocketControlMessage)(C.malloc(C.ulong(len(messages)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(messages))
		for i := range messages {
			out[i] = (*C.GSocketControlMessage)(unsafe.Pointer(messages[i].Native()))
		}
	}
	_arg6 = (C.gint)(flags)
	_arg7 = (C.gint64)(timeoutUs)
	_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_message_with_timeout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_arg8, _arg9, &_cerr)

	var _bytesWritten uint             // out
	var _pollableReturn PollableReturn // out
	var _goerr error                   // out

	_bytesWritten = (uint)(_arg8)
	_pollableReturn = PollableReturn(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _pollableReturn, _goerr
}

func (s socket) SendMessages(messages []OutputMessage, flags int, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 *C.GOutputMessage
	var _arg2 C.guint
	var _arg3 C.gint          // out
	var _arg4 *C.GCancellable // out
	var _cret C.gint          // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg2 = C.guint(len(messages))
	_arg1 = (*C.GOutputMessage)(unsafe.Pointer(&messages[0]))
	_arg3 = (C.gint)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (s socket) SendTo(address SocketAddress, buffer []byte, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.gchar
	var _arg3 C.gsize
	var _arg4 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg3 = C.gsize(len(buffer))
	_arg2 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_to(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s socket) SendWithBlocking(buffer []byte, blocking bool, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 *C.gchar
	var _arg2 C.gsize
	var _arg3 C.gboolean      // out
	var _arg4 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
	if blocking {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_with_blocking(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s socket) SetBlocking(blocking bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if blocking {
		_arg1 = C.TRUE
	}

	C.g_socket_set_blocking(_arg0, _arg1)
}

func (s socket) SetBroadcast(broadcast bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if broadcast {
		_arg1 = C.TRUE
	}

	C.g_socket_set_broadcast(_arg0, _arg1)
}

func (s socket) SetKeepalive(keepalive bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if keepalive {
		_arg1 = C.TRUE
	}

	C.g_socket_set_keepalive(_arg0, _arg1)
}

func (s socket) SetListenBacklog(backlog int) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(backlog)

	C.g_socket_set_listen_backlog(_arg0, _arg1)
}

func (s socket) SetMulticastLoopback(loopback bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if loopback {
		_arg1 = C.TRUE
	}

	C.g_socket_set_multicast_loopback(_arg0, _arg1)
}

func (s socket) SetMulticastTTL(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(ttl)

	C.g_socket_set_multicast_ttl(_arg0, _arg1)
}

func (s socket) SetOption(level int, optname int, value int) error {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(level)
	_arg2 = (C.gint)(optname)
	_arg3 = (C.gint)(value)

	C.g_socket_set_option(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) SetTimeout(timeout uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(timeout)

	C.g_socket_set_timeout(_arg0, _arg1)
}

func (s socket) SetTTL(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(ttl)

	C.g_socket_set_ttl(_arg0, _arg1)
}

func (s socket) Shutdown(shutdownRead bool, shutdownWrite bool) error {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out
	var _arg2 C.gboolean // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if shutdownRead {
		_arg1 = C.TRUE
	}
	if shutdownWrite {
		_arg2 = C.TRUE
	}

	C.g_socket_shutdown(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) SpeaksIPv4() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_speaks_ipv4(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SocketAddress is the equivalent of struct sockaddr in the BSD sockets API.
// This is an abstract class; use SocketAddress for internet sockets, or
// SocketAddress for UNIX domain sockets.
type SocketAddress interface {
	gextras.Objector
	SocketConnectable

	// Family gets the socket family type of @address.
	Family() SocketFamily
	// NativeSize gets the size of @address's native struct sockaddr. You can
	// use this to allocate memory to pass to g_socket_address_to_native().
	NativeSize() int
}

// socketAddress implements the SocketAddress class.
type socketAddress struct {
	gextras.Objector
	SocketConnectable
}

var _ SocketAddress = (*socketAddress)(nil)

// WrapSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketAddress(obj *externglib.Object) SocketAddress {
	return socketAddress{
		Objector:          obj,
		SocketConnectable: WrapSocketConnectable(obj),
	}
}

func marshalSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketAddress(obj), nil
}

func (a socketAddress) Family() SocketFamily {
	var _arg0 *C.GSocketAddress // out
	var _cret C.GSocketFamily   // in

	_arg0 = (*C.GSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_socket_address_get_family(_arg0)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

func (a socketAddress) NativeSize() int {
	var _arg0 *C.GSocketAddress // out
	var _cret C.gssize          // in

	_arg0 = (*C.GSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_socket_address_get_native_size(_arg0)

	var _gssize int // out

	_gssize = (int)(_cret)

	return _gssize
}

// SocketAddressEnumerator is an enumerator type for Address instances. It is
// returned by enumeration functions such as g_socket_connectable_enumerate(),
// which returns a AddressEnumerator to list each Address which could be used to
// connect to that Connectable.
//
// Enumeration is typically a blocking operation, so the asynchronous methods
// g_socket_address_enumerator_next_async() and
// g_socket_address_enumerator_next_finish() should be used where possible.
//
// Each AddressEnumerator can only be enumerated once. Once
// g_socket_address_enumerator_next() has returned nil, further enumeration with
// that AddressEnumerator is not possible, and it can be unreffed.
type SocketAddressEnumerator interface {
	gextras.Objector

	// Next retrieves the next Address from @enumerator. Note that this may
	// block for some amount of time. (Eg, a Address may need to do a DNS lookup
	// before it can return an address.) Use
	// g_socket_address_enumerator_next_async() if you need to avoid blocking.
	//
	// If @enumerator is expected to yield addresses, but for some reason is
	// unable to (eg, because of a DNS error), then the first call to
	// g_socket_address_enumerator_next() will return an appropriate error in
	// *@error. However, if the first call to g_socket_address_enumerator_next()
	// succeeds, then any further internal errors (other than @cancellable being
	// triggered) will be ignored.
	Next(cancellable Cancellable) (SocketAddress, error)
	// NextFinish retrieves the result of a completed call to
	// g_socket_address_enumerator_next_async(). See
	// g_socket_address_enumerator_next() for more information about error
	// handling.
	NextFinish(result AsyncResult) (SocketAddress, error)
}

// socketAddressEnumerator implements the SocketAddressEnumerator class.
type socketAddressEnumerator struct {
	gextras.Objector
}

var _ SocketAddressEnumerator = (*socketAddressEnumerator)(nil)

// WrapSocketAddressEnumerator wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketAddressEnumerator(obj *externglib.Object) SocketAddressEnumerator {
	return socketAddressEnumerator{
		Objector: obj,
	}
}

func marshalSocketAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketAddressEnumerator(obj), nil
}

func (e socketAddressEnumerator) Next(cancellable Cancellable) (SocketAddress, error) {
	var _arg0 *C.GSocketAddressEnumerator // out
	var _arg1 *C.GCancellable             // out
	var _cret *C.GSocketAddress           // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_address_enumerator_next(_arg0, _arg1, &_cerr)

	var _socketAddress SocketAddress // out
	var _goerr error                 // out

	_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketAddress, _goerr
}

func (e socketAddressEnumerator) NextFinish(result AsyncResult) (SocketAddress, error) {
	var _arg0 *C.GSocketAddressEnumerator // out
	var _arg1 *C.GAsyncResult             // out
	var _cret *C.GSocketAddress           // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_socket_address_enumerator_next_finish(_arg0, _arg1, &_cerr)

	var _socketAddress SocketAddress // out
	var _goerr error                 // out

	_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketAddress, _goerr
}

// SocketClient is a lightweight high-level utility class for connecting to a
// network host using a connection oriented socket type.
//
// You create a Client object, set any options you want, and then call a sync or
// async connect operation, which returns a Connection subclass on success.
//
// The type of the Connection object returned depends on the type of the
// underlying socket that is in use. For instance, for a TCP/IP connection it
// will be a Connection.
//
// As Client is a lightweight object, you don't need to cache it. You can just
// create a new one any time you need one.
type SocketClient interface {
	gextras.Objector

	// AddApplicationProXY: enable proxy protocols to be handled by the
	// application. When the indicated proxy protocol is returned by the
	// Resolver, Client will consider this protocol as supported but will not
	// try to find a #GProxy instance to handle handshaking. The application
	// must check for this case by calling
	// g_socket_connection_get_remote_address() on the returned Connection, and
	// seeing if it's a Address of the appropriate type, to determine whether or
	// not it needs to handle the proxy handshaking itself.
	//
	// This should be used for proxy protocols that are dialects of another
	// protocol such as HTTP proxy. It also allows cohabitation of proxy
	// protocols that are reused between protocols. A good example is HTTP. It
	// can be used to proxy HTTP, FTP and Gopher and can also be use as generic
	// socket proxy through the HTTP CONNECT method.
	//
	// When the proxy is detected as being an application proxy, TLS handshake
	// will be skipped. This is required to let the application do the proxy
	// specific handshake.
	AddApplicationProXY(protocol string)
	// ConnectSocketClient tries to resolve the @connectable and make a network
	// connection to it.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// The type of the Connection object returned depends on the type of the
	// underlying socket that is used. For instance, for a TCP/IP connection it
	// will be a Connection.
	//
	// The socket created will be the same family as the address that the
	// @connectable resolves to, unless family is set with
	// g_socket_client_set_family() or indirectly via
	// g_socket_client_set_local_address(). The socket type defaults to
	// G_SOCKET_TYPE_STREAM but can be set with
	// g_socket_client_set_socket_type().
	//
	// If a local address is specified with g_socket_client_set_local_address()
	// the socket will be bound to this address before connecting.
	ConnectSocketClient(connectable SocketConnectable, cancellable Cancellable) (SocketConnection, error)
	// ConnectFinish finishes an async connect operation. See
	// g_socket_client_connect_async()
	ConnectFinish(result AsyncResult) (SocketConnection, error)
	// ConnectToHost: this is a helper function for g_socket_client_connect().
	//
	// Attempts to create a TCP connection to the named host.
	//
	// @host_and_port may be in any of a number of recognized formats; an IPv6
	// address, an IPv4 address, or a domain name (in which case a DNS lookup is
	// performed). Quoting with [] is supported for all address types. A port
	// override may be specified in the usual way with a colon. Ports may be
	// given as decimal numbers or symbolic names (in which case an
	// /etc/services lookup is performed).
	//
	// If no port override is given in @host_and_port then @default_port will be
	// used as the port number to connect to.
	//
	// In general, @host_and_port is expected to be provided by the user
	// (allowing them to give the hostname, and a port override if necessary)
	// and @default_port is expected to be provided by the application.
	//
	// In the case that an IP address is given, a single connection attempt is
	// made. In the case that a name is given, multiple connection attempts may
	// be made, in turn and according to the number of address records in DNS,
	// until a connection succeeds.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) nil is returned and @error (if non-nil) is set accordingly.
	ConnectToHost(hostAndPort string, defaultPort uint16, cancellable Cancellable) (SocketConnection, error)
	// ConnectToHostFinish finishes an async connect operation. See
	// g_socket_client_connect_to_host_async()
	ConnectToHostFinish(result AsyncResult) (SocketConnection, error)
	// ConnectToService attempts to create a TCP connection to a service.
	//
	// This call looks up the SRV record for @service at @domain for the "tcp"
	// protocol. It then attempts to connect, in turn, to each of the hosts
	// providing the service until either a connection succeeds or there are no
	// hosts remaining.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) nil is returned and @error (if non-nil) is set accordingly.
	ConnectToService(domain string, service string, cancellable Cancellable) (SocketConnection, error)
	// ConnectToServiceFinish finishes an async connect operation. See
	// g_socket_client_connect_to_service_async()
	ConnectToServiceFinish(result AsyncResult) (SocketConnection, error)
	// ConnectToURI: this is a helper function for g_socket_client_connect().
	//
	// Attempts to create a TCP connection with a network URI.
	//
	// @uri may be any valid URI containing an "authority" (hostname/port)
	// component. If a port is not specified in the URI, @default_port will be
	// used. TLS will be negotiated if Client:tls is true. (Client does not know
	// to automatically assume TLS for certain URI schemes.)
	//
	// Using this rather than g_socket_client_connect() or
	// g_socket_client_connect_to_host() allows Client to determine when to use
	// application-specific proxy protocols.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) nil is returned and @error (if non-nil) is set accordingly.
	ConnectToURI(uri string, defaultPort uint16, cancellable Cancellable) (SocketConnection, error)
	// ConnectToURIFinish finishes an async connect operation. See
	// g_socket_client_connect_to_uri_async()
	ConnectToURIFinish(result AsyncResult) (SocketConnection, error)
	// EnableProXY gets the proxy enable state; see
	// g_socket_client_set_enable_proxy()
	EnableProXY() bool
	// Family gets the socket family of the socket client.
	//
	// See g_socket_client_set_family() for details.
	Family() SocketFamily
	// LocalAddress gets the local address of the socket client.
	//
	// See g_socket_client_set_local_address() for details.
	LocalAddress() SocketAddress
	// Protocol gets the protocol name type of the socket client.
	//
	// See g_socket_client_set_protocol() for details.
	Protocol() SocketProtocol
	// ProXYResolver gets the Resolver being used by @client. Normally, this
	// will be the resolver returned by g_proxy_resolver_get_default(), but you
	// can override it with g_socket_client_set_proxy_resolver().
	ProXYResolver() ProXYResolver
	// SocketType gets the socket type of the socket client.
	//
	// See g_socket_client_set_socket_type() for details.
	SocketType() SocketType
	// Timeout gets the I/O timeout time for sockets created by @client.
	//
	// See g_socket_client_set_timeout() for details.
	Timeout() uint
	// TLS gets whether @client creates TLS connections. See
	// g_socket_client_set_tls() for details.
	TLS() bool
	// TLSValidationFlags gets the TLS validation flags used creating TLS
	// connections via @client.
	TLSValidationFlags() TLSCertificateFlags
	// SetEnableProXY sets whether or not @client attempts to make connections
	// via a proxy server. When enabled (the default), Client will use a
	// Resolver to determine if a proxy protocol such as SOCKS is needed, and
	// automatically do the necessary proxy negotiation.
	//
	// See also g_socket_client_set_proxy_resolver().
	SetEnableProXY(enable bool)
	// SetFamily sets the socket family of the socket client. If this is set to
	// something other than G_SOCKET_FAMILY_INVALID then the sockets created by
	// this object will be of the specified family.
	//
	// This might be useful for instance if you want to force the local
	// connection to be an ipv4 socket, even though the address might be an ipv6
	// mapped to ipv4 address.
	SetFamily(family SocketFamily)
	// SetLocalAddress sets the local address of the socket client. The sockets
	// created by this object will bound to the specified address (if not nil)
	// before connecting.
	//
	// This is useful if you want to ensure that the local side of the
	// connection is on a specific port, or on a specific interface.
	SetLocalAddress(address SocketAddress)
	// SetProtocol sets the protocol of the socket client. The sockets created
	// by this object will use of the specified protocol.
	//
	// If @protocol is G_SOCKET_PROTOCOL_DEFAULT that means to use the default
	// protocol for the socket family and type.
	SetProtocol(protocol SocketProtocol)
	// SetProXYResolver overrides the Resolver used by @client. You can call
	// this if you want to use specific proxies, rather than using the system
	// default proxy settings.
	//
	// Note that whether or not the proxy resolver is actually used depends on
	// the setting of Client:enable-proxy, which is not changed by this function
	// (but which is true by default)
	SetProXYResolver(proxyResolver ProXYResolver)
	// SetSocketType sets the socket type of the socket client. The sockets
	// created by this object will be of the specified type.
	//
	// It doesn't make sense to specify a type of G_SOCKET_TYPE_DATAGRAM, as
	// GSocketClient is used for connection oriented services.
	SetSocketType(typ SocketType)
	// SetTimeout sets the I/O timeout for sockets created by @client. @timeout
	// is a time in seconds, or 0 for no timeout (the default).
	//
	// The timeout value affects the initial connection attempt as well, so
	// setting this may cause calls to g_socket_client_connect(), etc, to fail
	// with G_IO_ERROR_TIMED_OUT.
	SetTimeout(timeout uint)
	// SetTLS sets whether @client creates TLS (aka SSL) connections. If @tls is
	// true, @client will wrap its connections in a ClientConnection and perform
	// a TLS handshake when connecting.
	//
	// Note that since Client must return a Connection, but ClientConnection is
	// not a Connection, this actually wraps the resulting ClientConnection in a
	// WrapperConnection when returning it. You can use
	// g_tcp_wrapper_connection_get_base_io_stream() on the return value to
	// extract the ClientConnection.
	//
	// If you need to modify the behavior of the TLS handshake (eg, by setting a
	// client-side certificate to use, or connecting to the
	// Connection::accept-certificate signal), you can connect to @client's
	// Client::event signal and wait for it to be emitted with
	// G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you a chance to see the
	// ClientConnection before the handshake starts.
	SetTLS(tls bool)
	// SetTLSValidationFlags sets the TLS validation flags used when creating
	// TLS connections via @client. The default value is
	// G_TLS_CERTIFICATE_VALIDATE_ALL.
	SetTLSValidationFlags(flags TLSCertificateFlags)
}

// socketClient implements the SocketClient class.
type socketClient struct {
	gextras.Objector
}

var _ SocketClient = (*socketClient)(nil)

// WrapSocketClient wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketClient(obj *externglib.Object) SocketClient {
	return socketClient{
		Objector: obj,
	}
}

func marshalSocketClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketClient(obj), nil
}

// NewSocketClient creates a new Client with the default options.
func NewSocketClient() SocketClient {
	var _cret *C.GSocketClient // in

	_cret = C.g_socket_client_new()

	var _socketClient SocketClient // out

	_socketClient = WrapSocketClient(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _socketClient
}

func (c socketClient) AddApplicationProXY(protocol string) {
	var _arg0 *C.GSocketClient // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(protocol))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_socket_client_add_application_proxy(_arg0, _arg1)
}

func (c socketClient) ConnectSocketClient(connectable SocketConnectable, cancellable Cancellable) (SocketConnection, error) {
	var _arg0 *C.GSocketClient      // out
	var _arg1 *C.GSocketConnectable // out
	var _arg2 *C.GCancellable       // out
	var _cret *C.GSocketConnection  // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(connectable.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_client_connect(_arg0, _arg1, _arg2, &_cerr)

	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketConnection, _goerr
}

func (c socketClient) ConnectFinish(result AsyncResult) (SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_socket_client_connect_finish(_arg0, _arg1, &_cerr)

	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketConnection, _goerr
}

func (c socketClient) ConnectToHost(hostAndPort string, defaultPort uint16, cancellable Cancellable) (SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.gchar             // out
	var _arg2 C.guint16            // out
	var _arg3 *C.GCancellable      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(hostAndPort))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint16)(defaultPort)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_client_connect_to_host(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketConnection, _goerr
}

func (c socketClient) ConnectToHostFinish(result AsyncResult) (SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_socket_client_connect_to_host_finish(_arg0, _arg1, &_cerr)

	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketConnection, _goerr
}

func (c socketClient) ConnectToService(domain string, service string, cancellable Cancellable) (SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _arg3 *C.GCancellable      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(service))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_client_connect_to_service(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketConnection, _goerr
}

func (c socketClient) ConnectToServiceFinish(result AsyncResult) (SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_socket_client_connect_to_service_finish(_arg0, _arg1, &_cerr)

	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketConnection, _goerr
}

func (c socketClient) ConnectToURI(uri string, defaultPort uint16, cancellable Cancellable) (SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.gchar             // out
	var _arg2 C.guint16            // out
	var _arg3 *C.GCancellable      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint16)(defaultPort)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_client_connect_to_uri(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketConnection, _goerr
}

func (c socketClient) ConnectToURIFinish(result AsyncResult) (SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_socket_client_connect_to_uri_finish(_arg0, _arg1, &_cerr)

	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketConnection, _goerr
}

func (c socketClient) EnableProXY() bool {
	var _arg0 *C.GSocketClient // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_client_get_enable_proxy(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c socketClient) Family() SocketFamily {
	var _arg0 *C.GSocketClient // out
	var _cret C.GSocketFamily  // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_client_get_family(_arg0)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

func (c socketClient) LocalAddress() SocketAddress {
	var _arg0 *C.GSocketClient  // out
	var _cret *C.GSocketAddress // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_client_get_local_address(_arg0)

	var _socketAddress SocketAddress // out

	_socketAddress = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SocketAddress)

	return _socketAddress
}

func (c socketClient) Protocol() SocketProtocol {
	var _arg0 *C.GSocketClient  // out
	var _cret C.GSocketProtocol // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_client_get_protocol(_arg0)

	var _socketProtocol SocketProtocol // out

	_socketProtocol = SocketProtocol(_cret)

	return _socketProtocol
}

func (c socketClient) ProXYResolver() ProXYResolver {
	var _arg0 *C.GSocketClient  // out
	var _cret *C.GProxyResolver // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_client_get_proxy_resolver(_arg0)

	var _proxyResolver ProXYResolver // out

	_proxyResolver = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ProXYResolver)

	return _proxyResolver
}

func (c socketClient) SocketType() SocketType {
	var _arg0 *C.GSocketClient // out
	var _cret C.GSocketType    // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_client_get_socket_type(_arg0)

	var _socketType SocketType // out

	_socketType = SocketType(_cret)

	return _socketType
}

func (c socketClient) Timeout() uint {
	var _arg0 *C.GSocketClient // out
	var _cret C.guint          // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_client_get_timeout(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (c socketClient) TLS() bool {
	var _arg0 *C.GSocketClient // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_client_get_tls(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c socketClient) TLSValidationFlags() TLSCertificateFlags {
	var _arg0 *C.GSocketClient       // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_client_get_tls_validation_flags(_arg0)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

func (c socketClient) SetEnableProXY(enable bool) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.g_socket_client_set_enable_proxy(_arg0, _arg1)
}

func (c socketClient) SetFamily(family SocketFamily) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.GSocketFamily  // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GSocketFamily)(family)

	C.g_socket_client_set_family(_arg0, _arg1)
}

func (c socketClient) SetLocalAddress(address SocketAddress) {
	var _arg0 *C.GSocketClient  // out
	var _arg1 *C.GSocketAddress // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))

	C.g_socket_client_set_local_address(_arg0, _arg1)
}

func (c socketClient) SetProtocol(protocol SocketProtocol) {
	var _arg0 *C.GSocketClient  // out
	var _arg1 C.GSocketProtocol // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GSocketProtocol)(protocol)

	C.g_socket_client_set_protocol(_arg0, _arg1)
}

func (c socketClient) SetProXYResolver(proxyResolver ProXYResolver) {
	var _arg0 *C.GSocketClient  // out
	var _arg1 *C.GProxyResolver // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GProxyResolver)(unsafe.Pointer(proxyResolver.Native()))

	C.g_socket_client_set_proxy_resolver(_arg0, _arg1)
}

func (c socketClient) SetSocketType(typ SocketType) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.GSocketType    // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GSocketType)(typ)

	C.g_socket_client_set_socket_type(_arg0, _arg1)
}

func (c socketClient) SetTimeout(timeout uint) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(timeout)

	C.g_socket_client_set_timeout(_arg0, _arg1)
}

func (c socketClient) SetTLS(tls bool) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	if tls {
		_arg1 = C.TRUE
	}

	C.g_socket_client_set_tls(_arg0, _arg1)
}

func (c socketClient) SetTLSValidationFlags(flags TLSCertificateFlags) {
	var _arg0 *C.GSocketClient       // out
	var _arg1 C.GTlsCertificateFlags // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GTlsCertificateFlags)(flags)

	C.g_socket_client_set_tls_validation_flags(_arg0, _arg1)
}

// SocketConnection is a OStream for a connected socket. They can be created
// either by Client when connecting to a host, or by Listener when accepting a
// new client.
//
// The type of the Connection object returned from these calls depends on the
// type of the underlying socket that is in use. For instance, for a TCP/IP
// connection it will be a Connection.
//
// Choosing what type of object to construct is done with the socket connection
// factory, and it is possible for 3rd parties to register custom socket
// connection types for specific combination of socket family/type/protocol
// using g_socket_connection_factory_register_type().
//
// To close a Connection, use g_io_stream_close(). Closing both substreams of
// the OStream separately will not close the underlying #GSocket.
type SocketConnection interface {
	IOStream

	// ConnectSocketConnection: connect @connection to the specified remote
	// address.
	ConnectSocketConnection(address SocketAddress, cancellable Cancellable) error
	// ConnectFinish gets the result of a g_socket_connection_connect_async()
	// call.
	ConnectFinish(result AsyncResult) error
	// LocalAddress: try to get the local address of a socket connection.
	LocalAddress() (SocketAddress, error)
	// RemoteAddress: try to get the remote address of a socket connection.
	//
	// Since GLib 2.40, when used with g_socket_client_connect() or
	// g_socket_client_connect_async(), during emission of
	// G_SOCKET_CLIENT_CONNECTING, this function will return the remote address
	// that will be used for the connection. This allows applications to print
	// e.g. "Connecting to example.com (10.42.77.3)...".
	RemoteAddress() (SocketAddress, error)
	// Socket gets the underlying #GSocket object of the connection. This can be
	// useful if you want to do something unusual on it not supported by the
	// Connection APIs.
	Socket() Socket
	// IsConnected checks if @connection is connected. This is equivalent to
	// calling g_socket_is_connected() on @connection's underlying #GSocket.
	IsConnected() bool
}

// socketConnection implements the SocketConnection class.
type socketConnection struct {
	IOStream
}

var _ SocketConnection = (*socketConnection)(nil)

// WrapSocketConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketConnection(obj *externglib.Object) SocketConnection {
	return socketConnection{
		IOStream: WrapIOStream(obj),
	}
}

func marshalSocketConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketConnection(obj), nil
}

func (c socketConnection) ConnectSocketConnection(address SocketAddress, cancellable Cancellable) error {
	var _arg0 *C.GSocketConnection // out
	var _arg1 *C.GSocketAddress    // out
	var _arg2 *C.GCancellable      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_socket_connection_connect(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c socketConnection) ConnectFinish(result AsyncResult) error {
	var _arg0 *C.GSocketConnection // out
	var _arg1 *C.GAsyncResult      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_socket_connection_connect_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c socketConnection) LocalAddress() (SocketAddress, error) {
	var _arg0 *C.GSocketConnection // out
	var _cret *C.GSocketAddress    // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_connection_get_local_address(_arg0, &_cerr)

	var _socketAddress SocketAddress // out
	var _goerr error                 // out

	_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketAddress, _goerr
}

func (c socketConnection) RemoteAddress() (SocketAddress, error) {
	var _arg0 *C.GSocketConnection // out
	var _cret *C.GSocketAddress    // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_connection_get_remote_address(_arg0, &_cerr)

	var _socketAddress SocketAddress // out
	var _goerr error                 // out

	_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketAddress, _goerr
}

func (c socketConnection) Socket() Socket {
	var _arg0 *C.GSocketConnection // out
	var _cret *C.GSocket           // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_connection_get_socket(_arg0)

	var _socket Socket // out

	_socket = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Socket)

	return _socket
}

func (c socketConnection) IsConnected() bool {
	var _arg0 *C.GSocketConnection // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_socket_connection_is_connected(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SocketControlMessage: a ControlMessage is a special-purpose utility message
// that can be sent to or received from a #GSocket. These types of messages are
// often called "ancillary data".
//
// The message can represent some sort of special instruction to or information
// from the socket or can represent a special kind of transfer to the peer (for
// example, sending a file descriptor over a UNIX socket).
//
// These messages are sent with g_socket_send_message() and received with
// g_socket_receive_message().
//
// To extend the set of control message that can be sent, subclass this class
// and override the get_size, get_level, get_type and serialize methods.
//
// To extend the set of control messages that can be received, subclass this
// class and implement the deserialize method. Also, make sure your class is
// registered with the GType typesystem before calling
// g_socket_receive_message() to read such a message.
type SocketControlMessage interface {
	gextras.Objector

	// Level returns the "level" (i.e. the originating protocol) of the control
	// message. This is often SOL_SOCKET.
	Level() int
	// MsgType returns the protocol specific type of the control message. For
	// instance, for UNIX fd passing this would be SCM_RIGHTS.
	MsgType() int
	// Size returns the space required for the control message, not including
	// headers or alignment.
	Size() uint
}

// socketControlMessage implements the SocketControlMessage class.
type socketControlMessage struct {
	gextras.Objector
}

var _ SocketControlMessage = (*socketControlMessage)(nil)

// WrapSocketControlMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketControlMessage(obj *externglib.Object) SocketControlMessage {
	return socketControlMessage{
		Objector: obj,
	}
}

func marshalSocketControlMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketControlMessage(obj), nil
}

func (m socketControlMessage) Level() int {
	var _arg0 *C.GSocketControlMessage // out
	var _cret C.int                    // in

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_socket_control_message_get_level(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (m socketControlMessage) MsgType() int {
	var _arg0 *C.GSocketControlMessage // out
	var _cret C.int                    // in

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_socket_control_message_get_msg_type(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (m socketControlMessage) Size() uint {
	var _arg0 *C.GSocketControlMessage // out
	var _cret C.gsize                  // in

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_socket_control_message_get_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// SocketListener: a Listener is an object that keeps track of a set of server
// sockets and helps you accept sockets from any of the socket, either sync or
// async.
//
// Add addresses and ports to listen on using g_socket_listener_add_address()
// and g_socket_listener_add_inet_port(). These will be listened on until
// g_socket_listener_close() is called. Dropping your final reference to the
// Listener will not cause g_socket_listener_close() to be called implicitly, as
// some references to the Listener may be held internally.
//
// If you want to implement a network server, also look at Service and
// SocketService which are subclasses of Listener that make this even easier.
type SocketListener interface {
	gextras.Objector

	// Accept blocks waiting for a client to connect to any of the sockets added
	// to the listener. Returns a Connection for the socket that was accepted.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Accept(cancellable Cancellable) (gextras.Objector, SocketConnection, error)
	// AcceptFinish finishes an async accept operation. See
	// g_socket_listener_accept_async()
	AcceptFinish(result AsyncResult) (gextras.Objector, SocketConnection, error)
	// AcceptSocket blocks waiting for a client to connect to any of the sockets
	// added to the listener. Returns the #GSocket that was accepted.
	//
	// If you want to accept the high-level Connection, not a #GSocket, which is
	// often the case, then you should use g_socket_listener_accept() instead.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	AcceptSocket(cancellable Cancellable) (gextras.Objector, Socket, error)
	// AcceptSocketFinish finishes an async accept operation. See
	// g_socket_listener_accept_socket_async()
	AcceptSocketFinish(result AsyncResult) (gextras.Objector, Socket, error)
	// AddAddress creates a socket of type @type and protocol @protocol, binds
	// it to @address and adds it to the set of sockets we're accepting sockets
	// from.
	//
	// Note that adding an IPv6 address, depending on the platform, may or may
	// not result in a listener that also accepts IPv4 connections. For more
	// deterministic behavior, see g_socket_listener_add_inet_port().
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// If successful and @effective_address is non-nil then it will be set to
	// the address that the binding actually occurred at. This is helpful for
	// determining the port number that was used for when requesting a binding
	// to port 0 (ie: "any port"). This address, if requested, belongs to the
	// caller and must be freed.
	//
	// Call g_socket_listener_close() to stop listening on @address; this will
	// not be done automatically when you drop your final reference to
	// @listener, as references may be held internally.
	AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (SocketAddress, error)
	// AddAnyInetPort listens for TCP connections on any available port number
	// for both IPv6 and IPv4 (if each is available).
	//
	// This is useful if you need to have a socket for incoming connections but
	// don't care about the specific port number.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	AddAnyInetPort(sourceObject gextras.Objector) (uint16, error)
	// AddInetPort: helper function for g_socket_listener_add_address() that
	// creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the
	// specified port on all interfaces.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// Call g_socket_listener_close() to stop listening on @port; this will not
	// be done automatically when you drop your final reference to @listener, as
	// references may be held internally.
	AddInetPort(port uint16, sourceObject gextras.Objector) error
	// AddSocket adds @socket to the set of sockets that we try to accept new
	// clients from. The socket must be bound to a local address and listened
	// to.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// The @socket will not be automatically closed when the @listener is
	// finalized unless the listener held the final reference to the socket.
	// Before GLib 2.42, the @socket was automatically closed on finalization of
	// the @listener, even if references to it were held elsewhere.
	AddSocket(socket Socket, sourceObject gextras.Objector) error
	// Close closes all the sockets in the listener.
	Close()
	// SetBacklog sets the listen backlog on the sockets in the listener. This
	// must be called before adding any sockets, addresses or ports to the
	// Listener (for example, by calling g_socket_listener_add_inet_port()) to
	// be effective.
	//
	// See g_socket_set_listen_backlog() for details
	SetBacklog(listenBacklog int)
}

// socketListener implements the SocketListener class.
type socketListener struct {
	gextras.Objector
}

var _ SocketListener = (*socketListener)(nil)

// WrapSocketListener wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketListener(obj *externglib.Object) SocketListener {
	return socketListener{
		Objector: obj,
	}
}

func marshalSocketListener(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketListener(obj), nil
}

// NewSocketListener creates a new Listener with no sockets to listen for. New
// listeners can be added with e.g. g_socket_listener_add_address() or
// g_socket_listener_add_inet_port().
func NewSocketListener() SocketListener {
	var _cret *C.GSocketListener // in

	_cret = C.g_socket_listener_new()

	var _socketListener SocketListener // out

	_socketListener = WrapSocketListener(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _socketListener
}

func (l socketListener) Accept(cancellable Cancellable) (gextras.Objector, SocketConnection, error) {
	var _arg0 *C.GSocketListener   // out
	var _arg1 *C.GObject           // in
	var _arg2 *C.GCancellable      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_listener_accept(_arg0, &_arg1, _arg2, &_cerr)

	var _sourceObject gextras.Objector     // out
	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_sourceObject = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(gextras.Objector)
	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _sourceObject, _socketConnection, _goerr
}

func (l socketListener) AcceptFinish(result AsyncResult) (gextras.Objector, SocketConnection, error) {
	var _arg0 *C.GSocketListener   // out
	var _arg1 *C.GAsyncResult      // out
	var _arg2 *C.GObject           // in
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_socket_listener_accept_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _sourceObject gextras.Objector     // out
	var _socketConnection SocketConnection // out
	var _goerr error                       // out

	_sourceObject = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(gextras.Objector)
	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _sourceObject, _socketConnection, _goerr
}

func (l socketListener) AcceptSocket(cancellable Cancellable) (gextras.Objector, Socket, error) {
	var _arg0 *C.GSocketListener // out
	var _arg1 *C.GObject         // in
	var _arg2 *C.GCancellable    // out
	var _cret *C.GSocket         // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_listener_accept_socket(_arg0, &_arg1, _arg2, &_cerr)

	var _sourceObject gextras.Objector // out
	var _socket Socket                 // out
	var _goerr error                   // out

	_sourceObject = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(gextras.Objector)
	_socket = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _sourceObject, _socket, _goerr
}

func (l socketListener) AcceptSocketFinish(result AsyncResult) (gextras.Objector, Socket, error) {
	var _arg0 *C.GSocketListener // out
	var _arg1 *C.GAsyncResult    // out
	var _arg2 *C.GObject         // in
	var _cret *C.GSocket         // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_socket_listener_accept_socket_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _sourceObject gextras.Objector // out
	var _socket Socket                 // out
	var _goerr error                   // out

	_sourceObject = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(gextras.Objector)
	_socket = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _sourceObject, _socket, _goerr
}

func (l socketListener) AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (SocketAddress, error) {
	var _arg0 *C.GSocketListener // out
	var _arg1 *C.GSocketAddress  // out
	var _arg2 C.GSocketType      // out
	var _arg3 C.GSocketProtocol  // out
	var _arg4 *C.GObject         // out
	var _arg5 *C.GSocketAddress  // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg2 = (C.GSocketType)(typ)
	_arg3 = (C.GSocketProtocol)(protocol)
	_arg4 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	C.g_socket_listener_add_address(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)

	var _effectiveAddress SocketAddress // out
	var _goerr error                    // out

	_effectiveAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg5))).(SocketAddress)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _effectiveAddress, _goerr
}

func (l socketListener) AddAnyInetPort(sourceObject gextras.Objector) (uint16, error) {
	var _arg0 *C.GSocketListener // out
	var _arg1 *C.GObject         // out
	var _cret C.guint16          // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	_cret = C.g_socket_listener_add_any_inet_port(_arg0, _arg1, &_cerr)

	var _guint16 uint16 // out
	var _goerr error    // out

	_guint16 = (uint16)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint16, _goerr
}

func (l socketListener) AddInetPort(port uint16, sourceObject gextras.Objector) error {
	var _arg0 *C.GSocketListener // out
	var _arg1 C.guint16          // out
	var _arg2 *C.GObject         // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	_arg1 = (C.guint16)(port)
	_arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	C.g_socket_listener_add_inet_port(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (l socketListener) AddSocket(socket Socket, sourceObject gextras.Objector) error {
	var _arg0 *C.GSocketListener // out
	var _arg1 *C.GSocket         // out
	var _arg2 *C.GObject         // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GSocket)(unsafe.Pointer(socket.Native()))
	_arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	C.g_socket_listener_add_socket(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (l socketListener) Close() {
	var _arg0 *C.GSocketListener // out

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))

	C.g_socket_listener_close(_arg0)
}

func (l socketListener) SetBacklog(listenBacklog int) {
	var _arg0 *C.GSocketListener // out
	var _arg1 C.int              // out

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(listenBacklog)

	C.g_socket_listener_set_backlog(_arg0, _arg1)
}

// SocketService: a Service is an object that represents a service that is
// provided to the network or over local sockets. When a new connection is made
// to the service the Service::incoming signal is emitted.
//
// A Service is a subclass of Listener and you need to add the addresses you
// want to accept connections on with the Listener APIs.
//
// There are two options for implementing a network service based on Service.
// The first is to create the service using g_socket_service_new() and to
// connect to the Service::incoming signal. The second is to subclass Service
// and override the default signal handler implementation.
//
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested in
// writing connection handlers that contain blocking code then see
// SocketService.
//
// The socket service runs on the main loop of the [thread-default
// context][g-main-context-push-thread-default-context] of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
type SocketService interface {
	SocketListener

	// IsActive: check whether the service is active or not. An active service
	// will accept new clients that connect, while a non-active service will let
	// connecting clients queue up until the service is started.
	IsActive() bool
	// Start restarts the service, i.e. start accepting connections from the
	// added sockets when the mainloop runs. This only needs to be called after
	// the service has been stopped from g_socket_service_stop().
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	Start()
	// Stop stops the service, i.e. stops accepting connections from the added
	// sockets when the mainloop runs.
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	//
	// Note that this only stops accepting new connections; it does not close
	// the listening sockets, and you can call g_socket_service_start() again
	// later to begin listening again. To close the listening sockets, call
	// g_socket_listener_close(). (This will happen automatically when the
	// Service is finalized.)
	//
	// This must be called before calling g_socket_listener_close() as the
	// socket service will start accepting connections immediately when a new
	// socket is added.
	Stop()
}

// socketService implements the SocketService class.
type socketService struct {
	SocketListener
}

var _ SocketService = (*socketService)(nil)

// WrapSocketService wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketService(obj *externglib.Object) SocketService {
	return socketService{
		SocketListener: WrapSocketListener(obj),
	}
}

func marshalSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketService(obj), nil
}

// NewSocketService creates a new Service with no sockets to listen for. New
// listeners can be added with e.g. g_socket_listener_add_address() or
// g_socket_listener_add_inet_port().
//
// New services are created active, there is no need to call
// g_socket_service_start(), unless g_socket_service_stop() has been called
// before.
func NewSocketService() SocketService {
	var _cret *C.GSocketService // in

	_cret = C.g_socket_service_new()

	var _socketService SocketService // out

	_socketService = WrapSocketService(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _socketService
}

func (s socketService) IsActive() bool {
	var _arg0 *C.GSocketService // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GSocketService)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_service_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socketService) Start() {
	var _arg0 *C.GSocketService // out

	_arg0 = (*C.GSocketService)(unsafe.Pointer(s.Native()))

	C.g_socket_service_start(_arg0)
}

func (s socketService) Stop() {
	var _arg0 *C.GSocketService // out

	_arg0 = (*C.GSocketService)(unsafe.Pointer(s.Native()))

	C.g_socket_service_stop(_arg0)
}

// Subprocess allows the creation of and interaction with child processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess interface {
	gextras.Objector
	Initable

	// CommunicateUTF8: like g_subprocess_communicate(), but validates the
	// output of the process as UTF-8, and returns it as a regular NUL
	// terminated string.
	//
	// On error, @stdout_buf and @stderr_buf will be set to undefined values and
	// should not be used.
	CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, goerr error)
	// CommunicateUTF8Finish: complete an invocation of
	// g_subprocess_communicate_utf8_async().
	CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, goerr error)
	// ForceExit: use an operating-system specific method to attempt an
	// immediate, forceful termination of the process. There is no mechanism to
	// determine whether or not the request itself was successful; however, you
	// can use g_subprocess_wait() to monitor the status of the process after
	// calling this function.
	//
	// On Unix, this function sends SIGKILL.
	ForceExit()
	// ExitStatus: check the exit status of the subprocess, given that it exited
	// normally. This is the value passed to the exit() system call or the
	// return value from main.
	//
	// This is equivalent to the system WEXITSTATUS macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_exited() returned true.
	ExitStatus() int
	// Identifier: on UNIX, returns the process ID as a decimal string. On
	// Windows, returns the result of GetProcessId() also as a string. If the
	// subprocess has terminated, this will return nil.
	Identifier() string
	// IfExited: check if the given subprocess exited normally (ie: by way of
	// exit() or return from main()).
	//
	// This is equivalent to the system WIFEXITED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfExited() bool
	// IfSignaled: check if the given subprocess terminated in response to a
	// signal.
	//
	// This is equivalent to the system WIFSIGNALED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfSignaled() bool
	// Status gets the raw status code of the process, as from waitpid().
	//
	// This value has no particular meaning, but it can be used with the macros
	// defined by the system headers such as WIFEXITED. It can also be used with
	// g_spawn_check_exit_status().
	//
	// It is more likely that you want to use g_subprocess_get_if_exited()
	// followed by g_subprocess_get_exit_status().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Status() int
	// StderrPipe gets the Stream from which to read the stderr output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE,
	// otherwise nil will be returned.
	StderrPipe() InputStream
	// StdinPipe gets the Stream that you can write to in order to give data to
	// the stdin of @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE and
	// not G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise nil will be returned.
	StdinPipe() OutputStream
	// StdoutPipe gets the Stream from which to read the stdout output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
	// otherwise nil will be returned.
	StdoutPipe() InputStream
	// Successful checks if the process was "successful". A process is
	// considered successful if it exited cleanly with an exit status of 0,
	// either by way of the exit() system call or return from main().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Successful() bool
	// TermSig: get the signal number that caused the subprocess to terminate,
	// given that it terminated due to a signal.
	//
	// This is equivalent to the system WTERMSIG macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_signaled() returned true.
	TermSig() int
	// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
	// still running.
	//
	// This API is race-free. If the subprocess has terminated, it will not be
	// signalled.
	//
	// This API is not available on Windows.
	SendSignal(signalNum int)
	// Wait: synchronously wait for the subprocess to terminate.
	//
	// After the process terminates you can query its exit status with functions
	// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
	//
	// This function does not fail in the case of the subprocess having abnormal
	// termination. See g_subprocess_wait_check() for that.
	//
	// Cancelling @cancellable doesn't kill the subprocess. Call
	// g_subprocess_force_exit() if it is desirable.
	Wait(cancellable Cancellable) error
	// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
	WaitCheck(cancellable Cancellable) error
	// WaitCheckFinish collects the result of a previous call to
	// g_subprocess_wait_check_async().
	WaitCheckFinish(result AsyncResult) error
	// WaitFinish collects the result of a previous call to
	// g_subprocess_wait_async().
	WaitFinish(result AsyncResult) error
}

// subprocess implements the Subprocess class.
type subprocess struct {
	gextras.Objector
	Initable
}

var _ Subprocess = (*subprocess)(nil)

// WrapSubprocess wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocess(obj *externglib.Object) Subprocess {
	return subprocess{
		Objector: obj,
		Initable: WrapInitable(obj),
	}
}

func marshalSubprocess(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocess(obj), nil
}

// NewSubprocessV: create a new process with the given flags and argument list.
//
// The argument list is expected to be nil-terminated.
func NewSubprocessV(argv []string, flags SubprocessFlags) (Subprocess, error) {
	var _arg1 **C.gchar
	var _arg2 C.GSubprocessFlags // out
	var _cret *C.GSubprocess     // in
	var _cerr *C.GError          // in

	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = (C.GSubprocessFlags)(flags)

	_cret = C.g_subprocess_newv(_arg1, _arg2, &_cerr)

	var _subprocess Subprocess // out
	var _goerr error           // out

	_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Subprocess)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _subprocess, _goerr
}

func (s subprocess) CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.char         // out
	var _arg2 *C.GCancellable // out
	var _arg3 *C.char         // in
	var _arg4 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_subprocess_communicate_utf8(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_stderrBuf = C.GoString(_arg4)
	defer C.free(unsafe.Pointer(_arg4))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

func (s subprocess) CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _arg3 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_communicate_utf8_finish(_arg0, _arg1, &_arg2, &_arg3, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_stderrBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

func (s subprocess) ForceExit() {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	C.g_subprocess_force_exit(_arg0)
}

func (s subprocess) ExitStatus() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_exit_status(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s subprocess) Identifier() string {
	var _arg0 *C.GSubprocess // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_identifier(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s subprocess) IfExited() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_if_exited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s subprocess) IfSignaled() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_if_signaled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s subprocess) Status() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_status(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s subprocess) StderrPipe() InputStream {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_stderr_pipe(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

	return _inputStream
}

func (s subprocess) StdinPipe() OutputStream {
	var _arg0 *C.GSubprocess   // out
	var _cret *C.GOutputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_stdin_pipe(_arg0)

	var _outputStream OutputStream // out

	_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(OutputStream)

	return _outputStream
}

func (s subprocess) StdoutPipe() InputStream {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_stdout_pipe(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

	return _inputStream
}

func (s subprocess) Successful() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_successful(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s subprocess) TermSig() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_term_sig(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s subprocess) SendSignal(signalNum int) {
	var _arg0 *C.GSubprocess // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(signalNum)

	C.g_subprocess_send_signal(_arg0, _arg1)
}

func (s subprocess) Wait(cancellable Cancellable) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_subprocess_wait(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s subprocess) WaitCheck(cancellable Cancellable) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_subprocess_wait_check(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s subprocess) WaitCheckFinish(result AsyncResult) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_wait_check_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s subprocess) WaitFinish(result AsyncResult) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_wait_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher interface {
	gextras.Objector

	// Close closes all the file descriptors previously passed to the object
	// with g_subprocess_launcher_take_fd(),
	// g_subprocess_launcher_take_stderr_fd(), etc.
	//
	// After calling this method, any subsequent calls to
	// g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
	// return G_IO_ERROR_CLOSED. This method is idempotent if called more than
	// once.
	//
	// This function is called automatically when the Launcher is disposed, but
	// is provided separately so that garbage collected language bindings can
	// call it earlier to guarantee when FDs are closed.
	Close()
	// env returns the value of the environment variable @variable in the
	// environment of processes launched from this launcher.
	//
	// On UNIX, the returned string can be an arbitrary byte string. On Windows,
	// it will be UTF-8.
	env(variable string) string
	// SetCwd sets the current working directory that processes will be launched
	// with.
	//
	// By default processes are launched with the current working directory of
	// the launching process at the time of launch.
	SetCwd(cwd string)
	// SetEnviron: replace the entire environment of processes launched from
	// this launcher with the given 'environ' variable.
	//
	// Typically you will build this variable by using g_listenv() to copy the
	// process 'environ' and using the functions g_environ_setenv(),
	// g_environ_unsetenv(), etc.
	//
	// As an alternative, you can use g_subprocess_launcher_setenv(),
	// g_subprocess_launcher_unsetenv(), etc.
	//
	// Pass an empty array to set an empty environment. Pass nil to inherit the
	// parent process environment. As of GLib 2.54, the parent process
	// environment will be copied when g_subprocess_launcher_set_environ() is
	// called. Previously, it was copied when the subprocess was executed. This
	// means the copied environment may now be modified (using
	// g_subprocess_launcher_setenv(), etc.) before launching the subprocess.
	//
	// On UNIX, all strings in this array can be arbitrary byte strings. On
	// Windows, they should be in UTF-8.
	SetEnviron(env []string)
	// SetFlags sets the flags on the launcher.
	//
	// The default flags are G_SUBPROCESS_FLAGS_NONE.
	//
	// You may not set flags that specify conflicting options for how to handle
	// a particular stdio stream (eg: specifying both
	// G_SUBPROCESS_FLAGS_STDIN_PIPE and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
	//
	// You may also not set a flag that conflicts with a previous call to a
	// function like g_subprocess_launcher_set_stdin_file_path() or
	// g_subprocess_launcher_take_stdout_fd().
	SetFlags(flags SubprocessFlags)
	// SetStderrFilePath sets the file path to use as the stderr for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '2>' at the shell.
	//
	// If you want to send both stdout and stderr to the same file then use
	// G_SUBPROCESS_FLAGS_STDERR_MERGE.
	//
	// You may not set a stderr file path if a stderr fd is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	SetStderrFilePath(path string)
	// SetStdinFilePath sets the file path to use as the stdin for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file must exist or spawning the process will fail.
	//
	// You may not set a stdin file path if a stdin fd is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdinFilePath(path string)
	// SetStdoutFilePath sets the file path to use as the stdout for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '>' at the shell.
	//
	// You may not set a stdout file path if a stdout fd is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdoutFilePath(path string)
	// Setenv sets the environment variable @variable in the environment of
	// processes launched from this launcher.
	//
	// On UNIX, both the variable's name and value can be arbitrary byte
	// strings, except that the variable's name cannot contain '='. On Windows,
	// they should be in UTF-8.
	Setenv(variable string, value string, overwrite bool)
	// Spawnv creates a #GSubprocess given a provided array of arguments.
	Spawnv(argv []string) (Subprocess, error)
	// TakeFd: transfer an arbitrary file descriptor from parent process to the
	// child. This function takes ownership of the @source_fd; it will be closed
	// in the parent when @self is freed.
	//
	// By default, all file descriptors from the parent will be closed. This
	// function allows you to create (for example) a custom `pipe()` or
	// `socketpair()` before launching the process, and choose the target
	// descriptor in the child.
	//
	// An example use case is GNUPG, which has a command line argument
	// `--passphrase-fd` providing a file descriptor number where it expects the
	// passphrase to be written.
	TakeFd(sourceFd int, targetFd int)
	// TakeStderrFd sets the file descriptor to use as the stderr for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stderr through to the stderr
	// of the parent process.
	//
	// The passed @fd belongs to the Launcher. It will be automatically closed
	// when the launcher is finalized. The file descriptor will also be closed
	// on the child side when executing the spawned process.
	//
	// You may not set a stderr fd if a stderr file path is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStderrFd(fd int)
	// TakeStdinFd sets the file descriptor to use as the stdin for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that if your intention is to have the stdin of the calling process
	// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better
	// way to go about doing that.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdin fd if a stdin file path is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdinFd(fd int)
	// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stdout through to the stdout
	// of the parent process.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdout fd if a stdout file path is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdoutFd(fd int)
	// Unsetenv removes the environment variable @variable from the environment
	// of processes launched from this launcher.
	//
	// On UNIX, the variable's name can be an arbitrary byte string not
	// containing '='. On Windows, it should be in UTF-8.
	Unsetenv(variable string)
}

// subprocessLauncher implements the SubprocessLauncher class.
type subprocessLauncher struct {
	gextras.Objector
}

var _ SubprocessLauncher = (*subprocessLauncher)(nil)

// WrapSubprocessLauncher wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocessLauncher(obj *externglib.Object) SubprocessLauncher {
	return subprocessLauncher{
		Objector: obj,
	}
}

func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocessLauncher(obj), nil
}

// NewSubprocessLauncher creates a new Launcher.
//
// The launcher is created with the default options. A copy of the environment
// of the calling process is made at the time of this call and will be used as
// the environment that the process is launched in.
func NewSubprocessLauncher(flags SubprocessFlags) SubprocessLauncher {
	var _arg1 C.GSubprocessFlags     // out
	var _cret *C.GSubprocessLauncher // in

	_arg1 = (C.GSubprocessFlags)(flags)

	_cret = C.g_subprocess_launcher_new(_arg1)

	var _subprocessLauncher SubprocessLauncher // out

	_subprocessLauncher = WrapSubprocessLauncher(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _subprocessLauncher
}

func (s subprocessLauncher) Close() {
	var _arg0 *C.GSubprocessLauncher // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))

	C.g_subprocess_launcher_close(_arg0)
}

func (s subprocessLauncher) env(variable string) string {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_subprocess_launcher_getenv(_arg0, _arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (s subprocessLauncher) SetCwd(cwd string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(cwd))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_cwd(_arg0, _arg1)
}

func (s subprocessLauncher) SetEnviron(env []string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(env)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(env))
		for i := range env {
			out[i] = (*C.gchar)(C.CString(env[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_subprocess_launcher_set_environ(_arg0, _arg1)
}

func (s subprocessLauncher) SetFlags(flags SubprocessFlags) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.GSubprocessFlags     // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GSubprocessFlags)(flags)

	C.g_subprocess_launcher_set_flags(_arg0, _arg1)
}

func (s subprocessLauncher) SetStderrFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stderr_file_path(_arg0, _arg1)
}

func (s subprocessLauncher) SetStdinFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdin_file_path(_arg0, _arg1)
}

func (s subprocessLauncher) SetStdoutFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdout_file_path(_arg0, _arg1)
}

func (s subprocessLauncher) Setenv(variable string, value string, overwrite bool) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 C.gboolean             // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))
	if overwrite {
		_arg3 = C.TRUE
	}

	C.g_subprocess_launcher_setenv(_arg0, _arg1, _arg2, _arg3)
}

func (s subprocessLauncher) Spawnv(argv []string) (Subprocess, error) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar
	var _cret *C.GSubprocess // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_subprocess_launcher_spawnv(_arg0, _arg1, &_cerr)

	var _subprocess Subprocess // out
	var _goerr error           // out

	_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Subprocess)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _subprocess, _goerr
}

func (s subprocessLauncher) TakeFd(sourceFd int, targetFd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out
	var _arg2 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(sourceFd)
	_arg2 = (C.gint)(targetFd)

	C.g_subprocess_launcher_take_fd(_arg0, _arg1, _arg2)
}

func (s subprocessLauncher) TakeStderrFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(fd)

	C.g_subprocess_launcher_take_stderr_fd(_arg0, _arg1)
}

func (s subprocessLauncher) TakeStdinFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(fd)

	C.g_subprocess_launcher_take_stdin_fd(_arg0, _arg1)
}

func (s subprocessLauncher) TakeStdoutFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(fd)

	C.g_subprocess_launcher_take_stdout_fd(_arg0, _arg1)
}

func (s subprocessLauncher) Unsetenv(variable string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_unsetenv(_arg0, _arg1)
}

// Task: a #GTask represents and manages a cancellable "task".
//
//
// Asynchronous operations
//
// The most common usage of #GTask is as a Result, to manage data during an
// asynchronous operation. You call g_task_new() in the "start" method, followed
// by g_task_set_task_data() and the like if you need to keep some additional
// data associated with the task, and then pass the task object around through
// your asynchronous operation. Eventually, you will call a method such as
// g_task_return_pointer() or g_task_return_error(), which will save the value
// you give it and then invoke the task's callback function in the
// [thread-default main context][g-main-context-push-thread-default] where it
// was created (waiting until the next iteration of the main loop first, if
// necessary). The caller will pass the #GTask back to the operation's finish
// function (as a Result), and you can use g_task_propagate_pointer() or the
// like to extract the return value.
//
// Here is an example for using GTask as a GAsyncResult:
//
//        static void
//        bake_cake_thread (GTask         *task,
//                          gpointer       source_object,
//                          gpointer       task_data,
//                          GCancellable  *cancellable)
//        {
//          Baker *self = source_object;
//          CakeData *cake_data = task_data;
//          Cake *cake;
//          GError *error = NULL;
//
//          cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//                            cake_data->frosting, cake_data->message,
//                            &error);
//          if (error)
//            {
//              g_task_return_error (task, error);
//              return;
//            }
//
//          // If the task has already been cancelled, then we don't want to add
//          // the cake to the cake cache. Likewise, we don't  want to have the
//          // task get cancelled in the middle of updating the cache.
//          // g_task_set_return_on_cancel() will return true here if it managed
//          // to disable return-on-cancel, or false if the task was cancelled
//          // before it could.
//          if (g_task_set_return_on_cancel (task, FALSE))
//            {
//              // If the caller cancels at this point, their
//              // GAsyncReadyCallback won't be invoked until we return,
//              // so we don't have to worry that this code will run at
//              // the same time as that code does. But if there were
//              // other functions that might look at the cake cache,
//              // then we'd probably need a GMutex here as well.
//              baker_add_cake_to_cache (baker, cake);
//              g_task_return_pointer (task, cake, g_object_unref);
//            }
//        }
//
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          CakeData *cake_data;
//          GTask *task;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread (task, bake_cake_thread);
//        }
//
//        Cake *
//        baker_bake_cake_sync (Baker               *self,
//                              guint                radius,
//                              CakeFlavor           flavor,
//                              CakeFrostingType     frosting,
//                              const char          *message,
//                              GCancellable        *cancellable,
//                              GError             **error)
//        {
//          CakeData *cake_data;
//          GTask *task;
//          Cake *cake;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, NULL, NULL);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread_sync (task, bake_cake_thread);
//
//          cake = g_task_propagate_pointer (task, error);
//          g_object_unref (task);
//          return cake;
//        }
//
//
// Porting from GSimpleAsyncResult
//
// #GTask's API attempts to be simpler than AsyncResult's in several ways: - You
// can save task-specific data with g_task_set_task_data(), and retrieve it
// later with g_task_get_task_data(). This replaces the abuse of
// g_simple_async_result_set_op_res_gpointer() for the same purpose with
// AsyncResult. - In addition to the task data, #GTask also keeps track of the
// [priority][io-priority], #GCancellable, and Context associated with the task,
// so tasks that consist of a chain of simpler asynchronous operations will have
// easy access to those values when starting each sub-task. -
// g_task_return_error_if_cancelled() provides simplified handling for
// cancellation. In addition, cancellation overrides any other #GTask return
// value by default, like AsyncResult does when
// g_simple_async_result_set_check_cancellable() is called. (You can use
// g_task_set_check_cancellable() to turn off that behavior.) On the other hand,
// g_task_run_in_thread() guarantees that it will always run your `task_func`,
// even if the task's #GCancellable is already cancelled before the task gets a
// chance to run; you can start your `task_func` with a
// g_task_return_error_if_cancelled() check if you need the old behavior. - The
// "return" methods (eg, g_task_return_pointer()) automatically cause the task
// to be "completed" as well, and there is no need to worry about the "complete"
// vs "complete in idle" distinction. (#GTask automatically figures out whether
// the task's callback can be invoked directly, or if it needs to be sent to
// another Context, or delayed until the next iteration of the current Context.)
// - The "finish" functions for #GTask based operations are generally much
// simpler than AsyncResult ones, normally consisting of only a single call to
// g_task_propagate_pointer() or the like. Since g_task_propagate_pointer()
// "steals" the return value from the #GTask, it is not necessary to juggle
// pointers around to prevent it from being freed twice. - With AsyncResult, it
// was common to call g_simple_async_result_propagate_error() from the
// `_finish()` wrapper function, and have virtual method implementations only
// deal with successful returns. This behavior is deprecated, because it makes
// it difficult for a subclass to chain to a parent class's async methods.
// Instead, the wrapper function should just be a simple wrapper, and the
// virtual method should call an appropriate `g_task_propagate_` function. Note
// that wrapper methods can now use g_async_result_legacy_propagate_error() to
// do old-style AsyncResult error-returning behavior, and
// g_async_result_is_tagged() to check if a result is tagged as having come from
// the `_async()` wrapper function (for "short-circuit" results, such as when
// passing 0 to g_input_stream_read_async()).
type Task interface {
	gextras.Objector
	AsyncResult

	// Cancellable gets @task's #GCancellable
	Cancellable() Cancellable
	// CheckCancellable gets @task's check-cancellable flag. See
	// g_task_set_check_cancellable() for more details.
	CheckCancellable() bool
	// Completed gets the value of #GTask:completed. This changes from false to
	// true after the tasks callback is invoked, and will return false if
	// called from inside the callback.
	Completed() bool
	// Context gets the Context that @task will return its result in (that is,
	// the context that was the [thread-default main
	// context][g-main-context-push-thread-default] at the point when @task was
	// created).
	//
	// This will always return a non-nil value, even if the task's context is
	// the default Context.
	Context() *glib.MainContext
	// Name gets @tasks name. See g_task_set_name().
	Name() string
	// Priority gets @task's priority
	Priority() int
	// ReturnOnCancel gets @task's return-on-cancel flag. See
	// g_task_set_return_on_cancel() for more details.
	ReturnOnCancel() bool
	// SourceObject gets the source object from @task. Like
	// g_async_result_get_source_object(), but does not ref the object.
	SourceObject() gextras.Objector
	// HadError tests if @task resulted in an error.
	HadError() bool
	// PropagateBoolean gets the result of @task as a #gboolean.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return false and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateBoolean() error
	// PropagateInt gets the result of @task as an integer (#gssize).
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return -1 and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateInt() (int, error)
	// PropagateValue gets the result of @task as a #GValue, and transfers
	// ownership of that value to the caller. As with g_task_return_value(),
	// this is a generic low-level method; g_task_propagate_pointer() and the
	// like will usually be more useful for C code.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead set @error and return false.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateValue() (*externglib.Value, error)
	// ReturnBoolean sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this means).
	ReturnBoolean(result bool)
	// ReturnError sets @task's result to @error (which @task assumes ownership
	// of) and completes the task (see g_task_return_pointer() for more
	// discussion of exactly what this means).
	//
	// Note that since the task takes ownership of @error, and since the task
	// may be completed before returning from g_task_return_error(), you cannot
	// assume that @error is still valid after calling this. Call g_error_copy()
	// on the error if you need to keep a local copy as well.
	//
	// See also g_task_return_new_error().
	ReturnError(err error)
	// ReturnErrorIfCancelled checks if @task's #GCancellable has been
	// cancelled, and if so, sets @task's error accordingly and completes the
	// task (see g_task_return_pointer() for more discussion of exactly what
	// this means).
	ReturnErrorIfCancelled() bool
	// ReturnInt sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this means).
	ReturnInt(result int)
	// ReturnValue sets @task's result to @result (by copying it) and completes
	// the task.
	//
	// If @result is nil then a #GValue of type TYPE_POINTER with a value of nil
	// will be used for the result.
	//
	// This is a very generic low-level method intended primarily for use by
	// language bindings; for C code, g_task_return_pointer() and the like will
	// normally be much easier to use.
	ReturnValue(result **externglib.Value)
	// SetCheckCancellable sets or clears @task's check-cancellable flag. If
	// this is true (the default), then g_task_propagate_pointer(), etc, and
	// g_task_had_error() will check the task's #GCancellable first, and if it
	// has been cancelled, then they will consider the task to have returned an
	// "Operation was cancelled" error (G_IO_ERROR_CANCELLED), regardless of any
	// other error or return value the task may have had.
	//
	// If @check_cancellable is false, then the #GTask will not check the
	// cancellable itself, and it is up to @task's owner to do this (eg, via
	// g_task_return_error_if_cancelled()).
	//
	// If you are using g_task_set_return_on_cancel() as well, then you must
	// leave check-cancellable set true.
	SetCheckCancellable(checkCancellable bool)
	// SetName sets @tasks name, used in debugging and profiling. The name
	// defaults to nil.
	//
	// The task name should describe in a human readable way what the task does.
	// For example, Open file or Connect to network host. It is used to set
	// the name of the #GSource used for idle completion of the task.
	//
	// This function may only be called before the @task is first used in a
	// thread other than the one it was constructed in.
	SetName(name string)
	// SetPriority sets @task's priority. If you do not call this, it will
	// default to G_PRIORITY_DEFAULT.
	//
	// This will affect the priority of #GSources created with
	// g_task_attach_source() and the scheduling of tasks run in threads, and
	// can also be explicitly retrieved later via g_task_get_priority().
	SetPriority(priority int)
	// SetReturnOnCancel sets or clears @task's return-on-cancel flag. This is
	// only meaningful for tasks run via g_task_run_in_thread() or
	// g_task_run_in_thread_sync().
	//
	// If @return_on_cancel is true, then cancelling @task's #GCancellable will
	// immediately cause it to return, as though the task's ThreadFunc had
	// called g_task_return_error_if_cancelled() and then returned.
	//
	// This allows you to create a cancellable wrapper around an uninterruptible
	// function. The ThreadFunc just needs to be careful that it does not modify
	// any externally-visible state after it has been cancelled. To do that, the
	// thread should call g_task_set_return_on_cancel() again to (atomically)
	// set return-on-cancel false before making externally-visible changes; if
	// the task gets cancelled before the return-on-cancel flag could be
	// changed, g_task_set_return_on_cancel() will indicate this by returning
	// false.
	//
	// You can disable and re-enable this flag multiple times if you wish. If
	// the task's #GCancellable is cancelled while return-on-cancel is false,
	// then calling g_task_set_return_on_cancel() to set it true again will
	// cause the task to be cancelled at that point.
	//
	// If the task's #GCancellable is already cancelled before you call
	// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the ThreadFunc
	// will still be run (for consistency), but the task will also be completed
	// right away.
	SetReturnOnCancel(returnOnCancel bool) bool
}

// task implements the Task class.
type task struct {
	gextras.Objector
	AsyncResult
}

var _ Task = (*task)(nil)

// WrapTask wraps a GObject to the right type. It is
// primarily used internally.
func WrapTask(obj *externglib.Object) Task {
	return task{
		Objector:    obj,
		AsyncResult: WrapAsyncResult(obj),
	}
}

func marshalTask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTask(obj), nil
}

func (t task) Cancellable() Cancellable {
	var _arg0 *C.GTask        // out
	var _cret *C.GCancellable // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_cancellable(_arg0)

	var _cancellable Cancellable // out

	_cancellable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Cancellable)

	return _cancellable
}

func (t task) CheckCancellable() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_check_cancellable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) Completed() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_completed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) Context() *glib.MainContext {
	var _arg0 *C.GTask        // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_context(_arg0)

	var _mainContext *glib.MainContext // out

	_mainContext = glib.WrapMainContext(unsafe.Pointer(_cret))

	return _mainContext
}

func (t task) Name() string {
	var _arg0 *C.GTask // out
	var _cret *C.gchar // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (t task) Priority() int {
	var _arg0 *C.GTask // out
	var _cret C.gint   // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_priority(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t task) ReturnOnCancel() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_return_on_cancel(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) SourceObject() gextras.Objector {
	var _arg0 *C.GTask   // out
	var _cret C.gpointer // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_source_object(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (t task) HadError() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_had_error(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) PropagateBoolean() error {
	var _arg0 *C.GTask  // out
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	C.g_task_propagate_boolean(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (t task) PropagateInt() (int, error) {
	var _arg0 *C.GTask  // out
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_propagate_int(_arg0, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (t task) PropagateValue() (*externglib.Value, error) {
	var _arg0 *C.GTask  // out
	var _arg1 C.GValue  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	C.g_task_propagate_value(_arg0, &_arg1, &_cerr)

	var _value *externglib.Value // out
	var _goerr error             // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_arg1))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _value, _goerr
}

func (t task) ReturnBoolean(result bool) {
	var _arg0 *C.GTask   // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	if result {
		_arg1 = C.TRUE
	}

	C.g_task_return_boolean(_arg0, _arg1)
}

func (t task) ReturnError(err error) {
	var _arg0 *C.GTask  // out
	var _arg1 *C.GError // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))

	C.g_task_return_error(_arg0, _arg1)
}

func (t task) ReturnErrorIfCancelled() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_return_error_if_cancelled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) ReturnInt(result int) {
	var _arg0 *C.GTask // out
	var _arg1 C.gssize // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gssize)(result)

	C.g_task_return_int(_arg0, _arg1)
}

func (t task) ReturnValue(result **externglib.Value) {
	var _arg0 *C.GTask  // out
	var _arg1 *C.GValue // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GValue)(result.GValue)

	C.g_task_return_value(_arg0, _arg1)
}

func (t task) SetCheckCancellable(checkCancellable bool) {
	var _arg0 *C.GTask   // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	if checkCancellable {
		_arg1 = C.TRUE
	}

	C.g_task_set_check_cancellable(_arg0, _arg1)
}

func (t task) SetName(name string) {
	var _arg0 *C.GTask // out
	var _arg1 *C.gchar // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_task_set_name(_arg0, _arg1)
}

func (t task) SetPriority(priority int) {
	var _arg0 *C.GTask // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(priority)

	C.g_task_set_priority(_arg0, _arg1)
}

func (t task) SetReturnOnCancel(returnOnCancel bool) bool {
	var _arg0 *C.GTask   // out
	var _arg1 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	if returnOnCancel {
		_arg1 = C.TRUE
	}

	_cret = C.g_task_set_return_on_cancel(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TCPConnection: this is the subclass of Connection that is created for TCP/IP
// sockets.
type TCPConnection interface {
	SocketConnection

	// GracefulDisconnect checks if graceful disconnects are used. See
	// g_tcp_connection_set_graceful_disconnect().
	GracefulDisconnect() bool
	// SetGracefulDisconnect: this enables graceful disconnects on close. A
	// graceful disconnect means that we signal the receiving end that the
	// connection is terminated and wait for it to close the connection before
	// closing the connection.
	//
	// A graceful disconnect means that we can be sure that we successfully sent
	// all the outstanding data to the other end, or get an error reported.
	// However, it also means we have to wait for all the data to reach the
	// other side and for it to acknowledge this by closing the socket, which
	// may take a while. For this reason it is disabled by default.
	SetGracefulDisconnect(gracefulDisconnect bool)
}

// tcpConnection implements the TCPConnection class.
type tcpConnection struct {
	SocketConnection
}

var _ TCPConnection = (*tcpConnection)(nil)

// WrapTCPConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTCPConnection(obj *externglib.Object) TCPConnection {
	return tcpConnection{
		SocketConnection: WrapSocketConnection(obj),
	}
}

func marshalTCPConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTCPConnection(obj), nil
}

func (c tcpConnection) GracefulDisconnect() bool {
	var _arg0 *C.GTcpConnection // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GTcpConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tcp_connection_get_graceful_disconnect(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c tcpConnection) SetGracefulDisconnect(gracefulDisconnect bool) {
	var _arg0 *C.GTcpConnection // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GTcpConnection)(unsafe.Pointer(c.Native()))
	if gracefulDisconnect {
		_arg1 = C.TRUE
	}

	C.g_tcp_connection_set_graceful_disconnect(_arg0, _arg1)
}

// TCPWrapperConnection: a WrapperConnection can be used to wrap a OStream that
// is based on a #GSocket, but which is not actually a Connection. This is used
// by Client so that it can always return a Connection, even when the connection
// it has actually created is not directly a Connection.
type TCPWrapperConnection interface {
	TCPConnection

	// BaseIOStream gets @conn's base OStream
	BaseIOStream() IOStream
}

// tcpWrapperConnection implements the TCPWrapperConnection class.
type tcpWrapperConnection struct {
	TCPConnection
}

var _ TCPWrapperConnection = (*tcpWrapperConnection)(nil)

// WrapTCPWrapperConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTCPWrapperConnection(obj *externglib.Object) TCPWrapperConnection {
	return tcpWrapperConnection{
		TCPConnection: WrapTCPConnection(obj),
	}
}

func marshalTCPWrapperConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTCPWrapperConnection(obj), nil
}

// NewTCPWrapperConnection wraps @base_io_stream and @socket together as a
// Connection.
func NewTCPWrapperConnection(baseIoStream IOStream, socket Socket) TCPWrapperConnection {
	var _arg1 *C.GIOStream         // out
	var _arg2 *C.GSocket           // out
	var _cret *C.GSocketConnection // in

	_arg1 = (*C.GIOStream)(unsafe.Pointer(baseIoStream.Native()))
	_arg2 = (*C.GSocket)(unsafe.Pointer(socket.Native()))

	_cret = C.g_tcp_wrapper_connection_new(_arg1, _arg2)

	var _tcpWrapperConnection TCPWrapperConnection // out

	_tcpWrapperConnection = WrapTCPWrapperConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _tcpWrapperConnection
}

func (c tcpWrapperConnection) BaseIOStream() IOStream {
	var _arg0 *C.GTcpWrapperConnection // out
	var _cret *C.GIOStream             // in

	_arg0 = (*C.GTcpWrapperConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tcp_wrapper_connection_get_base_io_stream(_arg0)

	var _ioStream IOStream // out

	_ioStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IOStream)

	return _ioStream
}

// TestDBus: a helper class for testing code which uses D-Bus without touching
// the user's session bus.
//
// Note that DBus modifies the users environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
//
//    [D-BUS Service]
//    Name=org.gtk.GDBus.Examples.ObjectManager
//    Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//
// You will also need to indicate this service directory in your test fixtures,
// so you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as:
//
//       -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//
//    Once you have a service definition file which is local to your source tree,
//
// you can proceed to set up a GTest fixture using the DBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found here:
// gdbus-test-fixture.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your
// schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas:
//
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
type TestDBus interface {
	gextras.Objector

	// AddServiceDir: add a path where dbus-daemon will look up .service files.
	// This can't be called after g_test_dbus_up().
	AddServiceDir(path string)
	// Down: stop the session bus started by g_test_dbus_up().
	//
	// This will wait for the singleton returned by g_bus_get() or
	// g_bus_get_sync() to be destroyed. This is done to ensure that the next
	// unit test won't get a leaked singleton from this test.
	Down()
	// BusAddress: get the address on which dbus-daemon is running. If
	// g_test_dbus_up() has not been called yet, nil is returned. This can be
	// used with g_dbus_connection_new_for_address().
	BusAddress() string
	// Flags: get the flags of the DBus object.
	Flags() TestDBusFlags
	// Stop: stop the session bus started by g_test_dbus_up().
	//
	// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
	// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests
	// wanting to verify behaviour after the session bus has been stopped can
	// use this function but should still call g_test_dbus_down() when done.
	Stop()
	// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After
	// this call, it is safe for unit tests to start sending messages on the
	// session bus.
	//
	// If this function is called from setup callback of g_test_add(),
	// g_test_dbus_down() must be called in its teardown callback.
	//
	// If this function is called from unit test's main(), then
	// g_test_dbus_down() must be called after g_test_run().
	Up()
}

// testDBus implements the TestDBus class.
type testDBus struct {
	gextras.Objector
}

var _ TestDBus = (*testDBus)(nil)

// WrapTestDBus wraps a GObject to the right type. It is
// primarily used internally.
func WrapTestDBus(obj *externglib.Object) TestDBus {
	return testDBus{
		Objector: obj,
	}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTestDBus(obj), nil
}

// NewTestDBus: create a new DBus object.
func NewTestDBus(flags TestDBusFlags) TestDBus {
	var _arg1 C.GTestDBusFlags // out
	var _cret *C.GTestDBus     // in

	_arg1 = (C.GTestDBusFlags)(flags)

	_cret = C.g_test_dbus_new(_arg1)

	var _testDBus TestDBus // out

	_testDBus = WrapTestDBus(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _testDBus
}

func (s testDBus) AddServiceDir(path string) {
	var _arg0 *C.GTestDBus // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_test_dbus_add_service_dir(_arg0, _arg1)
}

func (s testDBus) Down() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_down(_arg0)
}

func (s testDBus) BusAddress() string {
	var _arg0 *C.GTestDBus // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	_cret = C.g_test_dbus_get_bus_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s testDBus) Flags() TestDBusFlags {
	var _arg0 *C.GTestDBus     // out
	var _cret C.GTestDBusFlags // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	_cret = C.g_test_dbus_get_flags(_arg0)

	var _testDBusFlags TestDBusFlags // out

	_testDBusFlags = TestDBusFlags(_cret)

	return _testDBusFlags
}

func (s testDBus) Stop() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_stop(_arg0)
}

func (s testDBus) Up() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_up(_arg0)
}

// ThemedIcon is an implementation of #GIcon that supports icon themes. Icon
// contains a list of all of the icons present in an icon theme, so that icons
// can be looked up quickly. Icon does not provide actual pixmaps for icons,
// just the icon names. Ideally something like gtk_icon_theme_choose_icon()
// should be used to resolve the list of names so that fallback icons work
// nicely with themes that inherit other themes.
type ThemedIcon interface {
	gextras.Objector
	Icon

	// AppendName: append a name to the list of icons from within @icon.
	//
	// Note that doing so invalidates the hash computed by prior calls to
	// g_icon_hash().
	AppendName(iconname string)
	// Names gets the names of icons from within @icon.
	Names() []string
	// PrependName: prepend a name to the list of icons from within @icon.
	//
	// Note that doing so invalidates the hash computed by prior calls to
	// g_icon_hash().
	PrependName(iconname string)
}

// themedIcon implements the ThemedIcon class.
type themedIcon struct {
	gextras.Objector
	Icon
}

var _ ThemedIcon = (*themedIcon)(nil)

// WrapThemedIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapThemedIcon(obj *externglib.Object) ThemedIcon {
	return themedIcon{
		Objector: obj,
		Icon:     WrapIcon(obj),
	}
}

func marshalThemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapThemedIcon(obj), nil
}

// NewThemedIcon creates a new themed icon for @iconname.
func NewThemedIcon(iconname string) ThemedIcon {
	var _arg1 *C.char  // out
	var _cret *C.GIcon // in

	_arg1 = (*C.char)(C.CString(iconname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_themed_icon_new(_arg1)

	var _themedIcon ThemedIcon // out

	_themedIcon = WrapThemedIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _themedIcon
}

// NewThemedIconFromNames creates a new themed icon for @iconnames.
func NewThemedIconFromNames(iconnames []string) ThemedIcon {
	var _arg1 **C.char
	var _arg2 C.int
	var _cret *C.GIcon // in

	_arg2 = C.int(len(iconnames))
	_arg1 = (**C.char)(C.malloc(C.ulong(len(iconnames)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(iconnames))
		for i := range iconnames {
			out[i] = (*C.char)(C.CString(iconnames[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_themed_icon_new_from_names(_arg1, _arg2)

	var _themedIcon ThemedIcon // out

	_themedIcon = WrapThemedIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _themedIcon
}

// NewThemedIconWithDefaultFallbacks creates a new themed icon for @iconname,
// and all the names that can be created by shortening @iconname at '-'
// characters.
//
// In the following example, @icon1 and @icon2 are equivalent:
//
//    const char *names[] = {
//      "gnome-dev-cdrom-audio",
//      "gnome-dev-cdrom",
//      "gnome-dev",
//      "gnome"
//    };
//
//    icon1 = g_themed_icon_new_from_names (names, 4);
//    icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
func NewThemedIconWithDefaultFallbacks(iconname string) ThemedIcon {
	var _arg1 *C.char  // out
	var _cret *C.GIcon // in

	_arg1 = (*C.char)(C.CString(iconname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_themed_icon_new_with_default_fallbacks(_arg1)

	var _themedIcon ThemedIcon // out

	_themedIcon = WrapThemedIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _themedIcon
}

func (i themedIcon) AppendName(iconname string) {
	var _arg0 *C.GThemedIcon // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GThemedIcon)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(iconname))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_themed_icon_append_name(_arg0, _arg1)
}

func (i themedIcon) Names() []string {
	var _arg0 *C.GThemedIcon // out
	var _cret **C.gchar

	_arg0 = (*C.GThemedIcon)(unsafe.Pointer(i.Native()))

	_cret = C.g_themed_icon_get_names(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (i themedIcon) PrependName(iconname string) {
	var _arg0 *C.GThemedIcon // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GThemedIcon)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(iconname))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_themed_icon_prepend_name(_arg0, _arg1)
}

// ThreadedSocketService: a SocketService is a simple subclass of Service that
// handles incoming connections by creating a worker thread and dispatching the
// connection to it by emitting the SocketService::run signal in the new thread.
//
// The signal handler may perform blocking IO and need not return until the
// connection is closed.
//
// The service is implemented using a thread pool, so there is a limited amount
// of threads available to serve incoming requests. The service automatically
// stops the Service from accepting new connections when all threads are busy.
//
// As with Service, you may connect to SocketService::run, or subclass and
// override the default handler.
type ThreadedSocketService interface {
	SocketService
}

// threadedSocketService implements the ThreadedSocketService class.
type threadedSocketService struct {
	SocketService
}

var _ ThreadedSocketService = (*threadedSocketService)(nil)

// WrapThreadedSocketService wraps a GObject to the right type. It is
// primarily used internally.
func WrapThreadedSocketService(obj *externglib.Object) ThreadedSocketService {
	return threadedSocketService{
		SocketService: WrapSocketService(obj),
	}
}

func marshalThreadedSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapThreadedSocketService(obj), nil
}

// NewThreadedSocketService creates a new SocketService with no listeners.
// Listeners must be added with one of the Listener "add" methods.
func NewThreadedSocketService(maxThreads int) ThreadedSocketService {
	var _arg1 C.int             // out
	var _cret *C.GSocketService // in

	_arg1 = (C.int)(maxThreads)

	_cret = C.g_threaded_socket_service_new(_arg1)

	var _threadedSocketService ThreadedSocketService // out

	_threadedSocketService = WrapThreadedSocketService(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _threadedSocketService
}

// TLSCertificate: a certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate received by
// a client from a server), or the combination of a certificate and a private
// key (which is needed when acting as a ServerConnection).
type TLSCertificate interface {
	gextras.Objector

	// Issuer gets the Certificate representing @cert's issuer, if known
	Issuer() TLSCertificate
	// IsSame: check if two Certificate objects represent the same certificate.
	// The raw DER byte data of the two certificates are checked for equality.
	// This has the effect that two certificates may compare equal even if their
	// Certificate:issuer, Certificate:private-key, or
	// Certificate:private-key-pem properties differ.
	IsSame(certTwo TLSCertificate) bool
	// Verify: this verifies @cert and returns a set of CertificateFlags
	// indicating any problems found with it. This can be used to verify a
	// certificate outside the context of making a connection, or to check a
	// certificate against a CA that is not part of the system CA database.
	//
	// If @identity is not nil, @cert's name(s) will be compared against it, and
	// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value if it does
	// not match. If @identity is nil, that bit will never be set in the return
	// value.
	//
	// If @trusted_ca is not nil, then @cert (or one of the certificates in its
	// chain) must be signed by it, or else G_TLS_CERTIFICATE_UNKNOWN_CA will be
	// set in the return value. If @trusted_ca is nil, that bit will never be
	// set in the return value.
	//
	// (All other CertificateFlags values will always be set or unset as
	// appropriate.)
	Verify(identity SocketConnectable, trustedCa TLSCertificate) TLSCertificateFlags
}

// tlsCertificate implements the TLSCertificate class.
type tlsCertificate struct {
	gextras.Objector
}

var _ TLSCertificate = (*tlsCertificate)(nil)

// WrapTLSCertificate wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSCertificate(obj *externglib.Object) TLSCertificate {
	return tlsCertificate{
		Objector: obj,
	}
}

func marshalTLSCertificate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSCertificate(obj), nil
}

// NewTLSCertificateFromFile creates a Certificate from the PEM-encoded data in
// @file. The returned certificate will be the first certificate found in @file.
// As of GLib 2.44, if @file contains more certificates it will try to load a
// certificate chain. All certificates will be verified in the order found
// (top-level certificate should be the last one in the file) and the
// Certificate:issuer property of each certificate will be set accordingly if
// the verification succeeds. If any certificate in the chain cannot be
// verified, the first certificate in the file will still be returned.
//
// If @file cannot be read or parsed, the function will return nil and set
// @error. Otherwise, this behaves like g_tls_certificate_new_from_pem().
func NewTLSCertificateFromFile(file string) (TLSCertificate, error) {
	var _arg1 *C.gchar           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_tls_certificate_new_from_file(_arg1, &_cerr)

	var _tlsCertificate TLSCertificate // out
	var _goerr error                   // out

	_tlsCertificate = WrapTLSCertificate(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificate, _goerr
}

// NewTLSCertificateFromFiles creates a Certificate from the PEM-encoded data in
// @cert_file and @key_file. The returned certificate will be the first
// certificate found in @cert_file. As of GLib 2.44, if @cert_file contains more
// certificates it will try to load a certificate chain. All certificates will
// be verified in the order found (top-level certificate should be the last one
// in the file) and the Certificate:issuer property of each certificate will be
// set accordingly if the verification succeeds. If any certificate in the chain
// cannot be verified, the first certificate in the file will still be returned.
//
// If either file cannot be read or parsed, the function will return nil and set
// @error. Otherwise, this behaves like g_tls_certificate_new_from_pem().
func NewTLSCertificateFromFiles(certFile string, keyFile string) (TLSCertificate, error) {
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(C.CString(certFile))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(keyFile))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_tls_certificate_new_from_files(_arg1, _arg2, &_cerr)

	var _tlsCertificate TLSCertificate // out
	var _goerr error                   // out

	_tlsCertificate = WrapTLSCertificate(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificate, _goerr
}

// NewTLSCertificateFromPem creates a Certificate from the PEM-encoded data in
// @data. If @data includes both a certificate and a private key, then the
// returned certificate will include the private key data as well. (See the
// Certificate:private-key-pem property for information about supported
// formats.)
//
// The returned certificate will be the first certificate found in @data. As of
// GLib 2.44, if @data contains more certificates it will try to load a
// certificate chain. All certificates will be verified in the order found
// (top-level certificate should be the last one in the file) and the
// Certificate:issuer property of each certificate will be set accordingly if
// the verification succeeds. If any certificate in the chain cannot be
// verified, the first certificate in the file will still be returned.
func NewTLSCertificateFromPem(data string, length int) (TLSCertificate, error) {
	var _arg1 *C.gchar           // out
	var _arg2 C.gssize           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(C.CString(data))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(length)

	_cret = C.g_tls_certificate_new_from_pem(_arg1, _arg2, &_cerr)

	var _tlsCertificate TLSCertificate // out
	var _goerr error                   // out

	_tlsCertificate = WrapTLSCertificate(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificate, _goerr
}

// NewTLSCertificateFromPkcs11Uris creates a Certificate from a PKCS \#11 URI.
//
// An example @pkcs11_uri would be
// `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01`
//
// Where the tokens layout is:
//
// ` Object 0: URL:
// pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=private20key;type=private
// Type: Private key (RSA-2048) ID: 01
//
// Object 1: URL:
// pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=Certificate20for20Authentication;type=cert
// Type: X.509 Certificate (RSA-2048) ID: 01 `
//
// In this case the certificate and private key would both be detected and used
// as expected. @pkcs_uri may also just reference an X.509 certificate object
// and then optionally @private_key_pkcs11_uri allows using a private key
// exposed under a different URI.
//
// Note that the private key is not accessed until usage and may fail or require
// a PIN later.
func NewTLSCertificateFromPkcs11Uris(pkcs11Uri string, privateKeyPkcs11Uri string) (TLSCertificate, error) {
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(C.CString(pkcs11Uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(privateKeyPkcs11Uri))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_tls_certificate_new_from_pkcs11_uris(_arg1, _arg2, &_cerr)

	var _tlsCertificate TLSCertificate // out
	var _goerr error                   // out

	_tlsCertificate = WrapTLSCertificate(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificate, _goerr
}

func (c tlsCertificate) Issuer() TLSCertificate {
	var _arg0 *C.GTlsCertificate // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_certificate_get_issuer(_arg0)

	var _tlsCertificate TLSCertificate // out

	_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

	return _tlsCertificate
}

func (c tlsCertificate) IsSame(certTwo TLSCertificate) bool {
	var _arg0 *C.GTlsCertificate // out
	var _arg1 *C.GTlsCertificate // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certTwo.Native()))

	_cret = C.g_tls_certificate_is_same(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c tlsCertificate) Verify(identity SocketConnectable, trustedCa TLSCertificate) TLSCertificateFlags {
	var _arg0 *C.GTlsCertificate     // out
	var _arg1 *C.GSocketConnectable  // out
	var _arg2 *C.GTlsCertificate     // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(identity.Native()))
	_arg2 = (*C.GTlsCertificate)(unsafe.Pointer(trustedCa.Native()))

	_cret = C.g_tls_certificate_verify(_arg0, _arg1, _arg2)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// TLSConnection is the base TLS connection class type, which wraps a OStream
// and provides TLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side TLS,
// respectively.
//
// For DTLS (Datagram TLS) support, see Connection.
type TLSConnection interface {
	IOStream

	// EmitAcceptCertificate: used by Connection implementations to emit the
	// Connection::accept-certificate signal.
	EmitAcceptCertificate(peerCert TLSCertificate, errors TLSCertificateFlags) bool
	// Certificate gets @conn's certificate, as set by
	// g_tls_connection_set_certificate().
	Certificate() TLSCertificate
	// ChannelBindingData: query the TLS backend for TLS channel binding data of
	// @type for @conn.
	//
	// This call retrieves TLS channel binding data as specified in RFC 5056
	// (https://tools.ietf.org/html/rfc5056), RFC 5929
	// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding data
	// is returned in @data. The @data is resized by the callee using Array
	// buffer management and will be freed when the @data is destroyed by
	// g_byte_array_unref(). If @data is nil, it will only check whether TLS
	// backend is able to fetch the data (e.g. whether @type is supported by the
	// TLS backend). It does not guarantee that the data will be available
	// though. That could happen if TLS connection does not support @type or the
	// binding data is not available yet due to additional negotiation or input
	// required.
	ChannelBindingData(typ TLSChannelBindingType) ([]byte, error)
	// Database gets the certificate database that @conn uses to verify peer
	// certificates. See g_tls_connection_set_database().
	Database() TLSDatabase
	// Interaction: get the object that will be used to interact with the user.
	// It will be used for things like prompting the user for passwords. If nil
	// is returned, then no user interaction will occur for this connection.
	Interaction() TLSInteraction
	// NegotiatedProtocol gets the name of the application-layer protocol
	// negotiated during the handshake.
	//
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend does
	// not support ALPN, then this will be nil. See
	// g_tls_connection_set_advertised_protocols().
	NegotiatedProtocol() string
	// PeerCertificate gets @conn's peer's certificate after the handshake has
	// completed or failed. (It is not set during the emission of
	// Connection::accept-certificate.)
	PeerCertificate() TLSCertificate
	// PeerCertificateErrors gets the errors associated with validating @conn's
	// peer's certificate, after the handshake has completed or failed. (It is
	// not set during the emission of Connection::accept-certificate.)
	PeerCertificateErrors() TLSCertificateFlags
	// RehandshakeMode gets @conn rehandshaking mode. See
	// g_tls_connection_set_rehandshake_mode() for details.
	RehandshakeMode() TLSRehandshakeMode
	// RequireCloseNotify tests whether or not @conn expects a proper TLS close
	// notification when the connection is closed. See
	// g_tls_connection_set_require_close_notify() for details.
	RequireCloseNotify() bool
	// UseSystemCertdb gets whether @conn uses the system certificate database
	// to verify peer certificates. See
	// g_tls_connection_set_use_system_certdb().
	UseSystemCertdb() bool
	// Handshake attempts a TLS handshake on @conn.
	//
	// On the client side, it is never necessary to call this method; although
	// the connection needs to perform a handshake after connecting (or after
	// sending a "STARTTLS"-type command), Connection will handle this for you
	// automatically when you try to send or receive data on the connection. You
	// can call g_tls_connection_handshake() manually if you want to know
	// whether the initial handshake succeeded or failed (as opposed to just
	// immediately trying to use @conn to read or write, in which case, if it
	// fails, it may not be possible to tell if it failed before or after
	// completing the handshake), but beware that servers may reject client
	// authentication after the handshake has completed, so a successful
	// handshake does not indicate the connection will be usable.
	//
	// Likewise, on the server side, although a handshake is necessary at the
	// beginning of the communication, you do not need to call this function
	// explicitly unless you want clearer error reporting.
	//
	// Previously, calling g_tls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was deprecated
	// in GLib 2.60 because rehandshaking was removed from the TLS protocol in
	// TLS 1.3. Since GLib 2.64, calling this function after the initial
	// handshake will no longer do anything.
	//
	// When using a Connection created by Client, the Client performs the
	// initial handshake, so calling this function manually is not recommended.
	//
	// Connection::accept_certificate may be emitted during the handshake.
	Handshake(cancellable Cancellable) error
	// HandshakeFinish: finish an asynchronous TLS handshake operation. See
	// g_tls_connection_handshake() for more information.
	HandshakeFinish(result AsyncResult) error
	// SetAdvertisedProtocols sets the list of application-layer protocols to
	// advertise that the caller is willing to speak on this connection. The
	// Application-Layer Protocol Negotiation (ALPN) extension will be used to
	// negotiate a compatible protocol with the peer; use
	// g_tls_connection_get_negotiated_protocol() to find the negotiated
	// protocol after the handshake. Specifying nil for the the value of
	// @protocols will disable ALPN negotiation.
	//
	// See IANA TLS ALPN Protocol IDs
	// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
	// for a list of registered protocol IDs.
	SetAdvertisedProtocols(protocols []string)
	// SetCertificate: this sets the certificate that @conn will present to its
	// peer during the TLS handshake. For a ServerConnection, it is mandatory to
	// set this, and that will normally be done at construct time.
	//
	// For a ClientConnection, this is optional. If a handshake fails with
	// G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server requires a
	// certificate, and if you try connecting again, you should call this method
	// first. You can call g_tls_client_connection_get_accepted_cas() on the
	// failed connection to get a list of Certificate Authorities that the
	// server will accept certificates from.
	//
	// (It is also possible that a server will allow the connection with or
	// without a certificate; in that case, if you don't provide a certificate,
	// you can tell that the server requested one by the fact that
	// g_tls_client_connection_get_accepted_cas() will return non-nil.)
	SetCertificate(certificate TLSCertificate)
	// SetDatabase sets the certificate database that is used to verify peer
	// certificates. This is set to the default database by default. See
	// g_tls_backend_get_default_database(). If set to nil, then peer
	// certificate validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA
	// error (meaning Connection::accept-certificate will always be emitted on
	// client-side connections, unless that bit is not set in
	// ClientConnection:validation-flags).
	SetDatabase(database TLSDatabase)
	// SetInteraction: set the object that will be used to interact with the
	// user. It will be used for things like prompting the user for passwords.
	//
	// The @interaction argument will normally be a derived subclass of
	// Interaction. nil can also be provided if no user interaction should occur
	// for this connection.
	SetInteraction(interaction TLSInteraction)
	// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
	// longer supported and will have no effect. With TLS 1.3, rehandshaking has
	// been removed from the TLS protocol, replaced by separate post-handshake
	// authentication and rekey operations.
	SetRehandshakeMode(mode TLSRehandshakeMode)
	// SetRequireCloseNotify sets whether or not @conn expects a proper TLS
	// close notification before the connection is closed. If this is true (the
	// default), then @conn will expect to receive a TLS close notification from
	// its peer before the connection is closed, and will return a
	// G_TLS_ERROR_EOF error if the connection is closed without proper
	// notification (since this may indicate a network error, or
	// man-in-the-middle attack).
	//
	// In some protocols, the application will know whether or not the
	// connection was closed cleanly based on application-level data (because
	// the application-level data includes a length field, or is somehow
	// self-delimiting); in this case, the close notify is redundant and
	// sometimes omitted. (TLS 1.1 explicitly allows this; in TLS 1.0 it is
	// technically an error, but often done anyway.) You can use
	// g_tls_connection_set_require_close_notify() to tell @conn to allow an
	// "unannounced" connection close, in which case the close will show up as a
	// 0-length read, as in a non-TLS Connection, and it is up to the
	// application to check that the data has been fully received.
	//
	// Note that this only affects the behavior when the peer closes the
	// connection; when the application calls g_io_stream_close() itself on
	// @conn, this will send a close notification regardless of the setting of
	// this property. If you explicitly want to do an unclean close, you can
	// close @conn's Connection:base-io-stream rather than closing @conn itself,
	// but note that this may only be done when no other operations are pending
	// on @conn or the base I/O stream.
	SetRequireCloseNotify(requireCloseNotify bool)
	// SetUseSystemCertdb sets whether @conn uses the system certificate
	// database to verify peer certificates. This is true by default. If set to
	// false, then peer certificate validation will always set the
	// G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
	// Connection::accept-certificate will always be emitted on client-side
	// connections, unless that bit is not set in
	// ClientConnection:validation-flags).
	SetUseSystemCertdb(useSystemCertdb bool)
}

// tlsConnection implements the TLSConnection class.
type tlsConnection struct {
	IOStream
}

var _ TLSConnection = (*tlsConnection)(nil)

// WrapTLSConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSConnection(obj *externglib.Object) TLSConnection {
	return tlsConnection{
		IOStream: WrapIOStream(obj),
	}
}

func marshalTLSConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSConnection(obj), nil
}

func (c tlsConnection) EmitAcceptCertificate(peerCert TLSCertificate, errors TLSCertificateFlags) bool {
	var _arg0 *C.GTlsConnection      // out
	var _arg1 *C.GTlsCertificate     // out
	var _arg2 C.GTlsCertificateFlags // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(peerCert.Native()))
	_arg2 = (C.GTlsCertificateFlags)(errors)

	_cret = C.g_tls_connection_emit_accept_certificate(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c tlsConnection) Certificate() TLSCertificate {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_certificate(_arg0)

	var _tlsCertificate TLSCertificate // out

	_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

	return _tlsCertificate
}

func (c tlsConnection) ChannelBindingData(typ TLSChannelBindingType) ([]byte, error) {
	var _arg0 *C.GTlsConnection        // out
	var _arg1 C.GTlsChannelBindingType // out
	var _arg2 C.GByteArray
	var _cerr *C.GError // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GTlsChannelBindingType)(typ)

	C.g_tls_connection_get_channel_binding_data(_arg0, _arg1, &_arg2, &_cerr)

	var _data []byte
	var _goerr error // out

	{
		var i int
		var z C.guint8
		for p := _arg2; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg2, i)
		_data = make([]byte, i)
		for i := range src {
			_data[i] = (byte)(src[i])
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _data, _goerr
}

func (c tlsConnection) Database() TLSDatabase {
	var _arg0 *C.GTlsConnection // out
	var _cret *C.GTlsDatabase   // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_database(_arg0)

	var _tlsDatabase TLSDatabase // out

	_tlsDatabase = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSDatabase)

	return _tlsDatabase
}

func (c tlsConnection) Interaction() TLSInteraction {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsInteraction // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_interaction(_arg0)

	var _tlsInteraction TLSInteraction // out

	_tlsInteraction = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSInteraction)

	return _tlsInteraction
}

func (c tlsConnection) NegotiatedProtocol() string {
	var _arg0 *C.GTlsConnection // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_negotiated_protocol(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c tlsConnection) PeerCertificate() TLSCertificate {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_peer_certificate(_arg0)

	var _tlsCertificate TLSCertificate // out

	_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

	return _tlsCertificate
}

func (c tlsConnection) PeerCertificateErrors() TLSCertificateFlags {
	var _arg0 *C.GTlsConnection      // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_peer_certificate_errors(_arg0)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

func (c tlsConnection) RehandshakeMode() TLSRehandshakeMode {
	var _arg0 *C.GTlsConnection     // out
	var _cret C.GTlsRehandshakeMode // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_rehandshake_mode(_arg0)

	var _tlsRehandshakeMode TLSRehandshakeMode // out

	_tlsRehandshakeMode = TLSRehandshakeMode(_cret)

	return _tlsRehandshakeMode
}

func (c tlsConnection) RequireCloseNotify() bool {
	var _arg0 *C.GTlsConnection // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_require_close_notify(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c tlsConnection) UseSystemCertdb() bool {
	var _arg0 *C.GTlsConnection // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_use_system_certdb(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c tlsConnection) Handshake(cancellable Cancellable) error {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GCancellable   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_tls_connection_handshake(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c tlsConnection) HandshakeFinish(result AsyncResult) error {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GAsyncResult   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_tls_connection_handshake_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c tlsConnection) SetAdvertisedProtocols(protocols []string) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 **C.gchar

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(protocols)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(protocols))
		for i := range protocols {
			out[i] = (*C.gchar)(C.CString(protocols[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_tls_connection_set_advertised_protocols(_arg0, _arg1)
}

func (c tlsConnection) SetCertificate(certificate TLSCertificate) {
	var _arg0 *C.GTlsConnection  // out
	var _arg1 *C.GTlsCertificate // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))

	C.g_tls_connection_set_certificate(_arg0, _arg1)
}

func (c tlsConnection) SetDatabase(database TLSDatabase) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GTlsDatabase   // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(database.Native()))

	C.g_tls_connection_set_database(_arg0, _arg1)
}

func (c tlsConnection) SetInteraction(interaction TLSInteraction) {
	var _arg0 *C.GTlsConnection  // out
	var _arg1 *C.GTlsInteraction // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))

	C.g_tls_connection_set_interaction(_arg0, _arg1)
}

func (c tlsConnection) SetRehandshakeMode(mode TLSRehandshakeMode) {
	var _arg0 *C.GTlsConnection     // out
	var _arg1 C.GTlsRehandshakeMode // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GTlsRehandshakeMode)(mode)

	C.g_tls_connection_set_rehandshake_mode(_arg0, _arg1)
}

func (c tlsConnection) SetRequireCloseNotify(requireCloseNotify bool) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	if requireCloseNotify {
		_arg1 = C.TRUE
	}

	C.g_tls_connection_set_require_close_notify(_arg0, _arg1)
}

func (c tlsConnection) SetUseSystemCertdb(useSystemCertdb bool) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	if useSystemCertdb {
		_arg1 = C.TRUE
	}

	C.g_tls_connection_set_use_system_certdb(_arg0, _arg1)
}

// TLSDatabase is used to look up certificates and other information from a
// certificate or key store. It is an abstract base class which TLS library
// specific subtypes override.
//
// A Database may be accessed from multiple threads by the TLS backend. All
// implementations are required to be fully thread-safe.
//
// Most common client applications will not directly interact with Database. It
// is used internally by Connection.
type TLSDatabase interface {
	gextras.Objector

	// CreateCertificateHandle: create a handle string for the certificate. The
	// database will only be able to create a handle for certificates that
	// originate from the database. In cases where the database cannot create a
	// handle for a certificate, nil will be returned.
	//
	// This handle should be stable across various instances of the application,
	// and between applications. If a certificate is modified in the database,
	// then it is not guaranteed that this handle will continue to point to it.
	CreateCertificateHandle(certificate TLSCertificate) string
	// LookupCertificateForHandle: look up a certificate by its handle.
	//
	// The handle should have been created by calling
	// g_tls_database_create_certificate_handle() on a Database object of the
	// same TLS backend. The handle is designed to remain valid across
	// instantiations of the database.
	//
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then nil will be returned.
	//
	// This function can block, use
	// g_tls_database_lookup_certificate_for_handle_async() to perform the
	// lookup operation asynchronously.
	LookupCertificateForHandle(handle string, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) (TLSCertificate, error)
	// LookupCertificateForHandleFinish: finish an asynchronous lookup of a
	// certificate by its handle. See
	// g_tls_database_lookup_certificate_for_handle() for more information.
	//
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then nil will be returned.
	LookupCertificateForHandleFinish(result AsyncResult) (TLSCertificate, error)
	// LookupCertificateIssuer: look up the issuer of @certificate in the
	// database.
	//
	// The Certificate:issuer property of @certificate is not modified, and the
	// two certificates are not hooked into a chain.
	//
	// This function can block, use
	// g_tls_database_lookup_certificate_issuer_async() to perform the lookup
	// operation asynchronously.
	LookupCertificateIssuer(certificate TLSCertificate, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) (TLSCertificate, error)
	// LookupCertificateIssuerFinish: finish an asynchronous lookup issuer
	// operation. See g_tls_database_lookup_certificate_issuer() for more
	// information.
	LookupCertificateIssuerFinish(result AsyncResult) (TLSCertificate, error)
	// VerifyChain determines the validity of a certificate chain after looking
	// up and adding any missing certificates to the chain.
	//
	// @chain is a chain of Certificate objects each pointing to the next
	// certificate in the chain by its Certificate:issuer property. The chain
	// may initially consist of one or more certificates. After the verification
	// process is complete, @chain may be modified by adding missing
	// certificates, or removing extra certificates. If a certificate anchor was
	// found, then it is added to the @chain.
	//
	// @purpose describes the purpose (or usage) for which the certificate is
	// being used. Typically @purpose will be set to
	// TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER which means that the certificate
	// is being used to authenticate a server (and we are acting as the client).
	//
	// The @identity is used to ensure the server certificate is valid for the
	// expected peer identity. If the identity does not match the certificate,
	// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value. If
	// @identity is nil, that bit will never be set in the return value. The
	// peer identity may also be used to check for pinned certificates (trust
	// exceptions) in the database. These may override the normal verification
	// process on a host-by-host basis.
	//
	// Currently there are no @flags, and G_TLS_DATABASE_VERIFY_NONE should be
	// used.
	//
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate the
	// problems found. If the function is unable to determine whether @chain is
	// valid or not (eg, because @cancellable is triggered before it completes)
	// then the return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and @error
	// will be set accordingly. @error is not set when @chain is successfully
	// analyzed but found to be invalid.
	//
	// This function can block, use g_tls_database_verify_chain_async() to
	// perform the verification operation asynchronously.
	VerifyChain(chain TLSCertificate, purpose string, identity SocketConnectable, interaction TLSInteraction, flags TLSDatabaseVerifyFlags, cancellable Cancellable) (TLSCertificateFlags, error)
	// VerifyChainFinish: finish an asynchronous verify chain operation. See
	// g_tls_database_verify_chain() for more information.
	//
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate the
	// problems found. If the function is unable to determine whether @chain is
	// valid or not (eg, because @cancellable is triggered before it completes)
	// then the return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and @error
	// will be set accordingly. @error is not set when @chain is successfully
	// analyzed but found to be invalid.
	VerifyChainFinish(result AsyncResult) (TLSCertificateFlags, error)
}

// tlsDatabase implements the TLSDatabase class.
type tlsDatabase struct {
	gextras.Objector
}

var _ TLSDatabase = (*tlsDatabase)(nil)

// WrapTLSDatabase wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSDatabase(obj *externglib.Object) TLSDatabase {
	return tlsDatabase{
		Objector: obj,
	}
}

func marshalTLSDatabase(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSDatabase(obj), nil
}

func (s tlsDatabase) CreateCertificateHandle(certificate TLSCertificate) string {
	var _arg0 *C.GTlsDatabase    // out
	var _arg1 *C.GTlsCertificate // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))

	_cret = C.g_tls_database_create_certificate_handle(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (s tlsDatabase) LookupCertificateForHandle(handle string, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) (TLSCertificate, error) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg1 *C.gchar                  // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _arg4 *C.GCancellable           // out
	var _cret *C.GTlsCertificate        // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(handle))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))
	_arg3 = (C.GTlsDatabaseLookupFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_tls_database_lookup_certificate_for_handle(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _tlsCertificate TLSCertificate // out
	var _goerr error                   // out

	_tlsCertificate = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSCertificate)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificate, _goerr
}

func (s tlsDatabase) LookupCertificateForHandleFinish(result AsyncResult) (TLSCertificate, error) {
	var _arg0 *C.GTlsDatabase    // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_tls_database_lookup_certificate_for_handle_finish(_arg0, _arg1, &_cerr)

	var _tlsCertificate TLSCertificate // out
	var _goerr error                   // out

	_tlsCertificate = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSCertificate)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificate, _goerr
}

func (s tlsDatabase) LookupCertificateIssuer(certificate TLSCertificate, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) (TLSCertificate, error) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _arg4 *C.GCancellable           // out
	var _cret *C.GTlsCertificate        // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))
	_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))
	_arg3 = (C.GTlsDatabaseLookupFlags)(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_tls_database_lookup_certificate_issuer(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _tlsCertificate TLSCertificate // out
	var _goerr error                   // out

	_tlsCertificate = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSCertificate)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificate, _goerr
}

func (s tlsDatabase) LookupCertificateIssuerFinish(result AsyncResult) (TLSCertificate, error) {
	var _arg0 *C.GTlsDatabase    // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_tls_database_lookup_certificate_issuer_finish(_arg0, _arg1, &_cerr)

	var _tlsCertificate TLSCertificate // out
	var _goerr error                   // out

	_tlsCertificate = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSCertificate)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificate, _goerr
}

func (s tlsDatabase) VerifyChain(chain TLSCertificate, purpose string, identity SocketConnectable, interaction TLSInteraction, flags TLSDatabaseVerifyFlags, cancellable Cancellable) (TLSCertificateFlags, error) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.gchar                  // out
	var _arg3 *C.GSocketConnectable     // out
	var _arg4 *C.GTlsInteraction        // out
	var _arg5 C.GTlsDatabaseVerifyFlags // out
	var _arg6 *C.GCancellable           // out
	var _cret C.GTlsCertificateFlags    // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(chain.Native()))
	_arg2 = (*C.gchar)(C.CString(purpose))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GSocketConnectable)(unsafe.Pointer(identity.Native()))
	_arg4 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))
	_arg5 = (C.GTlsDatabaseVerifyFlags)(flags)
	_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_tls_database_verify_chain(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_cerr)

	var _tlsCertificateFlags TLSCertificateFlags // out
	var _goerr error                             // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificateFlags, _goerr
}

func (s tlsDatabase) VerifyChainFinish(result AsyncResult) (TLSCertificateFlags, error) {
	var _arg0 *C.GTlsDatabase        // out
	var _arg1 *C.GAsyncResult        // out
	var _cret C.GTlsCertificateFlags // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_tls_database_verify_chain_finish(_arg0, _arg1, &_cerr)

	var _tlsCertificateFlags TLSCertificateFlags // out
	var _goerr error                             // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsCertificateFlags, _goerr
}

// TLSInteraction provides a mechanism for the TLS connection and database code
// to interact with the user. It can be used to ask the user for passwords.
//
// To use a Interaction with a TLS connection use
// g_tls_connection_set_interaction().
//
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
//
// Callers should use the 'invoke' functions like
// g_tls_interaction_invoke_ask_password() to run interaction methods. These
// functions make sure that the interaction is invoked in the main loop and not
// in the current thread, if the current thread is not running the main loop.
//
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
// it must also implement the corresponding finish method.
type TLSInteraction interface {
	gextras.Objector

	// AskPassword: run synchronous interaction to ask the user for a password.
	// In general, g_tls_interaction_invoke_ask_password() should be used
	// instead of this function.
	//
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value
	// will be filled in and then @callback will be called. Alternatively the
	// user may abort this password request, which will usually abort the TLS
	// connection.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	AskPassword(password TLSPassword, cancellable Cancellable) (TLSInteractionResult, error)
	// AskPasswordFinish: complete an ask password user interaction request.
	// This should be once the g_tls_interaction_ask_password_async() completion
	// callback is called.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Password passed to
	// g_tls_interaction_ask_password() will have its password filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code.
	AskPasswordFinish(result AsyncResult) (TLSInteractionResult, error)
	// InvokeAskPassword: invoke the interaction to ask the user for a password.
	// It invokes this interaction in the main loop, specifically the Context
	// returned by g_main_context_get_thread_default() when the interaction is
	// created. This is called by called by Connection or Database to ask the
	// user for a password.
	//
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value
	// will be filled in and then @callback will be called. Alternatively the
	// user may abort this password request, which will usually abort the TLS
	// connection.
	//
	// The implementation can either be a synchronous (eg: modal dialog) or an
	// asynchronous one (eg: modeless dialog). This function will take care of
	// calling which ever one correctly.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	InvokeAskPassword(password TLSPassword, cancellable Cancellable) (TLSInteractionResult, error)
	// InvokeRequestCertificate: invoke the interaction to ask the user to
	// choose a certificate to use with the connection. It invokes this
	// interaction in the main loop, specifically the Context returned by
	// g_main_context_get_thread_default() when the interaction is created. This
	// is called by called by Connection when the peer requests a certificate
	// during the handshake.
	//
	// Derived subclasses usually implement a certificate selector, although
	// they may also choose to provide a certificate from elsewhere.
	// Alternatively the user may abort this certificate request, which may or
	// may not abort the TLS connection.
	//
	// The implementation can either be a synchronous (eg: modal dialog) or an
	// asynchronous one (eg: modeless dialog). This function will take care of
	// calling which ever one correctly.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	InvokeRequestCertificate(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable) (TLSInteractionResult, error)
	// RequestCertificate: run synchronous interaction to ask the user to choose
	// a certificate to use with the connection. In general,
	// g_tls_interaction_invoke_request_certificate() should be used instead of
	// this function.
	//
	// Derived subclasses usually implement a certificate selector, although
	// they may also choose to provide a certificate from elsewhere.
	// Alternatively the user may abort this certificate request, which will
	// usually abort the TLS connection.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed to
	// g_tls_interaction_request_certificate() will have had its
	// Connection:certificate filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	RequestCertificate(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable) (TLSInteractionResult, error)
	// RequestCertificateFinish: complete a request certificate user interaction
	// request. This should be once the
	// g_tls_interaction_request_certificate_async() completion callback is
	// called.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed to
	// g_tls_interaction_request_certificate_async() will have had its
	// Connection:certificate filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code.
	RequestCertificateFinish(result AsyncResult) (TLSInteractionResult, error)
}

// tlsInteraction implements the TLSInteraction class.
type tlsInteraction struct {
	gextras.Objector
}

var _ TLSInteraction = (*tlsInteraction)(nil)

// WrapTLSInteraction wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSInteraction(obj *externglib.Object) TLSInteraction {
	return tlsInteraction{
		Objector: obj,
	}
}

func marshalTLSInteraction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSInteraction(obj), nil
}

func (i tlsInteraction) AskPassword(password TLSPassword, cancellable Cancellable) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction      // out
	var _arg1 *C.GTlsPassword         // out
	var _arg2 *C.GCancellable         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GTlsPassword)(unsafe.Pointer(password.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_tls_interaction_ask_password(_arg0, _arg1, _arg2, &_cerr)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsInteractionResult, _goerr
}

func (i tlsInteraction) AskPasswordFinish(result AsyncResult) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction      // out
	var _arg1 *C.GAsyncResult         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_tls_interaction_ask_password_finish(_arg0, _arg1, &_cerr)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsInteractionResult, _goerr
}

func (i tlsInteraction) InvokeAskPassword(password TLSPassword, cancellable Cancellable) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction      // out
	var _arg1 *C.GTlsPassword         // out
	var _arg2 *C.GCancellable         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GTlsPassword)(unsafe.Pointer(password.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_tls_interaction_invoke_ask_password(_arg0, _arg1, _arg2, &_cerr)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsInteractionResult, _goerr
}

func (i tlsInteraction) InvokeRequestCertificate(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction            // out
	var _arg1 *C.GTlsConnection             // out
	var _arg2 C.GTlsCertificateRequestFlags // out
	var _arg3 *C.GCancellable               // out
	var _cret C.GTlsInteractionResult       // in
	var _cerr *C.GError                     // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GTlsConnection)(unsafe.Pointer(connection.Native()))
	_arg2 = (C.GTlsCertificateRequestFlags)(flags)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_tls_interaction_invoke_request_certificate(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsInteractionResult, _goerr
}

func (i tlsInteraction) RequestCertificate(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction            // out
	var _arg1 *C.GTlsConnection             // out
	var _arg2 C.GTlsCertificateRequestFlags // out
	var _arg3 *C.GCancellable               // out
	var _cret C.GTlsInteractionResult       // in
	var _cerr *C.GError                     // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GTlsConnection)(unsafe.Pointer(connection.Native()))
	_arg2 = (C.GTlsCertificateRequestFlags)(flags)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_tls_interaction_request_certificate(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsInteractionResult, _goerr
}

func (i tlsInteraction) RequestCertificateFinish(result AsyncResult) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction      // out
	var _arg1 *C.GAsyncResult         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_tls_interaction_request_certificate_finish(_arg0, _arg1, &_cerr)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _tlsInteractionResult, _goerr
}

// TLSPassword holds a password used in TLS.
type TLSPassword interface {
	gextras.Objector

	// Description: get a description string about what the password will be
	// used for.
	Description() string
	// Flags: get flags about the password.
	Flags() TLSPasswordFlags
	// Value: get the password value. If @length is not nil then it will be
	// filled in with the length of the password value. (Note that the password
	// value is not nul-terminated, so you can only pass nil for @length in
	// contexts where you know the password will have a certain fixed length.)
	Value(length *uint) *byte
	// Warning: get a user readable translated warning. Usually this warning is
	// a representation of the password flags returned from
	// g_tls_password_get_flags().
	Warning() string
	// SetDescription: set a description string about what the password will be
	// used for.
	SetDescription(description string)
	// SetFlags: set flags about the password.
	SetFlags(flags TLSPasswordFlags)
	// SetValue: set the value for this password. The @value will be copied by
	// the password object.
	//
	// Specify the @length, for a non-nul-terminated password. Pass -1 as
	// @length if using a nul-terminated password, and @length will be
	// calculated automatically. (Note that the terminating nul is not
	// considered part of the password in this case.)
	SetValue(value []byte)
	// SetWarning: set a user readable translated warning. Usually this warning
	// is a representation of the password flags returned from
	// g_tls_password_get_flags().
	SetWarning(warning string)
}

// tlsPassword implements the TLSPassword class.
type tlsPassword struct {
	gextras.Objector
}

var _ TLSPassword = (*tlsPassword)(nil)

// WrapTLSPassword wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSPassword(obj *externglib.Object) TLSPassword {
	return tlsPassword{
		Objector: obj,
	}
}

func marshalTLSPassword(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSPassword(obj), nil
}

// NewTLSPassword: create a new Password object.
func NewTLSPassword(flags TLSPasswordFlags, description string) TLSPassword {
	var _arg1 C.GTlsPasswordFlags // out
	var _arg2 *C.gchar            // out
	var _cret *C.GTlsPassword     // in

	_arg1 = (C.GTlsPasswordFlags)(flags)
	_arg2 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_tls_password_new(_arg1, _arg2)

	var _tlsPassword TLSPassword // out

	_tlsPassword = WrapTLSPassword(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _tlsPassword
}

func (p tlsPassword) Description() string {
	var _arg0 *C.GTlsPassword // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))

	_cret = C.g_tls_password_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p tlsPassword) Flags() TLSPasswordFlags {
	var _arg0 *C.GTlsPassword     // out
	var _cret C.GTlsPasswordFlags // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))

	_cret = C.g_tls_password_get_flags(_arg0)

	var _tlsPasswordFlags TLSPasswordFlags // out

	_tlsPasswordFlags = TLSPasswordFlags(_cret)

	return _tlsPasswordFlags
}

func (p tlsPassword) Value(length *uint) *byte {
	var _arg0 *C.GTlsPassword // out
	var _arg1 *C.gsize        // out
	var _cret *C.guchar       // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gsize)(unsafe.Pointer(length))

	_cret = C.g_tls_password_get_value(_arg0, _arg1)

	var _guint8 *byte // out

	_guint8 = (*byte)(_cret)

	return _guint8
}

func (p tlsPassword) Warning() string {
	var _arg0 *C.GTlsPassword // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))

	_cret = C.g_tls_password_get_warning(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p tlsPassword) SetDescription(description string) {
	var _arg0 *C.GTlsPassword // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_tls_password_set_description(_arg0, _arg1)
}

func (p tlsPassword) SetFlags(flags TLSPasswordFlags) {
	var _arg0 *C.GTlsPassword     // out
	var _arg1 C.GTlsPasswordFlags // out

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
	_arg1 = (C.GTlsPasswordFlags)(flags)

	C.g_tls_password_set_flags(_arg0, _arg1)
}

func (p tlsPassword) SetValue(value []byte) {
	var _arg0 *C.GTlsPassword // out
	var _arg1 *C.guchar
	var _arg2 C.gssize

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
	_arg2 = C.gssize(len(value))
	_arg1 = (*C.guchar)(unsafe.Pointer(&value[0]))

	C.g_tls_password_set_value(_arg0, _arg1, _arg2)
}

func (p tlsPassword) SetWarning(warning string) {
	var _arg0 *C.GTlsPassword // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(warning))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_tls_password_set_warning(_arg0, _arg1)
}

// UnixConnection: this is the subclass of Connection that is created for UNIX
// domain sockets.
//
// It contains functions to do some of the UNIX socket specific functionality
// like passing file descriptors.
//
// Note that `<gio/gunixconnection.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixConnection interface {
	SocketConnection

	// ReceiveCredentials receives credentials from the sending end of the
	// connection. The sending end has to call
	// g_unix_connection_send_credentials() (or similar) for this to work.
	//
	// As well as reading the credentials this also reads (and discards) a
	// single byte from the stream, as this is required for credentials passing
	// to work on some implementations.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since
	// GLib 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd
	// since GLib 2.40
	//
	// Other ways to exchange credentials with a foreign peer includes the
	// CredentialsMessage type and g_socket_get_credentials() function.
	ReceiveCredentials(cancellable Cancellable) (Credentials, error)
	// ReceiveCredentialsFinish finishes an asynchronous receive credentials
	// operation started with g_unix_connection_receive_credentials_async().
	ReceiveCredentialsFinish(result AsyncResult) (Credentials, error)
	// ReceiveFd receives a file descriptor from the sending end of the
	// connection. The sending end has to call g_unix_connection_send_fd() for
	// this to work.
	//
	// As well as reading the fd this also reads a single byte from the stream,
	// as this is required for fd passing to work on some implementations.
	ReceiveFd(cancellable Cancellable) (int, error)
	// SendCredentials passes the credentials of the current user the receiving
	// side of the connection. The receiving end has to call
	// g_unix_connection_receive_credentials() (or similar) to accept the
	// credentials.
	//
	// As well as sending the credentials this also writes a single NUL byte to
	// the stream, as this is required for credentials passing to work on some
	// implementations.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since
	// GLib 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd
	// since GLib 2.40
	//
	// Other ways to exchange credentials with a foreign peer includes the
	// CredentialsMessage type and g_socket_get_credentials() function.
	SendCredentials(cancellable Cancellable) error
	// SendCredentialsFinish finishes an asynchronous send credentials operation
	// started with g_unix_connection_send_credentials_async().
	SendCredentialsFinish(result AsyncResult) error
	// SendFd passes a file descriptor to the receiving side of the connection.
	// The receiving end has to call g_unix_connection_receive_fd() to accept
	// the file descriptor.
	//
	// As well as sending the fd this also writes a single byte to the stream,
	// as this is required for fd passing to work on some implementations.
	SendFd(fd int, cancellable Cancellable) error
}

// unixConnection implements the UnixConnection class.
type unixConnection struct {
	SocketConnection
}

var _ UnixConnection = (*unixConnection)(nil)

// WrapUnixConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixConnection(obj *externglib.Object) UnixConnection {
	return unixConnection{
		SocketConnection: WrapSocketConnection(obj),
	}
}

func marshalUnixConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixConnection(obj), nil
}

func (c unixConnection) ReceiveCredentials(cancellable Cancellable) (Credentials, error) {
	var _arg0 *C.GUnixConnection // out
	var _arg1 *C.GCancellable    // out
	var _cret *C.GCredentials    // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_unix_connection_receive_credentials(_arg0, _arg1, &_cerr)

	var _credentials Credentials // out
	var _goerr error             // out

	_credentials = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Credentials)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _credentials, _goerr
}

func (c unixConnection) ReceiveCredentialsFinish(result AsyncResult) (Credentials, error) {
	var _arg0 *C.GUnixConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GCredentials    // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_unix_connection_receive_credentials_finish(_arg0, _arg1, &_cerr)

	var _credentials Credentials // out
	var _goerr error             // out

	_credentials = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Credentials)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _credentials, _goerr
}

func (c unixConnection) ReceiveFd(cancellable Cancellable) (int, error) {
	var _arg0 *C.GUnixConnection // out
	var _arg1 *C.GCancellable    // out
	var _cret C.gint             // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_unix_connection_receive_fd(_arg0, _arg1, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (c unixConnection) SendCredentials(cancellable Cancellable) error {
	var _arg0 *C.GUnixConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_unix_connection_send_credentials(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c unixConnection) SendCredentialsFinish(result AsyncResult) error {
	var _arg0 *C.GUnixConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_unix_connection_send_credentials_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c unixConnection) SendFd(fd int, cancellable Cancellable) error {
	var _arg0 *C.GUnixConnection // out
	var _arg1 C.gint             // out
	var _arg2 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(fd)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_unix_connection_send_fd(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// UnixCredentialsMessage: this ControlMessage contains a #GCredentials
// instance. It may be sent using g_socket_send_message() and received using
// g_socket_receive_message() over UNIX sockets (ie: sockets in the
// G_SOCKET_FAMILY_UNIX family).
//
// For an easier way to send and receive credentials over stream-oriented UNIX
// sockets, see g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials(). To receive credentials of a foreign
// process connected to a socket, use g_socket_get_credentials().
type UnixCredentialsMessage interface {
	SocketControlMessage

	// Credentials gets the credentials stored in @message.
	Credentials() Credentials
}

// unixCredentialsMessage implements the UnixCredentialsMessage class.
type unixCredentialsMessage struct {
	SocketControlMessage
}

var _ UnixCredentialsMessage = (*unixCredentialsMessage)(nil)

// WrapUnixCredentialsMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixCredentialsMessage(obj *externglib.Object) UnixCredentialsMessage {
	return unixCredentialsMessage{
		SocketControlMessage: WrapSocketControlMessage(obj),
	}
}

func marshalUnixCredentialsMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixCredentialsMessage(obj), nil
}

// NewUnixCredentialsMessage creates a new CredentialsMessage with credentials
// matching the current processes.
func NewUnixCredentialsMessage() UnixCredentialsMessage {
	var _cret *C.GSocketControlMessage // in

	_cret = C.g_unix_credentials_message_new()

	var _unixCredentialsMessage UnixCredentialsMessage // out

	_unixCredentialsMessage = WrapUnixCredentialsMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixCredentialsMessage
}

// NewUnixCredentialsMessageWithCredentials creates a new CredentialsMessage
// holding @credentials.
func NewUnixCredentialsMessageWithCredentials(credentials Credentials) UnixCredentialsMessage {
	var _arg1 *C.GCredentials          // out
	var _cret *C.GSocketControlMessage // in

	_arg1 = (*C.GCredentials)(unsafe.Pointer(credentials.Native()))

	_cret = C.g_unix_credentials_message_new_with_credentials(_arg1)

	var _unixCredentialsMessage UnixCredentialsMessage // out

	_unixCredentialsMessage = WrapUnixCredentialsMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixCredentialsMessage
}

func (m unixCredentialsMessage) Credentials() Credentials {
	var _arg0 *C.GUnixCredentialsMessage // out
	var _cret *C.GCredentials            // in

	_arg0 = (*C.GUnixCredentialsMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_credentials_message_get_credentials(_arg0)

	var _credentials Credentials // out

	_credentials = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Credentials)

	return _credentials
}

// UnixFDList: a FDList contains a list of file descriptors. It owns the file
// descriptors that it contains, closing them when finalized.
//
// It may be wrapped in a FDMessage and sent over a #GSocket in the
// G_SOCKET_FAMILY_UNIX family by using g_socket_send_message() and received
// using g_socket_receive_message().
//
// Note that `<gio/gunixfdlist.h>` belongs to the UNIX-specific GIO interfaces,
// thus you have to use the `gio-unix-2.0.pc` pkg-config file when using it.
type UnixFDList interface {
	gextras.Objector

	// Append adds a file descriptor to @list.
	//
	// The file descriptor is duplicated using dup(). You keep your copy of the
	// descriptor and the copy contained in @list will be closed when @list is
	// finalized.
	//
	// A possible cause of failure is exceeding the per-process or system-wide
	// file descriptor limit.
	//
	// The index of the file descriptor in the list is returned. If you use this
	// index with g_unix_fd_list_get() then you will receive back a duplicated
	// copy of the same file descriptor.
	Append(fd int) (int, error)
	// Get gets a file descriptor out of @list.
	//
	// @index_ specifies the index of the file descriptor to get. It is a
	// programmer error for @index_ to be out of range; see
	// g_unix_fd_list_get_length().
	//
	// The file descriptor is duplicated using dup() and set as close-on-exec
	// before being returned. You must call close() on it when you are done.
	//
	// A possible cause of failure is exceeding the per-process or system-wide
	// file descriptor limit.
	Get(index_ int) (int, error)
	// Length gets the length of @list (ie: the number of file descriptors
	// contained within).
	Length() int
}

// unixFDList implements the UnixFDList class.
type unixFDList struct {
	gextras.Objector
}

var _ UnixFDList = (*unixFDList)(nil)

// WrapUnixFDList wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixFDList(obj *externglib.Object) UnixFDList {
	return unixFDList{
		Objector: obj,
	}
}

func marshalUnixFDList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixFDList(obj), nil
}

// NewUnixFDList creates a new FDList containing no file descriptors.
func NewUnixFDList() UnixFDList {
	var _cret *C.GUnixFDList // in

	_cret = C.g_unix_fd_list_new()

	var _unixFDList UnixFDList // out

	_unixFDList = WrapUnixFDList(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixFDList
}

// NewUnixFDListFromArray creates a new FDList containing the file descriptors
// given in @fds. The file descriptors become the property of the new list and
// may no longer be used by the caller. The array itself is owned by the caller.
//
// Each file descriptor in the array should be set to close-on-exec.
//
// If @n_fds is -1 then @fds must be terminated with -1.
func NewUnixFDListFromArray(fds []int) UnixFDList {
	var _arg1 *C.gint
	var _arg2 C.gint
	var _cret *C.GUnixFDList // in

	_arg2 = C.gint(len(fds))
	_arg1 = (*C.gint)(unsafe.Pointer(&fds[0]))

	_cret = C.g_unix_fd_list_new_from_array(_arg1, _arg2)

	var _unixFDList UnixFDList // out

	_unixFDList = WrapUnixFDList(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixFDList
}

func (l unixFDList) Append(fd int) (int, error) {
	var _arg0 *C.GUnixFDList // out
	var _arg1 C.gint         // out
	var _cret C.gint         // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GUnixFDList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.gint)(fd)

	_cret = C.g_unix_fd_list_append(_arg0, _arg1, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (l unixFDList) Get(index_ int) (int, error) {
	var _arg0 *C.GUnixFDList // out
	var _arg1 C.gint         // out
	var _cret C.gint         // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GUnixFDList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.gint)(index_)

	_cret = C.g_unix_fd_list_get(_arg0, _arg1, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (l unixFDList) Length() int {
	var _arg0 *C.GUnixFDList // out
	var _cret C.gint         // in

	_arg0 = (*C.GUnixFDList)(unsafe.Pointer(l.Native()))

	_cret = C.g_unix_fd_list_get_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnixFDMessage: this ControlMessage contains a FDList. It may be sent using
// g_socket_send_message() and received using g_socket_receive_message() over
// UNIX sockets (ie: sockets in the G_SOCKET_FAMILY_UNIX family). The file
// descriptors are copied between processes by the kernel.
//
// For an easier way to send and receive file descriptors over stream-oriented
// UNIX sockets, see g_unix_connection_send_fd() and
// g_unix_connection_receive_fd().
//
// Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixFDMessage interface {
	SocketControlMessage

	// AppendFd adds a file descriptor to @message.
	//
	// The file descriptor is duplicated using dup(). You keep your copy of the
	// descriptor and the copy contained in @message will be closed when
	// @message is finalized.
	//
	// A possible cause of failure is exceeding the per-process or system-wide
	// file descriptor limit.
	AppendFd(fd int) error
	// FdList gets the FDList contained in @message. This function does not
	// return a reference to the caller, but the returned list is valid for the
	// lifetime of @message.
	FdList() UnixFDList
}

// unixFDMessage implements the UnixFDMessage class.
type unixFDMessage struct {
	SocketControlMessage
}

var _ UnixFDMessage = (*unixFDMessage)(nil)

// WrapUnixFDMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixFDMessage(obj *externglib.Object) UnixFDMessage {
	return unixFDMessage{
		SocketControlMessage: WrapSocketControlMessage(obj),
	}
}

func marshalUnixFDMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixFDMessage(obj), nil
}

// NewUnixFDMessage creates a new FDMessage containing an empty file descriptor
// list.
func NewUnixFDMessage() UnixFDMessage {
	var _cret *C.GSocketControlMessage // in

	_cret = C.g_unix_fd_message_new()

	var _unixFDMessage UnixFDMessage // out

	_unixFDMessage = WrapUnixFDMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixFDMessage
}

// NewUnixFDMessageWithFdList creates a new FDMessage containing @list.
func NewUnixFDMessageWithFdList(fdList UnixFDList) UnixFDMessage {
	var _arg1 *C.GUnixFDList           // out
	var _cret *C.GSocketControlMessage // in

	_arg1 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	_cret = C.g_unix_fd_message_new_with_fd_list(_arg1)

	var _unixFDMessage UnixFDMessage // out

	_unixFDMessage = WrapUnixFDMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixFDMessage
}

func (m unixFDMessage) AppendFd(fd int) error {
	var _arg0 *C.GUnixFDMessage // out
	var _arg1 C.gint            // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GUnixFDMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(fd)

	C.g_unix_fd_message_append_fd(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (m unixFDMessage) FdList() UnixFDList {
	var _arg0 *C.GUnixFDMessage // out
	var _cret *C.GUnixFDList    // in

	_arg0 = (*C.GUnixFDMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_fd_message_get_fd_list(_arg0)

	var _unixFDList UnixFDList // out

	_unixFDList = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(UnixFDList)

	return _unixFDList
}

// UnixInputStream implements Stream for reading from a UNIX file descriptor,
// including asynchronous operations. (If the file descriptor refers to a socket
// or pipe, this will use poll() to do asynchronous I/O. If it refers to a
// regular file, it will fall back to doing asynchronous I/O in another thread.)
//
// Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixInputStream interface {
	InputStream
	FileDescriptorBased
	PollableInputStream

	// CloseFd returns whether the file descriptor of @stream will be closed
	// when the stream is closed.
	CloseFd() bool
	// Fd: return the UNIX file descriptor that the stream reads from.
	Fd() int
	// SetCloseFd sets whether the file descriptor of @stream shall be closed
	// when the stream is closed.
	SetCloseFd(closeFd bool)
}

// unixInputStream implements the UnixInputStream class.
type unixInputStream struct {
	InputStream
	FileDescriptorBased
	PollableInputStream
}

var _ UnixInputStream = (*unixInputStream)(nil)

// WrapUnixInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixInputStream(obj *externglib.Object) UnixInputStream {
	return unixInputStream{
		InputStream:         WrapInputStream(obj),
		FileDescriptorBased: WrapFileDescriptorBased(obj),
		PollableInputStream: WrapPollableInputStream(obj),
	}
}

func marshalUnixInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixInputStream(obj), nil
}

// NewUnixInputStream creates a new InputStream for the given @fd.
//
// If @close_fd is true, the file descriptor will be closed when the stream is
// closed.
func NewUnixInputStream(fd int, closeFd bool) UnixInputStream {
	var _arg1 C.gint          // out
	var _arg2 C.gboolean      // out
	var _cret *C.GInputStream // in

	_arg1 = (C.gint)(fd)
	if closeFd {
		_arg2 = C.TRUE
	}

	_cret = C.g_unix_input_stream_new(_arg1, _arg2)

	var _unixInputStream UnixInputStream // out

	_unixInputStream = WrapUnixInputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixInputStream
}

func (s unixInputStream) CloseFd() bool {
	var _arg0 *C.GUnixInputStream // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GUnixInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_unix_input_stream_get_close_fd(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s unixInputStream) Fd() int {
	var _arg0 *C.GUnixInputStream // out
	var _cret C.gint              // in

	_arg0 = (*C.GUnixInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_unix_input_stream_get_fd(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s unixInputStream) SetCloseFd(closeFd bool) {
	var _arg0 *C.GUnixInputStream // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GUnixInputStream)(unsafe.Pointer(s.Native()))
	if closeFd {
		_arg1 = C.TRUE
	}

	C.g_unix_input_stream_set_close_fd(_arg0, _arg1)
}

// UnixMountMonitor watches Mounts for changes.
type UnixMountMonitor interface {
	gextras.Objector

	// SetRateLimit: this function does nothing.
	//
	// Before 2.44, this was a partially-effective way of controlling the rate
	// at which events would be reported under some uncommon circumstances.
	// Since @mount_monitor is a singleton, it also meant that calling this
	// function would have side effects for other users of the monitor.
	SetRateLimit(limitMsec int)
}

// unixMountMonitor implements the UnixMountMonitor class.
type unixMountMonitor struct {
	gextras.Objector
}

var _ UnixMountMonitor = (*unixMountMonitor)(nil)

// WrapUnixMountMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixMountMonitor(obj *externglib.Object) UnixMountMonitor {
	return unixMountMonitor{
		Objector: obj,
	}
}

func marshalUnixMountMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixMountMonitor(obj), nil
}

// NewUnixMountMonitor: deprecated alias for g_unix_mount_monitor_get().
//
// This function was never a true constructor, which is why it was renamed.
func NewUnixMountMonitor() UnixMountMonitor {
	var _cret *C.GUnixMountMonitor // in

	_cret = C.g_unix_mount_monitor_new()

	var _unixMountMonitor UnixMountMonitor // out

	_unixMountMonitor = WrapUnixMountMonitor(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixMountMonitor
}

func (m unixMountMonitor) SetRateLimit(limitMsec int) {
	var _arg0 *C.GUnixMountMonitor // out
	var _arg1 C.int                // out

	_arg0 = (*C.GUnixMountMonitor)(unsafe.Pointer(m.Native()))
	_arg1 = (C.int)(limitMsec)

	C.g_unix_mount_monitor_set_rate_limit(_arg0, _arg1)
}

// UnixOutputStream implements Stream for writing to a UNIX file descriptor,
// including asynchronous operations. (If the file descriptor refers to a socket
// or pipe, this will use poll() to do asynchronous I/O. If it refers to a
// regular file, it will fall back to doing asynchronous I/O in another thread.)
//
// Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixOutputStream interface {
	OutputStream
	FileDescriptorBased
	PollableOutputStream

	// CloseFd returns whether the file descriptor of @stream will be closed
	// when the stream is closed.
	CloseFd() bool
	// Fd: return the UNIX file descriptor that the stream writes to.
	Fd() int
	// SetCloseFd sets whether the file descriptor of @stream shall be closed
	// when the stream is closed.
	SetCloseFd(closeFd bool)
}

// unixOutputStream implements the UnixOutputStream class.
type unixOutputStream struct {
	OutputStream
	FileDescriptorBased
	PollableOutputStream
}

var _ UnixOutputStream = (*unixOutputStream)(nil)

// WrapUnixOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixOutputStream(obj *externglib.Object) UnixOutputStream {
	return unixOutputStream{
		OutputStream:         WrapOutputStream(obj),
		FileDescriptorBased:  WrapFileDescriptorBased(obj),
		PollableOutputStream: WrapPollableOutputStream(obj),
	}
}

func marshalUnixOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixOutputStream(obj), nil
}

// NewUnixOutputStream creates a new OutputStream for the given @fd.
//
// If @close_fd, is true, the file descriptor will be closed when the output
// stream is destroyed.
func NewUnixOutputStream(fd int, closeFd bool) UnixOutputStream {
	var _arg1 C.gint           // out
	var _arg2 C.gboolean       // out
	var _cret *C.GOutputStream // in

	_arg1 = (C.gint)(fd)
	if closeFd {
		_arg2 = C.TRUE
	}

	_cret = C.g_unix_output_stream_new(_arg1, _arg2)

	var _unixOutputStream UnixOutputStream // out

	_unixOutputStream = WrapUnixOutputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixOutputStream
}

func (s unixOutputStream) CloseFd() bool {
	var _arg0 *C.GUnixOutputStream // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GUnixOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_unix_output_stream_get_close_fd(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s unixOutputStream) Fd() int {
	var _arg0 *C.GUnixOutputStream // out
	var _cret C.gint               // in

	_arg0 = (*C.GUnixOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_unix_output_stream_get_fd(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s unixOutputStream) SetCloseFd(closeFd bool) {
	var _arg0 *C.GUnixOutputStream // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GUnixOutputStream)(unsafe.Pointer(s.Native()))
	if closeFd {
		_arg1 = C.TRUE
	}

	C.g_unix_output_stream_set_close_fd(_arg0, _arg1)
}

// UnixSocketAddress: support for UNIX-domain (also known as local) sockets.
//
// UNIX domain sockets are generally visible in the filesystem. However, some
// systems support abstract socket names which are not visible in the filesystem
// and not affected by the filesystem permissions, visibility, etc. Currently
// this is only supported under Linux. If you attempt to use abstract sockets on
// other systems, function calls may return G_IO_ERROR_NOT_SUPPORTED errors. You
// can use g_unix_socket_address_abstract_names_supported() to see if abstract
// names are supported.
//
// Note that `<gio/gunixsocketaddress.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixSocketAddress interface {
	SocketAddress
	SocketConnectable

	// AddressType gets @address's type.
	AddressType() UnixSocketAddressType
	// IsAbstract tests if @address is abstract.
	IsAbstract() bool
	// Path gets @address's path, or for abstract sockets the "name".
	//
	// Guaranteed to be zero-terminated, but an abstract socket may contain
	// embedded zeros, and thus you should use
	// g_unix_socket_address_get_path_len() to get the true length of this
	// string.
	Path() string
	// PathLen gets the length of @address's path.
	//
	// For details, see g_unix_socket_address_get_path().
	PathLen() uint
}

// unixSocketAddress implements the UnixSocketAddress class.
type unixSocketAddress struct {
	SocketAddress
	SocketConnectable
}

var _ UnixSocketAddress = (*unixSocketAddress)(nil)

// WrapUnixSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixSocketAddress(obj *externglib.Object) UnixSocketAddress {
	return unixSocketAddress{
		SocketAddress:     WrapSocketAddress(obj),
		SocketConnectable: WrapSocketConnectable(obj),
	}
}

func marshalUnixSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixSocketAddress(obj), nil
}

// NewUnixSocketAddress creates a new SocketAddress for @path.
//
// To create abstract socket addresses, on systems that support that, use
// g_unix_socket_address_new_abstract().
func NewUnixSocketAddress(path string) UnixSocketAddress {
	var _arg1 *C.gchar          // out
	var _cret *C.GSocketAddress // in

	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_unix_socket_address_new(_arg1)

	var _unixSocketAddress UnixSocketAddress // out

	_unixSocketAddress = WrapUnixSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixSocketAddress
}

// NewUnixSocketAddressAbstract creates a new
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED SocketAddress for @path.
func NewUnixSocketAddressAbstract(path []byte) UnixSocketAddress {
	var _arg1 *C.gchar
	var _arg2 C.gint
	var _cret *C.GSocketAddress // in

	_arg2 = C.gint(len(path))
	_arg1 = (*C.gchar)(unsafe.Pointer(&path[0]))

	_cret = C.g_unix_socket_address_new_abstract(_arg1, _arg2)

	var _unixSocketAddress UnixSocketAddress // out

	_unixSocketAddress = WrapUnixSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixSocketAddress
}

// NewUnixSocketAddressWithType creates a new SocketAddress of type @type with
// name @path.
//
// If @type is G_UNIX_SOCKET_ADDRESS_PATH, this is equivalent to calling
// g_unix_socket_address_new().
//
// If @type is G_UNIX_SOCKET_ADDRESS_ANONYMOUS, @path and @path_len will be
// ignored.
//
// If @path_type is G_UNIX_SOCKET_ADDRESS_ABSTRACT, then @path_len bytes of
// @path will be copied to the socket's path, and only those bytes will be
// considered part of the name. (If @path_len is -1, then @path is assumed to be
// NUL-terminated.) For example, if @path was "test", then calling
// g_socket_address_get_native_size() on the returned socket would return 7 (2
// bytes of overhead, 1 byte for the abstract-socket indicator byte, and 4 bytes
// for the name "test").
//
// If @path_type is G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, then @path_len bytes
// of @path will be copied to the socket's path, the rest of the path will be
// padded with 0 bytes, and the entire zero-padded buffer will be considered the
// name. (As above, if @path_len is -1, then @path is assumed to be
// NUL-terminated.) In this case, g_socket_address_get_native_size() will always
// return the full size of a `struct sockaddr_un`, although
// g_unix_socket_address_get_path_len() will still return just the length of
// @path.
//
// G_UNIX_SOCKET_ADDRESS_ABSTRACT is preferred over
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED for new programs. Of course, when
// connecting to a server created by another process, you must use the
// appropriate type corresponding to how that process created its listening
// socket.
func NewUnixSocketAddressWithType(path []byte, typ UnixSocketAddressType) UnixSocketAddress {
	var _arg1 *C.gchar
	var _arg2 C.gint
	var _arg3 C.GUnixSocketAddressType // out
	var _cret *C.GSocketAddress        // in

	_arg2 = C.gint(len(path))
	_arg1 = (*C.gchar)(unsafe.Pointer(&path[0]))
	_arg3 = (C.GUnixSocketAddressType)(typ)

	_cret = C.g_unix_socket_address_new_with_type(_arg1, _arg2, _arg3)

	var _unixSocketAddress UnixSocketAddress // out

	_unixSocketAddress = WrapUnixSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _unixSocketAddress
}

func (a unixSocketAddress) AddressType() UnixSocketAddressType {
	var _arg0 *C.GUnixSocketAddress    // out
	var _cret C.GUnixSocketAddressType // in

	_arg0 = (*C.GUnixSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_unix_socket_address_get_address_type(_arg0)

	var _unixSocketAddressType UnixSocketAddressType // out

	_unixSocketAddressType = UnixSocketAddressType(_cret)

	return _unixSocketAddressType
}

func (a unixSocketAddress) IsAbstract() bool {
	var _arg0 *C.GUnixSocketAddress // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GUnixSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_unix_socket_address_get_is_abstract(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a unixSocketAddress) Path() string {
	var _arg0 *C.GUnixSocketAddress // out
	var _cret *C.char               // in

	_arg0 = (*C.GUnixSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_unix_socket_address_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a unixSocketAddress) PathLen() uint {
	var _arg0 *C.GUnixSocketAddress // out
	var _cret C.gsize               // in

	_arg0 = (*C.GUnixSocketAddress)(unsafe.Pointer(a.Native()))

	_cret = C.g_unix_socket_address_get_path_len(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// VFS: entry point for using GIO functionality.
type VFS interface {
	gextras.Objector

	// FileForPath gets a #GFile for @path.
	FileForPath(path string) File
	// FileForURI gets a #GFile for @uri.
	//
	// This operation never fails, but the returned object might not support any
	// I/O operation if the URI is malformed or if the URI scheme is not
	// supported.
	FileForURI(uri string) File
	// SupportedURISchemes gets a list of URI schemes supported by @vfs.
	SupportedURISchemes() []string
	// IsActive checks if the VFS is active.
	IsActive() bool
	// ParseName: this operation never fails, but the returned object might not
	// support any I/O operations if the @parse_name cannot be parsed by the
	// #GVfs module.
	ParseName(parseName string) File
	// UnregisterURIScheme unregisters the URI handler for @scheme previously
	// registered with g_vfs_register_uri_scheme().
	UnregisterURIScheme(scheme string) bool
}

// vfS implements the VFS class.
type vfS struct {
	gextras.Objector
}

var _ VFS = (*vfS)(nil)

// WrapVFS wraps a GObject to the right type. It is
// primarily used internally.
func WrapVFS(obj *externglib.Object) VFS {
	return vfS{
		Objector: obj,
	}
}

func marshalVFS(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVFS(obj), nil
}

func (v vfS) FileForPath(path string) File {
	var _arg0 *C.GVfs  // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_vfs_get_file_for_path(_arg0, _arg1)

	var _file File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _file
}

func (v vfS) FileForURI(uri string) File {
	var _arg0 *C.GVfs  // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_vfs_get_file_for_uri(_arg0, _arg1)

	var _file File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _file
}

func (v vfS) SupportedURISchemes() []string {
	var _arg0 *C.GVfs // out
	var _cret **C.gchar

	_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))

	_cret = C.g_vfs_get_supported_uri_schemes(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (v vfS) IsActive() bool {
	var _arg0 *C.GVfs    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))

	_cret = C.g_vfs_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (v vfS) ParseName(parseName string) File {
	var _arg0 *C.GVfs  // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.char)(C.CString(parseName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_vfs_parse_name(_arg0, _arg1)

	var _file File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

	return _file
}

func (v vfS) UnregisterURIScheme(scheme string) bool {
	var _arg0 *C.GVfs    // out
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.char)(C.CString(scheme))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_vfs_unregister_uri_scheme(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VolumeMonitor is for listing the user interesting devices and volumes on the
// computer. In other words, what a file selector or file manager would show in
// a sidebar.
//
// Monitor is not [thread-default-context
// aware][g-main-context-push-thread-default], and so should not be used other
// than from the main thread, with no thread-default-context active.
//
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor interface {
	gextras.Objector

	// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid())
	MountForUUID(uuid string) Mount
	// VolumeForUUID finds a #GVolume object by its UUID (see
	// g_volume_get_uuid())
	VolumeForUUID(uuid string) Volume
}

// volumeMonitor implements the VolumeMonitor class.
type volumeMonitor struct {
	gextras.Objector
}

var _ VolumeMonitor = (*volumeMonitor)(nil)

// WrapVolumeMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapVolumeMonitor(obj *externglib.Object) VolumeMonitor {
	return volumeMonitor{
		Objector: obj,
	}
}

func marshalVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVolumeMonitor(obj), nil
}

func (v volumeMonitor) MountForUUID(uuid string) Mount {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GMount         // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.char)(C.CString(uuid))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_mount_for_uuid(_arg0, _arg1)

	var _mount Mount // out

	_mount = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Mount)

	return _mount
}

func (v volumeMonitor) VolumeForUUID(uuid string) Volume {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GVolume        // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.char)(C.CString(uuid))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_volume_for_uuid(_arg0, _arg1)

	var _volume Volume // out

	_volume = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Volume)

	return _volume
}

// ZlibCompressor: zlib decompression
type ZlibCompressor interface {
	gextras.Objector
	Converter

	// FileInfo returns the Compressor:file-info property.
	FileInfo() FileInfo
	// SetFileInfo sets @file_info in @compressor. If non-nil, and @compressor's
	// Compressor:format property is G_ZLIB_COMPRESSOR_FORMAT_GZIP, it will be
	// used to set the file name and modification time in the GZIP header of the
	// compressed data.
	//
	// Note: it is an error to call this function while a compression is in
	// progress; it may only be called immediately after creation of
	// @compressor, or after resetting it with g_converter_reset().
	SetFileInfo(fileInfo FileInfo)
}

// zlibCompressor implements the ZlibCompressor class.
type zlibCompressor struct {
	gextras.Objector
	Converter
}

var _ ZlibCompressor = (*zlibCompressor)(nil)

// WrapZlibCompressor wraps a GObject to the right type. It is
// primarily used internally.
func WrapZlibCompressor(obj *externglib.Object) ZlibCompressor {
	return zlibCompressor{
		Objector:  obj,
		Converter: WrapConverter(obj),
	}
}

func marshalZlibCompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapZlibCompressor(obj), nil
}

// NewZlibCompressor creates a new Compressor.
func NewZlibCompressor(format ZlibCompressorFormat, level int) ZlibCompressor {
	var _arg1 C.GZlibCompressorFormat // out
	var _arg2 C.int                   // out
	var _cret *C.GZlibCompressor      // in

	_arg1 = (C.GZlibCompressorFormat)(format)
	_arg2 = (C.int)(level)

	_cret = C.g_zlib_compressor_new(_arg1, _arg2)

	var _zlibCompressor ZlibCompressor // out

	_zlibCompressor = WrapZlibCompressor(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _zlibCompressor
}

func (c zlibCompressor) FileInfo() FileInfo {
	var _arg0 *C.GZlibCompressor // out
	var _cret *C.GFileInfo       // in

	_arg0 = (*C.GZlibCompressor)(unsafe.Pointer(c.Native()))

	_cret = C.g_zlib_compressor_get_file_info(_arg0)

	var _fileInfo FileInfo // out

	_fileInfo = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FileInfo)

	return _fileInfo
}

func (c zlibCompressor) SetFileInfo(fileInfo FileInfo) {
	var _arg0 *C.GZlibCompressor // out
	var _arg1 *C.GFileInfo       // out

	_arg0 = (*C.GZlibCompressor)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(fileInfo.Native()))

	C.g_zlib_compressor_set_file_info(_arg0, _arg1)
}

// ZlibDecompressor: zlib decompression
type ZlibDecompressor interface {
	gextras.Objector
	Converter

	// FileInfo retrieves the Info constructed from the GZIP header data of
	// compressed data processed by @compressor, or nil if @decompressor's
	// Decompressor:format property is not G_ZLIB_COMPRESSOR_FORMAT_GZIP, or the
	// header data was not fully processed yet, or it not present in the data
	// stream at all.
	FileInfo() FileInfo
}

// zlibDecompressor implements the ZlibDecompressor class.
type zlibDecompressor struct {
	gextras.Objector
	Converter
}

var _ ZlibDecompressor = (*zlibDecompressor)(nil)

// WrapZlibDecompressor wraps a GObject to the right type. It is
// primarily used internally.
func WrapZlibDecompressor(obj *externglib.Object) ZlibDecompressor {
	return zlibDecompressor{
		Objector:  obj,
		Converter: WrapConverter(obj),
	}
}

func marshalZlibDecompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapZlibDecompressor(obj), nil
}

// NewZlibDecompressor creates a new Decompressor.
func NewZlibDecompressor(format ZlibCompressorFormat) ZlibDecompressor {
	var _arg1 C.GZlibCompressorFormat // out
	var _cret *C.GZlibDecompressor    // in

	_arg1 = (C.GZlibCompressorFormat)(format)

	_cret = C.g_zlib_decompressor_new(_arg1)

	var _zlibDecompressor ZlibDecompressor // out

	_zlibDecompressor = WrapZlibDecompressor(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _zlibDecompressor
}

func (d zlibDecompressor) FileInfo() FileInfo {
	var _arg0 *C.GZlibDecompressor // out
	var _cret *C.GFileInfo         // in

	_arg0 = (*C.GZlibDecompressor)(unsafe.Pointer(d.Native()))

	_cret = C.g_zlib_decompressor_get_file_info(_arg0)

	var _fileInfo FileInfo // out

	_fileInfo = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FileInfo)

	return _fileInfo
}

// DBusAnnotationInfo: information about an annotation.
type DBusAnnotationInfo struct {
	native C.GDBusAnnotationInfo
}

// WrapDBusAnnotationInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusAnnotationInfo(ptr unsafe.Pointer) *DBusAnnotationInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusAnnotationInfo)(ptr)
}

func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusAnnotationInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusAnnotationInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusAnnotationInfo) Ref() *DBusAnnotationInfo {
	var _arg0 *C.GDBusAnnotationInfo // out
	var _cret *C.GDBusAnnotationInfo // in

	_arg0 = (*C.GDBusAnnotationInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_annotation_info_ref(_arg0)

	var _dBusAnnotationInfo *DBusAnnotationInfo // out

	_dBusAnnotationInfo = WrapDBusAnnotationInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_dBusAnnotationInfo, func(v *DBusAnnotationInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _dBusAnnotationInfo
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusAnnotationInfo) Unref() {
	var _arg0 *C.GDBusAnnotationInfo // out

	_arg0 = (*C.GDBusAnnotationInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_annotation_info_unref(_arg0)
}

// DBusArgInfo: information about an argument for a method or a signal.
type DBusArgInfo struct {
	native C.GDBusArgInfo
}

// WrapDBusArgInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusArgInfo(ptr unsafe.Pointer) *DBusArgInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusArgInfo)(ptr)
}

func marshalDBusArgInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusArgInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusArgInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusArgInfo) Ref() *DBusArgInfo {
	var _arg0 *C.GDBusArgInfo // out
	var _cret *C.GDBusArgInfo // in

	_arg0 = (*C.GDBusArgInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_arg_info_ref(_arg0)

	var _dBusArgInfo *DBusArgInfo // out

	_dBusArgInfo = WrapDBusArgInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_dBusArgInfo, func(v *DBusArgInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _dBusArgInfo
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusArgInfo) Unref() {
	var _arg0 *C.GDBusArgInfo // out

	_arg0 = (*C.GDBusArgInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_arg_info_unref(_arg0)
}

// DBusErrorEntry: struct used in g_dbus_error_register_error_domain().
type DBusErrorEntry struct {
	native C.GDBusErrorEntry
}

// WrapDBusErrorEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusErrorEntry(ptr unsafe.Pointer) *DBusErrorEntry {
	if ptr == nil {
		return nil
	}

	return (*DBusErrorEntry)(ptr)
}

// Native returns the underlying C source pointer.
func (d *DBusErrorEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// DBusInterfaceInfo: information about a D-Bus interface.
type DBusInterfaceInfo struct {
	native C.GDBusInterfaceInfo
}

// WrapDBusInterfaceInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusInterfaceInfo(ptr unsafe.Pointer) *DBusInterfaceInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusInterfaceInfo)(ptr)
}

func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusInterfaceInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusInterfaceInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// CacheBuild builds a lookup-cache to speed up
// g_dbus_interface_info_lookup_method(), g_dbus_interface_info_lookup_signal()
// and g_dbus_interface_info_lookup_property().
//
// If this has already been called with @info, the existing cache is used and
// its use count is increased.
//
// Note that @info cannot be modified until
// g_dbus_interface_info_cache_release() is called.
func (i *DBusInterfaceInfo) CacheBuild() {
	var _arg0 *C.GDBusInterfaceInfo // out

	_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_interface_info_cache_build(_arg0)
}

// CacheRelease decrements the usage count for the cache for @info built by
// g_dbus_interface_info_cache_build() (if any) and frees the resources used by
// the cache if the usage count drops to zero.
func (i *DBusInterfaceInfo) CacheRelease() {
	var _arg0 *C.GDBusInterfaceInfo // out

	_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_interface_info_cache_release(_arg0)
}

// LookupMethod looks up information about a method.
//
// The cost of this function is O(n) in number of methods unless
// g_dbus_interface_info_cache_build() has been used on @info.
func (i *DBusInterfaceInfo) LookupMethod(name string) *DBusMethodInfo {
	var _arg0 *C.GDBusInterfaceInfo // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusMethodInfo    // in

	_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_interface_info_lookup_method(_arg0, _arg1)

	var _dBusMethodInfo *DBusMethodInfo // out

	_dBusMethodInfo = WrapDBusMethodInfo(unsafe.Pointer(_cret))

	return _dBusMethodInfo
}

// LookupProperty looks up information about a property.
//
// The cost of this function is O(n) in number of properties unless
// g_dbus_interface_info_cache_build() has been used on @info.
func (i *DBusInterfaceInfo) LookupProperty(name string) *DBusPropertyInfo {
	var _arg0 *C.GDBusInterfaceInfo // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusPropertyInfo  // in

	_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_interface_info_lookup_property(_arg0, _arg1)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	_dBusPropertyInfo = WrapDBusPropertyInfo(unsafe.Pointer(_cret))

	return _dBusPropertyInfo
}

// LookupSignal looks up information about a signal.
//
// The cost of this function is O(n) in number of signals unless
// g_dbus_interface_info_cache_build() has been used on @info.
func (i *DBusInterfaceInfo) LookupSignal(name string) *DBusSignalInfo {
	var _arg0 *C.GDBusInterfaceInfo // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusSignalInfo    // in

	_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_interface_info_lookup_signal(_arg0, _arg1)

	var _dBusSignalInfo *DBusSignalInfo // out

	_dBusSignalInfo = WrapDBusSignalInfo(unsafe.Pointer(_cret))

	return _dBusSignalInfo
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusInterfaceInfo) Ref() *DBusInterfaceInfo {
	var _arg0 *C.GDBusInterfaceInfo // out
	var _cret *C.GDBusInterfaceInfo // in

	_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_interface_info_ref(_arg0)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	_dBusInterfaceInfo = WrapDBusInterfaceInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_dBusInterfaceInfo, func(v *DBusInterfaceInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _dBusInterfaceInfo
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusInterfaceInfo) Unref() {
	var _arg0 *C.GDBusInterfaceInfo // out

	_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_interface_info_unref(_arg0)
}

// DBusInterfaceVTable: virtual table for handling properties and method calls
// for a D-Bus interface.
//
// Since 2.38, if you want to handle getting/setting D-Bus properties
// asynchronously, give nil as your get_property() or set_property() function.
// The D-Bus call will be directed to your @method_call function, with the
// provided @interface_name set to "org.freedesktop.DBus.Properties".
//
// Ownership of the BusMethodInvocation object passed to the method_call()
// function is transferred to your handler; you must call one of the methods of
// BusMethodInvocation to return a reply (possibly empty), or an error. These
// functions also take ownership of the passed-in invocation object, so unless
// the invocation object has otherwise been referenced, it will be then be
// freed. Calling one of these functions may be done within your method_call()
// implementation but it also can be done at a later point to handle the method
// asynchronously.
//
// The usual checks on the validity of the calls is performed. For `Get` calls,
// an error is automatically returned if the property does not exist or the
// permissions do not allow access. The same checks are performed for `Set`
// calls, and the provided value is also checked for being the correct type.
//
// For both `Get` and `Set` calls, the BusMethodInvocation passed to the
// @method_call handler can be queried with
// g_dbus_method_invocation_get_property_info() to get a pointer to the
// BusPropertyInfo of the property.
//
// If you have readable properties specified in your interface info, you must
// ensure that you either provide a non-nil @get_property() function or provide
// implementations of both the `Get` and `GetAll` methods on
// org.freedesktop.DBus.Properties interface in your @method_call function. Note
// that the required return type of the `Get` call is `(v)`, not the type of the
// property. `GetAll` expects a return value of type `a{sv}`.
//
// If you have writable properties specified in your interface info, you must
// ensure that you either provide a non-nil @set_property() function or provide
// an implementation of the `Set` call. If implementing the call, you must
// return the value of type G_VARIANT_TYPE_UNIT.
type DBusInterfaceVTable struct {
	native C.GDBusInterfaceVTable
}

// WrapDBusInterfaceVTable wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusInterfaceVTable(ptr unsafe.Pointer) *DBusInterfaceVTable {
	if ptr == nil {
		return nil
	}

	return (*DBusInterfaceVTable)(ptr)
}

// Native returns the underlying C source pointer.
func (d *DBusInterfaceVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// DBusMethodInfo: information about a method on an D-Bus interface.
type DBusMethodInfo struct {
	native C.GDBusMethodInfo
}

// WrapDBusMethodInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusMethodInfo(ptr unsafe.Pointer) *DBusMethodInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusMethodInfo)(ptr)
}

func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusMethodInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusMethodInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusMethodInfo) Ref() *DBusMethodInfo {
	var _arg0 *C.GDBusMethodInfo // out
	var _cret *C.GDBusMethodInfo // in

	_arg0 = (*C.GDBusMethodInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_info_ref(_arg0)

	var _dBusMethodInfo *DBusMethodInfo // out

	_dBusMethodInfo = WrapDBusMethodInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_dBusMethodInfo, func(v *DBusMethodInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _dBusMethodInfo
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusMethodInfo) Unref() {
	var _arg0 *C.GDBusMethodInfo // out

	_arg0 = (*C.GDBusMethodInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_method_info_unref(_arg0)
}

// DBusNodeInfo: information about nodes in a remote object hierarchy.
type DBusNodeInfo struct {
	native C.GDBusNodeInfo
}

// WrapDBusNodeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusNodeInfo(ptr unsafe.Pointer) *DBusNodeInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusNodeInfo)(ptr)
}

func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusNodeInfo(unsafe.Pointer(b)), nil
}

// NewDBusNodeInfoForXML constructs a struct DBusNodeInfo.
func NewDBusNodeInfoForXML(xmlData string) (*DBusNodeInfo, error) {
	var _arg1 *C.gchar         // out
	var _cret *C.GDBusNodeInfo // in
	var _cerr *C.GError        // in

	_arg1 = (*C.gchar)(C.CString(xmlData))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_node_info_new_for_xml(_arg1, &_cerr)

	var _dBusNodeInfo *DBusNodeInfo // out
	var _goerr error                // out

	_dBusNodeInfo = WrapDBusNodeInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_dBusNodeInfo, func(v *DBusNodeInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusNodeInfo, _goerr
}

// Native returns the underlying C source pointer.
func (d *DBusNodeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// LookupInterface looks up information about an interface.
//
// The cost of this function is O(n) in number of interfaces.
func (i *DBusNodeInfo) LookupInterface(name string) *DBusInterfaceInfo {
	var _arg0 *C.GDBusNodeInfo      // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusInterfaceInfo // in

	_arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_node_info_lookup_interface(_arg0, _arg1)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	_dBusInterfaceInfo = WrapDBusInterfaceInfo(unsafe.Pointer(_cret))

	return _dBusInterfaceInfo
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusNodeInfo) Ref() *DBusNodeInfo {
	var _arg0 *C.GDBusNodeInfo // out
	var _cret *C.GDBusNodeInfo // in

	_arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_node_info_ref(_arg0)

	var _dBusNodeInfo *DBusNodeInfo // out

	_dBusNodeInfo = WrapDBusNodeInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_dBusNodeInfo, func(v *DBusNodeInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _dBusNodeInfo
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusNodeInfo) Unref() {
	var _arg0 *C.GDBusNodeInfo // out

	_arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_node_info_unref(_arg0)
}

// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
type DBusPropertyInfo struct {
	native C.GDBusPropertyInfo
}

// WrapDBusPropertyInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusPropertyInfo(ptr unsafe.Pointer) *DBusPropertyInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusPropertyInfo)(ptr)
}

func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusPropertyInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusPropertyInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusPropertyInfo) Ref() *DBusPropertyInfo {
	var _arg0 *C.GDBusPropertyInfo // out
	var _cret *C.GDBusPropertyInfo // in

	_arg0 = (*C.GDBusPropertyInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_property_info_ref(_arg0)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	_dBusPropertyInfo = WrapDBusPropertyInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_dBusPropertyInfo, func(v *DBusPropertyInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _dBusPropertyInfo
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusPropertyInfo) Unref() {
	var _arg0 *C.GDBusPropertyInfo // out

	_arg0 = (*C.GDBusPropertyInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_property_info_unref(_arg0)
}

// DBusSignalInfo: information about a signal on a D-Bus interface.
type DBusSignalInfo struct {
	native C.GDBusSignalInfo
}

// WrapDBusSignalInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusSignalInfo(ptr unsafe.Pointer) *DBusSignalInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusSignalInfo)(ptr)
}

func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusSignalInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusSignalInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusSignalInfo) Ref() *DBusSignalInfo {
	var _arg0 *C.GDBusSignalInfo // out
	var _cret *C.GDBusSignalInfo // in

	_arg0 = (*C.GDBusSignalInfo)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_signal_info_ref(_arg0)

	var _dBusSignalInfo *DBusSignalInfo // out

	_dBusSignalInfo = WrapDBusSignalInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_dBusSignalInfo, func(v *DBusSignalInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _dBusSignalInfo
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusSignalInfo) Unref() {
	var _arg0 *C.GDBusSignalInfo // out

	_arg0 = (*C.GDBusSignalInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_signal_info_unref(_arg0)
}

// DBusSubtreeVTable: virtual table for handling subtrees registered with
// g_dbus_connection_register_subtree().
type DBusSubtreeVTable struct {
	native C.GDBusSubtreeVTable
}

// WrapDBusSubtreeVTable wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusSubtreeVTable(ptr unsafe.Pointer) *DBusSubtreeVTable {
	if ptr == nil {
		return nil
	}

	return (*DBusSubtreeVTable)(ptr)
}

// Native returns the underlying C source pointer.
func (d *DBusSubtreeVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// FileAttributeInfo: information about a specific attribute.
type FileAttributeInfo struct {
	native C.GFileAttributeInfo
}

// WrapFileAttributeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileAttributeInfo(ptr unsafe.Pointer) *FileAttributeInfo {
	if ptr == nil {
		return nil
	}

	return (*FileAttributeInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (f *FileAttributeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// FileAttributeInfoList acts as a lightweight registry for possible valid file
// attributes. The registry stores Key-Value pair formats as AttributeInfos.
type FileAttributeInfoList struct {
	native C.GFileAttributeInfoList
}

// WrapFileAttributeInfoList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileAttributeInfoList(ptr unsafe.Pointer) *FileAttributeInfoList {
	if ptr == nil {
		return nil
	}

	return (*FileAttributeInfoList)(ptr)
}

func marshalFileAttributeInfoList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileAttributeInfoList(unsafe.Pointer(b)), nil
}

// NewFileAttributeInfoList constructs a struct FileAttributeInfoList.
func NewFileAttributeInfoList() *FileAttributeInfoList {
	var _cret *C.GFileAttributeInfoList // in

	_cret = C.g_file_attribute_info_list_new()

	var _fileAttributeInfoList *FileAttributeInfoList // out

	_fileAttributeInfoList = WrapFileAttributeInfoList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fileAttributeInfoList
}

// Native returns the underlying C source pointer.
func (f *FileAttributeInfoList) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// Add adds a new attribute with @name to the @list, setting its @type and
// @flags.
func (l *FileAttributeInfoList) Add(name string, typ FileAttributeType, flags FileAttributeInfoFlags) {
	var _arg0 *C.GFileAttributeInfoList // out
	var _arg1 *C.char                   // out
	var _arg2 C.GFileAttributeType      // out
	var _arg3 C.GFileAttributeInfoFlags // out

	_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GFileAttributeType)(typ)
	_arg3 = (C.GFileAttributeInfoFlags)(flags)

	C.g_file_attribute_info_list_add(_arg0, _arg1, _arg2, _arg3)
}

// Dup makes a duplicate of a file attribute info list.
func (l *FileAttributeInfoList) Dup() *FileAttributeInfoList {
	var _arg0 *C.GFileAttributeInfoList // out
	var _cret *C.GFileAttributeInfoList // in

	_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))

	_cret = C.g_file_attribute_info_list_dup(_arg0)

	var _fileAttributeInfoList *FileAttributeInfoList // out

	_fileAttributeInfoList = WrapFileAttributeInfoList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fileAttributeInfoList
}

// Lookup gets the file attribute with the name @name from @list.
func (l *FileAttributeInfoList) Lookup(name string) *FileAttributeInfo {
	var _arg0 *C.GFileAttributeInfoList // out
	var _arg1 *C.char                   // out
	var _cret *C.GFileAttributeInfo     // in

	_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_info_list_lookup(_arg0, _arg1)

	var _fileAttributeInfo *FileAttributeInfo // out

	_fileAttributeInfo = WrapFileAttributeInfo(unsafe.Pointer(_cret))

	return _fileAttributeInfo
}

// Ref references a file attribute info list.
func (l *FileAttributeInfoList) Ref() *FileAttributeInfoList {
	var _arg0 *C.GFileAttributeInfoList // out
	var _cret *C.GFileAttributeInfoList // in

	_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))

	_cret = C.g_file_attribute_info_list_ref(_arg0)

	var _fileAttributeInfoList *FileAttributeInfoList // out

	_fileAttributeInfoList = WrapFileAttributeInfoList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fileAttributeInfoList
}

// Unref removes a reference from the given @list. If the reference count falls
// to zero, the @list is deleted.
func (l *FileAttributeInfoList) Unref() {
	var _arg0 *C.GFileAttributeInfoList // out

	_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))

	C.g_file_attribute_info_list_unref(_arg0)
}

// FileAttributeMatcher determines if a string matches a file attribute.
type FileAttributeMatcher struct {
	native C.GFileAttributeMatcher
}

// WrapFileAttributeMatcher wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileAttributeMatcher(ptr unsafe.Pointer) *FileAttributeMatcher {
	if ptr == nil {
		return nil
	}

	return (*FileAttributeMatcher)(ptr)
}

func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileAttributeMatcher(unsafe.Pointer(b)), nil
}

// NewFileAttributeMatcher constructs a struct FileAttributeMatcher.
func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher {
	var _arg1 *C.char                  // out
	var _cret *C.GFileAttributeMatcher // in

	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_new(_arg1)

	var _fileAttributeMatcher *FileAttributeMatcher // out

	_fileAttributeMatcher = WrapFileAttributeMatcher(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fileAttributeMatcher, func(v *FileAttributeMatcher) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fileAttributeMatcher
}

// Native returns the underlying C source pointer.
func (f *FileAttributeMatcher) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// EnumerateNamespace checks if the matcher will match all of the keys in a
// given namespace. This will always return true if a wildcard character is in
// use (e.g. if matcher was created with "standard::*" and @ns is "standard", or
// if matcher was created using "*" and namespace is anything.)
//
// TODO: this is awkwardly worded.
func (m *FileAttributeMatcher) EnumerateNamespace(ns string) bool {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.char                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(ns))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_enumerate_namespace(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EnumerateNext gets the next matched attribute from a AttributeMatcher.
func (m *FileAttributeMatcher) EnumerateNext() string {
	var _arg0 *C.GFileAttributeMatcher // out
	var _cret *C.char                  // in

	_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))

	_cret = C.g_file_attribute_matcher_enumerate_next(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Matches checks if an attribute will be matched by an attribute matcher. If
// the matcher was created with the "*" matching string, this function will
// always return true.
func (m *FileAttributeMatcher) Matches(attribute string) bool {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.char                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_matches(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchesOnly checks if a attribute matcher only matches a given attribute.
// Always returns false if "*" was used when creating the matcher.
func (m *FileAttributeMatcher) MatchesOnly(attribute string) bool {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.char                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_matches_only(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref references a file attribute matcher.
func (m *FileAttributeMatcher) Ref() *FileAttributeMatcher {
	var _arg0 *C.GFileAttributeMatcher // out
	var _cret *C.GFileAttributeMatcher // in

	_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))

	_cret = C.g_file_attribute_matcher_ref(_arg0)

	var _fileAttributeMatcher *FileAttributeMatcher // out

	_fileAttributeMatcher = WrapFileAttributeMatcher(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fileAttributeMatcher, func(v *FileAttributeMatcher) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fileAttributeMatcher
}

// Subtract subtracts all attributes of @subtract from @matcher and returns a
// matcher that supports those attributes.
//
// Note that currently it is not possible to remove a single attribute when the
// @matcher matches the whole namespace - or remove a namespace or attribute
// when the matcher matches everything. This is a limitation of the current
// implementation, but may be fixed in the future.
func (m *FileAttributeMatcher) Subtract(subtract *FileAttributeMatcher) *FileAttributeMatcher {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.GFileAttributeMatcher // out
	var _cret *C.GFileAttributeMatcher // in

	_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GFileAttributeMatcher)(unsafe.Pointer(subtract.Native()))

	_cret = C.g_file_attribute_matcher_subtract(_arg0, _arg1)

	var _fileAttributeMatcher *FileAttributeMatcher // out

	_fileAttributeMatcher = WrapFileAttributeMatcher(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fileAttributeMatcher, func(v *FileAttributeMatcher) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fileAttributeMatcher
}

// String prints what the matcher is matching against. The format will be equal
// to the format passed to g_file_attribute_matcher_new(). The output however,
// might not be identical, as the matcher may decide to use a different order or
// omit needless parts.
func (m *FileAttributeMatcher) String() string {
	var _arg0 *C.GFileAttributeMatcher // out
	var _cret *C.char                  // in

	_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))

	_cret = C.g_file_attribute_matcher_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Unref unreferences @matcher. If the reference count falls below 1, the
// @matcher is automatically freed.
func (m *FileAttributeMatcher) Unref() {
	var _arg0 *C.GFileAttributeMatcher // out

	_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))

	C.g_file_attribute_matcher_unref(_arg0)
}

// IOExtension is an opaque data structure and can only be accessed using the
// following functions.
type IOExtension struct {
	native C.GIOExtension
}

// WrapIOExtension wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIOExtension(ptr unsafe.Pointer) *IOExtension {
	if ptr == nil {
		return nil
	}

	return (*IOExtension)(ptr)
}

// Native returns the underlying C source pointer.
func (i *IOExtension) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Name gets the name under which @extension was registered.
//
// Note that the same type may be registered as extension for multiple extension
// points, under different names.
func (e *IOExtension) Name() string {
	var _arg0 *C.GIOExtension // out
	var _cret *C.char         // in

	_arg0 = (*C.GIOExtension)(unsafe.Pointer(e.Native()))

	_cret = C.g_io_extension_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Priority gets the priority with which @extension was registered.
func (e *IOExtension) Priority() int {
	var _arg0 *C.GIOExtension // out
	var _cret C.gint          // in

	_arg0 = (*C.GIOExtension)(unsafe.Pointer(e.Native()))

	_cret = C.g_io_extension_get_priority(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Type gets the type associated with @extension.
func (e *IOExtension) Type() externglib.Type {
	var _arg0 *C.GIOExtension // out
	var _cret C.GType         // in

	_arg0 = (*C.GIOExtension)(unsafe.Pointer(e.Native()))

	_cret = C.g_io_extension_get_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// IOExtensionPoint is an opaque data structure and can only be accessed using
// the following functions.
type IOExtensionPoint struct {
	native C.GIOExtensionPoint
}

// WrapIOExtensionPoint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIOExtensionPoint(ptr unsafe.Pointer) *IOExtensionPoint {
	if ptr == nil {
		return nil
	}

	return (*IOExtensionPoint)(ptr)
}

// Native returns the underlying C source pointer.
func (i *IOExtensionPoint) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// ExtensionByName finds a OExtension for an extension point by name.
func (e *IOExtensionPoint) ExtensionByName(name string) *IOExtension {
	var _arg0 *C.GIOExtensionPoint // out
	var _arg1 *C.char              // out
	var _cret *C.GIOExtension      // in

	_arg0 = (*C.GIOExtensionPoint)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_io_extension_point_get_extension_by_name(_arg0, _arg1)

	var _ioExtension *IOExtension // out

	_ioExtension = WrapIOExtension(unsafe.Pointer(_cret))

	return _ioExtension
}

// RequiredType gets the required type for @extension_point.
func (e *IOExtensionPoint) RequiredType() externglib.Type {
	var _arg0 *C.GIOExtensionPoint // out
	var _cret C.GType              // in

	_arg0 = (*C.GIOExtensionPoint)(unsafe.Pointer(e.Native()))

	_cret = C.g_io_extension_point_get_required_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// SetRequiredType sets the required type for @extension_point to @type. All
// implementations must henceforth have this type.
func (e *IOExtensionPoint) SetRequiredType(typ externglib.Type) {
	var _arg0 *C.GIOExtensionPoint // out
	var _arg1 C.GType              // out

	_arg0 = (*C.GIOExtensionPoint)(unsafe.Pointer(e.Native()))
	_arg1 = C.GType(typ)

	C.g_io_extension_point_set_required_type(_arg0, _arg1)
}

// IOModuleScope represents a scope for loading IO modules. A scope can be used
// for blocking duplicate modules, or blocking a module you don't want to load.
//
// The scope can be used with g_io_modules_load_all_in_directory_with_scope() or
// g_io_modules_scan_all_in_directory_with_scope().
type IOModuleScope struct {
	native C.GIOModuleScope
}

// WrapIOModuleScope wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIOModuleScope(ptr unsafe.Pointer) *IOModuleScope {
	if ptr == nil {
		return nil
	}

	return (*IOModuleScope)(ptr)
}

// Native returns the underlying C source pointer.
func (i *IOModuleScope) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Block: block modules with the given @basename from being loaded when this
// scope is used with g_io_modules_scan_all_in_directory_with_scope() or
// g_io_modules_load_all_in_directory_with_scope().
func (s *IOModuleScope) Block(basename string) {
	var _arg0 *C.GIOModuleScope // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GIOModuleScope)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(basename))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_io_module_scope_block(_arg0, _arg1)
}

// Free: free a module scope.
func (s *IOModuleScope) Free() {
	var _arg0 *C.GIOModuleScope // out

	_arg0 = (*C.GIOModuleScope)(unsafe.Pointer(s.Native()))

	C.g_io_module_scope_free(_arg0)
}

// IOSchedulerJob: opaque class for defining and scheduling IO jobs.
type IOSchedulerJob struct {
	native C.GIOSchedulerJob
}

// WrapIOSchedulerJob wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIOSchedulerJob(ptr unsafe.Pointer) *IOSchedulerJob {
	if ptr == nil {
		return nil
	}

	return (*IOSchedulerJob)(ptr)
}

// Native returns the underlying C source pointer.
func (i *IOSchedulerJob) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type IOStreamAdapter struct {
	native C.GIOStreamAdapter
}

// WrapIOStreamAdapter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIOStreamAdapter(ptr unsafe.Pointer) *IOStreamAdapter {
	if ptr == nil {
		return nil
	}

	return (*IOStreamAdapter)(ptr)
}

// Native returns the underlying C source pointer.
func (i *IOStreamAdapter) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// InputMessage: structure used for scatter/gather data input when receiving
// multiple messages or packets in one go. You generally pass in an array of
// empty Vectors and the operation will use all the buffers as if they were one
// buffer, and will set @bytes_received to the total number of bytes received
// across all Vectors.
//
// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from the
// POSIX sockets API (see `man 2 recvmmsg`).
//
// If @address is non-nil then it is set to the source address the message was
// received from, and the caller must free it afterwards.
//
// If @control_messages is non-nil then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. @num_control_messages is set to the number of elements in this
// array, which may be zero.
//
// Flags relevant to this message will be returned in @flags. For example,
// `MSG_EOR` or `MSG_TRUNC`.
type InputMessage struct {
	native C.GInputMessage
}

// WrapInputMessage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInputMessage(ptr unsafe.Pointer) *InputMessage {
	if ptr == nil {
		return nil
	}

	return (*InputMessage)(ptr)
}

// Native returns the underlying C source pointer.
func (i *InputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// InputVector: structure used for scatter/gather data input. You generally pass
// in an array of Vectors and the operation will store the read data starting in
// the first buffer, switching to the next as needed.
type InputVector struct {
	native C.GInputVector
}

// WrapInputVector wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInputVector(ptr unsafe.Pointer) *InputVector {
	if ptr == nil {
		return nil
	}

	return (*InputVector)(ptr)
}

// Native returns the underlying C source pointer.
func (i *InputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// OutputMessage: structure used for scatter/gather data output when sending
// multiple messages or packets in one go. You generally pass in an array of
// Vectors and the operation will use all the buffers as if they were one
// buffer.
//
// If @address is nil then the message is sent to the default receiver (as
// previously set by g_socket_connect()).
type OutputMessage struct {
	native C.GOutputMessage
}

// WrapOutputMessage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOutputMessage(ptr unsafe.Pointer) *OutputMessage {
	if ptr == nil {
		return nil
	}

	return (*OutputMessage)(ptr)
}

// Native returns the underlying C source pointer.
func (o *OutputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// OutputVector: structure used for scatter/gather data output. You generally
// pass in an array of Vectors and the operation will use all the buffers as if
// they were one buffer.
type OutputVector struct {
	native C.GOutputVector
}

// WrapOutputVector wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOutputVector(ptr unsafe.Pointer) *OutputVector {
	if ptr == nil {
		return nil
	}

	return (*OutputVector)(ptr)
}

// Native returns the underlying C source pointer.
func (o *OutputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// Resource applications and libraries often contain binary or textual data that
// is really part of the application, rather than user data. For instance
// Builder .ui files, splashscreen images, GMenu markup XML, CSS files, icons,
// etc. These are often shipped as files in `$datadir/appname`, or manually
// included as literal strings in the code.
//
// The #GResource API and the [glib-compile-resources][glib-compile-resources]
// program provide a convenient and efficient alternative to this which has some
// nice properties. You maintain the files as normal files, so its easy to edit
// them, but during the build the files are combined into a binary bundle that
// is linked into the executable. This means that loading the resource files are
// efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in
// the filesystem). It also makes it easier to create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included
// in the resource bundle in a compressed form, but will be automatically
// uncompressed when the resource is used. This is very useful e.g. for larger
// text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of
// the `preprocess` attribute to a comma-separated list of preprocessing
// options. The only options currently supported are:
//
// `xml-stripblanks` which will use the xmllint command to strip ignorable
// whitespace from the XML file. For this to work, the `XMLLINT` environment
// variable must be set to the full path to the xmllint executable, or xmllint
// must be in the `PATH`; otherwise the preprocessing step is skipped.
//
// `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
// `gdk-pixbuf-pixdata` command to convert images to the Pixdata format, which
// allows you to create pixbufs directly using the data inside the resource
// file, rather than an (uncompressed) copy of it. For this, the
// `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
// `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
// `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will abort.
// `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as #GResource
// supports embedding modern image formats just as well. Instead of using it,
// embed a PNG or SVG file in your #GResource.
//
// `json-stripblanks` which will use the `json-glib-format` command to strip
// ignorable whitespace from the JSON file. For this to work, the
// `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
// `json-glib-format` executable, or it must be in the `PATH`; otherwise the
// preprocessing step is skipped. In addition, at least version 1.6 of
// `json-glib-format` is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given `prefix` and the filename from the `file` element.
// The `alias` attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the
// [glib-compile-resources][glib-compile-resources] program which takes an XML
// file that describes the bundle, and a set of files that the XML references.
// These are combined into a binary resource bundle.
//
// An example resource description:
//
//    <?xml version="1.0" encoding="UTF-8"?>
//    <gresources>
//      <gresource prefix="/org/gtk/Example">
//        <file>data/splashscreen.png</file>
//        <file compressed="true">dialog.ui</file>
//        <file preprocess="xml-stripblanks">menumarkup.xml</file>
//        <file alias="example.css">data/example.css</file>
//      </gresource>
//    </gresources>
//
// This will create a resource bundle with the following files:
//
//    /org/gtk/Example/data/splashscreen.png
//    /org/gtk/Example/dialog.ui
//    /org/gtk/Example/menumarkup.xml
//    /org/gtk/Example/example.css
//
// Note that all resources in the process share the same namespace, so use
// Java-style path prefixes (like in the above example) to avoid conflicts.
//
// You can then use [glib-compile-resources][glib-compile-resources] to compile
// the XML to a binary bundle that you can load with g_resource_load(). However,
// its more common to use the --generate-source and --generate-header arguments
// to create a source file and header to link directly into your application.
// This will generate `get_resource()`, `register_resource()` and
// `unregister_resource()` functions, prefixed by the `--c-name` argument passed
// to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
// the generated #GResource object. The register and unregister functions
// register the resource so its files can be accessed using
// g_resources_lookup_data().
//
// Once a #GResource has been created and registered all the data in it can be
// accessed globally in the process by using API calls like
// g_resources_open_stream() to stream the data or g_resources_lookup_data() to
// get a direct pointer to the data. You can also use URIs like
// "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access the
// resource data.
//
// Some higher-level APIs, such as Application, will automatically load
// resources from certain well-known paths in the resource namespace as a
// convenience. See the documentation for those APIs for details.
//
// There are two forms of the generated source, the default version uses the
// compiler support for constructor and destructor functions (where available)
// to automatically create and register the #GResource on startup or library
// load time. If you pass `--manual-register`, two functions to
// register/unregister the resource are created instead. This requires an
// explicit initialization call in your application/library, but it works on all
// platforms, even on the minor ones where constructors are not supported.
// (Constructor support is available for at least Win32, Mac OS and Linux.)
//
// Note that resource data can point directly into the data segment of e.g. a
// library, so if you are unloading libraries during runtime you need to be very
// careful with keeping around pointers to data from a resource, as this goes
// away when the library is unloaded. However, in practice this is not generally
// a problem, since most resource accesses are for your own resources, and
// resource data is often used once, during parsing, and then released.
//
// When debugging a program or testing a change to an installed version, it is
// often useful to be able to replace resources in the program or library,
// without recompiling, for debugging or quick hacking and testing purposes.
// Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment
// variable to selectively overlay resources with replacements from the
// filesystem. It is a G_SEARCHPATH_SEPARATOR-separated list of substitutions to
// perform during resource lookups. It is ignored when running in a setuid
// process.
//
// A substitution has the form
//
//    /org/gtk/libgtk=/home/desrt/gtk-overlay
//
// The part before the `=` is the resource subpath for which the overlay
// applies. The part after is a filesystem path which contains files and
// subdirectories as you would like to be loaded as resources with the
// equivalent names.
//
// In the example above, if an application tried to load a resource with the
// resource path `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check
// the filesystem path `/home/desrt/gtk-overlay/ui/gtkdialog.ui`. If a file was
// found there, it would be used instead. This is an overlay, not an outright
// replacement, which means that if a file is not found at that path, the
// built-in version will be used instead. Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash
// before the '='. The path after the slash should ideally be absolute, but this
// is not strictly required. It is possible to overlay the location of a single
// resource with an individual file.
type Resource struct {
	native C.GResource
}

// WrapResource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapResource(ptr unsafe.Pointer) *Resource {
	if ptr == nil {
		return nil
	}

	return (*Resource)(ptr)
}

func marshalResource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapResource(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Resource) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// EnumerateChildren returns all the names of children at the specified @path in
// the resource. The return result is a nil terminated list of strings which
// should be released with g_strfreev().
//
// If @path is invalid or does not exist in the #GResource,
// G_RESOURCE_ERROR_NOT_FOUND will be returned.
//
// @lookup_flags controls the behaviour of the lookup.
func (r *Resource) EnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret **C.char
	var _cerr *C.GError // in

	_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GResourceLookupFlags)(lookupFlags)

	_cret = C.g_resource_enumerate_children(_arg0, _arg1, _arg2, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

// Info looks for a file at the specified @path in the resource and if found
// returns information about it.
//
// @lookup_flags controls the behaviour of the lookup.
func (r *Resource) Info(path string, lookupFlags ResourceLookupFlags) (uint, uint32, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _arg3 C.gsize                // in
	var _arg4 C.guint32              // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GResourceLookupFlags)(lookupFlags)

	C.g_resource_get_info(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _size uint    // out
	var _flags uint32 // out
	var _goerr error  // out

	_size = (uint)(_arg3)
	_flags = (uint32)(_arg4)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _size, _flags, _goerr
}

// OpenStream looks for a file at the specified @path in the resource and
// returns a Stream that lets you read the data.
//
// @lookup_flags controls the behaviour of the lookup.
func (r *Resource) OpenStream(path string, lookupFlags ResourceLookupFlags) (InputStream, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret *C.GInputStream        // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GResourceLookupFlags)(lookupFlags)

	_cret = C.g_resource_open_stream(_arg0, _arg1, _arg2, &_cerr)

	var _inputStream InputStream // out
	var _goerr error             // out

	_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _inputStream, _goerr
}

// Ref: atomically increments the reference count of @resource by one. This
// function is MT-safe and may be called from any thread.
func (r *Resource) Ref() *Resource {
	var _arg0 *C.GResource // out
	var _cret *C.GResource // in

	_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))

	_cret = C.g_resource_ref(_arg0)

	var _ret *Resource // out

	_ret = WrapResource(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *Resource) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Unref: atomically decrements the reference count of @resource by one. If the
// reference count drops to 0, all memory allocated by the resource is released.
// This function is MT-safe and may be called from any thread.
func (r *Resource) Unref() {
	var _arg0 *C.GResource // out

	_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))

	C.g_resource_unref(_arg0)
}

// SettingsSchema: the SchemaSource and Schema APIs provide a mechanism for
// advanced control over the loading of schemas and a mechanism for
// introspecting their content.
//
// Plugin loading systems that wish to provide plugins a way to access settings
// face the problem of how to make the schemas for these settings visible to
// GSettings. Typically, a plugin will want to ship the schema along with itself
// and it won't be installed into the standard system directories for schemas.
//
// SchemaSource provides a mechanism for dealing with this by allowing the
// creation of a new 'schema source' from which schemas can be acquired. This
// schema source can then become part of the metadata associated with the plugin
// and queried whenever the plugin requires access to some settings.
//
// Consider the following example:
//
//    {
//      GSettings *settings;
//      gint some_value;
//
//      settings = plugin_get_settings (self, NULL);
//      some_value = g_settings_get_int (settings, "some-value");
//      ...
//    }
//
// It's also possible that the plugin system expects the schema source files
// (ie: .gschema.xml files) instead of a gschemas.compiled file. In that case,
// the plugin loading system must compile the schemas for itself before
// attempting to create the settings source.
type SettingsSchema struct {
	native C.GSettingsSchema
}

// WrapSettingsSchema wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchema(ptr unsafe.Pointer) *SettingsSchema {
	if ptr == nil {
		return nil
	}

	return (*SettingsSchema)(ptr)
}

func marshalSettingsSchema(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsSchema(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SettingsSchema) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// ID: get the ID of @schema.
func (s *SettingsSchema) ID() string {
	var _arg0 *C.GSettingsSchema // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_get_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Key gets the key named @name from @schema.
//
// It is a programmer error to request a key that does not exist. See
// g_settings_schema_list_keys().
func (s *SettingsSchema) Key(name string) *SettingsSchemaKey {
	var _arg0 *C.GSettingsSchema    // out
	var _arg1 *C.gchar              // out
	var _cret *C.GSettingsSchemaKey // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_schema_get_key(_arg0, _arg1)

	var _settingsSchemaKey *SettingsSchemaKey // out

	_settingsSchemaKey = WrapSettingsSchemaKey(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_settingsSchemaKey, func(v *SettingsSchemaKey) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _settingsSchemaKey
}

// Path gets the path associated with @schema, or nil.
//
// Schemas may be single-instance or relocatable. Single-instance schemas
// correspond to exactly one set of keys in the backend database: those located
// at the path returned by this function.
//
// Relocatable schemas can be referenced by other schemas and can therefore
// describe multiple sets of keys at different locations. For relocatable
// schemas, this function will return nil.
func (s *SettingsSchema) Path() string {
	var _arg0 *C.GSettingsSchema // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// HasKey checks if @schema has a key named @name.
func (s *SettingsSchema) HasKey(name string) bool {
	var _arg0 *C.GSettingsSchema // out
	var _arg1 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_schema_has_key(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListChildren gets the list of children in @schema.
//
// You should free the return value with g_strfreev() when you are done with it.
func (s *SettingsSchema) ListChildren() []string {
	var _arg0 *C.GSettingsSchema // out
	var _cret **C.gchar

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_list_children(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ListKeys introspects the list of keys on @schema.
//
// You should probably not be calling this function from "normal" code (since
// you should already know what keys are in your schema). This function is
// intended for introspection reasons.
func (s *SettingsSchema) ListKeys() []string {
	var _arg0 *C.GSettingsSchema // out
	var _cret **C.gchar

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_list_keys(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Ref: increase the reference count of @schema, returning a new reference.
func (s *SettingsSchema) Ref() *SettingsSchema {
	var _arg0 *C.GSettingsSchema // out
	var _cret *C.GSettingsSchema // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_ref(_arg0)

	var _settingsSchema *SettingsSchema // out

	_settingsSchema = WrapSettingsSchema(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_settingsSchema, func(v *SettingsSchema) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _settingsSchema
}

// Unref: decrease the reference count of @schema, possibly freeing it.
func (s *SettingsSchema) Unref() {
	var _arg0 *C.GSettingsSchema // out

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	C.g_settings_schema_unref(_arg0)
}

// SettingsSchemaKey is an opaque data structure and can only be accessed using
// the following functions.
type SettingsSchemaKey struct {
	native C.GSettingsSchemaKey
}

// WrapSettingsSchemaKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchemaKey(ptr unsafe.Pointer) *SettingsSchemaKey {
	if ptr == nil {
		return nil
	}

	return (*SettingsSchemaKey)(ptr)
}

func marshalSettingsSchemaKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsSchemaKey(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SettingsSchemaKey) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// DefaultValue gets the default value for @key.
//
// Note that this is the default value according to the schema. System
// administrator defaults and lockdown are not visible via this API.
func (k *SettingsSchemaKey) DefaultValue() *glib.Variant {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GVariant           // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_default_value(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Description gets the description for @key.
//
// If no description has been provided in the schema for @key, returns nil.
//
// The description can be one sentence to several paragraphs in length.
// Paragraphs are delimited with a double newline. Descriptions can be
// translated and the value returned from this function is is the current
// locale.
//
// This function is slow. The summary and description information for the
// schemas is not stored in the compiled schema database so this function has to
// parse all of the source XML files in the schema directory.
func (k *SettingsSchemaKey) Description() string {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Name gets the name of @key.
func (k *SettingsSchemaKey) Name() string {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Range queries the range of a key.
//
// This function will return a #GVariant that fully describes the range of
// values that are valid for @key.
//
// The type of #GVariant returned is `(sv)`. The string describes the type of
// range restriction in effect. The type and meaning of the value contained in
// the variant depends on the string.
//
// If the string is `'type'` then the variant contains an empty array. The
// element type of that empty array is the expected type of value and all values
// of that type are valid.
//
// If the string is `'enum'` then the variant contains an array enumerating the
// possible values. Each item in the array is a possible valid value and no
// other values are valid.
//
// If the string is `'flags'` then the variant contains an array. Each item in
// the array is a value that may appear zero or one times in an array to be used
// as the value for this key. For example, if the variant contained the array
// `['x', 'y']` then the valid values for the key would be `[]`, `['x']`,
// `['y']`, `['x', 'y']` and `['y', 'x']`.
//
// Finally, if the string is `'range'` then the variant contains a pair of
// like-typed values -- the minimum and maximum permissible values for this key.
//
// This information should not be used by normal programs. It is considered to
// be a hint for introspection purposes. Normal programs should already know
// what is permitted by their own schema. The format may change in any way in
// the future -- but particularly, new forms may be added to the possibilities
// described above.
//
// You should free the returned value with g_variant_unref() when it is no
// longer needed.
func (k *SettingsSchemaKey) Range() *glib.Variant {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GVariant           // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_range(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Summary gets the summary for @key.
//
// If no summary has been provided in the schema for @key, returns nil.
//
// The summary is a short description of the purpose of the key; usually one
// short sentence. Summaries can be translated and the value returned from this
// function is is the current locale.
//
// This function is slow. The summary and description information for the
// schemas is not stored in the compiled schema database so this function has to
// parse all of the source XML files in the schema directory.
func (k *SettingsSchemaKey) Summary() string {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_summary(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ValueType gets the Type of @key.
func (k *SettingsSchemaKey) ValueType() *glib.VariantType {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GVariantType       // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_value_type(_arg0)

	var _variantType *glib.VariantType // out

	_variantType = glib.WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

// RangeCheck checks if the given @value is of the correct type and within the
// permitted range for @key.
//
// It is a programmer error if @value is not of the correct type -- you must
// check for this first.
func (k *SettingsSchemaKey) RangeCheck(value *glib.Variant) bool {
	var _arg0 *C.GSettingsSchemaKey // out
	var _arg1 *C.GVariant           // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	_cret = C.g_settings_schema_key_range_check(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref: increase the reference count of @key, returning a new reference.
func (k *SettingsSchemaKey) Ref() *SettingsSchemaKey {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GSettingsSchemaKey // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_ref(_arg0)

	var _settingsSchemaKey *SettingsSchemaKey // out

	_settingsSchemaKey = WrapSettingsSchemaKey(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_settingsSchemaKey, func(v *SettingsSchemaKey) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _settingsSchemaKey
}

// Unref: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) Unref() {
	var _arg0 *C.GSettingsSchemaKey // out

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	C.g_settings_schema_key_unref(_arg0)
}

// SettingsSchemaSource: this is an opaque structure type. You may not access it
// directly.
type SettingsSchemaSource struct {
	native C.GSettingsSchemaSource
}

// WrapSettingsSchemaSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchemaSource(ptr unsafe.Pointer) *SettingsSchemaSource {
	if ptr == nil {
		return nil
	}

	return (*SettingsSchemaSource)(ptr)
}

func marshalSettingsSchemaSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsSchemaSource(unsafe.Pointer(b)), nil
}

// NewSettingsSchemaSourceFromDirectory constructs a struct SettingsSchemaSource.
func NewSettingsSchemaSourceFromDirectory(directory string, parent *SettingsSchemaSource, trusted bool) (*SettingsSchemaSource, error) {
	var _arg1 *C.gchar                 // out
	var _arg2 *C.GSettingsSchemaSource // out
	var _arg3 C.gboolean               // out
	var _cret *C.GSettingsSchemaSource // in
	var _cerr *C.GError                // in

	_arg1 = (*C.gchar)(C.CString(directory))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GSettingsSchemaSource)(unsafe.Pointer(parent.Native()))
	if trusted {
		_arg3 = C.TRUE
	}

	_cret = C.g_settings_schema_source_new_from_directory(_arg1, _arg2, _arg3, &_cerr)

	var _settingsSchemaSource *SettingsSchemaSource // out
	var _goerr error                                // out

	_settingsSchemaSource = WrapSettingsSchemaSource(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_settingsSchemaSource, func(v *SettingsSchemaSource) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _settingsSchemaSource, _goerr
}

// Native returns the underlying C source pointer.
func (s *SettingsSchemaSource) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// ListSchemas lists the schemas in a given source.
//
// If @recursive is true then include parent sources. If false then only include
// the schemas from one source (ie: one directory). You probably want true.
//
// Non-relocatable schemas are those for which you can call g_settings_new().
// Relocatable schemas are those for which you must use
// g_settings_new_with_path().
//
// Do not call this function from normal programs. This is designed for use by
// database editors, commandline tools, etc.
func (s *SettingsSchemaSource) ListSchemas(recursive bool) (nonRelocatable []string, relocatable []string) {
	var _arg0 *C.GSettingsSchemaSource // out
	var _arg1 C.gboolean               // out
	var _arg2 **C.gchar
	var _arg3 **C.gchar

	_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))
	if recursive {
		_arg1 = C.TRUE
	}

	C.g_settings_schema_source_list_schemas(_arg0, _arg1, &_arg2, &_arg3)

	var _nonRelocatable []string
	var _relocatable []string

	{
		var i int
		var z *C.gchar
		for p := _arg2; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg2, i)
		_nonRelocatable = make([]string, i)
		for i := range src {
			_nonRelocatable[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	{
		var i int
		var z *C.gchar
		for p := _arg3; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg3, i)
		_relocatable = make([]string, i)
		for i := range src {
			_relocatable[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _nonRelocatable, _relocatable
}

// Lookup looks up a schema with the identifier @schema_id in @source.
//
// This function is not required for normal uses of #GSettings but it may be
// useful to authors of plugin management systems or to those who want to
// introspect the content of schemas.
//
// If the schema isn't found directly in @source and @recursive is true then the
// parent sources will also be checked.
//
// If the schema isn't found, nil is returned.
func (s *SettingsSchemaSource) Lookup(schemaId string, recursive bool) *SettingsSchema {
	var _arg0 *C.GSettingsSchemaSource // out
	var _arg1 *C.gchar                 // out
	var _arg2 C.gboolean               // out
	var _cret *C.GSettingsSchema       // in

	_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(schemaId))
	defer C.free(unsafe.Pointer(_arg1))
	if recursive {
		_arg2 = C.TRUE
	}

	_cret = C.g_settings_schema_source_lookup(_arg0, _arg1, _arg2)

	var _settingsSchema *SettingsSchema // out

	_settingsSchema = WrapSettingsSchema(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_settingsSchema, func(v *SettingsSchema) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _settingsSchema
}

// Ref: increase the reference count of @source, returning a new reference.
func (s *SettingsSchemaSource) Ref() *SettingsSchemaSource {
	var _arg0 *C.GSettingsSchemaSource // out
	var _cret *C.GSettingsSchemaSource // in

	_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_source_ref(_arg0)

	var _settingsSchemaSource *SettingsSchemaSource // out

	_settingsSchemaSource = WrapSettingsSchemaSource(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_settingsSchemaSource, func(v *SettingsSchemaSource) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _settingsSchemaSource
}

// Unref: decrease the reference count of @source, possibly freeing it.
func (s *SettingsSchemaSource) Unref() {
	var _arg0 *C.GSettingsSchemaSource // out

	_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))

	C.g_settings_schema_source_unref(_arg0)
}

// SrvTarget: SRV (service) records are used by some network protocols to
// provide service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain; rather than
// connecting directly to "example.com" or assuming a specific server hostname
// like "xmpp.example.com", an XMPP client would look up the "xmpp-client" SRV
// record for "example.com", and then connect to whatever host was pointed to by
// that record.
//
// You can use g_resolver_lookup_service() or g_resolver_lookup_service_async()
// to find the Targets for a given service. However, if you are simply planning
// to connect to the remote service, you can use Service's Connectable interface
// and not need to worry about Target at all.
type SrvTarget struct {
	native C.GSrvTarget
}

// WrapSrvTarget wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSrvTarget(ptr unsafe.Pointer) *SrvTarget {
	if ptr == nil {
		return nil
	}

	return (*SrvTarget)(ptr)
}

func marshalSrvTarget(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSrvTarget(unsafe.Pointer(b)), nil
}

// NewSrvTarget constructs a struct SrvTarget.
func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget {
	var _arg1 *C.gchar      // out
	var _arg2 C.guint16     // out
	var _arg3 C.guint16     // out
	var _arg4 C.guint16     // out
	var _cret *C.GSrvTarget // in

	_arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint16)(port)
	_arg3 = (C.guint16)(priority)
	_arg4 = (C.guint16)(weight)

	_cret = C.g_srv_target_new(_arg1, _arg2, _arg3, _arg4)

	var _srvTarget *SrvTarget // out

	_srvTarget = WrapSrvTarget(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_srvTarget, func(v *SrvTarget) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _srvTarget
}

// Native returns the underlying C source pointer.
func (s *SrvTarget) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Copy copies @target
func (t *SrvTarget) Copy() *SrvTarget {
	var _arg0 *C.GSrvTarget // out
	var _cret *C.GSrvTarget // in

	_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

	_cret = C.g_srv_target_copy(_arg0)

	var _srvTarget *SrvTarget // out

	_srvTarget = WrapSrvTarget(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_srvTarget, func(v *SrvTarget) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _srvTarget
}

// Free frees @target
func (t *SrvTarget) Free() {
	var _arg0 *C.GSrvTarget // out

	_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

	C.g_srv_target_free(_arg0)
}

// Hostname gets @target's hostname (in ASCII form; if you are going to present
// this to the user, you should use g_hostname_is_ascii_encoded() to check if it
// contains encoded Unicode segments, and use g_hostname_to_unicode() to convert
// it if it does.)
func (t *SrvTarget) Hostname() string {
	var _arg0 *C.GSrvTarget // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

	_cret = C.g_srv_target_get_hostname(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Port gets @target's port
func (t *SrvTarget) Port() uint16 {
	var _arg0 *C.GSrvTarget // out
	var _cret C.guint16     // in

	_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

	_cret = C.g_srv_target_get_port(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// Priority gets @target's priority. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in RFC 2782.
func (t *SrvTarget) Priority() uint16 {
	var _arg0 *C.GSrvTarget // out
	var _cret C.guint16     // in

	_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

	_cret = C.g_srv_target_get_priority(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// Weight gets @target's weight. You should not need to look at this; #GResolver
// already sorts the targets according to the algorithm in RFC 2782.
func (t *SrvTarget) Weight() uint16 {
	var _arg0 *C.GSrvTarget // out
	var _cret C.guint16     // in

	_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

	_cret = C.g_srv_target_get_weight(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// StaticResource is an opaque data structure and can only be accessed using the
// following functions.
type StaticResource struct {
	native C.GStaticResource
}

// WrapStaticResource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStaticResource(ptr unsafe.Pointer) *StaticResource {
	if ptr == nil {
		return nil
	}

	return (*StaticResource)(ptr)
}

// Native returns the underlying C source pointer.
func (s *StaticResource) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Fini: finalized a GResource initialized by g_static_resource_init().
//
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
func (s *StaticResource) Fini() {
	var _arg0 *C.GStaticResource // out

	_arg0 = (*C.GStaticResource)(unsafe.Pointer(s.Native()))

	C.g_static_resource_fini(_arg0)
}

// Resource gets the GResource that was registered by a call to
// g_static_resource_init().
//
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
func (s *StaticResource) Resource() *Resource {
	var _arg0 *C.GStaticResource // out
	var _cret *C.GResource       // in

	_arg0 = (*C.GStaticResource)(unsafe.Pointer(s.Native()))

	_cret = C.g_static_resource_get_resource(_arg0)

	var _resource *Resource // out

	_resource = WrapResource(unsafe.Pointer(_cret))

	return _resource
}

// Init initializes a GResource from static data using a GStaticResource.
//
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
func (s *StaticResource) Init() {
	var _arg0 *C.GStaticResource // out

	_arg0 = (*C.GStaticResource)(unsafe.Pointer(s.Native()))

	C.g_static_resource_init(_arg0)
}

// UnixMountEntry defines a Unix mount entry (e.g.
// <filename>/media/cdrom</filename>). This corresponds roughly to a mtab entry.
type UnixMountEntry struct {
	native C.GUnixMountEntry
}

// WrapUnixMountEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapUnixMountEntry(ptr unsafe.Pointer) *UnixMountEntry {
	if ptr == nil {
		return nil
	}

	return (*UnixMountEntry)(ptr)
}

func marshalUnixMountEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapUnixMountEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *UnixMountEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// UnixMountPoint defines a Unix mount point (e.g. <filename>/dev</filename>).
// This corresponds roughly to a fstab entry.
type UnixMountPoint struct {
	native C.GUnixMountPoint
}

// WrapUnixMountPoint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapUnixMountPoint(ptr unsafe.Pointer) *UnixMountPoint {
	if ptr == nil {
		return nil
	}

	return (*UnixMountPoint)(ptr)
}

func marshalUnixMountPoint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapUnixMountPoint(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *UnixMountPoint) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// Compare compares two unix mount points.
func (m *UnixMountPoint) Compare(mount2 *UnixMountPoint) int {
	var _arg0 *C.GUnixMountPoint // out
	var _arg1 *C.GUnixMountPoint // out
	var _cret C.gint             // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GUnixMountPoint)(unsafe.Pointer(mount2.Native()))

	_cret = C.g_unix_mount_point_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Copy makes a copy of @mount_point.
func (m *UnixMountPoint) Copy() *UnixMountPoint {
	var _arg0 *C.GUnixMountPoint // out
	var _cret *C.GUnixMountPoint // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_copy(_arg0)

	var _unixMountPoint *UnixMountPoint // out

	_unixMountPoint = WrapUnixMountPoint(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_unixMountPoint, func(v *UnixMountPoint) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _unixMountPoint
}

// Free frees a unix mount point.
func (m *UnixMountPoint) Free() {
	var _arg0 *C.GUnixMountPoint // out

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	C.g_unix_mount_point_free(_arg0)
}

// DevicePath gets the device path for a unix mount point.
func (m *UnixMountPoint) DevicePath() string {
	var _arg0 *C.GUnixMountPoint // out
	var _cret *C.char            // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_get_device_path(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// FSType gets the file system type for the mount point.
func (m *UnixMountPoint) FSType() string {
	var _arg0 *C.GUnixMountPoint // out
	var _cret *C.char            // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_get_fs_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// MountPath gets the mount path for a unix mount point.
func (m *UnixMountPoint) MountPath() string {
	var _arg0 *C.GUnixMountPoint // out
	var _cret *C.char            // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_get_mount_path(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// Options gets the options for the mount point.
func (m *UnixMountPoint) Options() string {
	var _arg0 *C.GUnixMountPoint // out
	var _cret *C.char            // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_get_options(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GuessCanEject guesses whether a Unix mount point can be ejected.
func (m *UnixMountPoint) GuessCanEject() bool {
	var _arg0 *C.GUnixMountPoint // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_guess_can_eject(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GuessIcon guesses the icon of a Unix mount point.
func (m *UnixMountPoint) GuessIcon() Icon {
	var _arg0 *C.GUnixMountPoint // out
	var _cret *C.GIcon           // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_guess_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

// GuessName guesses the name of a Unix mount point. The result is a translated
// string.
func (m *UnixMountPoint) GuessName() string {
	var _arg0 *C.GUnixMountPoint // out
	var _cret *C.char            // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_guess_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GuessSymbolicIcon guesses the symbolic icon of a Unix mount point.
func (m *UnixMountPoint) GuessSymbolicIcon() Icon {
	var _arg0 *C.GUnixMountPoint // out
	var _cret *C.GIcon           // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_guess_symbolic_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

// IsLoopback checks if a unix mount point is a loopback device.
func (m *UnixMountPoint) IsLoopback() bool {
	var _arg0 *C.GUnixMountPoint // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_is_loopback(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsReadonly checks if a unix mount point is read only.
func (m *UnixMountPoint) IsReadonly() bool {
	var _arg0 *C.GUnixMountPoint // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_is_readonly(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsUserMountable checks if a unix mount point is mountable by the user.
func (m *UnixMountPoint) IsUserMountable() bool {
	var _arg0 *C.GUnixMountPoint // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

	_cret = C.g_unix_mount_point_is_user_mountable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
