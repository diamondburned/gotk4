// Code generated by girgen. DO NOT EDIT.

package gio

import (
"runtime"
"unsafe"

"github.com/diamondburned/gotk4/core/gerror"
"github.com/diamondburned/gotk4/core/gextras"
"github.com/diamondburned/gotk4/pkg/glib/v2"
externglib "github.com/gotk3/gotk3/glib"
)


// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
  externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
      {T: externglib.Type(C.g_bus_type_get_type()), F: marshalBusType},
      {T: externglib.Type(C.g_converter_result_get_type()), F: marshalConverterResult},
      {T: externglib.Type(C.g_credentials_type_get_type()), F: marshalCredentialsType},
      {T: externglib.Type(C.g_dbus_error_get_type()), F: marshalDBusError},
      {T: externglib.Type(C.g_dbus_message_byte_order_get_type()), F: marshalDBusMessageByteOrder},
      {T: externglib.Type(C.g_dbus_message_header_field_get_type()), F: marshalDBusMessageHeaderField},
      {T: externglib.Type(C.g_dbus_message_type_get_type()), F: marshalDBusMessageType},
      {T: externglib.Type(C.g_data_stream_byte_order_get_type()), F: marshalDataStreamByteOrder},
      {T: externglib.Type(C.g_data_stream_newline_type_get_type()), F: marshalDataStreamNewlineType},
      {T: externglib.Type(C.g_drive_start_stop_type_get_type()), F: marshalDriveStartStopType},
      {T: externglib.Type(C.g_emblem_origin_get_type()), F: marshalEmblemOrigin},
      {T: externglib.Type(C.g_file_attribute_status_get_type()), F: marshalFileAttributeStatus},
      {T: externglib.Type(C.g_file_attribute_type_get_type()), F: marshalFileAttributeType},
      {T: externglib.Type(C.g_file_monitor_event_get_type()), F: marshalFileMonitorEvent},
      {T: externglib.Type(C.g_file_type_get_type()), F: marshalFileType},
      {T: externglib.Type(C.g_filesystem_preview_type_get_type()), F: marshalFilesystemPreviewType},
      {T: externglib.Type(C.g_io_error_enum_get_type()), F: marshalIOErrorEnum},
      {T: externglib.Type(C.g_io_module_scope_flags_get_type()), F: marshalIOModuleScopeFlags},
      {T: externglib.Type(C.g_memory_monitor_warning_level_get_type()), F: marshalMemoryMonitorWarningLevel},
      {T: externglib.Type(C.g_mount_operation_result_get_type()), F: marshalMountOperationResult},
      {T: externglib.Type(C.g_network_connectivity_get_type()), F: marshalNetworkConnectivity},
      {T: externglib.Type(C.g_notification_priority_get_type()), F: marshalNotificationPriority},
      {T: externglib.Type(C.g_password_save_get_type()), F: marshalPasswordSave},
      {T: externglib.Type(C.g_pollable_return_get_type()), F: marshalPollableReturn},
      {T: externglib.Type(C.g_resolver_error_get_type()), F: marshalResolverError},
      {T: externglib.Type(C.g_resolver_record_type_get_type()), F: marshalResolverRecordType},
      {T: externglib.Type(C.g_resource_error_get_type()), F: marshalResourceError},
      {T: externglib.Type(C.g_socket_client_event_get_type()), F: marshalSocketClientEvent},
      {T: externglib.Type(C.g_socket_family_get_type()), F: marshalSocketFamily},
      {T: externglib.Type(C.g_socket_listener_event_get_type()), F: marshalSocketListenerEvent},
      {T: externglib.Type(C.g_socket_protocol_get_type()), F: marshalSocketProtocol},
      {T: externglib.Type(C.g_socket_type_get_type()), F: marshalSocketType},
      {T: externglib.Type(C.g_tls_authentication_mode_get_type()), F: marshalTLSAuthenticationMode},
      {T: externglib.Type(C.g_tls_certificate_request_flags_get_type()), F: marshalTLSCertificateRequestFlags},
      {T: externglib.Type(C.g_tls_channel_binding_error_get_type()), F: marshalTLSChannelBindingError},
      {T: externglib.Type(C.g_tls_channel_binding_type_get_type()), F: marshalTLSChannelBindingType},
      {T: externglib.Type(C.g_tls_database_lookup_flags_get_type()), F: marshalTLSDatabaseLookupFlags},
      {T: externglib.Type(C.g_tls_error_get_type()), F: marshalTLSError},
      {T: externglib.Type(C.g_tls_interaction_result_get_type()), F: marshalTLSInteractionResult},
      {T: externglib.Type(C.g_tls_rehandshake_mode_get_type()), F: marshalTLSRehandshakeMode},
      {T: externglib.Type(C.g_unix_socket_address_type_get_type()), F: marshalUnixSocketAddressType},
      {T: externglib.Type(C.g_zlib_compressor_format_get_type()), F: marshalZlibCompressorFormat},
      {T: externglib.Type(C.g_app_info_create_flags_get_type()), F: marshalAppInfoCreateFlags},
      {T: externglib.Type(C.g_application_flags_get_type()), F: marshalApplicationFlags},
      {T: externglib.Type(C.g_ask_password_flags_get_type()), F: marshalAskPasswordFlags},
      {T: externglib.Type(C.g_bus_name_owner_flags_get_type()), F: marshalBusNameOwnerFlags},
      {T: externglib.Type(C.g_bus_name_watcher_flags_get_type()), F: marshalBusNameWatcherFlags},
      {T: externglib.Type(C.g_converter_flags_get_type()), F: marshalConverterFlags},
      {T: externglib.Type(C.g_dbus_call_flags_get_type()), F: marshalDBusCallFlags},
      {T: externglib.Type(C.g_dbus_capability_flags_get_type()), F: marshalDBusCapabilityFlags},
      {T: externglib.Type(C.g_dbus_connection_flags_get_type()), F: marshalDBusConnectionFlags},
      {T: externglib.Type(C.g_dbus_interface_skeleton_flags_get_type()), F: marshalDBusInterfaceSkeletonFlags},
      {T: externglib.Type(C.g_dbus_message_flags_get_type()), F: marshalDBusMessageFlags},
      {T: externglib.Type(C.g_dbus_object_manager_client_flags_get_type()), F: marshalDBusObjectManagerClientFlags},
      {T: externglib.Type(C.g_dbus_property_info_flags_get_type()), F: marshalDBusPropertyInfoFlags},
      {T: externglib.Type(C.g_dbus_proxy_flags_get_type()), F: marshalDBusProXYFlags},
      {T: externglib.Type(C.g_dbus_send_message_flags_get_type()), F: marshalDBusSendMessageFlags},
      {T: externglib.Type(C.g_dbus_server_flags_get_type()), F: marshalDBusServerFlags},
      {T: externglib.Type(C.g_dbus_signal_flags_get_type()), F: marshalDBusSignalFlags},
      {T: externglib.Type(C.g_dbus_subtree_flags_get_type()), F: marshalDBusSubtreeFlags},
      {T: externglib.Type(C.g_drive_start_flags_get_type()), F: marshalDriveStartFlags},
      {T: externglib.Type(C.g_file_attribute_info_flags_get_type()), F: marshalFileAttributeInfoFlags},
      {T: externglib.Type(C.g_file_copy_flags_get_type()), F: marshalFileCopyFlags},
      {T: externglib.Type(C.g_file_create_flags_get_type()), F: marshalFileCreateFlags},
      {T: externglib.Type(C.g_file_measure_flags_get_type()), F: marshalFileMeasureFlags},
      {T: externglib.Type(C.g_file_monitor_flags_get_type()), F: marshalFileMonitorFlags},
      {T: externglib.Type(C.g_file_query_info_flags_get_type()), F: marshalFileQueryInfoFlags},
      {T: externglib.Type(C.g_io_stream_splice_flags_get_type()), F: marshalIOStreamSpliceFlags},
      {T: externglib.Type(C.g_mount_mount_flags_get_type()), F: marshalMountMountFlags},
      {T: externglib.Type(C.g_mount_unmount_flags_get_type()), F: marshalMountUnmountFlags},
      {T: externglib.Type(C.g_output_stream_splice_flags_get_type()), F: marshalOutputStreamSpliceFlags},
      {T: externglib.Type(C.g_resolver_name_lookup_flags_get_type()), F: marshalResolverNameLookupFlags},
      {T: externglib.Type(C.g_resource_flags_get_type()), F: marshalResourceFlags},
      {T: externglib.Type(C.g_resource_lookup_flags_get_type()), F: marshalResourceLookupFlags},
      {T: externglib.Type(C.g_settings_bind_flags_get_type()), F: marshalSettingsBindFlags},
      {T: externglib.Type(C.g_socket_msg_flags_get_type()), F: marshalSocketMsgFlags},
      {T: externglib.Type(C.g_subprocess_flags_get_type()), F: marshalSubprocessFlags},
      {T: externglib.Type(C.g_test_dbus_flags_get_type()), F: marshalTestDBusFlags},
      {T: externglib.Type(C.g_tls_certificate_flags_get_type()), F: marshalTLSCertificateFlags},
      {T: externglib.Type(C.g_tls_database_verify_flags_get_type()), F: marshalTLSDatabaseVerifyFlags},
      {T: externglib.Type(C.g_tls_password_flags_get_type()), F: marshalTLSPasswordFlags},
      {T: externglib.Type(C.g_action_get_type()), F: marshalAction},
      {T: externglib.Type(C.g_action_group_get_type()), F: marshalActionGroup},
      {T: externglib.Type(C.g_action_map_get_type()), F: marshalActionMap},
      {T: externglib.Type(C.g_app_info_get_type()), F: marshalAppInfo},
      {T: externglib.Type(C.g_async_initable_get_type()), F: marshalAsyncInitable},
      {T: externglib.Type(C.g_async_result_get_type()), F: marshalAsyncResult},
      {T: externglib.Type(C.g_converter_get_type()), F: marshalConverter},
      {T: externglib.Type(C.g_dbus_interface_get_type()), F: marshalDBusInterface},
      {T: externglib.Type(C.g_dbus_object_get_type()), F: marshalDBusObject},
      {T: externglib.Type(C.g_dbus_object_manager_get_type()), F: marshalDBusObjectManager},
      {T: externglib.Type(C.g_datagram_based_get_type()), F: marshalDatagramBased},
      {T: externglib.Type(C.g_desktop_app_info_lookup_get_type()), F: marshalDesktopAppInfoLookup},
      {T: externglib.Type(C.g_drive_get_type()), F: marshalDrive},
      {T: externglib.Type(C.g_dtls_client_connection_get_type()), F: marshalDTLSClientConnection},
      {T: externglib.Type(C.g_dtls_connection_get_type()), F: marshalDTLSConnection},
      {T: externglib.Type(C.g_dtls_server_connection_get_type()), F: marshalDTLSServerConnection},
      {T: externglib.Type(C.g_file_get_type()), F: marshalFile},
      {T: externglib.Type(C.g_file_descriptor_based_get_type()), F: marshalFileDescriptorBased},
      {T: externglib.Type(C.g_icon_get_type()), F: marshalIcon},
      {T: externglib.Type(C.g_initable_get_type()), F: marshalInitable},
      {T: externglib.Type(C.g_list_model_get_type()), F: marshalListModel},
      {T: externglib.Type(C.g_loadable_icon_get_type()), F: marshalLoadableIcon},
      {T: externglib.Type(C.g_memory_monitor_get_type()), F: marshalMemoryMonitor},
      {T: externglib.Type(C.g_mount_get_type()), F: marshalMount},
      {T: externglib.Type(C.g_network_monitor_get_type()), F: marshalNetworkMonitor},
      {T: externglib.Type(C.g_pollable_input_stream_get_type()), F: marshalPollableInputStream},
      {T: externglib.Type(C.g_pollable_output_stream_get_type()), F: marshalPollableOutputStream},
      {T: externglib.Type(C.g_proxy_get_type()), F: marshalProXY},
      {T: externglib.Type(C.g_proxy_resolver_get_type()), F: marshalProXYResolver},
      {T: externglib.Type(C.g_remote_action_group_get_type()), F: marshalRemoteActionGroup},
      {T: externglib.Type(C.g_seekable_get_type()), F: marshalSeekable},
      {T: externglib.Type(C.g_socket_connectable_get_type()), F: marshalSocketConnectable},
      {T: externglib.Type(C.g_tls_backend_get_type()), F: marshalTLSBackend},
      {T: externglib.Type(C.g_tls_client_connection_get_type()), F: marshalTLSClientConnection},
      {T: externglib.Type(C.g_tls_file_database_get_type()), F: marshalTLSFileDatabase},
      {T: externglib.Type(C.g_tls_server_connection_get_type()), F: marshalTLSServerConnection},
      {T: externglib.Type(C.g_volume_get_type()), F: marshalVolume},
      {T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
      {T: externglib.Type(C.g_app_launch_context_get_type()), F: marshalAppLaunchContext},
      {T: externglib.Type(C.g_application_get_type()), F: marshalApplication},
      {T: externglib.Type(C.g_application_command_line_get_type()), F: marshalApplicationCommandLine},
      {T: externglib.Type(C.g_buffered_input_stream_get_type()), F: marshalBufferedInputStream},
      {T: externglib.Type(C.g_buffered_output_stream_get_type()), F: marshalBufferedOutputStream},
      {T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIcon},
      {T: externglib.Type(C.g_cancellable_get_type()), F: marshalCancellable},
      {T: externglib.Type(C.g_charset_converter_get_type()), F: marshalCharsetConverter},
      {T: externglib.Type(C.g_converter_input_stream_get_type()), F: marshalConverterInputStream},
      {T: externglib.Type(C.g_converter_output_stream_get_type()), F: marshalConverterOutputStream},
      {T: externglib.Type(C.g_credentials_get_type()), F: marshalCredentials},
      {T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
      {T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
      {T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
      {T: externglib.Type(C.g_dbus_interface_skeleton_get_type()), F: marshalDBusInterfaceSkeleton},
      {T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
      {T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
      {T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
      {T: externglib.Type(C.g_dbus_object_manager_client_get_type()), F: marshalDBusObjectManagerClient},
      {T: externglib.Type(C.g_dbus_object_manager_server_get_type()), F: marshalDBusObjectManagerServer},
      {T: externglib.Type(C.g_dbus_object_proxy_get_type()), F: marshalDBusObjectProXY},
      {T: externglib.Type(C.g_dbus_object_skeleton_get_type()), F: marshalDBusObjectSkeleton},
      {T: externglib.Type(C.g_dbus_proxy_get_type()), F: marshalDBusProXY},
      {T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
      {T: externglib.Type(C.g_data_input_stream_get_type()), F: marshalDataInputStream},
      {T: externglib.Type(C.g_data_output_stream_get_type()), F: marshalDataOutputStream},
      {T: externglib.Type(C.g_desktop_app_info_get_type()), F: marshalDesktopAppInfo},
      {T: externglib.Type(C.g_emblem_get_type()), F: marshalEmblem},
      {T: externglib.Type(C.g_emblemed_icon_get_type()), F: marshalEmblemedIcon},
      {T: externglib.Type(C.g_file_enumerator_get_type()), F: marshalFileEnumerator},
      {T: externglib.Type(C.g_file_io_stream_get_type()), F: marshalFileIOStream},
      {T: externglib.Type(C.g_file_icon_get_type()), F: marshalFileIcon},
      {T: externglib.Type(C.g_file_info_get_type()), F: marshalFileInfo},
      {T: externglib.Type(C.g_file_input_stream_get_type()), F: marshalFileInputStream},
      {T: externglib.Type(C.g_file_monitor_get_type()), F: marshalFileMonitor},
      {T: externglib.Type(C.g_file_output_stream_get_type()), F: marshalFileOutputStream},
      {T: externglib.Type(C.g_filename_completer_get_type()), F: marshalFilenameCompleter},
      {T: externglib.Type(C.g_filter_input_stream_get_type()), F: marshalFilterInputStream},
      {T: externglib.Type(C.g_filter_output_stream_get_type()), F: marshalFilterOutputStream},
      {T: externglib.Type(C.g_io_stream_get_type()), F: marshalIOStream},
      {T: externglib.Type(C.g_inet_address_get_type()), F: marshalInetAddress},
      {T: externglib.Type(C.g_inet_address_mask_get_type()), F: marshalInetAddressMask},
      {T: externglib.Type(C.g_inet_socket_address_get_type()), F: marshalInetSocketAddress},
      {T: externglib.Type(C.g_input_stream_get_type()), F: marshalInputStream},
      {T: externglib.Type(C.g_list_store_get_type()), F: marshalListStore},
      {T: externglib.Type(C.g_memory_input_stream_get_type()), F: marshalMemoryInputStream},
      {T: externglib.Type(C.g_memory_output_stream_get_type()), F: marshalMemoryOutputStream},
      {T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
      {T: externglib.Type(C.g_menu_attribute_iter_get_type()), F: marshalMenuAttributeIter},
      {T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
      {T: externglib.Type(C.g_menu_link_iter_get_type()), F: marshalMenuLinkIter},
      {T: externglib.Type(C.g_menu_model_get_type()), F: marshalMenuModel},
      {T: externglib.Type(C.g_mount_operation_get_type()), F: marshalMountOperation},
      {T: externglib.Type(C.g_native_socket_address_get_type()), F: marshalNativeSocketAddress},
      {T: externglib.Type(C.g_native_volume_monitor_get_type()), F: marshalNativeVolumeMonitor},
      {T: externglib.Type(C.g_network_address_get_type()), F: marshalNetworkAddress},
      {T: externglib.Type(C.g_network_service_get_type()), F: marshalNetworkService},
      {T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
      {T: externglib.Type(C.g_output_stream_get_type()), F: marshalOutputStream},
      {T: externglib.Type(C.g_permission_get_type()), F: marshalPermission},
      {T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
      {T: externglib.Type(C.g_proxy_address_get_type()), F: marshalProXYAddress},
      {T: externglib.Type(C.g_proxy_address_enumerator_get_type()), F: marshalProXYAddressEnumerator},
      {T: externglib.Type(C.g_resolver_get_type()), F: marshalResolver},
      {T: externglib.Type(C.g_settings_get_type()), F: marshalSettings},
      {T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
      {T: externglib.Type(C.g_simple_action_group_get_type()), F: marshalSimpleActionGroup},
      {T: externglib.Type(C.g_simple_async_result_get_type()), F: marshalSimpleAsyncResult},
      {T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
      {T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
      {T: externglib.Type(C.g_simple_proxy_resolver_get_type()), F: marshalSimpleProXYResolver},
      {T: externglib.Type(C.g_socket_get_type()), F: marshalSocket},
      {T: externglib.Type(C.g_socket_address_get_type()), F: marshalSocketAddress},
      {T: externglib.Type(C.g_socket_address_enumerator_get_type()), F: marshalSocketAddressEnumerator},
      {T: externglib.Type(C.g_socket_client_get_type()), F: marshalSocketClient},
      {T: externglib.Type(C.g_socket_connection_get_type()), F: marshalSocketConnection},
      {T: externglib.Type(C.g_socket_control_message_get_type()), F: marshalSocketControlMessage},
      {T: externglib.Type(C.g_socket_listener_get_type()), F: marshalSocketListener},
      {T: externglib.Type(C.g_socket_service_get_type()), F: marshalSocketService},
      {T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
      {T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
      {T: externglib.Type(C.g_task_get_type()), F: marshalTask},
      {T: externglib.Type(C.g_tcp_connection_get_type()), F: marshalTCPConnection},
      {T: externglib.Type(C.g_tcp_wrapper_connection_get_type()), F: marshalTCPWrapperConnection},
      {T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
      {T: externglib.Type(C.g_themed_icon_get_type()), F: marshalThemedIcon},
      {T: externglib.Type(C.g_threaded_socket_service_get_type()), F: marshalThreadedSocketService},
      {T: externglib.Type(C.g_tls_certificate_get_type()), F: marshalTLSCertificate},
      {T: externglib.Type(C.g_tls_connection_get_type()), F: marshalTLSConnection},
      {T: externglib.Type(C.g_tls_database_get_type()), F: marshalTLSDatabase},
      {T: externglib.Type(C.g_tls_interaction_get_type()), F: marshalTLSInteraction},
      {T: externglib.Type(C.g_tls_password_get_type()), F: marshalTLSPassword},
      {T: externglib.Type(C.g_unix_connection_get_type()), F: marshalUnixConnection},
      {T: externglib.Type(C.g_unix_credentials_message_get_type()), F: marshalUnixCredentialsMessage},
      {T: externglib.Type(C.g_unix_fd_list_get_type()), F: marshalUnixFDList},
      {T: externglib.Type(C.g_unix_fd_message_get_type()), F: marshalUnixFDMessage},
      {T: externglib.Type(C.g_unix_input_stream_get_type()), F: marshalUnixInputStream},
      {T: externglib.Type(C.g_unix_mount_monitor_get_type()), F: marshalUnixMountMonitor},
      {T: externglib.Type(C.g_unix_output_stream_get_type()), F: marshalUnixOutputStream},
      {T: externglib.Type(C.g_unix_socket_address_get_type()), F: marshalUnixSocketAddress},
      {T: externglib.Type(C.g_vfs_get_type()), F: marshalVFS},
      {T: externglib.Type(C.g_volume_monitor_get_type()), F: marshalVolumeMonitor},
      {T: externglib.Type(C.g_zlib_compressor_get_type()), F: marshalZlibCompressor},
      {T: externglib.Type(C.g_zlib_decompressor_get_type()), F: marshalZlibDecompressor},
      {T: externglib.Type(C.g_dbus_annotation_info_get_type()), F: marshalDBusAnnotationInfo},
      {T: externglib.Type(C.g_dbus_arg_info_get_type()), F: marshalDBusArgInfo},
      {T: externglib.Type(C.g_dbus_interface_info_get_type()), F: marshalDBusInterfaceInfo},
      {T: externglib.Type(C.g_dbus_method_info_get_type()), F: marshalDBusMethodInfo},
      {T: externglib.Type(C.g_dbus_node_info_get_type()), F: marshalDBusNodeInfo},
      {T: externglib.Type(C.g_dbus_property_info_get_type()), F: marshalDBusPropertyInfo},
      {T: externglib.Type(C.g_dbus_signal_info_get_type()), F: marshalDBusSignalInfo},
      {T: externglib.Type(C.g_file_attribute_info_list_get_type()), F: marshalFileAttributeInfoList},
      {T: externglib.Type(C.g_file_attribute_matcher_get_type()), F: marshalFileAttributeMatcher},
      {T: externglib.Type(C.g_resource_get_type()), F: marshalResource},
      {T: externglib.Type(C.g_settings_schema_get_type()), F: marshalSettingsSchema},
      {T: externglib.Type(C.g_settings_schema_key_get_type()), F: marshalSettingsSchemaKey},
      {T: externglib.Type(C.g_settings_schema_source_get_type()), F: marshalSettingsSchemaSource},
      {T: externglib.Type(C.g_srv_target_get_type()), F: marshalSrvTarget},
      {T: externglib.Type(C.g_unix_mount_entry_get_type()), F: marshalUnixMountEntry},
      {T: externglib.Type(C.g_unix_mount_point_get_type()), F: marshalUnixMountPoint},
  })
}


	

	// BusType: an enumeration for well-known message buses.
	type BusType int

	const (
			// BusTypeStarter: an alias for the message bus that activated the process,
	// if any.
		BusTypeStarter BusType = -1
			// BusTypeNone: not a message bus.
		BusTypeNone BusType = 0
			// BusTypeSystem: the system-wide message bus.
		BusTypeSystem BusType = 1
			// BusTypeSession: the login session message bus.
		BusTypeSession BusType = 2
		)

	
	func marshalBusType(p uintptr) (interface{}, error) {
		return BusType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ConverterResult results returned from g_converter_convert().
	type ConverterResult int

	const (
			// ConverterResultError: there was an error during conversion.
		ConverterResultError ConverterResult = 0
			// ConverterResultConverted: some data was consumed or produced
		ConverterResultConverted ConverterResult = 1
			// ConverterResultFinished: the conversion is finished
		ConverterResultFinished ConverterResult = 2
			// ConverterResultFlushed: flushing is finished
		ConverterResultFlushed ConverterResult = 3
		)

	
	func marshalConverterResult(p uintptr) (interface{}, error) {
		return ConverterResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CredentialsType: enumeration describing different kinds of native credential
// types.
	type CredentialsType int

	const (
			// CredentialsTypeInvalid indicates an invalid native credential type.
		CredentialsTypeInvalid CredentialsType = 0
			// CredentialsTypeLinuxUcred: the native credentials type is a `struct
	// ucred`.
		CredentialsTypeLinuxUcred CredentialsType = 1
			// CredentialsTypeFreebsdCmsgcred: the native credentials type is a `struct
	// cmsgcred`.
		CredentialsTypeFreebsdCmsgcred CredentialsType = 2
			// CredentialsTypeOpenbsdSockpeercred: the native credentials type is a
	// `struct sockpeercred`. Added in 2.30.
		CredentialsTypeOpenbsdSockpeercred CredentialsType = 3
			// CredentialsTypeSolarisUcred: the native credentials type is a `ucred_t`.
	// Added in 2.40.
		CredentialsTypeSolarisUcred CredentialsType = 4
			// CredentialsTypeNetbsdUnpcbid: the native credentials type is a `struct
	// unpcbid`. Added in 2.42.
		CredentialsTypeNetbsdUnpcbid CredentialsType = 5
			// CredentialsTypeAppleXucred: the native credentials type is a `struct
	// xucred`. Added in 2.66.
		CredentialsTypeAppleXucred CredentialsType = 6
		)

	
	func marshalCredentialsType(p uintptr) (interface{}, error) {
		return CredentialsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusError: error codes for the G_DBUS_ERROR error domain.
	type DBusError int

	const (
			// DBusErrorFailed: a generic error; "something went wrong" - see the error
	// message for more.
		DBusErrorFailed DBusError = 0
			// DBusErrorNoMemory: there was not enough memory to complete an operation.
		DBusErrorNoMemory DBusError = 1
			// DBusErrorServiceUnknown: the bus doesn't know how to launch a service to
	// supply the bus name you wanted.
		DBusErrorServiceUnknown DBusError = 2
			// DBusErrorNameHasNoOwner: the bus name you referenced doesn't exist (i.e.
	// no application owns it).
		DBusErrorNameHasNoOwner DBusError = 3
			// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
		DBusErrorNoReply DBusError = 4
			// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
		DBusErrorIOError DBusError = 5
			// DBusErrorBadAddress: a D-Bus bus address was malformed.
		DBusErrorBadAddress DBusError = 6
			// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
		DBusErrorNotSupported DBusError = 7
			// DBusErrorLimitsExceeded: some limited resource is exhausted.
		DBusErrorLimitsExceeded DBusError = 8
			// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
		DBusErrorAccessDenied DBusError = 9
			// DBusErrorAuthFailed: authentication didn't work.
		DBusErrorAuthFailed DBusError = 10
			// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
		DBusErrorNoServer DBusError = 11
			// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
		DBusErrorTimeout DBusError = 12
			// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
		DBusErrorNoNetwork DBusError = 13
			// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
		DBusErrorAddressInUse DBusError = 14
			// DBusErrorDisconnected: the connection is disconnected and you're trying
	// to use it.
		DBusErrorDisconnected DBusError = 15
			// DBusErrorInvalidArgs: invalid arguments passed to a method call.
		DBusErrorInvalidArgs DBusError = 16
			// DBusErrorFileNotFound: missing file.
		DBusErrorFileNotFound DBusError = 17
			// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
		DBusErrorFileExists DBusError = 18
			// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
		DBusErrorUnknownMethod DBusError = 19
			// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
		DBusErrorTimedOut DBusError = 20
			// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
		DBusErrorMatchRuleNotFound DBusError = 21
			// DBusErrorMatchRuleInvalid: the match rule isn't syntactically valid.
		DBusErrorMatchRuleInvalid DBusError = 22
			// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
		DBusErrorSpawnExecFailed DBusError = 23
			// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
		DBusErrorSpawnForkFailed DBusError = 24
			// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
		DBusErrorSpawnChildExited DBusError = 25
			// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
		DBusErrorSpawnChildSignaled DBusError = 26
			// DBusErrorSpawnFailed: while starting a new process, something went wrong.
		DBusErrorSpawnFailed DBusError = 27
			// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
		DBusErrorSpawnSetupFailed DBusError = 28
			// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
		DBusErrorSpawnConfigInvalid DBusError = 29
			// DBusErrorSpawnServiceInvalid bus name was not valid.
		DBusErrorSpawnServiceInvalid DBusError = 30
			// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
		DBusErrorSpawnServiceNotFound DBusError = 31
			// DBusErrorSpawnPermissionsInvalid permissions are incorrect on the setuid
	// helper.
		DBusErrorSpawnPermissionsInvalid DBusError = 32
			// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
		DBusErrorSpawnFileInvalid DBusError = 33
			// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
		DBusErrorSpawnNoMemory DBusError = 34
			// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
		DBusErrorUnixProcessIDUnknown DBusError = 35
			// DBusErrorInvalidSignature: a type signature is not valid.
		DBusErrorInvalidSignature DBusError = 36
			// DBusErrorInvalidFileContent: a file contains invalid syntax or is
	// otherwise broken.
		DBusErrorInvalidFileContent DBusError = 37
			// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
		DBusErrorSelinuxSecurityContextUnknown DBusError = 38
			// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
		DBusErrorAdtAuditDataUnknown DBusError = 39
			// DBusErrorObjectPathInUse there's already an object with the requested
	// object path.
		DBusErrorObjectPathInUse DBusError = 40
			// DBusErrorUnknownObject: object you invoked a method on isn't known. Since
	// 2.42
		DBusErrorUnknownObject DBusError = 41
			// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42
		DBusErrorUnknownInterface DBusError = 42
			// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42
		DBusErrorUnknownProperty DBusError = 43
			// DBusErrorPropertyReadOnly: property you tried to set is read-only. Since
	// 2.42
		DBusErrorPropertyReadOnly DBusError = 44
		)

	
	func marshalDBusError(p uintptr) (interface{}, error) {
		return DBusError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
	type DBusMessageByteOrder int

	const (
			// DBusMessageByteOrderBigEndian: the byte order is big endian.
		DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
			// DBusMessageByteOrderLittleEndian: the byte order is little endian.
		DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
		)

	
	func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
		return DBusMessageByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusMessageHeaderField: header fields used in BusMessage.
	type DBusMessageHeaderField int

	const (
			// DBusMessageHeaderFieldInvalid: not a valid header field.
		DBusMessageHeaderFieldInvalid DBusMessageHeaderField = 0
			// DBusMessageHeaderFieldPath: the object path.
		DBusMessageHeaderFieldPath DBusMessageHeaderField = 1
			// DBusMessageHeaderFieldInterface: the interface name.
		DBusMessageHeaderFieldInterface DBusMessageHeaderField = 2
			// DBusMessageHeaderFieldMember: the method or signal name.
		DBusMessageHeaderFieldMember DBusMessageHeaderField = 3
			// DBusMessageHeaderFieldErrorName: the name of the error that occurred.
		DBusMessageHeaderFieldErrorName DBusMessageHeaderField = 4
			// DBusMessageHeaderFieldReplySerial: the serial number the message is a
	// reply to.
		DBusMessageHeaderFieldReplySerial DBusMessageHeaderField = 5
			// DBusMessageHeaderFieldDestination: the name the message is intended for.
		DBusMessageHeaderFieldDestination DBusMessageHeaderField = 6
			// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
		DBusMessageHeaderFieldSender DBusMessageHeaderField = 7
			// DBusMessageHeaderFieldSignature: the signature of the message body.
		DBusMessageHeaderFieldSignature DBusMessageHeaderField = 8
			// DBusMessageHeaderFieldNumUnixFds: the number of UNIX file descriptors
	// that accompany the message.
		DBusMessageHeaderFieldNumUnixFds DBusMessageHeaderField = 9
		)

	
	func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
		return DBusMessageHeaderField(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusMessageType: message types used in BusMessage.
	type DBusMessageType int

	const (
			// DBusMessageTypeInvalid: message is of invalid type.
		DBusMessageTypeInvalid DBusMessageType = 0
			// DBusMessageTypeMethodCall: method call.
		DBusMessageTypeMethodCall DBusMessageType = 1
			// DBusMessageTypeMethodReturn: method reply.
		DBusMessageTypeMethodReturn DBusMessageType = 2
			// DBusMessageTypeError: error reply.
		DBusMessageTypeError DBusMessageType = 3
			// DBusMessageTypeSignal: signal emission.
		DBusMessageTypeSignal DBusMessageType = 4
		)

	
	func marshalDBusMessageType(p uintptr) (interface{}, error) {
		return DBusMessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DataStreamByteOrder is used to ensure proper endianness of streaming data
// sources across various machine architectures.
	type DataStreamByteOrder int

	const (
			// DataStreamByteOrderBigEndian selects Big Endian byte order.
		DataStreamByteOrderBigEndian DataStreamByteOrder = 0
			// DataStreamByteOrderLittleEndian selects Little Endian byte order.
		DataStreamByteOrderLittleEndian DataStreamByteOrder = 1
			// DataStreamByteOrderHostEndian selects endianness based on host machine's
	// architecture.
		DataStreamByteOrderHostEndian DataStreamByteOrder = 2
		)

	
	func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
		return DataStreamByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DataStreamNewlineType is used when checking for or setting the line endings
// for a given file.
	type DataStreamNewlineType int

	const (
			// DataStreamNewlineTypeLf selects "LF" line endings, common on most modern
	// UNIX platforms.
		DataStreamNewlineTypeLf DataStreamNewlineType = 0
			// DataStreamNewlineTypeCr selects "CR" line endings.
		DataStreamNewlineTypeCr DataStreamNewlineType = 1
			// DataStreamNewlineTypeCrLf selects "CR, LF" line ending, common on
	// Microsoft Windows.
		DataStreamNewlineTypeCrLf DataStreamNewlineType = 2
			// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
		DataStreamNewlineTypeAny DataStreamNewlineType = 3
		)

	
	func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
		return DataStreamNewlineType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
	type DriveStartStopType int

	const (
			// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
		DriveStartStopTypeUnknown DriveStartStopType = 0
			// DriveStartStopTypeShutdown: the stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
		DriveStartStopTypeShutdown DriveStartStopType = 1
			// DriveStartStopTypeNetwork: the start/stop methods are used for
	// connecting/disconnect to the drive over the network.
		DriveStartStopTypeNetwork DriveStartStopType = 2
			// DriveStartStopTypeMultidisk: the start/stop methods will
	// assemble/disassemble a virtual drive from several physical drives.
		DriveStartStopTypeMultidisk DriveStartStopType = 3
			// DriveStartStopTypePassword: the start/stop methods will unlock/lock the
	// disk (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command)
		DriveStartStopTypePassword DriveStartStopType = 4
		)

	
	func marshalDriveStartStopType(p uintptr) (interface{}, error) {
		return DriveStartStopType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// EmblemOrigin: GEmblemOrigin is used to add information about the origin of
// the emblem to #GEmblem.
	type EmblemOrigin int

	const (
			// EmblemOriginUnknown: emblem of unknown origin
		EmblemOriginUnknown EmblemOrigin = 0
			// EmblemOriginDevice: emblem adds device-specific information
		EmblemOriginDevice EmblemOrigin = 1
			// EmblemOriginLivemetadata: emblem depicts live metadata, such as
	// "readonly"
		EmblemOriginLivemetadata EmblemOrigin = 2
			// EmblemOriginTag: emblem comes from a user-defined tag, e.g. set by
	// nautilus (in the future)
		EmblemOriginTag EmblemOrigin = 3
		)

	
	func marshalEmblemOrigin(p uintptr) (interface{}, error) {
		return EmblemOrigin(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
	type FileAttributeStatus int

	const (
			// FileAttributeStatusUnset: attribute value is unset (empty).
		FileAttributeStatusUnset FileAttributeStatus = 0
			// FileAttributeStatusSet: attribute value is set.
		FileAttributeStatusSet FileAttributeStatus = 1
			// FileAttributeStatusErrorSetting indicates an error in setting the value.
		FileAttributeStatusErrorSetting FileAttributeStatus = 2
		)

	
	func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
		return FileAttributeStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileAttributeType: the data types for file attributes.
	type FileAttributeType int

	const (
			// FileAttributeTypeInvalid indicates an invalid or uninitialized type.
		FileAttributeTypeInvalid FileAttributeType = 0
			// FileAttributeTypeString: a null terminated UTF8 string.
		FileAttributeTypeString FileAttributeType = 1
			// FileAttributeTypeByteString: a zero terminated string of non-zero bytes.
		FileAttributeTypeByteString FileAttributeType = 2
			// FileAttributeTypeBoolean: a boolean value.
		FileAttributeTypeBoolean FileAttributeType = 3
			// FileAttributeTypeUint32: an unsigned 4-byte/32-bit integer.
		FileAttributeTypeUint32 FileAttributeType = 4
			// FileAttributeTypeInt32: a signed 4-byte/32-bit integer.
		FileAttributeTypeInt32 FileAttributeType = 5
			// FileAttributeTypeUint64: an unsigned 8-byte/64-bit integer.
		FileAttributeTypeUint64 FileAttributeType = 6
			// FileAttributeTypeInt64: a signed 8-byte/64-bit integer.
		FileAttributeTypeInt64 FileAttributeType = 7
			// FileAttributeTypeObject: a #GObject.
		FileAttributeTypeObject FileAttributeType = 8
			// FileAttributeTypeStringv: a nil terminated char **. Since 2.22
		FileAttributeTypeStringv FileAttributeType = 9
		)

	
	func marshalFileAttributeType(p uintptr) (interface{}, error) {
		return FileAttributeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileMonitorEvent specifies what type of event a monitor event is.
	type FileMonitorEvent int

	const (
			// FileMonitorEventChanged: a file changed.
		FileMonitorEventChanged FileMonitorEvent = 0
			// FileMonitorEventChangesDoneHint: a hint that this was probably the last
	// change in a set of changes.
		FileMonitorEventChangesDoneHint FileMonitorEvent = 1
			// FileMonitorEventDeleted: a file was deleted.
		FileMonitorEventDeleted FileMonitorEvent = 2
			// FileMonitorEventCreated: a file was created.
		FileMonitorEventCreated FileMonitorEvent = 3
			// FileMonitorEventAttributeChanged: a file attribute was changed.
		FileMonitorEventAttributeChanged FileMonitorEvent = 4
			// FileMonitorEventPreUnmount: the file location will soon be unmounted.
		FileMonitorEventPreUnmount FileMonitorEvent = 5
			// FileMonitorEventUnmounted: the file location was unmounted.
		FileMonitorEventUnmounted FileMonitorEvent = 6
			// FileMonitorEventMoved: the file was moved -- only sent if the
	// (deprecated) G_FILE_MONITOR_SEND_MOVED flag is set
		FileMonitorEventMoved FileMonitorEvent = 7
			// FileMonitorEventRenamed: the file was renamed within the current
	// directory -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set.
	// Since: 2.46.
		FileMonitorEventRenamed FileMonitorEvent = 8
			// FileMonitorEventMovedIn: the file was moved into the monitored directory
	// from another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
		FileMonitorEventMovedIn FileMonitorEvent = 9
			// FileMonitorEventMovedOut: the file was moved out of the monitored
	// directory to another location -- only sent if the
	// G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46
		FileMonitorEventMovedOut FileMonitorEvent = 10
		)

	
	func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
		return FileMonitorEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileType indicates the file's on-disk type.
// 
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type; use
// Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a file is
// a symlink or not. This is due to the fact that NTFS does not have a single
// filesystem object type for symbolic links - it has files that symlink to
// files, and directories that symlink to directories. Type enumeration cannot
// precisely represent this important distinction, which is why all Windows
// symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
	type FileType int

	const (
			// FileTypeUnknown file's type is unknown.
		FileTypeUnknown FileType = 0
			// FileTypeRegular: file handle represents a regular file.
		FileTypeRegular FileType = 1
			// FileTypeDirectory: file handle represents a directory.
		FileTypeDirectory FileType = 2
			// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
		FileTypeSymbolicLink FileType = 3
			// FileTypeSpecial: file is a "special" file, such as a socket, fifo, block
	// device, or character device.
		FileTypeSpecial FileType = 4
			// FileTypeShortcut: file is a shortcut (Windows systems).
		FileTypeShortcut FileType = 5
			// FileTypeMountable: file is a mountable location.
		FileTypeMountable FileType = 6
		)

	
	func marshalFileType(p uintptr) (interface{}, error) {
		return FileType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FilesystemPreviewType indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
	type FilesystemPreviewType int

	const (
			// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
		FilesystemPreviewTypeIfAlways FilesystemPreviewType = 0
			// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
		FilesystemPreviewTypeIfLocal FilesystemPreviewType = 1
			// FilesystemPreviewTypeNever: never preview files.
		FilesystemPreviewTypeNever FilesystemPreviewType = 2
		)

	
	func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
		return FilesystemPreviewType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IOErrorEnum: error codes returned by GIO functions.
// 
// Note that this domain may be extended in future GLib releases. In general,
// new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before. You
// should therefore avoid writing code like
// 
//    if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
//      {
//        // Assume that this is EPRINTERONFIRE
//        ...
//      }
// 
// but should instead treat all unrecognized error codes the same as
// IO_ERROR_FAILED.
// 
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
	type IOErrorEnum int

	const (
			// IOErrorEnumFailed: generic error condition for when an operation fails
	// and no more specific OErrorEnum value is defined.
		IOErrorEnumFailed IOErrorEnum = 0
			// IOErrorEnumNotFound: file not found.
		IOErrorEnumNotFound IOErrorEnum = 1
			// IOErrorEnumExists: file already exists.
		IOErrorEnumExists IOErrorEnum = 2
			// IOErrorEnumIsDirectory: file is a directory.
		IOErrorEnumIsDirectory IOErrorEnum = 3
			// IOErrorEnumNotDirectory: file is not a directory.
		IOErrorEnumNotDirectory IOErrorEnum = 4
			// IOErrorEnumNotEmpty: file is a directory that isn't empty.
		IOErrorEnumNotEmpty IOErrorEnum = 5
			// IOErrorEnumNotRegularFile: file is not a regular file.
		IOErrorEnumNotRegularFile IOErrorEnum = 6
			// IOErrorEnumNotSymbolicLink: file is not a symbolic link.
		IOErrorEnumNotSymbolicLink IOErrorEnum = 7
			// IOErrorEnumNotMountableFile: file cannot be mounted.
		IOErrorEnumNotMountableFile IOErrorEnum = 8
			// IOErrorEnumFilenameTooLong: filename is too many characters.
		IOErrorEnumFilenameTooLong IOErrorEnum = 9
			// IOErrorEnumInvalidFilename: filename is invalid or contains invalid
	// characters.
		IOErrorEnumInvalidFilename IOErrorEnum = 10
			// IOErrorEnumTooManyLinks: file contains too many symbolic links.
		IOErrorEnumTooManyLinks IOErrorEnum = 11
			// IOErrorEnumNoSpace: no space left on drive.
		IOErrorEnumNoSpace IOErrorEnum = 12
			// IOErrorEnumInvalidArgument: invalid argument.
		IOErrorEnumInvalidArgument IOErrorEnum = 13
			// IOErrorEnumPermissionDenied: permission denied.
		IOErrorEnumPermissionDenied IOErrorEnum = 14
			// IOErrorEnumNotSupported: operation (or one of its parameters) not
	// supported
		IOErrorEnumNotSupported IOErrorEnum = 15
			// IOErrorEnumNotMounted: file isn't mounted.
		IOErrorEnumNotMounted IOErrorEnum = 16
			// IOErrorEnumAlreadyMounted: file is already mounted.
		IOErrorEnumAlreadyMounted IOErrorEnum = 17
			// IOErrorEnumClosed: file was closed.
		IOErrorEnumClosed IOErrorEnum = 18
			// IOErrorEnumCancelled: operation was cancelled. See #GCancellable.
		IOErrorEnumCancelled IOErrorEnum = 19
			// IOErrorEnumPending operations are still pending.
		IOErrorEnumPending IOErrorEnum = 20
			// IOErrorEnumReadOnly: file is read only.
		IOErrorEnumReadOnly IOErrorEnum = 21
			// IOErrorEnumCantCreateBackup: backup couldn't be created.
		IOErrorEnumCantCreateBackup IOErrorEnum = 22
			// IOErrorEnumWrongEtag file's Entity Tag was incorrect.
		IOErrorEnumWrongEtag IOErrorEnum = 23
			// IOErrorEnumTimedOut: operation timed out.
		IOErrorEnumTimedOut IOErrorEnum = 24
			// IOErrorEnumWouldRecurse: operation would be recursive.
		IOErrorEnumWouldRecurse IOErrorEnum = 25
			// IOErrorEnumBusy: file is busy.
		IOErrorEnumBusy IOErrorEnum = 26
			// IOErrorEnumWouldBlock: operation would block.
		IOErrorEnumWouldBlock IOErrorEnum = 27
			// IOErrorEnumHostNotFound: host couldn't be found (remote operations).
		IOErrorEnumHostNotFound IOErrorEnum = 28
			// IOErrorEnumWouldMerge: operation would merge files.
		IOErrorEnumWouldMerge IOErrorEnum = 29
			// IOErrorEnumFailedHandled: operation failed and a helper program has
	// already interacted with the user. Do not display any error dialog.
		IOErrorEnumFailedHandled IOErrorEnum = 30
			// IOErrorEnumTooManyOpenFiles: the current process has too many files open
	// and can't open any more. Duplicate descriptors do count toward this
	// limit. Since 2.20
		IOErrorEnumTooManyOpenFiles IOErrorEnum = 31
			// IOErrorEnumNotInitialized: the object has not been initialized. Since
	// 2.22
		IOErrorEnumNotInitialized IOErrorEnum = 32
			// IOErrorEnumAddressInUse: the requested address is already in use. Since
	// 2.22
		IOErrorEnumAddressInUse IOErrorEnum = 33
			// IOErrorEnumPartialInput: need more input to finish operation. Since 2.24
		IOErrorEnumPartialInput IOErrorEnum = 34
			// IOErrorEnumInvalidData: the input data was invalid. Since 2.24
		IOErrorEnumInvalidData IOErrorEnum = 35
			// IOErrorEnumDBusError: a remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
		IOErrorEnumDBusError IOErrorEnum = 36
			// IOErrorEnumHostUnreachable: host unreachable. Since 2.26
		IOErrorEnumHostUnreachable IOErrorEnum = 37
			// IOErrorEnumNetworkUnreachable: network unreachable. Since 2.26
		IOErrorEnumNetworkUnreachable IOErrorEnum = 38
			// IOErrorEnumConnectionRefused: connection refused. Since 2.26
		IOErrorEnumConnectionRefused IOErrorEnum = 39
			// IOErrorEnumProXYFailed: connection to proxy server failed. Since 2.26
		IOErrorEnumProXYFailed IOErrorEnum = 40
			// IOErrorEnumProXYAuthFailed: proxy authentication failed. Since 2.26
		IOErrorEnumProXYAuthFailed IOErrorEnum = 41
			// IOErrorEnumProXYNeedAuth: proxy server needs authentication. Since 2.26
		IOErrorEnumProXYNeedAuth IOErrorEnum = 42
			// IOErrorEnumProXYNotAllowed: proxy connection is not allowed by ruleset.
	// Since 2.26
		IOErrorEnumProXYNotAllowed IOErrorEnum = 43
			// IOErrorEnumBrokenPipe: broken pipe. Since 2.36
		IOErrorEnumBrokenPipe IOErrorEnum = 44
			// IOErrorEnumConnectionClosed: connection closed by peer. Note that this is
	// the same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection
	// closed" errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
		IOErrorEnumConnectionClosed IOErrorEnum = 44
			// IOErrorEnumNotConnected: transport endpoint is not connected. Since 2.44
		IOErrorEnumNotConnected IOErrorEnum = 45
			// IOErrorEnumMessageTooLarge: message too large. Since 2.48.
		IOErrorEnumMessageTooLarge IOErrorEnum = 46
		)

	
	func marshalIOErrorEnum(p uintptr) (interface{}, error) {
		return IOErrorEnum(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IOModuleScopeFlags flags for use with g_io_module_scope_new().
	type IOModuleScopeFlags int

	const (
			// IOModuleScopeFlagsNone: no module scan flags
		IOModuleScopeFlagsNone IOModuleScopeFlags = 0
			// IOModuleScopeFlagsBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
		IOModuleScopeFlagsBlockDuplicates IOModuleScopeFlags = 1
		)

	
	func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
		return IOModuleScopeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// MemoryMonitorWarningLevel: memory availability warning levels.
// 
// Note that because new values might be added, it is recommended that
// applications check MonitorWarningLevel as ranges, for example:
// 
//    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//      drop_caches ();
	type MemoryMonitorWarningLevel int

	const (
			// MemoryMonitorWarningLevelLow: memory on the device is low, processes
	// should free up unneeded resources (for example, in-memory caches) so they
	// can be used elsewhere.
		MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
			// MemoryMonitorWarningLevelMedium: same as
	// @G_MEMORY_MONITOR_WARNING_LEVEL_LOW but the device has even less free
	// memory, so processes should try harder to free up unneeded resources. If
	// your process does not need to stay running, it is a good time for it to
	// quit.
		MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
			// MemoryMonitorWarningLevelCritical: the system will soon start terminating
	// processes to reclaim memory, including background processes.
		MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
		)

	
	func marshalMemoryMonitorWarningLevel(p uintptr) (interface{}, error) {
		return MemoryMonitorWarningLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// MountOperationResult is returned as a result when a request for information
// is send by the mounting operation.
	type MountOperationResult int

	const (
			// MountOperationResultHandled: the request was fulfilled and the user
	// specified data is now available
		MountOperationResultHandled MountOperationResult = 0
			// MountOperationResultAborted: the user requested the mount operation to be
	// aborted
		MountOperationResultAborted MountOperationResult = 1
			// MountOperationResultUnhandled: the request was unhandled (i.e. not
	// implemented)
		MountOperationResultUnhandled MountOperationResult = 2
		)

	
	func marshalMountOperationResult(p uintptr) (interface{}, error) {
		return MountOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// NetworkConnectivity: the host's network connectivity state, as reported by
// Monitor.
	type NetworkConnectivity int

	const (
			// NetworkConnectivityLocal: the host is not configured with a route to the
	// Internet; it may or may not be connected to a local network.
		NetworkConnectivityLocal NetworkConnectivity = 1
			// NetworkConnectivityLimited: the host is connected to a network, but does
	// not appear to be able to reach the full Internet, perhaps due to upstream
	// network problems.
		NetworkConnectivityLimited NetworkConnectivity = 2
			// NetworkConnectivityPortal: the host is behind a captive portal and cannot
	// reach the full Internet.
		NetworkConnectivityPortal NetworkConnectivity = 3
			// NetworkConnectivityFull: the host is connected to a network, and appears
	// to be able to reach the full Internet.
		NetworkConnectivityFull NetworkConnectivity = 4
		)

	
	func marshalNetworkConnectivity(p uintptr) (interface{}, error) {
		return NetworkConnectivity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// NotificationPriority: priority levels for #GNotifications.
	type NotificationPriority int

	const (
			// NotificationPriorityNormal: the default priority, to be used for the
	// majority of notifications (for example email messages, software updates,
	// completed download/sync operations)
		NotificationPriorityNormal NotificationPriority = 0
			// NotificationPriorityLow: for notifications that do not require immediate
	// attention - typically used for contextual background information, such as
	// contact birthdays or local weather
		NotificationPriorityLow NotificationPriority = 1
			// NotificationPriorityHigh: for events that require more attention, usually
	// because responses are time-sensitive (for example chat and SMS messages
	// or alarms)
		NotificationPriorityHigh NotificationPriority = 2
			// NotificationPriorityUrgent: for urgent notifications, or notifications
	// that require a response in a short space of time (for example phone calls
	// or emergency warnings)
		NotificationPriorityUrgent NotificationPriority = 3
		)

	
	func marshalNotificationPriority(p uintptr) (interface{}, error) {
		return NotificationPriority(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PasswordSave is used to indicate the lifespan of a saved password.
// 
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to, and
// later retrieves it again from there.
	type PasswordSave int

	const (
			// PasswordSaveNever: never save a password.
		PasswordSaveNever PasswordSave = 0
			// PasswordSaveForSession: save a password for the session.
		PasswordSaveForSession PasswordSave = 1
			// PasswordSavePermanently: save a password permanently.
		PasswordSavePermanently PasswordSave = 2
		)

	
	func marshalPasswordSave(p uintptr) (interface{}, error) {
		return PasswordSave(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PollableReturn: return value for various IO operations that signal errors via
// the return value and not necessarily via a #GError.
// 
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for regularly
// happening errors like G_IO_ERROR_WOULD_BLOCK.
// 
// In case of G_POLLABLE_RETURN_FAILED a #GError should be set for the operation
// to give details about the error that happened.
	type PollableReturn int

	const (
			// PollableReturnFailed: generic error condition for when an operation
	// fails.
		PollableReturnFailed PollableReturn = 0
			// PollableReturnOk: the operation was successfully finished.
		PollableReturnOk PollableReturn = 1
			// PollableReturnWouldBlock: the operation would block.
		PollableReturnWouldBlock PollableReturn = -27
		)

	
	func marshalPollableReturn(p uintptr) (interface{}, error) {
		return PollableReturn(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ResolverError: an error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
	type ResolverError int

	const (
			// ResolverErrorNotFound: the requested name/address/service was not found
		ResolverErrorNotFound ResolverError = 0
			// ResolverErrorTemporaryFailure: the requested information could not be
	// looked up due to a network error or similar problem
		ResolverErrorTemporaryFailure ResolverError = 1
			// ResolverErrorInternal: unknown error
		ResolverErrorInternal ResolverError = 2
		)

	
	func marshalResolverError(p uintptr) (interface{}, error) {
		return ResolverError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ResolverRecordType: the type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
// 
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
// weight, a `guint16` with the port, and a string of the hostname.
// 
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// `(qs)`, representing a `guint16` with the preference, and a string containing
// the mail exchanger hostname.
// 
// G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// `(as)`, representing an array of the strings in the text record. Note: Most
// TXT records only contain a single string, but RFC 1035
// (https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record to
// contain multiple strings. The RFC which defines the interpretation of a
// specific TXT record will likely require concatenation of multiple strings if
// they are present, as with RFC 7208
// (https://tools.ietf.org/html/rfc7208#section-3.3).
// 
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// `(ssuuuuu)`, representing a string containing the primary name server, a
// string containing the administrator, the serial as a `guint32`, the refresh
// interval as a `guint32`, the retry interval as a `guint32`, the expire
// timeout as a `guint32`, and the TTL as a `guint32`.
// 
// G_RESOLVER_RECORD_NS records are returned as variants with the signature
// `(s)`, representing a string of the hostname of the name server.
	type ResolverRecordType int

	const (
			// ResolverRecordTypeSrv: look up DNS SRV records for a domain
		ResolverRecordTypeSrv ResolverRecordType = 1
			// ResolverRecordTypeMx: look up DNS MX records for a domain
		ResolverRecordTypeMx ResolverRecordType = 2
			// ResolverRecordTypeTxt: look up DNS TXT records for a name
		ResolverRecordTypeTxt ResolverRecordType = 3
			// ResolverRecordTypeSoa: look up DNS SOA records for a zone
		ResolverRecordTypeSoa ResolverRecordType = 4
			// ResolverRecordTypeNs: look up DNS NS records for a domain
		ResolverRecordTypeNs ResolverRecordType = 5
		)

	
	func marshalResolverRecordType(p uintptr) (interface{}, error) {
		return ResolverRecordType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ResourceError: an error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
	type ResourceError int

	const (
			// ResourceErrorNotFound: no file was found at the requested path
		ResourceErrorNotFound ResourceError = 0
			// ResourceErrorInternal: unknown error
		ResourceErrorInternal ResourceError = 1
		)

	
	func marshalResourceError(p uintptr) (interface{}, error) {
		return ResourceError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SocketClientEvent describes an event occurring on a Client. See the
// Client::event signal for more details.
// 
// Additional values may be added to this type in the future.
	type SocketClientEvent int

	const (
			// SocketClientEventResolving: the client is doing a DNS lookup.
		SocketClientEventResolving SocketClientEvent = 0
			// SocketClientEventResolved: the client has completed a DNS lookup.
		SocketClientEventResolved SocketClientEvent = 1
			// SocketClientEventConnecting: the client is connecting to a remote host
	// (either a proxy or the destination server).
		SocketClientEventConnecting SocketClientEvent = 2
			// SocketClientEventConnected: the client has connected to a remote host.
		SocketClientEventConnected SocketClientEvent = 3
			// SocketClientEventProXYNegotiating: the client is negotiating with a proxy
	// to connect to the destination server.
		SocketClientEventProXYNegotiating SocketClientEvent = 4
			// SocketClientEventProXYNegotiated: the client has negotiated with the
	// proxy server.
		SocketClientEventProXYNegotiated SocketClientEvent = 5
			// SocketClientEventTLSHandshaking: the client is performing a TLS
	// handshake.
		SocketClientEventTLSHandshaking SocketClientEvent = 6
			// SocketClientEventTLSHandshaked: the client has performed a TLS handshake.
		SocketClientEventTLSHandshaked SocketClientEvent = 7
			// SocketClientEventComplete: the client is done with a particular
	// Connectable.
		SocketClientEventComplete SocketClientEvent = 8
		)

	
	func marshalSocketClientEvent(p uintptr) (interface{}, error) {
		return SocketClientEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SocketFamily: the protocol family of a Address. (These values are identical
// to the system defines AF_INET, AF_INET6 and AF_UNIX, if available.)
	type SocketFamily int

	const (
			// SocketFamilyInvalid: no address family
		SocketFamilyInvalid SocketFamily = 0
			// SocketFamilyUnix: the UNIX domain family
		SocketFamilyUnix SocketFamily = 1
			// SocketFamilyIPv4: the IPv4 family
		SocketFamilyIPv4 SocketFamily = 2
			// SocketFamilyIPv6: the IPv6 family
		SocketFamilyIPv6 SocketFamily = 10
		)

	
	func marshalSocketFamily(p uintptr) (interface{}, error) {
		return SocketFamily(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SocketListenerEvent describes an event occurring on a Listener. See the
// Listener::event signal for more details.
// 
// Additional values may be added to this type in the future.
	type SocketListenerEvent int

	const (
			// SocketListenerEventBinding: the listener is about to bind a socket.
		SocketListenerEventBinding SocketListenerEvent = 0
			// SocketListenerEventBound: the listener has bound a socket.
		SocketListenerEventBound SocketListenerEvent = 1
			// SocketListenerEventListening: the listener is about to start listening on
	// this socket.
		SocketListenerEventListening SocketListenerEvent = 2
			// SocketListenerEventListened: the listener is now listening on this
	// socket.
		SocketListenerEventListened SocketListenerEvent = 3
		)

	
	func marshalSocketListenerEvent(p uintptr) (interface{}, error) {
		return SocketListenerEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SocketProtocol: a protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
// 
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
	type SocketProtocol int

	const (
			// SocketProtocolUnknown: the protocol type is unknown
		SocketProtocolUnknown SocketProtocol = -1
			// SocketProtocolDefault: the default protocol for the family/type
		SocketProtocolDefault SocketProtocol = 0
			// SocketProtocolTCP: TCP over IP
		SocketProtocolTCP SocketProtocol = 6
			// SocketProtocolUDP: UDP over IP
		SocketProtocolUDP SocketProtocol = 17
			// SocketProtocolSCTP: SCTP over IP
		SocketProtocolSCTP SocketProtocol = 132
		)

	
	func marshalSocketProtocol(p uintptr) (interface{}, error) {
		return SocketProtocol(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SocketType flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
	type SocketType int

	const (
			// SocketTypeInvalid: type unknown or wrong
		SocketTypeInvalid SocketType = 0
			// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
		SocketTypeStream SocketType = 1
			// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP)
		SocketTypeDatagram SocketType = 2
			// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
		SocketTypeSeqpacket SocketType = 3
		)

	
	func marshalSocketType(p uintptr) (interface{}, error) {
		return SocketType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSAuthenticationMode: the client authentication mode for a ServerConnection.
	type TLSAuthenticationMode int

	const (
			// TLSAuthenticationModeNone: client authentication not required
		TLSAuthenticationModeNone TLSAuthenticationMode = 0
			// TLSAuthenticationModeRequested: client authentication is requested
		TLSAuthenticationModeRequested TLSAuthenticationMode = 1
			// TLSAuthenticationModeRequired: client authentication is required
		TLSAuthenticationModeRequired TLSAuthenticationMode = 2
		)

	
	func marshalTLSAuthenticationMode(p uintptr) (interface{}, error) {
		return TLSAuthenticationMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSCertificateRequestFlags flags for g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
	type TLSCertificateRequestFlags int

	const (
			// TLSCertificateRequestFlagsNone: no flags
		TLSCertificateRequestFlagsNone TLSCertificateRequestFlags = 0
		)

	
	func marshalTLSCertificateRequestFlags(p uintptr) (interface{}, error) {
		return TLSCertificateRequestFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSChannelBindingError: an error code used with G_TLS_CHANNEL_BINDING_ERROR
// in a #GError to indicate a TLS channel binding retrieval error.
	type TLSChannelBindingError int

	const (
			// TLSChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
		TLSChannelBindingErrorNotImplemented TLSChannelBindingError = 0
			// TLSChannelBindingErrorInvalidState: the handshake is not yet complete on
	// the connection which is a strong requirement for any existing binding
	// type.
		TLSChannelBindingErrorInvalidState TLSChannelBindingError = 1
			// TLSChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
		TLSChannelBindingErrorNotAvailable TLSChannelBindingError = 2
			// TLSChannelBindingErrorNotSupported: binding type is not supported on the
	// current connection. This error could be triggered when requesting
	// `tls-server-end-point` binding data for a certificate which has no hash
	// function or uses multiple hash functions.
		TLSChannelBindingErrorNotSupported TLSChannelBindingError = 3
			// TLSChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
		TLSChannelBindingErrorGeneralError TLSChannelBindingError = 4
		)

	
	func marshalTLSChannelBindingError(p uintptr) (interface{}, error) {
		return TLSChannelBindingError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSChannelBindingType: the type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929. The
// `tls-unique-for-telnet` (https://tools.ietf.org/html/rfc5929#section-5)
// binding type is not currently implemented.
	type TLSChannelBindingType int

	const (
			// TLSChannelBindingTypeUnique: `tls-unique`
	// (https://tools.ietf.org/html/rfc5929#section-3) binding type
		TLSChannelBindingTypeUnique TLSChannelBindingType = 0
			// TLSChannelBindingTypeServerEndPoint: `tls-server-end-point`
	// (https://tools.ietf.org/html/rfc5929#section-4) binding type
		TLSChannelBindingTypeServerEndPoint TLSChannelBindingType = 1
		)

	
	func marshalTLSChannelBindingType(p uintptr) (interface{}, error) {
		return TLSChannelBindingType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSDatabaseLookupFlags flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
	type TLSDatabaseLookupFlags int

	const (
			// TLSDatabaseLookupFlagsNone: no lookup flags
		TLSDatabaseLookupFlagsNone TLSDatabaseLookupFlags = 0
			// TLSDatabaseLookupFlagsKeypair: restrict lookup to certificates that have
	// a private key.
		TLSDatabaseLookupFlagsKeypair TLSDatabaseLookupFlags = 1
		)

	
	func marshalTLSDatabaseLookupFlags(p uintptr) (interface{}, error) {
		return TLSDatabaseLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSError: an error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
	type TLSError int

	const (
			// TLSErrorUnavailable: no TLS provider is available
		TLSErrorUnavailable TLSError = 0
			// TLSErrorMisc miscellaneous TLS error
		TLSErrorMisc TLSError = 1
			// TLSErrorBadCertificate: the certificate presented could not be parsed or
	// failed validation.
		TLSErrorBadCertificate TLSError = 2
			// TLSErrorNotTLS: the TLS handshake failed because the peer does not seem
	// to be a TLS server.
		TLSErrorNotTLS TLSError = 3
			// TLSErrorHandshake: the TLS handshake failed because the peer's
	// certificate was not acceptable.
		TLSErrorHandshake TLSError = 4
			// TLSErrorCertificateRequired: the TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
		TLSErrorCertificateRequired TLSError = 5
			// TLSErrorEOF: the TLS connection was closed without proper notice, which
	// may indicate an attack. See g_tls_connection_set_require_close_notify().
		TLSErrorEOF TLSError = 6
			// TLSErrorInappropriateFallback: the TLS handshake failed because the
	// client sent the fallback SCSV, indicating a protocol downgrade attack.
	// Since: 2.60
		TLSErrorInappropriateFallback TLSError = 7
		)

	
	func marshalTLSError(p uintptr) (interface{}, error) {
		return TLSError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSInteractionResult is returned by various functions in Interaction when
// finishing an interaction request.
	type TLSInteractionResult int

	const (
			// TLSInteractionResultUnhandled: the interaction was unhandled (i.e. not
	// implemented).
		TLSInteractionResultUnhandled TLSInteractionResult = 0
			// TLSInteractionResultHandled: the interaction completed, and resulting
	// data is available.
		TLSInteractionResultHandled TLSInteractionResult = 1
			// TLSInteractionResultFailed: the interaction has failed, or was cancelled.
	// and the operation should be aborted.
		TLSInteractionResultFailed TLSInteractionResult = 2
		)

	
	func marshalTLSInteractionResult(p uintptr) (interface{}, error) {
		return TLSInteractionResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
	type TLSRehandshakeMode int

	const (
			// TLSRehandshakeModeNever: never allow rehandshaking
		TLSRehandshakeModeNever TLSRehandshakeMode = 0
			// TLSRehandshakeModeSafely: allow safe rehandshaking only
		TLSRehandshakeModeSafely TLSRehandshakeMode = 1
			// TLSRehandshakeModeUnsafely: allow unsafe rehandshaking
		TLSRehandshakeModeUnsafely TLSRehandshakeMode = 2
		)

	
	func marshalTLSRehandshakeMode(p uintptr) (interface{}, error) {
		return TLSRehandshakeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// UnixSocketAddressType: the type of name used by a SocketAddress.
// G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain socket bound
// to a filesystem path. G_UNIX_SOCKET_ADDRESS_ANONYMOUS indicates a socket not
// bound to any name (eg, a client-side socket, or a socket created with
// socketpair()).
// 
// For abstract sockets, there are two incompatible ways of naming them; the man
// pages suggest using the entire `struct sockaddr_un` as the name, padding the
// unused parts of the sun_path field with zeroes; this corresponds to
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED. However, many programs instead just
// use a portion of sun_path, and pass an appropriate smaller length to bind()
// or connect(). This is G_UNIX_SOCKET_ADDRESS_ABSTRACT.
	type UnixSocketAddressType int

	const (
			// UnixSocketAddressTypeInvalid: invalid
		UnixSocketAddressTypeInvalid UnixSocketAddressType = 0
			// UnixSocketAddressTypeAnonymous: anonymous
		UnixSocketAddressTypeAnonymous UnixSocketAddressType = 1
			// UnixSocketAddressTypePath: a filesystem path
		UnixSocketAddressTypePath UnixSocketAddressType = 2
			// UnixSocketAddressTypeAbstract: an abstract name
		UnixSocketAddressTypeAbstract UnixSocketAddressType = 3
			// UnixSocketAddressTypeAbstractPadded: an abstract name, 0-padded to the
	// full length of a unix socket name
		UnixSocketAddressTypeAbstractPadded UnixSocketAddressType = 4
		)

	
	func marshalUnixSocketAddressType(p uintptr) (interface{}, error) {
		return UnixSocketAddressType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ZlibCompressorFormat: used to select the type of data format to use for
// Decompressor and Compressor.
	type ZlibCompressorFormat int

	const (
			// ZlibCompressorFormatZlib: deflate compression with zlib header
		ZlibCompressorFormatZlib ZlibCompressorFormat = 0
			// ZlibCompressorFormatGzip: gzip file format
		ZlibCompressorFormatGzip ZlibCompressorFormat = 1
			// ZlibCompressorFormatRaw: deflate compression with no header
		ZlibCompressorFormatRaw ZlibCompressorFormat = 2
		)

	
	func marshalZlibCompressorFormat(p uintptr) (interface{}, error) {
		return ZlibCompressorFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AppInfoCreateFlags flags used when creating a Info.
	type AppInfoCreateFlags int

	const (
			// AppInfoCreateFlagsNone: no flags.
		AppInfoCreateFlagsNone AppInfoCreateFlags = 0
			// AppInfoCreateFlagsNeedsTerminal: application opens in a terminal window.
		AppInfoCreateFlagsNeedsTerminal AppInfoCreateFlags = 1
			// AppInfoCreateFlagsSupportsUris: application supports URI arguments.
		AppInfoCreateFlagsSupportsUris AppInfoCreateFlags = 2
			// AppInfoCreateFlagsSupportsStartupNotification: application supports
	// startup notification. Since 2.26
		AppInfoCreateFlagsSupportsStartupNotification AppInfoCreateFlags = 4
		)

	
	func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
		return AppInfoCreateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ApplicationFlags flags used to define the behaviour of a #GApplication.
	type ApplicationFlags int

	const (
			// ApplicationFlagsFlagsNone: default
		ApplicationFlagsFlagsNone ApplicationFlags = 0
			// ApplicationFlagsIsService: run as a service. In this mode, registration
	// fails if the service is already running, and the application will
	// initially wait up to 10 seconds for an initial activation message to
	// arrive.
		ApplicationFlagsIsService ApplicationFlags = 1
			// ApplicationFlagsIsLauncher: don't try to become the primary instance.
		ApplicationFlagsIsLauncher ApplicationFlags = 2
			// ApplicationFlagsHandlesOpen: this application handles opening files (in
	// the primary instance). Note that this flag only affects the default
	// implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
		ApplicationFlagsHandlesOpen ApplicationFlags = 4
			// ApplicationFlagsHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
		ApplicationFlagsHandlesCommandLine ApplicationFlags = 8
			// ApplicationFlagsSendEnvironment: send the environment of the launching
	// process to the primary instance. Set this flag if your application is
	// expected to behave differently depending on certain environment
	// variables. For instance, an editor might be expected to use the
	// `GIT_COMMITTER_NAME` environment variable when editing a git commit
	// message. The environment is available to the #GApplication::command-line
	// signal handler, via g_application_command_line_getenv().
		ApplicationFlagsSendEnvironment ApplicationFlags = 16
			// ApplicationFlagsNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID is
	// given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
		ApplicationFlagsNonUnique ApplicationFlags = 32
			// ApplicationFlagsCanOverrideAppID: allow users to override the application
	// ID from the command line with `--gapplication-app-id`. Since: 2.48
		ApplicationFlagsCanOverrideAppID ApplicationFlags = 64
			// ApplicationFlagsAllowReplacement: allow another instance to take over the
	// bus name. Since: 2.60
		ApplicationFlagsAllowReplacement ApplicationFlags = 128
			// ApplicationFlagsReplace: take over from another instance. This flag is
	// usually set by passing `--gapplication-replace` on the commandline.
	// Since: 2.60
		ApplicationFlagsReplace ApplicationFlags = 256
		)

	
	func marshalApplicationFlags(p uintptr) (interface{}, error) {
		return ApplicationFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AskPasswordFlags PasswordFlags are used to request specific information from
// the user, or to notify the user of their choices in an authentication
// situation.
	type AskPasswordFlags int

	const (
			// AskPasswordFlagsNeedPassword: operation requires a password.
		AskPasswordFlagsNeedPassword AskPasswordFlags = 1
			// AskPasswordFlagsNeedUsername: operation requires a username.
		AskPasswordFlagsNeedUsername AskPasswordFlags = 2
			// AskPasswordFlagsNeedDomain: operation requires a domain.
		AskPasswordFlagsNeedDomain AskPasswordFlags = 4
			// AskPasswordFlagsSavingSupported: operation supports saving settings.
		AskPasswordFlagsSavingSupported AskPasswordFlags = 8
			// AskPasswordFlagsAnonymousSupported: operation supports anonymous users.
		AskPasswordFlagsAnonymousSupported AskPasswordFlags = 16
			// AskPasswordFlagsTcrypt: operation takes TCRYPT parameters (Since: 2.58)
		AskPasswordFlagsTcrypt AskPasswordFlags = 32
		)

	
	func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
		return AskPasswordFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// BusNameOwnerFlags flags used in g_bus_own_name().
	type BusNameOwnerFlags int

	const (
			// BusNameOwnerFlagsNone: no flags set.
		BusNameOwnerFlagsNone BusNameOwnerFlags = 0
			// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
		BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 1
			// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the
	// name from the other connection.
		BusNameOwnerFlagsReplace BusNameOwnerFlags = 2
			// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns the
	// name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54)
		BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 4
		)

	
	func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
		return BusNameOwnerFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// BusNameWatcherFlags flags used in g_bus_watch_name().
	type BusNameWatcherFlags int

	const (
			// BusNameWatcherFlagsNone: no flags set.
		BusNameWatcherFlagsNone BusNameWatcherFlags = 0
			// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
		BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 1
		)

	
	func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
		return BusNameWatcherFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ConverterFlags flags used when calling a g_converter_convert().
	type ConverterFlags int

	const (
			// ConverterFlagsNone: no flags.
		ConverterFlagsNone ConverterFlags = 0
			// ConverterFlagsInputAtEnd: at end of input data
		ConverterFlagsInputAtEnd ConverterFlags = 1
			// ConverterFlagsFlush: flush data
		ConverterFlagsFlush ConverterFlags = 2
		)

	
	func marshalConverterFlags(p uintptr) (interface{}, error) {
		return ConverterFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusCallFlags flags used in g_dbus_connection_call() and similar APIs.
	type DBusCallFlags int

	const (
			// DBusCallFlagsNone: no flags set.
		DBusCallFlagsNone DBusCallFlags = 0
			// DBusCallFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this method invocation.
		DBusCallFlagsNoAutoStart DBusCallFlags = 1
			// DBusCallFlagsAllowInteractiveAuthorization: the caller is prepared to
	// wait for interactive authorization. Since 2.46.
		DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 2
		)

	
	func marshalDBusCallFlags(p uintptr) (interface{}, error) {
		return DBusCallFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusCapabilityFlags capabilities negotiated with the remote peer.
	type DBusCapabilityFlags int

	const (
			// DBusCapabilityFlagsNone: no flags set.
		DBusCapabilityFlagsNone DBusCapabilityFlags = 0
			// DBusCapabilityFlagsUnixFdPassing: the connection supports exchanging UNIX
	// file descriptors with the remote peer.
		DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 1
		)

	
	func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
		return DBusCapabilityFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusConnectionFlags flags used when creating a new BusConnection.
	type DBusConnectionFlags int

	const (
			// DBusConnectionFlagsNone: no flags set.
		DBusConnectionFlagsNone DBusConnectionFlags = 0
			// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
		DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 1
			// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
		DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 2
			// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
		DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 4
			// DBusConnectionFlagsMessageBusConnection pass this flag if connecting to a
	// peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
		DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 8
			// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
		DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 16
			// DBusConnectionFlagsAuthenticationRequireSameUser: when authenticating as
	// a server, require the UID of the peer to be the same as the UID of the
	// server. (Since: 2.68)
		DBusConnectionFlagsAuthenticationRequireSameUser DBusConnectionFlags = 32
		)

	
	func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
		return DBusConnectionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusInterfaceSkeletonFlags flags describing the behavior of a
// BusInterfaceSkeleton instance.
	type DBusInterfaceSkeletonFlags int

	const (
			// DBusInterfaceSkeletonFlagsNone: no flags set.
		DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0
			// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
		DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 1
		)

	
	func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
		return DBusInterfaceSkeletonFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusMessageFlags: message flags used in BusMessage.
	type DBusMessageFlags int

	const (
			// DBusMessageFlagsNone: no flags set.
		DBusMessageFlagsNone DBusMessageFlags = 0
			// DBusMessageFlagsNoReplyExpected: a reply is not expected.
		DBusMessageFlagsNoReplyExpected DBusMessageFlags = 1
			// DBusMessageFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this message.
		DBusMessageFlagsNoAutoStart DBusMessageFlags = 2
			// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
		DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 4
		)

	
	func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
		return DBusMessageFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusObjectManagerClientFlags flags used when constructing a
// BusObjectManagerClient.
	type DBusObjectManagerClientFlags int

	const (
			// DBusObjectManagerClientFlagsNone: no flags set.
		DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0
			// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager is
	// for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
		DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 1
		)

	
	func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
		return DBusObjectManagerClientFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusPropertyInfoFlags flags describing the access control of a D-Bus
// property.
	type DBusPropertyInfoFlags int

	const (
			// DBusPropertyInfoFlagsNone: no flags set.
		DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0
			// DBusPropertyInfoFlagsReadable: property is readable.
		DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 1
			// DBusPropertyInfoFlagsWritable: property is writable.
		DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 2
		)

	
	func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
		return DBusPropertyInfoFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusProXYFlags flags used when constructing an instance of a BusProxy derived
// class.
	type DBusProXYFlags int

	const (
			// DBusProXYFlagsNone: no flags set.
		DBusProXYFlagsNone DBusProXYFlags = 0
			// DBusProXYFlagsDoNotLoadProperties: don't load properties.
		DBusProXYFlagsDoNotLoadProperties DBusProXYFlags = 1
			// DBusProXYFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
		DBusProXYFlagsDoNotConnectSignals DBusProXYFlags = 2
			// DBusProXYFlagsDoNotAutoStart: if the proxy is for a well-known name, do
	// not ask the bus to launch an owner during proxy initialization or a
	// method call. This flag is only meaningful in proxies for well-known
	// names.
		DBusProXYFlagsDoNotAutoStart DBusProXYFlags = 4
			// DBusProXYFlagsGetInvalidatedProperties: if set, the property value for
	// any __invalidated property__ will be (asynchronously) retrieved upon
	// receiving the `PropertiesChanged`
	// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
		DBusProXYFlagsGetInvalidatedProperties DBusProXYFlags = 8
			// DBusProXYFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call. This
	// flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
		DBusProXYFlagsDoNotAutoStartAtConstruction DBusProXYFlags = 16
		)

	
	func marshalDBusProXYFlags(p uintptr) (interface{}, error) {
		return DBusProXYFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusSendMessageFlags flags used when sending BusMessages on a BusConnection.
	type DBusSendMessageFlags int

	const (
			// DBusSendMessageFlagsNone: no flags set.
		DBusSendMessageFlagsNone DBusSendMessageFlags = 0
			// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
		DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 1
		)

	
	func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
		return DBusSendMessageFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusServerFlags flags used when creating a BusServer.
	type DBusServerFlags int

	const (
			// DBusServerFlagsNone: no flags set.
		DBusServerFlagsNone DBusServerFlags = 0
			// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
		DBusServerFlagsRunInThread DBusServerFlags = 1
			// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
		DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 2
			// DBusServerFlagsAuthenticationRequireSameUser: require the UID of the peer
	// to be the same as the UID of the server when authenticating. (Since:
	// 2.68)
		DBusServerFlagsAuthenticationRequireSameUser DBusServerFlags = 4
		)

	
	func marshalDBusServerFlags(p uintptr) (interface{}, error) {
		return DBusServerFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusSignalFlags flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
	type DBusSignalFlags int

	const (
			// DBusSignalFlagsNone: no flags set.
		DBusSignalFlagsNone DBusSignalFlags = 0
			// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
		DBusSignalFlagsNoMatchRule DBusSignalFlags = 1
			// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
		DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 2
			// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
		DBusSignalFlagsMatchArg0Path DBusSignalFlags = 4
		)

	
	func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
		return DBusSignalFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DBusSubtreeFlags flags passed to g_dbus_connection_register_subtree().
	type DBusSubtreeFlags int

	const (
			// DBusSubtreeFlagsNone: no flags set.
		DBusSubtreeFlagsNone DBusSubtreeFlags = 0
			// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
		DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 1
		)

	
	func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
		return DBusSubtreeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DriveStartFlags flags used when starting a drive.
	type DriveStartFlags int

	const (
			// DriveStartFlagsNone: no flags set.
		DriveStartFlagsNone DriveStartFlags = 0
		)

	
	func marshalDriveStartFlags(p uintptr) (interface{}, error) {
		return DriveStartFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileAttributeInfoFlags flags specifying the behaviour of an attribute.
	type FileAttributeInfoFlags int

	const (
			// FileAttributeInfoFlagsNone: no flags set.
		FileAttributeInfoFlagsNone FileAttributeInfoFlags = 0
			// FileAttributeInfoFlagsCopyWithFile: copy the attribute values when the
	// file is copied.
		FileAttributeInfoFlagsCopyWithFile FileAttributeInfoFlags = 1
			// FileAttributeInfoFlagsCopyWhenMoved: copy the attribute values when the
	// file is moved.
		FileAttributeInfoFlagsCopyWhenMoved FileAttributeInfoFlags = 2
		)

	
	func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
		return FileAttributeInfoFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileCopyFlags flags used when copying or moving files.
	type FileCopyFlags int

	const (
			// FileCopyFlagsNone: no flags set.
		FileCopyFlagsNone FileCopyFlags = 0
			// FileCopyFlagsOverwrite: overwrite any existing files
		FileCopyFlagsOverwrite FileCopyFlags = 1
			// FileCopyFlagsBackup: make a backup of any existing files.
		FileCopyFlagsBackup FileCopyFlags = 2
			// FileCopyFlagsNofollowSymlinks: don't follow symlinks.
		FileCopyFlagsNofollowSymlinks FileCopyFlags = 4
			// FileCopyFlagsAllMetadata: copy all file metadata instead of just default
	// set used for copy (see Info).
		FileCopyFlagsAllMetadata FileCopyFlags = 8
			// FileCopyFlagsNoFallbackForMove: don't use copy and delete fallback if
	// native move not supported.
		FileCopyFlagsNoFallbackForMove FileCopyFlags = 16
			// FileCopyFlagsTargetDefaultPerms leaves target file with default perms,
	// instead of setting the source file perms.
		FileCopyFlagsTargetDefaultPerms FileCopyFlags = 32
		)

	
	func marshalFileCopyFlags(p uintptr) (interface{}, error) {
		return FileCopyFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileCreateFlags flags used when an operation may create a file.
	type FileCreateFlags int

	const (
			// FileCreateFlagsNone: no flags set.
		FileCreateFlagsNone FileCreateFlags = 0
			// FileCreateFlagsPrivate: create a file that can only be accessed by the
	// current user.
		FileCreateFlagsPrivate FileCreateFlags = 1
			// FileCreateFlagsReplaceDestination: replace the destination as if it
	// didn't exist before. Don't try to keep any old permissions, replace
	// instead of following links. This is generally useful if you're doing a
	// "copy over" rather than a "save new version of" replace operation. You
	// can think of it as "unlink destination" before writing to it, although
	// the implementation may not be exactly like that. This flag can only be
	// used with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20
		FileCreateFlagsReplaceDestination FileCreateFlags = 2
		)

	
	func marshalFileCreateFlags(p uintptr) (interface{}, error) {
		return FileCreateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileMeasureFlags flags that can be used with g_file_measure_disk_usage().
	type FileMeasureFlags int

	const (
			// FileMeasureFlagsNone: no flags set.
		FileMeasureFlagsNone FileMeasureFlags = 0
			// FileMeasureFlagsReportAnyError: report any error encountered while
	// traversing the directory tree. Normally errors are only reported for the
	// toplevel file.
		FileMeasureFlagsReportAnyError FileMeasureFlags = 2
			// FileMeasureFlagsApparentSize: tally usage based on apparent file sizes.
	// Normally, the block-size is used, if available, as this is a more
	// accurate representation of disk space used. Compare with `du
	// --apparent-size`.
		FileMeasureFlagsApparentSize FileMeasureFlags = 4
			// FileMeasureFlagsNoXdev: do not cross mount point boundaries. Compare with
	// `du -x`.
		FileMeasureFlagsNoXdev FileMeasureFlags = 8
		)

	
	func marshalFileMeasureFlags(p uintptr) (interface{}, error) {
		return FileMeasureFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileMonitorFlags flags used to set what a Monitor will watch for.
	type FileMonitorFlags int

	const (
			// FileMonitorFlagsNone: no flags set.
		FileMonitorFlagsNone FileMonitorFlags = 0
			// FileMonitorFlagsWatchMounts: watch for mount events.
		FileMonitorFlagsWatchMounts FileMonitorFlags = 1
			// FileMonitorFlagsSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
		FileMonitorFlagsSendMoved FileMonitorFlags = 2
			// FileMonitorFlagsWatchHardLinks: watch for changes to the file made via
	// another hard link. Since 2.36.
		FileMonitorFlagsWatchHardLinks FileMonitorFlags = 4
			// FileMonitorFlagsWatchMoves: watch for rename operations on a monitored
	// directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
		FileMonitorFlagsWatchMoves FileMonitorFlags = 8
		)

	
	func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
		return FileMonitorFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileQueryInfoFlags flags used when querying a Info.
	type FileQueryInfoFlags int

	const (
			// FileQueryInfoFlagsNone: no flags set.
		FileQueryInfoFlagsNone FileQueryInfoFlags = 0
			// FileQueryInfoFlagsNofollowSymlinks: don't follow symlinks.
		FileQueryInfoFlagsNofollowSymlinks FileQueryInfoFlags = 1
		)

	
	func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
		return FileQueryInfoFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IOStreamSpliceFlags gIOStreamSpliceFlags determine how streams should be
// spliced.
	type IOStreamSpliceFlags int

	const (
			// IOStreamSpliceFlagsNone: do not close either stream.
		IOStreamSpliceFlagsNone IOStreamSpliceFlags = 0
			// IOStreamSpliceFlagsCloseStream1: close the first stream after the splice.
		IOStreamSpliceFlagsCloseStream1 IOStreamSpliceFlags = 1
			// IOStreamSpliceFlagsCloseStream2: close the second stream after the
	// splice.
		IOStreamSpliceFlagsCloseStream2 IOStreamSpliceFlags = 2
			// IOStreamSpliceFlagsWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
		IOStreamSpliceFlagsWaitForBoth IOStreamSpliceFlags = 4
		)

	
	func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
		return IOStreamSpliceFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// MountMountFlags flags used when mounting a mount.
	type MountMountFlags int

	const (
			// MountMountFlagsNone: no flags set.
		MountMountFlagsNone MountMountFlags = 0
		)

	
	func marshalMountMountFlags(p uintptr) (interface{}, error) {
		return MountMountFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// MountUnmountFlags flags used when an unmounting a mount.
	type MountUnmountFlags int

	const (
			// MountUnmountFlagsNone: no flags set.
		MountUnmountFlagsNone MountUnmountFlags = 0
			// MountUnmountFlagsForce: unmount even if there are outstanding file
	// operations on the mount.
		MountUnmountFlagsForce MountUnmountFlags = 1
		)

	
	func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
		return MountUnmountFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// OutputStreamSpliceFlags gOutputStreamSpliceFlags determine how streams should
// be spliced.
	type OutputStreamSpliceFlags int

	const (
			// OutputStreamSpliceFlagsNone: do not close either stream.
		OutputStreamSpliceFlagsNone OutputStreamSpliceFlags = 0
			// OutputStreamSpliceFlagsCloseSource: close the source stream after the
	// splice.
		OutputStreamSpliceFlagsCloseSource OutputStreamSpliceFlags = 1
			// OutputStreamSpliceFlagsCloseTarget: close the target stream after the
	// splice.
		OutputStreamSpliceFlagsCloseTarget OutputStreamSpliceFlags = 2
		)

	
	func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
		return OutputStreamSpliceFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ResolverNameLookupFlags flags to modify lookup behavior.
	type ResolverNameLookupFlags int

	const (
			// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name())
		ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0
			// ResolverNameLookupFlagsIPv4Only: only resolve ipv4 addresses
		ResolverNameLookupFlagsIPv4Only ResolverNameLookupFlags = 1
			// ResolverNameLookupFlagsIPv6Only: only resolve ipv6 addresses
		ResolverNameLookupFlagsIPv6Only ResolverNameLookupFlags = 2
		)

	
	func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
		return ResolverNameLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ResourceFlags gResourceFlags give information about a particular file inside
// a resource bundle.
	type ResourceFlags int

	const (
			// ResourceFlagsNone: no flags set.
		ResourceFlagsNone ResourceFlags = 0
			// ResourceFlagsCompressed: the file is compressed.
		ResourceFlagsCompressed ResourceFlags = 1
		)

	
	func marshalResourceFlags(p uintptr) (interface{}, error) {
		return ResourceFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ResourceLookupFlags gResourceLookupFlags determine how resource path lookups
// are handled.
	type ResourceLookupFlags int

	const (
			// ResourceLookupFlagsNone: no flags set.
		ResourceLookupFlagsNone ResourceLookupFlags = 0
		)

	
	func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
		return ResourceLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SettingsBindFlags flags used when creating a binding. These flags determine
// in which direction the binding works. The default is to synchronize in both
// directions.
	type SettingsBindFlags int

	const (
			// SettingsBindFlagsDefault: equivalent to
	// `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
		SettingsBindFlagsDefault SettingsBindFlags = 0
			// SettingsBindFlagsGet: update the #GObject property when the setting
	// changes. It is an error to use this flag if the property is not writable.
		SettingsBindFlagsGet SettingsBindFlags = 1
			// SettingsBindFlagsSet: update the setting when the #GObject property
	// changes. It is an error to use this flag if the property is not readable.
		SettingsBindFlagsSet SettingsBindFlags = 2
			// SettingsBindFlagsNoSensitivity: do not try to bind a "sensitivity"
	// property to the writability of the setting
		SettingsBindFlagsNoSensitivity SettingsBindFlags = 4
			// SettingsBindFlagsGetNoChanges: when set in addition to SETTINGS_BIND_GET,
	// set the #GObject property value initially from the setting, but do not
	// listen for changes of the setting
		SettingsBindFlagsGetNoChanges SettingsBindFlags = 8
			// SettingsBindFlagsInvertBoolean: when passed to g_settings_bind(), uses a
	// pair of mapping functions that invert the boolean value when mapping
	// between the setting and the property. The setting and property must both
	// be booleans. You cannot pass this flag to g_settings_bind_with_mapping().
		SettingsBindFlagsInvertBoolean SettingsBindFlags = 16
		)

	
	func marshalSettingsBindFlags(p uintptr) (interface{}, error) {
		return SettingsBindFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SocketMsgFlags flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
	type SocketMsgFlags int

	const (
			// SocketMsgFlagsNone: no flags.
		SocketMsgFlagsNone SocketMsgFlags = 0
			// SocketMsgFlagsOob: request to send/receive out of band data.
		SocketMsgFlagsOob SocketMsgFlags = 1
			// SocketMsgFlagsPeek: read data from the socket without removing it from
	// the queue.
		SocketMsgFlagsPeek SocketMsgFlags = 2
			// SocketMsgFlagsDontroute: don't use a gateway to send out the packet, only
	// send to hosts on directly connected networks.
		SocketMsgFlagsDontroute SocketMsgFlags = 4
		)

	
	func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
		return SocketMsgFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SubprocessFlags flags to define the behaviour of a #GSubprocess.
// 
// Note that the default for stdin is to redirect from `/dev/null`. For stdout
// and stderr the default are for them to inherit the corresponding descriptor
// from the calling process.
// 
// Note that it is a programmer error to mix 'incompatible' flags. For example,
// you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
	type SubprocessFlags int

	const (
			// SubprocessFlagsNone: no flags.
		SubprocessFlagsNone SubprocessFlags = 0
			// SubprocessFlagsStdinPipe: create a pipe for the stdin of the spawned
	// process that can be accessed with g_subprocess_get_stdin_pipe().
		SubprocessFlagsStdinPipe SubprocessFlags = 1
			// SubprocessFlagsStdinInherit: stdin is inherited from the calling process.
		SubprocessFlagsStdinInherit SubprocessFlags = 2
			// SubprocessFlagsStdoutPipe: create a pipe for the stdout of the spawned
	// process that can be accessed with g_subprocess_get_stdout_pipe().
		SubprocessFlagsStdoutPipe SubprocessFlags = 4
			// SubprocessFlagsStdoutSilence: silence the stdout of the spawned process
	// (ie: redirect to `/dev/null`).
		SubprocessFlagsStdoutSilence SubprocessFlags = 8
			// SubprocessFlagsStderrPipe: create a pipe for the stderr of the spawned
	// process that can be accessed with g_subprocess_get_stderr_pipe().
		SubprocessFlagsStderrPipe SubprocessFlags = 16
			// SubprocessFlagsStderrSilence: silence the stderr of the spawned process
	// (ie: redirect to `/dev/null`).
		SubprocessFlagsStderrSilence SubprocessFlags = 32
			// SubprocessFlagsStderrMerge: merge the stderr of the spawned process with
	// whatever the stdout happens to be. This is a good way of directing both
	// streams to a common log file, for example.
		SubprocessFlagsStderrMerge SubprocessFlags = 64
			// SubprocessFlagsInheritFds: spawned processes will inherit the file
	// descriptors of their parent, unless those descriptors have been
	// explicitly marked as close-on-exec. This flag has no effect over the
	// "standard" file descriptors (stdin, stdout, stderr).
		SubprocessFlagsInheritFds SubprocessFlags = 128
		)

	
	func marshalSubprocessFlags(p uintptr) (interface{}, error) {
		return SubprocessFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TestDBusFlags flags to define future DBus behaviour.
	type TestDBusFlags int

	const (
			// TestDBusFlagsNone: no flags.
		TestDBusFlagsNone TestDBusFlags = 0
		)

	
	func marshalTestDBusFlags(p uintptr) (interface{}, error) {
		return TestDBusFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSCertificateFlags: a set of flags describing TLS certification validation.
// This can be used to set which validation steps to perform (eg, with
// g_tls_client_connection_set_validation_flags()), or to describe why a
// particular certificate was rejected (eg, in Connection::accept-certificate).
	type TLSCertificateFlags int

	const (
			// TLSCertificateFlagsUnknownCa: the signing certificate authority is not
	// known.
		TLSCertificateFlagsUnknownCa TLSCertificateFlags = 1
			// TLSCertificateFlagsBadIdentity: the certificate does not match the
	// expected identity of the site that it was retrieved from.
		TLSCertificateFlagsBadIdentity TLSCertificateFlags = 2
			// TLSCertificateFlagsNotActivated: the certificate's activation time is
	// still in the future
		TLSCertificateFlagsNotActivated TLSCertificateFlags = 4
			// TLSCertificateFlagsExpired: the certificate has expired
		TLSCertificateFlagsExpired TLSCertificateFlags = 8
			// TLSCertificateFlagsRevoked: the certificate has been revoked according to
	// the Connection's certificate revocation list.
		TLSCertificateFlagsRevoked TLSCertificateFlags = 16
			// TLSCertificateFlagsInsecure: the certificate's algorithm is considered
	// insecure.
		TLSCertificateFlagsInsecure TLSCertificateFlags = 32
			// TLSCertificateFlagsGenericError: some other error occurred validating the
	// certificate
		TLSCertificateFlagsGenericError TLSCertificateFlags = 64
			// TLSCertificateFlagsValidateAll: the combination of all of the above flags
		TLSCertificateFlagsValidateAll TLSCertificateFlags = 127
		)

	
	func marshalTLSCertificateFlags(p uintptr) (interface{}, error) {
		return TLSCertificateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSDatabaseVerifyFlags flags for g_tls_database_verify_chain().
	type TLSDatabaseVerifyFlags int

	const (
			// TLSDatabaseVerifyFlagsNone: no verification flags
		TLSDatabaseVerifyFlagsNone TLSDatabaseVerifyFlags = 0
		)

	
	func marshalTLSDatabaseVerifyFlags(p uintptr) (interface{}, error) {
		return TLSDatabaseVerifyFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TLSPasswordFlags various flags for the password.
	type TLSPasswordFlags int

	const (
			// TLSPasswordFlagsNone: no flags
		TLSPasswordFlagsNone TLSPasswordFlags = 0
			// TLSPasswordFlagsRetry: the password was wrong, and the user should retry.
		TLSPasswordFlagsRetry TLSPasswordFlags = 2
			// TLSPasswordFlagsManyTries: hint to the user that the password has been
	// wrong many times, and the user may not have many chances left.
		TLSPasswordFlagsManyTries TLSPasswordFlags = 4
			// TLSPasswordFlagsFinalTry: hint to the user that this is the last try to
	// get this password right.
		TLSPasswordFlagsFinalTry TLSPasswordFlags = 8
		)

	
	func marshalTLSPasswordFlags(p uintptr) (interface{}, error) {
		return TLSPasswordFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	// BusGetFinish finishes an operation started with g_bus_get().
// 
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
// 
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
	func BusGetFinish(res AsyncResult) (DBusConnection, error) {
var _arg1 *C.GAsyncResult // out
var _cret *C.GDBusConnection // in
var _cerr *C.GError // in

_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_bus_get_finish(_arg1, &_cerr)


var _dBusConnection DBusConnection // out
var _goerr error // out

_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusConnection, _goerr
}


	// BusGetSync: synchronously connects to the message bus specified by @bus_type.
// Note that the returned object may shared with other callers, e.g. if two
// separate parts of a process calls this function with the same @bus_type, they
// will share the same object.
// 
// This is a synchronous failable function. See g_bus_get() and
// g_bus_get_finish() for the asynchronous version.
// 
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
// 
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
	func BusGetSync(busType BusType, cancellable CancellableClass) (DBusConnection, error) {
var _arg1 C.GBusType // out
var _arg2 *C.GCancellable // out
var _cret *C.GDBusConnection // in
var _cerr *C.GError // in

_arg1 = (C.GBusType)(busType)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_bus_get_sync(_arg1, _arg2, &_cerr)


var _dBusConnection DBusConnection // out
var _goerr error // out

_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusConnection, _goerr
}


	// BusUnownName stops owning a name.
// 
// Note that there may still be D-Bus traffic to process (relating to owning and
// unowning the name) in the current thread-default Context after this function
// has returned. You should continue to iterate the Context until the Notify
// function passed to g_bus_own_name() is called, in order to avoid memory leaks
// through callbacks queued on the Context after its stopped being iterated.
	func BusUnownName(ownerId uint)  {
var _arg1 C.guint // out

_arg1 = (C.guint)(ownerId)

C.g_bus_unown_name(_arg1)
}


	// BusUnwatchName stops watching a name.
// 
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_bus_watch_name() is called, in order to avoid
// memory leaks through callbacks queued on the Context after its stopped being
// iterated.
	func BusUnwatchName(watcherId uint)  {
var _arg1 C.guint // out

_arg1 = (C.guint)(watcherId)

C.g_bus_unwatch_name(_arg1)
}


	// ContentTypeCanBeExecutable checks if a content type can be executable. Note
// that for instance things like text files can be executables (i.e. scripts and
// batch files).
	func ContentTypeCanBeExecutable(typ string) bool {
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_content_type_can_be_executable(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// ContentTypeEquals compares two content types for equality.
	func ContentTypeEquals(type1 string, type2 string) bool {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(type1))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(type2))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_content_type_equals(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// ContentTypeFromMIMEType tries to find a content type based on the mime type
// name.
	func ContentTypeFromMIMEType(mimeType string) string {
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg1 = (*C.gchar)(C.CString(mimeType))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_content_type_from_mime_type(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// ContentTypeGetDescription gets the human readable description of the content
// type.
	func ContentTypeGetDescription(typ string) string {
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg1 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_content_type_get_description(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// ContentTypeGetGenericIconName gets the generic icon name for a content type.
// 
// See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on the generic icon name.
	func ContentTypeGetGenericIconName(typ string) string {
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg1 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_content_type_get_generic_icon_name(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// ContentTypeGetIcon gets the icon for a content type.
	func ContentTypeGetIcon(typ string) Icon {
var _arg1 *C.gchar // out
var _cret *C.GIcon // in

_arg1 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_content_type_get_icon(_arg1)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}


	// ContentTypeGetMIMEDirs: get the list of directories which MIME data is loaded
// from. See g_content_type_set_mime_dirs() for details.
	func ContentTypeGetMIMEDirs() []string {
var _cret **C.gchar

_cret = C.g_content_type_get_mime_dirs()


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}


	// ContentTypeGetMIMEType gets the mime type for the content type, if one is
// registered.
	func ContentTypeGetMIMEType(typ string) string {
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg1 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_content_type_get_mime_type(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// ContentTypeGetSymbolicIcon gets the symbolic icon for a content type.
	func ContentTypeGetSymbolicIcon(typ string) Icon {
var _arg1 *C.gchar // out
var _cret *C.GIcon // in

_arg1 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_content_type_get_symbolic_icon(_arg1)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}


	// ContentTypeGuess guesses the content type based on example data. If the
// function is uncertain, @result_uncertain will be set to true. Either
// @filename or @data may be nil, in which case the guess will be based solely
// on the other argument.
	func ContentTypeGuess(filename string, data []byte) (bool, string) {
var _arg1 *C.gchar // out
var _arg2 *C.guchar
var _arg3 C.gsize
var _arg4 C.gboolean // in
var _cret *C.gchar // in

_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))
_arg3 = C.gsize(len(data))
_arg2 = (*C.guchar)(unsafe.Pointer(&data[0]))

_cret = C.g_content_type_guess(_arg1, _arg2, _arg3, &_arg4)


var _resultUncertain bool // out
var _utf8 string // out

if _arg4 { _resultUncertain = true }
_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _resultUncertain, _utf8
}


	// ContentTypeGuessForTree tries to guess the type of the tree with root @root,
// by looking at the files it contains. The result is an array of content types,
// with the best guess coming first.
// 
// The types returned all have the form x-content/foo, e.g. x-content/audio-cdda
// (for audio CDs) or x-content/image-dcf (for a camera memory card). See the
// shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
// 
// This function is useful in the implementation of
// g_mount_guess_content_type().
	func ContentTypeGuessForTree(root File) []string {
var _arg1 *C.GFile // out
var _cret **C.gchar

_arg1 = (*C.GFile)(unsafe.Pointer(root.Native()))

_cret = C.g_content_type_guess_for_tree(_arg1)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}


	// ContentTypeIsA determines if @type is a subset of @supertype.
	func ContentTypeIsA(typ string, supertype string) bool {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(supertype))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_content_type_is_a(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// ContentTypeIsMIMEType determines if @type is a subset of @mime_type.
// Convenience wrapper around g_content_type_is_a().
	func ContentTypeIsMIMEType(typ string, mimeType string) bool {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(mimeType))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_content_type_is_mime_type(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// ContentTypeIsUnknown checks if the content type is the generic "unknown"
// type. On UNIX this is the "application/octet-stream" mimetype, while on win32
// it is "*" and on OSX it is a dynamic type or octet-stream.
	func ContentTypeIsUnknown(typ string) bool {
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_content_type_is_unknown(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// ContentTypeSetMIMEDirs: set the list of directories used by GIO to load the
// MIME database. If @dirs is nil, the directories used are the default:
// 
//    - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
//    - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
// 
// This function is intended to be used when writing tests that depend on
// information stored in the MIME database, in order to control the data.
// 
// Typically, in case your tests use G_TEST_OPTION_ISOLATE_DIRS, but they depend
// on the systems MIME database, you should call this function with @dirs set
// to nil before calling g_test_init(), for instance:
// 
//      // Load MIME data from the system
//      g_content_type_set_mime_dirs (NULL);
//      // Isolate the environment
//      g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
// 
//      
// 
//      return g_test_run ();
	func ContentTypeSetMIMEDirs(dirs []string)  {
var _arg1 **C.gchar

_arg1 = (**C.gchar)(C.malloc(C.ulong(len(dirs)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(dirs))
for i := range dirs {
out[i] = (*C.gchar)(C.CString(dirs[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.g_content_type_set_mime_dirs(_arg1)
}


	// DBusAddressEscapeValue: escape @string so it can appear in a D-Bus address as
// the value part of a key-value pair.
// 
// For instance, if @string is `/run/bus-for-:0`, this function would return
// `/run/bus-for-3A0`, which could be used in a D-Bus address like
// `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-3A0`.
	func DBusAddressEscapeValue(_string string) string {
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_address_escape_value(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// DBusAddressGetForBusSync: synchronously looks up the D-Bus address for the
// well-known message bus instance specified by @bus_type. This may involve
// using various platform specific mechanisms.
// 
// The returned address will be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
	func DBusAddressGetForBusSync(busType BusType, cancellable CancellableClass) (string, error) {
var _arg1 C.GBusType // out
var _arg2 *C.GCancellable // out
var _cret *C.gchar // in
var _cerr *C.GError // in

_arg1 = (C.GBusType)(busType)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_address_get_for_bus_sync(_arg1, _arg2, &_cerr)


var _utf8 string // out
var _goerr error // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8, _goerr
}


	// DBusAddressGetStreamFinish finishes an operation started with
// g_dbus_address_get_stream().
// 
// A server is not required to set a GUID, so @out_guid may be set to nil even
// on success.
	func DBusAddressGetStreamFinish(res AsyncResult) (string, IOStream, error) {
var _arg1 *C.GAsyncResult // out
var _arg2 *C.gchar // in
var _cret *C.GIOStream // in
var _cerr *C.GError // in

_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_address_get_stream_finish(_arg1, &_arg2, &_cerr)


var _outGuid string // out
var _ioStream IOStream // out
var _goerr error // out

_outGuid = C.GoString(_arg2)
defer C.free(unsafe.Pointer(_arg2))
_ioStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _outGuid, _ioStream, _goerr
}


	// DBusAddressGetStreamSync: synchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
// 
// A server is not required to set a GUID, so @out_guid may be set to nil even
// on success.
// 
// This is a synchronous failable function. See g_dbus_address_get_stream() for
// the asynchronous version.
	func DBusAddressGetStreamSync(address string, cancellable CancellableClass) (string, IOStream, error) {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // in
var _arg3 *C.GCancellable // out
var _cret *C.GIOStream // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(address))
defer C.free(unsafe.Pointer(_arg1))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_address_get_stream_sync(_arg1, &_arg2, _arg3, &_cerr)


var _outGuid string // out
var _ioStream IOStream // out
var _goerr error // out

_outGuid = C.GoString(_arg2)
defer C.free(unsafe.Pointer(_arg2))
_ioStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _outGuid, _ioStream, _goerr
}


	// DBusEscapeObjectPath: this is a language binding friendly version of
// g_dbus_escape_object_path_bytestring().
	func DBusEscapeObjectPath(s string) string {
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg1 = (*C.gchar)(C.CString(s))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_escape_object_path(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// DBusEscapeObjectPathBytestring escapes @bytes for use in a D-Bus object path
// component. @bytes is an array of zero or more nonzero bytes in an unspecified
// encoding, followed by a single zero byte.
// 
// The escaping method consists of replacing all non-alphanumeric characters
// (see g_ascii_isalnum()) with their hexadecimal value preceded by an
// underscore (`_`). For example: `foo.bar.baz` will become `foo_2ebar_2ebaz`.
// 
// This method is appropriate to use when the input is nearly a valid object
// path component but is not when your input is far from being a valid object
// path component. Other escaping algorithms are also valid to use with D-Bus
// object paths.
// 
// This can be reversed with g_dbus_unescape_object_path().
	func DBusEscapeObjectPathBytestring(bytes []byte) string {
var _arg1 *C.guint8
var _cret *C.gchar // in

{
var zero byte
bytes = append(bytes, zero)
}
_arg1 = (*C.guint8)(unsafe.Pointer(&bytes[0]))

_cret = C.g_dbus_escape_object_path_bytestring(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// DBusGenerateGuid: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
// 
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
	func DBusGenerateGuid() string {
var _cret *C.gchar // in

_cret = C.g_dbus_generate_guid()


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// DBusGValueToGVariant converts a #GValue to a #GVariant of the type indicated
// by the @type parameter.
// 
// The conversion is using the following rules:
// 
// - TYPE_STRING: 's', 'o', 'g' or 'ay' - TYPE_STRV: 'as', 'ao' or 'aay' -
// TYPE_BOOLEAN: 'b' - TYPE_UCHAR: 'y' - TYPE_INT: 'i', 'n' - TYPE_UINT: 'u',
// 'q' - TYPE_INT64 'x' - TYPE_UINT64: 't' - TYPE_DOUBLE: 'd' - TYPE_VARIANT:
// Any Type
// 
// This can fail if e.g. @gvalue is of type TYPE_STRING and @type is
// ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType (including
// e.g. TYPE_OBJECT and TYPE_BOXED derived-types) not in the table above.
// 
// Note that if @gvalue is of type TYPE_VARIANT and its value is nil, the empty
// #GVariant instance (never nil) for @type is returned (e.g. 0 for scalar
// types, the empty string for string types, '/' for object path types, the
// empty array for any array type and so on).
// 
// See the g_dbus_gvariant_to_gvalue() function for how to convert a #GVariant
// to a #GValue.
	func DBusGValueToGVariant(gvalue **externglib.Value, typ *glib.VariantType) *glib.Variant {
var _arg1 *C.GValue // out
var _arg2 *C.GVariantType // out
var _cret *C.GVariant // in

_arg1 = (*C.GValue)(gvalue.GValue)
_arg2 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

_cret = C.g_dbus_gvalue_to_gvariant(_arg1, _arg2)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}


	// DBusGVariantToGValue converts a #GVariant to a #GValue. If @value is
// floating, it is consumed.
// 
// The rules specified in the g_dbus_gvalue_to_gvariant() function are used -
// this function is essentially its reverse form. So, a #GVariant containing any
// basic or string array type will be converted to a #GValue containing a basic
// value or string array. Any other #GVariant (handle, variant, tuple, dict
// entry) will be converted to a #GValue containing that #GVariant.
// 
// The conversion never fails - a valid #GValue is always returned in
// @out_gvalue.
	func DBusGVariantToGValue(value *glib.Variant) *externglib.Value {
var _arg1 *C.GVariant // out
var _arg2 C.GValue // in

_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

C.g_dbus_gvariant_to_gvalue(_arg1, &_arg2)

var _outGvalue *externglib.Value // out

_outGvalue = externglib.ValueFromNative(unsafe.Pointer(_arg2))

return _outGvalue
}


	// DBusIsAddress checks if @string is a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
// 
// This doesn't check if @string is actually supported by BusServer or
// BusConnection - use g_dbus_is_supported_address() to do more checks.
	func DBusIsAddress(_string string) bool {
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_is_address(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// DBusIsGuid checks if @string is a D-Bus GUID.
// 
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
	func DBusIsGuid(_string string) bool {
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_is_guid(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// DBusIsInterfaceName checks if @string is a valid D-Bus interface name.
	func DBusIsInterfaceName(_string string) bool {
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_is_interface_name(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// DBusIsMemberName checks if @string is a valid D-Bus member (e.g. signal or
// method) name.
	func DBusIsMemberName(_string string) bool {
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_is_member_name(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// DBusIsName checks if @string is a valid D-Bus bus name (either unique or
// well-known).
	func DBusIsName(_string string) bool {
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_is_name(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// DBusIsSupportedAddress: like g_dbus_is_address() but also checks if the
// library supports the transports in @string and that key/value pairs for each
// transport are valid. See the specification of the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
	func DBusIsSupportedAddress(_string string) error {
var _arg1 *C.gchar // out
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_is_supported_address(_arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}


	// DBusIsUniqueName checks if @string is a valid D-Bus unique bus name.
	func DBusIsUniqueName(_string string) bool {
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_is_unique_name(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// DBusUnescapeObjectPath unescapes an string that was previously escaped with
// g_dbus_escape_object_path(). If the string is in a format that could not have
// been returned by g_dbus_escape_object_path(), this function returns nil.
// 
// Encoding alphanumeric characters which do not need to be encoded is not
// allowed (e.g `_63` is not valid, the string should contain `c` instead).
	func DBusUnescapeObjectPath(s string) []byte {
var _arg1 *C.gchar // out
var _cret *C.guint8

_arg1 = (*C.gchar)(C.CString(s))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_unescape_object_path(_arg1)


var _guint8s []byte

{
var i int
var z C.guint8
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_guint8s = make([]byte, i)
for i := range src {
_guint8s[i] = (byte)(src[i])
}
}

return _guint8s
}


	// IOErrorFromErrno converts errno.h error codes into GIO error codes. The
// fallback value G_IO_ERROR_FAILED is returned for error codes not currently
// handled (but note that future GLib releases may return a more specific value
// instead).
// 
// As errno is global and may be modified by intermediate function calls, you
// should save its value as soon as the call which sets it
	func IOErrorFromErrno(errNo int) IOErrorEnum {
var _arg1 C.gint // out
var _cret C.GIOErrorEnum // in

_arg1 = (C.gint)(errNo)

_cret = C.g_io_error_from_errno(_arg1)


var _ioErrorEnum IOErrorEnum // out

_ioErrorEnum = IOErrorEnum(_cret)

return _ioErrorEnum
}


	// IOModulesScanAllInDirectory scans all the modules in the specified directory,
// ensuring that any extension point implemented by a module is registered.
// 
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
// 
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
	func IOModulesScanAllInDirectory(dirname string)  {
var _arg1 *C.char // out

_arg1 = (*C.char)(C.CString(dirname))
defer C.free(unsafe.Pointer(_arg1))

C.g_io_modules_scan_all_in_directory(_arg1)
}


	// IOModulesScanAllInDirectoryWithScope scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
// 
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
// 
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
	func IOModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope)  {
var _arg1 *C.gchar // out
var _arg2 *C.GIOModuleScope // out

_arg1 = (*C.gchar)(C.CString(dirname))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GIOModuleScope)(unsafe.Pointer(scope.Native()))

C.g_io_modules_scan_all_in_directory_with_scope(_arg1, _arg2)
}


	// IOSchedulerCancelAllJobs cancels all cancellable I/O jobs.
// 
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
	func IOSchedulerCancelAllJobs()  {
C.g_io_scheduler_cancel_all_jobs()
}


	// PollableStreamRead tries to read from @stream, as with g_input_stream_read()
// (if @blocking is true) or g_pollable_input_stream_read_nonblocking() (if
// @blocking is false). This can be used to more easily share code between
// blocking and non-blocking implementations of a method.
// 
// If @blocking is false, then @stream must be a InputStream for which
// g_pollable_input_stream_can_poll() returns true, or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// InputStream.
	func PollableStreamRead(stream InputStreamClass, buffer []byte, blocking bool, cancellable CancellableClass) (int, error) {
var _arg1 *C.GInputStream // out
var _arg2 *C.void
var _arg3 C.gsize
var _arg4 C.gboolean // out
var _arg5 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
_arg3 = C.gsize(len(buffer))
_arg2 = (*C.void)(unsafe.Pointer(&buffer[0]))
if blocking { _arg4 = C.TRUE }
_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_pollable_stream_read(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}


	// PollableStreamWrite tries to write to @stream, as with
// g_output_stream_write() (if @blocking is true) or
// g_pollable_output_stream_write_nonblocking() (if @blocking is false). This
// can be used to more easily share code between blocking and non-blocking
// implementations of a method.
// 
// If @blocking is false, then @stream must be a OutputStream for which
// g_pollable_output_stream_can_poll() returns true or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// OutputStream.
	func PollableStreamWrite(stream OutputStreamClass, buffer []byte, blocking bool, cancellable CancellableClass) (int, error) {
var _arg1 *C.GOutputStream // out
var _arg2 *C.void
var _arg3 C.gsize
var _arg4 C.gboolean // out
var _arg5 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
_arg3 = C.gsize(len(buffer))
_arg2 = (*C.void)(unsafe.Pointer(&buffer[0]))
if blocking { _arg4 = C.TRUE }
_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_pollable_stream_write(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}


	// PollableStreamWriteAll tries to write @count bytes to @stream, as with
// g_output_stream_write_all(), but using g_pollable_stream_write() rather than
// g_output_stream_write().
// 
// On a successful write of @count bytes, true is returned, and @bytes_written
// is set to @count.
// 
// If there is an error during the operation (including G_IO_ERROR_WOULD_BLOCK
// in the non-blocking case), false is returned and @error is set to indicate
// the error status, @bytes_written is updated to contain the number of bytes
// written into the stream before the error occurred.
// 
// As with g_pollable_stream_write(), if @blocking is false, then @stream must
// be a OutputStream for which g_pollable_output_stream_can_poll() returns true
// or else the behavior is undefined. If @blocking is true, then @stream does
// not need to be a OutputStream.
	func PollableStreamWriteAll(stream OutputStreamClass, buffer []byte, blocking bool, cancellable CancellableClass) (uint, error) {
var _arg1 *C.GOutputStream // out
var _arg2 *C.void
var _arg3 C.gsize
var _arg4 C.gboolean // out
var _arg5 C.gsize // in
var _arg6 *C.GCancellable // out
var _cerr *C.GError // in

_arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
_arg3 = C.gsize(len(buffer))
_arg2 = (*C.void)(unsafe.Pointer(&buffer[0]))
if blocking { _arg4 = C.TRUE }
_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_pollable_stream_write_all(_arg1, _arg2, _arg3, _arg4, &_arg5, _arg6, &_cerr)

var _bytesWritten uint // out
var _goerr error // out

_bytesWritten = (uint)(_arg5)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesWritten, _goerr
}


	// ResourcesEnumerateChildren returns all the names of children at the specified
// @path in the set of globally registered resources. The return result is a nil
// terminated list of strings which should be released with g_strfreev().
// 
// @lookup_flags controls the behaviour of the lookup.
	func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
var _arg1 *C.char // out
var _arg2 C.GResourceLookupFlags // out
var _cret **C.char
var _cerr *C.GError // in

_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GResourceLookupFlags)(lookupFlags)

_cret = C.g_resources_enumerate_children(_arg1, _arg2, &_cerr)


var _utf8s []string
var _goerr error // out

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8s, _goerr
}


	// ResourcesGetInfo looks for a file at the specified @path in the set of
// globally registered resources and if found returns information about it.
// 
// @lookup_flags controls the behaviour of the lookup.
	func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (uint, uint32, error) {
var _arg1 *C.char // out
var _arg2 C.GResourceLookupFlags // out
var _arg3 C.gsize // in
var _arg4 C.guint32 // in
var _cerr *C.GError // in

_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GResourceLookupFlags)(lookupFlags)

C.g_resources_get_info(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

var _size uint // out
var _flags uint32 // out
var _goerr error // out

_size = (uint)(_arg3)
_flags = (uint32)(_arg4)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _size, _flags, _goerr
}


	// ResourcesOpenStream looks for a file at the specified @path in the set of
// globally registered resources and returns a Stream that lets you read the
// data.
// 
// @lookup_flags controls the behaviour of the lookup.
	func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) (InputStream, error) {
var _arg1 *C.char // out
var _arg2 C.GResourceLookupFlags // out
var _cret *C.GInputStream // in
var _cerr *C.GError // in

_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GResourceLookupFlags)(lookupFlags)

_cret = C.g_resources_open_stream(_arg1, _arg2, &_cerr)


var _inputStream InputStream // out
var _goerr error // out

_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _inputStream, _goerr
}


	// ResourcesRegister registers the resource with the process-global set of
// resources. Once a resource is registered the files in it can be accessed with
// the global resource lookup functions like g_resources_lookup_data().
	func ResourcesRegister(resource *Resource)  {
var _arg1 *C.GResource // out

_arg1 = (*C.GResource)(unsafe.Pointer(resource.Native()))

C.g_resources_register(_arg1)
}


	// ResourcesUnregister unregisters the resource from the process-global set of
// resources.
	func ResourcesUnregister(resource *Resource)  {
var _arg1 *C.GResource // out

_arg1 = (*C.GResource)(unsafe.Pointer(resource.Native()))

C.g_resources_unregister(_arg1)
}


	// UnixIsMountPathSystemInternal determines if @mount_path is considered an
// implementation of the OS. This is primarily used for hiding mountable and
// mounted volumes that only are used in the OS and has little to no relevance
// to the casual user.
	func UnixIsMountPathSystemInternal(mountPath string) bool {
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg1 = (*C.char)(C.CString(mountPath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_unix_is_mount_path_system_internal(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// UnixIsSystemDevicePath determines if @device_path is considered a block
// device path which is only used in implementation of the OS. This is primarily
// used for hiding mounted volumes that are intended as APIs for programs to
// read, and system administrators at a shell; rather than something that
// should, for example, appear in a GUI. For example, the Linux `/proc`
// filesystem.
// 
// The list of device paths considered system ones may change over time.
	func UnixIsSystemDevicePath(devicePath string) bool {
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg1 = (*C.char)(C.CString(devicePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_unix_is_system_device_path(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// UnixIsSystemFSType determines if @fs_type is considered a type of file system
// which is only used in implementation of the OS. This is primarily used for
// hiding mounted volumes that are intended as APIs for programs to read, and
// system administrators at a shell; rather than something that should, for
// example, appear in a GUI. For example, the Linux `/proc` filesystem.
// 
// The list of file system types considered system ones may change over time.
	func UnixIsSystemFSType(fsType string) bool {
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg1 = (*C.char)(C.CString(fsType))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_unix_is_system_fs_type(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// UnixMountAt gets a MountEntry for a given mount path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
// 
// If more mounts have the same mount path, the last matching mount is returned.
	func UnixMountAt(mountPath string) (uint64, *UnixMountEntry) {
var _arg1 *C.char // out
var _arg2 C.guint64 // in
var _cret *C.GUnixMountEntry // in

_arg1 = (*C.char)(C.CString(mountPath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_unix_mount_at(_arg1, &_arg2)


var _timeRead uint64 // out
var _unixMountEntry *UnixMountEntry // out

_timeRead = (uint64)(_arg2)
_unixMountEntry = *(**UnixMountEntry)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_unixMountEntry, func(v *UnixMountEntry) {
  C.free(unsafe.Pointer(v.Native()))
})

return _timeRead, _unixMountEntry
}


	// UnixMountCompare compares two unix mounts.
	func UnixMountCompare(mount1 *UnixMountEntry, mount2 *UnixMountEntry) int {
var _arg1 *C.GUnixMountEntry // out
var _arg2 *C.GUnixMountEntry // out
var _cret C.gint // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mount1.Native()))
_arg2 = (*C.GUnixMountEntry)(unsafe.Pointer(mount2.Native()))

_cret = C.g_unix_mount_compare(_arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}


	// UnixMountCopy makes a copy of @mount_entry.
	func UnixMountCopy(mountEntry *UnixMountEntry) *UnixMountEntry {
var _arg1 *C.GUnixMountEntry // out
var _cret *C.GUnixMountEntry // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_copy(_arg1)


var _unixMountEntry *UnixMountEntry // out

_unixMountEntry = *(**UnixMountEntry)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_unixMountEntry, func(v *UnixMountEntry) {
  C.free(unsafe.Pointer(v.Native()))
})

return _unixMountEntry
}


	// UnixMountFor gets a MountEntry for a given file path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
// 
// If more mounts have the same mount path, the last matching mount is returned.
	func UnixMountFor(filePath string) (uint64, *UnixMountEntry) {
var _arg1 *C.char // out
var _arg2 C.guint64 // in
var _cret *C.GUnixMountEntry // in

_arg1 = (*C.char)(C.CString(filePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_unix_mount_for(_arg1, &_arg2)


var _timeRead uint64 // out
var _unixMountEntry *UnixMountEntry // out

_timeRead = (uint64)(_arg2)
_unixMountEntry = *(**UnixMountEntry)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_unixMountEntry, func(v *UnixMountEntry) {
  C.free(unsafe.Pointer(v.Native()))
})

return _timeRead, _unixMountEntry
}


	// UnixMountFree frees a unix mount.
	func UnixMountFree(mountEntry *UnixMountEntry)  {
var _arg1 *C.GUnixMountEntry // out

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

C.g_unix_mount_free(_arg1)
}


	// UnixMountGetDevicePath gets the device path for a unix mount.
	func UnixMountGetDevicePath(mountEntry *UnixMountEntry) string {
var _arg1 *C.GUnixMountEntry // out
var _cret *C.char // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_get_device_path(_arg1)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}


	// UnixMountGetFSType gets the filesystem type for the unix mount.
	func UnixMountGetFSType(mountEntry *UnixMountEntry) string {
var _arg1 *C.GUnixMountEntry // out
var _cret *C.char // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_get_fs_type(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}


	// UnixMountGetMountPath gets the mount path for a unix mount.
	func UnixMountGetMountPath(mountEntry *UnixMountEntry) string {
var _arg1 *C.GUnixMountEntry // out
var _cret *C.char // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_get_mount_path(_arg1)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}


	// UnixMountGetOptions gets a comma-separated list of mount options for the unix
// mount. For example, `rw,relatime,seclabel,data=ordered`.
// 
// This is similar to g_unix_mount_point_get_options(), but it takes a
// MountEntry as an argument.
	func UnixMountGetOptions(mountEntry *UnixMountEntry) string {
var _arg1 *C.GUnixMountEntry // out
var _cret *C.char // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_get_options(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}


	// UnixMountGetRootPath gets the root of the mount within the filesystem. This
// is useful e.g. for mounts created by bind operation, or btrfs subvolumes.
// 
// For example, the root path is equal to "/" for mount created by "mount
// /dev/sda1 /mnt/foo" and "/bar" for "mount --bind /mnt/foo/bar /mnt/bar".
	func UnixMountGetRootPath(mountEntry *UnixMountEntry) string {
var _arg1 *C.GUnixMountEntry // out
var _cret *C.char // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_get_root_path(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}


	// UnixMountGuessCanEject guesses whether a Unix mount can be ejected.
	func UnixMountGuessCanEject(mountEntry *UnixMountEntry) bool {
var _arg1 *C.GUnixMountEntry // out
var _cret C.gboolean // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_guess_can_eject(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// UnixMountGuessIcon guesses the icon of a Unix mount.
	func UnixMountGuessIcon(mountEntry *UnixMountEntry) Icon {
var _arg1 *C.GUnixMountEntry // out
var _cret *C.GIcon // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_guess_icon(_arg1)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}


	// UnixMountGuessName guesses the name of a Unix mount. The result is a
// translated string.
	func UnixMountGuessName(mountEntry *UnixMountEntry) string {
var _arg1 *C.GUnixMountEntry // out
var _cret *C.char // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_guess_name(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// UnixMountGuessShouldDisplay guesses whether a Unix mount should be displayed
// in the UI.
	func UnixMountGuessShouldDisplay(mountEntry *UnixMountEntry) bool {
var _arg1 *C.GUnixMountEntry // out
var _cret C.gboolean // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_guess_should_display(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// UnixMountGuessSymbolicIcon guesses the symbolic icon of a Unix mount.
	func UnixMountGuessSymbolicIcon(mountEntry *UnixMountEntry) Icon {
var _arg1 *C.GUnixMountEntry // out
var _cret *C.GIcon // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_guess_symbolic_icon(_arg1)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}


	// UnixMountIsReadonly checks if a unix mount is mounted read only.
	func UnixMountIsReadonly(mountEntry *UnixMountEntry) bool {
var _arg1 *C.GUnixMountEntry // out
var _cret C.gboolean // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_is_readonly(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// UnixMountIsSystemInternal checks if a Unix mount is a system mount. This is
// the Boolean OR of g_unix_is_system_fs_type(), g_unix_is_system_device_path()
// and g_unix_is_mount_path_system_internal() on @mount_entrys properties.
// 
// The definition of what a system mount entry is may change over time as new
// file system types and device paths are ignored.
	func UnixMountIsSystemInternal(mountEntry *UnixMountEntry) bool {
var _arg1 *C.GUnixMountEntry // out
var _cret C.gboolean // in

_arg1 = (*C.GUnixMountEntry)(unsafe.Pointer(mountEntry.Native()))

_cret = C.g_unix_mount_is_system_internal(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// UnixMountPointsChangedSince checks if the unix mount points have changed
// since a given unix time.
	func UnixMountPointsChangedSince(time uint64) bool {
var _arg1 C.guint64 // out
var _cret C.gboolean // in

_arg1 = (C.guint64)(time)

_cret = C.g_unix_mount_points_changed_since(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// UnixMountsChangedSince checks if the unix mounts have changed since a given
// unix time.
	func UnixMountsChangedSince(time uint64) bool {
var _arg1 C.guint64 // out
var _cret C.gboolean // in

_arg1 = (C.guint64)(time)

_cret = C.g_unix_mounts_changed_since(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	
	// ActionInterface contains virtual methods for Action, or
	// methods that can be overridden.
	type ActionInterface interface {
		gextras.Objector

			// Activate activates the action.
	// 
	// @parameter must be the correct type of parameter for the action (ie: the
	// parameter type given at construction time). If the parameter type was nil
	// then @parameter must also be nil.
	// 
	// If the @parameter GVariant is floating, it is consumed.
		Activate(parameter *glib.Variant) 
			// ChangeState: request for the state of @action to be changed to @value.
	// 
	// The action must be stateful and @value must be of the correct type. See
	// g_action_get_state_type().
	// 
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_get_state_hint().
	// 
	// If the @value GVariant is floating, it is consumed.
		ChangeState(value *glib.Variant) 
			// Enabled checks if @action is currently enabled.
	// 
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
		Enabled() bool
			// Name queries the name of @action.
		Name() string
			// ParameterType queries the type of the parameter that must be given when
	// activating @action.
	// 
	// When activating the action using g_action_activate(), the #GVariant given
	// to that function must be of the type returned by this function.
	// 
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
		ParameterType() *glib.VariantType
			// State queries the current state of @action.
	// 
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_get_state_type().
	// 
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
		State() *glib.Variant
			// StateHint requests a hint about the valid range of values for the state
	// of @action.
	// 
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	// 
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	// 
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	// 
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
		StateHint() *glib.Variant
			// StateType queries the type of the state of @action.
	// 
	// If the action is stateful (e.g. created with
	// g_simple_action_new_stateful()) then this function returns the Type of
	// the state. This is the type of the initial value given as the state. All
	// calls to g_action_change_state() must give a #GVariant of this type and
	// g_action_get_state() will return a #GVariant of the same type.
	// 
	// If the action is not stateful (e.g. created with g_simple_action_new())
	// then this function will return nil. In that case, g_action_get_state()
	// will return nil and you must not call g_action_change_state().
		StateType() *glib.VariantType
		
	}
	

	// Action represents a single named action.
// 
// The main interface to an action is that it can be activated with
// g_action_activate(). This results in the 'activate' signal being emitted. An
// activation has a #GVariant parameter (which may be nil). The correct type for
// the parameter is determined by a static parameter type (which is given at
// construction time).
// 
// An action may optionally have a state, in which case the state may be set
// with g_action_change_state(). This call takes a #GVariant. The correct type
// for the state is determined by a static state type (which is given at
// construction time).
// 
// The state may have a hint associated with it, specifying its valid range.
// 
// #GAction is merely the interface to the concept of an action, as described
// above. Various implementations of actions exist, including Action.
// 
// In all cases, the implementing class is responsible for storing the name of
// the action, the parameter type, the enabled state, the optional state type
// and the state and emitting the appropriate signals when these change. The
// implementor is responsible for filtering calls to g_action_activate() and
// g_action_change_state() for type safety and for the state being enabled.
// 
// Probably the only useful thing to do with a #GAction is to put it inside of a
// ActionGroup.
	type Action struct {
		**externglib.Object
		
	}

	
	func marshalAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Action{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Activate activates the action.
// 
// @parameter must be the correct type of parameter for the action (ie: the
// parameter type given at construction time). If the parameter type was nil
// then @parameter must also be nil.
// 
// If the @parameter GVariant is floating, it is consumed.
	func (a Action) Activate(parameter *glib.Variant)  {
var _arg0 *C.GAction // out
var _arg1 *C.GVariant // out

_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

C.g_action_activate(_arg0, _arg1)
}
	
	// ChangeState: request for the state of @action to be changed to @value.
// 
// The action must be stateful and @value must be of the correct type. See
// g_action_get_state_type().
// 
// This call merely requests a change. The action may refuse to change its state
// or may change its state to something other than @value. See
// g_action_get_state_hint().
// 
// If the @value GVariant is floating, it is consumed.
	func (a Action) ChangeState(value *glib.Variant)  {
var _arg0 *C.GAction // out
var _arg1 *C.GVariant // out

_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

C.g_action_change_state(_arg0, _arg1)
}
	
	// Enabled checks if @action is currently enabled.
// 
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
	func (a Action) Enabled() bool {
var _arg0 *C.GAction // out
var _cret C.gboolean // in

_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

_cret = C.g_action_get_enabled(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Name queries the name of @action.
	func (a Action) Name() string {
var _arg0 *C.GAction // out
var _cret *C.gchar // in

_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

_cret = C.g_action_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ParameterType queries the type of the parameter that must be given when
// activating @action.
// 
// When activating the action using g_action_activate(), the #GVariant given to
// that function must be of the type returned by this function.
// 
// In the case that this function returns nil, you must not give any #GVariant,
// but nil instead.
	func (a Action) ParameterType() *glib.VariantType {
var _arg0 *C.GAction // out
var _cret *C.GVariantType // in

_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

_cret = C.g_action_get_parameter_type(_arg0)


var _variantType *glib.VariantType // out

_variantType = *(**glib.VariantType)(unsafe.Pointer(&_cret))

return _variantType
}
	
	// State queries the current state of @action.
// 
// If the action is not stateful then nil will be returned. If the action is
// stateful then the type of the return value is the type given by
// g_action_get_state_type().
// 
// The return value (if non-nil) should be freed with g_variant_unref() when it
// is no longer required.
	func (a Action) State() *glib.Variant {
var _arg0 *C.GAction // out
var _cret *C.GVariant // in

_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

_cret = C.g_action_get_state(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// StateHint requests a hint about the valid range of values for the state of
// @action.
// 
// If nil is returned it either means that the action is not stateful or that
// there is no hint about the valid range of values for the state of the action.
// 
// If a #GVariant array is returned then each item in the array is a possible
// value for the state. If a #GVariant pair (ie: two-tuple) is returned then the
// tuple specifies the inclusive lower and upper bound of valid values for the
// state.
// 
// In any case, the information is merely a hint. It may be possible to have a
// state value outside of the hinted range and setting a value within the range
// may fail.
// 
// The return value (if non-nil) should be freed with g_variant_unref() when it
// is no longer required.
	func (a Action) StateHint() *glib.Variant {
var _arg0 *C.GAction // out
var _cret *C.GVariant // in

_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

_cret = C.g_action_get_state_hint(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// StateType queries the type of the state of @action.
// 
// If the action is stateful (e.g. created with g_simple_action_new_stateful())
// then this function returns the Type of the state. This is the type of the
// initial value given as the state. All calls to g_action_change_state() must
// give a #GVariant of this type and g_action_get_state() will return a
// #GVariant of the same type.
// 
// If the action is not stateful (e.g. created with g_simple_action_new()) then
// this function will return nil. In that case, g_action_get_state() will return
// nil and you must not call g_action_change_state().
	func (a Action) StateType() *glib.VariantType {
var _arg0 *C.GAction // out
var _cret *C.GVariantType // in

_arg0 = (*C.GAction)(unsafe.Pointer(a.Native()))

_cret = C.g_action_get_state_type(_arg0)


var _variantType *glib.VariantType // out

_variantType = *(**glib.VariantType)(unsafe.Pointer(&_cret))

return _variantType
}
	


	
	// ActionGroupInterface contains virtual methods for ActionGroup, or
	// methods that can be overridden.
	type ActionGroupInterface interface {
		gextras.Objector

			// ActionAdded emits the Group::action-added signal on @action_group.
	// 
	// This function should only be called by Group implementations.
		ActionAdded(actionName string) 
			// ActionEnabledChanged emits the Group::action-enabled-changed signal on
	// @action_group.
	// 
	// This function should only be called by Group implementations.
		ActionEnabledChanged(actionName string, enabled bool) 
			// ActionRemoved emits the Group::action-removed signal on @action_group.
	// 
	// This function should only be called by Group implementations.
		ActionRemoved(actionName string) 
			// ActionStateChanged emits the Group::action-state-changed signal on
	// @action_group.
	// 
	// This function should only be called by Group implementations.
		ActionStateChanged(actionName string, state *glib.Variant) 
			// ActivateAction: activate the named action within @action_group.
	// 
	// If the action is expecting a parameter, then the correct type of
	// parameter must be given as @parameter. If the action is expecting no
	// parameters then @parameter must be nil. See
	// g_action_group_get_action_parameter_type().
	// 
	// If the Group implementation supports asynchronous remote activation over
	// D-Bus, this call may return before the relevant D-Bus traffic has been
	// sent, or any replies have been received. In order to block on such
	// asynchronous activation calls, g_dbus_connection_flush() should be called
	// prior to the code, which depends on the result of the action activation.
	// Without flushing the D-Bus connection, there is no guarantee that the
	// action would have been activated.
	// 
	// The following code which runs in a remote app instance, shows an example
	// of a "quit" action being activated on the primary app instance over
	// D-Bus. Here g_dbus_connection_flush() is called before `exit()`. Without
	// g_dbus_connection_flush(), the "quit" action may fail to be activated on
	// the primary instance.
	// 
	//    // call "quit" action on primary instance
	//    g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
	// 
	//    // make sure the action is activated now
	//    g_dbus_connection_flush (...);
	// 
	//    g_debug ("application has been terminated. exiting.");
	// 
	//    exit (0);
		ActivateAction(actionName string, parameter *glib.Variant) 
			// ChangeActionState: request for the state of the named action within
	// @action_group to be changed to @value.
	// 
	// The action must be stateful and @value must be of the correct type. See
	// g_action_group_get_action_state_type().
	// 
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_group_get_action_state_hint().
	// 
	// If the @value GVariant is floating, it is consumed.
		ChangeActionState(actionName string, value *glib.Variant) 
			// ActionEnabled checks if the named action within @action_group is
	// currently enabled.
	// 
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
		ActionEnabled(actionName string) bool
			// ActionParameterType queries the type of the parameter that must be given
	// when activating the named action within @action_group.
	// 
	// When activating the action using g_action_group_activate_action(), the
	// #GVariant given to that function must be of the type returned by this
	// function.
	// 
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	// 
	// The parameter type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different parameter type.
		ActionParameterType(actionName string) *glib.VariantType
			// ActionState queries the current state of the named action within
	// @action_group.
	// 
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_group_get_action_state_type().
	// 
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
		ActionState(actionName string) *glib.Variant
			// ActionStateHint requests a hint about the valid range of values for the
	// state of the named action within @action_group.
	// 
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	// 
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	// 
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	// 
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
		ActionStateHint(actionName string) *glib.Variant
			// ActionStateType queries the type of the state of the named action within
	// @action_group.
	// 
	// If the action is stateful then this function returns the Type of the
	// state. All calls to g_action_group_change_action_state() must give a
	// #GVariant of this type and g_action_group_get_action_state() will return
	// a #GVariant of the same type.
	// 
	// If the action is not stateful then this function will return nil. In that
	// case, g_action_group_get_action_state() will return nil and you must not
	// call g_action_group_change_action_state().
	// 
	// The state type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different state type.
		ActionStateType(actionName string) *glib.VariantType
			// HasAction checks if the named action exists within @action_group.
		HasAction(actionName string) bool
			// ListActions lists the actions contained within @action_group.
	// 
	// The caller is responsible for freeing the list with g_strfreev() when it
	// is no longer required.
		ListActions() []string
			// QueryAction queries all aspects of the named action within an
	// @action_group.
	// 
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	// 
	// This provides two main benefits.
	// 
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	// 
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	// 
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
		QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool)
		
	}
	

	// ActionGroup represents a group of actions. Actions can be used to expose
// functionality in a structured way, either from one part of a program to
// another, or to the outside world. Action groups are often used together with
// a Model that provides additional representation data for displaying the
// actions to the user, e.g. in a menu.
// 
// The main way to interact with the actions in a GActionGroup is to activate
// them with g_action_group_activate_action(). Activating an action may require
// a #GVariant parameter. The required type of the parameter can be inquired
// with g_action_group_get_action_parameter_type(). Actions may be disabled, see
// g_action_group_get_action_enabled(). Activating a disabled action has no
// effect.
// 
// Actions may optionally have a state in the form of a #GVariant. The current
// state of an action can be inquired with g_action_group_get_action_state().
// Activating a stateful action may change its state, but it is also possible to
// set the state by calling g_action_group_change_action_state().
// 
// As typical example, consider a text editing application which has an option
// to change the current font to 'bold'. A good way to represent this would be a
// stateful action, with a boolean state. Activating the action would toggle the
// state.
// 
// Each action in the group has a unique name (which is a string). All method
// calls, except g_action_group_list_actions() take the name of an action as an
// argument.
// 
// The Group API is meant to be the 'public' API to the action group. The calls
// here are exactly the interaction that 'external forces' (eg: UI, incoming
// D-Bus messages, etc.) are supposed to have with actions. 'Internal' APIs (ie:
// ones meant only to be accessed by the action group implementation) are found
// on subclasses. This is why you will find - for example -
// g_action_group_get_action_enabled() but not an equivalent set() call.
// 
// Signals are emitted on the action group in response to state changes on
// individual actions.
// 
// Implementations of Group should provide implementations for the virtual
// functions g_action_group_list_actions() and g_action_group_query_action().
// The other virtual functions should not be implemented - their "wrappers" are
// actually implemented with calls to g_action_group_query_action().
	type ActionGroup struct {
		**externglib.Object
		
	}

	
	func marshalActionGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// ActionAdded emits the Group::action-added signal on @action_group.
// 
// This function should only be called by Group implementations.
	func (a ActionGroup) ActionAdded(actionName string)  {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

C.g_action_group_action_added(_arg0, _arg1)
}
	
	// ActionEnabledChanged emits the Group::action-enabled-changed signal on
// @action_group.
// 
// This function should only be called by Group implementations.
	func (a ActionGroup) ActionEnabledChanged(actionName string, enabled bool)  {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _arg2 C.gboolean // out

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))
if enabled { _arg2 = C.TRUE }

C.g_action_group_action_enabled_changed(_arg0, _arg1, _arg2)
}
	
	// ActionRemoved emits the Group::action-removed signal on @action_group.
// 
// This function should only be called by Group implementations.
	func (a ActionGroup) ActionRemoved(actionName string)  {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

C.g_action_group_action_removed(_arg0, _arg1)
}
	
	// ActionStateChanged emits the Group::action-state-changed signal on
// @action_group.
// 
// This function should only be called by Group implementations.
	func (a ActionGroup) ActionStateChanged(actionName string, state *glib.Variant)  {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(state.Native()))

C.g_action_group_action_state_changed(_arg0, _arg1, _arg2)
}
	
	// ActivateAction: activate the named action within @action_group.
// 
// If the action is expecting a parameter, then the correct type of parameter
// must be given as @parameter. If the action is expecting no parameters then
// @parameter must be nil. See g_action_group_get_action_parameter_type().
// 
// If the Group implementation supports asynchronous remote activation over
// D-Bus, this call may return before the relevant D-Bus traffic has been sent,
// or any replies have been received. In order to block on such asynchronous
// activation calls, g_dbus_connection_flush() should be called prior to the
// code, which depends on the result of the action activation. Without flushing
// the D-Bus connection, there is no guarantee that the action would have been
// activated.
// 
// The following code which runs in a remote app instance, shows an example of a
// "quit" action being activated on the primary app instance over D-Bus. Here
// g_dbus_connection_flush() is called before `exit()`. Without
// g_dbus_connection_flush(), the "quit" action may fail to be activated on the
// primary instance.
// 
//    // call "quit" action on primary instance
//    g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
// 
//    // make sure the action is activated now
//    g_dbus_connection_flush (...);
// 
//    g_debug ("application has been terminated. exiting.");
// 
//    exit (0);
	func (a ActionGroup) ActivateAction(actionName string, parameter *glib.Variant)  {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

C.g_action_group_activate_action(_arg0, _arg1, _arg2)
}
	
	// ChangeActionState: request for the state of the named action within
// @action_group to be changed to @value.
// 
// The action must be stateful and @value must be of the correct type. See
// g_action_group_get_action_state_type().
// 
// This call merely requests a change. The action may refuse to change its state
// or may change its state to something other than @value. See
// g_action_group_get_action_state_hint().
// 
// If the @value GVariant is floating, it is consumed.
	func (a ActionGroup) ChangeActionState(actionName string, value *glib.Variant)  {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

C.g_action_group_change_action_state(_arg0, _arg1, _arg2)
}
	
	// ActionEnabled checks if the named action within @action_group is currently
// enabled.
// 
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
	func (a ActionGroup) ActionEnabled(actionName string) bool {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_action_group_get_action_enabled(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ActionParameterType queries the type of the parameter that must be given when
// activating the named action within @action_group.
// 
// When activating the action using g_action_group_activate_action(), the
// #GVariant given to that function must be of the type returned by this
// function.
// 
// In the case that this function returns nil, you must not give any #GVariant,
// but nil instead.
// 
// The parameter type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added with
// the same name but a different parameter type.
	func (a ActionGroup) ActionParameterType(actionName string) *glib.VariantType {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _cret *C.GVariantType // in

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_action_group_get_action_parameter_type(_arg0, _arg1)


var _variantType *glib.VariantType // out

_variantType = *(**glib.VariantType)(unsafe.Pointer(&_cret))

return _variantType
}
	
	// ActionState queries the current state of the named action within
// @action_group.
// 
// If the action is not stateful then nil will be returned. If the action is
// stateful then the type of the return value is the type given by
// g_action_group_get_action_state_type().
// 
// The return value (if non-nil) should be freed with g_variant_unref() when it
// is no longer required.
	func (a ActionGroup) ActionState(actionName string) *glib.Variant {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _cret *C.GVariant // in

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_action_group_get_action_state(_arg0, _arg1)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// ActionStateHint requests a hint about the valid range of values for the state
// of the named action within @action_group.
// 
// If nil is returned it either means that the action is not stateful or that
// there is no hint about the valid range of values for the state of the action.
// 
// If a #GVariant array is returned then each item in the array is a possible
// value for the state. If a #GVariant pair (ie: two-tuple) is returned then the
// tuple specifies the inclusive lower and upper bound of valid values for the
// state.
// 
// In any case, the information is merely a hint. It may be possible to have a
// state value outside of the hinted range and setting a value within the range
// may fail.
// 
// The return value (if non-nil) should be freed with g_variant_unref() when it
// is no longer required.
	func (a ActionGroup) ActionStateHint(actionName string) *glib.Variant {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _cret *C.GVariant // in

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_action_group_get_action_state_hint(_arg0, _arg1)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// ActionStateType queries the type of the state of the named action within
// @action_group.
// 
// If the action is stateful then this function returns the Type of the state.
// All calls to g_action_group_change_action_state() must give a #GVariant of
// this type and g_action_group_get_action_state() will return a #GVariant of
// the same type.
// 
// If the action is not stateful then this function will return nil. In that
// case, g_action_group_get_action_state() will return nil and you must not call
// g_action_group_change_action_state().
// 
// The state type of a particular action will never change but it is possible
// for an action to be removed and for a new action to be added with the same
// name but a different state type.
	func (a ActionGroup) ActionStateType(actionName string) *glib.VariantType {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _cret *C.GVariantType // in

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_action_group_get_action_state_type(_arg0, _arg1)


var _variantType *glib.VariantType // out

_variantType = *(**glib.VariantType)(unsafe.Pointer(&_cret))

return _variantType
}
	
	// HasAction checks if the named action exists within @action_group.
	func (a ActionGroup) HasAction(actionName string) bool {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_action_group_has_action(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ListActions lists the actions contained within @action_group.
// 
// The caller is responsible for freeing the list with g_strfreev() when it is
// no longer required.
	func (a ActionGroup) ListActions() []string {
var _arg0 *C.GActionGroup // out
var _cret **C.gchar

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))

_cret = C.g_action_group_list_actions(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// QueryAction queries all aspects of the named action within an @action_group.
// 
// This function acquires the information available from
// g_action_group_has_action(), g_action_group_get_action_enabled(),
// g_action_group_get_action_parameter_type(),
// g_action_group_get_action_state_type(),
// g_action_group_get_action_state_hint() and g_action_group_get_action_state()
// with a single function call.
// 
// This provides two main benefits.
// 
// The first is the improvement in efficiency that comes with not having to
// perform repeated lookups of the action in order to discover different things
// about it. The second is that implementing Group can now be done by only
// overriding this one virtual function.
// 
// The interface provides a default implementation of this function that calls
// the individual functions, as required, to fetch the information. The
// interface also provides default implementations of those functions that call
// this function. All implementations, therefore, must override either this
// function or all of the others.
// 
// If the action exists, true is returned and any of the requested fields (as
// indicated by having a non-nil reference passed in) are filled. If the action
// doesn't exist, false is returned and the fields may or may not have been
// modified.
	func (a ActionGroup) QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool) {
var _arg0 *C.GActionGroup // out
var _arg1 *C.gchar // out
var _arg2 C.gboolean // in
var _parameterType *glib.VariantType
var _stateType *glib.VariantType
var _stateHint *glib.Variant
var _state *glib.Variant
var _cret C.gboolean // in

_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_action_group_query_action(_arg0, _arg1, &_arg2, (**C.GVariantType)(unsafe.Pointer(&_parameterType)), (**C.GVariantType)(unsafe.Pointer(&_stateType)), (**C.GVariant)(unsafe.Pointer(&_stateHint)), (**C.GVariant)(unsafe.Pointer(&_state)))


var _enabled bool // out




var _ok bool // out

if _arg2 { _enabled = true }




if _cret != 0 { _ok = true }

return _enabled, _parameterType, _stateType, _stateHint, _state, _ok
}
	


	
	// ActionMapInterface contains virtual methods for ActionMap, or
	// methods that can be overridden.
	type ActionMapInterface interface {
		gextras.Objector

			// AddAction adds an action to the @action_map.
	// 
	// If the action map already contains an action with the same name as
	// @action then the old action is dropped from the action map.
	// 
	// The action map takes its own reference on @action.
		AddAction(action Action) 
			// LookupAction looks up the action with the name @action_name in
	// @action_map.
	// 
	// If no such action exists, returns nil.
		LookupAction(actionName string) Action
			// RemoveAction removes the named action from the action map.
	// 
	// If no action of this name is in the map then nothing happens.
		RemoveAction(actionName string) 
		
	}
	

	// ActionMap: the GActionMap interface is implemented by Group implementations
// that operate by containing a number of named #GAction instances, such as
// ActionGroup.
// 
// One useful application of this interface is to map the names of actions from
// various action groups to unique, prefixed names (e.g. by prepending "app." or
// "win."). This is the motivation for the 'Map' part of the interface name.
	type ActionMap struct {
		**externglib.Object
		
	}

	
	func marshalActionMap(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ActionMap{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddAction adds an action to the @action_map.
// 
// If the action map already contains an action with the same name as @action
// then the old action is dropped from the action map.
// 
// The action map takes its own reference on @action.
	func (a ActionMap) AddAction(action Action)  {
var _arg0 *C.GActionMap // out
var _arg1 *C.GAction // out

_arg0 = (*C.GActionMap)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GAction)(unsafe.Pointer(action.Native()))

C.g_action_map_add_action(_arg0, _arg1)
}
	
	// LookupAction looks up the action with the name @action_name in @action_map.
// 
// If no such action exists, returns nil.
	func (a ActionMap) LookupAction(actionName string) Action {
var _arg0 *C.GActionMap // out
var _arg1 *C.gchar // out
var _cret *C.GAction // in

_arg0 = (*C.GActionMap)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_action_map_lookup_action(_arg0, _arg1)


var _action Action // out

_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

return _action
}
	
	// RemoveAction removes the named action from the action map.
// 
// If no action of this name is in the map then nothing happens.
	func (a ActionMap) RemoveAction(actionName string)  {
var _arg0 *C.GActionMap // out
var _arg1 *C.gchar // out

_arg0 = (*C.GActionMap)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

C.g_action_map_remove_action(_arg0, _arg1)
}
	


	
	// AppInfoInterface contains virtual methods for AppInfo, or
	// methods that can be overridden.
	type AppInfoInterface interface {
		gextras.Objector

			// AddSupportsType adds a content type to the application information to
	// indicate the application is capable of opening files with the given
	// content type.
		AddSupportsType(contentType string) error
			// CanDelete obtains the information whether the Info can be deleted. See
	// g_app_info_delete().
		CanDelete() bool
			// CanRemoveSupportsType checks if a supported content type can be removed
	// from an application.
		CanRemoveSupportsType() bool
			// DoDelete tries to delete a Info.
	// 
	// On some platforms, there may be a difference between user-defined Infos
	// which can be deleted, and system-wide ones which cannot. See
	// g_app_info_can_delete().
		DoDelete() bool
			// Dup creates a duplicate of a Info.
		Dup() AppInfo
			// Equal checks if two Infos are equal.
	// 
	// Note that the check *may not* compare each individual field, and only
	// does an identity check. In case detecting changes in the contents is
	// needed, program code must additionally compare relevant fields.
		Equal(appinfo2 AppInfo) bool
			// Commandline gets the commandline with which the application will be
	// started.
		Commandline() string
			// Description gets a human-readable description of an installed
	// application.
		Description() string
			// DisplayName gets the display name of the application. The display name is
	// often more descriptive to the user than the name itself.
		DisplayName() string
			// Executable gets the executable's name for the installed application.
		Executable() string
			// Icon gets the icon for the application.
		Icon() Icon
			// ID gets the ID of an application. An id is a string that identifies the
	// application. The exact format of the id is platform dependent. For
	// instance, on Unix this is the desktop file id from the xdg menu
	// specification.
	// 
	// Note that the returned ID may be nil, depending on how the @appinfo has
	// been constructed.
		ID() string
			// Name gets the installed name of the application.
		Name() string
			// SupportedTypes retrieves the list of content types that @app_info claims
	// to support. If this information is not provided by the environment, this
	// function will return nil. This function does not take in consideration
	// associations added with g_app_info_add_supports_type(), but only those
	// exported directly by the application.
		SupportedTypes() []string
			// LaunchUrisFinish finishes a g_app_info_launch_uris_async() operation.
		LaunchUrisFinish(result AsyncResult) error
			// RemoveSupportsType removes a supported type from an application, if
	// possible.
		RemoveSupportsType(contentType string) error
			// SetAsDefaultForExtension sets the application as the default handler for
	// the given file extension.
		SetAsDefaultForExtension(extension string) error
			// SetAsDefaultForType sets the application as the default handler for a
	// given type.
		SetAsDefaultForType(contentType string) error
			// SetAsLastUsedForType sets the application as the last used application
	// for a given type. This will make the application appear as first in the
	// list returned by g_app_info_get_recommended_for_type(), regardless of the
	// default application for that content type.
		SetAsLastUsedForType(contentType string) error
			// ShouldShow checks if the application info should be shown in menus that
	// list available applications.
		ShouldShow() bool
			// SupportsFiles checks if the application accepts files as arguments.
		SupportsFiles() bool
			// SupportsUris checks if the application supports reading files and
	// directories from URIs.
		SupportsUris() bool
		
	}
	

	// AppInfo: Info and LaunchContext are used for describing and launching
// applications installed on the system.
// 
// As of GLib 2.20, URIs will always be converted to POSIX paths (using
// g_file_get_path()) when using g_app_info_launch() even if the application
// requested an URI and not a POSIX path. For example for a desktop-file based
// application with Exec key `totem U` and a single URI, `sftp://foo/file.avi`,
// then `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only
// work if a set of suitable GIO extensions (such as gvfs 2.26 compiled with
// FUSE support), is available and operational; if this is not the case, the URI
// will be passed unmodified to the application. Some URIs, such as `mailto:`,
// of course cannot be mapped to a POSIX path (in gvfs there's no FUSE mount for
// it); such URIs will be passed unmodified to the application.
// 
// Specifically for gvfs 2.26 and later, the POSIX URI will be mapped back to
// the GIO URI in the #GFile constructors (since gvfs implements the #GVfs
// extension point). As such, if the application needs to examine the URI, it
// needs to use g_file_get_uri() or similar on #GFile. In other words, an
// application cannot assume that the URI passed to e.g.
// g_file_new_for_commandline_arg() is equal to the result of g_file_get_uri().
// The following snippet illustrates this:
// 
//    GFile *f;
//    char *uri;
// 
//    file = g_file_new_for_commandline_arg (uri_from_commandline);
// 
//    uri = g_file_get_uri (file);
//    strcmp (uri, uri_from_commandline) == 0;
//    g_free (uri);
// 
//    if (g_file_has_uri_scheme (file, "cdda"))
//      {
//        // do something special with uri
//      }
//    g_object_unref (file);
// 
// This code will work when both `cdda://sr0/Track 1.wav` and
// `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the application. It
// should be noted that it's generally not safe for applications to rely on the
// format of a particular URIs. Different launcher applications (e.g. file
// managers) may have different ideas of what a given URI means.
	type AppInfo struct {
		**externglib.Object
		
	}

	
	func marshalAppInfo(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {AppInfo{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddSupportsType adds a content type to the application information to
// indicate the application is capable of opening files with the given content
// type.
	func (a AppInfo) AddSupportsType(contentType string) error {
var _arg0 *C.GAppInfo // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg1))

C.g_app_info_add_supports_type(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CanDelete obtains the information whether the Info can be deleted. See
// g_app_info_delete().
	func (a AppInfo) CanDelete() bool {
var _arg0 *C.GAppInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_can_delete(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanRemoveSupportsType checks if a supported content type can be removed from
// an application.
	func (a AppInfo) CanRemoveSupportsType() bool {
var _arg0 *C.GAppInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_can_remove_supports_type(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Delete tries to delete a Info.
// 
// On some platforms, there may be a difference between user-defined Infos which
// can be deleted, and system-wide ones which cannot. See
// g_app_info_can_delete().
	func (a AppInfo) Delete() bool {
var _arg0 *C.GAppInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_delete(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Dup creates a duplicate of a Info.
	func (a AppInfo) Dup() AppInfo {
var _arg0 *C.GAppInfo // out
var _cret *C.GAppInfo // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_dup(_arg0)


var _appInfo AppInfo // out

_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppInfo)

return _appInfo
}
	
	// Equal checks if two Infos are equal.
// 
// Note that the check *may not* compare each individual field, and only does an
// identity check. In case detecting changes in the contents is needed, program
// code must additionally compare relevant fields.
	func (a AppInfo) Equal(appinfo2 AppInfo) bool {
var _arg0 *C.GAppInfo // out
var _arg1 *C.GAppInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GAppInfo)(unsafe.Pointer(appinfo2.Native()))

_cret = C.g_app_info_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Commandline gets the commandline with which the application will be started.
	func (a AppInfo) Commandline() string {
var _arg0 *C.GAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_get_commandline(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// Description gets a human-readable description of an installed application.
	func (a AppInfo) Description() string {
var _arg0 *C.GAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_get_description(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// DisplayName gets the display name of the application. The display name is
// often more descriptive to the user than the name itself.
	func (a AppInfo) DisplayName() string {
var _arg0 *C.GAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_get_display_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Executable gets the executable's name for the installed application.
	func (a AppInfo) Executable() string {
var _arg0 *C.GAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_get_executable(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// Icon gets the icon for the application.
	func (a AppInfo) Icon() Icon {
var _arg0 *C.GAppInfo // out
var _cret *C.GIcon // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_get_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// ID gets the ID of an application. An id is a string that identifies the
// application. The exact format of the id is platform dependent. For instance,
// on Unix this is the desktop file id from the xdg menu specification.
// 
// Note that the returned ID may be nil, depending on how the @appinfo has been
// constructed.
	func (a AppInfo) ID() string {
var _arg0 *C.GAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_get_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Name gets the installed name of the application.
	func (a AppInfo) Name() string {
var _arg0 *C.GAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SupportedTypes retrieves the list of content types that @app_info claims to
// support. If this information is not provided by the environment, this
// function will return nil. This function does not take in consideration
// associations added with g_app_info_add_supports_type(), but only those
// exported directly by the application.
	func (a AppInfo) SupportedTypes() []string {
var _arg0 *C.GAppInfo // out
var _cret **C.char

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_get_supported_types(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// LaunchUrisFinish finishes a g_app_info_launch_uris_async() operation.
	func (a AppInfo) LaunchUrisFinish(result AsyncResult) error {
var _arg0 *C.GAppInfo // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_app_info_launch_uris_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// RemoveSupportsType removes a supported type from an application, if possible.
	func (a AppInfo) RemoveSupportsType(contentType string) error {
var _arg0 *C.GAppInfo // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg1))

C.g_app_info_remove_supports_type(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAsDefaultForExtension sets the application as the default handler for the
// given file extension.
	func (a AppInfo) SetAsDefaultForExtension(extension string) error {
var _arg0 *C.GAppInfo // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(extension))
defer C.free(unsafe.Pointer(_arg1))

C.g_app_info_set_as_default_for_extension(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAsDefaultForType sets the application as the default handler for a given
// type.
	func (a AppInfo) SetAsDefaultForType(contentType string) error {
var _arg0 *C.GAppInfo // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg1))

C.g_app_info_set_as_default_for_type(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAsLastUsedForType sets the application as the last used application for a
// given type. This will make the application appear as first in the list
// returned by g_app_info_get_recommended_for_type(), regardless of the default
// application for that content type.
	func (a AppInfo) SetAsLastUsedForType(contentType string) error {
var _arg0 *C.GAppInfo // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg1))

C.g_app_info_set_as_last_used_for_type(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ShouldShow checks if the application info should be shown in menus that list
// available applications.
	func (a AppInfo) ShouldShow() bool {
var _arg0 *C.GAppInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_should_show(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SupportsFiles checks if the application accepts files as arguments.
	func (a AppInfo) SupportsFiles() bool {
var _arg0 *C.GAppInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_supports_files(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SupportsUris checks if the application supports reading files and directories
// from URIs.
	func (a AppInfo) SupportsUris() bool {
var _arg0 *C.GAppInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

_cret = C.g_app_info_supports_uris(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// AsyncInitableInterface contains virtual methods for AsyncInitable, or
	// methods that can be overridden.
	type AsyncInitableInterface interface {
		gextras.Objector

			// InitFinish finishes asynchronous initialization and returns the result.
	// See g_async_initable_init_async().
		InitFinish(res AsyncResult) error
		
	}
	

	// AsyncInitable: this is the asynchronous version of #GInitable; it behaves the
// same in all ways except that initialization is asynchronous. For more details
// see the descriptions on #GInitable.
// 
// A class may implement both the #GInitable and Initable interfaces.
// 
// Users of objects implementing this are not intended to use the interface
// method directly; instead it will be used automatically in various ways. For C
// applications you generally just call g_async_initable_new_async() directly,
// or indirectly via a foo_thing_new_async() wrapper. This will call
// g_async_initable_init_async() under the cover, calling back with nil and a
// set GError on failure.
// 
// A typical implementation might look something like this:
// 
//    enum {
//       NOT_INITIALIZED,
//       INITIALIZING,
//       INITIALIZED
//    };
// 
//    static void
//    _foo_ready_cb (Foo *self)
//    {
//      GList *l;
// 
//      self->priv->state = INITIALIZED;
// 
//      for (l = self->priv->init_results; l != NULL; l = l->next)
//        {
//          GTask *task = l->data;
// 
//          if (self->priv->success)
//            g_task_return_boolean (task, TRUE);
//          else
//            g_task_return_new_error (task, ...);
//          g_object_unref (task);
//        }
// 
//      g_list_free (self->priv->init_results);
//      self->priv->init_results = NULL;
//    }
// 
//    static void
//    foo_init_async (GAsyncInitable       *initable,
//                    int                   io_priority,
//                    GCancellable         *cancellable,
//                    GAsyncReadyCallback   callback,
//                    gpointer              user_data)
//    {
//      Foo *self = FOO (initable);
//      GTask *task;
// 
//      task = g_task_new (initable, cancellable, callback, user_data);
//      g_task_set_name (task, G_STRFUNC);
// 
//      switch (self->priv->state)
//        {
//          case NOT_INITIALIZED:
//            _foo_get_ready (self);
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            self->priv->state = INITIALIZING;
//            break;
//          case INITIALIZING:
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            break;
//          case INITIALIZED:
//            if (!self->priv->success)
//              g_task_return_new_error (task, ...);
//            else
//              g_task_return_boolean (task, TRUE);
//            g_object_unref (task);
//            break;
//        }
//    }
// 
//    static gboolean
//    foo_init_finish (GAsyncInitable       *initable,
//                     GAsyncResult         *result,
//                     GError              **error)
//    {
//      g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
// 
//      return g_task_propagate_boolean (G_TASK (result), error);
//    }
// 
//    static void
//    foo_async_initable_iface_init (gpointer g_iface,
//                                   gpointer data)
//    {
//      GAsyncInitableIface *iface = g_iface;
// 
//      iface->init_async = foo_init_async;
//      iface->init_finish = foo_init_finish;
//    }
	type AsyncInitable struct {
		**externglib.Object
		
	}

	
	func marshalAsyncInitable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// InitFinish finishes asynchronous initialization and returns the result. See
// g_async_initable_init_async().
	func (i AsyncInitable) InitFinish(res AsyncResult) error {
var _arg0 *C.GAsyncInitable // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GAsyncInitable)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

C.g_async_initable_init_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// NewFinish finishes the async construction for the various
// g_async_initable_new calls, returning the created object or nil on error.
	func (i AsyncInitable) NewFinish(res AsyncResult) (**externglib.Object, error) {
var _arg0 *C.GAsyncInitable // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GObject // in
var _cerr *C.GError // in

_arg0 = (*C.GAsyncInitable)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_async_initable_new_finish(_arg0, _arg1, &_cerr)


var _object **externglib.Object // out
var _goerr error // out

_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(**externglib.Object)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _object, _goerr
}
	


	
	// AsyncResultInterface contains virtual methods for AsyncResult, or
	// methods that can be overridden.
	type AsyncResultInterface interface {
		gextras.Objector

			// SourceObject gets the source object from a Result.
		SourceObject() **externglib.Object
		
	}
	

	// AsyncResult provides a base class for implementing asynchronous function
// results.
// 
// Asynchronous operations are broken up into two separate operations which are
// chained together by a ReadyCallback. To begin an asynchronous operation,
// provide a ReadyCallback to the asynchronous function. This callback will be
// triggered when the operation has completed, and must be run in a later
// iteration of the [thread-default main
// context][g-main-context-push-thread-default] from where the operation was
// initiated. It will be passed a Result instance filled with the details of the
// operation's success or failure, the object the asynchronous function was
// started for and any error codes returned. The asynchronous callback function
// is then expected to call the corresponding "_finish()" function, passing the
// object the function was called for, the Result instance, and (optionally) an
// @error to grab any error conditions that may have occurred.
// 
// The "_finish()" function for an operation takes the generic result (of type
// Result) and returns the specific result that the operation in question yields
// (e.g. a Enumerator for a "enumerate children" operation). If the result or
// error status of the operation is not needed, there is no need to call the
// "_finish()" function; GIO will take care of cleaning up the result and error
// information after the ReadyCallback returns. You can pass nil for the
// ReadyCallback if you don't need to take any action at all after the operation
// completes. Applications may also take a reference to the Result and call
// "_finish()" later; however, the "_finish()" function may be called at most
// once.
// 
// Example of a typical asynchronous operation flow:
// 
//    void _theoretical_frobnitz_async (Theoretical         *t,
//                                      GCancellable        *c,
//                                      GAsyncReadyCallback  cb,
//                                      gpointer             u);
// 
//    gboolean _theoretical_frobnitz_finish (Theoretical   *t,
//                                           GAsyncResult  *res,
//                                           GError       **e);
// 
//    static void
//    frobnitz_result_func (GObject      *source_object,
//    		 GAsyncResult *res,
//    		 gpointer      user_data)
//    {
//      gboolean success = FALSE;
// 
//      success = _theoretical_frobnitz_finish (source_object, res, NULL);
// 
//      if (success)
//        g_printf ("Hurray!\n");
//      else
//        g_printf ("Uh oh!\n");
// 
//      ...
// 
//    }
// 
//    int main (int argc, void *argv[])
//    {
//       ...
// 
//       _theoretical_frobnitz_async (theoretical_data,
//                                    NULL,
//                                    frobnitz_result_func,
//                                    NULL);
// 
//       ...
//    }
// 
// The callback for an asynchronous operation is called only once, and is always
// called, even in the case of a cancelled operation. On cancellation the result
// is a G_IO_ERROR_CANCELLED error.
// 
// I/O Priority
// 
// Many I/O-related asynchronous operations have a priority parameter, which is
// used in certain cases to determine the order in which operations are
// executed. They are not used to determine system-wide I/O scheduling.
// Priorities are integers, with lower numbers indicating higher priority. It is
// recommended to choose priorities between G_PRIORITY_LOW and G_PRIORITY_HIGH,
// with G_PRIORITY_DEFAULT as a default.
	type AsyncResult struct {
		**externglib.Object
		
	}

	
	func marshalAsyncResult(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {AsyncResult{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// SourceObject gets the source object from a Result.
	func (r AsyncResult) SourceObject() **externglib.Object {
var _arg0 *C.GAsyncResult // out
var _cret *C.GObject // in

_arg0 = (*C.GAsyncResult)(unsafe.Pointer(r.Native()))

_cret = C.g_async_result_get_source_object(_arg0)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// LegacyPropagateError: if @res is a AsyncResult, this is equivalent to
// g_simple_async_result_propagate_error(). Otherwise it returns false.
// 
// This can be used for legacy error handling in async *_finish() wrapper
// functions that traditionally handled AsyncResult error returns themselves
// rather than calling into the virtual method. This should not be used in new
// code; Result errors that are set by virtual methods should also be extracted
// by virtual methods, to enable subclasses to chain up correctly.
	func (r AsyncResult) LegacyPropagateError() error {
var _arg0 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GAsyncResult)(unsafe.Pointer(r.Native()))

C.g_async_result_legacy_propagate_error(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	
	// ConverterInterface contains virtual methods for Converter, or
	// methods that can be overridden.
	type ConverterInterface interface {
		gextras.Objector

			// Convert: this is the main operation used when converting data. It is to
	// be called multiple times in a loop, and each time it will do some work,
	// i.e. producing some output (in @outbuf) or consuming some input (from
	// @inbuf) or both. If its not possible to do any work an error is returned.
	// 
	// Note that a single call may not consume all input (or any input at all).
	// Also a call may produce output even if given no input, due to state
	// stored in the converter producing output.
	// 
	// If any data was either produced or consumed, and then an error happens,
	// then only the successful conversion is reported and the error is returned
	// on the next call.
	// 
	// A full conversion loop involves calling this method repeatedly, each time
	// giving it new input and space output space. When there is no more input
	// data after the data in @inbuf, the flag G_CONVERTER_INPUT_AT_END must be
	// set. The loop will be (unless some error happens) returning
	// G_CONVERTER_CONVERTED each time until all data is consumed and all output
	// is produced, then G_CONVERTER_FINISHED is returned instead. Note, that
	// G_CONVERTER_FINISHED may be returned even if G_CONVERTER_INPUT_AT_END is
	// not set, for instance in a decompression converter where the end of data
	// is detectable from the data (and there might even be other data after the
	// end of the compressed data).
	// 
	// When some data has successfully been converted @bytes_read and is set to
	// the number of bytes read from @inbuf, and @bytes_written is set to
	// indicate how many bytes was written to @outbuf. If there are more data to
	// output or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified)
	// then G_CONVERTER_CONVERTED is returned, and if no more data is to be
	// output then G_CONVERTER_FINISHED is returned.
	// 
	// On error G_CONVERTER_ERROR is returned and @error is set accordingly.
	// Some errors need special handling:
	// 
	// G_IO_ERROR_NO_SPACE is returned if there is not enough space to write the
	// resulting converted data, the application should call the function again
	// with a larger @outbuf to continue.
	// 
	// G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough input to
	// fully determine what the conversion should produce, and the
	// G_CONVERTER_INPUT_AT_END flag is not set. This happens for example with
	// an incomplete multibyte sequence when converting text, or when a regexp
	// matches up to the end of the input (and may match further input). It may
	// also happen when @inbuf_size is zero and there is no more data to
	// produce.
	// 
	// When this happens the application should read more input and then call
	// the function again. If further input shows that there is no more data
	// call the function again with the same data but with the
	// G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion to
	// finish as e.g. in the regexp match case (or, to fail again with
	// G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the input is
	// actually partial).
	// 
	// After g_converter_convert() has returned G_CONVERTER_FINISHED the
	// converter object is in an invalid state where its not allowed to call
	// g_converter_convert() anymore. At this time you can only free the object
	// or call g_converter_reset() to reset it to the initial state.
	// 
	// If the flag G_CONVERTER_FLUSH is set then conversion is modified to try
	// to write out all internal state to the output. The application has to
	// call the function multiple times with the flag set, and when the
	// available input has been consumed and all internal state has been
	// produced then G_CONVERTER_FLUSHED (or G_CONVERTER_FINISHED if really at
	// the end) is returned instead of G_CONVERTER_CONVERTED. This is somewhat
	// similar to what happens at the end of the input stream, but done in the
	// middle of the data.
	// 
	// This has different meanings for different conversions. For instance in a
	// compression converter it would mean that we flush all the compression
	// state into output such that if you uncompress the compressed data you get
	// back all the input data. Doing this may make the final file larger due to
	// padding though. Another example is a regexp conversion, where if you at
	// the end of the flushed data have a match, but there is also a potential
	// longer match. In the non-flushed case we would ask for more input, but
	// when flushing we treat this as the end of input and do the match.
	// 
	// Flushing is not always possible (like if a charset converter flushes at a
	// partial multibyte sequence). Converters are supposed to try to produce as
	// much output as possible and then return an error (typically
	// G_IO_ERROR_PARTIAL_INPUT).
		Convert(inbuf []byte, outbuf []byte, flags ConverterFlags) (bytesRead uint, bytesWritten uint, converterResult ConverterResult, goerr error)
			// Reset resets all internal state in the converter, making it behave as if
	// it was just created. If the converter has any internal state that would
	// produce output then that output is lost.
		Reset() 
		
	}
	

	// Converter is implemented by objects that convert binary data in various ways.
// The conversion can be stateful and may fail at any place.
// 
// Some example conversions are: character set conversion, compression,
// decompression and regular expression replace.
	type Converter struct {
		**externglib.Object
		
	}

	
	func marshalConverter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Converter{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Convert: this is the main operation used when converting data. It is to be
// called multiple times in a loop, and each time it will do some work, i.e.
// producing some output (in @outbuf) or consuming some input (from @inbuf) or
// both. If its not possible to do any work an error is returned.
// 
// Note that a single call may not consume all input (or any input at all). Also
// a call may produce output even if given no input, due to state stored in the
// converter producing output.
// 
// If any data was either produced or consumed, and then an error happens, then
// only the successful conversion is reported and the error is returned on the
// next call.
// 
// A full conversion loop involves calling this method repeatedly, each time
// giving it new input and space output space. When there is no more input data
// after the data in @inbuf, the flag G_CONVERTER_INPUT_AT_END must be set. The
// loop will be (unless some error happens) returning G_CONVERTER_CONVERTED each
// time until all data is consumed and all output is produced, then
// G_CONVERTER_FINISHED is returned instead. Note, that G_CONVERTER_FINISHED may
// be returned even if G_CONVERTER_INPUT_AT_END is not set, for instance in a
// decompression converter where the end of data is detectable from the data
// (and there might even be other data after the end of the compressed data).
// 
// When some data has successfully been converted @bytes_read and is set to the
// number of bytes read from @inbuf, and @bytes_written is set to indicate how
// many bytes was written to @outbuf. If there are more data to output or
// consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified) then
// G_CONVERTER_CONVERTED is returned, and if no more data is to be output then
// G_CONVERTER_FINISHED is returned.
// 
// On error G_CONVERTER_ERROR is returned and @error is set accordingly. Some
// errors need special handling:
// 
// G_IO_ERROR_NO_SPACE is returned if there is not enough space to write the
// resulting converted data, the application should call the function again with
// a larger @outbuf to continue.
// 
// G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough input to fully
// determine what the conversion should produce, and the
// G_CONVERTER_INPUT_AT_END flag is not set. This happens for example with an
// incomplete multibyte sequence when converting text, or when a regexp matches
// up to the end of the input (and may match further input). It may also happen
// when @inbuf_size is zero and there is no more data to produce.
// 
// When this happens the application should read more input and then call the
// function again. If further input shows that there is no more data call the
// function again with the same data but with the G_CONVERTER_INPUT_AT_END flag
// set. This may cause the conversion to finish as e.g. in the regexp match case
// (or, to fail again with G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion
// where the input is actually partial).
// 
// After g_converter_convert() has returned G_CONVERTER_FINISHED the converter
// object is in an invalid state where its not allowed to call
// g_converter_convert() anymore. At this time you can only free the object or
// call g_converter_reset() to reset it to the initial state.
// 
// If the flag G_CONVERTER_FLUSH is set then conversion is modified to try to
// write out all internal state to the output. The application has to call the
// function multiple times with the flag set, and when the available input has
// been consumed and all internal state has been produced then
// G_CONVERTER_FLUSHED (or G_CONVERTER_FINISHED if really at the end) is
// returned instead of G_CONVERTER_CONVERTED. This is somewhat similar to what
// happens at the end of the input stream, but done in the middle of the data.
// 
// This has different meanings for different conversions. For instance in a
// compression converter it would mean that we flush all the compression state
// into output such that if you uncompress the compressed data you get back all
// the input data. Doing this may make the final file larger due to padding
// though. Another example is a regexp conversion, where if you at the end of
// the flushed data have a match, but there is also a potential longer match. In
// the non-flushed case we would ask for more input, but when flushing we treat
// this as the end of input and do the match.
// 
// Flushing is not always possible (like if a charset converter flushes at a
// partial multibyte sequence). Converters are supposed to try to produce as
// much output as possible and then return an error (typically
// G_IO_ERROR_PARTIAL_INPUT).
	func (c Converter) Convert(inbuf []byte, outbuf []byte, flags ConverterFlags) (bytesRead uint, bytesWritten uint, converterResult ConverterResult, goerr error) {
var _arg0 *C.GConverter // out
var _arg1 *C.void
var _arg2 C.gsize
var _arg3 *C.void
var _arg4 C.gsize
var _arg5 C.GConverterFlags // out
var _arg6 C.gsize // in
var _arg7 C.gsize // in
var _cret C.GConverterResult // in
var _cerr *C.GError // in

_arg0 = (*C.GConverter)(unsafe.Pointer(c.Native()))
_arg2 = C.gsize(len(inbuf))
_arg1 = (*C.void)(unsafe.Pointer(&inbuf[0]))
_arg4 = C.gsize(len(outbuf))
_arg3 = (*C.void)(unsafe.Pointer(&outbuf[0]))
_arg5 = (C.GConverterFlags)(flags)

_cret = C.g_converter_convert(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, &_arg7, &_cerr)


var _bytesRead uint // out
var _bytesWritten uint // out
var _converterResult ConverterResult // out
var _goerr error // out

_bytesRead = (uint)(_arg6)
_bytesWritten = (uint)(_arg7)
_converterResult = ConverterResult(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesRead, _bytesWritten, _converterResult, _goerr
}
	
	// Reset resets all internal state in the converter, making it behave as if it
// was just created. If the converter has any internal state that would produce
// output then that output is lost.
	func (c Converter) Reset()  {
var _arg0 *C.GConverter // out

_arg0 = (*C.GConverter)(unsafe.Pointer(c.Native()))

C.g_converter_reset(_arg0)
}
	


	
	// DBusInterfaceInterface contains virtual methods for DBusInterface, or
	// methods that can be overridden.
	type DBusInterfaceInterface interface {
		gextras.Objector

			// DupObject gets the BusObject that @interface_ belongs to, if any.
		DupObject() DBusObject
			// Info gets D-Bus introspection information for the D-Bus interface
	// implemented by @interface_.
		Info() *DBusInterfaceInfo
			// SetObject sets the BusObject for @interface_ to @object.
	// 
	// Note that @interface_ will hold a weak reference to @object.
		SetObject(object DBusObject) 
		
	}
	

	// DBusInterface: the BusInterface type is the base type for D-Bus interfaces
// both on the service side (see BusInterfaceSkeleton) and client side (see
// BusProxy).
	type DBusInterface struct {
		**externglib.Object
		
	}

	
	func marshalDBusInterface(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {DBusInterface{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// DupObject gets the BusObject that @interface_ belongs to, if any.
	func (i DBusInterface) DupObject() DBusObject {
var _arg0 *C.GDBusInterface // out
var _cret *C.GDBusObject // in

_arg0 = (*C.GDBusInterface)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_interface_dup_object(_arg0)


var _dBusObject DBusObject // out

_dBusObject = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusObject)

return _dBusObject
}
	
	// Info gets D-Bus introspection information for the D-Bus interface implemented
// by @interface_.
	func (i DBusInterface) Info() *DBusInterfaceInfo {
var _arg0 *C.GDBusInterface // out
var _cret *C.GDBusInterfaceInfo // in

_arg0 = (*C.GDBusInterface)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_interface_get_info(_arg0)


var _dBusInterfaceInfo *DBusInterfaceInfo // out

_dBusInterfaceInfo = *(**DBusInterfaceInfo)(unsafe.Pointer(&_cret))

return _dBusInterfaceInfo
}
	
	// SetObject sets the BusObject for @interface_ to @object.
// 
// Note that @interface_ will hold a weak reference to @object.
	func (i DBusInterface) SetObject(object DBusObject)  {
var _arg0 *C.GDBusInterface // out
var _arg1 *C.GDBusObject // out

_arg0 = (*C.GDBusInterface)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GDBusObject)(unsafe.Pointer(object.Native()))

C.g_dbus_interface_set_object(_arg0, _arg1)
}
	


	
	// DBusObjectInterface contains virtual methods for DBusObject, or
	// methods that can be overridden.
	type DBusObjectInterface interface {
		gextras.Objector

			// Interface gets the D-Bus interface with name @interface_name associated
	// with @object, if any.
		Interface(interfaceName string) DBusInterface
			// ObjectPath gets the object path for @object.
		ObjectPath() string
		
		InterfaceAdded(interface_ DBusInterface) 
		
		InterfaceRemoved(interface_ DBusInterface) 
		
	}
	

	// DBusObject: the BusObject type is the base type for D-Bus objects on both the
// service side (see BusObjectSkeleton) and the client side (see
// BusObjectProxy). It is essentially just a container of interfaces.
	type DBusObject struct {
		**externglib.Object
		
	}

	
	func marshalDBusObject(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {DBusObject{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Interface gets the D-Bus interface with name @interface_name associated with
// @object, if any.
	func (o DBusObject) Interface(interfaceName string) DBusInterface {
var _arg0 *C.GDBusObject // out
var _arg1 *C.gchar // out
var _cret *C.GDBusInterface // in

_arg0 = (*C.GDBusObject)(unsafe.Pointer(o.Native()))
_arg1 = (*C.gchar)(C.CString(interfaceName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_object_get_interface(_arg0, _arg1)


var _dBusInterface DBusInterface // out

_dBusInterface = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusInterface)

return _dBusInterface
}
	
	// ObjectPath gets the object path for @object.
	func (o DBusObject) ObjectPath() string {
var _arg0 *C.GDBusObject // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusObject)(unsafe.Pointer(o.Native()))

_cret = C.g_dbus_object_get_object_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	


	
	// DBusObjectManagerInterface contains virtual methods for DBusObjectManager, or
	// methods that can be overridden.
	type DBusObjectManagerInterface interface {
		gextras.Objector

			// Interface gets the interface proxy for @interface_name at @object_path,
	// if any.
		Interface(objectPath string, interfaceName string) DBusInterface
			// Object gets the BusObjectProxy at @object_path, if any.
		Object(objectPath string) DBusObject
			// ObjectPath gets the object path that @manager is for.
		ObjectPath() string
		
		InterfaceAdded(object DBusObject, interface_ DBusInterface) 
		
		InterfaceRemoved(object DBusObject, interface_ DBusInterface) 
		
		ObjectAdded(object DBusObject) 
		
		ObjectRemoved(object DBusObject) 
		
	}
	

	// DBusObjectManager: the BusObjectManager type is the base type for service-
// and client-side implementations of the standardized
// org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface.
// 
// See BusObjectManagerClient for the client-side implementation and
// BusObjectManagerServer for the service-side implementation.
	type DBusObjectManager struct {
		**externglib.Object
		
	}

	
	func marshalDBusObjectManager(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {DBusObjectManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Interface gets the interface proxy for @interface_name at @object_path, if
// any.
	func (m DBusObjectManager) Interface(objectPath string, interfaceName string) DBusInterface {
var _arg0 *C.GDBusObjectManager // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret *C.GDBusInterface // in

_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(interfaceName))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_dbus_object_manager_get_interface(_arg0, _arg1, _arg2)


var _dBusInterface DBusInterface // out

_dBusInterface = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusInterface)

return _dBusInterface
}
	
	// Object gets the BusObjectProxy at @object_path, if any.
	func (m DBusObjectManager) Object(objectPath string) DBusObject {
var _arg0 *C.GDBusObjectManager // out
var _arg1 *C.gchar // out
var _cret *C.GDBusObject // in

_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_object_manager_get_object(_arg0, _arg1)


var _dBusObject DBusObject // out

_dBusObject = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusObject)

return _dBusObject
}
	
	// ObjectPath gets the object path that @manager is for.
	func (m DBusObjectManager) ObjectPath() string {
var _arg0 *C.GDBusObjectManager // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_object_manager_get_object_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	


	
	// DatagramBasedInterface contains virtual methods for DatagramBased, or
	// methods that can be overridden.
	type DatagramBasedInterface interface {
		gextras.Objector

			// ConditionCheck checks on the readiness of @datagram_based to perform
	// operations. The operations specified in @condition are checked for and
	// masked against the currently-satisfied conditions on @datagram_based. The
	// result is returned.
	// 
	// G_IO_IN will be set in the return value if data is available to read with
	// g_datagram_based_receive_messages(), or if the connection is closed
	// remotely (EOS); and if the datagram_based has not been closed locally
	// using some implementation-specific method (such as g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if its a #GSocket).
	// 
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if its a #GSocket, for
	// example), all calls to this function will return G_IO_ERROR_CLOSED.
	// 
	// G_IO_OUT will be set if it is expected that at least one byte can be sent
	// using g_datagram_based_send_messages() without blocking. It will not be
	// set if the datagram_based has been closed locally.
	// 
	// G_IO_HUP will be set if the connection has been closed locally.
	// 
	// G_IO_ERR will be set if there was an asynchronous error in transmitting
	// data previously enqueued using g_datagram_based_send_messages().
	// 
	// Note that on Windows, it is possible for an operation to return
	// G_IO_ERROR_WOULD_BLOCK even immediately after
	// g_datagram_based_condition_check() has claimed that the Based is ready
	// for writing. Rather than calling g_datagram_based_condition_check() and
	// then writing to the Based if it succeeds, it is generally better to
	// simply try writing right away, and try again later if the initial attempt
	// returns G_IO_ERROR_WOULD_BLOCK.
	// 
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in @condition; these
	// conditions will always be set in the output if they are true. Apart from
	// these flags, the output is guaranteed to be masked by @condition.
	// 
	// This call never blocks.
		ConditionCheck(condition glib.IOCondition) glib.IOCondition
			// ConditionWait waits for up to @timeout microseconds for condition to
	// become true on @datagram_based. If the condition is met, true is
	// returned.
	// 
	// If @cancellable is cancelled before the condition is met, or if @timeout
	// is reached before the condition is met, then false is returned and @error
	// is set appropriately (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
		ConditionWait(condition glib.IOCondition, timeout int64, cancellable CancellableClass) error
			// ReceiveMessages: receive one or more data messages from @datagram_based
	// in one go.
	// 
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains a pointer to an
	// array of Vector structs describing the buffers that the data received in
	// each message will be written to.
	// 
	// @flags modify how all messages are received. The commonly available
	// arguments for this are available in the MsgFlags enum, but the values
	// there are the same as the system values, and the flags are passed in
	// as-is, so you can pass in system-specific flags too. These flags affect
	// the overall receive operation. Flags affecting individual messages are
	// returned in Message.flags.
	// 
	// The other members of Message are treated as described in its
	// documentation.
	// 
	// If @timeout is negative the call will block until @num_messages have been
	// received, the connection is closed remotely (EOS), @cancellable is
	// cancelled, or an error occurs.
	// 
	// If @timeout is 0 the call will return up to @num_messages without
	// blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
	// operating system to be received.
	// 
	// If @timeout is positive the call will block on the same conditions as if
	// @timeout were negative. If the timeout is reached before any messages are
	// received, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the
	// number of messages received before timing out. (Note: This is effectively
	// the behaviour of `MSG_WAITFORONE` with recvmmsg().)
	// 
	// To be notified when messages are available, wait for the G_IO_IN
	// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
	// from g_datagram_based_receive_messages() even if you were previously
	// notified of a G_IO_IN condition.
	// 
	// If the remote peer closes the connection, any messages queued in the
	// underlying receive buffer will be returned, and subsequent calls to
	// g_datagram_based_receive_messages() will return 0 (with no error set).
	// 
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if its a #GSocket, for
	// example), all calls to this function will return G_IO_ERROR_CLOSED.
	// 
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be received; otherwise the number of
	// messages successfully received before the error will be returned. If
	// @cancellable is cancelled, G_IO_ERROR_CANCELLED is returned as with any
	// other error.
		ReceiveMessages(messages []InputMessage, flags int, timeout int64, cancellable CancellableClass) (int, error)
			// SendMessages: send one or more data messages from @datagram_based in one
	// go.
	// 
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains an address to
	// send the data to, and a pointer to an array of Vector structs to describe
	// the buffers that the data to be sent for each message will be gathered
	// from.
	// 
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the MsgFlags enum, but the values there are the
	// same as the system values, and the flags are passed in as-is, so you can
	// pass in system-specific flags too.
	// 
	// The other members of Message are treated as described in its
	// documentation.
	// 
	// If @timeout is negative the call will block until @num_messages have been
	// sent, @cancellable is cancelled, or an error occurs.
	// 
	// If @timeout is 0 the call will send up to @num_messages without blocking,
	// or will return G_IO_ERROR_WOULD_BLOCK if there is no space to send
	// messages.
	// 
	// If @timeout is positive the call will block on the same conditions as if
	// @timeout were negative. If the timeout is reached before any messages are
	// sent, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the
	// number of messages sent before timing out.
	// 
	// To be notified when messages can be sent, wait for the G_IO_OUT
	// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
	// from g_datagram_based_send_messages() even if you were previously
	// notified of a G_IO_OUT condition. (On Windows in particular, this is very
	// common due to the way the underlying APIs work.)
	// 
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_write set, if its a #GSocket, for
	// example), all calls to this function will return G_IO_ERROR_CLOSED.
	// 
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be sent; otherwise the number of
	// messages successfully sent before the error will be returned. If
	// @cancellable is cancelled, G_IO_ERROR_CANCELLED is returned as with any
	// other error.
		SendMessages(messages []OutputMessage, flags int, timeout int64, cancellable CancellableClass) (int, error)
		
	}
	

	// DatagramBased: a Based is a networking interface for representing
// datagram-based communications. It is a more or less direct mapping of the
// core parts of the BSD socket API in a portable GObject interface. It is
// implemented by #GSocket, which wraps the UNIX socket API on UNIX and winsock2
// on Windows.
// 
// Based is entirely platform independent, and is intended to be used alongside
// higher-level networking APIs such as OStream.
// 
// It uses vectored scatter/gather I/O by default, allowing for many messages to
// be sent or received in a single call. Where possible, implementations of the
// interface should take advantage of vectored I/O to minimise processing or
// system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
// possible. Callers should take advantage of scatter/gather I/O (the use of
// multiple buffers per message) to avoid unnecessary copying of data to
// assemble or disassemble a message.
// 
// Each Based operation has a timeout parameter which may be negative for
// blocking behaviour, zero for non-blocking behaviour, or positive for timeout
// behaviour. A blocking operation blocks until finished or there is an error. A
// non-blocking operation will return immediately with a G_IO_ERROR_WOULD_BLOCK
// error if it cannot make progress. A timeout operation will block until the
// operation is complete or the timeout expires; if the timeout expires it will
// return what progress it made, or G_IO_ERROR_TIMED_OUT if no progress was
// made. To know when a call would successfully run you can call
// g_datagram_based_condition_check() or g_datagram_based_condition_wait(). You
// can also use g_datagram_based_create_source() and attach it to a Context to
// get callbacks when I/O is possible.
// 
// When running a non-blocking operation applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
// 
// As with #GSocket, Baseds can be either connection oriented (for example,
// SCTP) or connectionless (for example, UDP). Baseds must be datagram-based,
// not stream-based. The interface does not cover connection establishment  use
// methods on the underlying type to establish a connection before sending and
// receiving data through the Based API. For connectionless socket types the
// target/source address is specified or received in each I/O operation.
// 
// Like most other APIs in GLib, Based is not inherently thread safe. To use a
// Based concurrently from multiple threads, you must implement your own
// locking.
	type DatagramBased struct {
		**externglib.Object
		
	}

	
	func marshalDatagramBased(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {DatagramBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// ConditionCheck checks on the readiness of @datagram_based to perform
// operations. The operations specified in @condition are checked for and masked
// against the currently-satisfied conditions on @datagram_based. The result is
// returned.
// 
// G_IO_IN will be set in the return value if data is available to read with
// g_datagram_based_receive_messages(), or if the connection is closed remotely
// (EOS); and if the datagram_based has not been closed locally using some
// implementation-specific method (such as g_socket_close() or
// g_socket_shutdown() with @shutdown_read set, if its a #GSocket).
// 
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with @shutdown_read set, if its a #GSocket, for
// example), all calls to this function will return G_IO_ERROR_CLOSED.
// 
// G_IO_OUT will be set if it is expected that at least one byte can be sent
// using g_datagram_based_send_messages() without blocking. It will not be set
// if the datagram_based has been closed locally.
// 
// G_IO_HUP will be set if the connection has been closed locally.
// 
// G_IO_ERR will be set if there was an asynchronous error in transmitting data
// previously enqueued using g_datagram_based_send_messages().
// 
// Note that on Windows, it is possible for an operation to return
// G_IO_ERROR_WOULD_BLOCK even immediately after
// g_datagram_based_condition_check() has claimed that the Based is ready for
// writing. Rather than calling g_datagram_based_condition_check() and then
// writing to the Based if it succeeds, it is generally better to simply try
// writing right away, and try again later if the initial attempt returns
// G_IO_ERROR_WOULD_BLOCK.
// 
// It is meaningless to specify G_IO_ERR or G_IO_HUP in @condition; these
// conditions will always be set in the output if they are true. Apart from
// these flags, the output is guaranteed to be masked by @condition.
// 
// This call never blocks.
	func (d DatagramBased) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
var _arg0 *C.GDatagramBased // out
var _arg1 C.GIOCondition // out
var _cret C.GIOCondition // in

_arg0 = (*C.GDatagramBased)(unsafe.Pointer(d.Native()))
_arg1 = (C.GIOCondition)(condition)

_cret = C.g_datagram_based_condition_check(_arg0, _arg1)


var _ioCondition glib.IOCondition // out

_ioCondition = glib.IOCondition(_cret)

return _ioCondition
}
	
	// ConditionWait waits for up to @timeout microseconds for condition to become
// true on @datagram_based. If the condition is met, true is returned.
// 
// If @cancellable is cancelled before the condition is met, or if @timeout is
// reached before the condition is met, then false is returned and @error is set
// appropriately (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	func (d DatagramBased) ConditionWait(condition glib.IOCondition, timeout int64, cancellable CancellableClass) error {
var _arg0 *C.GDatagramBased // out
var _arg1 C.GIOCondition // out
var _arg2 C.gint64 // out
var _arg3 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDatagramBased)(unsafe.Pointer(d.Native()))
_arg1 = (C.GIOCondition)(condition)
_arg2 = (C.gint64)(timeout)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_datagram_based_condition_wait(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ReceiveMessages: receive one or more data messages from @datagram_based in
// one go.
// 
// @messages must point to an array of Message structs and @num_messages must be
// the length of this array. Each Message contains a pointer to an array of
// Vector structs describing the buffers that the data received in each message
// will be written to.
// 
// @flags modify how all messages are received. The commonly available arguments
// for this are available in the MsgFlags enum, but the values there are the
// same as the system values, and the flags are passed in as-is, so you can pass
// in system-specific flags too. These flags affect the overall receive
// operation. Flags affecting individual messages are returned in Message.flags.
// 
// The other members of Message are treated as described in its documentation.
// 
// If @timeout is negative the call will block until @num_messages have been
// received, the connection is closed remotely (EOS), @cancellable is cancelled,
// or an error occurs.
// 
// If @timeout is 0 the call will return up to @num_messages without blocking,
// or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
// to be received.
// 
// If @timeout is positive the call will block on the same conditions as if
// @timeout were negative. If the timeout is reached before any messages are
// received, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the
// number of messages received before timing out. (Note: This is effectively the
// behaviour of `MSG_WAITFORONE` with recvmmsg().)
// 
// To be notified when messages are available, wait for the G_IO_IN condition.
// Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_datagram_based_receive_messages() even if you were previously notified of a
// G_IO_IN condition.
// 
// If the remote peer closes the connection, any messages queued in the
// underlying receive buffer will be returned, and subsequent calls to
// g_datagram_based_receive_messages() will return 0 (with no error set).
// 
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with @shutdown_read set, if its a #GSocket, for
// example), all calls to this function will return G_IO_ERROR_CLOSED.
// 
// On error -1 is returned and @error is set accordingly. An error will only be
// returned if zero messages could be received; otherwise the number of messages
// successfully received before the error will be returned. If @cancellable is
// cancelled, G_IO_ERROR_CANCELLED is returned as with any other error.
	func (d DatagramBased) ReceiveMessages(messages []InputMessage, flags int, timeout int64, cancellable CancellableClass) (int, error) {
var _arg0 *C.GDatagramBased // out
var _arg1 *C.GInputMessage
var _arg2 C.guint
var _arg3 C.gint // out
var _arg4 C.gint64 // out
var _arg5 *C.GCancellable // out
var _cret C.gint // in
var _cerr *C.GError // in

_arg0 = (*C.GDatagramBased)(unsafe.Pointer(d.Native()))
_arg2 = C.guint(len(messages))
_arg1 = (*C.GInputMessage)(unsafe.Pointer(&messages[0]))
_arg3 = (C.gint)(flags)
_arg4 = (C.gint64)(timeout)
_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_datagram_based_receive_messages(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// SendMessages: send one or more data messages from @datagram_based in one go.
// 
// @messages must point to an array of Message structs and @num_messages must be
// the length of this array. Each Message contains an address to send the data
// to, and a pointer to an array of Vector structs to describe the buffers that
// the data to be sent for each message will be gathered from.
// 
// @flags modify how the message is sent. The commonly available arguments for
// this are available in the MsgFlags enum, but the values there are the same as
// the system values, and the flags are passed in as-is, so you can pass in
// system-specific flags too.
// 
// The other members of Message are treated as described in its documentation.
// 
// If @timeout is negative the call will block until @num_messages have been
// sent, @cancellable is cancelled, or an error occurs.
// 
// If @timeout is 0 the call will send up to @num_messages without blocking, or
// will return G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
// 
// If @timeout is positive the call will block on the same conditions as if
// @timeout were negative. If the timeout is reached before any messages are
// sent, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
// of messages sent before timing out.
// 
// To be notified when messages can be sent, wait for the G_IO_OUT condition.
// Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_datagram_based_send_messages() even if you were previously notified of a
// G_IO_OUT condition. (On Windows in particular, this is very common due to the
// way the underlying APIs work.)
// 
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with @shutdown_write set, if its a #GSocket, for
// example), all calls to this function will return G_IO_ERROR_CLOSED.
// 
// On error -1 is returned and @error is set accordingly. An error will only be
// returned if zero messages could be sent; otherwise the number of messages
// successfully sent before the error will be returned. If @cancellable is
// cancelled, G_IO_ERROR_CANCELLED is returned as with any other error.
	func (d DatagramBased) SendMessages(messages []OutputMessage, flags int, timeout int64, cancellable CancellableClass) (int, error) {
var _arg0 *C.GDatagramBased // out
var _arg1 *C.GOutputMessage
var _arg2 C.guint
var _arg3 C.gint // out
var _arg4 C.gint64 // out
var _arg5 *C.GCancellable // out
var _cret C.gint // in
var _cerr *C.GError // in

_arg0 = (*C.GDatagramBased)(unsafe.Pointer(d.Native()))
_arg2 = C.guint(len(messages))
_arg1 = (*C.GOutputMessage)(unsafe.Pointer(&messages[0]))
_arg3 = (C.gint)(flags)
_arg4 = (C.gint64)(timeout)
_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_datagram_based_send_messages(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	


	
	// DesktopAppInfoLookupInterface contains virtual methods for DesktopAppInfoLookup, or
	// methods that can be overridden.
	type DesktopAppInfoLookupInterface interface {
		gextras.Objector

			// DefaultForURIScheme gets the default application for launching
	// applications using this URI scheme for a particular AppInfoLookup
	// implementation.
	// 
	// The AppInfoLookup interface and this function is used to implement
	// g_app_info_get_default_for_uri_scheme() backends in a GIO module. There
	// is no reason for applications to use it directly. Applications should use
	// g_app_info_get_default_for_uri_scheme().
		DefaultForURIScheme(uriScheme string) AppInfo
		
	}
	

	// DesktopAppInfoLookup is an opaque data structure and can only be accessed
// using the following functions.
	type DesktopAppInfoLookup struct {
		**externglib.Object
		
	}

	
	func marshalDesktopAppInfoLookup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {DesktopAppInfoLookup{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// DefaultForURIScheme gets the default application for launching applications
// using this URI scheme for a particular AppInfoLookup implementation.
// 
// The AppInfoLookup interface and this function is used to implement
// g_app_info_get_default_for_uri_scheme() backends in a GIO module. There is no
// reason for applications to use it directly. Applications should use
// g_app_info_get_default_for_uri_scheme().
	func (l DesktopAppInfoLookup) DefaultForURIScheme(uriScheme string) AppInfo {
var _arg0 *C.GDesktopAppInfoLookup // out
var _arg1 *C.char // out
var _cret *C.GAppInfo // in

_arg0 = (*C.GDesktopAppInfoLookup)(unsafe.Pointer(l.Native()))
_arg1 = (*C.char)(C.CString(uriScheme))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_desktop_app_info_lookup_get_default_for_uri_scheme(_arg0, _arg1)


var _appInfo AppInfo // out

_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppInfo)

return _appInfo
}
	


	
	// DriveInterface contains virtual methods for Drive, or
	// methods that can be overridden.
	type DriveInterface interface {
		gextras.Objector

			// CanEject checks if a drive can be ejected.
		CanEject() bool
			// CanPollForMedia checks if a drive can be polled for media changes.
		CanPollForMedia() bool
			// CanStart checks if a drive can be started.
		CanStart() bool
			// CanStartDegraded checks if a drive can be started degraded.
		CanStartDegraded() bool
			// CanStop checks if a drive can be stopped.
		CanStop() bool
		
		Changed() 
		
		Disconnected() 
		
		EjectButton() 
			// EjectFinish finishes ejecting a drive.
		EjectFinish(result AsyncResult) error
			// EjectWithOperationFinish finishes ejecting a drive. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
		EjectWithOperationFinish(result AsyncResult) error
			// EnumerateIdentifiers gets the kinds of identifiers that @drive has. Use
	// g_drive_get_identifier() to obtain the identifiers themselves.
		EnumerateIdentifiers() []string
			// Icon gets the icon for @drive.
		Icon() Icon
			// Identifier gets the identifier of the given kind for @drive. The only
	// identifier currently available is DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
		Identifier(kind string) string
			// Name gets the name of @drive.
		Name() string
			// SortKey gets the sort key for @drive, if any.
		SortKey() string
			// StartStopType gets a hint about how a drive can be started/stopped.
		StartStopType() DriveStartStopType
			// SymbolicIcon gets the icon for @drive.
		SymbolicIcon() Icon
			// HasMedia checks if the @drive has media. Note that the OS may not be
	// polling the drive for media changes; see
	// g_drive_is_media_check_automatic() for more details.
		HasMedia() bool
			// HasVolumes: check if @drive has any mountable volumes.
		HasVolumes() bool
			// IsMediaCheckAutomatic checks if @drive is capable of automatically
	// detecting media changes.
		IsMediaCheckAutomatic() bool
			// IsMediaRemovable checks if the @drive supports removable media.
		IsMediaRemovable() bool
			// IsRemovable checks if the #GDrive and/or its media is considered
	// removable by the user. See g_drive_is_media_removable().
		IsRemovable() bool
			// PollForMediaFinish finishes an operation started with
	// g_drive_poll_for_media() on a drive.
		PollForMediaFinish(result AsyncResult) error
			// StartFinish finishes starting a drive.
		StartFinish(result AsyncResult) error
		
		StopButton() 
			// StopFinish finishes stopping a drive.
		StopFinish(result AsyncResult) error
		
	}
	

	// Drive: #GDrive - this represent a piece of hardware connected to the machine.
// It's generally only created for removable hardware or hardware with removable
// media.
// 
// #GDrive is a container class for #GVolume objects that stem from the same
// piece of media. As such, #GDrive abstracts a drive with (or without)
// removable media and provides operations for querying whether media is
// available, determining whether media change is automatically detected and
// ejecting the media.
// 
// If the #GDrive reports that media isn't automatically detected, one can poll
// for media; typically one should not do this periodically as a poll for media
// operation is potentially expensive and may spin up the drive creating noise.
// 
// #GDrive supports starting and stopping drives with authentication support for
// the former. This can be used to support a diverse set of use cases including
// connecting/disconnecting iSCSI devices, powering down external disk
// enclosures and starting/stopping multi-disk devices such as RAID devices.
// Note that the actual semantics and side-effects of starting/stopping a
// #GDrive may vary according to implementation. To choose the correct verbs in
// e.g. a file manager, use g_drive_get_start_stop_type().
// 
// For porting from GnomeVFS note that there is no equivalent of #GDrive in that
// API.
	type Drive struct {
		**externglib.Object
		
	}

	
	func marshalDrive(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Drive{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CanEject checks if a drive can be ejected.
	func (d Drive) CanEject() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_can_eject(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanPollForMedia checks if a drive can be polled for media changes.
	func (d Drive) CanPollForMedia() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_can_poll_for_media(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanStart checks if a drive can be started.
	func (d Drive) CanStart() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_can_start(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanStartDegraded checks if a drive can be started degraded.
	func (d Drive) CanStartDegraded() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_can_start_degraded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanStop checks if a drive can be stopped.
	func (d Drive) CanStop() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_can_stop(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EjectFinish finishes ejecting a drive.
	func (d Drive) EjectFinish(result AsyncResult) error {
var _arg0 *C.GDrive // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_drive_eject_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// EjectWithOperationFinish finishes ejecting a drive. If any errors occurred
// during the operation, @error will be set to contain the errors and false will
// be returned.
	func (d Drive) EjectWithOperationFinish(result AsyncResult) error {
var _arg0 *C.GDrive // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_drive_eject_with_operation_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// EnumerateIdentifiers gets the kinds of identifiers that @drive has. Use
// g_drive_get_identifier() to obtain the identifiers themselves.
	func (d Drive) EnumerateIdentifiers() []string {
var _arg0 *C.GDrive // out
var _cret **C.char

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_enumerate_identifiers(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// Icon gets the icon for @drive.
	func (d Drive) Icon() Icon {
var _arg0 *C.GDrive // out
var _cret *C.GIcon // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_get_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// Identifier gets the identifier of the given kind for @drive. The only
// identifier currently available is DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
	func (d Drive) Identifier(kind string) string {
var _arg0 *C.GDrive // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
_arg1 = (*C.char)(C.CString(kind))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_drive_get_identifier(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Name gets the name of @drive.
	func (d Drive) Name() string {
var _arg0 *C.GDrive // out
var _cret *C.char // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// SortKey gets the sort key for @drive, if any.
	func (d Drive) SortKey() string {
var _arg0 *C.GDrive // out
var _cret *C.gchar // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_get_sort_key(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// StartStopType gets a hint about how a drive can be started/stopped.
	func (d Drive) StartStopType() DriveStartStopType {
var _arg0 *C.GDrive // out
var _cret C.GDriveStartStopType // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_get_start_stop_type(_arg0)


var _driveStartStopType DriveStartStopType // out

_driveStartStopType = DriveStartStopType(_cret)

return _driveStartStopType
}
	
	// SymbolicIcon gets the icon for @drive.
	func (d Drive) SymbolicIcon() Icon {
var _arg0 *C.GDrive // out
var _cret *C.GIcon // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_get_symbolic_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// HasMedia checks if the @drive has media. Note that the OS may not be polling
// the drive for media changes; see g_drive_is_media_check_automatic() for more
// details.
	func (d Drive) HasMedia() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_has_media(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasVolumes: check if @drive has any mountable volumes.
	func (d Drive) HasVolumes() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_has_volumes(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMediaCheckAutomatic checks if @drive is capable of automatically detecting
// media changes.
	func (d Drive) IsMediaCheckAutomatic() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_is_media_check_automatic(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMediaRemovable checks if the @drive supports removable media.
	func (d Drive) IsMediaRemovable() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_is_media_removable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsRemovable checks if the #GDrive and/or its media is considered removable by
// the user. See g_drive_is_media_removable().
	func (d Drive) IsRemovable() bool {
var _arg0 *C.GDrive // out
var _cret C.gboolean // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))

_cret = C.g_drive_is_removable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PollForMediaFinish finishes an operation started with
// g_drive_poll_for_media() on a drive.
	func (d Drive) PollForMediaFinish(result AsyncResult) error {
var _arg0 *C.GDrive // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_drive_poll_for_media_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// StartFinish finishes starting a drive.
	func (d Drive) StartFinish(result AsyncResult) error {
var _arg0 *C.GDrive // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_drive_start_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// StopFinish finishes stopping a drive.
	func (d Drive) StopFinish(result AsyncResult) error {
var _arg0 *C.GDrive // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDrive)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_drive_stop_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	

	// DTLSClientConnection is the client-side subclass of Connection, representing
// a client-side DTLS connection.
	type DTLSClientConnection struct {
		DatagramBased
		DTLSConnection
		
	}

	
	func marshalDTLSClientConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {DTLSClientConnection{
DatagramBased: DatagramBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
DTLSConnection: DTLSConnection{
DatagramBased: DatagramBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// ServerIdentity gets @conn's expected server identity
	func (c DTLSClientConnection) ServerIdentity() SocketConnectable {
var _arg0 *C.GDtlsClientConnection // out
var _cret *C.GSocketConnectable // in

_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_client_connection_get_server_identity(_arg0)


var _socketConnectable SocketConnectable // out

_socketConnectable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SocketConnectable)

return _socketConnectable
}
	
	// ValidationFlags gets @conn's validation flags
	func (c DTLSClientConnection) ValidationFlags() TLSCertificateFlags {
var _arg0 *C.GDtlsClientConnection // out
var _cret C.GTlsCertificateFlags // in

_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_client_connection_get_validation_flags(_arg0)


var _tlsCertificateFlags TLSCertificateFlags // out

_tlsCertificateFlags = TLSCertificateFlags(_cret)

return _tlsCertificateFlags
}
	
	// SetServerIdentity sets @conn's expected server identity, which is used both
// to tell servers on virtual hosts which certificate to present, and also to
// let @conn know what name to look for in the certificate when performing
// G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
	func (c DTLSClientConnection) SetServerIdentity(identity SocketConnectable)  {
var _arg0 *C.GDtlsClientConnection // out
var _arg1 *C.GSocketConnectable // out

_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(identity.Native()))

C.g_dtls_client_connection_set_server_identity(_arg0, _arg1)
}
	
	// SetValidationFlags sets @conn's validation flags, to override the default set
// of checks performed when validating a server certificate. By default,
// G_TLS_CERTIFICATE_VALIDATE_ALL is used.
	func (c DTLSClientConnection) SetValidationFlags(flags TLSCertificateFlags)  {
var _arg0 *C.GDtlsClientConnection // out
var _arg1 C.GTlsCertificateFlags // out

_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.GTlsCertificateFlags)(flags)

C.g_dtls_client_connection_set_validation_flags(_arg0, _arg1)
}
	


	
	// DTLSConnectionInterface contains virtual methods for DTLSConnection, or
	// methods that can be overridden.
	type DTLSConnectionInterface interface {
		gextras.Objector

		
		AcceptCertificate(peerCert TLSCertificateClass, errors TLSCertificateFlags) bool
		
		BindingData(typ TLSChannelBindingType, data []byte) error
			// NegotiatedProtocol gets the name of the application-layer protocol
	// negotiated during the handshake.
	// 
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend does
	// not support ALPN, then this will be nil. See
	// g_dtls_connection_set_advertised_protocols().
		NegotiatedProtocol() string
			// Handshake attempts a TLS handshake on @conn.
	// 
	// On the client side, it is never necessary to call this method; although
	// the connection needs to perform a handshake after connecting, Connection
	// will handle this for you automatically when you try to send or receive
	// data on the connection. You can call g_dtls_connection_handshake()
	// manually if you want to know whether the initial handshake succeeded or
	// failed (as opposed to just immediately trying to use @conn to read or
	// write, in which case, if it fails, it may not be possible to tell if it
	// failed before or after completing the handshake), but beware that servers
	// may reject client authentication after the handshake has completed, so a
	// successful handshake does not indicate the connection will be usable.
	// 
	// Likewise, on the server side, although a handshake is necessary at the
	// beginning of the communication, you do not need to call this function
	// explicitly unless you want clearer error reporting.
	// 
	// Previously, calling g_dtls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was deprecated
	// in GLib 2.60 because rehandshaking was removed from the TLS protocol in
	// TLS 1.3. Since GLib 2.64, calling this function after the initial
	// handshake will no longer do anything.
	// 
	// Connection::accept_certificate may be emitted during the handshake.
		Handshake(cancellable CancellableClass) error
			// HandshakeFinish: finish an asynchronous TLS handshake operation. See
	// g_dtls_connection_handshake() for more information.
		HandshakeFinish(result AsyncResult) error
			// SetAdvertisedProtocols sets the list of application-layer protocols to
	// advertise that the caller is willing to speak on this connection. The
	// Application-Layer Protocol Negotiation (ALPN) extension will be used to
	// negotiate a compatible protocol with the peer; use
	// g_dtls_connection_get_negotiated_protocol() to find the negotiated
	// protocol after the handshake. Specifying nil for the the value of
	// @protocols will disable ALPN negotiation.
	// 
	// See IANA TLS ALPN Protocol IDs
	// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
	// for a list of registered protocol IDs.
		SetAdvertisedProtocols(protocols []string) 
			// Shutdown: shut down part or all of a DTLS connection.
	// 
	// If @shutdown_read is true then the receiving side of the connection is
	// shut down, and further reading is disallowed. Subsequent calls to
	// g_datagram_based_receive_messages() will return G_IO_ERROR_CLOSED.
	// 
	// If @shutdown_write is true then the sending side of the connection is
	// shut down, and further writing is disallowed. Subsequent calls to
	// g_datagram_based_send_messages() will return G_IO_ERROR_CLOSED.
	// 
	// It is allowed for both @shutdown_read and @shutdown_write to be TRUE 
	// this is equivalent to calling g_dtls_connection_close().
	// 
	// If @cancellable is cancelled, the Connection may be left partially-closed
	// and any pending untransmitted data may be lost. Call
	// g_dtls_connection_shutdown() again to complete closing the Connection.
		Shutdown(shutdownRead bool, shutdownWrite bool, cancellable CancellableClass) error
			// ShutdownFinish: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
		ShutdownFinish(result AsyncResult) error
		
	}
	

	// DTLSConnection is the base DTLS connection class type, which wraps a Based
// and provides DTLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side DTLS,
// respectively.
// 
// For TLS support, see Connection.
// 
// As DTLS is datagram based, Connection implements Based, presenting a
// datagram-socket-like API for the encrypted connection. This operates over a
// base datagram connection, which is also a Based (Connection:base-socket).
// 
// To close a DTLS connection, use g_dtls_connection_close().
// 
// Neither ServerConnection or ClientConnection set the peer address on their
// base Based if it is a #GSocket  it is up to the caller to do that if they
// wish. If they do not, and g_socket_close() is called on the base socket, the
// Connection will not raise a G_IO_ERROR_NOT_CONNECTED error on further I/O.
	type DTLSConnection struct {
		DatagramBased
		
	}

	
	func marshalDTLSConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {DTLSConnection{
DatagramBased: DatagramBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Close: close the DTLS connection. This is equivalent to calling
// g_dtls_connection_shutdown() to shut down both sides of the connection.
// 
// Closing a Connection waits for all buffered but untransmitted data to be sent
// before it completes. It then sends a `close_notify` DTLS alert to the peer
// and may wait for a `close_notify` to be received from the peer. It does not
// close the underlying Connection:base-socket; that must be closed separately.
// 
// Once @conn is closed, all other operations will return G_IO_ERROR_CLOSED.
// Closing a Connection multiple times will not return an error.
// 
// Connections will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are released
// as early as possible.
// 
// If @cancellable is cancelled, the Connection may be left partially-closed and
// any pending untransmitted data may be lost. Call g_dtls_connection_close()
// again to complete closing the Connection.
	func (c DTLSConnection) Close(cancellable CancellableClass) error {
var _arg0 *C.GDtlsConnection // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_dtls_connection_close(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CloseFinish: finish an asynchronous TLS close operation. See
// g_dtls_connection_close() for more information.
	func (c DTLSConnection) CloseFinish(result AsyncResult) error {
var _arg0 *C.GDtlsConnection // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_dtls_connection_close_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// EmitAcceptCertificate: used by Connection implementations to emit the
// Connection::accept-certificate signal.
	func (c DTLSConnection) EmitAcceptCertificate(peerCert TLSCertificateClass, errors TLSCertificateFlags) bool {
var _arg0 *C.GDtlsConnection // out
var _arg1 *C.GTlsCertificate // out
var _arg2 C.GTlsCertificateFlags // out
var _cret C.gboolean // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(peerCert.Native()))
_arg2 = (C.GTlsCertificateFlags)(errors)

_cret = C.g_dtls_connection_emit_accept_certificate(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Certificate gets @conn's certificate, as set by
// g_dtls_connection_set_certificate().
	func (c DTLSConnection) Certificate() TLSCertificate {
var _arg0 *C.GDtlsConnection // out
var _cret *C.GTlsCertificate // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_connection_get_certificate(_arg0)


var _tlsCertificate TLSCertificate // out

_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

return _tlsCertificate
}
	
	// ChannelBindingData: query the TLS backend for TLS channel binding data of
// @type for @conn.
// 
// This call retrieves TLS channel binding data as specified in RFC 5056
// (https://tools.ietf.org/html/rfc5056), RFC 5929
// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding data is
// returned in @data. The @data is resized by the callee using Array buffer
// management and will be freed when the @data is destroyed by
// g_byte_array_unref(). If @data is nil, it will only check whether TLS backend
// is able to fetch the data (e.g. whether @type is supported by the TLS
// backend). It does not guarantee that the data will be available though. That
// could happen if TLS connection does not support @type or the binding data is
// not available yet due to additional negotiation or input required.
	func (c DTLSConnection) ChannelBindingData(typ TLSChannelBindingType) ([]byte, error) {
var _arg0 *C.GDtlsConnection // out
var _arg1 C.GTlsChannelBindingType // out
var _arg2 C.GByteArray
var _cerr *C.GError // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.GTlsChannelBindingType)(typ)

C.g_dtls_connection_get_channel_binding_data(_arg0, _arg1, &_arg2, &_cerr)

var _data []byte
var _goerr error // out

{
var i int
var z C.guint8
for p := _arg2; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_arg2, i)
_data = make([]byte, i)
for i := range src {
_data[i] = (byte)(src[i])
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _data, _goerr
}
	
	// Database gets the certificate database that @conn uses to verify peer
// certificates. See g_dtls_connection_set_database().
	func (c DTLSConnection) Database() TLSDatabase {
var _arg0 *C.GDtlsConnection // out
var _cret *C.GTlsDatabase // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_connection_get_database(_arg0)


var _tlsDatabase TLSDatabase // out

_tlsDatabase = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSDatabase)

return _tlsDatabase
}
	
	// Interaction: get the object that will be used to interact with the user. It
// will be used for things like prompting the user for passwords. If nil is
// returned, then no user interaction will occur for this connection.
	func (c DTLSConnection) Interaction() TLSInteraction {
var _arg0 *C.GDtlsConnection // out
var _cret *C.GTlsInteraction // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_connection_get_interaction(_arg0)


var _tlsInteraction TLSInteraction // out

_tlsInteraction = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSInteraction)

return _tlsInteraction
}
	
	// NegotiatedProtocol gets the name of the application-layer protocol negotiated
// during the handshake.
// 
// If the peer did not use the ALPN extension, or did not advertise a protocol
// that matched one of @conn's protocols, or the TLS backend does not support
// ALPN, then this will be nil. See
// g_dtls_connection_set_advertised_protocols().
	func (c DTLSConnection) NegotiatedProtocol() string {
var _arg0 *C.GDtlsConnection // out
var _cret *C.gchar // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_connection_get_negotiated_protocol(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PeerCertificate gets @conn's peer's certificate after the handshake has
// completed or failed. (It is not set during the emission of
// Connection::accept-certificate.)
	func (c DTLSConnection) PeerCertificate() TLSCertificate {
var _arg0 *C.GDtlsConnection // out
var _cret *C.GTlsCertificate // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_connection_get_peer_certificate(_arg0)


var _tlsCertificate TLSCertificate // out

_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

return _tlsCertificate
}
	
	// PeerCertificateErrors gets the errors associated with validating @conn's
// peer's certificate, after the handshake has completed or failed. (It is not
// set during the emission of Connection::accept-certificate.)
	func (c DTLSConnection) PeerCertificateErrors() TLSCertificateFlags {
var _arg0 *C.GDtlsConnection // out
var _cret C.GTlsCertificateFlags // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_connection_get_peer_certificate_errors(_arg0)


var _tlsCertificateFlags TLSCertificateFlags // out

_tlsCertificateFlags = TLSCertificateFlags(_cret)

return _tlsCertificateFlags
}
	
	// RehandshakeMode gets @conn rehandshaking mode. See
// g_dtls_connection_set_rehandshake_mode() for details.
	func (c DTLSConnection) RehandshakeMode() TLSRehandshakeMode {
var _arg0 *C.GDtlsConnection // out
var _cret C.GTlsRehandshakeMode // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_connection_get_rehandshake_mode(_arg0)


var _tlsRehandshakeMode TLSRehandshakeMode // out

_tlsRehandshakeMode = TLSRehandshakeMode(_cret)

return _tlsRehandshakeMode
}
	
	// RequireCloseNotify tests whether or not @conn expects a proper TLS close
// notification when the connection is closed. See
// g_dtls_connection_set_require_close_notify() for details.
	func (c DTLSConnection) RequireCloseNotify() bool {
var _arg0 *C.GDtlsConnection // out
var _cret C.gboolean // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dtls_connection_get_require_close_notify(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Handshake attempts a TLS handshake on @conn.
// 
// On the client side, it is never necessary to call this method; although the
// connection needs to perform a handshake after connecting, Connection will
// handle this for you automatically when you try to send or receive data on the
// connection. You can call g_dtls_connection_handshake() manually if you want
// to know whether the initial handshake succeeded or failed (as opposed to just
// immediately trying to use @conn to read or write, in which case, if it fails,
// it may not be possible to tell if it failed before or after completing the
// handshake), but beware that servers may reject client authentication after
// the handshake has completed, so a successful handshake does not indicate the
// connection will be usable.
// 
// Likewise, on the server side, although a handshake is necessary at the
// beginning of the communication, you do not need to call this function
// explicitly unless you want clearer error reporting.
// 
// Previously, calling g_dtls_connection_handshake() after the initial handshake
// would trigger a rehandshake; however, this usage was deprecated in GLib 2.60
// because rehandshaking was removed from the TLS protocol in TLS 1.3. Since
// GLib 2.64, calling this function after the initial handshake will no longer
// do anything.
// 
// Connection::accept_certificate may be emitted during the handshake.
	func (c DTLSConnection) Handshake(cancellable CancellableClass) error {
var _arg0 *C.GDtlsConnection // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_dtls_connection_handshake(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// HandshakeFinish: finish an asynchronous TLS handshake operation. See
// g_dtls_connection_handshake() for more information.
	func (c DTLSConnection) HandshakeFinish(result AsyncResult) error {
var _arg0 *C.GDtlsConnection // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_dtls_connection_handshake_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAdvertisedProtocols sets the list of application-layer protocols to
// advertise that the caller is willing to speak on this connection. The
// Application-Layer Protocol Negotiation (ALPN) extension will be used to
// negotiate a compatible protocol with the peer; use
// g_dtls_connection_get_negotiated_protocol() to find the negotiated protocol
// after the handshake. Specifying nil for the the value of @protocols will
// disable ALPN negotiation.
// 
// See IANA TLS ALPN Protocol IDs
// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
// for a list of registered protocol IDs.
	func (c DTLSConnection) SetAdvertisedProtocols(protocols []string)  {
var _arg0 *C.GDtlsConnection // out
var _arg1 **C.gchar

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(protocols)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(protocols))
for i := range protocols {
out[i] = (*C.gchar)(C.CString(protocols[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.g_dtls_connection_set_advertised_protocols(_arg0, _arg1)
}
	
	// SetCertificate: this sets the certificate that @conn will present to its peer
// during the TLS handshake. For a ServerConnection, it is mandatory to set
// this, and that will normally be done at construct time.
// 
// For a ClientConnection, this is optional. If a handshake fails with
// G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server requires a
// certificate, and if you try connecting again, you should call this method
// first. You can call g_dtls_client_connection_get_accepted_cas() on the failed
// connection to get a list of Certificate Authorities that the server will
// accept certificates from.
// 
// (It is also possible that a server will allow the connection with or without
// a certificate; in that case, if you don't provide a certificate, you can tell
// that the server requested one by the fact that
// g_dtls_client_connection_get_accepted_cas() will return non-nil.)
	func (c DTLSConnection) SetCertificate(certificate TLSCertificateClass)  {
var _arg0 *C.GDtlsConnection // out
var _arg1 *C.GTlsCertificate // out

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))

C.g_dtls_connection_set_certificate(_arg0, _arg1)
}
	
	// SetDatabase sets the certificate database that is used to verify peer
// certificates. This is set to the default database by default. See
// g_tls_backend_get_default_database(). If set to nil, then peer certificate
// validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
// Connection::accept-certificate will always be emitted on client-side
// connections, unless that bit is not set in
// ClientConnection:validation-flags).
	func (c DTLSConnection) SetDatabase(database TLSDatabaseClass)  {
var _arg0 *C.GDtlsConnection // out
var _arg1 *C.GTlsDatabase // out

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(database.Native()))

C.g_dtls_connection_set_database(_arg0, _arg1)
}
	
	// SetInteraction: set the object that will be used to interact with the user.
// It will be used for things like prompting the user for passwords.
// 
// The @interaction argument will normally be a derived subclass of Interaction.
// nil can also be provided if no user interaction should occur for this
// connection.
	func (c DTLSConnection) SetInteraction(interaction TLSInteractionClass)  {
var _arg0 *C.GDtlsConnection // out
var _arg1 *C.GTlsInteraction // out

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))

C.g_dtls_connection_set_interaction(_arg0, _arg1)
}
	
	// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
// longer supported and will have no effect. With TLS 1.3, rehandshaking has
// been removed from the TLS protocol, replaced by separate post-handshake
// authentication and rekey operations.
	func (c DTLSConnection) SetRehandshakeMode(mode TLSRehandshakeMode)  {
var _arg0 *C.GDtlsConnection // out
var _arg1 C.GTlsRehandshakeMode // out

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.GTlsRehandshakeMode)(mode)

C.g_dtls_connection_set_rehandshake_mode(_arg0, _arg1)
}
	
	// SetRequireCloseNotify sets whether or not @conn expects a proper TLS close
// notification before the connection is closed. If this is true (the default),
// then @conn will expect to receive a TLS close notification from its peer
// before the connection is closed, and will return a G_TLS_ERROR_EOF error if
// the connection is closed without proper notification (since this may indicate
// a network error, or man-in-the-middle attack).
// 
// In some protocols, the application will know whether or not the connection
// was closed cleanly based on application-level data (because the
// application-level data includes a length field, or is somehow
// self-delimiting); in this case, the close notify is redundant and may be
// omitted. You can use g_dtls_connection_set_require_close_notify() to tell
// @conn to allow an "unannounced" connection close, in which case the close
// will show up as a 0-length read, as in a non-TLS Based, and it is up to the
// application to check that the data has been fully received.
// 
// Note that this only affects the behavior when the peer closes the connection;
// when the application calls g_dtls_connection_close_async() on @conn itself,
// this will send a close notification regardless of the setting of this
// property. If you explicitly want to do an unclean close, you can close
// @conn's Connection:base-socket rather than closing @conn itself.
	func (c DTLSConnection) SetRequireCloseNotify(requireCloseNotify bool)  {
var _arg0 *C.GDtlsConnection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
if requireCloseNotify { _arg1 = C.TRUE }

C.g_dtls_connection_set_require_close_notify(_arg0, _arg1)
}
	
	// Shutdown: shut down part or all of a DTLS connection.
// 
// If @shutdown_read is true then the receiving side of the connection is shut
// down, and further reading is disallowed. Subsequent calls to
// g_datagram_based_receive_messages() will return G_IO_ERROR_CLOSED.
// 
// If @shutdown_write is true then the sending side of the connection is shut
// down, and further writing is disallowed. Subsequent calls to
// g_datagram_based_send_messages() will return G_IO_ERROR_CLOSED.
// 
// It is allowed for both @shutdown_read and @shutdown_write to be TRUE  this
// is equivalent to calling g_dtls_connection_close().
// 
// If @cancellable is cancelled, the Connection may be left partially-closed and
// any pending untransmitted data may be lost. Call g_dtls_connection_shutdown()
// again to complete closing the Connection.
	func (c DTLSConnection) Shutdown(shutdownRead bool, shutdownWrite bool, cancellable CancellableClass) error {
var _arg0 *C.GDtlsConnection // out
var _arg1 C.gboolean // out
var _arg2 C.gboolean // out
var _arg3 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
if shutdownRead { _arg1 = C.TRUE }
if shutdownWrite { _arg2 = C.TRUE }
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_dtls_connection_shutdown(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ShutdownFinish: finish an asynchronous TLS shutdown operation. See
// g_dtls_connection_shutdown() for more information.
	func (c DTLSConnection) ShutdownFinish(result AsyncResult) error {
var _arg0 *C.GDtlsConnection // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_dtls_connection_shutdown_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	

	// DTLSServerConnection is the server-side subclass of Connection, representing
// a server-side DTLS connection.
	type DTLSServerConnection struct {
		DatagramBased
		DTLSConnection
		
	}

	
	func marshalDTLSServerConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {DTLSServerConnection{
DatagramBased: DatagramBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
DTLSConnection: DTLSConnection{
DatagramBased: DatagramBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	


	
	// FileInterface contains virtual methods for File, or
	// methods that can be overridden.
	type FileInterface interface {
		gextras.Objector

			// AppendTo gets an output stream for appending data to the file. If the
	// file doesn't already exist it is created.
	// 
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// Some file systems don't allow all file names, and may return an
	// G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
	// G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible
	// too, and depend on what kind of filesystem the file is on.
		AppendTo(flags FileCreateFlags, cancellable CancellableClass) (FileOutputStream, error)
			// AppendToFinish finishes an asynchronous file append operation started
	// with g_file_append_to_async().
		AppendToFinish(res AsyncResult) (FileOutputStream, error)
			// CopyFinish finishes copying the file started with g_file_copy_async().
		CopyFinish(res AsyncResult) error
			// Create creates a new file and returns an output stream for writing to it.
	// The file must not already exist.
	// 
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// If a file or directory with this name already exists the
	// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
	// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
	// if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
	// Other errors are possible too, and depend on what kind of filesystem the
	// file is on.
		Create(flags FileCreateFlags, cancellable CancellableClass) (FileOutputStream, error)
			// CreateFinish finishes an asynchronous file create operation started with
	// g_file_create_async().
		CreateFinish(res AsyncResult) (FileOutputStream, error)
			// CreateReadwrite creates a new file and returns a stream for reading and
	// writing to it. The file must not already exist.
	// 
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// If a file or directory with this name already exists, the
	// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
	// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
	// if the name is too long, G_IO_ERROR_FILENAME_TOO_LONG will be returned.
	// Other errors are possible too, and depend on what kind of filesystem the
	// file is on.
	// 
	// Note that in many non-local file cases read and write streams are not
	// supported, so make sure you really need to do read and write streaming,
	// rather than just opening for reading or writing.
		CreateReadwrite(flags FileCreateFlags, cancellable CancellableClass) (FileIOStream, error)
			// CreateReadwriteFinish finishes an asynchronous file create operation
	// started with g_file_create_readwrite_async().
		CreateReadwriteFinish(res AsyncResult) (FileIOStream, error)
			// DeleteFile deletes a file. If the @file is a directory, it will only be
	// deleted if it is empty. This has the same semantics as g_unlink().
	// 
	// If @file doesnt exist, G_IO_ERROR_NOT_FOUND will be returned. This
	// allows for deletion to be implemented avoiding time-of-check to
	// time-of-use races
	// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
	// 
	//    g_autoptr(GError) local_error = NULL;
	//    if (!g_file_delete (my_file, my_cancellable, &local_error) &&
	//        !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
	//      {
	//        // deletion failed for some reason other than the file not existing:
	//        // so report the error
	//        g_warning ("Failed to delete s: s",
	//                   g_file_peek_path (my_file), local_error->message);
	//      }
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		DeleteFile(cancellable CancellableClass) error
			// DeleteFileFinish finishes deleting a file started with
	// g_file_delete_async().
		DeleteFileFinish(result AsyncResult) error
			// Dup duplicates a #GFile handle. This operation does not duplicate the
	// actual file or directory represented by the #GFile; see g_file_copy() if
	// attempting to copy a file.
	// 
	// g_file_dup() is useful when a second handle is needed to the same
	// underlying file, for use in a separate thread (#GFile is not
	// thread-safe). For use within the same thread, use g_object_ref() to
	// increment the existing objects reference count.
	// 
	// This call does no blocking I/O.
		Dup() File
			// EjectMountableFinish finishes an asynchronous eject operation started by
	// g_file_eject_mountable().
		EjectMountableFinish(result AsyncResult) error
			// EjectMountableWithOperationFinish finishes an asynchronous eject
	// operation started by g_file_eject_mountable_with_operation().
		EjectMountableWithOperationFinish(result AsyncResult) error
			// EnumerateChildren gets the requested information about the files in a
	// directory. The result is a Enumerator object that will give out Info
	// objects for all the files in the directory.
	// 
	// The @attributes value is a string that specifies the file attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "standard::*" means all attributes in the standard namespace. An example
	// attribute query be "standard::*,owner::user". The standard attributes are
	// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is not a directory, the G_IO_ERROR_NOT_DIRECTORY
	// error will be returned. Other errors are possible too.
		EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable CancellableClass) (FileEnumerator, error)
			// EnumerateChildrenFinish finishes an async enumerate children operation.
	// See g_file_enumerate_children_async().
		EnumerateChildrenFinish(res AsyncResult) (FileEnumerator, error)
			// Equal checks if the two given #GFiles refer to the same file.
	// 
	// Note that two #GFiles that differ can still refer to the same file on the
	// filesystem due to various forms of filename aliasing.
	// 
	// This call does no blocking I/O.
		Equal(file2 File) bool
			// FindEnclosingMount gets a #GMount for the #GFile.
	// 
	// #GMount is returned only for user interesting locations, see Monitor. If
	// the Iface for @file does not have a #mount, @error will be set to
	// G_IO_ERROR_NOT_FOUND and nil #will be returned.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		FindEnclosingMount(cancellable CancellableClass) (Mount, error)
			// FindEnclosingMountFinish finishes an asynchronous find mount request. See
	// g_file_find_enclosing_mount_async().
		FindEnclosingMountFinish(res AsyncResult) (Mount, error)
			// Basename gets the base name (the last component of the path) for a given
	// #GFile.
	// 
	// If called for the top level of a system (such as the filesystem root or a
	// uri like sftp://host/) it will return a single directory separator (and
	// on Windows, possibly a drive letter).
	// 
	// The base name is a byte string (not UTF-8). It has no defined encoding or
	// rules other than it may not contain zero bytes. If you want to use
	// filenames in a user interface you should use the display name that you
	// can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
	// attribute with g_file_query_info().
	// 
	// This call does no blocking I/O.
		Basename() string
			// ChildForDisplayName gets the child of @file for a given @display_name
	// (i.e. a UTF-8 version of the name). If this function fails, it returns
	// nil and @error will be set. This is very useful when constructing a
	// #GFile for a new file and the user entered the filename in the user
	// interface, for instance when you select a directory and type a filename
	// in the file selector.
	// 
	// This call does no blocking I/O.
		ChildForDisplayName(displayName string) (File, error)
			// Parent gets the parent directory for the @file. If the @file represents
	// the root directory of the file system, then nil will be returned.
	// 
	// This call does no blocking I/O.
		Parent() File
			// ParseName gets the parse name of the @file. A parse name is a UTF-8
	// string that describes the file such that one can get the #GFile back
	// using g_file_parse_name().
	// 
	// This is generally used to show the #GFile as a nice full-pathname kind of
	// string in a user interface, like in a location entry.
	// 
	// For local files with names that can safely be converted to UTF-8 the
	// pathname is used, otherwise the IRI is used (a form of URI that allows
	// UTF-8 characters unescaped).
	// 
	// This call does no blocking I/O.
		ParseName() string
			// Path gets the local pathname for #GFile, if one exists. If non-nil, this
	// is guaranteed to be an absolute, canonical path. It might contain
	// symlinks.
	// 
	// This call does no blocking I/O.
		Path() string
			// RelativePath gets the path for @descendant relative to @parent.
	// 
	// This call does no blocking I/O.
		RelativePath(descendant File) string
			// URI gets the URI for the @file.
	// 
	// This call does no blocking I/O.
		URI() string
			// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme
	// as:
	// 
	//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
	// 
	// Common schemes include "file", "http", "ftp", etc.
	// 
	// The scheme can be different from the one used to construct the #GFile, in
	// that it might be replaced with one that is logically equivalent to the
	// #GFile.
	// 
	// This call does no blocking I/O.
		URIScheme() string
			// HasURIScheme checks to see if a #GFile has a given URI scheme.
	// 
	// This call does no blocking I/O.
		HasURIScheme(uriScheme string) bool
			// Hash creates a hash value for a #GFile.
	// 
	// This call does no blocking I/O.
		Hash() uint
			// IsNative checks to see if a file is native to the platform.
	// 
	// A native file is one expressed in the platform-native filename format,
	// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
	// as it might be on a locally mounted remote filesystem.
	// 
	// On some systems non-native files may be available using the native
	// filesystem via a userspace filesystem (FUSE), in these cases this call
	// will return false, but g_file_get_path() will still return a native path.
	// 
	// This call does no blocking I/O.
		IsNative() bool
			// MakeDirectory creates a directory. Note that this will only create a
	// child directory of the immediate parent directory of the path or URI
	// given by the #GFile. To recursively create directories, see
	// g_file_make_directory_with_parents(). This function will fail if the
	// parent directory does not exist, setting @error to G_IO_ERROR_NOT_FOUND.
	// If the file system doesn't support creating directories, this function
	// will fail, setting @error to G_IO_ERROR_NOT_SUPPORTED.
	// 
	// For a local #GFile the newly created directory will have the default
	// (current) ownership and permissions of the current process.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		MakeDirectory(cancellable CancellableClass) error
			// MakeDirectoryFinish finishes an asynchronous directory creation, started
	// with g_file_make_directory_async().
		MakeDirectoryFinish(result AsyncResult) error
			// MakeSymbolicLink creates a symbolic link named @file which contains the
	// string @symlink_value.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		MakeSymbolicLink(symlinkValue string, cancellable CancellableClass) error
			// MeasureDiskUsageFinish collects the results from an earlier call to
	// g_file_measure_disk_usage_async(). See g_file_measure_disk_usage() for
	// more information.
		MeasureDiskUsageFinish(result AsyncResult) (diskUsage uint64, numDirs uint64, numFiles uint64, goerr error)
			// MonitorDir obtains a directory monitor for the given file. This may fail
	// if directory monitoring is not supported.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// It does not make sense for @flags to contain
	// G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
	// directories. It is not possible to monitor all the files in a directory
	// for changes made via hard links; if you want to do this then you must
	// register individual watches with g_file_monitor().
		MonitorDir(flags FileMonitorFlags, cancellable CancellableClass) (FileMonitor, error)
			// MonitorFile obtains a file monitor for the given file. If no file
	// notification mechanism exists, then regular polling of the file is used.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// If @flags contains G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor will
	// also attempt to report changes made to the file via another filename (ie,
	// a hard link). Without this flag, you can only rely on changes made
	// through the filename contained in @file to be reported. Using this flag
	// may result in an increase in resource usage, and may not have any effect
	// depending on the Monitor backend and/or filesystem type.
		MonitorFile(flags FileMonitorFlags, cancellable CancellableClass) (FileMonitor, error)
			// MountEnclosingVolumeFinish finishes a mount operation started by
	// g_file_mount_enclosing_volume().
		MountEnclosingVolumeFinish(result AsyncResult) error
			// MountMountableFinish finishes a mount operation. See
	// g_file_mount_mountable() for details.
	// 
	// Finish an asynchronous mount operation that was started with
	// g_file_mount_mountable().
		MountMountableFinish(result AsyncResult) (File, error)
			// OpenReadwrite opens an existing file for reading and writing. The result
	// is a IOStream that can be used to read and write the contents of the
	// file.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
	// will be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on. Note that in many non-local file cases read
	// and write streams are not supported, so make sure you really need to do
	// read and write streaming, rather than just opening for reading or
	// writing.
		OpenReadwrite(cancellable CancellableClass) (FileIOStream, error)
			// OpenReadwriteFinish finishes an asynchronous file read operation started
	// with g_file_open_readwrite_async().
		OpenReadwriteFinish(res AsyncResult) (FileIOStream, error)
			// PollMountableFinish finishes a poll operation. See
	// g_file_poll_mountable() for details.
	// 
	// Finish an asynchronous poll operation that was polled with
	// g_file_poll_mountable().
		PollMountableFinish(result AsyncResult) error
			// PrefixMatches checks whether @file has the prefix specified by @prefix.
	// 
	// In other words, if the names of initial elements of @file's pathname
	// match @prefix. Only full pathname elements are matched, so a path like
	// /foo is not considered a prefix of /foobar, only of /foo/bar.
	// 
	// A #GFile is not a prefix of itself. If you want to check for equality,
	// use g_file_equal().
	// 
	// This call does no I/O, as it works purely on names. As such it can
	// sometimes return false even if @file is inside a @prefix (from a
	// filesystem point of view), because the prefix of @file is an alias of
	// @prefix.
		PrefixMatches(file File) bool
			// QueryFilesystemInfo: similar to g_file_query_info(), but obtains
	// information about the filesystem the @file is on, rather than the file
	// itself. For instance the amount of space available and the type of the
	// filesystem.
	// 
	// The @attributes value is a string that specifies the attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "filesystem::*" means all attributes in the filesystem namespace. The
	// standard namespace for filesystem attributes is "filesystem". Common
	// attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size
	// of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of
	// bytes available), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the
	// filesystem).
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
		QueryFilesystemInfo(attributes string, cancellable CancellableClass) (FileInfo, error)
			// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query.
	// See g_file_query_filesystem_info_async().
		QueryFilesystemInfoFinish(res AsyncResult) (FileInfo, error)
			// QueryInfo gets the requested information about specified @file. The
	// result is a Info object that contains key-value attributes (such as the
	// type or size of the file).
	// 
	// The @attributes value is a string that specifies the file attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "standard::*" means all attributes in the standard namespace. An example
	// attribute query be "standard::*,owner::user". The standard attributes are
	// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// For symlinks, normally the information about the target of the symlink is
	// returned, rather than information about the symlink itself. However if
	// you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in @flags the information
	// about the symlink itself will be returned. Also, for symlinks that point
	// to non-existing files the information about the symlink itself will be
	// returned.
	// 
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
		QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable CancellableClass) (FileInfo, error)
			// QueryInfoFinish finishes an asynchronous file info query. See
	// g_file_query_info_async().
		QueryInfoFinish(res AsyncResult) (FileInfo, error)
			// QuerySettableAttributes: obtain the list of settable attributes for the
	// file.
	// 
	// Returns the type and full attribute name of all the attributes that can
	// be set on this file. This doesn't mean setting it will always succeed
	// though, you might get an access failure, or some specific file may not
	// support a specific attribute.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		QuerySettableAttributes(cancellable CancellableClass) (*FileAttributeInfoList, error)
			// QueryWritableNamespaces: obtain the list of attribute namespaces where
	// new attributes can be created by a user. An example of this is extended
	// attributes (in the "xattr" namespace).
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		QueryWritableNamespaces(cancellable CancellableClass) (*FileAttributeInfoList, error)
			// ReadFinish finishes an asynchronous file read operation started with
	// g_file_read_async().
		ReadFinish(res AsyncResult) (FileInputStream, error)
			// ReadFn opens a file for reading. The result is a InputStream that can be
	// used to read the contents of the file.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
	// will be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on.
		ReadFn(cancellable CancellableClass) (FileInputStream, error)
			// Replace returns an output stream for overwriting the file, possibly
	// creating a backup copy of the file first. If the file doesn't exist, it
	// will be created.
	// 
	// This will try to replace the file in the safest way possible so that any
	// errors during the writing will not affect an already existing copy of the
	// file. For instance, for local files it may write to a temporary file and
	// then atomically rename over the destination when the stream is closed.
	// 
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// 
	// If you pass in a non-nil @etag value and @file already exists, then this
	// value is compared to the current entity tag of the file, and if they
	// differ an G_IO_ERROR_WRONG_ETAG error is returned. This generally means
	// that the file has been changed since you last read it. You can get the
	// new etag from g_file_output_stream_get_etag() after you've finished
	// writing and closed the OutputStream. When you load a new file you can use
	// g_file_input_stream_query_info() to get the etag of the file.
	// 
	// If @make_backup is true, this function will attempt to make a backup of
	// the current file before overwriting it. If this fails a
	// G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you want to
	// replace anyway, try again with @make_backup set to false.
	// 
	// If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be
	// returned, and if the file is some other form of non-regular file then a
	// G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some file systems
	// don't allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME
	// error, and if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
		Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable CancellableClass) (FileOutputStream, error)
			// ReplaceFinish finishes an asynchronous file replace operation started
	// with g_file_replace_async().
		ReplaceFinish(res AsyncResult) (FileOutputStream, error)
			// ReplaceReadwrite returns an output stream for overwriting the file in
	// readwrite mode, possibly creating a backup copy of the file first. If the
	// file doesn't exist, it will be created.
	// 
	// For details about the behaviour, see g_file_replace() which does the same
	// thing but returns an output stream only.
	// 
	// Note that in many non-local file cases read and write streams are not
	// supported, so make sure you really need to do read and write streaming,
	// rather than just opening for reading or writing.
		ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable CancellableClass) (FileIOStream, error)
			// ReplaceReadwriteFinish finishes an asynchronous file replace operation
	// started with g_file_replace_readwrite_async().
		ReplaceReadwriteFinish(res AsyncResult) (FileIOStream, error)
			// ResolveRelativePath resolves a relative path for @file to an absolute
	// path.
	// 
	// This call does no blocking I/O.
		ResolveRelativePath(relativePath string) File
			// SetAttributesFinish finishes setting an attribute started in
	// g_file_set_attributes_async().
		SetAttributesFinish(result AsyncResult) (FileInfo, error)
			// SetAttributesFromInfo tries to set all attributes in the Info on the
	// target values, not stopping on the first error.
	// 
	// If there is any error during this operation then @error will be set to
	// the first error. Error on particular fields are flagged by setting the
	// "status" field in the attribute value to
	// G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect
	// further errors.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		SetAttributesFromInfo(info FileInfoClass, flags FileQueryInfoFlags, cancellable CancellableClass) error
			// SetDisplayName renames @file to the specified display name.
	// 
	// The display name is converted from UTF-8 to the correct encoding for the
	// target filesystem if possible and the @file is renamed to this.
	// 
	// If you want to implement a rename operation in the user interface the
	// edit name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
	// initial value in the rename widget, and then the result after editing
	// should be passed to g_file_set_display_name().
	// 
	// On success the resulting converted filename is returned.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		SetDisplayName(displayName string, cancellable CancellableClass) (File, error)
			// SetDisplayNameFinish finishes setting a display name started with
	// g_file_set_display_name_async().
		SetDisplayNameFinish(res AsyncResult) (File, error)
			// StartMountableFinish finishes a start operation. See
	// g_file_start_mountable() for details.
	// 
	// Finish an asynchronous start operation that was started with
	// g_file_start_mountable().
		StartMountableFinish(result AsyncResult) error
			// StopMountableFinish finishes a stop operation, see
	// g_file_stop_mountable() for details.
	// 
	// Finish an asynchronous stop operation that was started with
	// g_file_stop_mountable().
		StopMountableFinish(result AsyncResult) error
			// Trash sends @file to the "Trashcan", if possible. This is similar to
	// deleting it, but the user can recover it before emptying the trashcan.
	// Not all file systems support trashing, so this call can return the
	// G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash`
	// unix mount option can be used to disable g_file_trash() support for
	// certain mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in
	// that case.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		Trash(cancellable CancellableClass) error
			// TrashFinish finishes an asynchronous file trashing operation, started
	// with g_file_trash_async().
		TrashFinish(result AsyncResult) error
			// UnmountMountableFinish finishes an unmount operation, see
	// g_file_unmount_mountable() for details.
	// 
	// Finish an asynchronous unmount operation that was started with
	// g_file_unmount_mountable().
		UnmountMountableFinish(result AsyncResult) error
			// UnmountMountableWithOperationFinish finishes an unmount operation, see
	// g_file_unmount_mountable_with_operation() for details.
	// 
	// Finish an asynchronous unmount operation that was started with
	// g_file_unmount_mountable_with_operation().
		UnmountMountableWithOperationFinish(result AsyncResult) error
		
	}
	

	// File is a high level abstraction for manipulating files on a virtual file
// system. #GFiles are lightweight, immutable objects that do no I/O upon
// creation. It is necessary to understand that #GFile objects do not represent
// files, merely an identifier for a file. All file content I/O is implemented
// as streaming operations (see Stream and Stream).
// 
// To construct a #GFile, you can use: - g_file_new_for_path() if you have a
// path. - g_file_new_for_uri() if you have a URI. -
// g_file_new_for_commandline_arg() for a command line argument. -
// g_file_new_tmp() to create a temporary file from a template. -
// g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
// - g_file_new_build_filename() to create a file from path elements.
// 
// One way to think of a #GFile is as an abstraction of a pathname. For normal
// files the system pathname is what is stored internally, but as #GFiles are
// extensible it could also be something else that corresponds to a pathname in
// a userspace implementation of a filesystem.
// 
// #GFiles make up hierarchies of directories and files that correspond to the
// files on a filesystem. You can move through the file system with #GFile using
// g_file_get_parent() to get an identifier for the parent directory,
// g_file_get_child() to get a child within a directory,
// g_file_resolve_relative_path() to resolve a relative path between two
// #GFiles. There can be multiple hierarchies, so you may not end up at the same
// root if you repeatedly call g_file_get_parent() on two different files.
// 
// All #GFiles have a basename (get with g_file_get_basename()). These names are
// byte strings that are used to identify the file on the filesystem (relative
// to its parent directory) and there is no guarantees that they have any
// particular charset encoding or even make any sense at all. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info(). This is guaranteed to be in UTF-8 and can be used in a
// user interface. But always store the real basename or the #GFile to use to
// actually access the file, because there is no way to go from a display name
// to the actual name.
// 
// Using #GFile as an identifier has the same weaknesses as using a path in that
// there may be multiple aliases for the same file. For instance, hard or soft
// links may cause two different #GFiles to refer to the same file. Other
// possible causes for aliases are: case insensitive filesystems, short and long
// names on FAT/NTFS, or bind mounts in Linux. If you want to check if two
// #GFiles point to the same file you can query for the G_FILE_ATTRIBUTE_ID_FILE
// attribute. Note that #GFile does some trivial canonicalization of pathnames
// passed in, so that trivial differences in the path string used at creation
// (duplicated slashes, slash at end of path, "." or ".." path segments, etc)
// does not create different #GFiles.
// 
// Many #GFile operations have both synchronous and asynchronous versions to
// suit your application. Asynchronous versions of synchronous functions simply
// have _async() appended to their function names. The asynchronous I/O
// functions call a ReadyCallback which is then used to finalize the operation,
// producing a GAsyncResult which is then passed to the function's matching
// _finish() operation.
// 
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section][async-programming] for
// more.
// 
// Some #GFile operations almost always take a noticeable amount of time, and so
// do not have synchronous analogs. Notable cases include: -
// g_file_mount_mountable() to mount a mountable file. -
// g_file_unmount_mountable_with_operation() to unmount a mountable file. -
// g_file_eject_mountable_with_operation() to eject a mountable file.
// 
// 
// Entity Tags
// 
// One notable feature of #GFiles are entity tags, or "etags" for short. Entity
// tags are somewhat like a more abstract version of the traditional mtime, and
// can be used to quickly determine if the file has been modified from the
// version on the file system. See the HTTP 1.1 specification
// (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) for HTTP Etag
// headers, which are a very similar concept.
	type File struct {
		**externglib.Object
		
	}

	
	func marshalFile(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {File{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AppendTo gets an output stream for appending data to the file. If the file
// doesn't already exist it is created.
// 
// By default files created are generally readable by everyone, but if you pass
// FILE_CREATE_PRIVATE in @flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// Some file systems don't allow all file names, and may return an
// G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
// G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible
// too, and depend on what kind of filesystem the file is on.
	func (f File) AppendTo(flags FileCreateFlags, cancellable CancellableClass) (FileOutputStream, error) {
var _arg0 *C.GFile // out
var _arg1 C.GFileCreateFlags // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileOutputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (C.GFileCreateFlags)(flags)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_append_to(_arg0, _arg1, _arg2, &_cerr)


var _fileOutputStream FileOutputStream // out
var _goerr error // out

_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileOutputStream, _goerr
}
	
	// AppendToFinish finishes an asynchronous file append operation started with
// g_file_append_to_async().
	func (f File) AppendToFinish(res AsyncResult) (FileOutputStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileOutputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_append_to_finish(_arg0, _arg1, &_cerr)


var _fileOutputStream FileOutputStream // out
var _goerr error // out

_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileOutputStream, _goerr
}
	
	// BuildAttributeListForCopy prepares the file attribute query string for
// copying to @file.
// 
// This function prepares an attribute query string to be passed to
// g_file_query_info() to get a list of attributes normally copied with the file
// (see g_file_copy_attributes() for the detailed description). This function is
// used by the implementation of g_file_copy_attributes() and is useful when one
// needs to query and set the attributes in two stages (e.g., for recursive move
// of a directory).
	func (f File) BuildAttributeListForCopy(flags FileCopyFlags, cancellable CancellableClass) (string, error) {
var _arg0 *C.GFile // out
var _arg1 C.GFileCopyFlags // out
var _arg2 *C.GCancellable // out
var _cret *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (C.GFileCopyFlags)(flags)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_build_attribute_list_for_copy(_arg0, _arg1, _arg2, &_cerr)


var _utf8 string // out
var _goerr error // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8, _goerr
}
	
	// CopyAttributes copies the file attributes from @source to @destination.
// 
// Normally only a subset of the file attributes are copied, those that are
// copies in a normal file copy operation (which for instance does not include
// e.g. owner). However if FILE_COPY_ALL_METADATA is specified in @flags, then
// all the metadata that is possible to copy is copied. This is useful when
// implementing move by copy + delete source.
	func (s File) CopyAttributes(destination File, flags FileCopyFlags, cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.GFile // out
var _arg2 C.GFileCopyFlags // out
var _arg3 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(destination.Native()))
_arg2 = (C.GFileCopyFlags)(flags)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_copy_attributes(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CopyFinish finishes copying the file started with g_file_copy_async().
	func (f File) CopyFinish(res AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

C.g_file_copy_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Create creates a new file and returns an output stream for writing to it. The
// file must not already exist.
// 
// By default files created are generally readable by everyone, but if you pass
// FILE_CREATE_PRIVATE in @flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// If a file or directory with this name already exists the G_IO_ERROR_EXISTS
// error will be returned. Some file systems don't allow all file names, and may
// return an G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
// G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are possible too,
// and depend on what kind of filesystem the file is on.
	func (f File) Create(flags FileCreateFlags, cancellable CancellableClass) (FileOutputStream, error) {
var _arg0 *C.GFile // out
var _arg1 C.GFileCreateFlags // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileOutputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (C.GFileCreateFlags)(flags)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_create(_arg0, _arg1, _arg2, &_cerr)


var _fileOutputStream FileOutputStream // out
var _goerr error // out

_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileOutputStream, _goerr
}
	
	// CreateFinish finishes an asynchronous file create operation started with
// g_file_create_async().
	func (f File) CreateFinish(res AsyncResult) (FileOutputStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileOutputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_create_finish(_arg0, _arg1, &_cerr)


var _fileOutputStream FileOutputStream // out
var _goerr error // out

_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileOutputStream, _goerr
}
	
	// CreateReadwrite creates a new file and returns a stream for reading and
// writing to it. The file must not already exist.
// 
// By default files created are generally readable by everyone, but if you pass
// FILE_CREATE_PRIVATE in @flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// If a file or directory with this name already exists, the G_IO_ERROR_EXISTS
// error will be returned. Some file systems don't allow all file names, and may
// return an G_IO_ERROR_INVALID_FILENAME error, and if the name is too long,
// G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are possible too,
// and depend on what kind of filesystem the file is on.
// 
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
	func (f File) CreateReadwrite(flags FileCreateFlags, cancellable CancellableClass) (FileIOStream, error) {
var _arg0 *C.GFile // out
var _arg1 C.GFileCreateFlags // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileIOStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (C.GFileCreateFlags)(flags)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_create_readwrite(_arg0, _arg1, _arg2, &_cerr)


var _fileIOStream FileIOStream // out
var _goerr error // out

_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileIOStream, _goerr
}
	
	// CreateReadwriteFinish finishes an asynchronous file create operation started
// with g_file_create_readwrite_async().
	func (f File) CreateReadwriteFinish(res AsyncResult) (FileIOStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileIOStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_create_readwrite_finish(_arg0, _arg1, &_cerr)


var _fileIOStream FileIOStream // out
var _goerr error // out

_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileIOStream, _goerr
}
	
	// Delete deletes a file. If the @file is a directory, it will only be deleted
// if it is empty. This has the same semantics as g_unlink().
// 
// If @file doesnt exist, G_IO_ERROR_NOT_FOUND will be returned. This allows
// for deletion to be implemented avoiding time-of-check to time-of-use races
// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
// 
//    g_autoptr(GError) local_error = NULL;
//    if (!g_file_delete (my_file, my_cancellable, &local_error) &&
//        !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
//      {
//        // deletion failed for some reason other than the file not existing:
//        // so report the error
//        g_warning ("Failed to delete s: s",
//                   g_file_peek_path (my_file), local_error->message);
//      }
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) Delete(cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_delete(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// DeleteFinish finishes deleting a file started with g_file_delete_async().
	func (f File) DeleteFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_delete_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Dup duplicates a #GFile handle. This operation does not duplicate the actual
// file or directory represented by the #GFile; see g_file_copy() if attempting
// to copy a file.
// 
// g_file_dup() is useful when a second handle is needed to the same underlying
// file, for use in a separate thread (#GFile is not thread-safe). For use
// within the same thread, use g_object_ref() to increment the existing objects
// reference count.
// 
// This call does no blocking I/O.
	func (f File) Dup() File {
var _arg0 *C.GFile // out
var _cret *C.GFile // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_dup(_arg0)


var _ret File // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _ret
}
	
	// EjectMountableFinish finishes an asynchronous eject operation started by
// g_file_eject_mountable().
	func (f File) EjectMountableFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_eject_mountable_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// EjectMountableWithOperationFinish finishes an asynchronous eject operation
// started by g_file_eject_mountable_with_operation().
	func (f File) EjectMountableWithOperationFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_eject_mountable_with_operation_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// EnumerateChildren gets the requested information about the files in a
// directory. The result is a Enumerator object that will give out Info objects
// for all the files in the directory.
// 
// The @attributes value is a string that specifies the file attributes that
// should be gathered. It is not an error if it's not possible to read a
// particular requested attribute from a file - it just won't be set.
// @attributes should be a comma-separated list of attributes or attribute
// wildcards. The wildcard "*" means all attributes, and a wildcard like
// "standard::*" means all attributes in the standard namespace. An example
// attribute query be "standard::*,owner::user". The standard attributes are
// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is not a directory, the G_IO_ERROR_NOT_DIRECTORY error will be
// returned. Other errors are possible too.
	func (f File) EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable CancellableClass) (FileEnumerator, error) {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 C.GFileQueryInfoFlags // out
var _arg3 *C.GCancellable // out
var _cret *C.GFileEnumerator // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GFileQueryInfoFlags)(flags)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_enumerate_children(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _fileEnumerator FileEnumerator // out
var _goerr error // out

_fileEnumerator = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileEnumerator)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileEnumerator, _goerr
}
	
	// EnumerateChildrenFinish finishes an async enumerate children operation. See
// g_file_enumerate_children_async().
	func (f File) EnumerateChildrenFinish(res AsyncResult) (FileEnumerator, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileEnumerator // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_enumerate_children_finish(_arg0, _arg1, &_cerr)


var _fileEnumerator FileEnumerator // out
var _goerr error // out

_fileEnumerator = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileEnumerator)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileEnumerator, _goerr
}
	
	// Equal checks if the two given #GFiles refer to the same file.
// 
// Note that two #GFiles that differ can still refer to the same file on the
// filesystem due to various forms of filename aliasing.
// 
// This call does no blocking I/O.
	func (f File) Equal(file2 File) bool {
var _arg0 *C.GFile // out
var _arg1 *C.GFile // out
var _cret C.gboolean // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file2.Native()))

_cret = C.g_file_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FindEnclosingMount gets a #GMount for the #GFile.
// 
// #GMount is returned only for user interesting locations, see Monitor. If the
// Iface for @file does not have a #mount, @error will be set to
// G_IO_ERROR_NOT_FOUND and nil #will be returned.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) FindEnclosingMount(cancellable CancellableClass) (Mount, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cret *C.GMount // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_find_enclosing_mount(_arg0, _arg1, &_cerr)


var _mount Mount // out
var _goerr error // out

_mount = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Mount)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _mount, _goerr
}
	
	// FindEnclosingMountFinish finishes an asynchronous find mount request. See
// g_file_find_enclosing_mount_async().
	func (f File) FindEnclosingMountFinish(res AsyncResult) (Mount, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GMount // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_find_enclosing_mount_finish(_arg0, _arg1, &_cerr)


var _mount Mount // out
var _goerr error // out

_mount = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Mount)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _mount, _goerr
}
	
	// Basename gets the base name (the last component of the path) for a given
// #GFile.
// 
// If called for the top level of a system (such as the filesystem root or a uri
// like sftp://host/) it will return a single directory separator (and on
// Windows, possibly a drive letter).
// 
// The base name is a byte string (not UTF-8). It has no defined encoding or
// rules other than it may not contain zero bytes. If you want to use filenames
// in a user interface you should use the display name that you can get by
// requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info().
// 
// This call does no blocking I/O.
	func (f File) Basename() string {
var _arg0 *C.GFile // out
var _cret *C.char // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_get_basename(_arg0)


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}
	
	// Child gets a child of @file with basename equal to @name.
// 
// Note that the file with that specific name might not exist, but you can still
// have a #GFile that points to it. You can use this for instance to create that
// file.
// 
// This call does no blocking I/O.
	func (f File) Child(name string) File {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _cret *C.GFile // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_get_child(_arg0, _arg1)


var _ret File // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _ret
}
	
	// ChildForDisplayName gets the child of @file for a given @display_name (i.e. a
// UTF-8 version of the name). If this function fails, it returns nil and @error
// will be set. This is very useful when constructing a #GFile for a new file
// and the user entered the filename in the user interface, for instance when
// you select a directory and type a filename in the file selector.
// 
// This call does no blocking I/O.
	func (f File) ChildForDisplayName(displayName string) (File, error) {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _cret *C.GFile // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(displayName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_get_child_for_display_name(_arg0, _arg1, &_cerr)


var _ret File // out
var _goerr error // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _ret, _goerr
}
	
	// Parent gets the parent directory for the @file. If the @file represents the
// root directory of the file system, then nil will be returned.
// 
// This call does no blocking I/O.
	func (f File) Parent() File {
var _arg0 *C.GFile // out
var _cret *C.GFile // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_get_parent(_arg0)


var _ret File // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _ret
}
	
	// ParseName gets the parse name of the @file. A parse name is a UTF-8 string
// that describes the file such that one can get the #GFile back using
// g_file_parse_name().
// 
// This is generally used to show the #GFile as a nice full-pathname kind of
// string in a user interface, like in a location entry.
// 
// For local files with names that can safely be converted to UTF-8 the pathname
// is used, otherwise the IRI is used (a form of URI that allows UTF-8
// characters unescaped).
// 
// This call does no blocking I/O.
	func (f File) ParseName() string {
var _arg0 *C.GFile // out
var _cret *C.char // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_get_parse_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Path gets the local pathname for #GFile, if one exists. If non-nil, this is
// guaranteed to be an absolute, canonical path. It might contain symlinks.
// 
// This call does no blocking I/O.
	func (f File) Path() string {
var _arg0 *C.GFile // out
var _cret *C.char // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_get_path(_arg0)


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}
	
	// RelativePath gets the path for @descendant relative to @parent.
// 
// This call does no blocking I/O.
	func (p File) RelativePath(descendant File) string {
var _arg0 *C.GFile // out
var _arg1 *C.GFile // out
var _cret *C.char // in

_arg0 = (*C.GFile)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(descendant.Native()))

_cret = C.g_file_get_relative_path(_arg0, _arg1)


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}
	
	// URI gets the URI for the @file.
// 
// This call does no blocking I/O.
	func (f File) URI() string {
var _arg0 *C.GFile // out
var _cret *C.char // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_get_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme as:
// 
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// 
// Common schemes include "file", "http", "ftp", etc.
// 
// The scheme can be different from the one used to construct the #GFile, in
// that it might be replaced with one that is logically equivalent to the
// #GFile.
// 
// This call does no blocking I/O.
	func (f File) URIScheme() string {
var _arg0 *C.GFile // out
var _cret *C.char // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_get_uri_scheme(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// HasParent checks if @file has a parent, and optionally, if it is @parent.
// 
// If @parent is nil then this function returns true if @file has any parent at
// all. If @parent is non-nil then true is only returned if @file is an
// immediate child of @parent.
	func (f File) HasParent(parent File) bool {
var _arg0 *C.GFile // out
var _arg1 *C.GFile // out
var _cret C.gboolean // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(parent.Native()))

_cret = C.g_file_has_parent(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasPrefix checks whether @file has the prefix specified by @prefix.
// 
// In other words, if the names of initial elements of @file's pathname match
// @prefix. Only full pathname elements are matched, so a path like /foo is not
// considered a prefix of /foobar, only of /foo/bar.
// 
// A #GFile is not a prefix of itself. If you want to check for equality, use
// g_file_equal().
// 
// This call does no I/O, as it works purely on names. As such it can sometimes
// return false even if @file is inside a @prefix (from a filesystem point of
// view), because the prefix of @file is an alias of @prefix.
	func (f File) HasPrefix(prefix File) bool {
var _arg0 *C.GFile // out
var _arg1 *C.GFile // out
var _cret C.gboolean // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(prefix.Native()))

_cret = C.g_file_has_prefix(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasURIScheme checks to see if a #GFile has a given URI scheme.
// 
// This call does no blocking I/O.
	func (f File) HasURIScheme(uriScheme string) bool {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(uriScheme))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_has_uri_scheme(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Hash creates a hash value for a #GFile.
// 
// This call does no blocking I/O.
	func (f File) Hash() uint {
var _arg0 C.gconstpointer // out
var _cret C.guint // in

_arg0 = (C.gconstpointer)(unsafe.Pointer(f.Native()))

_cret = C.g_file_hash(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// IsNative checks to see if a file is native to the platform.
// 
// A native file is one expressed in the platform-native filename format, e.g.
// "C:\Windows" or "/usr/bin/". This does not mean the file is local, as it
// might be on a locally mounted remote filesystem.
// 
// On some systems non-native files may be available using the native filesystem
// via a userspace filesystem (FUSE), in these cases this call will return
// false, but g_file_get_path() will still return a native path.
// 
// This call does no blocking I/O.
	func (f File) IsNative() bool {
var _arg0 *C.GFile // out
var _cret C.gboolean // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_is_native(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LoadContents loads the content of the file into memory. The data is always
// zero-terminated, but this is not included in the resultant @length. The
// returned @contents should be freed with g_free() when no longer needed.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) LoadContents(cancellable CancellableClass) ([]byte, string, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _arg2 *C.char
var _arg3 C.gsize // in
var _arg4 *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_load_contents(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)

var _contents []byte
var _etagOut string // out
var _goerr error // out

_contents = unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3)
runtime.SetFinalizer(&_contents, func(v *[]byte) {
  C.free(unsafe.Pointer(&(*v)[0]))
})
_etagOut = C.GoString(_arg4)
defer C.free(unsafe.Pointer(_arg4))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _contents, _etagOut, _goerr
}
	
	// LoadContentsFinish finishes an asynchronous load of the @file's contents. The
// contents are placed in @contents, and @length is set to the size of the
// @contents string. The @contents should be freed with g_free() when no longer
// needed. If @etag_out is present, it will be set to the new entity tag for the
// @file.
	func (f File) LoadContentsFinish(res AsyncResult) ([]byte, string, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _arg2 *C.char
var _arg3 C.gsize // in
var _arg4 *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

C.g_file_load_contents_finish(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)

var _contents []byte
var _etagOut string // out
var _goerr error // out

_contents = unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3)
runtime.SetFinalizer(&_contents, func(v *[]byte) {
  C.free(unsafe.Pointer(&(*v)[0]))
})
_etagOut = C.GoString(_arg4)
defer C.free(unsafe.Pointer(_arg4))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _contents, _etagOut, _goerr
}
	
	// LoadPartialContentsFinish finishes an asynchronous partial load operation
// that was started with g_file_load_partial_contents_async(). The data is
// always zero-terminated, but this is not included in the resultant @length.
// The returned @contents should be freed with g_free() when no longer needed.
	func (f File) LoadPartialContentsFinish(res AsyncResult) ([]byte, string, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _arg2 *C.char
var _arg3 C.gsize // in
var _arg4 *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

C.g_file_load_partial_contents_finish(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)

var _contents []byte
var _etagOut string // out
var _goerr error // out

_contents = unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3)
runtime.SetFinalizer(&_contents, func(v *[]byte) {
  C.free(unsafe.Pointer(&(*v)[0]))
})
_etagOut = C.GoString(_arg4)
defer C.free(unsafe.Pointer(_arg4))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _contents, _etagOut, _goerr
}
	
	// MakeDirectory creates a directory. Note that this will only create a child
// directory of the immediate parent directory of the path or URI given by the
// #GFile. To recursively create directories, see
// g_file_make_directory_with_parents(). This function will fail if the parent
// directory does not exist, setting @error to G_IO_ERROR_NOT_FOUND. If the file
// system doesn't support creating directories, this function will fail, setting
// @error to G_IO_ERROR_NOT_SUPPORTED.
// 
// For a local #GFile the newly created directory will have the default
// (current) ownership and permissions of the current process.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) MakeDirectory(cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_make_directory(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// MakeDirectoryFinish finishes an asynchronous directory creation, started with
// g_file_make_directory_async().
	func (f File) MakeDirectoryFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_make_directory_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// MakeDirectoryWithParents creates a directory and any parent directories that
// may not exist similar to 'mkdir -p'. If the file system does not support
// creating directories, this function will fail, setting @error to
// G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists, this
// function will fail setting @error to G_IO_ERROR_EXISTS, unlike the similar
// g_mkdir_with_parents().
// 
// For a local #GFile the newly created directories will have the default
// (current) ownership and permissions of the current process.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) MakeDirectoryWithParents(cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_make_directory_with_parents(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// MakeSymbolicLink creates a symbolic link named @file which contains the
// string @symlink_value.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) MakeSymbolicLink(symlinkValue string, cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(symlinkValue))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_make_symbolic_link(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// MeasureDiskUsageFinish collects the results from an earlier call to
// g_file_measure_disk_usage_async(). See g_file_measure_disk_usage() for more
// information.
	func (f File) MeasureDiskUsageFinish(result AsyncResult) (diskUsage uint64, numDirs uint64, numFiles uint64, goerr error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.guint64 // in
var _arg3 C.guint64 // in
var _arg4 C.guint64 // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_measure_disk_usage_finish(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)

var _diskUsage uint64 // out
var _numDirs uint64 // out
var _numFiles uint64 // out
var _goerr error // out

_diskUsage = (uint64)(_arg2)
_numDirs = (uint64)(_arg3)
_numFiles = (uint64)(_arg4)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _diskUsage, _numDirs, _numFiles, _goerr
}
	
	// Monitor obtains a file or directory monitor for the given file, depending on
// the type of the file.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) Monitor(flags FileMonitorFlags, cancellable CancellableClass) (FileMonitor, error) {
var _arg0 *C.GFile // out
var _arg1 C.GFileMonitorFlags // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileMonitor // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (C.GFileMonitorFlags)(flags)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_monitor(_arg0, _arg1, _arg2, &_cerr)


var _fileMonitor FileMonitor // out
var _goerr error // out

_fileMonitor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileMonitor)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileMonitor, _goerr
}
	
	// MonitorDirectory obtains a directory monitor for the given file. This may
// fail if directory monitoring is not supported.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// It does not make sense for @flags to contain G_FILE_MONITOR_WATCH_HARD_LINKS,
// since hard links can not be made to directories. It is not possible to
// monitor all the files in a directory for changes made via hard links; if you
// want to do this then you must register individual watches with
// g_file_monitor().
	func (f File) MonitorDirectory(flags FileMonitorFlags, cancellable CancellableClass) (FileMonitor, error) {
var _arg0 *C.GFile // out
var _arg1 C.GFileMonitorFlags // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileMonitor // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (C.GFileMonitorFlags)(flags)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_monitor_directory(_arg0, _arg1, _arg2, &_cerr)


var _fileMonitor FileMonitor // out
var _goerr error // out

_fileMonitor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileMonitor)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileMonitor, _goerr
}
	
	// MonitorFile obtains a file monitor for the given file. If no file
// notification mechanism exists, then regular polling of the file is used.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// If @flags contains G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor will also
// attempt to report changes made to the file via another filename (ie, a hard
// link). Without this flag, you can only rely on changes made through the
// filename contained in @file to be reported. Using this flag may result in an
// increase in resource usage, and may not have any effect depending on the
// Monitor backend and/or filesystem type.
	func (f File) MonitorFile(flags FileMonitorFlags, cancellable CancellableClass) (FileMonitor, error) {
var _arg0 *C.GFile // out
var _arg1 C.GFileMonitorFlags // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileMonitor // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (C.GFileMonitorFlags)(flags)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_monitor_file(_arg0, _arg1, _arg2, &_cerr)


var _fileMonitor FileMonitor // out
var _goerr error // out

_fileMonitor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileMonitor)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileMonitor, _goerr
}
	
	// MountEnclosingVolumeFinish finishes a mount operation started by
// g_file_mount_enclosing_volume().
	func (l File) MountEnclosingVolumeFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_mount_enclosing_volume_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// MountMountableFinish finishes a mount operation. See g_file_mount_mountable()
// for details.
// 
// Finish an asynchronous mount operation that was started with
// g_file_mount_mountable().
	func (f File) MountMountableFinish(result AsyncResult) (File, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFile // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_file_mount_mountable_finish(_arg0, _arg1, &_cerr)


var _ret File // out
var _goerr error // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _ret, _goerr
}
	
	// OpenReadwrite opens an existing file for reading and writing. The result is a
// IOStream that can be used to read and write the contents of the file.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on. Note that in many non-local file cases read and
// write streams are not supported, so make sure you really need to do read and
// write streaming, rather than just opening for reading or writing.
	func (f File) OpenReadwrite(cancellable CancellableClass) (FileIOStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cret *C.GFileIOStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_open_readwrite(_arg0, _arg1, &_cerr)


var _fileIOStream FileIOStream // out
var _goerr error // out

_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileIOStream, _goerr
}
	
	// OpenReadwriteFinish finishes an asynchronous file read operation started with
// g_file_open_readwrite_async().
	func (f File) OpenReadwriteFinish(res AsyncResult) (FileIOStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileIOStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_open_readwrite_finish(_arg0, _arg1, &_cerr)


var _fileIOStream FileIOStream // out
var _goerr error // out

_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileIOStream, _goerr
}
	
	// PeekPath: exactly like g_file_get_path(), but caches the result via
// g_object_set_qdata_full(). This is useful for example in C applications which
// mix `g_file_*` APIs with native ones. It also avoids an extra duplicated
// string when possible, so will be generally more efficient.
// 
// This call does no blocking I/O.
	func (f File) PeekPath() string {
var _arg0 *C.GFile // out
var _cret *C.char // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_peek_path(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// PollMountableFinish finishes a poll operation. See g_file_poll_mountable()
// for details.
// 
// Finish an asynchronous poll operation that was polled with
// g_file_poll_mountable().
	func (f File) PollMountableFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_poll_mountable_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// QueryDefaultHandler returns the Info that is registered as the default
// application to handle the file specified by @file.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) QueryDefaultHandler(cancellable CancellableClass) (AppInfo, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cret *C.GAppInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_query_default_handler(_arg0, _arg1, &_cerr)


var _appInfo AppInfo // out
var _goerr error // out

_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _appInfo, _goerr
}
	
	// QueryDefaultHandlerFinish finishes a g_file_query_default_handler_async()
// operation.
	func (f File) QueryDefaultHandlerFinish(result AsyncResult) (AppInfo, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GAppInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_file_query_default_handler_finish(_arg0, _arg1, &_cerr)


var _appInfo AppInfo // out
var _goerr error // out

_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _appInfo, _goerr
}
	
	// QueryExists: utility function to check if a particular file exists. This is
// implemented using g_file_query_info() and as such does blocking I/O.
// 
// Note that in many cases it is racy to first check for file existence
// (https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) and then execute
// something based on the outcome of that, because the file might have been
// created or removed in between the operations. The general approach to
// handling that is to not check, but just do the operation and handle the
// errors as they come.
// 
// As an example of race-free checking, take the case of reading a file, and if
// it doesn't exist, creating it. There are two racy versions: read it, and on
// error create it; and: check if it exists, if not create it. These can both
// result in two processes creating the file (with perhaps a partially written
// file as the result). The correct approach is to always try to create the file
// with g_file_create() which will either atomically create the file or fail
// with a G_IO_ERROR_EXISTS error.
// 
// However, in many cases an existence check is useful in a user interface, for
// instance to make a menu item sensitive/insensitive, so that you don't have to
// fool users that something is possible and then just show an error dialog. If
// you do this, you should make sure to also handle the errors that can happen
// due to races when you execute the operation.
	func (f File) QueryExists(cancellable CancellableClass) bool {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cret C.gboolean // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_query_exists(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// QueryFileType: utility function to inspect the Type of a file. This is
// implemented using g_file_query_info() and as such does blocking I/O.
// 
// The primary use case of this method is to check if a file is a regular file,
// directory, or symlink.
	func (f File) QueryFileType(flags FileQueryInfoFlags, cancellable CancellableClass) FileType {
var _arg0 *C.GFile // out
var _arg1 C.GFileQueryInfoFlags // out
var _arg2 *C.GCancellable // out
var _cret C.GFileType // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (C.GFileQueryInfoFlags)(flags)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_query_file_type(_arg0, _arg1, _arg2)


var _fileType FileType // out

_fileType = FileType(_cret)

return _fileType
}
	
	// QueryFilesystemInfo: similar to g_file_query_info(), but obtains information
// about the filesystem the @file is on, rather than the file itself. For
// instance the amount of space available and the type of the filesystem.
// 
// The @attributes value is a string that specifies the attributes that should
// be gathered. It is not an error if it's not possible to read a particular
// requested attribute from a file - it just won't be set. @attributes should be
// a comma-separated list of attributes or attribute wildcards. The wildcard "*"
// means all attributes, and a wildcard like "filesystem::*" means all
// attributes in the filesystem namespace. The standard namespace for filesystem
// attributes is "filesystem". Common attributes of interest are
// FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes),
// FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available), and
// FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
	func (f File) QueryFilesystemInfo(attributes string, cancellable CancellableClass) (FileInfo, error) {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_query_filesystem_info(_arg0, _arg1, _arg2, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	
	// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query. See
// g_file_query_filesystem_info_async().
	func (f File) QueryFilesystemInfoFinish(res AsyncResult) (FileInfo, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_query_filesystem_info_finish(_arg0, _arg1, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	
	// QueryInfo gets the requested information about specified @file. The result is
// a Info object that contains key-value attributes (such as the type or size of
// the file).
// 
// The @attributes value is a string that specifies the file attributes that
// should be gathered. It is not an error if it's not possible to read a
// particular requested attribute from a file - it just won't be set.
// @attributes should be a comma-separated list of attributes or attribute
// wildcards. The wildcard "*" means all attributes, and a wildcard like
// "standard::*" means all attributes in the standard namespace. An example
// attribute query be "standard::*,owner::user". The standard attributes are
// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// For symlinks, normally the information about the target of the symlink is
// returned, rather than information about the symlink itself. However if you
// pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in @flags the information about the
// symlink itself will be returned. Also, for symlinks that point to
// non-existing files the information about the symlink itself will be returned.
// 
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
	func (f File) QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable CancellableClass) (FileInfo, error) {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 C.GFileQueryInfoFlags // out
var _arg3 *C.GCancellable // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GFileQueryInfoFlags)(flags)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_query_info(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	
	// QueryInfoFinish finishes an asynchronous file info query. See
// g_file_query_info_async().
	func (f File) QueryInfoFinish(res AsyncResult) (FileInfo, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_query_info_finish(_arg0, _arg1, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	
	// QuerySettableAttributes: obtain the list of settable attributes for the file.
// 
// Returns the type and full attribute name of all the attributes that can be
// set on this file. This doesn't mean setting it will always succeed though,
// you might get an access failure, or some specific file may not support a
// specific attribute.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) QuerySettableAttributes(cancellable CancellableClass) (*FileAttributeInfoList, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cret *C.GFileAttributeInfoList // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_query_settable_attributes(_arg0, _arg1, &_cerr)


var _fileAttributeInfoList *FileAttributeInfoList // out
var _goerr error // out

_fileAttributeInfoList = *(**FileAttributeInfoList)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileAttributeInfoList, _goerr
}
	
	// QueryWritableNamespaces: obtain the list of attribute namespaces where new
// attributes can be created by a user. An example of this is extended
// attributes (in the "xattr" namespace).
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) QueryWritableNamespaces(cancellable CancellableClass) (*FileAttributeInfoList, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cret *C.GFileAttributeInfoList // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_query_writable_namespaces(_arg0, _arg1, &_cerr)


var _fileAttributeInfoList *FileAttributeInfoList // out
var _goerr error // out

_fileAttributeInfoList = *(**FileAttributeInfoList)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileAttributeInfoList, _goerr
}
	
	// Read opens a file for reading. The result is a InputStream that can be used
// to read the contents of the file.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on.
	func (f File) Read(cancellable CancellableClass) (FileInputStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cret *C.GFileInputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_read(_arg0, _arg1, &_cerr)


var _fileInputStream FileInputStream // out
var _goerr error // out

_fileInputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInputStream, _goerr
}
	
	// ReadFinish finishes an asynchronous file read operation started with
// g_file_read_async().
	func (f File) ReadFinish(res AsyncResult) (FileInputStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileInputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_read_finish(_arg0, _arg1, &_cerr)


var _fileInputStream FileInputStream // out
var _goerr error // out

_fileInputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInputStream, _goerr
}
	
	// Replace returns an output stream for overwriting the file, possibly creating
// a backup copy of the file first. If the file doesn't exist, it will be
// created.
// 
// This will try to replace the file in the safest way possible so that any
// errors during the writing will not affect an already existing copy of the
// file. For instance, for local files it may write to a temporary file and then
// atomically rename over the destination when the stream is closed.
// 
// By default files created are generally readable by everyone, but if you pass
// FILE_CREATE_PRIVATE in @flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// If you pass in a non-nil @etag value and @file already exists, then this
// value is compared to the current entity tag of the file, and if they differ
// an G_IO_ERROR_WRONG_ETAG error is returned. This generally means that the
// file has been changed since you last read it. You can get the new etag from
// g_file_output_stream_get_etag() after you've finished writing and closed the
// OutputStream. When you load a new file you can use
// g_file_input_stream_query_info() to get the etag of the file.
// 
// If @make_backup is true, this function will attempt to make a backup of the
// current file before overwriting it. If this fails a
// G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you want to replace
// anyway, try again with @make_backup set to false.
// 
// If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be
// returned, and if the file is some other form of non-regular file then a
// G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some file systems don't
// allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME error,
// and if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
	func (f File) Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable CancellableClass) (FileOutputStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 C.gboolean // out
var _arg3 C.GFileCreateFlags // out
var _arg4 *C.GCancellable // out
var _cret *C.GFileOutputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(etag))
defer C.free(unsafe.Pointer(_arg1))
if makeBackup { _arg2 = C.TRUE }
_arg3 = (C.GFileCreateFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_replace(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _fileOutputStream FileOutputStream // out
var _goerr error // out

_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileOutputStream, _goerr
}
	
	// ReplaceContents replaces the contents of @file with @contents of @length
// bytes.
// 
// If @etag is specified (not nil), any existing file must have that etag, or
// the error G_IO_ERROR_WRONG_ETAG will be returned.
// 
// If @make_backup is true, this function will attempt to make a backup of
// @file. Internally, it uses g_file_replace(), so will try to replace the file
// contents in the safest way possible. For example, atomic renames are used
// when replacing local files contents.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
// 
// The returned @new_etag can be used to verify that the file hasn't changed the
// next time it is saved over.
	func (f File) ReplaceContents(contents []byte, etag string, makeBackup bool, flags FileCreateFlags, cancellable CancellableClass) (string, error) {
var _arg0 *C.GFile // out
var _arg1 *C.char
var _arg2 C.gsize
var _arg3 *C.char // out
var _arg4 C.gboolean // out
var _arg5 C.GFileCreateFlags // out
var _arg6 *C.char // in
var _arg7 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg2 = C.gsize(len(contents))
_arg1 = (*C.char)(unsafe.Pointer(&contents[0]))
_arg3 = (*C.char)(C.CString(etag))
defer C.free(unsafe.Pointer(_arg3))
if makeBackup { _arg4 = C.TRUE }
_arg5 = (C.GFileCreateFlags)(flags)
_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_replace_contents(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, _arg7, &_cerr)

var _newEtag string // out
var _goerr error // out

_newEtag = C.GoString(_arg6)
defer C.free(unsafe.Pointer(_arg6))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _newEtag, _goerr
}
	
	// ReplaceContentsFinish finishes an asynchronous replace of the given @file.
// See g_file_replace_contents_async(). Sets @new_etag to the new entity tag for
// the document, if present.
	func (f File) ReplaceContentsFinish(res AsyncResult) (string, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _arg2 *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

C.g_file_replace_contents_finish(_arg0, _arg1, &_arg2, &_cerr)

var _newEtag string // out
var _goerr error // out

_newEtag = C.GoString(_arg2)
defer C.free(unsafe.Pointer(_arg2))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _newEtag, _goerr
}
	
	// ReplaceFinish finishes an asynchronous file replace operation started with
// g_file_replace_async().
	func (f File) ReplaceFinish(res AsyncResult) (FileOutputStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileOutputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_replace_finish(_arg0, _arg1, &_cerr)


var _fileOutputStream FileOutputStream // out
var _goerr error // out

_fileOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileOutputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileOutputStream, _goerr
}
	
	// ReplaceReadwrite returns an output stream for overwriting the file in
// readwrite mode, possibly creating a backup copy of the file first. If the
// file doesn't exist, it will be created.
// 
// For details about the behaviour, see g_file_replace() which does the same
// thing but returns an output stream only.
// 
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
	func (f File) ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable CancellableClass) (FileIOStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 C.gboolean // out
var _arg3 C.GFileCreateFlags // out
var _arg4 *C.GCancellable // out
var _cret *C.GFileIOStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(etag))
defer C.free(unsafe.Pointer(_arg1))
if makeBackup { _arg2 = C.TRUE }
_arg3 = (C.GFileCreateFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_replace_readwrite(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _fileIOStream FileIOStream // out
var _goerr error // out

_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileIOStream, _goerr
}
	
	// ReplaceReadwriteFinish finishes an asynchronous file replace operation
// started with g_file_replace_readwrite_async().
	func (f File) ReplaceReadwriteFinish(res AsyncResult) (FileIOStream, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileIOStream // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_replace_readwrite_finish(_arg0, _arg1, &_cerr)


var _fileIOStream FileIOStream // out
var _goerr error // out

_fileIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileIOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileIOStream, _goerr
}
	
	// ResolveRelativePath resolves a relative path for @file to an absolute path.
// 
// This call does no blocking I/O.
	func (f File) ResolveRelativePath(relativePath string) File {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _cret *C.GFile // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(relativePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_resolve_relative_path(_arg0, _arg1)


var _ret File // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _ret
}
	
	// SetAttributeByteString sets @attribute of type
// G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value. If @attribute is of a different
// type, this operation will fail, returning false.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 *C.char // out
var _arg3 C.GFileQueryInfoFlags // out
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(value))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.GFileQueryInfoFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_set_attribute_byte_string(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAttributeInt32 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_INT32 to
// @value. If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 C.gint32 // out
var _arg3 C.GFileQueryInfoFlags // out
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint32)(value)
_arg3 = (C.GFileQueryInfoFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_set_attribute_int32(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAttributeInt64 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_INT64 to
// @value. If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 C.gint64 // out
var _arg3 C.GFileQueryInfoFlags // out
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint64)(value)
_arg3 = (C.GFileQueryInfoFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_set_attribute_int64(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAttributeString sets @attribute of type G_FILE_ATTRIBUTE_TYPE_STRING to
// @value. If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 *C.char // out
var _arg3 C.GFileQueryInfoFlags // out
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(value))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.GFileQueryInfoFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_set_attribute_string(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAttributeUint32 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_UINT32 to
// @value. If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 C.guint32 // out
var _arg3 C.GFileQueryInfoFlags // out
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint32)(value)
_arg3 = (C.GFileQueryInfoFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_set_attribute_uint32(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAttributeUint64 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_UINT64 to
// @value. If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 C.guint64 // out
var _arg3 C.GFileQueryInfoFlags // out
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint64)(value)
_arg3 = (C.GFileQueryInfoFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_set_attribute_uint64(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAttributesFinish finishes setting an attribute started in
// g_file_set_attributes_async().
	func (f File) SetAttributesFinish(result AsyncResult) (FileInfo, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _arg2 *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_set_attributes_finish(_arg0, _arg1, &_arg2, &_cerr)

var _info FileInfo // out
var _goerr error // out

_info = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg2))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _info, _goerr
}
	
	// SetAttributesFromInfo tries to set all attributes in the Info on the target
// values, not stopping on the first error.
// 
// If there is any error during this operation then @error will be set to the
// first error. Error on particular fields are flagged by setting the "status"
// field in the attribute value to G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which
// means you can also detect further errors.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) SetAttributesFromInfo(info FileInfoClass, flags FileQueryInfoFlags, cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.GFileInfo // out
var _arg2 C.GFileQueryInfoFlags // out
var _arg3 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GFileInfo)(unsafe.Pointer(info.Native()))
_arg2 = (C.GFileQueryInfoFlags)(flags)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_set_attributes_from_info(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetDisplayName renames @file to the specified display name.
// 
// The display name is converted from UTF-8 to the correct encoding for the
// target filesystem if possible and the @file is renamed to this.
// 
// If you want to implement a rename operation in the user interface the edit
// name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value
// in the rename widget, and then the result after editing should be passed to
// g_file_set_display_name().
// 
// On success the resulting converted filename is returned.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) SetDisplayName(displayName string, cancellable CancellableClass) (File, error) {
var _arg0 *C.GFile // out
var _arg1 *C.char // out
var _arg2 *C.GCancellable // out
var _cret *C.GFile // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(displayName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_set_display_name(_arg0, _arg1, _arg2, &_cerr)


var _ret File // out
var _goerr error // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _ret, _goerr
}
	
	// SetDisplayNameFinish finishes setting a display name started with
// g_file_set_display_name_async().
	func (f File) SetDisplayNameFinish(res AsyncResult) (File, error) {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFile // in
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_file_set_display_name_finish(_arg0, _arg1, &_cerr)


var _ret File // out
var _goerr error // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _ret, _goerr
}
	
	// StartMountableFinish finishes a start operation. See g_file_start_mountable()
// for details.
// 
// Finish an asynchronous start operation that was started with
// g_file_start_mountable().
	func (f File) StartMountableFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_start_mountable_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// StopMountableFinish finishes a stop operation, see g_file_stop_mountable()
// for details.
// 
// Finish an asynchronous stop operation that was started with
// g_file_stop_mountable().
	func (f File) StopMountableFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_stop_mountable_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SupportsThreadContexts checks if @file supports [thread-default
// contexts][g-main-context-push-thread-default-context]. If this returns false,
// you cannot perform asynchronous operations on @file in a thread that has a
// thread-default context.
	func (f File) SupportsThreadContexts() bool {
var _arg0 *C.GFile // out
var _cret C.gboolean // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

_cret = C.g_file_supports_thread_contexts(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Trash sends @file to the "Trashcan", if possible. This is similar to deleting
// it, but the user can recover it before emptying the trashcan. Not all file
// systems support trashing, so this call can return the
// G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
// mount option can be used to disable g_file_trash() support for certain
// mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (f File) Trash(cancellable CancellableClass) error {
var _arg0 *C.GFile // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_trash(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// TrashFinish finishes an asynchronous file trashing operation, started with
// g_file_trash_async().
	func (f File) TrashFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_trash_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// UnmountMountableFinish finishes an unmount operation, see
// g_file_unmount_mountable() for details.
// 
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable().
	func (f File) UnmountMountableFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_unmount_mountable_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// UnmountMountableWithOperationFinish finishes an unmount operation, see
// g_file_unmount_mountable_with_operation() for details.
// 
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable_with_operation().
	func (f File) UnmountMountableWithOperationFinish(result AsyncResult) error {
var _arg0 *C.GFile // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_unmount_mountable_with_operation_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	
	// FileDescriptorBasedInterface contains virtual methods for FileDescriptorBased, or
	// methods that can be overridden.
	type FileDescriptorBasedInterface interface {
		gextras.Objector

			// Fd gets the underlying file descriptor.
		Fd() int
		
	}
	

	// FileDescriptorBased is implemented by streams (implementations of Stream or
// Stream) that are based on file descriptors.
// 
// Note that `<gio/gfiledescriptorbased.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
	type FileDescriptorBased struct {
		**externglib.Object
		
	}

	
	func marshalFileDescriptorBased(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {FileDescriptorBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Fd gets the underlying file descriptor.
	func (f FileDescriptorBased) Fd() int {
var _arg0 *C.GFileDescriptorBased // out
var _cret C.int // in

_arg0 = (*C.GFileDescriptorBased)(unsafe.Pointer(f.Native()))

_cret = C.g_file_descriptor_based_get_fd(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	


	
	// IconInterface contains virtual methods for Icon, or
	// methods that can be overridden.
	type IconInterface interface {
		gextras.Objector

			// Equal checks if two icons are equal.
		Equal(icon2 Icon) bool
			// Hash gets a hash for an icon.
		Hash() uint
			// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can
	// be retrieved back by calling g_icon_deserialize() on the returned value.
	// As serialization will avoid using raw icon data when possible, it only
	// makes sense to transfer the #GVariant between processes on the same
	// machine, (as opposed to over the network), and within the same file
	// system namespace.
		Serialize() *glib.Variant
		
	}
	

	// Icon is a very minimal interface for icons. It provides functions for
// checking the equality of two icons, hashing of icons and serializing an icon
// to and from strings.
// 
// #GIcon does not provide the actual pixmap for the icon as this is out of
// GIO's scope, however implementations of #GIcon may contain the name of an
// icon (see Icon), or the path to an icon (see Icon).
// 
// To obtain a hash of a #GIcon, see g_icon_hash().
// 
// To check if two #GIcons are equal, see g_icon_equal().
// 
// For serializing a #GIcon, use g_icon_serialize() and g_icon_deserialize().
// 
// If you want to consume #GIcon (for example, in a toolkit) you must be
// prepared to handle at least the three following cases: Icon, Icon and Icon.
// It may also make sense to have fast-paths for other cases (like handling
// Pixbuf directly, for example) but all compliant #GIcon implementations
// outside of GIO must implement Icon.
// 
// If your application or library provides one or more #GIcon implementations
// you need to ensure that your new implementation also implements Icon.
// Additionally, you must provide an implementation of g_icon_serialize() that
// gives a result that is understood by g_icon_deserialize(), yielding one of
// the built-in icon types.
	type Icon struct {
		**externglib.Object
		
	}

	
	func marshalIcon(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Equal checks if two icons are equal.
	func (i Icon) Equal(icon2 Icon) bool {
var _arg0 *C.GIcon // out
var _arg1 *C.GIcon // out
var _cret C.gboolean // in

_arg0 = (*C.GIcon)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon2.Native()))

_cret = C.g_icon_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can be
// retrieved back by calling g_icon_deserialize() on the returned value. As
// serialization will avoid using raw icon data when possible, it only makes
// sense to transfer the #GVariant between processes on the same machine, (as
// opposed to over the network), and within the same file system namespace.
	func (i Icon) Serialize() *glib.Variant {
var _arg0 *C.GIcon // out
var _cret *C.GVariant // in

_arg0 = (*C.GIcon)(unsafe.Pointer(i.Native()))

_cret = C.g_icon_serialize(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// String generates a textual representation of @icon that can be used for
// serialization such as when passing @icon to a different process or saving it
// to persistent storage. Use g_icon_new_for_string() to get @icon back from the
// returned string.
// 
// The encoding of the returned string is proprietary to #GIcon except in the
// following two cases
// 
// - If @icon is a Icon, the returned string is a native path (such as
// `/path/to/my icon.png`) without escaping if the #GFile for @icon is a native
// file. If the file is not native, the returned string is the result of
// g_file_get_uri() (such as `sftp://path/to/my20icon.png`).
// 
// - If @icon is a Icon with exactly one name and no fallbacks, the encoding is
// simply the name (such as `network-server`).
	func (i Icon) String() string {
var _arg0 *C.GIcon // out
var _cret *C.gchar // in

_arg0 = (*C.GIcon)(unsafe.Pointer(i.Native()))

_cret = C.g_icon_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	
	// InitableInterface contains virtual methods for Initable, or
	// methods that can be overridden.
	type InitableInterface interface {
		gextras.Objector

			// Init initializes the object implementing the interface.
	// 
	// This method is intended for language bindings. If writing in C,
	// g_initable_new() should typically be used instead.
	// 
	// The object must be initialized before any real use after initial
	// construction, either with this function or g_async_initable_init_async().
	// 
	// Implementations may also support cancellation. If @cancellable is not
	// nil, then initialization can be cancelled by triggering the cancellable
	// object from another thread. If the operation was cancelled, the error
	// G_IO_ERROR_CANCELLED will be returned. If @cancellable is not nil and the
	// object doesn't support cancellable initialization the error
	// G_IO_ERROR_NOT_SUPPORTED will be returned.
	// 
	// If the object is not initialized, or initialization returns with an
	// error, then all operations on the object except g_object_ref() and
	// g_object_unref() are considered to be invalid, and have undefined
	// behaviour. See the [introduction][ginitable] for more details.
	// 
	// Callers should not assume that a class which implements #GInitable can be
	// initialized multiple times, unless the class explicitly documents itself
	// as supporting this. Generally, a class implementation of init() can
	// assume (and assert) that it will only be called once. Previously, this
	// documentation recommended all #GInitable implementations should be
	// idempotent; that recommendation was relaxed in GLib 2.54.
	// 
	// If a class explicitly supports being initialized multiple times, it is
	// recommended that the method is idempotent: multiple calls with the same
	// arguments should return the same results. Only the first call initializes
	// the object; further calls return the result of the first call.
	// 
	// One reason why a class might need to support idempotent initialization is
	// if it is designed to be used via the singleton pattern, with a
	// Class.constructor that sometimes returns an existing instance. In this
	// pattern, a caller would expect to be able to call g_initable_init() on
	// the result of g_object_new(), regardless of whether it is in fact a new
	// instance.
		Init(cancellable CancellableClass) error
		
	}
	

	// Initable is implemented by objects that can fail during initialization. If an
// object implements this interface then it must be initialized as the first
// thing after construction, either via g_initable_init() or
// g_async_initable_init_async() (the latter is only available if it also
// implements Initable).
// 
// If the object is not initialized, or initialization returns with an error,
// then all operations on the object except g_object_ref() and g_object_unref()
// are considered to be invalid, and have undefined behaviour. They will often
// fail with g_critical() or g_warning(), but this must not be relied on.
// 
// Users of objects implementing this are not intended to use the interface
// method directly, instead it will be used automatically in various ways. For C
// applications you generally just call g_initable_new() directly, or indirectly
// via a foo_thing_new() wrapper. This will call g_initable_init() under the
// cover, returning nil and setting a #GError on failure (at which point the
// instance is unreferenced).
// 
// For bindings in languages where the native constructor supports exceptions
// the binding could check for objects implementing GInitable during normal
// construction and automatically initialize them, throwing an exception on
// failure.
	type Initable struct {
		**externglib.Object
		
	}

	
	func marshalInitable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Init initializes the object implementing the interface.
// 
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
// 
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
// 
// Implementations may also support cancellation. If @cancellable is not nil,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// G_IO_ERROR_CANCELLED will be returned. If @cancellable is not nil and the
// object doesn't support cancellable initialization the error
// G_IO_ERROR_NOT_SUPPORTED will be returned.
// 
// If the object is not initialized, or initialization returns with an error,
// then all operations on the object except g_object_ref() and g_object_unref()
// are considered to be invalid, and have undefined behaviour. See the
// [introduction][ginitable] for more details.
// 
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class implementation of init() can assume (and
// assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
// 
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes the
// object; further calls return the result of the first call.
// 
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a Class.constructor
// that sometimes returns an existing instance. In this pattern, a caller would
// expect to be able to call g_initable_init() on the result of g_object_new(),
// regardless of whether it is in fact a new instance.
	func (i Initable) Init(cancellable CancellableClass) error {
var _arg0 *C.GInitable // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GInitable)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_initable_init(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	
	// ListModelInterface contains virtual methods for ListModel, or
	// methods that can be overridden.
	type ListModelInterface interface {
		gextras.Objector

			// Item: get the item at @position. If @position is greater than the number
	// of items in @list, nil is returned.
	// 
	// nil is never returned for an index that is smaller than the length of the
	// list. See g_list_model_get_n_items().
		Item(position uint) **externglib.Object
			// ItemType gets the type of the items in @list. All items returned from
	// g_list_model_get_type() are of that type or a subtype, or are an
	// implementation of that interface.
	// 
	// The item type of a Model can not change during the life of the model.
		ItemType() externglib.Type
			// NItems gets the number of items in @list.
	// 
	// Depending on the model implementation, calling this function may be less
	// efficient than iterating the list with increasing values for @position
	// until g_list_model_get_item() returns nil.
		NItems() uint
		
	}
	

	// ListModel is an interface that represents a mutable list of #GObjects. Its
// main intention is as a model for various widgets in user interfaces, such as
// list views, but it can also be used as a convenient method of returning lists
// of data, with support for updates.
// 
// Each object in the list may also report changes in itself via some mechanism
// (normally the #GObject::notify signal). Taken together with the
// Model::items-changed signal, this provides for a list that can change its
// membership, and in which the members can change their individual properties.
// 
// A good example would be the list of visible wireless network access points,
// where each access point can report dynamic properties such as signal
// strength.
// 
// It is important to note that the Model itself does not report changes to the
// individual items. It only reports changes to the list membership. If you want
// to observe changes to the objects themselves then you need to connect signals
// to the objects that you are interested in.
// 
// All items in a Model are of (or derived from) the same type.
// g_list_model_get_item_type() returns that type. The type may be an interface,
// in which case all objects in the list must implement it.
// 
// The semantics are close to that of an array: g_list_model_get_n_items()
// returns the number of items in the list and g_list_model_get_item() returns
// an item at a (0-based) position. In order to allow implementations to
// calculate the list length lazily, you can also iterate over items: starting
// from 0, repeatedly call g_list_model_get_item() until it returns nil.
// 
// An implementation may create objects lazily, but must take care to return the
// same object for a given position until all references to it are gone.
// 
// On the other side, a consumer is expected only to hold references on objects
// that are currently "user visible", in order to facilitate the maximum level
// of laziness in the implementation of the list and to reduce the required
// number of signal connections at a given time.
// 
// This interface is intended only to be used from a single thread. The thread
// in which it is appropriate to use it depends on the particular
// implementation, but typically it will be from the thread that owns the
// [thread-default main context][g-main-context-push-thread-default] in effect
// at the time that the model was created.
	type ListModel struct {
		**externglib.Object
		
	}

	
	func marshalListModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// ItemType gets the type of the items in @list. All items returned from
// g_list_model_get_type() are of that type or a subtype, or are an
// implementation of that interface.
// 
// The item type of a Model can not change during the life of the model.
	func (l ListModel) ItemType() externglib.Type {
var _arg0 *C.GListModel // out
var _cret C.GType // in

_arg0 = (*C.GListModel)(unsafe.Pointer(l.Native()))

_cret = C.g_list_model_get_item_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// NItems gets the number of items in @list.
// 
// Depending on the model implementation, calling this function may be less
// efficient than iterating the list with increasing values for @position until
// g_list_model_get_item() returns nil.
	func (l ListModel) NItems() uint {
var _arg0 *C.GListModel // out
var _cret C.guint // in

_arg0 = (*C.GListModel)(unsafe.Pointer(l.Native()))

_cret = C.g_list_model_get_n_items(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Object: get the item at @position. If @position is greater than the number of
// items in @list, nil is returned.
// 
// nil is never returned for an index that is smaller than the length of the
// list. See g_list_model_get_n_items().
	func (l ListModel) Object(position uint) **externglib.Object {
var _arg0 *C.GListModel // out
var _arg1 C.guint // out
var _cret *C.GObject // in

_arg0 = (*C.GListModel)(unsafe.Pointer(l.Native()))
_arg1 = (C.guint)(position)

_cret = C.g_list_model_get_object(_arg0, _arg1)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// ItemsChanged emits the Model::items-changed signal on @list.
// 
// This function should only be called by classes implementing Model. It has to
// be called after the internal representation of @list has been updated,
// because handlers connected to this signal might query the new state of the
// list.
// 
// Implementations must only make changes to the model (as visible to its
// consumer) in places that will not cause problems for that consumer. For
// models that are driven directly by a write API (such as Store), changes can
// be reported in response to uses of that API. For models that represent remote
// data, changes should only be made from a fresh mainloop dispatch. It is
// particularly not permitted to make changes in response to a call to the Model
// consumer API.
// 
// Stated another way: in general, it is assumed that code making a series of
// accesses to the model via the API, without returning to the mainloop, and
// without calling other code, will continue to view the same contents of the
// model.
	func (l ListModel) ItemsChanged(position uint, removed uint, added uint)  {
var _arg0 *C.GListModel // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 C.guint // out

_arg0 = (*C.GListModel)(unsafe.Pointer(l.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.guint)(removed)
_arg3 = (C.guint)(added)

C.g_list_model_items_changed(_arg0, _arg1, _arg2, _arg3)
}
	


	
	// LoadableIconInterface contains virtual methods for LoadableIcon, or
	// methods that can be overridden.
	type LoadableIconInterface interface {
		gextras.Objector

			// Load loads a loadable icon. For the asynchronous version of this
	// function, see g_loadable_icon_load_async().
		Load(size int, cancellable CancellableClass) (string, InputStream, error)
			// LoadFinish finishes an asynchronous icon load started in
	// g_loadable_icon_load_async().
		LoadFinish(res AsyncResult) (string, InputStream, error)
		
	}
	

	// LoadableIcon extends the #GIcon interface and adds the ability to load icons
// from streams.
	type LoadableIcon struct {
		Icon
		
	}

	
	func marshalLoadableIcon(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {LoadableIcon{
Icon: Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Load loads a loadable icon. For the asynchronous version of this function,
// see g_loadable_icon_load_async().
	func (i LoadableIcon) Load(size int, cancellable CancellableClass) (string, InputStream, error) {
var _arg0 *C.GLoadableIcon // out
var _arg1 C.int // out
var _arg2 *C.char // in
var _arg3 *C.GCancellable // out
var _cret *C.GInputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(size)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_loadable_icon_load(_arg0, _arg1, &_arg2, _arg3, &_cerr)


var _typ string // out
var _inputStream InputStream // out
var _goerr error // out

_typ = C.GoString(_arg2)
defer C.free(unsafe.Pointer(_arg2))
_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _typ, _inputStream, _goerr
}
	
	// LoadFinish finishes an asynchronous icon load started in
// g_loadable_icon_load_async().
	func (i LoadableIcon) LoadFinish(res AsyncResult) (string, InputStream, error) {
var _arg0 *C.GLoadableIcon // out
var _arg1 *C.GAsyncResult // out
var _arg2 *C.char // in
var _cret *C.GInputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_loadable_icon_load_finish(_arg0, _arg1, &_arg2, &_cerr)


var _typ string // out
var _inputStream InputStream // out
var _goerr error // out

_typ = C.GoString(_arg2)
defer C.free(unsafe.Pointer(_arg2))
_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _typ, _inputStream, _goerr
}
	


	
	// MemoryMonitorInterface contains virtual methods for MemoryMonitor, or
	// methods that can be overridden.
	type MemoryMonitorInterface interface {
		gextras.Objector

		
		LowMemoryWarning(level MemoryMonitorWarningLevel) 
		
	}
	

	// MemoryMonitor: Monitor will monitor system memory and suggest to the
// application when to free memory so as to leave more room for other
// applications. It is implemented on Linux using the Low Memory Monitor
// (https://gitlab.freedesktop.org/hadess/low-memory-monitor/) (API
// documentation (https://hadess.pages.freedesktop.org/low-memory-monitor/)).
// 
// There is also an implementation for use inside Flatpak sandboxes.
// 
// Possible actions to take when the signal is received are: - Free caches -
// Save files that haven't been looked at in a while to disk, ready to be
// reopened when needed - Run a garbage collection cycle - Try and compress
// fragmented allocations - Exit on idle if the process has no reason to stay
// around - Call `malloc_trim(3)` (man:malloc_trim) to return cached heap pages
// to the kernel (if supported by your libc)
// 
// Note that some actions may not always improve system performance, and so
// should be profiled for your application. `malloc_trim()`, for example, may
// make future heap allocations slower (due to releasing cached heap pages back
// to the kernel).
// 
// See MonitorWarningLevel for details on the various warning levels.
// 
//    static void
//    warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
//    {
//      g_debug ("Warning level: d", level);
//      if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//        drop_caches ();
//    }
// 
//    static GMemoryMonitor *
//    monitor_low_memory (void)
//    {
//      GMemoryMonitor *m;
//      m = g_memory_monitor_dup_default ();
//      g_signal_connect (G_OBJECT (m), "low-memory-warning",
//                        G_CALLBACK (warning_cb), NULL);
//      return m;
//    }
// 
// Don't forget to disconnect the Monitor::low-memory-warning signal, and unref
// the Monitor itself when exiting.
	type MemoryMonitor struct {
		Initable
		
	}

	
	func marshalMemoryMonitor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {MemoryMonitor{
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	


	
	// MountInterface contains virtual methods for Mount, or
	// methods that can be overridden.
	type MountInterface interface {
		gextras.Objector

			// CanEject checks if @mount can be ejected.
		CanEject() bool
			// CanUnmount checks if @mount can be unmounted.
		CanUnmount() bool
		
		Changed() 
			// EjectFinish finishes ejecting a mount. If any errors occurred during the
	// operation, @error will be set to contain the errors and false will be
	// returned.
		EjectFinish(result AsyncResult) error
			// EjectWithOperationFinish finishes ejecting a mount. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
		EjectWithOperationFinish(result AsyncResult) error
			// DefaultLocation gets the default location of @mount. The default location
	// of the given @mount is a path that reflects the main entry point for the
	// user (e.g. the home directory, or the root of the volume).
		DefaultLocation() File
			// Drive gets the drive for the @mount.
	// 
	// This is a convenience method for getting the #GVolume and then using that
	// object to get the #GDrive.
		Drive() Drive
			// Icon gets the icon for @mount.
		Icon() Icon
			// Name gets the name of @mount.
		Name() string
			// Root gets the root directory on @mount.
		Root() File
			// SortKey gets the sort key for @mount, if any.
		SortKey() string
			// SymbolicIcon gets the symbolic icon for @mount.
		SymbolicIcon() Icon
			// UUID gets the UUID for the @mount. The reference is typically based on
	// the file system UUID for the mount in question and should be considered
	// an opaque string. Returns nil if there is no UUID available.
		UUID() string
			// Volume gets the volume for the @mount.
		Volume() Volume
			// GuessContentTypeFinish finishes guessing content types of @mount. If any
	// errors occurred during the operation, @error will be set to contain the
	// errors and false will be returned. In particular, you may get an
	// G_IO_ERROR_NOT_SUPPORTED if the mount does not support content guessing.
		GuessContentTypeFinish(result AsyncResult) ([]string, error)
			// GuessContentTypeSync tries to guess the type of content stored on @mount.
	// Returns one or more textual identifiers of well-known content types
	// (typically prefixed with "x-content/"), e.g. x-content/image-dcf for
	// camera memory cards. See the shared-mime-info
	// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
	// specification for more on x-content types.
	// 
	// This is a synchronous operation and as such may block doing IO; see
	// g_mount_guess_content_type() for the asynchronous version.
		GuessContentTypeSync(forceRescan bool, cancellable CancellableClass) ([]string, error)
		
		PreUnmount() 
			// RemountFinish finishes remounting a mount. If any errors occurred during
	// the operation, @error will be set to contain the errors and false will be
	// returned.
		RemountFinish(result AsyncResult) error
			// UnmountFinish finishes unmounting a mount. If any errors occurred during
	// the operation, @error will be set to contain the errors and false will be
	// returned.
		UnmountFinish(result AsyncResult) error
			// UnmountWithOperationFinish finishes unmounting a mount. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
		UnmountWithOperationFinish(result AsyncResult) error
		
		Unmounted() 
		
	}
	

	// Mount: the #GMount interface represents user-visible mounts. Note, when
// porting from GnomeVFS, #GMount is the moral equivalent of VFSVolume.
// 
// #GMount is a "mounted" filesystem that you can access. Mounted is in quotes
// because it's not the same as a unix mount, it might be a gvfs mount, but you
// can still access the files on it if you use GIO. Might or might not be
// related to a volume object.
// 
// Unmounting a #GMount instance is an asynchronous operation. For more
// information about asynchronous operations, see Result and #GTask. To unmount
// a #GMount instance, first call g_mount_unmount_with_operation() with (at
// least) the #GMount instance and a ReadyCallback. The callback will be fired
// when the operation has resolved (either with success or failure), and a
// Result structure will be passed to the callback. That callback should then
// call g_mount_unmount_with_operation_finish() with the #GMount and the Result
// data to see if the operation was completed successfully. If an @error is
// present when g_mount_unmount_with_operation_finish() is called, then it will
// be filled with any error information.
	type Mount struct {
		**externglib.Object
		
	}

	
	func marshalMount(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Mount{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CanEject checks if @mount can be ejected.
	func (m Mount) CanEject() bool {
var _arg0 *C.GMount // out
var _cret C.gboolean // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_can_eject(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanUnmount checks if @mount can be unmounted.
	func (m Mount) CanUnmount() bool {
var _arg0 *C.GMount // out
var _cret C.gboolean // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_can_unmount(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EjectFinish finishes ejecting a mount. If any errors occurred during the
// operation, @error will be set to contain the errors and false will be
// returned.
	func (m Mount) EjectFinish(result AsyncResult) error {
var _arg0 *C.GMount // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_mount_eject_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// EjectWithOperationFinish finishes ejecting a mount. If any errors occurred
// during the operation, @error will be set to contain the errors and false will
// be returned.
	func (m Mount) EjectWithOperationFinish(result AsyncResult) error {
var _arg0 *C.GMount // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_mount_eject_with_operation_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// DefaultLocation gets the default location of @mount. The default location of
// the given @mount is a path that reflects the main entry point for the user
// (e.g. the home directory, or the root of the volume).
	func (m Mount) DefaultLocation() File {
var _arg0 *C.GMount // out
var _cret *C.GFile // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_get_default_location(_arg0)


var _file File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _file
}
	
	// Drive gets the drive for the @mount.
// 
// This is a convenience method for getting the #GVolume and then using that
// object to get the #GDrive.
	func (m Mount) Drive() Drive {
var _arg0 *C.GMount // out
var _cret *C.GDrive // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_get_drive(_arg0)


var _drive Drive // out

_drive = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Drive)

return _drive
}
	
	// Icon gets the icon for @mount.
	func (m Mount) Icon() Icon {
var _arg0 *C.GMount // out
var _cret *C.GIcon // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_get_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// Name gets the name of @mount.
	func (m Mount) Name() string {
var _arg0 *C.GMount // out
var _cret *C.char // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Root gets the root directory on @mount.
	func (m Mount) Root() File {
var _arg0 *C.GMount // out
var _cret *C.GFile // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_get_root(_arg0)


var _file File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _file
}
	
	// SortKey gets the sort key for @mount, if any.
	func (m Mount) SortKey() string {
var _arg0 *C.GMount // out
var _cret *C.gchar // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_get_sort_key(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SymbolicIcon gets the symbolic icon for @mount.
	func (m Mount) SymbolicIcon() Icon {
var _arg0 *C.GMount // out
var _cret *C.GIcon // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_get_symbolic_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// UUID gets the UUID for the @mount. The reference is typically based on the
// file system UUID for the mount in question and should be considered an opaque
// string. Returns nil if there is no UUID available.
	func (m Mount) UUID() string {
var _arg0 *C.GMount // out
var _cret *C.char // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_get_uuid(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Volume gets the volume for the @mount.
	func (m Mount) Volume() Volume {
var _arg0 *C.GMount // out
var _cret *C.GVolume // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_get_volume(_arg0)


var _volume Volume // out

_volume = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Volume)

return _volume
}
	
	// GuessContentTypeFinish finishes guessing content types of @mount. If any
// errors occurred during the operation, @error will be set to contain the
// errors and false will be returned. In particular, you may get an
// G_IO_ERROR_NOT_SUPPORTED if the mount does not support content guessing.
	func (m Mount) GuessContentTypeFinish(result AsyncResult) ([]string, error) {
var _arg0 *C.GMount // out
var _arg1 *C.GAsyncResult // out
var _cret **C.gchar
var _cerr *C.GError // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_mount_guess_content_type_finish(_arg0, _arg1, &_cerr)


var _utf8s []string
var _goerr error // out

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8s, _goerr
}
	
	// GuessContentTypeSync tries to guess the type of content stored on @mount.
// Returns one or more textual identifiers of well-known content types
// (typically prefixed with "x-content/"), e.g. x-content/image-dcf for camera
// memory cards. See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
// 
// This is a synchronous operation and as such may block doing IO; see
// g_mount_guess_content_type() for the asynchronous version.
	func (m Mount) GuessContentTypeSync(forceRescan bool, cancellable CancellableClass) ([]string, error) {
var _arg0 *C.GMount // out
var _arg1 C.gboolean // out
var _arg2 *C.GCancellable // out
var _cret **C.gchar
var _cerr *C.GError // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
if forceRescan { _arg1 = C.TRUE }
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_mount_guess_content_type_sync(_arg0, _arg1, _arg2, &_cerr)


var _utf8s []string
var _goerr error // out

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8s, _goerr
}
	
	// IsShadowed determines if @mount is shadowed. Applications or libraries should
// avoid displaying @mount in the user interface if it is shadowed.
// 
// A mount is said to be shadowed if there exists one or more user visible
// objects (currently #GMount objects) with a root that is inside the root of
// @mount.
// 
// One application of shadow mounts is when exposing a single file system that
// is used to address several logical volumes. In this situation, a Monitor
// implementation would create two #GVolume objects (for example, one for the
// camera functionality of the device and one for a SD card reader on the
// device) with activation URIs `gphoto2://[usb:001,002]/store1/` and
// `gphoto2://[usb:001,002]/store2/`. When the underlying mount (with root
// `gphoto2://[usb:001,002]/`) is mounted, said Monitor implementation would
// create two #GMount objects (each with their root matching the corresponding
// volume activation root) that would shadow the original mount.
// 
// The proxy monitor in GVfs 2.26 and later, automatically creates and manage
// shadow mounts (and shadows the underlying mount) if the activation root on a
// #GVolume is set.
	func (m Mount) IsShadowed() bool {
var _arg0 *C.GMount // out
var _cret C.gboolean // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

_cret = C.g_mount_is_shadowed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemountFinish finishes remounting a mount. If any errors occurred during the
// operation, @error will be set to contain the errors and false will be
// returned.
	func (m Mount) RemountFinish(result AsyncResult) error {
var _arg0 *C.GMount // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_mount_remount_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Shadow increments the shadow count on @mount. Usually used by Monitor
// implementations when creating a shadow mount for @mount, see
// g_mount_is_shadowed() for more information. The caller will need to emit the
// #GMount::changed signal on @mount manually.
	func (m Mount) Shadow()  {
var _arg0 *C.GMount // out

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

C.g_mount_shadow(_arg0)
}
	
	// UnmountFinish finishes unmounting a mount. If any errors occurred during the
// operation, @error will be set to contain the errors and false will be
// returned.
	func (m Mount) UnmountFinish(result AsyncResult) error {
var _arg0 *C.GMount // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_mount_unmount_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// UnmountWithOperationFinish finishes unmounting a mount. If any errors
// occurred during the operation, @error will be set to contain the errors and
// false will be returned.
	func (m Mount) UnmountWithOperationFinish(result AsyncResult) error {
var _arg0 *C.GMount // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_mount_unmount_with_operation_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Unshadow decrements the shadow count on @mount. Usually used by Monitor
// implementations when destroying a shadow mount for @mount, see
// g_mount_is_shadowed() for more information. The caller will need to emit the
// #GMount::changed signal on @mount manually.
	func (m Mount) Unshadow()  {
var _arg0 *C.GMount // out

_arg0 = (*C.GMount)(unsafe.Pointer(m.Native()))

C.g_mount_unshadow(_arg0)
}
	


	
	// NetworkMonitorInterface contains virtual methods for NetworkMonitor, or
	// methods that can be overridden.
	type NetworkMonitorInterface interface {
		gextras.Objector

			// CanReach attempts to determine whether or not the host pointed to by
	// @connectable can be reached, without actually trying to connect to it.
	// 
	// This may return true even when Monitor:network-available is false, if,
	// for example, @monitor can determine that @connectable refers to a host on
	// a local network.
	// 
	// If @monitor believes that an attempt to connect to @connectable will
	// succeed, it will return true. Otherwise, it will return false and set
	// @error to an appropriate error (such as G_IO_ERROR_HOST_UNREACHABLE).
	// 
	// Note that although this does not attempt to connect to @connectable, it
	// may still block for a brief period of time (eg, trying to do multicast
	// DNS on the local network), so if you do not want to block, you should use
	// g_network_monitor_can_reach_async().
		CanReach(connectable SocketConnectable, cancellable CancellableClass) error
			// CanReachFinish finishes an async network connectivity test. See
	// g_network_monitor_can_reach_async().
		CanReachFinish(result AsyncResult) error
		
		NetworkChanged(networkAvailable bool) 
		
	}
	

	// NetworkMonitor provides an easy-to-use cross-platform API for monitoring
// network connectivity. On Linux, the available implementations are based on
// the kernel's netlink interface and on NetworkManager.
// 
// There is also an implementation for use inside Flatpak sandboxes.
	type NetworkMonitor struct {
		Initable
		
	}

	
	func marshalNetworkMonitor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {NetworkMonitor{
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CanReach attempts to determine whether or not the host pointed to by
// @connectable can be reached, without actually trying to connect to it.
// 
// This may return true even when Monitor:network-available is false, if, for
// example, @monitor can determine that @connectable refers to a host on a local
// network.
// 
// If @monitor believes that an attempt to connect to @connectable will succeed,
// it will return true. Otherwise, it will return false and set @error to an
// appropriate error (such as G_IO_ERROR_HOST_UNREACHABLE).
// 
// Note that although this does not attempt to connect to @connectable, it may
// still block for a brief period of time (eg, trying to do multicast DNS on the
// local network), so if you do not want to block, you should use
// g_network_monitor_can_reach_async().
	func (m NetworkMonitor) CanReach(connectable SocketConnectable, cancellable CancellableClass) error {
var _arg0 *C.GNetworkMonitor // out
var _arg1 *C.GSocketConnectable // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(connectable.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_network_monitor_can_reach(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CanReachFinish finishes an async network connectivity test. See
// g_network_monitor_can_reach_async().
	func (m NetworkMonitor) CanReachFinish(result AsyncResult) error {
var _arg0 *C.GNetworkMonitor // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_network_monitor_can_reach_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Connectivity gets a more detailed networking state than
// g_network_monitor_get_network_available().
// 
// If Monitor:network-available is false, then the connectivity state will be
// G_NETWORK_CONNECTIVITY_LOCAL.
// 
// If Monitor:network-available is true, then the connectivity state will be
// G_NETWORK_CONNECTIVITY_FULL (if there is full Internet connectivity),
// G_NETWORK_CONNECTIVITY_LIMITED (if the host has a default route, but appears
// to be unable to actually reach the full Internet), or
// G_NETWORK_CONNECTIVITY_PORTAL (if the host is trapped behind a "captive
// portal" that requires some sort of login or acknowledgement before allowing
// full Internet access).
// 
// Note that in the case of G_NETWORK_CONNECTIVITY_LIMITED and
// G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are reachable
// but others are not. In this case, applications can attempt to connect to
// remote servers, but should gracefully fall back to their "offline" behavior
// if the connection attempt fails.
	func (m NetworkMonitor) Connectivity() NetworkConnectivity {
var _arg0 *C.GNetworkMonitor // out
var _cret C.GNetworkConnectivity // in

_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))

_cret = C.g_network_monitor_get_connectivity(_arg0)


var _networkConnectivity NetworkConnectivity // out

_networkConnectivity = NetworkConnectivity(_cret)

return _networkConnectivity
}
	
	// NetworkAvailable checks if the network is available. "Available" here means
// that the system has a default route available for at least one of IPv4 or
// IPv6. It does not necessarily imply that the public Internet is reachable.
// See Monitor:network-available for more details.
	func (m NetworkMonitor) NetworkAvailable() bool {
var _arg0 *C.GNetworkMonitor // out
var _cret C.gboolean // in

_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))

_cret = C.g_network_monitor_get_network_available(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// NetworkMetered checks if the network is metered. See Monitor:network-metered
// for more details.
	func (m NetworkMonitor) NetworkMetered() bool {
var _arg0 *C.GNetworkMonitor // out
var _cret C.gboolean // in

_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(m.Native()))

_cret = C.g_network_monitor_get_network_metered(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// PollableInputStreamInterface contains virtual methods for PollableInputStream, or
	// methods that can be overridden.
	type PollableInputStreamInterface interface {
		gextras.Objector

			// CanPoll checks if @stream is actually pollable. Some classes may
	// implement InputStream but have only certain instances of that class be
	// pollable. If this method returns false, then the behavior of other
	// InputStream methods is undefined.
	// 
	// For any given stream, the value returned by this method is constant; a
	// stream cannot switch from pollable to non-pollable or vice versa.
		CanPoll() bool
			// IsReadable checks if @stream can be read.
	// 
	// Note that some stream types may not be able to implement this 100%
	// reliably, and it is possible that a call to g_input_stream_read() after
	// this returns true would still block. To guarantee non-blocking behavior,
	// you should always use g_pollable_input_stream_read_nonblocking(), which
	// will return a G_IO_ERROR_WOULD_BLOCK error rather than blocking.
		IsReadable() bool
			// ReadNonblocking attempts to read up to @count bytes from @stream into
	// @buffer, as with g_input_stream_read(). If @stream is not currently
	// readable, this will immediately return G_IO_ERROR_WOULD_BLOCK, and you
	// can use g_pollable_input_stream_create_source() to create a #GSource that
	// will be triggered when @stream is readable.
	// 
	// Note that since this method never blocks, you cannot actually use
	// @cancellable to cancel it. However, it will return an error if
	// @cancellable has already been cancelled when you call, which may happen
	// if you call this method after a source triggers due to having been
	// cancelled.
		ReadNonblocking(buffer []byte) (int, error)
		
	}
	

	// PollableInputStream is implemented by Streams that can be polled for
// readiness to read. This can be used when interfacing with a non-GIO API that
// expects UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
	type PollableInputStream struct {
		InputStream
		
	}

	
	func marshalPollableInputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {PollableInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CanPoll checks if @stream is actually pollable. Some classes may implement
// InputStream but have only certain instances of that class be pollable. If
// this method returns false, then the behavior of other InputStream methods is
// undefined.
// 
// For any given stream, the value returned by this method is constant; a stream
// cannot switch from pollable to non-pollable or vice versa.
	func (s PollableInputStream) CanPoll() bool {
var _arg0 *C.GPollableInputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_pollable_input_stream_can_poll(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsReadable checks if @stream can be read.
// 
// Note that some stream types may not be able to implement this 100% reliably,
// and it is possible that a call to g_input_stream_read() after this returns
// true would still block. To guarantee non-blocking behavior, you should always
// use g_pollable_input_stream_read_nonblocking(), which will return a
// G_IO_ERROR_WOULD_BLOCK error rather than blocking.
	func (s PollableInputStream) IsReadable() bool {
var _arg0 *C.GPollableInputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_pollable_input_stream_is_readable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ReadNonblocking attempts to read up to @count bytes from @stream into
// @buffer, as with g_input_stream_read(). If @stream is not currently readable,
// this will immediately return G_IO_ERROR_WOULD_BLOCK, and you can use
// g_pollable_input_stream_create_source() to create a #GSource that will be
// triggered when @stream is readable.
// 
// Note that since this method never blocks, you cannot actually use
// @cancellable to cancel it. However, it will return an error if @cancellable
// has already been cancelled when you call, which may happen if you call this
// method after a source triggers due to having been cancelled.
	func (s PollableInputStream) ReadNonblocking(buffer []byte, cancellable CancellableClass) (int, error) {
var _arg0 *C.GPollableInputStream // out
var _arg1 *C.void
var _arg2 C.gsize
var _arg3 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(buffer))
_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_pollable_input_stream_read_nonblocking(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	


	
	// PollableOutputStreamInterface contains virtual methods for PollableOutputStream, or
	// methods that can be overridden.
	type PollableOutputStreamInterface interface {
		gextras.Objector

			// CanPoll checks if @stream is actually pollable. Some classes may
	// implement OutputStream but have only certain instances of that class be
	// pollable. If this method returns false, then the behavior of other
	// OutputStream methods is undefined.
	// 
	// For any given stream, the value returned by this method is constant; a
	// stream cannot switch from pollable to non-pollable or vice versa.
		CanPoll() bool
			// IsWritable checks if @stream can be written.
	// 
	// Note that some stream types may not be able to implement this 100%
	// reliably, and it is possible that a call to g_output_stream_write() after
	// this returns true would still block. To guarantee non-blocking behavior,
	// you should always use g_pollable_output_stream_write_nonblocking(), which
	// will return a G_IO_ERROR_WOULD_BLOCK error rather than blocking.
		IsWritable() bool
			// WriteNonblocking attempts to write up to @count bytes from @buffer to
	// @stream, as with g_output_stream_write(). If @stream is not currently
	// writable, this will immediately return G_IO_ERROR_WOULD_BLOCK, and you
	// can use g_pollable_output_stream_create_source() to create a #GSource
	// that will be triggered when @stream is writable.
	// 
	// Note that since this method never blocks, you cannot actually use
	// @cancellable to cancel it. However, it will return an error if
	// @cancellable has already been cancelled when you call, which may happen
	// if you call this method after a source triggers due to having been
	// cancelled.
	// 
	// Also note that if G_IO_ERROR_WOULD_BLOCK is returned some underlying
	// transports like D/TLS require that you re-send the same @buffer and
	// @count in the next write call.
		WriteNonblocking(buffer []byte) (int, error)
			// WritevNonblocking attempts to write the bytes contained in the @n_vectors
	// @vectors to @stream, as with g_output_stream_writev(). If @stream is not
	// currently writable, this will immediately return
	// %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can use
	// g_pollable_output_stream_create_source() to create a #GSource that will
	// be triggered when @stream is writable. @error will *not* be set in that
	// case.
	// 
	// Note that since this method never blocks, you cannot actually use
	// @cancellable to cancel it. However, it will return an error if
	// @cancellable has already been cancelled when you call, which may happen
	// if you call this method after a source triggers due to having been
	// cancelled.
	// 
	// Also note that if G_POLLABLE_RETURN_WOULD_BLOCK is returned some
	// underlying transports like D/TLS require that you re-send the same
	// @vectors and @n_vectors in the next write call.
		WritevNonblocking(vectors []OutputVector) (uint, PollableReturn, error)
		
	}
	

	// PollableOutputStream is implemented by Streams that can be polled for
// readiness to write. This can be used when interfacing with a non-GIO API that
// expects UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
	type PollableOutputStream struct {
		OutputStream
		
	}

	
	func marshalPollableOutputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {PollableOutputStream{
OutputStream: OutputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CanPoll checks if @stream is actually pollable. Some classes may implement
// OutputStream but have only certain instances of that class be pollable. If
// this method returns false, then the behavior of other OutputStream methods is
// undefined.
// 
// For any given stream, the value returned by this method is constant; a stream
// cannot switch from pollable to non-pollable or vice versa.
	func (s PollableOutputStream) CanPoll() bool {
var _arg0 *C.GPollableOutputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_pollable_output_stream_can_poll(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsWritable checks if @stream can be written.
// 
// Note that some stream types may not be able to implement this 100% reliably,
// and it is possible that a call to g_output_stream_write() after this returns
// true would still block. To guarantee non-blocking behavior, you should always
// use g_pollable_output_stream_write_nonblocking(), which will return a
// G_IO_ERROR_WOULD_BLOCK error rather than blocking.
	func (s PollableOutputStream) IsWritable() bool {
var _arg0 *C.GPollableOutputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_pollable_output_stream_is_writable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WriteNonblocking attempts to write up to @count bytes from @buffer to
// @stream, as with g_output_stream_write(). If @stream is not currently
// writable, this will immediately return G_IO_ERROR_WOULD_BLOCK, and you can
// use g_pollable_output_stream_create_source() to create a #GSource that will
// be triggered when @stream is writable.
// 
// Note that since this method never blocks, you cannot actually use
// @cancellable to cancel it. However, it will return an error if @cancellable
// has already been cancelled when you call, which may happen if you call this
// method after a source triggers due to having been cancelled.
// 
// Also note that if G_IO_ERROR_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same @buffer and @count in
// the next write call.
	func (s PollableOutputStream) WriteNonblocking(buffer []byte, cancellable CancellableClass) (int, error) {
var _arg0 *C.GPollableOutputStream // out
var _arg1 *C.void
var _arg2 C.gsize
var _arg3 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(buffer))
_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_pollable_output_stream_write_nonblocking(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// WritevNonblocking attempts to write the bytes contained in the @n_vectors
// @vectors to @stream, as with g_output_stream_writev(). If @stream is not
// currently writable, this will immediately return
// %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can use
// g_pollable_output_stream_create_source() to create a #GSource that will be
// triggered when @stream is writable. @error will *not* be set in that case.
// 
// Note that since this method never blocks, you cannot actually use
// @cancellable to cancel it. However, it will return an error if @cancellable
// has already been cancelled when you call, which may happen if you call this
// method after a source triggers due to having been cancelled.
// 
// Also note that if G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same @vectors and
// @n_vectors in the next write call.
	func (s PollableOutputStream) WritevNonblocking(vectors []OutputVector, cancellable CancellableClass) (uint, PollableReturn, error) {
var _arg0 *C.GPollableOutputStream // out
var _arg1 *C.GOutputVector
var _arg2 C.gsize
var _arg3 C.gsize // in
var _arg4 *C.GCancellable // out
var _cret C.GPollableReturn // in
var _cerr *C.GError // in

_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(vectors))
_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_pollable_output_stream_writev_nonblocking(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)


var _bytesWritten uint // out
var _pollableReturn PollableReturn // out
var _goerr error // out

_bytesWritten = (uint)(_arg3)
_pollableReturn = PollableReturn(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesWritten, _pollableReturn, _goerr
}
	


	
	// ProXYInterface contains virtual methods for ProXY, or
	// methods that can be overridden.
	type ProXYInterface interface {
		gextras.Objector

			// ConnectProXY: given @connection to communicate with a proxy (eg, a
	// Connection that is connected to the proxy server), this does the
	// necessary handshake to connect to @proxy_address, and if required, wraps
	// the OStream to handle proxy payload.
		ConnectProXY(connection IOStreamClass, proxyAddress ProXYAddressClass, cancellable CancellableClass) (IOStream, error)
			// ConnectFinish: see g_proxy_connect().
		ConnectFinish(result AsyncResult) (IOStream, error)
			// SupportsHostname: some proxy protocols expect to be passed a hostname,
	// which they will resolve to an IP address themselves. Others, like SOCKS4,
	// do not allow this. This function will return false if @proxy is
	// implementing such a protocol. When false is returned, the caller should
	// resolve the destination hostname first, and then pass a Address
	// containing the stringified IP address to g_proxy_connect() or
	// g_proxy_connect_async().
		SupportsHostname() bool
		
	}
	

	// ProXY: a #GProxy handles connecting to a remote host via a given type of
// proxy server. It is implemented by the 'gio-proxy' extension point. The
// extensions are named after their proxy protocol name. As an example, a SOCKS5
// proxy implementation can be retrieved with the name 'socks5' using the
// function g_io_extension_point_get_extension_by_name().
	type ProXY struct {
		**externglib.Object
		
	}

	
	func marshalProXY(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ProXY{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// ConnectProXY: given @connection to communicate with a proxy (eg, a Connection
// that is connected to the proxy server), this does the necessary handshake to
// connect to @proxy_address, and if required, wraps the OStream to handle proxy
// payload.
	func (p ProXY) ConnectProXY(connection IOStreamClass, proxyAddress ProXYAddressClass, cancellable CancellableClass) (IOStream, error) {
var _arg0 *C.GProxy // out
var _arg1 *C.GIOStream // out
var _arg2 *C.GProxyAddress // out
var _arg3 *C.GCancellable // out
var _cret *C.GIOStream // in
var _cerr *C.GError // in

_arg0 = (*C.GProxy)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GIOStream)(unsafe.Pointer(connection.Native()))
_arg2 = (*C.GProxyAddress)(unsafe.Pointer(proxyAddress.Native()))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_proxy_connect(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _ioStream IOStream // out
var _goerr error // out

_ioStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _ioStream, _goerr
}
	
	// ConnectFinish: see g_proxy_connect().
	func (p ProXY) ConnectFinish(result AsyncResult) (IOStream, error) {
var _arg0 *C.GProxy // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GIOStream // in
var _cerr *C.GError // in

_arg0 = (*C.GProxy)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_proxy_connect_finish(_arg0, _arg1, &_cerr)


var _ioStream IOStream // out
var _goerr error // out

_ioStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IOStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _ioStream, _goerr
}
	
	// SupportsHostname: some proxy protocols expect to be passed a hostname, which
// they will resolve to an IP address themselves. Others, like SOCKS4, do not
// allow this. This function will return false if @proxy is implementing such a
// protocol. When false is returned, the caller should resolve the destination
// hostname first, and then pass a Address containing the stringified IP address
// to g_proxy_connect() or g_proxy_connect_async().
	func (p ProXY) SupportsHostname() bool {
var _arg0 *C.GProxy // out
var _cret C.gboolean // in

_arg0 = (*C.GProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_proxy_supports_hostname(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// ProXYResolverInterface contains virtual methods for ProXYResolver, or
	// methods that can be overridden.
	type ProXYResolverInterface interface {
		gextras.Objector

			// IsSupported checks if @resolver can be used on this system. (This is used
	// internally; g_proxy_resolver_get_default() will only return a proxy
	// resolver that returns true for this method.)
		IsSupported() bool
			// Lookup looks into the system proxy configuration to determine what proxy,
	// if any, to use to connect to @uri. The returned proxy URIs are of the
	// form `<protocol>://[user[:password]@]host:port` or `direct://`, where
	// <protocol> could be http, rtsp, socks or other proxying protocol.
	// 
	// If you don't know what network protocol is being used on the socket, you
	// should use `none` as the URI protocol. In this case, the resolver might
	// still return a generic proxy type (such as SOCKS), but would not return
	// protocol-specific proxy types (such as http).
	// 
	// `direct://` is used when no proxy is needed. Direct connection should not
	// be attempted unless it is part of the returned array of proxies.
		Lookup(uri string, cancellable CancellableClass) ([]string, error)
			// LookupFinish: call this function to obtain the array of proxy URIs when
	// g_proxy_resolver_lookup_async() is complete. See
	// g_proxy_resolver_lookup() for more details.
		LookupFinish(result AsyncResult) ([]string, error)
		
	}
	

	// ProXYResolver provides synchronous and asynchronous network proxy resolution.
// Resolver is used within Client through the method
// g_socket_connectable_proxy_enumerate().
// 
// Implementations of Resolver based on libproxy and GNOME settings can be found
// in glib-networking. GIO comes with an implementation for use inside Flatpak
// portals.
	type ProXYResolver struct {
		**externglib.Object
		
	}

	
	func marshalProXYResolver(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ProXYResolver{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// IsSupported checks if @resolver can be used on this system. (This is used
// internally; g_proxy_resolver_get_default() will only return a proxy resolver
// that returns true for this method.)
	func (r ProXYResolver) IsSupported() bool {
var _arg0 *C.GProxyResolver // out
var _cret C.gboolean // in

_arg0 = (*C.GProxyResolver)(unsafe.Pointer(r.Native()))

_cret = C.g_proxy_resolver_is_supported(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Lookup looks into the system proxy configuration to determine what proxy, if
// any, to use to connect to @uri. The returned proxy URIs are of the form
// `<protocol>://[user[:password]@]host:port` or `direct://`, where <protocol>
// could be http, rtsp, socks or other proxying protocol.
// 
// If you don't know what network protocol is being used on the socket, you
// should use `none` as the URI protocol. In this case, the resolver might still
// return a generic proxy type (such as SOCKS), but would not return
// protocol-specific proxy types (such as http).
// 
// `direct://` is used when no proxy is needed. Direct connection should not be
// attempted unless it is part of the returned array of proxies.
	func (r ProXYResolver) Lookup(uri string, cancellable CancellableClass) ([]string, error) {
var _arg0 *C.GProxyResolver // out
var _arg1 *C.gchar // out
var _arg2 *C.GCancellable // out
var _cret **C.gchar
var _cerr *C.GError // in

_arg0 = (*C.GProxyResolver)(unsafe.Pointer(r.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_proxy_resolver_lookup(_arg0, _arg1, _arg2, &_cerr)


var _utf8s []string
var _goerr error // out

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8s, _goerr
}
	
	// LookupFinish: call this function to obtain the array of proxy URIs when
// g_proxy_resolver_lookup_async() is complete. See g_proxy_resolver_lookup()
// for more details.
	func (r ProXYResolver) LookupFinish(result AsyncResult) ([]string, error) {
var _arg0 *C.GProxyResolver // out
var _arg1 *C.GAsyncResult // out
var _cret **C.gchar
var _cerr *C.GError // in

_arg0 = (*C.GProxyResolver)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_proxy_resolver_lookup_finish(_arg0, _arg1, &_cerr)


var _utf8s []string
var _goerr error // out

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8s, _goerr
}
	


	
	// RemoteActionGroupInterface contains virtual methods for RemoteActionGroup, or
	// methods that can be overridden.
	type RemoteActionGroupInterface interface {
		gextras.Objector

			// ActivateActionFull activates the remote action.
	// 
	// This is the same as g_action_group_activate_action() except that it
	// allows for provision of "platform data" to be sent along with the
	// activation request. This typically contains details such as the user
	// interaction timestamp or startup notification information.
	// 
	// @platform_data must be non-nil and must have the type
	// G_VARIANT_TYPE_VARDICT. If it is floating, it will be consumed.
		ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant) 
			// ChangeActionStateFull changes the state of a remote action.
	// 
	// This is the same as g_action_group_change_action_state() except that it
	// allows for provision of "platform data" to be sent along with the state
	// change request. This typically contains details such as the user
	// interaction timestamp or startup notification information.
	// 
	// @platform_data must be non-nil and must have the type
	// G_VARIANT_TYPE_VARDICT. If it is floating, it will be consumed.
		ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant) 
		
	}
	

	// RemoteActionGroup: the GRemoteActionGroup interface is implemented by Group
// instances that either transmit action invocations to other processes or
// receive action invocations in the local process from other processes.
// 
// The interface has `_full` variants of the two methods on Group used to
// activate actions: g_action_group_activate_action() and
// g_action_group_change_action_state(). These variants allow a "platform data"
// #GVariant to be specified: a dictionary providing context for the action
// invocation (for example: timestamps, startup notification IDs, etc).
// 
// BusActionGroup implements ActionGroup. This provides a mechanism to send
// platform data for action invocations over D-Bus.
// 
// Additionally, g_dbus_connection_export_action_group() will check if the
// exported Group implements ActionGroup and use the `_full` variants of the
// calls if available. This provides a mechanism by which to receive platform
// data for action invocations that arrive by way of D-Bus.
	type RemoteActionGroup struct {
		ActionGroup
		
	}

	
	func marshalRemoteActionGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {RemoteActionGroup{
ActionGroup: ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// ActivateActionFull activates the remote action.
// 
// This is the same as g_action_group_activate_action() except that it allows
// for provision of "platform data" to be sent along with the activation
// request. This typically contains details such as the user interaction
// timestamp or startup notification information.
// 
// @platform_data must be non-nil and must have the type G_VARIANT_TYPE_VARDICT.
// If it is floating, it will be consumed.
	func (r RemoteActionGroup) ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant)  {
var _arg0 *C.GRemoteActionGroup // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out
var _arg3 *C.GVariant // out

_arg0 = (*C.GRemoteActionGroup)(unsafe.Pointer(r.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))
_arg3 = (*C.GVariant)(unsafe.Pointer(platformData.Native()))

C.g_remote_action_group_activate_action_full(_arg0, _arg1, _arg2, _arg3)
}
	
	// ChangeActionStateFull changes the state of a remote action.
// 
// This is the same as g_action_group_change_action_state() except that it
// allows for provision of "platform data" to be sent along with the state
// change request. This typically contains details such as the user interaction
// timestamp or startup notification information.
// 
// @platform_data must be non-nil and must have the type G_VARIANT_TYPE_VARDICT.
// If it is floating, it will be consumed.
	func (r RemoteActionGroup) ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant)  {
var _arg0 *C.GRemoteActionGroup // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out
var _arg3 *C.GVariant // out

_arg0 = (*C.GRemoteActionGroup)(unsafe.Pointer(r.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))
_arg3 = (*C.GVariant)(unsafe.Pointer(platformData.Native()))

C.g_remote_action_group_change_action_state_full(_arg0, _arg1, _arg2, _arg3)
}
	


	
	// SeekableInterface contains virtual methods for Seekable, or
	// methods that can be overridden.
	type SeekableInterface interface {
		gextras.Objector

			// CanSeek tests if the stream supports the Iface.
		CanSeek() bool
			// CanTruncate tests if the length of the stream can be adjusted with
	// g_seekable_truncate().
		CanTruncate() bool
			// Seek seeks in the stream by the given @offset, modified by @type.
	// 
	// Attempting to seek past the end of the stream will have different results
	// depending on if the stream is fixed-sized or resizable. If the stream is
	// resizable then seeking past the end and then writing will result in zeros
	// filling the empty space. Seeking past the end of a resizable stream and
	// reading will result in EOF. Seeking past the end of a fixed-sized stream
	// will fail.
	// 
	// Any operation that would result in a negative offset will fail.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
		Seek(offset int64, typ glib.SeekType, cancellable CancellableClass) error
			// Tell tells the current position within the stream.
		Tell() int64
			// TruncateFn sets the length of the stream to @offset. If the stream was
	// previously larger than @offset, the extra data is discarded. If the
	// stream was previously shorter than @offset, it is extended with NUL
	// ('\0') bytes.
	// 
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
		TruncateFn(offset int64, cancellable CancellableClass) error
		
	}
	

	// Seekable is implemented by streams (implementations of Stream or Stream) that
// support seeking.
// 
// Seekable streams largely fall into two categories: resizable and fixed-size.
// 
// #GSeekable on fixed-sized streams is approximately the same as POSIX lseek()
// on a block device (for example: attempting to seek past the end of the device
// is an error). Fixed streams typically cannot be truncated.
// 
// #GSeekable on resizable streams is approximately the same as POSIX lseek() on
// a normal file. Seeking past the end and writing data will usually cause the
// stream to resize by introducing zero bytes.
	type Seekable struct {
		**externglib.Object
		
	}

	
	func marshalSeekable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Seekable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CanSeek tests if the stream supports the Iface.
	func (s Seekable) CanSeek() bool {
var _arg0 *C.GSeekable // out
var _cret C.gboolean // in

_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))

_cret = C.g_seekable_can_seek(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanTruncate tests if the length of the stream can be adjusted with
// g_seekable_truncate().
	func (s Seekable) CanTruncate() bool {
var _arg0 *C.GSeekable // out
var _cret C.gboolean // in

_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))

_cret = C.g_seekable_can_truncate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Seek seeks in the stream by the given @offset, modified by @type.
// 
// Attempting to seek past the end of the stream will have different results
// depending on if the stream is fixed-sized or resizable. If the stream is
// resizable then seeking past the end and then writing will result in zeros
// filling the empty space. Seeking past the end of a resizable stream and
// reading will result in EOF. Seeking past the end of a fixed-sized stream will
// fail.
// 
// Any operation that would result in a negative offset will fail.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (s Seekable) Seek(offset int64, typ glib.SeekType, cancellable CancellableClass) error {
var _arg0 *C.GSeekable // out
var _arg1 C.goffset // out
var _arg2 C.GSeekType // out
var _arg3 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))
_arg1 = (C.goffset)(offset)
_arg2 = (C.GSeekType)(typ)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_seekable_seek(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Tell tells the current position within the stream.
	func (s Seekable) Tell() int64 {
var _arg0 *C.GSeekable // out
var _cret C.goffset // in

_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))

_cret = C.g_seekable_tell(_arg0)


var _gint64 int64 // out

_gint64 = (int64)(_cret)

return _gint64
}
	
	// Truncate sets the length of the stream to @offset. If the stream was
// previously larger than @offset, the extra data is discarded. If the stream
// was previously shorter than @offset, it is extended with NUL ('\0') bytes.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
	func (s Seekable) Truncate(offset int64, cancellable CancellableClass) error {
var _arg0 *C.GSeekable // out
var _arg1 C.goffset // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GSeekable)(unsafe.Pointer(s.Native()))
_arg1 = (C.goffset)(offset)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_seekable_truncate(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	
	// SocketConnectableInterface contains virtual methods for SocketConnectable, or
	// methods that can be overridden.
	type SocketConnectableInterface interface {
		gextras.Objector

			// Enumerate creates a AddressEnumerator for @connectable.
		Enumerate() SocketAddressEnumerator
			// ProXYEnumerate creates a AddressEnumerator for @connectable that will
	// return a Address for each of its addresses that you must connect to via a
	// proxy.
	// 
	// If @connectable does not implement
	// g_socket_connectable_proxy_enumerate(), this will fall back to calling
	// g_socket_connectable_enumerate().
		ProXYEnumerate() SocketAddressEnumerator
			// String: format a Connectable as a string. This is a human-readable format
	// for use in debugging output, and is not a stable serialization format. It
	// is not suitable for use in user interfaces as it exposes too much
	// information for a user.
	// 
	// If the Connectable implementation does not support string formatting, the
	// implementations type name will be returned as a fallback.
		String() string
		
	}
	

	// SocketConnectable objects that describe one or more potential socket
// endpoints implement Connectable. Callers can then use
// g_socket_connectable_enumerate() to get a AddressEnumerator to try out each
// socket address in turn until one succeeds, as shown in the sample code below.
// 
//    MyConnectionType *
//    connect_to_host (const char    *hostname,
//                     guint16        port,
//                     GCancellable  *cancellable,
//                     GError       **error)
//    {
//      MyConnection *conn = NULL;
//      GSocketConnectable *addr;
//      GSocketAddressEnumerator *enumerator;
//      GSocketAddress *sockaddr;
//      GError *conn_error = NULL;
// 
//      addr = g_network_address_new (hostname, port);
//      enumerator = g_socket_connectable_enumerate (addr);
//      g_object_unref (addr);
// 
//      // Try each sockaddr until we succeed. Record the first connection error,
//      // but not any further ones (since they'll probably be basically the same
//      // as the first).
//      while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
//        {
//          conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
//          g_object_unref (sockaddr);
//        }
//      g_object_unref (enumerator);
// 
//      if (conn)
//        {
//          if (conn_error)
//            {
//              // We couldn't connect to the first address, but we succeeded
//              // in connecting to a later address.
//              g_error_free (conn_error);
//            }
//          return conn;
//        }
//      else if (error)
//        {
//          /// Either initial lookup failed, or else the caller cancelled us.
//          if (conn_error)
//            g_error_free (conn_error);
//          return NULL;
//        }
//      else
//        {
//          g_error_propagate (error, conn_error);
//          return NULL;
//        }
//    }
	type SocketConnectable struct {
		**externglib.Object
		
	}

	
	func marshalSocketConnectable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Enumerate creates a AddressEnumerator for @connectable.
	func (c SocketConnectable) Enumerate() SocketAddressEnumerator {
var _arg0 *C.GSocketConnectable // out
var _cret *C.GSocketAddressEnumerator // in

_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_connectable_enumerate(_arg0)


var _socketAddressEnumerator SocketAddressEnumerator // out

_socketAddressEnumerator = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddressEnumerator)

return _socketAddressEnumerator
}
	
	// ProXYEnumerate creates a AddressEnumerator for @connectable that will return
// a Address for each of its addresses that you must connect to via a proxy.
// 
// If @connectable does not implement g_socket_connectable_proxy_enumerate(),
// this will fall back to calling g_socket_connectable_enumerate().
	func (c SocketConnectable) ProXYEnumerate() SocketAddressEnumerator {
var _arg0 *C.GSocketConnectable // out
var _cret *C.GSocketAddressEnumerator // in

_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_connectable_proxy_enumerate(_arg0)


var _socketAddressEnumerator SocketAddressEnumerator // out

_socketAddressEnumerator = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddressEnumerator)

return _socketAddressEnumerator
}
	
	// String: format a Connectable as a string. This is a human-readable format for
// use in debugging output, and is not a stable serialization format. It is not
// suitable for use in user interfaces as it exposes too much information for a
// user.
// 
// If the Connectable implementation does not support string formatting, the
// implementations type name will be returned as a fallback.
	func (c SocketConnectable) String() string {
var _arg0 *C.GSocketConnectable // out
var _cret *C.gchar // in

_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_connectable_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	
	// TLSBackendInterface contains virtual methods for TLSBackend, or
	// methods that can be overridden.
	type TLSBackendInterface interface {
		gextras.Objector

			// DefaultDatabase gets the default Database used to verify TLS connections.
		DefaultDatabase() TLSDatabase
			// SupportsDTLS checks if DTLS is supported. DTLS support may not be
	// available even if TLS support is available, and vice-versa.
		SupportsDTLS() bool
			// SupportsTLS checks if TLS is supported; if this returns false for the
	// default Backend, it means no "real" TLS backend is available.
		SupportsTLS() bool
		
	}
	

	// TLSBackend: TLS (Transport Layer Security, aka SSL) and DTLS backend.
	type TLSBackend struct {
		**externglib.Object
		
	}

	
	func marshalTLSBackend(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TLSBackend{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CertificateType gets the #GType of @backend's Certificate implementation.
	func (b TLSBackend) CertificateType() externglib.Type {
var _arg0 *C.GTlsBackend // out
var _cret C.GType // in

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

_cret = C.g_tls_backend_get_certificate_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// ClientConnectionType gets the #GType of @backend's ClientConnection
// implementation.
	func (b TLSBackend) ClientConnectionType() externglib.Type {
var _arg0 *C.GTlsBackend // out
var _cret C.GType // in

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

_cret = C.g_tls_backend_get_client_connection_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// DefaultDatabase gets the default Database used to verify TLS connections.
	func (b TLSBackend) DefaultDatabase() TLSDatabase {
var _arg0 *C.GTlsBackend // out
var _cret *C.GTlsDatabase // in

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

_cret = C.g_tls_backend_get_default_database(_arg0)


var _tlsDatabase TLSDatabase // out

_tlsDatabase = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSDatabase)

return _tlsDatabase
}
	
	// DTLSClientConnectionType gets the #GType of @backends ClientConnection
// implementation.
	func (b TLSBackend) DTLSClientConnectionType() externglib.Type {
var _arg0 *C.GTlsBackend // out
var _cret C.GType // in

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

_cret = C.g_tls_backend_get_dtls_client_connection_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// DTLSServerConnectionType gets the #GType of @backends ServerConnection
// implementation.
	func (b TLSBackend) DTLSServerConnectionType() externglib.Type {
var _arg0 *C.GTlsBackend // out
var _cret C.GType // in

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

_cret = C.g_tls_backend_get_dtls_server_connection_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// FileDatabaseType gets the #GType of @backend's FileDatabase implementation.
	func (b TLSBackend) FileDatabaseType() externglib.Type {
var _arg0 *C.GTlsBackend // out
var _cret C.GType // in

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

_cret = C.g_tls_backend_get_file_database_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// ServerConnectionType gets the #GType of @backend's ServerConnection
// implementation.
	func (b TLSBackend) ServerConnectionType() externglib.Type {
var _arg0 *C.GTlsBackend // out
var _cret C.GType // in

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

_cret = C.g_tls_backend_get_server_connection_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// SetDefaultDatabase: set the default Database used to verify TLS connections
// 
// Any subsequent call to g_tls_backend_get_default_database() will return the
// database set in this call. Existing databases and connections are not
// modified.
// 
// Setting a nil default database will reset to using the system default
// database as if g_tls_backend_set_default_database() had never been called.
	func (b TLSBackend) SetDefaultDatabase(database TLSDatabaseClass)  {
var _arg0 *C.GTlsBackend // out
var _arg1 *C.GTlsDatabase // out

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(database.Native()))

C.g_tls_backend_set_default_database(_arg0, _arg1)
}
	
	// SupportsDTLS checks if DTLS is supported. DTLS support may not be available
// even if TLS support is available, and vice-versa.
	func (b TLSBackend) SupportsDTLS() bool {
var _arg0 *C.GTlsBackend // out
var _cret C.gboolean // in

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

_cret = C.g_tls_backend_supports_dtls(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SupportsTLS checks if TLS is supported; if this returns false for the default
// Backend, it means no "real" TLS backend is available.
	func (b TLSBackend) SupportsTLS() bool {
var _arg0 *C.GTlsBackend // out
var _cret C.gboolean // in

_arg0 = (*C.GTlsBackend)(unsafe.Pointer(b.Native()))

_cret = C.g_tls_backend_supports_tls(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// TLSClientConnectionInterface contains virtual methods for TLSClientConnection, or
	// methods that can be overridden.
	type TLSClientConnectionInterface interface {
		gextras.Objector

			// CopySessionState: possibly copies session state from one connection to
	// another, for use in TLS session resumption. This is not normally needed,
	// but may be used when the same session needs to be used between different
	// endpoints, as is required by some protocols, such as FTP over TLS.
	// @source should have already completed a handshake and, since TLS 1.3, it
	// should have been used to read data at least once. @conn should not have
	// completed a handshake.
	// 
	// It is not possible to know whether a call to this function will actually
	// do anything. Because session resumption is normally used only for
	// performance benefit, the TLS backend might not implement this function.
	// Even if implemented, it may not actually succeed in allowing @conn to
	// resume @source's TLS session, because the server may not have sent a
	// session resumption token to @source, or it may refuse to accept the token
	// from @conn. There is no way to know whether a call to this function is
	// actually successful.
	// 
	// Using this function is not required to benefit from session resumption.
	// If the TLS backend supports session resumption, the session will be
	// resumed automatically if it is possible to do so without weakening the
	// privacy guarantees normally provided by TLS, without need to call this
	// function. For example, with TLS 1.3, a session ticket will be
	// automatically copied from any ClientConnection that has previously
	// received session tickets from the server, provided a ticket is available
	// that has not previously been used for session resumption, since session
	// ticket reuse would be a privacy weakness. Using this function causes the
	// ticket to be copied without regard for privacy considerations.
		CopySessionState(source TLSClientConnection) 
		
	}
	

	// TLSClientConnection is the client-side subclass of Connection, representing a
// client-side TLS connection.
	type TLSClientConnection struct {
		TLSConnection
		
	}

	
	func marshalTLSClientConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TLSClientConnection{
TLSConnection: TLSConnection{
IOStream: IOStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CopySessionState: possibly copies session state from one connection to
// another, for use in TLS session resumption. This is not normally needed, but
// may be used when the same session needs to be used between different
// endpoints, as is required by some protocols, such as FTP over TLS. @source
// should have already completed a handshake and, since TLS 1.3, it should have
// been used to read data at least once. @conn should not have completed a
// handshake.
// 
// It is not possible to know whether a call to this function will actually do
// anything. Because session resumption is normally used only for performance
// benefit, the TLS backend might not implement this function. Even if
// implemented, it may not actually succeed in allowing @conn to resume
// @source's TLS session, because the server may not have sent a session
// resumption token to @source, or it may refuse to accept the token from @conn.
// There is no way to know whether a call to this function is actually
// successful.
// 
// Using this function is not required to benefit from session resumption. If
// the TLS backend supports session resumption, the session will be resumed
// automatically if it is possible to do so without weakening the privacy
// guarantees normally provided by TLS, without need to call this function. For
// example, with TLS 1.3, a session ticket will be automatically copied from any
// ClientConnection that has previously received session tickets from the
// server, provided a ticket is available that has not previously been used for
// session resumption, since session ticket reuse would be a privacy weakness.
// Using this function causes the ticket to be copied without regard for privacy
// considerations.
	func (c TLSClientConnection) CopySessionState(source TLSClientConnection)  {
var _arg0 *C.GTlsClientConnection // out
var _arg1 *C.GTlsClientConnection // out

_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsClientConnection)(unsafe.Pointer(source.Native()))

C.g_tls_client_connection_copy_session_state(_arg0, _arg1)
}
	
	// ServerIdentity gets @conn's expected server identity
	func (c TLSClientConnection) ServerIdentity() SocketConnectable {
var _arg0 *C.GTlsClientConnection // out
var _cret *C.GSocketConnectable // in

_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_client_connection_get_server_identity(_arg0)


var _socketConnectable SocketConnectable // out

_socketConnectable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SocketConnectable)

return _socketConnectable
}
	
	// UseSSL3: SSL 3.0 is no longer supported. See
// g_tls_client_connection_set_use_ssl3() for details.
	func (c TLSClientConnection) UseSSL3() bool {
var _arg0 *C.GTlsClientConnection // out
var _cret C.gboolean // in

_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_client_connection_get_use_ssl3(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ValidationFlags gets @conn's validation flags
	func (c TLSClientConnection) ValidationFlags() TLSCertificateFlags {
var _arg0 *C.GTlsClientConnection // out
var _cret C.GTlsCertificateFlags // in

_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_client_connection_get_validation_flags(_arg0)


var _tlsCertificateFlags TLSCertificateFlags // out

_tlsCertificateFlags = TLSCertificateFlags(_cret)

return _tlsCertificateFlags
}
	
	// SetServerIdentity sets @conn's expected server identity, which is used both
// to tell servers on virtual hosts which certificate to present, and also to
// let @conn know what name to look for in the certificate when performing
// G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
	func (c TLSClientConnection) SetServerIdentity(identity SocketConnectable)  {
var _arg0 *C.GTlsClientConnection // out
var _arg1 *C.GSocketConnectable // out

_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(identity.Native()))

C.g_tls_client_connection_set_server_identity(_arg0, _arg1)
}
	
	// SetUseSSL3: since GLib 2.42.1, SSL 3.0 is no longer supported.
// 
// From GLib 2.42.1 through GLib 2.62, this function could be used to force use
// of TLS 1.0, the lowest-supported TLS protocol version at the time. In the
// past, this was needed to connect to broken TLS servers that exhibited
// protocol version intolerance. Such servers are no longer common, and using
// TLS 1.0 is no longer considered acceptable.
// 
// Since GLib 2.64, this function does nothing.
	func (c TLSClientConnection) SetUseSSL3(useSsl3 bool)  {
var _arg0 *C.GTlsClientConnection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))
if useSsl3 { _arg1 = C.TRUE }

C.g_tls_client_connection_set_use_ssl3(_arg0, _arg1)
}
	
	// SetValidationFlags sets @conn's validation flags, to override the default set
// of checks performed when validating a server certificate. By default,
// G_TLS_CERTIFICATE_VALIDATE_ALL is used.
	func (c TLSClientConnection) SetValidationFlags(flags TLSCertificateFlags)  {
var _arg0 *C.GTlsClientConnection // out
var _arg1 C.GTlsCertificateFlags // out

_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.GTlsCertificateFlags)(flags)

C.g_tls_client_connection_set_validation_flags(_arg0, _arg1)
}
	


	

	// TLSFileDatabase is implemented by Database objects which load their
// certificate information from a file. It is an interface which TLS library
// specific subtypes implement.
	type TLSFileDatabase struct {
		TLSDatabase
		
	}

	
	func marshalTLSFileDatabase(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TLSFileDatabase{
TLSDatabase: TLSDatabase{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	


	

	// TLSServerConnection is the server-side subclass of Connection, representing a
// server-side TLS connection.
	type TLSServerConnection struct {
		TLSConnection
		
	}

	
	func marshalTLSServerConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TLSServerConnection{
TLSConnection: TLSConnection{
IOStream: IOStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	


	
	// VolumeInterface contains virtual methods for Volume, or
	// methods that can be overridden.
	type VolumeInterface interface {
		gextras.Objector

			// CanEject checks if a volume can be ejected.
		CanEject() bool
			// CanMount checks if a volume can be mounted.
		CanMount() bool
		
		Changed() 
			// EjectFinish finishes ejecting a volume. If any errors occurred during the
	// operation, @error will be set to contain the errors and false will be
	// returned.
		EjectFinish(result AsyncResult) error
			// EjectWithOperationFinish finishes ejecting a volume. If any errors
	// occurred during the operation, @error will be set to contain the errors
	// and false will be returned.
		EjectWithOperationFinish(result AsyncResult) error
			// EnumerateIdentifiers gets the kinds of [identifiers][volume-identifier]
	// that @volume has. Use g_volume_get_identifier() to obtain the identifiers
	// themselves.
		EnumerateIdentifiers() []string
			// ActivationRoot gets the activation root for a #GVolume if it is known
	// ahead of mount time. Returns nil otherwise. If not nil and if @volume is
	// mounted, then the result of g_mount_get_root() on the #GMount object
	// obtained from g_volume_get_mount() will always either be equal or a
	// prefix of what this function returns. In other words, in code
	// 
	//    (g_file_has_prefix (volume_activation_root, mount_root) ||
	//     g_file_equal (volume_activation_root, mount_root))
	// 
	// will always be true.
	// 
	// Activation roots are typically used in Monitor implementations to find
	// the underlying mount to shadow, see g_mount_is_shadowed() for more
	// details.
		ActivationRoot() File
			// Drive gets the drive for the @volume.
		Drive() Drive
			// Icon gets the icon for @volume.
		Icon() Icon
			// Identifier gets the identifier of the given kind for @volume. See the
	// [introduction][volume-identifier] for more information about volume
	// identifiers.
		Identifier(kind string) string
			// Mount gets the mount for the @volume.
		Mount() Mount
			// Name gets the name of @volume.
		Name() string
			// SortKey gets the sort key for @volume, if any.
		SortKey() string
			// SymbolicIcon gets the symbolic icon for @volume.
		SymbolicIcon() Icon
			// UUID gets the UUID for the @volume. The reference is typically based on
	// the file system UUID for the volume in question and should be considered
	// an opaque string. Returns nil if there is no UUID available.
		UUID() string
			// MountFinish finishes mounting a volume. If any errors occurred during the
	// operation, @error will be set to contain the errors and false will be
	// returned.
	// 
	// If the mount operation succeeded, g_volume_get_mount() on @volume is
	// guaranteed to return the mount right after calling this function; there's
	// no need to listen for the 'mount-added' signal on Monitor.
		MountFinish(result AsyncResult) error
		
		Removed() 
			// ShouldAutomount returns whether the volume should be automatically
	// mounted.
		ShouldAutomount() bool
		
	}
	

	// Volume: the #GVolume interface represents user-visible objects that can be
// mounted. Note, when porting from GnomeVFS, #GVolume is the moral equivalent
// of VFSDrive.
// 
// Mounting a #GVolume instance is an asynchronous operation. For more
// information about asynchronous operations, see Result and #GTask. To mount a
// #GVolume, first call g_volume_mount() with (at least) the #GVolume instance,
// optionally a Operation object and a ReadyCallback.
// 
// Typically, one will only want to pass nil for the Operation if automounting
// all volumes when a desktop session starts since it's not desirable to put up
// a lot of dialogs asking for credentials.
// 
// The callback will be fired when the operation has resolved (either with
// success or failure), and a Result instance will be passed to the callback.
// That callback should then call g_volume_mount_finish() with the #GVolume
// instance and the Result data to see if the operation was completed
// successfully. If an @error is present when g_volume_mount_finish() is called,
// then it will be filled with any error information.
// 
// 
// Volume Identifiers
// 
// It is sometimes necessary to directly access the underlying operating system
// object behind a volume (e.g. for passing a volume to an application via the
// commandline). For this purpose, GIO allows to obtain an 'identifier' for the
// volume. There can be different kinds of identifiers, such as Hal UDIs,
// filesystem labels, traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO
// uses predefined strings as names for the different kinds of identifiers:
// VOLUME_IDENTIFIER_KIND_UUID, VOLUME_IDENTIFIER_KIND_LABEL, etc. Use
// g_volume_get_identifier() to obtain an identifier for a volume.
// 
//    Note that VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available when the gvfs hal volume monitor is in use. Other volume monitors will generally be able to provide the VOLUME_IDENTIFIER_KIND_UNIX_DEVICE identifier, which can be used to obtain a hal device by means of libhal_manager_find_device_string_match().
	type Volume struct {
		**externglib.Object
		
	}

	
	func marshalVolume(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Volume{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CanEject checks if a volume can be ejected.
	func (v Volume) CanEject() bool {
var _arg0 *C.GVolume // out
var _cret C.gboolean // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_can_eject(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanMount checks if a volume can be mounted.
	func (v Volume) CanMount() bool {
var _arg0 *C.GVolume // out
var _cret C.gboolean // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_can_mount(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EjectFinish finishes ejecting a volume. If any errors occurred during the
// operation, @error will be set to contain the errors and false will be
// returned.
	func (v Volume) EjectFinish(result AsyncResult) error {
var _arg0 *C.GVolume // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_volume_eject_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// EjectWithOperationFinish finishes ejecting a volume. If any errors occurred
// during the operation, @error will be set to contain the errors and false will
// be returned.
	func (v Volume) EjectWithOperationFinish(result AsyncResult) error {
var _arg0 *C.GVolume // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_volume_eject_with_operation_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// EnumerateIdentifiers gets the kinds of [identifiers][volume-identifier] that
// @volume has. Use g_volume_get_identifier() to obtain the identifiers
// themselves.
	func (v Volume) EnumerateIdentifiers() []string {
var _arg0 *C.GVolume // out
var _cret **C.char

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_enumerate_identifiers(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// ActivationRoot gets the activation root for a #GVolume if it is known ahead
// of mount time. Returns nil otherwise. If not nil and if @volume is mounted,
// then the result of g_mount_get_root() on the #GMount object obtained from
// g_volume_get_mount() will always either be equal or a prefix of what this
// function returns. In other words, in code
// 
//    (g_file_has_prefix (volume_activation_root, mount_root) ||
//     g_file_equal (volume_activation_root, mount_root))
// 
// will always be true.
// 
// Activation roots are typically used in Monitor implementations to find the
// underlying mount to shadow, see g_mount_is_shadowed() for more details.
	func (v Volume) ActivationRoot() File {
var _arg0 *C.GVolume // out
var _cret *C.GFile // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_get_activation_root(_arg0)


var _file File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _file
}
	
	// Drive gets the drive for the @volume.
	func (v Volume) Drive() Drive {
var _arg0 *C.GVolume // out
var _cret *C.GDrive // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_get_drive(_arg0)


var _drive Drive // out

_drive = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Drive)

return _drive
}
	
	// Icon gets the icon for @volume.
	func (v Volume) Icon() Icon {
var _arg0 *C.GVolume // out
var _cret *C.GIcon // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_get_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// Identifier gets the identifier of the given kind for @volume. See the
// [introduction][volume-identifier] for more information about volume
// identifiers.
	func (v Volume) Identifier(kind string) string {
var _arg0 *C.GVolume // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))
_arg1 = (*C.char)(C.CString(kind))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_volume_get_identifier(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Mount gets the mount for the @volume.
	func (v Volume) Mount() Mount {
var _arg0 *C.GVolume // out
var _cret *C.GMount // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_get_mount(_arg0)


var _mount Mount // out

_mount = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Mount)

return _mount
}
	
	// Name gets the name of @volume.
	func (v Volume) Name() string {
var _arg0 *C.GVolume // out
var _cret *C.char // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// SortKey gets the sort key for @volume, if any.
	func (v Volume) SortKey() string {
var _arg0 *C.GVolume // out
var _cret *C.gchar // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_get_sort_key(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SymbolicIcon gets the symbolic icon for @volume.
	func (v Volume) SymbolicIcon() Icon {
var _arg0 *C.GVolume // out
var _cret *C.GIcon // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_get_symbolic_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// UUID gets the UUID for the @volume. The reference is typically based on the
// file system UUID for the volume in question and should be considered an
// opaque string. Returns nil if there is no UUID available.
	func (v Volume) UUID() string {
var _arg0 *C.GVolume // out
var _cret *C.char // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_get_uuid(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// MountFinish finishes mounting a volume. If any errors occurred during the
// operation, @error will be set to contain the errors and false will be
// returned.
// 
// If the mount operation succeeded, g_volume_get_mount() on @volume is
// guaranteed to return the mount right after calling this function; there's no
// need to listen for the 'mount-added' signal on Monitor.
	func (v Volume) MountFinish(result AsyncResult) error {
var _arg0 *C.GVolume // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_volume_mount_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ShouldAutomount returns whether the volume should be automatically mounted.
	func (v Volume) ShouldAutomount() bool {
var _arg0 *C.GVolume // out
var _cret C.gboolean // in

_arg0 = (*C.GVolume)(unsafe.Pointer(v.Native()))

_cret = C.g_volume_should_automount(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
// 
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
// 
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
	type AppInfoMonitor struct {
		**externglib.Object
		
	}

	// AppInfoMonitorClass is an interface that the AppInfoMonitor class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AppInfoMonitorClass interface {
		gextras.Objector
		_appInfoMonitor()
	}

	func (AppInfoMonitor) _appInfoMonitor() {}

	
	func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAppInfoMonitor(obj), nil
	}
	

	

	


	// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
	type AppLaunchContext struct {
		**externglib.Object
		
	}

	// AppLaunchContextClass is an interface that the AppLaunchContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AppLaunchContextClass interface {
		gextras.Objector
		_appLaunchContext()
	}

	func (AppLaunchContext) _appLaunchContext() {}

	
	func marshalAppLaunchContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAppLaunchContext(obj), nil
	}
	

	
	// NewAppLaunchContext creates a new application launch context. This is not
// normally used, instead you instantiate a subclass of this, such as
// AppLaunchContext.
	func NewAppLaunchContext() AppLaunchContext {
var _cret *C.GAppLaunchContext // in

_cret = C.g_app_launch_context_new()


var _appLaunchContext AppLaunchContext // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_appLaunchContext = AppLaunchContext{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _appLaunchContext
}
	

	
	// Environment gets the complete environment variable list to be passed to the
// child process when @context is used to launch an application. This is a
// nil-terminated array of strings, where each string has the form `KEY=VALUE`.
	func (c AppLaunchContext) Environment() []string {
var _arg0 *C.GAppLaunchContext // out
var _cret **C.char

_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))

_cret = C.g_app_launch_context_get_environment(_arg0)


var _filenames []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_filenames = make([]string, i)
for i := range src {
_filenames[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _filenames
}
	
	// LaunchFailed: called when an application has failed to launch, so that it can
// cancel the application startup notification started in
// g_app_launch_context_get_startup_notify_id().
	func (c AppLaunchContext) LaunchFailed(startupNotifyId string)  {
var _arg0 *C.GAppLaunchContext // out
var _arg1 *C.char // out

_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(startupNotifyId))
defer C.free(unsafe.Pointer(_arg1))

C.g_app_launch_context_launch_failed(_arg0, _arg1)
}
	
	// Setenv arranges for @variable to be set to @value in the child's environment
// when @context is used to launch an application.
	func (c AppLaunchContext) Setenv(variable string, value string)  {
var _arg0 *C.GAppLaunchContext // out
var _arg1 *C.char // out
var _arg2 *C.char // out

_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(variable))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(value))
defer C.free(unsafe.Pointer(_arg2))

C.g_app_launch_context_setenv(_arg0, _arg1, _arg2)
}
	
	// Unsetenv arranges for @variable to be unset in the child's environment when
// @context is used to launch an application.
	func (c AppLaunchContext) Unsetenv(variable string)  {
var _arg0 *C.GAppLaunchContext // out
var _arg1 *C.char // out

_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(variable))
defer C.free(unsafe.Pointer(_arg1))

C.g_app_launch_context_unsetenv(_arg0, _arg1)
}
	


	// Application: a #GApplication is the foundation of an application. It wraps
// some low-level platform-specific services and is intended to act as the
// foundation for higher-level application classes such as Application or
// Application. In general, you should not use this class outside of a higher
// level framework.
// 
// GApplication provides convenient life cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using g_application_hold() and g_application_release(). If it drops to zero,
// the application exits. Higher-level classes such as Application employ the
// use count to ensure that the application stays alive as long as it has any
// opened windows.
// 
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent, but
// corresponds roughly to a graphical desktop login. When your application is
// launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
// 
// The use of #GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a #GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling g_application_run(). All checks for uniqueness are
// done internally. If the application is the primary instance then the startup
// signal is emitted and the mainloop runs. If the application is not the
// primary instance then a signal is sent to the primary instance and
// g_application_run() promptly returns. See the code examples below.
// 
// If used, the expected form of an application identifier is the same as that
// of of a D-Bus well-known bus name
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: `com.example.MyApp`,
// `org.example.internal_apps.Calculator`, `org._7_zip.Archiver`. For details on
// valid application identifiers, see g_application_id_is_valid().
// 
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application is
// scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with the
// shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is not
// running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in g_application_register()).
// Unfortunately, this means that you cannot use g_application_get_is_remote()
// to decide if you want to register object paths.
// 
// GApplication also implements the Group and Map interfaces and lets you easily
// export actions by adding them with g_action_map_add_action(). When invoking
// an action by calling g_action_group_activate_action() on the application, it
// is always invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the BusActionGroup wrapper to conveniently
// access them remotely. GIO provides a BusMenuModel wrapper for remote access
// to exported Models.
// 
// There is a number of different entry points into a GApplication:
// 
// - via 'Activate' (i.e. just starting the application)
// 
// - via 'Open' (i.e. opening some files)
// 
// - by handling a command-line
// 
// - via activating an action
// 
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
// 
// Regardless of which of these entry points is used to start the application,
// GApplication passes some platform data from the launching instance to the
// primary instance, in the form of a #GVariant dictionary mapping strings to
// variants. To use platform data, override the @before_emit or @after_emit
// virtual functions in your #GApplication subclass. When dealing with
// CommandLine objects, the platform data is directly available via
// g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
// 
// As the name indicates, the platform data may vary depending on the operating
// system, but it always includes the current directory (key "cwd"), and
// optionally the environment (ie the set of environment variables and their
// values) of the calling process (key "environ"). The environment is only added
// to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// #GApplication subclasses can add their own platform data by overriding the
// @add_platform_data virtual function. For instance, Application adds startup
// notification data in this way.
// 
// To parse commandline arguments you may handle the #GApplication::command-line
// signal or override the local_command_line() vfunc, to parse them in either
// the primary instance or the local instance, respectively.
// 
// For an example of opening files with a GApplication, see
// gapplication-example-open.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).
// 
// For an example of using actions with GApplication, see
// gapplication-example-actions.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).
// 
// For an example of using extra D-Bus hooks with GApplication, see
// gapplication-example-dbushooks.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).
	type Application struct {
		**externglib.Object
		ActionGroup
		ActionMap
		
	}

	// ApplicationClass is an interface that the Application class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ApplicationClass interface {
		gextras.Objector
		_application()
	}

	func (Application) _application() {}

	
	func marshalApplication(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapApplication(obj), nil
	}
	

	
	// NewApplication creates a new #GApplication instance.
// 
// If non-nil, the application id must be valid. See
// g_application_id_is_valid().
// 
// If no application ID is given then some features of #GApplication (most
// notably application uniqueness) will be disabled.
	func NewApplication(applicationId string, flags ApplicationFlags) Application {
var _arg1 *C.gchar // out
var _arg2 C.GApplicationFlags // out
var _cret *C.GApplication // in

_arg1 = (*C.gchar)(C.CString(applicationId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GApplicationFlags)(flags)

_cret = C.g_application_new(_arg1, _arg2)


var _application Application // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_application = Application{
Object: &externglib.Object{externglib.ToGObject(obj)},
ActionGroup: ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ActionMap: ActionMap{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _application
}
	

	
	// Activate activates the application.
// 
// In essence, this results in the #GApplication::activate signal being emitted
// in the primary instance.
// 
// The application must be registered before calling this function.
	func (a Application) Activate()  {
var _arg0 *C.GApplication // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

C.g_application_activate(_arg0)
}
	
	// AddMainOption: add an option to be handled by @application.
// 
// Calling this function is the equivalent of calling
// g_application_add_main_option_entries() with a single Entry that has its
// arg_data member set to nil.
// 
// The parsed arguments will be packed into a Dict which is passed to
// #GApplication::handle-local-options. If G_APPLICATION_HANDLES_COMMAND_LINE is
// set, then it will also be sent to the primary instance. See
// g_application_add_main_option_entries() for more details.
// 
// See Entry for more documentation of the arguments.
	func (a Application) AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string)  {
var _arg0 *C.GApplication // out
var _arg1 *C.char // out
var _arg2 C.char // out
var _arg3 C.GOptionFlags // out
var _arg4 C.GOptionArg // out
var _arg5 *C.char // out
var _arg6 *C.char // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(longName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.char)(shortName)
_arg3 = (C.GOptionFlags)(flags)
_arg4 = (C.GOptionArg)(arg)
_arg5 = (*C.char)(C.CString(description))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (*C.char)(C.CString(argDescription))
defer C.free(unsafe.Pointer(_arg6))

C.g_application_add_main_option(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}
	
	// AddMainOptionEntries adds main option entries to be handled by @application.
// 
// This function is comparable to g_option_context_add_main_entries().
// 
// After the commandline arguments are parsed, the
// #GApplication::handle-local-options signal will be emitted. At this point,
// the application can inspect the values pointed to by @arg_data in the given
// Entrys.
// 
// Unlike Context, #GApplication supports giving a nil @arg_data for a
// non-callback Entry. This results in the argument in question being packed
// into a Dict which is also passed to #GApplication::handle-local-options,
// where it can be inspected and modified. If G_APPLICATION_HANDLES_COMMAND_LINE
// is set, then the resulting dictionary is sent to the primary instance, where
// g_application_command_line_get_options_dict() will return it. This "packing"
// is done according to the type of the argument -- booleans for normal flags,
// strings for strings, bytestrings for filenames, etc. The packing only occurs
// if the flag is given (ie: we do not pack a "false" #GVariant in the case that
// a flag is missing).
// 
// In general, it is recommended that all commandline arguments are parsed
// locally. The options dictionary should then be used to transmit the result of
// the parsing to the primary instance, where g_variant_dict_lookup() can be
// used. For local options, it is possible to either use @arg_data in the usual
// way, or to consult (and potentially remove) the option from the options
// dictionary.
// 
// This function is new in GLib 2.40. Before then, the only real choice was to
// send all of the commandline arguments (options and all) to the primary
// instance for handling. #GApplication ignored them completely on the local
// side. Calling this function "opts in" to the new behaviour, and in
// particular, means that unrecognised options will be treated as errors.
// Unrecognised options have never been ignored when
// G_APPLICATION_HANDLES_COMMAND_LINE is unset.
// 
// If #GApplication::handle-local-options needs to see the list of filenames,
// then the use of G_OPTION_REMAINING is recommended. If @arg_data is nil then
// G_OPTION_REMAINING can be used as a key into the options dictionary. If you
// do use G_OPTION_REMAINING then you need to handle these arguments for
// yourself because once they are consumed, they will no longer be visible to
// the default handling (which treats them as filenames to be opened).
// 
// It is important to use the proper GVariant format when retrieving the options
// with g_variant_dict_lookup(): - for G_OPTION_ARG_NONE, use `b` - for
// G_OPTION_ARG_STRING, use `&s` - for G_OPTION_ARG_INT, use `i` - for
// G_OPTION_ARG_INT64, use `x` - for G_OPTION_ARG_DOUBLE, use `d` - for
// G_OPTION_ARG_FILENAME, use `^&ay` - for G_OPTION_ARG_STRING_ARRAY, use `^a&s`
// - for G_OPTION_ARG_FILENAME_ARRAY, use `^a&ay`
	func (a Application) AddMainOptionEntries(entries []glib.OptionEntry)  {
var _arg0 *C.GApplication // out
var _arg1 *C.GOptionEntry

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
{
var zero glib.OptionEntry
entries = append(entries, zero)
}
_arg1 = (*C.GOptionEntry)(unsafe.Pointer(&entries[0]))

C.g_application_add_main_option_entries(_arg0, _arg1)
}
	
	// AddOptionGroup adds a Group to the commandline handling of @application.
// 
// This function is comparable to g_option_context_add_group().
// 
// Unlike g_application_add_main_option_entries(), this function does not deal
// with nil @arg_data and never transmits options to the primary instance.
// 
// The reason for that is because, by the time the options arrive at the primary
// instance, it is typically too late to do anything with them. Taking the GTK
// option group as an example: GTK will already have been initialised by the
// time the #GApplication::command-line handler runs. In the case that this is
// not the first-running instance of the application, the existing instance may
// already have been running for a very long time.
// 
// This means that the options from Group are only really usable in the case
// that the instance of the application being run is the first instance. Passing
// options like `--display=` or `--gdk-debug=` on future runs will have no
// effect on the existing primary instance.
// 
// Calling this function will cause the options in the supplied option group to
// be parsed, but it does not cause you to be "opted in" to the new
// functionality whereby unrecognised options are rejected even if
// G_APPLICATION_HANDLES_COMMAND_LINE was given.
	func (a Application) AddOptionGroup(group *glib.OptionGroup)  {
var _arg0 *C.GApplication // out
var _arg1 *C.GOptionGroup // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GOptionGroup)(unsafe.Pointer(group.Native()))

C.g_application_add_option_group(_arg0, _arg1)
}
	
	// BindBusyProperty marks @application as busy (see g_application_mark_busy())
// while @property on @object is true.
// 
// The binding holds a reference to @application while it is active, but not to
// @object. Instead, the binding is destroyed when @object is finalized.
	func (a Application) BindBusyProperty(object **externglib.Object, property string)  {
var _arg0 *C.GApplication // out
var _arg1 C.gpointer // out
var _arg2 *C.gchar // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
_arg2 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg2))

C.g_application_bind_busy_property(_arg0, _arg1, _arg2)
}
	
	// ApplicationID gets the unique identifier for @application.
	func (a Application) ApplicationID() string {
var _arg0 *C.GApplication // out
var _cret *C.gchar // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

_cret = C.g_application_get_application_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// DBusConnection gets the BusConnection being used by the application, or nil.
// 
// If #GApplication is using its D-Bus backend then this function will return
// the BusConnection being used for uniqueness and communication with the
// desktop environment and other instances of the application.
// 
// If #GApplication is not using D-Bus then this function will return nil. This
// includes the situation where the D-Bus backend would normally be in use but
// we were unable to connect to the bus.
// 
// This function must not be called before the application has been registered.
// See g_application_get_is_registered().
	func (a Application) DBusConnection() DBusConnection {
var _arg0 *C.GApplication // out
var _cret *C.GDBusConnection // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

_cret = C.g_application_get_dbus_connection(_arg0)


var _dBusConnection DBusConnection // out

_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

return _dBusConnection
}
	
	// DBusObjectPath gets the D-Bus object path being used by the application, or
// nil.
// 
// If #GApplication is using its D-Bus backend then this function will return
// the D-Bus object path that #GApplication is using. If the application is the
// primary instance then there is an object published at this path. If the
// application is not the primary instance then the result of this function is
// undefined.
// 
// If #GApplication is not using D-Bus then this function will return nil. This
// includes the situation where the D-Bus backend would normally be in use but
// we were unable to connect to the bus.
// 
// This function must not be called before the application has been registered.
// See g_application_get_is_registered().
	func (a Application) DBusObjectPath() string {
var _arg0 *C.GApplication // out
var _cret *C.gchar // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

_cret = C.g_application_get_dbus_object_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Flags gets the flags for @application.
// 
// See Flags.
	func (a Application) Flags() ApplicationFlags {
var _arg0 *C.GApplication // out
var _cret C.GApplicationFlags // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

_cret = C.g_application_get_flags(_arg0)


var _applicationFlags ApplicationFlags // out

_applicationFlags = ApplicationFlags(_cret)

return _applicationFlags
}
	
	// InactivityTimeout gets the current inactivity timeout for the application.
// 
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
	func (a Application) InactivityTimeout() uint {
var _arg0 *C.GApplication // out
var _cret C.guint // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

_cret = C.g_application_get_inactivity_timeout(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// IsBusy gets the application's current busy state, as set through
// g_application_mark_busy() or g_application_bind_busy_property().
	func (a Application) IsBusy() bool {
var _arg0 *C.GApplication // out
var _cret C.gboolean // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

_cret = C.g_application_get_is_busy(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsRegistered checks if @application is registered.
// 
// An application is registered if g_application_register() has been
// successfully called.
	func (a Application) IsRegistered() bool {
var _arg0 *C.GApplication // out
var _cret C.gboolean // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

_cret = C.g_application_get_is_registered(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsRemote checks if @application is remote.
// 
// If @application is remote then it means that another instance of application
// already exists (the 'primary' instance). Calls to perform actions on
// @application will result in the actions being performed by the primary
// instance.
// 
// The value of this property cannot be accessed before g_application_register()
// has been called. See g_application_get_is_registered().
	func (a Application) IsRemote() bool {
var _arg0 *C.GApplication // out
var _cret C.gboolean // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

_cret = C.g_application_get_is_remote(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ResourceBasePath gets the resource base path of @application.
// 
// See g_application_set_resource_base_path() for more information.
	func (a Application) ResourceBasePath() string {
var _arg0 *C.GApplication // out
var _cret *C.gchar // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

_cret = C.g_application_get_resource_base_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Hold increases the use count of @application.
// 
// Use this function to indicate that the application has a reason to continue
// to run. For example, g_application_hold() is called by GTK+ when a toplevel
// window is on the screen.
// 
// To cancel the hold, call g_application_release().
	func (a Application) Hold()  {
var _arg0 *C.GApplication // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

C.g_application_hold(_arg0)
}
	
	// MarkBusy increases the busy count of @application.
// 
// Use this function to indicate that the application is busy, for instance
// while a long running operation is pending.
// 
// The busy state will be exposed to other processes, so a session shell will
// use that information to indicate the state to the user (e.g. with a spinner).
// 
// To cancel the busy indication, use g_application_unmark_busy().
	func (a Application) MarkBusy()  {
var _arg0 *C.GApplication // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

C.g_application_mark_busy(_arg0)
}
	
	// Open opens the given files.
// 
// In essence, this results in the #GApplication::open signal being emitted in
// the primary instance.
// 
// @n_files must be greater than zero.
// 
// @hint is simply passed through to the ::open signal. It is intended to be
// used by applications that have multiple modes for opening files (eg: "view"
// vs "edit", etc). Unless you have a need for this functionality, you should
// use "".
// 
// The application must be registered before calling this function and it must
// have the G_APPLICATION_HANDLES_OPEN flag set.
	func (a Application) Open(files []File, hint string)  {
var _arg0 *C.GApplication // out
var _arg1 **C.GFile
var _arg2 C.gint
var _arg3 *C.gchar // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg2 = C.gint(len(files))
_arg1 = (**C.GFile)(C.malloc(C.ulong(len(files)) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(files))
for i := range files {
out[i] = (*C.GFile)(unsafe.Pointer(files[i].Native()))
}
}
_arg3 = (*C.gchar)(C.CString(hint))
defer C.free(unsafe.Pointer(_arg3))

C.g_application_open(_arg0, _arg1, _arg2, _arg3)
}
	
	// Quit: immediately quits the application.
// 
// Upon return to the mainloop, g_application_run() will return, calling only
// the 'shutdown' function before doing so.
// 
// The hold count is ignored. Take care if your code has called
// g_application_hold() on the application and is therefore still expecting it
// to exist. (Note that you may have called g_application_hold() indirectly, for
// example through gtk_application_add_window().)
// 
// The result of calling g_application_run() again after it returns is
// unspecified.
	func (a Application) Quit()  {
var _arg0 *C.GApplication // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

C.g_application_quit(_arg0)
}
	
	// Register attempts registration of the application.
// 
// This is the point at which the application discovers if it is the primary
// instance or merely acting as a remote for an already-existing primary
// instance. This is implemented by attempting to acquire the application
// identifier as a unique bus name on the session bus using GDBus.
// 
// If there is no application ID or if G_APPLICATION_NON_UNIQUE was given, then
// this process will always become the primary instance.
// 
// Due to the internal architecture of GDBus, method calls can be dispatched at
// any time (even if a main loop is not running). For this reason, you must
// ensure that any object paths that you wish to register are registered before
// calling this function.
// 
// If the application has already been registered then true is returned with no
// work performed.
// 
// The #GApplication::startup signal is emitted if registration succeeds and
// @application is the primary instance (including the non-unique case).
// 
// In the event of an error (such as @cancellable being cancelled, or a failure
// to connect to the session bus), false is returned and @error is set
// appropriately.
// 
// Note: the return value of this function is not an indicator that this
// instance is or is not the primary instance of the application. See
// g_application_get_is_remote() for that.
	func (a Application) Register(cancellable CancellableClass) error {
var _arg0 *C.GApplication // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_application_register(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Release: decrease the use count of @application.
// 
// When the use count reaches zero, the application will stop running.
// 
// Never call this function except to cancel the effect of a previous call to
// g_application_hold().
	func (a Application) Release()  {
var _arg0 *C.GApplication // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

C.g_application_release(_arg0)
}
	
	// Run runs the application.
// 
// This function is intended to be run from main() and its return value is
// intended to be returned by main(). Although you are expected to pass the
// @argc, @argv parameters from main() to this function, it is possible to pass
// nil if @argv is not available or commandline handling is not required. Note
// that on Windows, @argc and @argv are ignored, and g_win32_get_command_line()
// is called internally (for proper support of Unicode commandline arguments).
// 
// #GApplication will attempt to parse the commandline arguments. You can add
// commandline flags to the list of recognised options by way of
// g_application_add_main_option_entries(). After this, the
// #GApplication::handle-local-options signal is emitted, from which the
// application can inspect the values of its Entrys.
// 
// #GApplication::handle-local-options is a good place to handle options such as
// `--version`, where an immediate reply from the local process is desired
// (instead of communicating with an already-running instance). A
// #GApplication::handle-local-options handler can stop further processing by
// returning a non-negative value, which then becomes the exit status of the
// process.
// 
// What happens next depends on the flags: if G_APPLICATION_HANDLES_COMMAND_LINE
// was specified then the remaining commandline arguments are sent to the
// primary instance, where a #GApplication::command-line signal is emitted.
// Otherwise, the remaining commandline arguments are assumed to be a list of
// files. If there are no files listed, the application is activated via the
// #GApplication::activate signal. If there are one or more files, and
// G_APPLICATION_HANDLES_OPEN was specified then the files are opened via the
// #GApplication::open signal.
// 
// If you are interested in doing more complicated local handling of the
// commandline then you should implement your own #GApplication subclass and
// override local_command_line(). In this case, you most likely want to return
// true from your local_command_line() implementation to suppress the default
// handling. See
// [gapplication-example-cmdline2.c][gapplication-example-cmdline2] for an
// example.
// 
// If, after the above is done, the use count of the application is zero then
// the exit status is returned immediately. If the use count is non-zero then
// the default main context is iterated until the use count falls to zero, at
// which point 0 is returned.
// 
// If the G_APPLICATION_IS_SERVICE flag is set, then the service will run for as
// much as 10 seconds with a use count of zero while waiting for the message
// that caused the activation to arrive. After that, if the use count falls to
// zero the application will exit immediately, except in the case that
// g_application_set_inactivity_timeout() is in use.
// 
// This function sets the prgname (g_set_prgname()), if not already set, to the
// basename of argv[0].
// 
// Much like g_main_loop_run(), this function will acquire the main context for
// the duration that the application is running.
// 
// Since 2.40, applications that are not explicitly flagged as services or
// launchers (ie: neither G_APPLICATION_IS_SERVICE or G_APPLICATION_IS_LAUNCHER
// are given as flags) will check (from the default handler for
// local_command_line) if "--gapplication-service" was given in the command
// line. If this flag is present then normal commandline processing is
// interrupted and the G_APPLICATION_IS_SERVICE flag is set. This provides a
// "compromise" solution whereby running an application directly from the
// commandline will invoke it in the normal way (which can be useful for
// debugging) while still allowing applications to be D-Bus activated in service
// mode. The D-Bus service file should invoke the executable with
// "--gapplication-service" as the sole commandline argument. This approach is
// suitable for use by most graphical applications but should not be used from
// applications like editors that need precise control over when processes
// invoked via the commandline will exit and what their exit status will be.
	func (a Application) Run(argv []string) int {
var _arg0 *C.GApplication // out
var _arg2 **C.char
var _arg1 C.int
var _cret C.int // in

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = C.int(len(argv))
_arg2 = (**C.char)(C.malloc(C.ulong(len(argv)) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(argv))
for i := range argv {
out[i] = (*C.gchar)(C.CString(argv[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.g_application_run(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SendNotification sends a notification on behalf of @application to the
// desktop shell. There is no guarantee that the notification is displayed
// immediately, or even at all.
// 
// Notifications may persist after the application exits. It will be
// D-Bus-activated when the notification or one of its actions is activated.
// 
// Modifying @notification after this call has no effect. However, the object
// can be reused for a later call to this function.
// 
// @id may be any string that uniquely identifies the event for the application.
// It does not need to be in any special format. For example, "new-message"
// might be appropriate for a notification about new messages.
// 
// If a previous notification was sent with the same @id, it will be replaced
// with @notification and shown again as if it was a new notification. This
// works even for notifications sent from a previous execution of the
// application, as long as @id is the same string.
// 
// @id may be nil, but it is impossible to replace or withdraw notifications
// without an id.
// 
// If @notification is no longer relevant, it can be withdrawn with
// g_application_withdraw_notification().
	func (a Application) SendNotification(id string, notification NotificationClass)  {
var _arg0 *C.GApplication // out
var _arg1 *C.gchar // out
var _arg2 *C.GNotification // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GNotification)(unsafe.Pointer(notification.Native()))

C.g_application_send_notification(_arg0, _arg1, _arg2)
}
	
	// SetActionGroup: this used to be how actions were associated with a
// #GApplication. Now there is Map for that.
	func (a Application) SetActionGroup(actionGroup ActionGroup)  {
var _arg0 *C.GApplication // out
var _arg1 *C.GActionGroup // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GActionGroup)(unsafe.Pointer(actionGroup.Native()))

C.g_application_set_action_group(_arg0, _arg1)
}
	
	// SetApplicationID sets the unique identifier for @application.
// 
// The application id can only be modified if @application has not yet been
// registered.
// 
// If non-nil, the application id must be valid. See
// g_application_id_is_valid().
	func (a Application) SetApplicationID(applicationId string)  {
var _arg0 *C.GApplication // out
var _arg1 *C.gchar // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(applicationId))
defer C.free(unsafe.Pointer(_arg1))

C.g_application_set_application_id(_arg0, _arg1)
}
	
	// SetDefault sets or unsets the default application for the process, as
// returned by g_application_get_default().
// 
// This function does not take its own reference on @application. If
// @application is destroyed then the default application will revert back to
// nil.
	func (a Application) SetDefault()  {
var _arg0 *C.GApplication // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

C.g_application_set_default(_arg0)
}
	
	// SetFlags sets the flags for @application.
// 
// The flags can only be modified if @application has not yet been registered.
// 
// See Flags.
	func (a Application) SetFlags(flags ApplicationFlags)  {
var _arg0 *C.GApplication // out
var _arg1 C.GApplicationFlags // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (C.GApplicationFlags)(flags)

C.g_application_set_flags(_arg0, _arg1)
}
	
	// SetInactivityTimeout sets the current inactivity timeout for the application.
// 
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
// 
// This call has no side effects of its own. The value set here is only used for
// next time g_application_release() drops the use count to zero. Any timeouts
// currently in progress are not impacted.
	func (a Application) SetInactivityTimeout(inactivityTimeout uint)  {
var _arg0 *C.GApplication // out
var _arg1 C.guint // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (C.guint)(inactivityTimeout)

C.g_application_set_inactivity_timeout(_arg0, _arg1)
}
	
	// SetOptionContextDescription adds a description to the @application option
// context.
// 
// See g_option_context_set_description() for more information.
	func (a Application) SetOptionContextDescription(description string)  {
var _arg0 *C.GApplication // out
var _arg1 *C.gchar // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(description))
defer C.free(unsafe.Pointer(_arg1))

C.g_application_set_option_context_description(_arg0, _arg1)
}
	
	// SetOptionContextParameterString sets the parameter string to be used by the
// commandline handling of @application.
// 
// This function registers the argument to be passed to g_option_context_new()
// when the internal Context of @application is created.
// 
// See g_option_context_new() for more information about @parameter_string.
	func (a Application) SetOptionContextParameterString(parameterString string)  {
var _arg0 *C.GApplication // out
var _arg1 *C.gchar // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(parameterString))
defer C.free(unsafe.Pointer(_arg1))

C.g_application_set_option_context_parameter_string(_arg0, _arg1)
}
	
	// SetOptionContextSummary adds a summary to the @application option context.
// 
// See g_option_context_set_summary() for more information.
	func (a Application) SetOptionContextSummary(summary string)  {
var _arg0 *C.GApplication // out
var _arg1 *C.gchar // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(summary))
defer C.free(unsafe.Pointer(_arg1))

C.g_application_set_option_context_summary(_arg0, _arg1)
}
	
	// SetResourceBasePath sets (or unsets) the base resource path of @application.
// 
// The path is used to automatically load various [application
// resources][gresource] such as menu layouts and action descriptions. The
// various types of resources will be found at fixed names relative to the given
// base path.
// 
// By default, the resource base path is determined from the application ID by
// prefixing '/' and replacing each '.' with '/'. This is done at the time that
// the #GApplication object is constructed. Changes to the application ID after
// that point will not have an impact on the resource base path.
// 
// As an example, if the application has an ID of "org.example.app" then the
// default resource base path will be "/org/example/app". If this is a
// Application (and you have not manually changed the path) then Gtk will then
// search for the menus of the application at "/org/example/app/gtk/menus.ui".
// 
// See #GResource for more information about adding resources to your
// application.
// 
// You can disable automatic resource loading functionality by setting the path
// to nil.
// 
// Changing the resource base path once the application is running is not
// recommended. The point at which the resource path is consulted for forming
// paths for various purposes is unspecified. When writing a sub-class of
// #GApplication you should either set the #GApplication:resource-base-path
// property at construction time, or call this function during the instance
// initialization. Alternatively, you can call this function in the
// Class.startup virtual function, before chaining up to the parent
// implementation.
	func (a Application) SetResourceBasePath(resourcePath string)  {
var _arg0 *C.GApplication // out
var _arg1 *C.gchar // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

C.g_application_set_resource_base_path(_arg0, _arg1)
}
	
	// UnbindBusyProperty destroys a binding between @property and the busy state of
// @application that was previously created with
// g_application_bind_busy_property().
	func (a Application) UnbindBusyProperty(object **externglib.Object, property string)  {
var _arg0 *C.GApplication // out
var _arg1 C.gpointer // out
var _arg2 *C.gchar // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
_arg2 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg2))

C.g_application_unbind_busy_property(_arg0, _arg1, _arg2)
}
	
	// UnmarkBusy decreases the busy count of @application.
// 
// When the busy count reaches zero, the new state will be propagated to other
// processes.
// 
// This function must only be called to cancel the effect of a previous call to
// g_application_mark_busy().
	func (a Application) UnmarkBusy()  {
var _arg0 *C.GApplication // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))

C.g_application_unmark_busy(_arg0)
}
	
	// WithdrawNotification withdraws a notification that was sent with
// g_application_send_notification().
// 
// This call does nothing if a notification with @id doesn't exist or the
// notification was never sent.
// 
// This function works even for notifications sent in previous executions of
// this application, as long @id is the same as it was for the sent
// notification.
// 
// Note that notifications are dismissed when the user clicks on one of the
// buttons in a notification or triggers its default action, so there is no need
// to explicitly withdraw the notification in that case.
	func (a Application) WithdrawNotification(id string)  {
var _arg0 *C.GApplication // out
var _arg1 *C.gchar // out

_arg0 = (*C.GApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))

C.g_application_withdraw_notification(_arg0, _arg1)
}
	


	// ApplicationCommandLine represents a command-line invocation of an
// application. It is created by #GApplication and emitted in the
// #GApplication::command-line signal and virtual function.
// 
// The class contains the list of arguments that the program was invoked with.
// It is also possible to query if the commandline invocation was local (ie: the
// current process is running in direct response to the invocation) or remote
// (ie: some other process forwarded the commandline to this process).
// 
// The GApplicationCommandLine object can provide the @argc and @argv parameters
// for use with the Context command-line parsing API, with the
// g_application_command_line_get_arguments() function. See
// [gapplication-example-cmdline3.c][gapplication-example-cmdline3] for an
// example.
// 
// The exit status of the originally-invoked process may be set and messages can
// be printed to stdout or stderr of that process. The lifecycle of the
// originally-invoked process is tied to the lifecycle of this object (ie: the
// process exits when the last reference is dropped).
// 
// The main use for CommandLine (and the #GApplication::command-line signal) is
// 'Emacs server' like use cases: You can set the `EDITOR` environment variable
// to have e.g. git use your favourite editor to edit commit messages, and if
// you already have an instance of the editor running, the editing will happen
// in the running instance, instead of opening a new one. An important aspect of
// this use case is that the process that gets started by git does not return
// until the editing is done.
// 
// Normally, the commandline is completely handled in the
// #GApplication::command-line handler. The launching instance exits once the
// signal handler in the primary instance has returned, and the return value of
// the signal handler becomes the exit status of the launching instance.
// 
//    static gboolean
//    my_cmdline_handler (gpointer data)
//    {
//      GApplicationCommandLine *cmdline = data;
// 
//      // do the heavy lifting in an idle
// 
//      g_application_command_line_set_exit_status (cmdline, 0);
//      g_object_unref (cmdline); // this releases the application
// 
//      return G_SOURCE_REMOVE;
//    }
// 
//    static int
//    command_line (GApplication            *application,
//                  GApplicationCommandLine *cmdline)
//    {
//      // keep the application running until we are done with this commandline
//      g_application_hold (application);
// 
//      g_object_set_data_full (G_OBJECT (cmdline),
//                              "application", application,
//                              (GDestroyNotify)g_application_release);
// 
//      g_object_ref (cmdline);
//      g_idle_add (my_cmdline_handler, cmdline);
// 
//      return 0;
//    }
// 
// In this example the commandline is not completely handled before the
// #GApplication::command-line handler returns. Instead, we keep a reference to
// the CommandLine object and handle it later (in this example, in an idle).
// Note that it is necessary to hold the application until you are done with the
// commandline.
// 
// The complete example can be found here: gapplication-example-cmdline3.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline3.c)
	type ApplicationCommandLine struct {
		**externglib.Object
		
	}

	// ApplicationCommandLineClass is an interface that the ApplicationCommandLine class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ApplicationCommandLineClass interface {
		gextras.Objector
		_applicationCommandLine()
	}

	func (ApplicationCommandLine) _applicationCommandLine() {}

	
	func marshalApplicationCommandLine(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapApplicationCommandLine(obj), nil
	}
	

	

	
	// CreateFileForArg creates a #GFile corresponding to a filename that was given
// as part of the invocation of @cmdline.
// 
// This differs from g_file_new_for_commandline_arg() in that it resolves
// relative pathnames using the current working directory of the invoking
// process rather than the local process.
	func (c ApplicationCommandLine) CreateFileForArg(arg string) File {
var _arg0 *C.GApplicationCommandLine // out
var _arg1 *C.gchar // out
var _cret *C.GFile // in

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(arg))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_application_command_line_create_file_for_arg(_arg0, _arg1)


var _file File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _file
}
	
	// Cwd gets the working directory of the command line invocation. The string may
// contain non-utf8 data.
// 
// It is possible that the remote application did not send a working directory,
// so this may be nil.
// 
// The return value should not be modified or freed and is valid for as long as
// @cmdline exists.
	func (c ApplicationCommandLine) Cwd() string {
var _arg0 *C.GApplicationCommandLine // out
var _cret *C.gchar // in

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

_cret = C.g_application_command_line_get_cwd(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// Environ gets the contents of the 'environ' variable of the command line
// invocation, as would be returned by g_get_environ(), ie as a nil-terminated
// list of strings in the form 'NAME=VALUE'. The strings may contain non-utf8
// data.
// 
// The remote application usually does not send an environment. Use
// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it is
// possible that the environment is still not available (due to invocation
// messages from other applications).
// 
// The return value should not be modified or freed and is valid for as long as
// @cmdline exists.
// 
// See g_application_command_line_getenv() if you are only interested in the
// value of a single environment variable.
	func (c ApplicationCommandLine) Environ() []string {
var _arg0 *C.GApplicationCommandLine // out
var _cret **C.gchar

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

_cret = C.g_application_command_line_get_environ(_arg0)


var _filenames []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_filenames = make([]string, i)
for i := range src {
_filenames[i] = C.GoString(src[i])
}
}

return _filenames
}
	
	// ExitStatus gets the exit status of @cmdline. See
// g_application_command_line_set_exit_status() for more information.
	func (c ApplicationCommandLine) ExitStatus() int {
var _arg0 *C.GApplicationCommandLine // out
var _cret C.int // in

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

_cret = C.g_application_command_line_get_exit_status(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsRemote determines if @cmdline represents a remote invocation.
	func (c ApplicationCommandLine) IsRemote() bool {
var _arg0 *C.GApplicationCommandLine // out
var _cret C.gboolean // in

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

_cret = C.g_application_command_line_get_is_remote(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// OptionsDict gets the options there were passed to
// g_application_command_line().
// 
// If you did not override local_command_line() then these are the same options
// that were parsed according to the Entrys added to the application with
// g_application_add_main_option_entries() and possibly modified from your
// GApplication::handle-local-options handler.
// 
// If no options were sent then an empty dictionary is returned so that you
// don't need to check for nil.
	func (c ApplicationCommandLine) OptionsDict() *glib.VariantDict {
var _arg0 *C.GApplicationCommandLine // out
var _cret *C.GVariantDict // in

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

_cret = C.g_application_command_line_get_options_dict(_arg0)


var _variantDict *glib.VariantDict // out

_variantDict = *(**glib.VariantDict)(unsafe.Pointer(&_cret))

return _variantDict
}
	
	// PlatformData gets the platform data associated with the invocation of
// @cmdline.
// 
// This is a #GVariant dictionary containing information about the context in
// which the invocation occurred. It typically contains information like the
// current working directory and the startup notification ID.
// 
// For local invocation, it will be nil.
	func (c ApplicationCommandLine) PlatformData() *glib.Variant {
var _arg0 *C.GApplicationCommandLine // out
var _cret *C.GVariant // in

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

_cret = C.g_application_command_line_get_platform_data(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// Stdin gets the stdin of the invoking process.
// 
// The Stream can be used to read data passed to the standard input of the
// invoking process. This doesn't work on all platforms. Presently, it is only
// available on UNIX when using a D-Bus daemon capable of passing file
// descriptors. If stdin is not available then nil will be returned. In the
// future, support may be expanded to other platforms.
// 
// You must only call this function once per commandline invocation.
	func (c ApplicationCommandLine) Stdin() InputStream {
var _arg0 *C.GApplicationCommandLine // out
var _cret *C.GInputStream // in

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))

_cret = C.g_application_command_line_get_stdin(_arg0)


var _inputStream InputStream // out

_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)

return _inputStream
}
	
	// env gets the value of a particular environment variable of the command line
// invocation, as would be returned by g_getenv(). The strings may contain
// non-utf8 data.
// 
// The remote application usually does not send an environment. Use
// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it is
// possible that the environment is still not available (due to invocation
// messages from other applications).
// 
// The return value should not be modified or freed and is valid for as long as
// @cmdline exists.
	func (c ApplicationCommandLine) env(name string) string {
var _arg0 *C.GApplicationCommandLine // out
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_application_command_line_getenv(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetExitStatus sets the exit status that will be used when the invoking
// process exits.
// 
// The return value of the #GApplication::command-line signal is passed to this
// function when the handler returns. This is the usual way of setting the exit
// status.
// 
// In the event that you want the remote invocation to continue running and want
// to decide on the exit status in the future, you can use this call. For the
// case of a remote invocation, the remote process will typically exit when the
// last reference is dropped on @cmdline. The exit status of the remote process
// will be equal to the last value that was set with this function.
// 
// In the case that the commandline invocation is local, the situation is
// slightly more complicated. If the commandline invocation results in the
// mainloop running (ie: because the use-count of the application increased to a
// non-zero value) then the application is considered to have been 'successful'
// in a certain sense, and the exit status is always zero. If the application
// use count is zero, though, the exit status of the local CommandLine is used.
	func (c ApplicationCommandLine) SetExitStatus(exitStatus int)  {
var _arg0 *C.GApplicationCommandLine // out
var _arg1 C.int // out

_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(exitStatus)

C.g_application_command_line_set_exit_status(_arg0, _arg1)
}
	


	// BufferedInputStream: buffered input stream implements InputStream and
// provides for buffered reads.
// 
// By default, InputStream's buffer size is set at 4 kilobytes.
// 
// To create a buffered input stream, use g_buffered_input_stream_new(), or
// g_buffered_input_stream_new_sized() to specify the buffer's size at
// construction.
// 
// To get the size of a buffer within a buffered input stream, use
// g_buffered_input_stream_get_buffer_size(). To change the size of a buffered
// input stream's buffer, use g_buffered_input_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
	type BufferedInputStream struct {
		FilterInputStream
		Seekable
		
	}

	// BufferedInputStreamClass is an interface that the BufferedInputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BufferedInputStreamClass interface {
		gextras.Objector
		_bufferedInputStream()
	}

	func (BufferedInputStream) _bufferedInputStream() {}

	
	func marshalBufferedInputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBufferedInputStream(obj), nil
	}
	

	
	// NewBufferedInputStream creates a new Stream from the given @base_stream, with
// a buffer set to the default size (4 kilobytes).
	func NewBufferedInputStream(baseStream InputStreamClass) BufferedInputStream {
var _arg1 *C.GInputStream // out
var _cret *C.GInputStream // in

_arg1 = (*C.GInputStream)(unsafe.Pointer(baseStream.Native()))

_cret = C.g_buffered_input_stream_new(_arg1)


var _bufferedInputStream BufferedInputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_bufferedInputStream = BufferedInputStream{
FilterInputStream: FilterInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Seekable: Seekable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _bufferedInputStream
}
	
	// NewBufferedInputStreamSized creates a new InputStream from the given
// @base_stream, with a buffer set to @size.
	func NewBufferedInputStreamSized(baseStream InputStreamClass, size uint) BufferedInputStream {
var _arg1 *C.GInputStream // out
var _arg2 C.gsize // out
var _cret *C.GInputStream // in

_arg1 = (*C.GInputStream)(unsafe.Pointer(baseStream.Native()))
_arg2 = (C.gsize)(size)

_cret = C.g_buffered_input_stream_new_sized(_arg1, _arg2)


var _bufferedInputStream BufferedInputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_bufferedInputStream = BufferedInputStream{
FilterInputStream: FilterInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Seekable: Seekable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _bufferedInputStream
}
	

	
	// Fill tries to read @count bytes from the stream into the buffer. Will block
// during this read.
// 
// If @count is zero, returns zero and does nothing. A value of @count larger
// than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
// 
// On success, the number of bytes read into the buffer is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// near the end of a file. Zero is returned on end of file (or if @count is
// zero), but never otherwise.
// 
// If @count is -1 then the attempted read size is equal to the number of bytes
// that are required to fill the buffer.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
// 
// On error -1 is returned and @error is set accordingly.
// 
// For the asynchronous, non-blocking, version of this function, see
// g_buffered_input_stream_fill_async().
	func (s BufferedInputStream) Fill(count int, cancellable CancellableClass) (int, error) {
var _arg0 *C.GBufferedInputStream // out
var _arg1 C.gssize // out
var _arg2 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.gssize)(count)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_buffered_input_stream_fill(_arg0, _arg1, _arg2, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// FillFinish finishes an asynchronous read.
	func (s BufferedInputStream) FillFinish(result AsyncResult) (int, error) {
var _arg0 *C.GBufferedInputStream // out
var _arg1 *C.GAsyncResult // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_buffered_input_stream_fill_finish(_arg0, _arg1, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// Available gets the size of the available data within the stream.
	func (s BufferedInputStream) Available() uint {
var _arg0 *C.GBufferedInputStream // out
var _cret C.gsize // in

_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_buffered_input_stream_get_available(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	
	// BufferSize gets the size of the input buffer.
	func (s BufferedInputStream) BufferSize() uint {
var _arg0 *C.GBufferedInputStream // out
var _cret C.gsize // in

_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_buffered_input_stream_get_buffer_size(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	
	// Peek peeks in the buffer, copying data of size @count into @buffer, offset
// @offset bytes.
	func (s BufferedInputStream) Peek(buffer []byte, offset uint) uint {
var _arg0 *C.GBufferedInputStream // out
var _arg1 *C.void
var _arg3 C.gsize
var _arg2 C.gsize // out
var _cret C.gsize // in

_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
_arg3 = C.gsize(len(buffer))
_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
_arg2 = (C.gsize)(offset)

_cret = C.g_buffered_input_stream_peek(_arg0, _arg1, _arg2, _arg3)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	
	// ReadByte tries to read a single byte from the stream or the buffer. Will
// block during this read.
// 
// On success, the byte read from the stream is returned. On end of stream -1 is
// returned but it's not an exceptional error and @error is not set.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
// 
// On error -1 is returned and @error is set accordingly.
	func (s BufferedInputStream) ReadByte(cancellable CancellableClass) (int, error) {
var _arg0 *C.GBufferedInputStream // out
var _arg1 *C.GCancellable // out
var _cret C.int // in
var _cerr *C.GError // in

_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_buffered_input_stream_read_byte(_arg0, _arg1, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// SetBufferSize sets the size of the internal buffer of @stream to @size, or to
// the size of the contents of the buffer. The buffer can never be resized
// smaller than its current contents.
	func (s BufferedInputStream) SetBufferSize(size uint)  {
var _arg0 *C.GBufferedInputStream // out
var _arg1 C.gsize // out

_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.gsize)(size)

C.g_buffered_input_stream_set_buffer_size(_arg0, _arg1)
}
	


	// BufferedOutputStream: buffered output stream implements OutputStream and
// provides for buffered writes.
// 
// By default, OutputStream's buffer size is set at 4 kilobytes.
// 
// To create a buffered output stream, use g_buffered_output_stream_new(), or
// g_buffered_output_stream_new_sized() to specify the buffer's size at
// construction.
// 
// To get the size of a buffer within a buffered input stream, use
// g_buffered_output_stream_get_buffer_size(). To change the size of a buffered
// output stream's buffer, use g_buffered_output_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
	type BufferedOutputStream struct {
		FilterOutputStream
		Seekable
		
	}

	// BufferedOutputStreamClass is an interface that the BufferedOutputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BufferedOutputStreamClass interface {
		gextras.Objector
		_bufferedOutputStream()
	}

	func (BufferedOutputStream) _bufferedOutputStream() {}

	
	func marshalBufferedOutputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBufferedOutputStream(obj), nil
	}
	

	
	// NewBufferedOutputStream creates a new buffered output stream for a base
// stream.
	func NewBufferedOutputStream(baseStream OutputStreamClass) BufferedOutputStream {
var _arg1 *C.GOutputStream // out
var _cret *C.GOutputStream // in

_arg1 = (*C.GOutputStream)(unsafe.Pointer(baseStream.Native()))

_cret = C.g_buffered_output_stream_new(_arg1)


var _bufferedOutputStream BufferedOutputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_bufferedOutputStream = BufferedOutputStream{
FilterOutputStream: FilterOutputStream{
OutputStream: OutputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Seekable: Seekable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _bufferedOutputStream
}
	
	// NewBufferedOutputStreamSized creates a new buffered output stream with a
// given buffer size.
	func NewBufferedOutputStreamSized(baseStream OutputStreamClass, size uint) BufferedOutputStream {
var _arg1 *C.GOutputStream // out
var _arg2 C.gsize // out
var _cret *C.GOutputStream // in

_arg1 = (*C.GOutputStream)(unsafe.Pointer(baseStream.Native()))
_arg2 = (C.gsize)(size)

_cret = C.g_buffered_output_stream_new_sized(_arg1, _arg2)


var _bufferedOutputStream BufferedOutputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_bufferedOutputStream = BufferedOutputStream{
FilterOutputStream: FilterOutputStream{
OutputStream: OutputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Seekable: Seekable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _bufferedOutputStream
}
	

	
	// AutoGrow checks if the buffer automatically grows as data is added.
	func (s BufferedOutputStream) AutoGrow() bool {
var _arg0 *C.GBufferedOutputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_buffered_output_stream_get_auto_grow(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BufferSize gets the size of the buffer in the @stream.
	func (s BufferedOutputStream) BufferSize() uint {
var _arg0 *C.GBufferedOutputStream // out
var _cret C.gsize // in

_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_buffered_output_stream_get_buffer_size(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	
	// SetAutoGrow sets whether or not the @stream's buffer should automatically
// grow. If @auto_grow is true, then each write will just make the buffer
// larger, and you must manually flush the buffer to actually write out the data
// to the underlying stream.
	func (s BufferedOutputStream) SetAutoGrow(autoGrow bool)  {
var _arg0 *C.GBufferedOutputStream // out
var _arg1 C.gboolean // out

_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(s.Native()))
if autoGrow { _arg1 = C.TRUE }

C.g_buffered_output_stream_set_auto_grow(_arg0, _arg1)
}
	
	// SetBufferSize sets the size of the internal buffer to @size.
	func (s BufferedOutputStream) SetBufferSize(size uint)  {
var _arg0 *C.GBufferedOutputStream // out
var _arg1 C.gsize // out

_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.gsize)(size)

C.g_buffered_output_stream_set_buffer_size(_arg0, _arg1)
}
	


	// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
	type BytesIcon struct {
		**externglib.Object
		Icon
		LoadableIcon
		
	}

	// BytesIconClass is an interface that the BytesIcon class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BytesIconClass interface {
		gextras.Objector
		_bytesIcon()
	}

	func (BytesIcon) _bytesIcon() {}

	
	func marshalBytesIcon(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBytesIcon(obj), nil
	}
	

	

	


	// Cancellable: GCancellable is a thread-safe operation cancellation stack used
// throughout GIO to allow for cancellation of synchronous and asynchronous
// operations.
	type Cancellable struct {
		**externglib.Object
		
	}

	// CancellableClass is an interface that the Cancellable class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CancellableClass interface {
		gextras.Objector
		_cancellable()
	}

	func (Cancellable) _cancellable() {}

	
	func marshalCancellable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCancellable(obj), nil
	}
	

	
	// NewCancellable creates a new #GCancellable object.
// 
// Applications that want to start one or more operations that should be
// cancellable should create a #GCancellable and pass it to the operations.
// 
// One #GCancellable can be used in multiple consecutive operations or in
// multiple concurrent operations.
	func NewCancellable() Cancellable {
var _cret *C.GCancellable // in

_cret = C.g_cancellable_new()


var _cancellable Cancellable // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_cancellable = Cancellable{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _cancellable
}
	

	
	// Cancel: will set @cancellable to cancelled, and will emit the
// #GCancellable::cancelled signal. (However, see the warning about race
// conditions in the documentation for that signal if you are planning to
// connect to it.)
// 
// This function is thread-safe. In other words, you can safely call it from a
// thread other than the one running the operation that was passed the
// @cancellable.
// 
// If @cancellable is nil, this function returns immediately for convenience.
// 
// The convention within GIO is that cancelling an asynchronous operation causes
// it to complete asynchronously. That is, if you cancel the operation from the
// same thread in which it is running, then the operation's ReadyCallback will
// not be invoked until the application returns to the main loop.
	func (c Cancellable) Cancel()  {
var _arg0 *C.GCancellable // out

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

C.g_cancellable_cancel(_arg0)
}
	
	// Disconnect disconnects a handler from a cancellable instance similar to
// g_signal_handler_disconnect(). Additionally, in the event that a signal
// handler is currently running, this call will block until the handler has
// finished. Calling this function from a #GCancellable::cancelled signal
// handler will therefore result in a deadlock.
// 
// This avoids a race condition where a thread cancels at the same time as the
// cancellable operation is finished and the signal handler is removed. See
// #GCancellable::cancelled for details on how to use this.
// 
// If @cancellable is nil or @handler_id is `0` this function does nothing.
	func (c Cancellable) Disconnect(handlerId uint32)  {
var _arg0 *C.GCancellable // out
var _arg1 C.gulong // out

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))
_arg1 = (C.gulong)(handlerId)

C.g_cancellable_disconnect(_arg0, _arg1)
}
	
	// Fd gets the file descriptor for a cancellable job. This can be used to
// implement cancellable operations on Unix systems. The returned fd will turn
// readable when @cancellable is cancelled.
// 
// You are not supposed to read from the fd yourself, just check for readable
// status. Reading to unset the readable status is done with
// g_cancellable_reset().
// 
// After a successful return from this function, you should use
// g_cancellable_release_fd() to free up resources allocated for the returned
// file descriptor.
// 
// See also g_cancellable_make_pollfd().
	func (c Cancellable) Fd() int {
var _arg0 *C.GCancellable // out
var _cret C.int // in

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

_cret = C.g_cancellable_get_fd(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsCancelled checks if a cancellable job has been cancelled.
	func (c Cancellable) IsCancelled() bool {
var _arg0 *C.GCancellable // out
var _cret C.gboolean // in

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

_cret = C.g_cancellable_is_cancelled(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MakePollfd creates a FD corresponding to @cancellable; this can be passed to
// g_poll() and used to poll for cancellation. This is useful both for unix
// systems without a native poll and for portability to windows.
// 
// When this function returns true, you should use g_cancellable_release_fd() to
// free up resources allocated for the @pollfd. After a false return, do not
// call g_cancellable_release_fd().
// 
// If this function returns false, either no @cancellable was given or resource
// limits prevent this function from allocating the necessary structures for
// polling. (On Linux, you will likely have reached the maximum number of file
// descriptors.) The suggested way to handle these cases is to ignore the
// @cancellable.
// 
// You are not supposed to read from the fd yourself, just check for readable
// status. Reading to unset the readable status is done with
// g_cancellable_reset().
	func (c Cancellable) MakePollfd(pollfd *glib.PollFD) bool {
var _arg0 *C.GCancellable // out
var _arg1 *C.GPollFD // out
var _cret C.gboolean // in

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GPollFD)(unsafe.Pointer(pollfd.Native()))

_cret = C.g_cancellable_make_pollfd(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PopCurrent pops @cancellable off the cancellable stack (verifying that
// @cancellable is on the top of the stack).
	func (c Cancellable) PopCurrent()  {
var _arg0 *C.GCancellable // out

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

C.g_cancellable_pop_current(_arg0)
}
	
	// PushCurrent pushes @cancellable onto the cancellable stack. The current
// cancellable can then be received using g_cancellable_get_current().
// 
// This is useful when implementing cancellable operations in code that does not
// allow you to pass down the cancellable object.
// 
// This is typically called automatically by e.g. #GFile operations, so you
// rarely have to call this yourself.
	func (c Cancellable) PushCurrent()  {
var _arg0 *C.GCancellable // out

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

C.g_cancellable_push_current(_arg0)
}
	
	// ReleaseFd releases a resources previously allocated by g_cancellable_get_fd()
// or g_cancellable_make_pollfd().
// 
// For compatibility reasons with older releases, calling this function is not
// strictly required, the resources will be automatically freed when the
// @cancellable is finalized. However, the @cancellable will block scarce file
// descriptors until it is finalized if this function is not called. This can
// cause the application to run out of file descriptors when many #GCancellables
// are used at the same time.
	func (c Cancellable) ReleaseFd()  {
var _arg0 *C.GCancellable // out

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

C.g_cancellable_release_fd(_arg0)
}
	
	// Reset resets @cancellable to its uncancelled state.
// 
// If cancellable is currently in use by any cancellable operation then the
// behavior of this function is undefined.
// 
// Note that it is generally not a good idea to reuse an existing cancellable
// for more operations after it has been cancelled once, as this function might
// tempt you to do. The recommended practice is to drop the reference to a
// cancellable after cancelling it, and let it die with the outstanding async
// operations. You should create a fresh cancellable for further async
// operations.
	func (c Cancellable) Reset()  {
var _arg0 *C.GCancellable // out

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

C.g_cancellable_reset(_arg0)
}
	
	// SetErrorIfCancelled: if the @cancellable is cancelled, sets the error to
// notify that the operation was cancelled.
	func (c Cancellable) SetErrorIfCancelled() error {
var _arg0 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GCancellable)(unsafe.Pointer(c.Native()))

C.g_cancellable_set_error_if_cancelled(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	// CharsetConverter is an implementation of #GConverter based on GIConv.
	type CharsetConverter struct {
		**externglib.Object
		Converter
		Initable
		
	}

	// CharsetConverterClass is an interface that the CharsetConverter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CharsetConverterClass interface {
		gextras.Objector
		_charsetConverter()
	}

	func (CharsetConverter) _charsetConverter() {}

	
	func marshalCharsetConverter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCharsetConverter(obj), nil
	}
	

	
	// NewCharsetConverter creates a new Converter.
	func NewCharsetConverter(toCharset string, fromCharset string) (CharsetConverter, error) {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret *C.GCharsetConverter // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(toCharset))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(fromCharset))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_charset_converter_new(_arg1, _arg2, &_cerr)


var _charsetConverter CharsetConverter // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_charsetConverter = CharsetConverter{
Object: &externglib.Object{externglib.ToGObject(obj)},
Converter: Converter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _charsetConverter, _goerr
}
	

	
	// NumFallbacks gets the number of fallbacks that @converter has applied so far.
	func (c CharsetConverter) NumFallbacks() uint {
var _arg0 *C.GCharsetConverter // out
var _cret C.guint // in

_arg0 = (*C.GCharsetConverter)(unsafe.Pointer(c.Native()))

_cret = C.g_charset_converter_get_num_fallbacks(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// UseFallback gets the Converter:use-fallback property.
	func (c CharsetConverter) UseFallback() bool {
var _arg0 *C.GCharsetConverter // out
var _cret C.gboolean // in

_arg0 = (*C.GCharsetConverter)(unsafe.Pointer(c.Native()))

_cret = C.g_charset_converter_get_use_fallback(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetUseFallback sets the Converter:use-fallback property.
	func (c CharsetConverter) SetUseFallback(useFallback bool)  {
var _arg0 *C.GCharsetConverter // out
var _arg1 C.gboolean // out

_arg0 = (*C.GCharsetConverter)(unsafe.Pointer(c.Native()))
if useFallback { _arg1 = C.TRUE }

C.g_charset_converter_set_use_fallback(_arg0, _arg1)
}
	


	// ConverterInputStream: converter input stream implements Stream and allows
// conversion of data of various types during reading.
// 
// As of GLib 2.34, InputStream implements InputStream.
	type ConverterInputStream struct {
		FilterInputStream
		PollableInputStream
		
	}

	// ConverterInputStreamClass is an interface that the ConverterInputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ConverterInputStreamClass interface {
		gextras.Objector
		_converterInputStream()
	}

	func (ConverterInputStream) _converterInputStream() {}

	
	func marshalConverterInputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapConverterInputStream(obj), nil
	}
	

	
	// NewConverterInputStream creates a new converter input stream for the
// @base_stream.
	func NewConverterInputStream(baseStream InputStreamClass, converter Converter) ConverterInputStream {
var _arg1 *C.GInputStream // out
var _arg2 *C.GConverter // out
var _cret *C.GInputStream // in

_arg1 = (*C.GInputStream)(unsafe.Pointer(baseStream.Native()))
_arg2 = (*C.GConverter)(unsafe.Pointer(converter.Native()))

_cret = C.g_converter_input_stream_new(_arg1, _arg2)


var _converterInputStream ConverterInputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_converterInputStream = ConverterInputStream{
FilterInputStream: FilterInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
PollableInputStream: PollableInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _converterInputStream
}
	

	
	// Converter gets the #GConverter that is used by @converter_stream.
	func (c ConverterInputStream) Converter() Converter {
var _arg0 *C.GConverterInputStream // out
var _cret *C.GConverter // in

_arg0 = (*C.GConverterInputStream)(unsafe.Pointer(c.Native()))

_cret = C.g_converter_input_stream_get_converter(_arg0)


var _converter Converter // out

_converter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Converter)

return _converter
}
	


	// ConverterOutputStream: converter output stream implements Stream and allows
// conversion of data of various types during reading.
// 
// As of GLib 2.34, OutputStream implements OutputStream.
	type ConverterOutputStream struct {
		FilterOutputStream
		PollableOutputStream
		
	}

	// ConverterOutputStreamClass is an interface that the ConverterOutputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ConverterOutputStreamClass interface {
		gextras.Objector
		_converterOutputStream()
	}

	func (ConverterOutputStream) _converterOutputStream() {}

	
	func marshalConverterOutputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapConverterOutputStream(obj), nil
	}
	

	
	// NewConverterOutputStream creates a new converter output stream for the
// @base_stream.
	func NewConverterOutputStream(baseStream OutputStreamClass, converter Converter) ConverterOutputStream {
var _arg1 *C.GOutputStream // out
var _arg2 *C.GConverter // out
var _cret *C.GOutputStream // in

_arg1 = (*C.GOutputStream)(unsafe.Pointer(baseStream.Native()))
_arg2 = (*C.GConverter)(unsafe.Pointer(converter.Native()))

_cret = C.g_converter_output_stream_new(_arg1, _arg2)


var _converterOutputStream ConverterOutputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_converterOutputStream = ConverterOutputStream{
FilterOutputStream: FilterOutputStream{
OutputStream: OutputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
PollableOutputStream: PollableOutputStream{
OutputStream: OutputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _converterOutputStream
}
	

	
	// Converter gets the #GConverter that is used by @converter_stream.
	func (c ConverterOutputStream) Converter() Converter {
var _arg0 *C.GConverterOutputStream // out
var _cret *C.GConverter // in

_arg0 = (*C.GConverterOutputStream)(unsafe.Pointer(c.Native()))

_cret = C.g_converter_output_stream_get_converter(_arg0)


var _converter Converter // out

_converter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Converter)

return _converter
}
	


	// Credentials: the #GCredentials type is a reference-counted wrapper for native
// credentials. This information is typically used for identifying,
// authenticating and authorizing other processes.
// 
// Some operating systems supports looking up the credentials of the remote peer
// of a communication endpoint - see e.g. g_socket_get_credentials().
// 
// Some operating systems supports securely sending and receiving credentials
// over a Unix Domain Socket, see CredentialsMessage,
// g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials() for details.
// 
// On Linux, the native credential type is a `struct ucred` - see the unix(7)
// man page for details. This corresponds to G_CREDENTIALS_TYPE_LINUX_UCRED.
// 
// On Apple operating systems (including iOS, tvOS, and macOS), the native
// credential type is a `struct xucred`. This corresponds to
// G_CREDENTIALS_TYPE_APPLE_XUCRED.
// 
// On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is
// a `struct cmsgcred`. This corresponds to G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
// 
// On NetBSD, the native credential type is a `struct unpcbid`. This corresponds
// to G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
// 
// On OpenBSD, the native credential type is a `struct sockpeercred`. This
// corresponds to G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
// 
// On Solaris (including OpenSolaris and its derivatives), the native credential
// type is a `ucred_t`. This corresponds to G_CREDENTIALS_TYPE_SOLARIS_UCRED.
	type Credentials struct {
		**externglib.Object
		
	}

	// CredentialsClass is an interface that the Credentials class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CredentialsClass interface {
		gextras.Objector
		_credentials()
	}

	func (Credentials) _credentials() {}

	
	func marshalCredentials(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCredentials(obj), nil
	}
	

	
	// NewCredentials creates a new #GCredentials object with credentials matching
// the the current process.
	func NewCredentials() Credentials {
var _cret *C.GCredentials // in

_cret = C.g_credentials_new()


var _credentials Credentials // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_credentials = Credentials{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _credentials
}
	

	
	// UnixPid tries to get the UNIX process identifier from @credentials. This
// method is only available on UNIX platforms.
// 
// This operation can fail if #GCredentials is not supported on the OS or if the
// native credentials type does not contain information about the UNIX process
// ID (for example this is the case for G_CREDENTIALS_TYPE_APPLE_XUCRED).
	func (c Credentials) UnixPid() (int, error) {
var _arg0 *C.GCredentials // out
var _cret C.pid_t // in
var _cerr *C.GError // in

_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))

_cret = C.g_credentials_get_unix_pid(_arg0, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// UnixUser tries to get the UNIX user identifier from @credentials. This method
// is only available on UNIX platforms.
// 
// This operation can fail if #GCredentials is not supported on the OS or if the
// native credentials type does not contain information about the UNIX user.
	func (c Credentials) UnixUser() (uint, error) {
var _arg0 *C.GCredentials // out
var _cret C.uid_t // in
var _cerr *C.GError // in

_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))

_cret = C.g_credentials_get_unix_user(_arg0, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// IsSameUser checks if @credentials and @other_credentials is the same user.
// 
// This operation can fail if #GCredentials is not supported on the the OS.
	func (c Credentials) IsSameUser(otherCredentials CredentialsClass) error {
var _arg0 *C.GCredentials // out
var _arg1 *C.GCredentials // out
var _cerr *C.GError // in

_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GCredentials)(unsafe.Pointer(otherCredentials.Native()))

C.g_credentials_is_same_user(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetUnixUser tries to set the UNIX user identifier on @credentials. This
// method is only available on UNIX platforms.
// 
// This operation can fail if #GCredentials is not supported on the OS or if the
// native credentials type does not contain information about the UNIX user. It
// can also fail if the OS does not allow the use of "spoofed" credentials.
	func (c Credentials) SetUnixUser(uid uint) error {
var _arg0 *C.GCredentials // out
var _arg1 C.uid_t // out
var _cerr *C.GError // in

_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))
_arg1 = (C.uid_t)(uid)

C.g_credentials_set_unix_user(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// String creates a human-readable textual representation of @credentials that
// can be used in logging and debug messages. The format of the returned string
// may change in future GLib release.
	func (c Credentials) String() string {
var _arg0 *C.GCredentials // out
var _cret *C.gchar // in

_arg0 = (*C.GCredentials)(unsafe.Pointer(c.Native()))

_cret = C.g_credentials_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
	type DBusActionGroup struct {
		**externglib.Object
		ActionGroup
		RemoteActionGroup
		
	}

	// DBusActionGroupClass is an interface that the DBusActionGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusActionGroupClass interface {
		gextras.Objector
		_dBusActionGroup()
	}

	func (DBusActionGroup) _dBusActionGroup() {}

	
	func marshalDBusActionGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusActionGroup(obj), nil
	}
	

	

	


	// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
// 
// 
// Controlling Authentication Mechanisms
// 
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
// 
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
// 
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
// 
//      return authorized;
//    }
	type DBusAuthObserver struct {
		**externglib.Object
		
	}

	// DBusAuthObserverClass is an interface that the DBusAuthObserver class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusAuthObserverClass interface {
		gextras.Objector
		_dBusAuthObserver()
	}

	func (DBusAuthObserver) _dBusAuthObserver() {}

	
	func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusAuthObserver(obj), nil
	}
	

	
	// NewDBusAuthObserver creates a new BusAuthObserver object.
	func NewDBusAuthObserver() DBusAuthObserver {
var _cret *C.GDBusAuthObserver // in

_cret = C.g_dbus_auth_observer_new()


var _dBusAuthObserver DBusAuthObserver // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusAuthObserver = DBusAuthObserver{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _dBusAuthObserver
}
	

	
	// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
// @observer.
	func (o DBusAuthObserver) AllowMechanism(mechanism string) bool {
var _arg0 *C.GDBusAuthObserver // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
_arg1 = (*C.gchar)(C.CString(mechanism))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_auth_observer_allow_mechanism(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AuthorizeAuthenticatedPeer emits the
// BusAuthObserver::authorize-authenticated-peer signal on @observer.
	func (o DBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStreamClass, credentials CredentialsClass) bool {
var _arg0 *C.GDBusAuthObserver // out
var _arg1 *C.GIOStream // out
var _arg2 *C.GCredentials // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
_arg2 = (*C.GCredentials)(unsafe.Pointer(credentials.Native()))

_cret = C.g_dbus_auth_observer_authorize_authenticated_peer(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
// 
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
// 
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
// 
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
// 
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
// 
// 
// An example D-Bus server
// 
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
// 
// 
// An example for exporting a subtree
// 
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
// 
// 
// An example for file descriptor passing
// 
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
// 
// 
// An example for exporting a GObject
// 
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
	type DBusConnection struct {
		**externglib.Object
		AsyncInitable
		Initable
		
	}

	// DBusConnectionClass is an interface that the DBusConnection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusConnectionClass interface {
		gextras.Objector
		_dBusConnection()
	}

	func (DBusConnection) _dBusConnection() {}

	
	func marshalDBusConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusConnection(obj), nil
	}
	

	
	// NewDBusConnectionFinish finishes an operation started with
// g_dbus_connection_new().
	func NewDBusConnectionFinish(res AsyncResult) (DBusConnection, error) {
var _arg1 *C.GAsyncResult // out
var _cret *C.GDBusConnection // in
var _cerr *C.GError // in

_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_connection_new_finish(_arg1, &_cerr)


var _dBusConnection DBusConnection // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusConnection = DBusConnection{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusConnection, _goerr
}
	
	// NewDBusConnectionForAddressFinish finishes an operation started with
// g_dbus_connection_new_for_address().
	func NewDBusConnectionForAddressFinish(res AsyncResult) (DBusConnection, error) {
var _arg1 *C.GAsyncResult // out
var _cret *C.GDBusConnection // in
var _cerr *C.GError // in

_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_connection_new_for_address_finish(_arg1, &_cerr)


var _dBusConnection DBusConnection // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusConnection = DBusConnection{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusConnection, _goerr
}
	
	// NewDBusConnectionForAddressSync: synchronously connects and sets up a D-Bus
// client connection for exchanging D-Bus messages with an endpoint specified by
// @address which must be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
// 
// This constructor can only be used to initiate client-side connections - use
// g_dbus_connection_new_sync() if you need to act as the server. In particular,
// @flags cannot contain the G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
// 
// This is a synchronous failable constructor. See
// g_dbus_connection_new_for_address() for the asynchronous version.
// 
// If @observer is not nil it may be used to control the authentication process.
	func NewDBusConnectionForAddressSync(address string, flags DBusConnectionFlags, observer DBusAuthObserverClass, cancellable CancellableClass) (DBusConnection, error) {
var _arg1 *C.gchar // out
var _arg2 C.GDBusConnectionFlags // out
var _arg3 *C.GDBusAuthObserver // out
var _arg4 *C.GCancellable // out
var _cret *C.GDBusConnection // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(address))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GDBusConnectionFlags)(flags)
_arg3 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_connection_new_for_address_sync(_arg1, _arg2, _arg3, _arg4, &_cerr)


var _dBusConnection DBusConnection // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusConnection = DBusConnection{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusConnection, _goerr
}
	
	// NewDBusConnectionSync: synchronously sets up a D-Bus connection for
// exchanging D-Bus messages with the end represented by @stream.
// 
// If @stream is a Connection, then the corresponding #GSocket will be put into
// non-blocking mode.
// 
// The D-Bus connection will interact with @stream from a worker thread. As a
// result, the caller should not interact with @stream after this method has
// been called, except by calling g_object_unref() on it.
// 
// If @observer is not nil it may be used to control the authentication process.
// 
// This is a synchronous failable constructor. See g_dbus_connection_new() for
// the asynchronous version.
	func NewDBusConnectionSync(stream IOStreamClass, guid string, flags DBusConnectionFlags, observer DBusAuthObserverClass, cancellable CancellableClass) (DBusConnection, error) {
var _arg1 *C.GIOStream // out
var _arg2 *C.gchar // out
var _arg3 C.GDBusConnectionFlags // out
var _arg4 *C.GDBusAuthObserver // out
var _arg5 *C.GCancellable // out
var _cret *C.GDBusConnection // in
var _cerr *C.GError // in

_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
_arg2 = (*C.gchar)(C.CString(guid))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.GDBusConnectionFlags)(flags)
_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_connection_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)


var _dBusConnection DBusConnection // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusConnection = DBusConnection{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusConnection, _goerr
}
	

	
	// CallFinish finishes an operation started with g_dbus_connection_call().
	func (c DBusConnection) CallFinish(res AsyncResult) (*glib.Variant, error) {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GVariant // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_connection_call_finish(_arg0, _arg1, &_cerr)


var _variant *glib.Variant // out
var _goerr error // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _variant, _goerr
}
	
	// CallSync: synchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at @object_path owned by
// @bus_name.
// 
// If @connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If @cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible with the
// D-Bus protocol, the operation fails with G_IO_ERROR_INVALID_ARGUMENT.
// 
// If @reply_type is non-nil then the reply will be checked for having this type
// and an error will be raised if it does not match. Said another way, if you
// give a @reply_type then any non-nil return value will be of this type.
// 
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
// 
//    g_dbus_connection_call_sync (connection,
//                                 "org.freedesktop.StringThings",
//                                 "/org/freedesktop/StringThings",
//                                 "org.freedesktop.StringThings",
//                                 "TwoStrings",
//                                 g_variant_new ("(ss)",
//                                                "Thing One",
//                                                "Thing Two"),
//                                 NULL,
//                                 G_DBUS_CALL_FLAGS_NONE,
//                                 -1,
//                                 NULL,
//                                 &error);
// 
// The calling thread is blocked until a reply is received. See
// g_dbus_connection_call() for the asynchronous version of this method.
	func (c DBusConnection) CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable CancellableClass) (*glib.Variant, error) {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _arg5 *C.GVariant // out
var _arg6 *C.GVariantType // out
var _arg7 C.GDBusCallFlags // out
var _arg8 C.gint // out
var _arg9 *C.GCancellable // out
var _cret *C.GVariant // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(busName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(interfaceName))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(methodName))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
_arg7 = (C.GDBusCallFlags)(flags)
_arg8 = (C.gint)(timeoutMsec)
_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_connection_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_cerr)


var _variant *glib.Variant // out
var _goerr error // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _variant, _goerr
}
	
	// CallWithUnixFdListFinish finishes an operation started with
// g_dbus_connection_call_with_unix_fd_list().
// 
// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values in
// the body of the message. For example, if g_variant_get_handle() returns 5,
// that is intended to be a reference to the file descriptor that can be
// accessed by `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
// 
// When designing D-Bus APIs that are intended to be interoperable, please note
// that non-GDBus implementations of D-Bus can usually only access file
// descriptors if they are referenced in this way by a value of type
// G_VARIANT_TYPE_HANDLE in the body of the message.
	func (c DBusConnection) CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error) {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.GUnixFDList // in
var _arg2 *C.GAsyncResult // out
var _cret *C.GVariant // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_connection_call_with_unix_fd_list_finish(_arg0, &_arg1, _arg2, &_cerr)


var _outFdList UnixFDList // out
var _variant *glib.Variant // out
var _goerr error // out

_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1))).(UnixFDList)
_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _outFdList, _variant, _goerr
}
	
	// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes and
// returns FDList objects. See g_dbus_connection_call_with_unix_fd_list() and
// g_dbus_connection_call_with_unix_fd_list_finish() for more details.
// 
// This method is only available on UNIX.
	func (c DBusConnection) CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDListClass, cancellable CancellableClass) (UnixFDList, *glib.Variant, error) {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _arg5 *C.GVariant // out
var _arg6 *C.GVariantType // out
var _arg7 C.GDBusCallFlags // out
var _arg8 C.gint // out
var _arg9 *C.GUnixFDList // out
var _arg10 *C.GUnixFDList // in
var _arg11 *C.GCancellable // out
var _cret *C.GVariant // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(busName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(interfaceName))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(methodName))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
_arg7 = (C.GDBusCallFlags)(flags)
_arg8 = (C.gint)(timeoutMsec)
_arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
_arg11 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_connection_call_with_unix_fd_list_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_arg10, _arg11, &_cerr)


var _outFdList UnixFDList // out
var _variant *glib.Variant // out
var _goerr error // out

_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg10))).(UnixFDList)
_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _outFdList, _variant, _goerr
}
	
	// CloseFinish finishes an operation started with g_dbus_connection_close().
	func (c DBusConnection) CloseFinish(res AsyncResult) error {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

C.g_dbus_connection_close_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CloseSync: synchronously closes @connection. The calling thread is blocked
// until this is done. See g_dbus_connection_close() for the asynchronous
// version of this method and more details about what it does.
	func (c DBusConnection) CloseSync(cancellable CancellableClass) error {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_dbus_connection_close_sync(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// EmitSignal emits a signal.
// 
// If the parameters GVariant is floating, it is consumed.
// 
// This can only fail if @parameters is not compatible with the D-Bus protocol
// (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
// (G_IO_ERROR_CLOSED).
	func (c DBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _arg5 *C.GVariant // out
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(destinationBusName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(interfaceName))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(signalName))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

C.g_dbus_connection_emit_signal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ExportActionGroup exports @action_group on @connection at @object_path.
// 
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
// 
// A given object path can only have one action group exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// @error set accordingly).
// 
// You can unexport the action group using
// g_dbus_connection_unexport_action_group() with the return value of this
// function.
// 
// The thread default main context is taken at the time of this call. All
// incoming action activations and state change requests are reported from this
// context. Any changes on the action group that cause it to emit signals must
// also come from this same context. Since incoming action activations and state
// change requests are rather likely to cause changes on the action group, this
// effectively limits a given action group to being exported from only one main
// context.
	func (c DBusConnection) ExportActionGroup(objectPath string, actionGroup ActionGroup) (uint, error) {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.gchar // out
var _arg2 *C.GActionGroup // out
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GActionGroup)(unsafe.Pointer(actionGroup.Native()))

_cret = C.g_dbus_connection_export_action_group(_arg0, _arg1, _arg2, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// ExportMenuModel exports @menu on @connection at @object_path.
// 
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
// 
// An object path can only have one menu model exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// @error set accordingly).
// 
// You can unexport the menu model using g_dbus_connection_unexport_menu_model()
// with the return value of this function.
	func (c DBusConnection) ExportMenuModel(objectPath string, menu MenuModelClass) (uint, error) {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.gchar // out
var _arg2 *C.GMenuModel // out
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GMenuModel)(unsafe.Pointer(menu.Native()))

_cret = C.g_dbus_connection_export_menu_model(_arg0, _arg1, _arg2, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// FlushFinish finishes an operation started with g_dbus_connection_flush().
	func (c DBusConnection) FlushFinish(res AsyncResult) error {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

C.g_dbus_connection_flush_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// FlushSync: synchronously flushes @connection. The calling thread is blocked
// until this is done. See g_dbus_connection_flush() for the asynchronous
// version of this method and more details about what it does.
	func (c DBusConnection) FlushSync(cancellable CancellableClass) error {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_dbus_connection_flush_sync(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Capabilities gets the capabilities negotiated with the remote peer
	func (c DBusConnection) Capabilities() DBusCapabilityFlags {
var _arg0 *C.GDBusConnection // out
var _cret C.GDBusCapabilityFlags // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dbus_connection_get_capabilities(_arg0)


var _dBusCapabilityFlags DBusCapabilityFlags // out

_dBusCapabilityFlags = DBusCapabilityFlags(_cret)

return _dBusCapabilityFlags
}
	
	// ExitOnClose gets whether the process is terminated when @connection is closed
// by the remote peer. See BusConnection:exit-on-close for more details.
	func (c DBusConnection) ExitOnClose() bool {
var _arg0 *C.GDBusConnection // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dbus_connection_get_exit_on_close(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Flags gets the flags used to construct this connection
	func (c DBusConnection) Flags() DBusConnectionFlags {
var _arg0 *C.GDBusConnection // out
var _cret C.GDBusConnectionFlags // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dbus_connection_get_flags(_arg0)


var _dBusConnectionFlags DBusConnectionFlags // out

_dBusConnectionFlags = DBusConnectionFlags(_cret)

return _dBusConnectionFlags
}
	
	// Guid: the GUID of the peer performing the role of server when authenticating.
// See BusConnection:guid for more details.
	func (c DBusConnection) Guid() string {
var _arg0 *C.GDBusConnection // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dbus_connection_get_guid(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// LastSerial retrieves the last serial number assigned to a BusMessage on the
// current thread. This includes messages sent via both low-level API such as
// g_dbus_connection_send_message() as well as high-level API such as
// g_dbus_connection_emit_signal(), g_dbus_connection_call() or
// g_dbus_proxy_call().
	func (c DBusConnection) LastSerial() uint32 {
var _arg0 *C.GDBusConnection // out
var _cret C.guint32 // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dbus_connection_get_last_serial(_arg0)


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}
	
	// PeerCredentials gets the credentials of the authenticated peer. This will
// always return nil unless @connection acted as a server (e.g.
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and the
// client passed credentials as part of the authentication process.
// 
// In a message bus setup, the message bus is always the server and each
// application is a client. So this method will always return nil for message
// bus clients.
	func (c DBusConnection) PeerCredentials() Credentials {
var _arg0 *C.GDBusConnection // out
var _cret *C.GCredentials // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dbus_connection_get_peer_credentials(_arg0)


var _credentials Credentials // out

_credentials = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Credentials)

return _credentials
}
	
	// Stream gets the underlying stream used for IO.
// 
// While the BusConnection is active, it will interact with this stream from a
// worker thread, so it is not safe to interact with the stream directly.
	func (c DBusConnection) Stream() IOStream {
var _arg0 *C.GDBusConnection // out
var _cret *C.GIOStream // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dbus_connection_get_stream(_arg0)


var _ioStream IOStream // out

_ioStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IOStream)

return _ioStream
}
	
	// UniqueName gets the unique name of @connection as assigned by the message
// bus. This can also be used to figure out if @connection is a message bus
// connection.
	func (c DBusConnection) UniqueName() string {
var _arg0 *C.GDBusConnection // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dbus_connection_get_unique_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IsClosed gets whether @connection is closed.
	func (c DBusConnection) IsClosed() bool {
var _arg0 *C.GDBusConnection // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_dbus_connection_is_closed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveFilter removes a filter.
// 
// Note that since filters run in a different thread, there is a race condition
// where it is possible that the filter will be running even after calling
// g_dbus_connection_remove_filter(), so you cannot just free data that the
// filter might be using. Instead, you should pass a Notify to
// g_dbus_connection_add_filter(), which will be called when it is guaranteed
// that the data is no longer needed.
	func (c DBusConnection) RemoveFilter(filterId uint)  {
var _arg0 *C.GDBusConnection // out
var _arg1 C.guint // out

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(filterId)

C.g_dbus_connection_remove_filter(_arg0, _arg1)
}
	
	// SendMessage: asynchronously sends @message to the peer represented by
// @connection.
// 
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the
// serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the message
// to the underlying transport. While it has a `volatile` qualifier, this is a
// historical artifact and the argument passed to it should not be `volatile`.
// 
// If @connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If @message is not well-formed, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
// 
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
// 
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	func (c DBusConnection) SendMessage(message DBusMessageClass, flags DBusSendMessageFlags) (uint32, error) {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.GDBusMessage // out
var _arg2 C.GDBusSendMessageFlags // out
var _arg3 C.guint32 // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
_arg2 = (C.GDBusSendMessageFlags)(flags)

C.g_dbus_connection_send_message(_arg0, _arg1, _arg2, &_arg3, &_cerr)

var _outSerial uint32 // out
var _goerr error // out

_outSerial = (uint32)(_arg3)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _outSerial, _goerr
}
	
	// SendMessageWithReplyFinish finishes an operation started with
// g_dbus_connection_send_message_with_reply().
// 
// Note that @error is only set if a local in-process error occurred. That is to
// say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode this
// to a #GError.
// 
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
	func (c DBusConnection) SendMessageWithReplyFinish(res AsyncResult) (DBusMessage, error) {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GDBusMessage // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_connection_send_message_with_reply_finish(_arg0, _arg1, &_cerr)


var _dBusMessage DBusMessage // out
var _goerr error // out

_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusMessage, _goerr
}
	
	// SendMessageWithReplySync: synchronously sends @message to the peer
// represented by @connection and blocks the calling thread until a reply is
// received or the timeout is reached. See
// g_dbus_connection_send_message_with_reply() for the asynchronous version of
// this method.
// 
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the
// serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the message
// to the underlying transport. While it has a `volatile` qualifier, this is a
// historical artifact and the argument passed to it should not be `volatile`.
// 
// If @connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If @cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation fails
// with G_IO_ERROR_INVALID_ARGUMENT.
// 
// Note that @error is only set if a local in-process error occurred. That is to
// say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode this
// to a #GError.
// 
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
// 
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	func (c DBusConnection) SendMessageWithReplySync(message DBusMessageClass, flags DBusSendMessageFlags, timeoutMsec int, cancellable CancellableClass) (uint32, DBusMessage, error) {
var _arg0 *C.GDBusConnection // out
var _arg1 *C.GDBusMessage // out
var _arg2 C.GDBusSendMessageFlags // out
var _arg3 C.gint // out
var _arg4 C.guint32 // in
var _arg5 *C.GCancellable // out
var _cret *C.GDBusMessage // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
_arg2 = (C.GDBusSendMessageFlags)(flags)
_arg3 = (C.gint)(timeoutMsec)
_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_connection_send_message_with_reply_sync(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, &_cerr)


var _outSerial uint32 // out
var _dBusMessage DBusMessage // out
var _goerr error // out

_outSerial = (uint32)(_arg4)
_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _outSerial, _dBusMessage, _goerr
}
	
	// SetExitOnClose sets whether the process should be terminated when @connection
// is closed by the remote peer. See BusConnection:exit-on-close for more
// details.
// 
// Note that this function should be used with care. Most modern UNIX desktops
// tie the notion of a user session with the session bus, and expect all of a
// user's applications to quit when their bus connection goes away. If you are
// setting @exit_on_close to false for the shared session bus connection, you
// should make sure that your application exits when the user session ends.
	func (c DBusConnection) SetExitOnClose(exitOnClose bool)  {
var _arg0 *C.GDBusConnection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
if exitOnClose { _arg1 = C.TRUE }

C.g_dbus_connection_set_exit_on_close(_arg0, _arg1)
}
	
	// SignalUnsubscribe unsubscribes from signals.
// 
// Note that there may still be D-Bus traffic to process (relating to this
// signal subscription) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_dbus_connection_signal_subscribe() is called, in
// order to avoid memory leaks through callbacks queued on the Context after
// its stopped being iterated.
	func (c DBusConnection) SignalUnsubscribe(subscriptionId uint)  {
var _arg0 *C.GDBusConnection // out
var _arg1 C.guint // out

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(subscriptionId)

C.g_dbus_connection_signal_unsubscribe(_arg0, _arg1)
}
	
	// StartMessageProcessing: if @connection was created with
// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
// processing messages. Does nothing on if @connection wasn't created with this
// flag or if the method has already been called.
	func (c DBusConnection) StartMessageProcessing()  {
var _arg0 *C.GDBusConnection // out

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

C.g_dbus_connection_start_message_processing(_arg0)
}
	
	// UnexportActionGroup reverses the effect of a previous call to
// g_dbus_connection_export_action_group().
// 
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_action_group() or to call it with the same ID more
// than once.
	func (c DBusConnection) UnexportActionGroup(exportId uint)  {
var _arg0 *C.GDBusConnection // out
var _arg1 C.guint // out

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(exportId)

C.g_dbus_connection_unexport_action_group(_arg0, _arg1)
}
	
	// UnexportMenuModel reverses the effect of a previous call to
// g_dbus_connection_export_menu_model().
// 
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_menu_model() or to call it with the same ID more
// than once.
	func (c DBusConnection) UnexportMenuModel(exportId uint)  {
var _arg0 *C.GDBusConnection // out
var _arg1 C.guint // out

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(exportId)

C.g_dbus_connection_unexport_menu_model(_arg0, _arg1)
}
	
	// UnregisterObject unregisters an object.
	func (c DBusConnection) UnregisterObject(registrationId uint) bool {
var _arg0 *C.GDBusConnection // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(registrationId)

_cret = C.g_dbus_connection_unregister_object(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UnregisterSubtree unregisters a subtree.
	func (c DBusConnection) UnregisterSubtree(registrationId uint) bool {
var _arg0 *C.GDBusConnection // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(registrationId)

_cret = C.g_dbus_connection_unregister_subtree(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// DBusInterfaceSkeleton: abstract base class for D-Bus interfaces on the
// service side.
	type DBusInterfaceSkeleton struct {
		**externglib.Object
		DBusInterface
		
	}

	// DBusInterfaceSkeletonClass is an interface that the DBusInterfaceSkeleton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusInterfaceSkeletonClass interface {
		gextras.Objector
		_dBusInterfaceSkeleton()
	}

	func (DBusInterfaceSkeleton) _dBusInterfaceSkeleton() {}

	
	func marshalDBusInterfaceSkeleton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusInterfaceSkeleton(obj), nil
	}
	

	

	
	// Export exports @interface_ at @object_path on @connection.
// 
// This can be called multiple times to export the same @interface_ onto
// multiple connections however the @object_path provided must be the same for
// all connections.
// 
// Use g_dbus_interface_skeleton_unexport() to unexport the object.
	func (i DBusInterfaceSkeleton) Export(connection DBusConnectionClass, objectPath string) error {
var _arg0 *C.GDBusInterfaceSkeleton // out
var _arg1 *C.GDBusConnection // out
var _arg2 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
_arg2 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg2))

C.g_dbus_interface_skeleton_export(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Flush: if @interface_ has outstanding changes, request for these changes to
// be emitted immediately.
// 
// For example, an exported D-Bus interface may queue up property changes and
// emit the `org.freedesktop.DBus.Properties.PropertiesChanged` signal later
// (e.g. in an idle handler). This technique is useful for collapsing multiple
// property changes into one.
	func (i DBusInterfaceSkeleton) Flush()  {
var _arg0 *C.GDBusInterfaceSkeleton // out

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

C.g_dbus_interface_skeleton_flush(_arg0)
}
	
	// Connection gets the first connection that @interface_ is exported on, if any.
	func (i DBusInterfaceSkeleton) Connection() DBusConnection {
var _arg0 *C.GDBusInterfaceSkeleton // out
var _cret *C.GDBusConnection // in

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_interface_skeleton_get_connection(_arg0)


var _dBusConnection DBusConnection // out

_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

return _dBusConnection
}
	
	// Flags gets the BusInterfaceSkeletonFlags that describes what the behavior of
// @interface_
	func (i DBusInterfaceSkeleton) Flags() DBusInterfaceSkeletonFlags {
var _arg0 *C.GDBusInterfaceSkeleton // out
var _cret C.GDBusInterfaceSkeletonFlags // in

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_interface_skeleton_get_flags(_arg0)


var _dBusInterfaceSkeletonFlags DBusInterfaceSkeletonFlags // out

_dBusInterfaceSkeletonFlags = DBusInterfaceSkeletonFlags(_cret)

return _dBusInterfaceSkeletonFlags
}
	
	// Info gets D-Bus introspection information for the D-Bus interface implemented
// by @interface_.
	func (i DBusInterfaceSkeleton) Info() *DBusInterfaceInfo {
var _arg0 *C.GDBusInterfaceSkeleton // out
var _cret *C.GDBusInterfaceInfo // in

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_interface_skeleton_get_info(_arg0)


var _dBusInterfaceInfo *DBusInterfaceInfo // out

_dBusInterfaceInfo = *(**DBusInterfaceInfo)(unsafe.Pointer(&_cret))

return _dBusInterfaceInfo
}
	
	// ObjectPath gets the object path that @interface_ is exported on, if any.
	func (i DBusInterfaceSkeleton) ObjectPath() string {
var _arg0 *C.GDBusInterfaceSkeleton // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_interface_skeleton_get_object_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Properties gets all D-Bus properties for @interface_.
	func (i DBusInterfaceSkeleton) Properties() *glib.Variant {
var _arg0 *C.GDBusInterfaceSkeleton // out
var _cret *C.GVariant // in

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_interface_skeleton_get_properties(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// HasConnection checks if @interface_ is exported on @connection.
	func (i DBusInterfaceSkeleton) HasConnection(connection DBusConnectionClass) bool {
var _arg0 *C.GDBusInterfaceSkeleton // out
var _arg1 *C.GDBusConnection // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

_cret = C.g_dbus_interface_skeleton_has_connection(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetFlags sets flags describing what the behavior of @skeleton should be.
	func (i DBusInterfaceSkeleton) SetFlags(flags DBusInterfaceSkeletonFlags)  {
var _arg0 *C.GDBusInterfaceSkeleton // out
var _arg1 C.GDBusInterfaceSkeletonFlags // out

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))
_arg1 = (C.GDBusInterfaceSkeletonFlags)(flags)

C.g_dbus_interface_skeleton_set_flags(_arg0, _arg1)
}
	
	// Unexport stops exporting @interface_ on all connections it is exported on.
// 
// To unexport @interface_ from only a single connection, use
// g_dbus_interface_skeleton_unexport_from_connection()
	func (i DBusInterfaceSkeleton) Unexport()  {
var _arg0 *C.GDBusInterfaceSkeleton // out

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))

C.g_dbus_interface_skeleton_unexport(_arg0)
}
	
	// UnexportFromConnection stops exporting @interface_ on @connection.
// 
// To stop exporting on all connections the interface is exported on, use
// g_dbus_interface_skeleton_unexport().
	func (i DBusInterfaceSkeleton) UnexportFromConnection(connection DBusConnectionClass)  {
var _arg0 *C.GDBusInterfaceSkeleton // out
var _arg1 *C.GDBusConnection // out

_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

C.g_dbus_interface_skeleton_unexport_from_connection(_arg0, _arg1)
}
	


	// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
	type DBusMenuModel struct {
		MenuModel
		
	}

	// DBusMenuModelClass is an interface that the DBusMenuModel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusMenuModelClass interface {
		gextras.Objector
		_dBusMenuModel()
	}

	func (DBusMenuModel) _dBusMenuModel() {}

	
	func marshalDBusMenuModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusMenuModel(obj), nil
	}
	

	

	


	// DBusMessage: a type for representing D-Bus messages that can be sent or
// received on a BusConnection.
	type DBusMessage struct {
		**externglib.Object
		
	}

	// DBusMessageClass is an interface that the DBusMessage class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusMessageClass interface {
		gextras.Objector
		_dBusMessage()
	}

	func (DBusMessage) _dBusMessage() {}

	
	func marshalDBusMessage(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusMessage(obj), nil
	}
	

	
	// NewDBusMessage creates a new empty BusMessage.
	func NewDBusMessage() DBusMessage {
var _cret *C.GDBusMessage // in

_cret = C.g_dbus_message_new()


var _dBusMessage DBusMessage // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusMessage = DBusMessage{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _dBusMessage
}
	
	// NewDBusMessageFromBlob creates a new BusMessage from the data stored at
// @blob. The byte order that the message was in can be retrieved using
// g_dbus_message_get_byte_order().
// 
// If the @blob cannot be parsed, contains invalid fields, or contains invalid
// headers, G_IO_ERROR_INVALID_ARGUMENT will be returned.
	func NewDBusMessageFromBlob(blob []byte, capabilities DBusCapabilityFlags) (DBusMessage, error) {
var _arg1 *C.guchar
var _arg2 C.gsize
var _arg3 C.GDBusCapabilityFlags // out
var _cret *C.GDBusMessage // in
var _cerr *C.GError // in

_arg2 = C.gsize(len(blob))
_arg1 = (*C.guchar)(unsafe.Pointer(&blob[0]))
_arg3 = (C.GDBusCapabilityFlags)(capabilities)

_cret = C.g_dbus_message_new_from_blob(_arg1, _arg2, _arg3, &_cerr)


var _dBusMessage DBusMessage // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusMessage = DBusMessage{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusMessage, _goerr
}
	
	// NewDBusMessageMethodCall creates a new BusMessage for a method call.
	func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) DBusMessage {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _cret *C.GDBusMessage // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(interface_))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(method))
defer C.free(unsafe.Pointer(_arg4))

_cret = C.g_dbus_message_new_method_call(_arg1, _arg2, _arg3, _arg4)


var _dBusMessage DBusMessage // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusMessage = DBusMessage{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _dBusMessage
}
	
	// NewDBusMessageSignal creates a new BusMessage for a signal emission.
	func NewDBusMessageSignal(path string, interface_ string, signal string) DBusMessage {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _cret *C.GDBusMessage // in

_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(interface_))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(signal))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.g_dbus_message_new_signal(_arg1, _arg2, _arg3)


var _dBusMessage DBusMessage // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusMessage = DBusMessage{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _dBusMessage
}
	

	
	// Copy copies @message. The copy is a deep copy and the returned BusMessage is
// completely identical except that it is guaranteed to not be locked.
// 
// This operation can fail if e.g. @message contains file descriptors and the
// per-process or system-wide open files limit is reached.
	func (m DBusMessage) Copy() (DBusMessage, error) {
var _arg0 *C.GDBusMessage // out
var _cret *C.GDBusMessage // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_copy(_arg0, &_cerr)


var _dBusMessage DBusMessage // out
var _goerr error // out

_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusMessage, _goerr
}
	
	// Arg0: convenience to get the first item in the body of @message.
	func (m DBusMessage) Arg0() string {
var _arg0 *C.GDBusMessage // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_arg0(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Body gets the body of a message.
	func (m DBusMessage) Body() *glib.Variant {
var _arg0 *C.GDBusMessage // out
var _cret *C.GVariant // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_body(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// ByteOrder gets the byte order of @message.
	func (m DBusMessage) ByteOrder() DBusMessageByteOrder {
var _arg0 *C.GDBusMessage // out
var _cret C.GDBusMessageByteOrder // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_byte_order(_arg0)


var _dBusMessageByteOrder DBusMessageByteOrder // out

_dBusMessageByteOrder = DBusMessageByteOrder(_cret)

return _dBusMessageByteOrder
}
	
	// Destination: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	func (m DBusMessage) Destination() string {
var _arg0 *C.GDBusMessage // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_destination(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ErrorName: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME
// header field.
	func (m DBusMessage) ErrorName() string {
var _arg0 *C.GDBusMessage // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_error_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Flags gets the flags for @message.
	func (m DBusMessage) Flags() DBusMessageFlags {
var _arg0 *C.GDBusMessage // out
var _cret C.GDBusMessageFlags // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_flags(_arg0)


var _dBusMessageFlags DBusMessageFlags // out

_dBusMessageFlags = DBusMessageFlags(_cret)

return _dBusMessageFlags
}
	
	// Header gets a header field on @message.
// 
// The caller is responsible for checking the type of the returned #GVariant
// matches what is expected.
	func (m DBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant {
var _arg0 *C.GDBusMessage // out
var _arg1 C.GDBusMessageHeaderField // out
var _cret *C.GVariant // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.GDBusMessageHeaderField)(headerField)

_cret = C.g_dbus_message_get_header(_arg0, _arg1)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// HeaderFields gets an array of all header fields on @message that are set.
	func (m DBusMessage) HeaderFields() []byte {
var _arg0 *C.GDBusMessage // out
var _cret *C.guchar

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_header_fields(_arg0)


var _guint8s []byte

{
var i int
var z C.guchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_guint8s = make([]byte, i)
for i := range src {
_guint8s[i] = (byte)(src[i])
}
}

return _guint8s
}
	
	// Interface: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE
// header field.
	func (m DBusMessage) Interface() string {
var _arg0 *C.GDBusMessage // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_interface(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Locked checks whether @message is locked. To monitor changes to this value,
// conncet to the #GObject::notify signal to listen for changes on the
// BusMessage:locked property.
	func (m DBusMessage) Locked() bool {
var _arg0 *C.GDBusMessage // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_locked(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header
// field.
	func (m DBusMessage) Member() string {
var _arg0 *C.GDBusMessage // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_member(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// MessageType gets the type of @message.
	func (m DBusMessage) MessageType() DBusMessageType {
var _arg0 *C.GDBusMessage // out
var _cret C.GDBusMessageType // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_message_type(_arg0)


var _dBusMessageType DBusMessageType // out

_dBusMessageType = DBusMessageType(_cret)

return _dBusMessageType
}
	
	// NumUnixFds: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	func (m DBusMessage) NumUnixFds() uint32 {
var _arg0 *C.GDBusMessage // out
var _cret C.guint32 // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_num_unix_fds(_arg0)


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}
	
	// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
	func (m DBusMessage) Path() string {
var _arg0 *C.GDBusMessage // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ReplySerial: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	func (m DBusMessage) ReplySerial() uint32 {
var _arg0 *C.GDBusMessage // out
var _cret C.guint32 // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_reply_serial(_arg0)


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}
	
	// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER header
// field.
	func (m DBusMessage) Sender() string {
var _arg0 *C.GDBusMessage // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_sender(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Serial gets the serial for @message.
	func (m DBusMessage) Serial() uint32 {
var _arg0 *C.GDBusMessage // out
var _cret C.guint32 // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_serial(_arg0)


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}
	
	// Signature: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE
// header field.
	func (m DBusMessage) Signature() string {
var _arg0 *C.GDBusMessage // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_signature(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// UnixFdList gets the UNIX file descriptors associated with @message, if any.
// 
// This method is only available on UNIX.
// 
// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values in
// the body of the message. For example, if g_variant_get_handle() returns 5,
// that is intended to be a reference to the file descriptor that can be
// accessed by `g_unix_fd_list_get (list, 5, ...)`.
	func (m DBusMessage) UnixFdList() UnixFDList {
var _arg0 *C.GDBusMessage // out
var _cret *C.GUnixFDList // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_get_unix_fd_list(_arg0)


var _unixFDList UnixFDList // out

_unixFDList = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(UnixFDList)

return _unixFDList
}
	
	// Lock: if @message is locked, does nothing. Otherwise locks the message.
	func (m DBusMessage) Lock()  {
var _arg0 *C.GDBusMessage // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

C.g_dbus_message_lock(_arg0)
}
	
	// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
// @method_call_message.
	func (m DBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret *C.GDBusMessage // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(errorName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(errorMessage))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_dbus_message_new_method_error_literal(_arg0, _arg1, _arg2)


var _dBusMessage DBusMessage // out

_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

return _dBusMessage
}
	
	// NewMethodReply creates a new BusMessage that is a reply to
// @method_call_message.
	func (m DBusMessage) NewMethodReply() DBusMessage {
var _arg0 *C.GDBusMessage // out
var _cret *C.GDBusMessage // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_message_new_method_reply(_arg0)


var _dBusMessage DBusMessage // out

_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

return _dBusMessage
}
	
	// Print produces a human-readable multi-line description of @message.
// 
// The contents of the description has no ABI guarantees, the contents and
// formatting is subject to change at any time. Typical output looks something
// like this:
// 
//    Flags:   none
//    Version: 0
//    Serial:  4
//    Headers:
//      path -> objectpath '/org/gtk/GDBus/TestObject'
//      interface -> 'org.gtk.GDBus.TestInterface'
//      member -> 'GimmeStdout'
//      destination -> ':1.146'
//    Body: ()
//    UNIX File Descriptors:
//      (none)
// 
// or
// 
//    Flags:   no-reply-expected
//    Version: 0
//    Serial:  477
//    Headers:
//      reply-serial -> uint32 4
//      destination -> ':1.159'
//      sender -> ':1.146'
//      num-unix-fds -> uint32 1
//    Body: ()
//    UNIX File Descriptors:
//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
	func (m DBusMessage) Print(indent uint) string {
var _arg0 *C.GDBusMessage // out
var _arg1 C.guint // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(indent)

_cret = C.g_dbus_message_print(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// SetBody sets the body @message. As a side-effect the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type string
// of @body (or cleared if @body is nil).
// 
// If @body is floating, @message assumes ownership of @body.
	func (m DBusMessage) SetBody(body *glib.Variant)  {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.GVariant // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(body.Native()))

C.g_dbus_message_set_body(_arg0, _arg1)
}
	
	// SetByteOrder sets the byte order of @message.
	func (m DBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder)  {
var _arg0 *C.GDBusMessage // out
var _arg1 C.GDBusMessageByteOrder // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.GDBusMessageByteOrder)(byteOrder)

C.g_dbus_message_set_byte_order(_arg0, _arg1)
}
	
	// SetDestination: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	func (m DBusMessage) SetDestination(value string)  {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.gchar // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_message_set_destination(_arg0, _arg1)
}
	
	// SetErrorName: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	func (m DBusMessage) SetErrorName(value string)  {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.gchar // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_message_set_error_name(_arg0, _arg1)
}
	
	// SetFlags sets the flags to set on @message.
	func (m DBusMessage) SetFlags(flags DBusMessageFlags)  {
var _arg0 *C.GDBusMessage // out
var _arg1 C.GDBusMessageFlags // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.GDBusMessageFlags)(flags)

C.g_dbus_message_set_flags(_arg0, _arg1)
}
	
	// SetHeader sets a header field on @message.
// 
// If @value is floating, @message assumes ownership of @value.
	func (m DBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant)  {
var _arg0 *C.GDBusMessage // out
var _arg1 C.GDBusMessageHeaderField // out
var _arg2 *C.GVariant // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.GDBusMessageHeaderField)(headerField)
_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

C.g_dbus_message_set_header(_arg0, _arg1, _arg2)
}
	
	// SetInterface: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	func (m DBusMessage) SetInterface(value string)  {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.gchar // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_message_set_interface(_arg0, _arg1)
}
	
	// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
	func (m DBusMessage) SetMember(value string)  {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.gchar // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_message_set_member(_arg0, _arg1)
}
	
	// SetMessageType sets @message to be of @type.
	func (m DBusMessage) SetMessageType(typ DBusMessageType)  {
var _arg0 *C.GDBusMessage // out
var _arg1 C.GDBusMessageType // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.GDBusMessageType)(typ)

C.g_dbus_message_set_message_type(_arg0, _arg1)
}
	
	// SetNumUnixFds: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	func (m DBusMessage) SetNumUnixFds(value uint32)  {
var _arg0 *C.GDBusMessage // out
var _arg1 C.guint32 // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint32)(value)

C.g_dbus_message_set_num_unix_fds(_arg0, _arg1)
}
	
	// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
	func (m DBusMessage) SetPath(value string)  {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.gchar // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_message_set_path(_arg0, _arg1)
}
	
	// SetReplySerial: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	func (m DBusMessage) SetReplySerial(value uint32)  {
var _arg0 *C.GDBusMessage // out
var _arg1 C.guint32 // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint32)(value)

C.g_dbus_message_set_reply_serial(_arg0, _arg1)
}
	
	// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
	func (m DBusMessage) SetSender(value string)  {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.gchar // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_message_set_sender(_arg0, _arg1)
}
	
	// SetSerial sets the serial for @message.
	func (m DBusMessage) SetSerial(serial uint32)  {
var _arg0 *C.GDBusMessage // out
var _arg1 C.guint32 // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint32)(serial)

C.g_dbus_message_set_serial(_arg0, _arg1)
}
	
	// SetSignature: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	func (m DBusMessage) SetSignature(value string)  {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.gchar // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_message_set_signature(_arg0, _arg1)
}
	
	// SetUnixFdList sets the UNIX file descriptors associated with @message. As a
// side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field is set
// to the number of fds in @fd_list (or cleared if @fd_list is nil).
// 
// This method is only available on UNIX.
// 
// When designing D-Bus APIs that are intended to be interoperable, please note
// that non-GDBus implementations of D-Bus can usually only access file
// descriptors if they are referenced by a value of type G_VARIANT_TYPE_HANDLE
// in the body of the message.
	func (m DBusMessage) SetUnixFdList(fdList UnixFDListClass)  {
var _arg0 *C.GDBusMessage // out
var _arg1 *C.GUnixFDList // out

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

C.g_dbus_message_set_unix_fd_list(_arg0, _arg1)
}
	
	// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does nothing
// and returns false.
// 
// Otherwise this method encodes the error in @message as a #GError using
// g_dbus_error_set_dbus_error() using the information in the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well as
// the first string item in @message's body.
	func (m DBusMessage) ToGerror() error {
var _arg0 *C.GDBusMessage // out
var _cerr *C.GError // in

_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

C.g_dbus_message_to_gerror(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
// 
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
	type DBusMethodInvocation struct {
		**externglib.Object
		
	}

	// DBusMethodInvocationClass is an interface that the DBusMethodInvocation class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusMethodInvocationClass interface {
		gextras.Objector
		_dBusMethodInvocation()
	}

	func (DBusMethodInvocation) _dBusMethodInvocation() {}

	
	func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusMethodInvocation(obj), nil
	}
	

	

	
	// Connection gets the BusConnection the method was invoked on.
	func (i DBusMethodInvocation) Connection() DBusConnection {
var _arg0 *C.GDBusMethodInvocation // out
var _cret *C.GDBusConnection // in

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_invocation_get_connection(_arg0)


var _dBusConnection DBusConnection // out

_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

return _dBusConnection
}
	
	// InterfaceName gets the name of the D-Bus interface the method was invoked on.
// 
// If this method call is a property Get, Set or GetAll call that has been
// redirected to the method call handler then "org.freedesktop.DBus.Properties"
// will be returned. See BusInterfaceVTable for more information.
	func (i DBusMethodInvocation) InterfaceName() string {
var _arg0 *C.GDBusMethodInvocation // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_invocation_get_interface_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Message gets the BusMessage for the method invocation. This is useful if you
// need to use low-level protocol features, such as UNIX file descriptor
// passing, that cannot be properly expressed in the #GVariant API.
// 
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
	func (i DBusMethodInvocation) Message() DBusMessage {
var _arg0 *C.GDBusMethodInvocation // out
var _cret *C.GDBusMessage // in

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_invocation_get_message(_arg0)


var _dBusMessage DBusMessage // out

_dBusMessage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusMessage)

return _dBusMessage
}
	
	// MethodInfo gets information about the method call, if any.
// 
// If this method invocation is a property Get, Set or GetAll call that has been
// redirected to the method call handler then nil will be returned. See
// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for more
// information.
	func (i DBusMethodInvocation) MethodInfo() *DBusMethodInfo {
var _arg0 *C.GDBusMethodInvocation // out
var _cret *C.GDBusMethodInfo // in

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_invocation_get_method_info(_arg0)


var _dBusMethodInfo *DBusMethodInfo // out

_dBusMethodInfo = *(**DBusMethodInfo)(unsafe.Pointer(&_cret))

return _dBusMethodInfo
}
	
	// MethodName gets the name of the method that was invoked.
	func (i DBusMethodInvocation) MethodName() string {
var _arg0 *C.GDBusMethodInvocation // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_invocation_get_method_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ObjectPath gets the object path the method was invoked on.
	func (i DBusMethodInvocation) ObjectPath() string {
var _arg0 *C.GDBusMethodInvocation // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_invocation_get_object_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Parameters gets the parameters of the method invocation. If there are no
// input parameters then this will return a GVariant with 0 children rather than
// NULL.
	func (i DBusMethodInvocation) Parameters() *glib.Variant {
var _arg0 *C.GDBusMethodInvocation // out
var _cret *C.GVariant // in

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_invocation_get_parameters(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// PropertyInfo gets information about the property that this method call is
// for, if any.
// 
// This will only be set in the case of an invocation in response to a property
// Get or Set call that has been directed to the method call handler for an
// object on account of its property_get() or property_set() vtable pointers
// being unset.
// 
// See BusInterfaceVTable for more information.
// 
// If the call was GetAll, nil will be returned.
	func (i DBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
var _arg0 *C.GDBusMethodInvocation // out
var _cret *C.GDBusPropertyInfo // in

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_invocation_get_property_info(_arg0)


var _dBusPropertyInfo *DBusPropertyInfo // out

_dBusPropertyInfo = *(**DBusPropertyInfo)(unsafe.Pointer(&_cret))

return _dBusPropertyInfo
}
	
	// Sender gets the bus name that invoked the method.
	func (i DBusMethodInvocation) Sender() string {
var _arg0 *C.GDBusMethodInvocation // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_invocation_get_sender(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ReturnDBusError finishes handling a D-Bus method call by returning an error.
// 
// This method will take ownership of @invocation. See BusInterfaceVTable for
// more information about the ownership of @invocation.
	func (i DBusMethodInvocation) ReturnDBusError(errorName string, errorMessage string)  {
var _arg0 *C.GDBusMethodInvocation // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(errorName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(errorMessage))
defer C.free(unsafe.Pointer(_arg2))

C.g_dbus_method_invocation_return_dbus_error(_arg0, _arg1, _arg2)
}
	
	// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
// #GError instead of the error domain, error code and message.
// 
// This method will take ownership of @invocation. See BusInterfaceVTable for
// more information about the ownership of @invocation.
	func (i DBusMethodInvocation) ReturnGerror(err error)  {
var _arg0 *C.GDBusMethodInvocation // out
var _arg1 *C.GError // out

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))
defer C.g_error_free(_arg1)

C.g_dbus_method_invocation_return_gerror(_arg0, _arg1)
}
	
	// ReturnValue finishes handling a D-Bus method call by returning @parameters.
// If the @parameters GVariant is floating, it is consumed.
// 
// It is an error if @parameters is not of the right format: it must be a tuple
// containing the out-parameters of the D-Bus method. Even if the method has a
// single out-parameter, it must be contained in a tuple. If the method has no
// out-parameters, @parameters may be nil or an empty tuple.
// 
//    GDBusMethodInvocation *invocation = some_invocation;
//    g_autofree gchar *result_string = NULL;
//    g_autoptr (GError) error = NULL;
// 
//    result_string = calculate_result (&error);
// 
//    if (error != NULL)
//      g_dbus_method_invocation_return_gerror (invocation, error);
//    else
//      g_dbus_method_invocation_return_value (invocation,
//                                             g_variant_new ("(s)", result_string));
// 
//    // Do not free @invocation here; returning a value does that
// 
// This method will take ownership of @invocation. See BusInterfaceVTable for
// more information about the ownership of @invocation.
// 
// Since 2.48, if the method call requested for a reply not to be sent then this
// call will sink @parameters and free @invocation, but otherwise do nothing (as
// per the recommendations of the D-Bus specification).
	func (i DBusMethodInvocation) ReturnValue(parameters *glib.Variant)  {
var _arg0 *C.GDBusMethodInvocation // out
var _arg1 *C.GVariant // out

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

C.g_dbus_method_invocation_return_value(_arg0, _arg1)
}
	
	// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value() but
// also takes a FDList.
// 
// This method is only available on UNIX.
// 
// This method will take ownership of @invocation. See BusInterfaceVTable for
// more information about the ownership of @invocation.
	func (i DBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDListClass)  {
var _arg0 *C.GDBusMethodInvocation // out
var _arg1 *C.GVariant // out
var _arg2 *C.GUnixFDList // out

_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
_arg2 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

C.g_dbus_method_invocation_return_value_with_unix_fd_list(_arg0, _arg1, _arg2)
}
	


	// DBusObjectManagerClient is used to create, monitor and delete object proxies
// for remote objects exported by a BusObjectManagerServer (or any code
// implementing the org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
// 
// Once an instance of this type has been created, you can connect to the
// BusObjectManager::object-added and BusObjectManager::object-removed signals
// and inspect the BusObjectProxy objects returned by
// g_dbus_object_manager_get_objects().
// 
// If the name for a BusObjectManagerClient is not owned by anyone at object
// construction time, the default behavior is to request the message bus to
// launch an owner for the name. This behavior can be disabled using the
// G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START flag. It's also worth
// noting that this only works if the name of interest is activatable in the
// first place. E.g. in some cases it is not possible to launch an owner for the
// requested name. In this case, BusObjectManagerClient object construction
// still succeeds but there will be no object proxies (e.g.
// g_dbus_object_manager_get_objects() returns the empty list) and the
// BusObjectManagerClient:name-owner property is nil.
// 
// The owner of the requested name can come and go (for example consider a
// system service being restarted)  BusObjectManagerClient handles this case
// too; simply connect to the #GObject::notify signal to watch for changes on
// the BusObjectManagerClient:name-owner property. When the name owner vanishes,
// the behavior is that BusObjectManagerClient:name-owner is set to nil (this
// includes emission of the #GObject::notify signal) and then
// BusObjectManager::object-removed signals are synthesized for all currently
// existing object proxies. Since BusObjectManagerClient:name-owner is nil when
// this happens, you can use this information to disambiguate a synthesized
// signal from a genuine signal caused by object removal on the remote
// BusObjectManager. Similarly, when a new name owner appears,
// BusObjectManager::object-added signals are synthesized while
// BusObjectManagerClient:name-owner is still nil. Only when all object proxies
// have been added, the BusObjectManagerClient:name-owner is set to the new name
// owner (this includes emission of the #GObject::notify signal). Furthermore,
// you are guaranteed that BusObjectManagerClient:name-owner will alternate
// between a name owner (e.g. `:1.42`) and nil even in the case where the name
// of interest is atomically replaced
// 
// Ultimately, BusObjectManagerClient is used to obtain BusProxy instances. All
// signals (including the org.freedesktop.DBus.Properties::PropertiesChanged
// signal) delivered to BusProxy instances are guaranteed to originate from the
// name owner. This guarantee along with the behavior described above, means
// that certain race conditions including the "half the proxy is from the old
// owner and the other half is from the new owner" problem cannot happen.
// 
// To avoid having the application connect to signals on the returned
// BusObjectProxy and BusProxy objects, the BusObject::interface-added,
// BusObject::interface-removed, BusProxy::g-properties-changed and
// BusProxy::g-signal signals are also emitted on the BusObjectManagerClient
// instance managing these objects. The signals emitted are
// BusObjectManager::interface-added, BusObjectManager::interface-removed,
// BusObjectManagerClient::interface-proxy-properties-changed and
// BusObjectManagerClient::interface-proxy-signal.
// 
// Note that all callbacks and signals are emitted in the [thread-default main
// context][g-main-context-push-thread-default] that the BusObjectManagerClient
// object was constructed in. Additionally, the BusObjectProxy and BusProxy
// objects originating from the BusObjectManagerClient object will be created in
// the same context and, consequently, will deliver signals in the same main
// loop.
	type DBusObjectManagerClient struct {
		**externglib.Object
		AsyncInitable
		DBusObjectManager
		Initable
		
	}

	// DBusObjectManagerClientClass is an interface that the DBusObjectManagerClient class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusObjectManagerClientClass interface {
		gextras.Objector
		_dBusObjectManagerClient()
	}

	func (DBusObjectManagerClient) _dBusObjectManagerClient() {}

	
	func marshalDBusObjectManagerClient(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusObjectManagerClient(obj), nil
	}
	

	
	// NewDBusObjectManagerClientFinish finishes an operation started with
// g_dbus_object_manager_client_new().
	func NewDBusObjectManagerClientFinish(res AsyncResult) (DBusObjectManagerClient, error) {
var _arg1 *C.GAsyncResult // out
var _cret *C.GDBusObjectManager // in
var _cerr *C.GError // in

_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_object_manager_client_new_finish(_arg1, &_cerr)


var _dBusObjectManagerClient DBusObjectManagerClient // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusObjectManagerClient = DBusObjectManagerClient{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
DBusObjectManager: DBusObjectManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusObjectManagerClient, _goerr
}
	
	// NewDBusObjectManagerClientForBusFinish finishes an operation started with
// g_dbus_object_manager_client_new_for_bus().
	func NewDBusObjectManagerClientForBusFinish(res AsyncResult) (DBusObjectManagerClient, error) {
var _arg1 *C.GAsyncResult // out
var _cret *C.GDBusObjectManager // in
var _cerr *C.GError // in

_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_object_manager_client_new_for_bus_finish(_arg1, &_cerr)


var _dBusObjectManagerClient DBusObjectManagerClient // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusObjectManagerClient = DBusObjectManagerClient{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
DBusObjectManager: DBusObjectManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusObjectManagerClient, _goerr
}
	

	
	// Connection gets the BusConnection used by @manager.
	func (m DBusObjectManagerClient) Connection() DBusConnection {
var _arg0 *C.GDBusObjectManagerClient // out
var _cret *C.GDBusConnection // in

_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_object_manager_client_get_connection(_arg0)


var _dBusConnection DBusConnection // out

_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

return _dBusConnection
}
	
	// Flags gets the flags that @manager was constructed with.
	func (m DBusObjectManagerClient) Flags() DBusObjectManagerClientFlags {
var _arg0 *C.GDBusObjectManagerClient // out
var _cret C.GDBusObjectManagerClientFlags // in

_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_object_manager_client_get_flags(_arg0)


var _dBusObjectManagerClientFlags DBusObjectManagerClientFlags // out

_dBusObjectManagerClientFlags = DBusObjectManagerClientFlags(_cret)

return _dBusObjectManagerClientFlags
}
	
	// Name gets the name that @manager is for, or nil if not a message bus
// connection.
	func (m DBusObjectManagerClient) Name() string {
var _arg0 *C.GDBusObjectManagerClient // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_object_manager_client_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NameOwner: the unique name that owns the name that @manager is for or nil if
// no-one currently owns that name. You can connect to the #GObject::notify
// signal to track changes to the BusObjectManagerClient:name-owner property.
	func (m DBusObjectManagerClient) NameOwner() string {
var _arg0 *C.GDBusObjectManagerClient // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_object_manager_client_get_name_owner(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	// DBusObjectManagerServer is used to export BusObject instances using the
// standardized org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface. For example, remote D-Bus clients can get all objects and
// properties in a single call. Additionally, any change in the object hierarchy
// is broadcast using signals. This means that D-Bus clients can keep caches up
// to date by only listening to D-Bus signals.
// 
// The recommended path to export an object manager at is the path form of the
// well-known name of a D-Bus service, or below. For example, if a D-Bus service
// is available at the well-known name `net.example.ExampleService1`, the object
// manager should typically be exported at `/net/example/ExampleService1`, or
// below (to allow for multiple object managers in a service).
// 
// It is supported, but not recommended, to export an object manager at the root
// path, `/`.
// 
// See BusObjectManagerClient for the client-side code that is intended to be
// used with BusObjectManagerServer or any D-Bus object implementing the
// org.freedesktop.DBus.ObjectManager interface.
	type DBusObjectManagerServer struct {
		**externglib.Object
		DBusObjectManager
		
	}

	// DBusObjectManagerServerClass is an interface that the DBusObjectManagerServer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusObjectManagerServerClass interface {
		gextras.Objector
		_dBusObjectManagerServer()
	}

	func (DBusObjectManagerServer) _dBusObjectManagerServer() {}

	
	func marshalDBusObjectManagerServer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusObjectManagerServer(obj), nil
	}
	

	
	// NewDBusObjectManagerServer creates a new BusObjectManagerServer object.
// 
// The returned server isn't yet exported on any connection. To do so, use
// g_dbus_object_manager_server_set_connection(). Normally you want to export
// all of your objects before doing so to avoid InterfacesAdded
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// signals being emitted.
	func NewDBusObjectManagerServer(objectPath string) DBusObjectManagerServer {
var _arg1 *C.gchar // out
var _cret *C.GDBusObjectManagerServer // in

_arg1 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_object_manager_server_new(_arg1)


var _dBusObjectManagerServer DBusObjectManagerServer // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusObjectManagerServer = DBusObjectManagerServer{
Object: &externglib.Object{externglib.ToGObject(obj)},
DBusObjectManager: DBusObjectManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dBusObjectManagerServer
}
	

	
	// Export exports @object on @manager.
// 
// If there is already a BusObject exported at the object path, then the old
// object is removed.
// 
// The object path for @object must be in the hierarchy rooted by the object
// path for @manager.
// 
// Note that @manager will take a reference on @object for as long as it is
// exported.
	func (m DBusObjectManagerServer) Export(object DBusObjectSkeletonClass)  {
var _arg0 *C.GDBusObjectManagerServer // out
var _arg1 *C.GDBusObjectSkeleton // out

_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(object.Native()))

C.g_dbus_object_manager_server_export(_arg0, _arg1)
}
	
	// ExportUniquely: like g_dbus_object_manager_server_export() but appends a
// string of the form _N (with N being a natural number) to @object's object
// path if an object with the given path already exists. As such, the
// BusObjectProxy:g-object-path property of @object may be modified.
	func (m DBusObjectManagerServer) ExportUniquely(object DBusObjectSkeletonClass)  {
var _arg0 *C.GDBusObjectManagerServer // out
var _arg1 *C.GDBusObjectSkeleton // out

_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(object.Native()))

C.g_dbus_object_manager_server_export_uniquely(_arg0, _arg1)
}
	
	// Connection gets the BusConnection used by @manager.
	func (m DBusObjectManagerServer) Connection() DBusConnection {
var _arg0 *C.GDBusObjectManagerServer // out
var _cret *C.GDBusConnection // in

_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))

_cret = C.g_dbus_object_manager_server_get_connection(_arg0)


var _dBusConnection DBusConnection // out

_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)

return _dBusConnection
}
	
	// IsExported returns whether @object is currently exported on @manager.
	func (m DBusObjectManagerServer) IsExported(object DBusObjectSkeletonClass) bool {
var _arg0 *C.GDBusObjectManagerServer // out
var _arg1 *C.GDBusObjectSkeleton // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(object.Native()))

_cret = C.g_dbus_object_manager_server_is_exported(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetConnection exports all objects managed by @manager on @connection. If
// @connection is nil, stops exporting objects.
	func (m DBusObjectManagerServer) SetConnection(connection DBusConnectionClass)  {
var _arg0 *C.GDBusObjectManagerServer // out
var _arg1 *C.GDBusConnection // out

_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))

C.g_dbus_object_manager_server_set_connection(_arg0, _arg1)
}
	
	// Unexport: if @manager has an object at @path, removes the object. Otherwise
// does nothing.
// 
// Note that @object_path must be in the hierarchy rooted by the object path for
// @manager.
	func (m DBusObjectManagerServer) Unexport(objectPath string) bool {
var _arg0 *C.GDBusObjectManagerServer // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_object_manager_server_unexport(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// DBusObjectProXY: a BusObjectProxy is an object used to represent a remote
// object with one or more D-Bus interfaces. Normally, you don't instantiate a
// BusObjectProxy yourself - typically BusObjectManagerClient is used to obtain
// it.
	type DBusObjectProXY struct {
		**externglib.Object
		DBusObject
		
	}

	// DBusObjectProXYClass is an interface that the DBusObjectProXY class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusObjectProXYClass interface {
		gextras.Objector
		_dBusObjectProXY()
	}

	func (DBusObjectProXY) _dBusObjectProXY() {}

	
	func marshalDBusObjectProXY(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusObjectProXY(obj), nil
	}
	

	
	// NewDBusObjectProXY creates a new BusObjectProxy for the given connection and
// object path.
	func NewDBusObjectProXY(connection DBusConnectionClass, objectPath string) DBusObjectProXY {
var _arg1 *C.GDBusConnection // out
var _arg2 *C.gchar // out
var _cret *C.GDBusObjectProxy // in

_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
_arg2 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_dbus_object_proxy_new(_arg1, _arg2)


var _dBusObjectProxy DBusObjectProXY // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusObjectProxy = DBusObjectProXY{
Object: &externglib.Object{externglib.ToGObject(obj)},
DBusObject: DBusObject{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dBusObjectProxy
}
	

	
	// Connection gets the connection that @proxy is for.
	func (p DBusObjectProXY) Connection() DBusConnection {
var _arg0 *C.GDBusObjectProxy // out
var _cret *C.GDBusConnection // in

_arg0 = (*C.GDBusObjectProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_object_proxy_get_connection(_arg0)


var _dBusConnection DBusConnection // out

_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

return _dBusConnection
}
	


	// DBusObjectSkeleton: a BusObjectSkeleton instance is essentially a group of
// D-Bus interfaces. The set of exported interfaces on the object may be dynamic
// and change at runtime.
// 
// This type is intended to be used with BusObjectManager.
	type DBusObjectSkeleton struct {
		**externglib.Object
		DBusObject
		
	}

	// DBusObjectSkeletonClass is an interface that the DBusObjectSkeleton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusObjectSkeletonClass interface {
		gextras.Objector
		_dBusObjectSkeleton()
	}

	func (DBusObjectSkeleton) _dBusObjectSkeleton() {}

	
	func marshalDBusObjectSkeleton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusObjectSkeleton(obj), nil
	}
	

	
	// NewDBusObjectSkeleton creates a new BusObjectSkeleton.
	func NewDBusObjectSkeleton(objectPath string) DBusObjectSkeleton {
var _arg1 *C.gchar // out
var _cret *C.GDBusObjectSkeleton // in

_arg1 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_object_skeleton_new(_arg1)


var _dBusObjectSkeleton DBusObjectSkeleton // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusObjectSkeleton = DBusObjectSkeleton{
Object: &externglib.Object{externglib.ToGObject(obj)},
DBusObject: DBusObject{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dBusObjectSkeleton
}
	

	
	// AddInterface adds @interface_ to @object.
// 
// If @object already contains a BusInterfaceSkeleton with the same interface
// name, it is removed before @interface_ is added.
// 
// Note that @object takes its own reference on @interface_ and holds it until
// removed.
	func (o DBusObjectSkeleton) AddInterface(interface_ DBusInterfaceSkeletonClass)  {
var _arg0 *C.GDBusObjectSkeleton // out
var _arg1 *C.GDBusInterfaceSkeleton // out

_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(interface_.Native()))

C.g_dbus_object_skeleton_add_interface(_arg0, _arg1)
}
	
	// Flush: this method simply calls g_dbus_interface_skeleton_flush() on all
// interfaces belonging to @object. See that method for when flushing is useful.
	func (o DBusObjectSkeleton) Flush()  {
var _arg0 *C.GDBusObjectSkeleton // out

_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))

C.g_dbus_object_skeleton_flush(_arg0)
}
	
	// RemoveInterface removes @interface_ from @object.
	func (o DBusObjectSkeleton) RemoveInterface(interface_ DBusInterfaceSkeletonClass)  {
var _arg0 *C.GDBusObjectSkeleton // out
var _arg1 *C.GDBusInterfaceSkeleton // out

_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(interface_.Native()))

C.g_dbus_object_skeleton_remove_interface(_arg0, _arg1)
}
	
	// RemoveInterfaceByName removes the BusInterface with @interface_name from
// @object.
// 
// If no D-Bus interface of the given interface exists, this function does
// nothing.
	func (o DBusObjectSkeleton) RemoveInterfaceByName(interfaceName string)  {
var _arg0 *C.GDBusObjectSkeleton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))
_arg1 = (*C.gchar)(C.CString(interfaceName))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_object_skeleton_remove_interface_by_name(_arg0, _arg1)
}
	
	// SetObjectPath sets the object path for @object.
	func (o DBusObjectSkeleton) SetObjectPath(objectPath string)  {
var _arg0 *C.GDBusObjectSkeleton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(o.Native()))
_arg1 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg1))

C.g_dbus_object_skeleton_set_object_path(_arg0, _arg1)
}
	


	// DBusProXY is a base class used for proxies to access a D-Bus interface on a
// remote object. A BusProxy can be constructed for both well-known and unique
// names.
// 
// By default, BusProxy will cache all properties (and listen to changes) of the
// remote object, and proxy all signals that get emitted. This behaviour can be
// changed by passing suitable BusProxyFlags when the proxy is created. If the
// proxy is for a well-known name, the property cache is flushed when the name
// owner vanishes and reloaded when a name owner appears.
// 
// The unique name owner of the proxy's name is tracked and can be read from
// BusProxy:g-name-owner. Connect to the #GObject::notify signal to get notified
// of changes. Additionally, only signals and property changes emitted from the
// current name owner are considered and calls are always sent to the current
// name owner. This avoids a number of race conditions when the name is lost by
// one owner and claimed by another. However, if no name owner currently exists,
// then calls will be sent to the well-known name which may result in the
// message bus launching an owner (unless G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// is set).
// 
// The generic BusProxy::g-properties-changed and BusProxy::g-signal signals are
// not very convenient to work with. Therefore, the recommended way of working
// with proxies is to subclass BusProxy, and have more natural properties and
// signals in your derived class. This [example][gdbus-example-gdbus-codegen]
// shows how this can easily be done using the [gdbus-codegen][gdbus-codegen]
// tool.
// 
// A BusProxy instance can be used from multiple threads but note that all
// signals (e.g. BusProxy::g-signal, BusProxy::g-properties-changed and
// #GObject::notify) are emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread where the instance
// was constructed.
// 
// An example using a proxy for a well-known name can be found in
// gdbus-example-watch-proxy.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c)
	type DBusProXY struct {
		**externglib.Object
		AsyncInitable
		DBusInterface
		Initable
		
	}

	// DBusProXYClass is an interface that the DBusProXY class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusProXYClass interface {
		gextras.Objector
		_dBusProXY()
	}

	func (DBusProXY) _dBusProXY() {}

	
	func marshalDBusProXY(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusProXY(obj), nil
	}
	

	
	// NewDBusProXYFinish finishes creating a BusProxy.
	func NewDBusProXYFinish(res AsyncResult) (DBusProXY, error) {
var _arg1 *C.GAsyncResult // out
var _cret *C.GDBusProxy // in
var _cerr *C.GError // in

_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_proxy_new_finish(_arg1, &_cerr)


var _dBusProxy DBusProXY // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusProxy = DBusProXY{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
DBusInterface: DBusInterface{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusProxy, _goerr
}
	
	// NewDBusProXYForBusFinish finishes creating a BusProxy.
	func NewDBusProXYForBusFinish(res AsyncResult) (DBusProXY, error) {
var _arg1 *C.GAsyncResult // out
var _cret *C.GDBusProxy // in
var _cerr *C.GError // in

_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_proxy_new_for_bus_finish(_arg1, &_cerr)


var _dBusProxy DBusProXY // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusProxy = DBusProXY{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
DBusInterface: DBusInterface{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusProxy, _goerr
}
	
	// NewDBusProXYForBusSync: like g_dbus_proxy_new_sync() but takes a Type instead
// of a BusConnection.
// 
// BusProxy is used in this [example][gdbus-wellknown-proxy].
	func NewDBusProXYForBusSync(busType BusType, flags DBusProXYFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable CancellableClass) (DBusProXY, error) {
var _arg1 C.GBusType // out
var _arg2 C.GDBusProxyFlags // out
var _arg3 *C.GDBusInterfaceInfo // out
var _arg4 *C.gchar // out
var _arg5 *C.gchar // out
var _arg6 *C.gchar // out
var _arg7 *C.GCancellable // out
var _cret *C.GDBusProxy // in
var _cerr *C.GError // in

_arg1 = (C.GBusType)(busType)
_arg2 = (C.GDBusProxyFlags)(flags)
_arg3 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(info.Native()))
_arg4 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (*C.gchar)(C.CString(interfaceName))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_proxy_new_for_bus_sync(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)


var _dBusProxy DBusProXY // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusProxy = DBusProXY{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
DBusInterface: DBusInterface{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusProxy, _goerr
}
	
	// NewDBusProXYSync creates a proxy for accessing @interface_name on the remote
// object at @object_path owned by @name at @connection and synchronously loads
// D-Bus properties unless the G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is
// used.
// 
// If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets
// up match rules for signals. Connect to the BusProxy::g-signal signal to
// handle signals from the remote object.
// 
// If both G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
// G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
// guaranteed to return immediately without blocking.
// 
// If @name is a well-known name and the G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// and G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION flags aren't set and
// no name owner currently exists, the message bus will be requested to launch a
// name owner for the name.
// 
// This is a synchronous failable constructor. See g_dbus_proxy_new() and
// g_dbus_proxy_new_finish() for the asynchronous version.
// 
// BusProxy is used in this [example][gdbus-wellknown-proxy].
	func NewDBusProXYSync(connection DBusConnectionClass, flags DBusProXYFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable CancellableClass) (DBusProXY, error) {
var _arg1 *C.GDBusConnection // out
var _arg2 C.GDBusProxyFlags // out
var _arg3 *C.GDBusInterfaceInfo // out
var _arg4 *C.gchar // out
var _arg5 *C.gchar // out
var _arg6 *C.gchar // out
var _arg7 *C.GCancellable // out
var _cret *C.GDBusProxy // in
var _cerr *C.GError // in

_arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
_arg2 = (C.GDBusProxyFlags)(flags)
_arg3 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(info.Native()))
_arg4 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.gchar)(C.CString(objectPath))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (*C.gchar)(C.CString(interfaceName))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_proxy_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)


var _dBusProxy DBusProXY // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusProxy = DBusProXY{
Object: &externglib.Object{externglib.ToGObject(obj)},
AsyncInitable: AsyncInitable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
DBusInterface: DBusInterface{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusProxy, _goerr
}
	

	
	// CallFinish finishes an operation started with g_dbus_proxy_call().
	func (p DBusProXY) CallFinish(res AsyncResult) (*glib.Variant, error) {
var _arg0 *C.GDBusProxy // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GVariant // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_proxy_call_finish(_arg0, _arg1, &_cerr)


var _variant *glib.Variant // out
var _goerr error // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _variant, _goerr
}
	
	// CallSync: synchronously invokes the @method_name method on @proxy.
// 
// If @method_name contains any dots, then @name is split into interface and
// method name parts. This allows using @proxy for invoking methods on other
// interfaces.
// 
// If the BusConnection associated with @proxy is disconnected then the
// operation will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled, the
// operation will fail with G_IO_ERROR_CANCELLED. If @parameters contains a
// value not compatible with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
// 
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
// 
//    g_dbus_proxy_call_sync (proxy,
//                            "TwoStrings",
//                            g_variant_new ("(ss)",
//                                           "Thing One",
//                                           "Thing Two"),
//                            G_DBUS_CALL_FLAGS_NONE,
//                            -1,
//                            NULL,
//                            &error);
// 
// The calling thread is blocked until a reply is received. See
// g_dbus_proxy_call() for the asynchronous version of this method.
// 
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @method_name is referenced by it, then the return value is checked against
// the return type.
	func (p DBusProXY) CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable CancellableClass) (*glib.Variant, error) {
var _arg0 *C.GDBusProxy // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out
var _arg3 C.GDBusCallFlags // out
var _arg4 C.gint // out
var _arg5 *C.GCancellable // out
var _cret *C.GVariant // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(methodName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
_arg3 = (C.GDBusCallFlags)(flags)
_arg4 = (C.gint)(timeoutMsec)
_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_proxy_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)


var _variant *glib.Variant // out
var _goerr error // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _variant, _goerr
}
	
	// CallWithUnixFdListFinish finishes an operation started with
// g_dbus_proxy_call_with_unix_fd_list().
	func (p DBusProXY) CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error) {
var _arg0 *C.GDBusProxy // out
var _arg1 *C.GUnixFDList // in
var _arg2 *C.GAsyncResult // out
var _cret *C.GVariant // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
_arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.g_dbus_proxy_call_with_unix_fd_list_finish(_arg0, &_arg1, _arg2, &_cerr)


var _outFdList UnixFDList // out
var _variant *glib.Variant // out
var _goerr error // out

_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1))).(UnixFDList)
_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _outFdList, _variant, _goerr
}
	
	// CallWithUnixFdListSync: like g_dbus_proxy_call_sync() but also takes and
// returns FDList objects.
// 
// This method is only available on UNIX.
	func (p DBusProXY) CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDListClass, cancellable CancellableClass) (UnixFDList, *glib.Variant, error) {
var _arg0 *C.GDBusProxy // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out
var _arg3 C.GDBusCallFlags // out
var _arg4 C.gint // out
var _arg5 *C.GUnixFDList // out
var _arg6 *C.GUnixFDList // in
var _arg7 *C.GCancellable // out
var _cret *C.GVariant // in
var _cerr *C.GError // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(methodName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
_arg3 = (C.GDBusCallFlags)(flags)
_arg4 = (C.gint)(timeoutMsec)
_arg5 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_proxy_call_with_unix_fd_list_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, _arg7, &_cerr)


var _outFdList UnixFDList // out
var _variant *glib.Variant // out
var _goerr error // out

_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg6))).(UnixFDList)
_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _outFdList, _variant, _goerr
}
	
	// CachedProperty looks up the value for a property from the cache. This call
// does no blocking IO.
// 
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @property_name is referenced by it, then @value is checked against the type
// of the property.
	func (p DBusProXY) CachedProperty(propertyName string) *glib.Variant {
var _arg0 *C.GDBusProxy // out
var _arg1 *C.gchar // out
var _cret *C.GVariant // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_proxy_get_cached_property(_arg0, _arg1)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// CachedPropertyNames gets the names of all cached properties on @proxy.
	func (p DBusProXY) CachedPropertyNames() []string {
var _arg0 *C.GDBusProxy // out
var _cret **C.gchar

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_proxy_get_cached_property_names(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// Connection gets the connection @proxy is for.
	func (p DBusProXY) Connection() DBusConnection {
var _arg0 *C.GDBusProxy // out
var _cret *C.GDBusConnection // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_proxy_get_connection(_arg0)


var _dBusConnection DBusConnection // out

_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

return _dBusConnection
}
	
	// DefaultTimeout gets the timeout to use if -1 (specifying default timeout) is
// passed as @timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
// 
// See the BusProxy:g-default-timeout property for more details.
	func (p DBusProXY) DefaultTimeout() int {
var _arg0 *C.GDBusProxy // out
var _cret C.gint // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_proxy_get_default_timeout(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Flags gets the flags that @proxy was constructed with.
	func (p DBusProXY) Flags() DBusProXYFlags {
var _arg0 *C.GDBusProxy // out
var _cret C.GDBusProxyFlags // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_proxy_get_flags(_arg0)


var _dBusProxyFlags DBusProXYFlags // out

_dBusProxyFlags = DBusProXYFlags(_cret)

return _dBusProxyFlags
}
	
	// InterfaceInfo returns the BusInterfaceInfo, if any, specifying the interface
// that @proxy conforms to. See the BusProxy:g-interface-info property for more
// details.
	func (p DBusProXY) InterfaceInfo() *DBusInterfaceInfo {
var _arg0 *C.GDBusProxy // out
var _cret *C.GDBusInterfaceInfo // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_proxy_get_interface_info(_arg0)


var _dBusInterfaceInfo *DBusInterfaceInfo // out

_dBusInterfaceInfo = *(**DBusInterfaceInfo)(unsafe.Pointer(&_cret))

return _dBusInterfaceInfo
}
	
	// InterfaceName gets the D-Bus interface name @proxy is for.
	func (p DBusProXY) InterfaceName() string {
var _arg0 *C.GDBusProxy // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_proxy_get_interface_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Name gets the name that @proxy was constructed for.
	func (p DBusProXY) Name() string {
var _arg0 *C.GDBusProxy // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_proxy_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NameOwner: the unique name that owns the name that @proxy is for or nil if
// no-one currently owns that name. You may connect to the #GObject::notify
// signal to track changes to the BusProxy:g-name-owner property.
	func (p DBusProXY) NameOwner() string {
var _arg0 *C.GDBusProxy // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_proxy_get_name_owner(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// ObjectPath gets the object path @proxy is for.
	func (p DBusProXY) ObjectPath() string {
var _arg0 *C.GDBusProxy // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

_cret = C.g_dbus_proxy_get_object_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetCachedProperty: if @value is not nil, sets the cached value for the
// property with name @property_name to the value in @value.
// 
// If @value is nil, then the cached value is removed from the property cache.
// 
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @property_name is referenced by it, then @value is checked against the type
// of the property.
// 
// If the @value #GVariant is floating, it is consumed. This allows convenient
// 'inline' use of g_variant_new(), e.g.
// 
//    g_dbus_proxy_set_cached_property (proxy,
//                                      "SomeProperty",
//                                      g_variant_new ("(si)",
//                                                    "A String",
//                                                    42));
// 
// Normally you will not need to use this method since @proxy is tracking
// changes using the `org.freedesktop.DBus.Properties.PropertiesChanged` D-Bus
// signal. However, for performance reasons an object may decide to not use this
// signal for some properties and instead use a proprietary out-of-band
// mechanism to transmit changes.
// 
// As a concrete example, consider an object with a property
// `ChatroomParticipants` which is an array of strings. Instead of transmitting
// the same (long) array every time the property changes, it is more efficient
// to only transmit the delta using e.g. signals
// `ChatroomParticipantJoined(String name)` and
// `ChatroomParticipantParted(String name)`.
	func (p DBusProXY) SetCachedProperty(propertyName string, value *glib.Variant)  {
var _arg0 *C.GDBusProxy // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

C.g_dbus_proxy_set_cached_property(_arg0, _arg1, _arg2)
}
	
	// SetDefaultTimeout sets the timeout to use if -1 (specifying default timeout)
// is passed as @timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
// 
// See the BusProxy:g-default-timeout property for more details.
	func (p DBusProXY) SetDefaultTimeout(timeoutMsec int)  {
var _arg0 *C.GDBusProxy // out
var _arg1 C.gint // out

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(timeoutMsec)

C.g_dbus_proxy_set_default_timeout(_arg0, _arg1)
}
	
	// SetInterfaceInfo: ensure that interactions with @proxy conform to the given
// interface. See the BusProxy:g-interface-info property for more details.
	func (p DBusProXY) SetInterfaceInfo(info *DBusInterfaceInfo)  {
var _arg0 *C.GDBusProxy // out
var _arg1 *C.GDBusInterfaceInfo // out

_arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(info.Native()))

C.g_dbus_proxy_set_interface_info(_arg0, _arg1)
}
	


	// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
// 
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
// 
// An example of peer-to-peer communication with GDBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
// 
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer. Since GLib 2.68 this can be achieved more simply by
// passing the G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the
// server.
	type DBusServer struct {
		**externglib.Object
		Initable
		
	}

	// DBusServerClass is an interface that the DBusServer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DBusServerClass interface {
		gextras.Objector
		_dBusServer()
	}

	func (DBusServer) _dBusServer() {}

	
	func marshalDBusServer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDBusServer(obj), nil
	}
	

	
	// NewDBusServerSync creates a new D-Bus server that listens on the first
// address in @address that works.
// 
// Once constructed, you can use g_dbus_server_get_client_address() to get a
// D-Bus address string that clients can use to connect.
// 
// To have control over the available authentication mechanisms and the users
// that are authorized to connect, it is strongly recommended to provide a
// non-nil BusAuthObserver.
// 
// Connect to the BusServer::new-connection signal to handle incoming
// connections.
// 
// The returned BusServer isn't active - you have to start it with
// g_dbus_server_start().
// 
// BusServer is used in this [example][gdbus-peer-to-peer].
// 
// This is a synchronous failable constructor. There is currently no
// asynchronous version.
	func NewDBusServerSync(address string, flags DBusServerFlags, guid string, observer DBusAuthObserverClass, cancellable CancellableClass) (DBusServer, error) {
var _arg1 *C.gchar // out
var _arg2 C.GDBusServerFlags // out
var _arg3 *C.gchar // out
var _arg4 *C.GDBusAuthObserver // out
var _arg5 *C.GCancellable // out
var _cret *C.GDBusServer // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(address))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GDBusServerFlags)(flags)
_arg3 = (*C.gchar)(C.CString(guid))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_dbus_server_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)


var _dBusServer DBusServer // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dBusServer = DBusServer{
Object: &externglib.Object{externglib.ToGObject(obj)},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusServer, _goerr
}
	

	
	// ClientAddress gets a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses) string
// that can be used by clients to connect to @server.
	func (s DBusServer) ClientAddress() string {
var _arg0 *C.GDBusServer // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

_cret = C.g_dbus_server_get_client_address(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Flags gets the flags for @server.
	func (s DBusServer) Flags() DBusServerFlags {
var _arg0 *C.GDBusServer // out
var _cret C.GDBusServerFlags // in

_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

_cret = C.g_dbus_server_get_flags(_arg0)


var _dBusServerFlags DBusServerFlags // out

_dBusServerFlags = DBusServerFlags(_cret)

return _dBusServerFlags
}
	
	// Guid gets the GUID for @server.
	func (s DBusServer) Guid() string {
var _arg0 *C.GDBusServer // out
var _cret *C.gchar // in

_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

_cret = C.g_dbus_server_get_guid(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IsActive gets whether @server is active.
	func (s DBusServer) IsActive() bool {
var _arg0 *C.GDBusServer // out
var _cret C.gboolean // in

_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

_cret = C.g_dbus_server_is_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Start starts @server.
	func (s DBusServer) Start()  {
var _arg0 *C.GDBusServer // out

_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

C.g_dbus_server_start(_arg0)
}
	
	// Stop stops @server.
	func (s DBusServer) Stop()  {
var _arg0 *C.GDBusServer // out

_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

C.g_dbus_server_stop(_arg0)
}
	


	// DataInputStream: data input stream implements Stream and includes functions
// for reading structured data directly from a binary input stream.
	type DataInputStream struct {
		BufferedInputStream
		Seekable
		
	}

	// DataInputStreamClass is an interface that the DataInputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DataInputStreamClass interface {
		gextras.Objector
		_dataInputStream()
	}

	func (DataInputStream) _dataInputStream() {}

	
	func marshalDataInputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDataInputStream(obj), nil
	}
	

	
	// NewDataInputStream creates a new data input stream for the @base_stream.
	func NewDataInputStream(baseStream InputStreamClass) DataInputStream {
var _arg1 *C.GInputStream // out
var _cret *C.GDataInputStream // in

_arg1 = (*C.GInputStream)(unsafe.Pointer(baseStream.Native()))

_cret = C.g_data_input_stream_new(_arg1)


var _dataInputStream DataInputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dataInputStream = DataInputStream{
BufferedInputStream: BufferedInputStream{
FilterInputStream: FilterInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Seekable: Seekable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Seekable: Seekable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dataInputStream
}
	

	
	// ByteOrder gets the byte order for the data input stream.
	func (s DataInputStream) ByteOrder() DataStreamByteOrder {
var _arg0 *C.GDataInputStream // out
var _cret C.GDataStreamByteOrder // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_data_input_stream_get_byte_order(_arg0)


var _dataStreamByteOrder DataStreamByteOrder // out

_dataStreamByteOrder = DataStreamByteOrder(_cret)

return _dataStreamByteOrder
}
	
	// NewlineType gets the current newline type for the @stream.
	func (s DataInputStream) NewlineType() DataStreamNewlineType {
var _arg0 *C.GDataInputStream // out
var _cret C.GDataStreamNewlineType // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_data_input_stream_get_newline_type(_arg0)


var _dataStreamNewlineType DataStreamNewlineType // out

_dataStreamNewlineType = DataStreamNewlineType(_cret)

return _dataStreamNewlineType
}
	
	// ReadByte reads an unsigned 8-bit/1-byte value from @stream.
	func (s DataInputStream) ReadByte(cancellable CancellableClass) (byte, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GCancellable // out
var _cret C.guchar // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_byte(_arg0, _arg1, &_cerr)


var _guint8 byte // out
var _goerr error // out

_guint8 = (byte)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint8, _goerr
}
	
	// ReadInt16 reads a 16-bit/2-byte value from @stream.
// 
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
	func (s DataInputStream) ReadInt16(cancellable CancellableClass) (int16, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GCancellable // out
var _cret C.gint16 // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_int16(_arg0, _arg1, &_cerr)


var _gint16 int16 // out
var _goerr error // out

_gint16 = (int16)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint16, _goerr
}
	
	// ReadInt32 reads a signed 32-bit/4-byte value from @stream.
// 
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (s DataInputStream) ReadInt32(cancellable CancellableClass) (int32, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GCancellable // out
var _cret C.gint32 // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_int32(_arg0, _arg1, &_cerr)


var _gint32 int32 // out
var _goerr error // out

_gint32 = (int32)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint32, _goerr
}
	
	// ReadInt64 reads a 64-bit/8-byte value from @stream.
// 
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (s DataInputStream) ReadInt64(cancellable CancellableClass) (int64, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GCancellable // out
var _cret C.gint64 // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_int64(_arg0, _arg1, &_cerr)


var _gint64 int64 // out
var _goerr error // out

_gint64 = (int64)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint64, _goerr
}
	
	// ReadLine reads a line from the data input stream. Note that no encoding
// checks or conversion is performed; the input is not guaranteed to be UTF-8,
// and may in fact have embedded NUL characters.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (s DataInputStream) ReadLine(cancellable CancellableClass) (uint, []byte, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 C.gsize // in
var _arg2 *C.GCancellable // out
var _cret *C.char
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_line(_arg0, &_arg1, _arg2, &_cerr)


var _length uint // out
var _guint8s []byte
var _goerr error // out

_length = (uint)(_arg1)
{
var i int
var z C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_guint8s = make([]byte, i)
for i := range src {
_guint8s[i] = (byte)(src[i])
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _length, _guint8s, _goerr
}
	
	// ReadLineFinish: finish an asynchronous call started by
// g_data_input_stream_read_line_async(). Note the warning about string encoding
// in g_data_input_stream_read_line() applies here as well.
	func (s DataInputStream) ReadLineFinish(result AsyncResult) (uint, []byte, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gsize // in
var _cret *C.char
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_data_input_stream_read_line_finish(_arg0, _arg1, &_arg2, &_cerr)


var _length uint // out
var _guint8s []byte
var _goerr error // out

_length = (uint)(_arg2)
{
var i int
var z C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_guint8s = make([]byte, i)
for i := range src {
_guint8s[i] = (byte)(src[i])
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _length, _guint8s, _goerr
}
	
	// ReadLineFinishUTF8: finish an asynchronous call started by
// g_data_input_stream_read_line_async().
	func (s DataInputStream) ReadLineFinishUTF8(result AsyncResult) (uint, string, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gsize // in
var _cret *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_data_input_stream_read_line_finish_utf8(_arg0, _arg1, &_arg2, &_cerr)


var _length uint // out
var _utf8 string // out
var _goerr error // out

_length = (uint)(_arg2)
_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _length, _utf8, _goerr
}
	
	// ReadLineUTF8 reads a UTF-8 encoded line from the data input stream.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (s DataInputStream) ReadLineUTF8(cancellable CancellableClass) (uint, string, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 C.gsize // in
var _arg2 *C.GCancellable // out
var _cret *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_line_utf8(_arg0, &_arg1, _arg2, &_cerr)


var _length uint // out
var _utf8 string // out
var _goerr error // out

_length = (uint)(_arg1)
_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _length, _utf8, _goerr
}
	
	// ReadUint16 reads an unsigned 16-bit/2-byte value from @stream.
// 
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
	func (s DataInputStream) ReadUint16(cancellable CancellableClass) (uint16, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GCancellable // out
var _cret C.guint16 // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_uint16(_arg0, _arg1, &_cerr)


var _guint16 uint16 // out
var _goerr error // out

_guint16 = (uint16)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint16, _goerr
}
	
	// ReadUint32 reads an unsigned 32-bit/4-byte value from @stream.
// 
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (s DataInputStream) ReadUint32(cancellable CancellableClass) (uint32, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GCancellable // out
var _cret C.guint32 // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_uint32(_arg0, _arg1, &_cerr)


var _guint32 uint32 // out
var _goerr error // out

_guint32 = (uint32)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint32, _goerr
}
	
	// ReadUint64 reads an unsigned 64-bit/8-byte value from @stream.
// 
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order().
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (s DataInputStream) ReadUint64(cancellable CancellableClass) (uint64, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GCancellable // out
var _cret C.guint64 // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_uint64(_arg0, _arg1, &_cerr)


var _guint64 uint64 // out
var _goerr error // out

_guint64 = (uint64)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint64, _goerr
}
	
	// ReadUntil reads a string from the data input stream, up to the first
// occurrence of any of the stop characters.
// 
// Note that, in contrast to g_data_input_stream_read_until_async(), this
// function consumes the stop character that it finds.
// 
// Don't use this function in new code. Its functionality is inconsistent with
// g_data_input_stream_read_until_async(). Both functions will be marked as
// deprecated in a future release. Use g_data_input_stream_read_upto() instead,
// but note that that function does not consume the stop character.
	func (s DataInputStream) ReadUntil(stopChars string, cancellable CancellableClass) (uint, string, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.gchar // out
var _arg2 C.gsize // in
var _arg3 *C.GCancellable // out
var _cret *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(stopChars))
defer C.free(unsafe.Pointer(_arg1))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_until(_arg0, _arg1, &_arg2, _arg3, &_cerr)


var _length uint // out
var _utf8 string // out
var _goerr error // out

_length = (uint)(_arg2)
_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _length, _utf8, _goerr
}
	
	// ReadUntilFinish: finish an asynchronous call started by
// g_data_input_stream_read_until_async().
	func (s DataInputStream) ReadUntilFinish(result AsyncResult) (uint, string, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gsize // in
var _cret *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_data_input_stream_read_until_finish(_arg0, _arg1, &_arg2, &_cerr)


var _length uint // out
var _utf8 string // out
var _goerr error // out

_length = (uint)(_arg2)
_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _length, _utf8, _goerr
}
	
	// ReadUpto reads a string from the data input stream, up to the first
// occurrence of any of the stop characters.
// 
// In contrast to g_data_input_stream_read_until(), this function does not
// consume the stop character. You have to use g_data_input_stream_read_byte()
// to get it before calling g_data_input_stream_read_upto() again.
// 
// Note that @stop_chars may contain '\0' if @stop_chars_len is specified.
// 
// The returned string will always be nul-terminated on success.
	func (s DataInputStream) ReadUpto(stopChars string, stopCharsLen int, cancellable CancellableClass) (uint, string, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.gchar // out
var _arg2 C.gssize // out
var _arg3 C.gsize // in
var _arg4 *C.GCancellable // out
var _cret *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(stopChars))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gssize)(stopCharsLen)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_data_input_stream_read_upto(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)


var _length uint // out
var _utf8 string // out
var _goerr error // out

_length = (uint)(_arg3)
_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _length, _utf8, _goerr
}
	
	// ReadUptoFinish: finish an asynchronous call started by
// g_data_input_stream_read_upto_async().
// 
// Note that this function does not consume the stop character. You have to use
// g_data_input_stream_read_byte() to get it before calling
// g_data_input_stream_read_upto_async() again.
// 
// The returned string will always be nul-terminated on success.
	func (s DataInputStream) ReadUptoFinish(result AsyncResult) (uint, string, error) {
var _arg0 *C.GDataInputStream // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gsize // in
var _cret *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_data_input_stream_read_upto_finish(_arg0, _arg1, &_arg2, &_cerr)


var _length uint // out
var _utf8 string // out
var _goerr error // out

_length = (uint)(_arg2)
_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _length, _utf8, _goerr
}
	
	// SetByteOrder: this function sets the byte order for the given @stream. All
// subsequent reads from the @stream will be read in the given @order.
	func (s DataInputStream) SetByteOrder(order DataStreamByteOrder)  {
var _arg0 *C.GDataInputStream // out
var _arg1 C.GDataStreamByteOrder // out

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.GDataStreamByteOrder)(order)

C.g_data_input_stream_set_byte_order(_arg0, _arg1)
}
	
	// SetNewlineType sets the newline type for the @stream.
// 
// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
// chunk ends in "CR" we must read an additional byte to know if this is "CR" or
// "CR LF", and this might block if there is no more data available.
	func (s DataInputStream) SetNewlineType(typ DataStreamNewlineType)  {
var _arg0 *C.GDataInputStream // out
var _arg1 C.GDataStreamNewlineType // out

_arg0 = (*C.GDataInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.GDataStreamNewlineType)(typ)

C.g_data_input_stream_set_newline_type(_arg0, _arg1)
}
	


	// DataOutputStream: data output stream implements Stream and includes functions
// for writing data directly to an output stream.
	type DataOutputStream struct {
		FilterOutputStream
		Seekable
		
	}

	// DataOutputStreamClass is an interface that the DataOutputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DataOutputStreamClass interface {
		gextras.Objector
		_dataOutputStream()
	}

	func (DataOutputStream) _dataOutputStream() {}

	
	func marshalDataOutputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDataOutputStream(obj), nil
	}
	

	
	// NewDataOutputStream creates a new data output stream for @base_stream.
	func NewDataOutputStream(baseStream OutputStreamClass) DataOutputStream {
var _arg1 *C.GOutputStream // out
var _cret *C.GDataOutputStream // in

_arg1 = (*C.GOutputStream)(unsafe.Pointer(baseStream.Native()))

_cret = C.g_data_output_stream_new(_arg1)


var _dataOutputStream DataOutputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dataOutputStream = DataOutputStream{
FilterOutputStream: FilterOutputStream{
OutputStream: OutputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Seekable: Seekable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dataOutputStream
}
	

	
	// ByteOrder gets the byte order for the stream.
	func (s DataOutputStream) ByteOrder() DataStreamByteOrder {
var _arg0 *C.GDataOutputStream // out
var _cret C.GDataStreamByteOrder // in

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_data_output_stream_get_byte_order(_arg0)


var _dataStreamByteOrder DataStreamByteOrder // out

_dataStreamByteOrder = DataStreamByteOrder(_cret)

return _dataStreamByteOrder
}
	
	// PutByte puts a byte into the output stream.
	func (s DataOutputStream) PutByte(data byte, cancellable CancellableClass) error {
var _arg0 *C.GDataOutputStream // out
var _arg1 C.guchar // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.guchar)(data)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_data_output_stream_put_byte(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PutInt16 puts a signed 16-bit integer into the output stream.
	func (s DataOutputStream) PutInt16(data int16, cancellable CancellableClass) error {
var _arg0 *C.GDataOutputStream // out
var _arg1 C.gint16 // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint16)(data)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_data_output_stream_put_int16(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PutInt32 puts a signed 32-bit integer into the output stream.
	func (s DataOutputStream) PutInt32(data int32, cancellable CancellableClass) error {
var _arg0 *C.GDataOutputStream // out
var _arg1 C.gint32 // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint32)(data)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_data_output_stream_put_int32(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PutInt64 puts a signed 64-bit integer into the stream.
	func (s DataOutputStream) PutInt64(data int64, cancellable CancellableClass) error {
var _arg0 *C.GDataOutputStream // out
var _arg1 C.gint64 // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint64)(data)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_data_output_stream_put_int64(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PutString puts a string into the output stream.
	func (s DataOutputStream) PutString(str string, cancellable CancellableClass) error {
var _arg0 *C.GDataOutputStream // out
var _arg1 *C.char // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_data_output_stream_put_string(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PutUint16 puts an unsigned 16-bit integer into the output stream.
	func (s DataOutputStream) PutUint16(data uint16, cancellable CancellableClass) error {
var _arg0 *C.GDataOutputStream // out
var _arg1 C.guint16 // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint16)(data)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_data_output_stream_put_uint16(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PutUint32 puts an unsigned 32-bit integer into the stream.
	func (s DataOutputStream) PutUint32(data uint32, cancellable CancellableClass) error {
var _arg0 *C.GDataOutputStream // out
var _arg1 C.guint32 // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint32)(data)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_data_output_stream_put_uint32(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PutUint64 puts an unsigned 64-bit integer into the stream.
	func (s DataOutputStream) PutUint64(data uint64, cancellable CancellableClass) error {
var _arg0 *C.GDataOutputStream // out
var _arg1 C.guint64 // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint64)(data)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_data_output_stream_put_uint64(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetByteOrder sets the byte order of the data output stream to @order.
	func (s DataOutputStream) SetByteOrder(order DataStreamByteOrder)  {
var _arg0 *C.GDataOutputStream // out
var _arg1 C.GDataStreamByteOrder // out

_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.GDataStreamByteOrder)(order)

C.g_data_output_stream_set_byte_order(_arg0, _arg1)
}
	


	// DesktopAppInfo is an implementation of Info based on desktop files.
// 
// Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
	type DesktopAppInfo struct {
		**externglib.Object
		AppInfo
		
	}

	// DesktopAppInfoClass is an interface that the DesktopAppInfo class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DesktopAppInfoClass interface {
		gextras.Objector
		_desktopAppInfo()
	}

	func (DesktopAppInfo) _desktopAppInfo() {}

	
	func marshalDesktopAppInfo(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDesktopAppInfo(obj), nil
	}
	

	
	// NewDesktopAppInfo creates a new AppInfo based on a desktop file id.
// 
// A desktop file id is the basename of the desktop file, including the .desktop
// extension. GIO is looking for a desktop file with this name in the
// `applications` subdirectories of the XDG data directories (i.e. the
// directories specified in the `XDG_DATA_HOME` and `XDG_DATA_DIRS` environment
// variables). GIO also supports the prefix-to-subdirectory mapping that is
// described in the Menu Spec
// (http://standards.freedesktop.org/menu-spec/latest/) (i.e. a desktop id of
// kde-foo.desktop will match `/usr/share/applications/kde/foo.desktop`).
	func NewDesktopAppInfo(desktopId string) DesktopAppInfo {
var _arg1 *C.char // out
var _cret *C.GDesktopAppInfo // in

_arg1 = (*C.char)(C.CString(desktopId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_desktop_app_info_new(_arg1)


var _desktopAppInfo DesktopAppInfo // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_desktopAppInfo = DesktopAppInfo{
Object: &externglib.Object{externglib.ToGObject(obj)},
AppInfo: AppInfo{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _desktopAppInfo
}
	
	// NewDesktopAppInfoFromFilename creates a new AppInfo.
	func NewDesktopAppInfoFromFilename(filename string) DesktopAppInfo {
var _arg1 *C.char // out
var _cret *C.GDesktopAppInfo // in

_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_desktop_app_info_new_from_filename(_arg1)


var _desktopAppInfo DesktopAppInfo // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_desktopAppInfo = DesktopAppInfo{
Object: &externglib.Object{externglib.ToGObject(obj)},
AppInfo: AppInfo{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _desktopAppInfo
}
	
	// NewDesktopAppInfoFromKeyfile creates a new AppInfo.
	func NewDesktopAppInfoFromKeyfile(keyFile *glib.KeyFile) DesktopAppInfo {
var _arg1 *C.GKeyFile // out
var _cret *C.GDesktopAppInfo // in

_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))

_cret = C.g_desktop_app_info_new_from_keyfile(_arg1)


var _desktopAppInfo DesktopAppInfo // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_desktopAppInfo = DesktopAppInfo{
Object: &externglib.Object{externglib.ToGObject(obj)},
AppInfo: AppInfo{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _desktopAppInfo
}
	

	
	// ActionName gets the user-visible display name of the "additional application
// action" specified by @action_name.
// 
// This corresponds to the "Name" key within the keyfile group for the action.
	func (i DesktopAppInfo) ActionName(actionName string) string {
var _arg0 *C.GDesktopAppInfo // out
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_desktop_app_info_get_action_name(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Boolean looks up a boolean value in the keyfile backing @info.
// 
// The @key is looked up in the "Desktop Entry" group.
	func (i DesktopAppInfo) Boolean(key string) bool {
var _arg0 *C.GDesktopAppInfo // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_desktop_app_info_get_boolean(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Categories gets the categories from the desktop file.
	func (i DesktopAppInfo) Categories() string {
var _arg0 *C.GDesktopAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_desktop_app_info_get_categories(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Filename: when @info was created from a known filename, return it. In some
// situations such as the AppInfo returned from
// g_desktop_app_info_new_from_keyfile(), this function will return nil.
	func (i DesktopAppInfo) Filename() string {
var _arg0 *C.GDesktopAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_desktop_app_info_get_filename(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// GenericName gets the generic name from the desktop file.
	func (i DesktopAppInfo) GenericName() string {
var _arg0 *C.GDesktopAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_desktop_app_info_get_generic_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IsHidden: a desktop file is hidden if the Hidden key in it is set to True.
	func (i DesktopAppInfo) IsHidden() bool {
var _arg0 *C.GDesktopAppInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_desktop_app_info_get_is_hidden(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Keywords gets the keywords from the desktop file.
	func (i DesktopAppInfo) Keywords() []string {
var _arg0 *C.GDesktopAppInfo // out
var _cret **C.char

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_desktop_app_info_get_keywords(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// LocaleString looks up a localized string value in the keyfile backing @info
// translated to the current locale.
// 
// The @key is looked up in the "Desktop Entry" group.
	func (i DesktopAppInfo) LocaleString(key string) string {
var _arg0 *C.GDesktopAppInfo // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_desktop_app_info_get_locale_string(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Nodisplay gets the value of the NoDisplay key, which helps determine if the
// application info should be shown in menus. See
// KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().
	func (i DesktopAppInfo) Nodisplay() bool {
var _arg0 *C.GDesktopAppInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_desktop_app_info_get_nodisplay(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowIn checks if the application info should be shown in menus that list
// available applications for a specific name of the desktop, based on the
// `OnlyShowIn` and `NotShowIn` keys.
// 
// @desktop_env should typically be given as nil, in which case the
// `XDG_CURRENT_DESKTOP` environment variable is consulted. If you want to
// override the default mechanism then you may specify @desktop_env, but this is
// not recommended.
// 
// Note that g_app_info_should_show() for @info will include this check (with
// nil for @desktop_env) as well as additional checks.
	func (i DesktopAppInfo) ShowIn(desktopEnv string) bool {
var _arg0 *C.GDesktopAppInfo // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(desktopEnv))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_desktop_app_info_get_show_in(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// StartupWmClass retrieves the StartupWMClass field from @info. This represents
// the WM_CLASS property of the main window of the application, if launched
// through @info.
	func (i DesktopAppInfo) StartupWmClass() string {
var _arg0 *C.GDesktopAppInfo // out
var _cret *C.char // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_desktop_app_info_get_startup_wm_class(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// String looks up a string value in the keyfile backing @info.
// 
// The @key is looked up in the "Desktop Entry" group.
	func (i DesktopAppInfo) String(key string) string {
var _arg0 *C.GDesktopAppInfo // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_desktop_app_info_get_string(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// HasKey returns whether @key exists in the "Desktop Entry" group of the
// keyfile backing @info.
	func (i DesktopAppInfo) HasKey(key string) bool {
var _arg0 *C.GDesktopAppInfo // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_desktop_app_info_has_key(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LaunchAction activates the named application action.
// 
// You may only call this function on action names that were returned from
// g_desktop_app_info_list_actions().
// 
// Note that if the main entry of the desktop file indicates that the
// application supports startup notification, and @launch_context is non-nil,
// then startup notification will be used when activating the action (and as
// such, invocation of the action on the receiving side must signal the end of
// startup notification when it is completed). This is the expected behaviour of
// applications declaring additional actions, as per the desktop file
// specification.
// 
// As with g_app_info_launch() there is no way to detect failures that occur
// while using this function.
	func (i DesktopAppInfo) LaunchAction(actionName string, launchContext AppLaunchContextClass)  {
var _arg0 *C.GDesktopAppInfo // out
var _arg1 *C.gchar // out
var _arg2 *C.GAppLaunchContext // out

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(launchContext.Native()))

C.g_desktop_app_info_launch_action(_arg0, _arg1, _arg2)
}
	
	// ListActions returns the list of "additional application actions" supported on
// the desktop file, as per the desktop file specification.
// 
// As per the specification, this is the list of actions that are explicitly
// listed in the "Actions" key of the [Desktop Entry] group.
	func (i DesktopAppInfo) ListActions() []string {
var _arg0 *C.GDesktopAppInfo // out
var _cret **C.gchar

_arg0 = (*C.GDesktopAppInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_desktop_app_info_list_actions(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	


	// Emblem is an implementation of #GIcon that supports having an emblem, which
// is an icon with additional properties. It can than be added to a Icon.
// 
// Currently, only metainformation about the emblem's origin is supported. More
// may be added in the future.
	type Emblem struct {
		**externglib.Object
		Icon
		
	}

	// EmblemClass is an interface that the Emblem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EmblemClass interface {
		gextras.Objector
		_emblem()
	}

	func (Emblem) _emblem() {}

	
	func marshalEmblem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEmblem(obj), nil
	}
	

	
	// NewEmblem creates a new emblem for @icon.
	func NewEmblem(icon Icon) Emblem {
var _arg1 *C.GIcon // out
var _cret *C.GEmblem // in

_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

_cret = C.g_emblem_new(_arg1)


var _emblem Emblem // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_emblem = Emblem{
Object: &externglib.Object{externglib.ToGObject(obj)},
Icon: Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _emblem
}
	
	// NewEmblemWithOrigin creates a new emblem for @icon.
	func NewEmblemWithOrigin(icon Icon, origin EmblemOrigin) Emblem {
var _arg1 *C.GIcon // out
var _arg2 C.GEmblemOrigin // out
var _cret *C.GEmblem // in

_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
_arg2 = (C.GEmblemOrigin)(origin)

_cret = C.g_emblem_new_with_origin(_arg1, _arg2)


var _emblem Emblem // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_emblem = Emblem{
Object: &externglib.Object{externglib.ToGObject(obj)},
Icon: Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _emblem
}
	

	
	// GetIcon gives back the icon from @emblem.
	func (e Emblem) GetIcon() Icon {
var _arg0 *C.GEmblem // out
var _cret *C.GIcon // in

_arg0 = (*C.GEmblem)(unsafe.Pointer(e.Native()))

_cret = C.g_emblem_get_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// Origin gets the origin of the emblem.
	func (e Emblem) Origin() EmblemOrigin {
var _arg0 *C.GEmblem // out
var _cret C.GEmblemOrigin // in

_arg0 = (*C.GEmblem)(unsafe.Pointer(e.Native()))

_cret = C.g_emblem_get_origin(_arg0)


var _emblemOrigin EmblemOrigin // out

_emblemOrigin = EmblemOrigin(_cret)

return _emblemOrigin
}
	


	// EmblemedIcon is an implementation of #GIcon that supports adding an emblem to
// an icon. Adding multiple emblems to an icon is ensured via
// g_emblemed_icon_add_emblem().
// 
// Note that Icon allows no control over the position of the emblems. See also
// #GEmblem for more information.
	type EmblemedIcon struct {
		**externglib.Object
		Icon
		
	}

	// EmblemedIconClass is an interface that the EmblemedIcon class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EmblemedIconClass interface {
		gextras.Objector
		_emblemedIcon()
	}

	func (EmblemedIcon) _emblemedIcon() {}

	
	func marshalEmblemedIcon(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEmblemedIcon(obj), nil
	}
	

	
	// NewEmblemedIcon creates a new emblemed icon for @icon with the emblem
// @emblem.
	func NewEmblemedIcon(icon Icon, emblem EmblemClass) EmblemedIcon {
var _arg1 *C.GIcon // out
var _arg2 *C.GEmblem // out
var _cret *C.GIcon // in

_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
_arg2 = (*C.GEmblem)(unsafe.Pointer(emblem.Native()))

_cret = C.g_emblemed_icon_new(_arg1, _arg2)


var _emblemedIcon EmblemedIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_emblemedIcon = EmblemedIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
Icon: Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _emblemedIcon
}
	

	
	// AddEmblem adds @emblem to the #GList of #GEmblems.
	func (e EmblemedIcon) AddEmblem(emblem EmblemClass)  {
var _arg0 *C.GEmblemedIcon // out
var _arg1 *C.GEmblem // out

_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GEmblem)(unsafe.Pointer(emblem.Native()))

C.g_emblemed_icon_add_emblem(_arg0, _arg1)
}
	
	// ClearEmblems removes all the emblems from @icon.
	func (e EmblemedIcon) ClearEmblems()  {
var _arg0 *C.GEmblemedIcon // out

_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(e.Native()))

C.g_emblemed_icon_clear_emblems(_arg0)
}
	
	// GetIcon gets the main icon for @emblemed.
	func (e EmblemedIcon) GetIcon() Icon {
var _arg0 *C.GEmblemedIcon // out
var _cret *C.GIcon // in

_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(e.Native()))

_cret = C.g_emblemed_icon_get_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	


	// FileEnumerator allows you to operate on a set of #GFiles, returning a Info
// structure for each file enumerated (e.g. g_file_enumerate_children() will
// return a Enumerator for each of the children within a directory).
// 
// To get the next file's information from a Enumerator, use
// g_file_enumerator_next_file() or its asynchronous version,
// g_file_enumerator_next_files_async(). Note that the asynchronous version will
// return a list of Infos, whereas the synchronous will only return the next
// file in the enumerator.
// 
// The ordering of returned files is unspecified for non-Unix platforms; for
// more information, see g_dir_read_name(). On Unix, when operating on local
// files, returned files will be sorted by inode number. Effectively you can
// assume that the ordering of returned files will be stable between successive
// calls (and applications) assuming the directory is unchanged.
// 
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your application code.
// 
// To close a Enumerator, use g_file_enumerator_close(), or its asynchronous
// version, g_file_enumerator_close_async(). Once a Enumerator is closed, no
// further actions may be performed on it, and it should be freed with
// g_object_unref().
	type FileEnumerator struct {
		**externglib.Object
		
	}

	// FileEnumeratorClass is an interface that the FileEnumerator class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileEnumeratorClass interface {
		gextras.Objector
		_fileEnumerator()
	}

	func (FileEnumerator) _fileEnumerator() {}

	
	func marshalFileEnumerator(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileEnumerator(obj), nil
	}
	

	

	
	// Close releases all resources used by this enumerator, making the enumerator
// return G_IO_ERROR_CLOSED on all calls.
// 
// This will be automatically called when the last reference is dropped, but you
// might want to call this function to make sure resources are released as early
// as possible.
	func (e FileEnumerator) Close(cancellable CancellableClass) error {
var _arg0 *C.GFileEnumerator // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_enumerator_close(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CloseFinish finishes closing a file enumerator, started from
// g_file_enumerator_close_async().
// 
// If the file enumerator was already closed when
// g_file_enumerator_close_async() was called, then this function will report
// G_IO_ERROR_CLOSED in @error, and return false. If the file enumerator had
// pending operation when the close operation was started, then this function
// will report G_IO_ERROR_PENDING, and return false. If @cancellable was not
// nil, then the operation may have been cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// G_IO_ERROR_CANCELLED will be set, and false will be returned.
	func (e FileEnumerator) CloseFinish(result AsyncResult) error {
var _arg0 *C.GFileEnumerator // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_file_enumerator_close_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Child: return a new #GFile which refers to the file named by @info in the
// source directory of @enumerator. This function is primarily intended to be
// used inside loops with g_file_enumerator_next_file().
// 
// This is a convenience method that's equivalent to:
// 
//    gchar *name = g_file_info_get_name (info);
//    GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
//                                     name);
	func (e FileEnumerator) Child(info FileInfoClass) File {
var _arg0 *C.GFileEnumerator // out
var _arg1 *C.GFileInfo // out
var _cret *C.GFile // in

_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GFileInfo)(unsafe.Pointer(info.Native()))

_cret = C.g_file_enumerator_get_child(_arg0, _arg1)


var _file File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _file
}
	
	// Container: get the #GFile container which is being enumerated.
	func (e FileEnumerator) Container() File {
var _arg0 *C.GFileEnumerator // out
var _cret *C.GFile // in

_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))

_cret = C.g_file_enumerator_get_container(_arg0)


var _file File // out

_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(File)

return _file
}
	
	// HasPending checks if the file enumerator has pending operations.
	func (e FileEnumerator) HasPending() bool {
var _arg0 *C.GFileEnumerator // out
var _cret C.gboolean // in

_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))

_cret = C.g_file_enumerator_has_pending(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsClosed checks if the file enumerator has been closed.
	func (e FileEnumerator) IsClosed() bool {
var _arg0 *C.GFileEnumerator // out
var _cret C.gboolean // in

_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))

_cret = C.g_file_enumerator_is_closed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Iterate: this is a version of g_file_enumerator_next_file() that's easier to
// use correctly from C programs. With g_file_enumerator_next_file(), the
// gboolean return value signifies "end of iteration or error", which requires
// allocation of a temporary #GError.
// 
// In contrast, with this function, a false return from
// g_file_enumerator_iterate() *always* means "error". End of iteration is
// signaled by @out_info or @out_child being nil.
// 
// Another crucial difference is that the references for @out_info and
// @out_child are owned by @direnum (they are cached as hidden properties). You
// must not unref them in your own code. This makes memory management
// significantly easier for C code in combination with loops.
// 
// Finally, this function optionally allows retrieving a #GFile as well.
// 
// You must specify at least one of @out_info or @out_child.
// 
// The code pattern for correctly using g_file_enumerator_iterate() from C is:
// 
//    direnum = g_file_enumerate_children (file, ...);
//    while (TRUE)
//      {
//        GFileInfo *info;
//        if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
//          goto out;
//        if (!info)
//          break;
//        ... do stuff with "info"; do not unref it! ...
//      }
// 
//    out:
//      g_object_unref (direnum); // Note: frees the last @info
	func (d FileEnumerator) Iterate(cancellable CancellableClass) (FileInfo, File, error) {
var _arg0 *C.GFileEnumerator // out
var _arg1 *C.GFileInfo // in
var _arg2 *C.GFile // in
var _arg3 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(d.Native()))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_file_enumerator_iterate(_arg0, &_arg1, &_arg2, _arg3, &_cerr)

var _outInfo FileInfo // out
var _outChild File // out
var _goerr error // out

_outInfo = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(FileInfo)
_outChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(File)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _outInfo, _outChild, _goerr
}
	
	// NextFile returns information for the next file in the enumerated object. Will
// block until the information is available. The Info returned from this
// function will contain attributes that match the attribute string that was
// passed when the Enumerator was created.
// 
// See the documentation of Enumerator for information about the order of
// returned files.
// 
// On error, returns nil and sets @error to the error. If the enumerator is at
// the end, nil will be returned and @error will be unset.
	func (e FileEnumerator) NextFile(cancellable CancellableClass) (FileInfo, error) {
var _arg0 *C.GFileEnumerator // out
var _arg1 *C.GCancellable // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_enumerator_next_file(_arg0, _arg1, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	
	// SetPending sets the file enumerator as having pending operations.
	func (e FileEnumerator) SetPending(pending bool)  {
var _arg0 *C.GFileEnumerator // out
var _arg1 C.gboolean // out

_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(e.Native()))
if pending { _arg1 = C.TRUE }

C.g_file_enumerator_set_pending(_arg0, _arg1)
}
	


	// FileIOStream: GFileIOStream provides io streams that both read and write to
// the same file handle.
// 
// GFileIOStream implements #GSeekable, which allows the io stream to jump to
// arbitrary positions in the file and to truncate the file, provided the
// filesystem of the file supports these operations.
// 
// To find the position of a file io stream, use g_seekable_tell().
// 
// To find out if a file io stream supports seeking, use g_seekable_can_seek().
// To position a file io stream, use g_seekable_seek(). To find out if a file io
// stream supports truncating, use g_seekable_can_truncate(). To truncate a file
// io stream, use g_seekable_truncate().
// 
// The default implementation of all the IOStream operations and the
// implementation of #GSeekable just call into the same operations on the output
// stream.
	type FileIOStream struct {
		IOStream
		Seekable
		
	}

	// FileIOStreamClass is an interface that the FileIOStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileIOStreamClass interface {
		gextras.Objector
		_fileIOStream()
	}

	func (FileIOStream) _fileIOStream() {}

	
	func marshalFileIOStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileIOStream(obj), nil
	}
	

	

	
	// Etag gets the entity tag for the file when it has been written. This must be
// called after the stream has been written and closed, as the etag can change
// while writing.
	func (s FileIOStream) Etag() string {
var _arg0 *C.GFileIOStream // out
var _cret *C.char // in

_arg0 = (*C.GFileIOStream)(unsafe.Pointer(s.Native()))

_cret = C.g_file_io_stream_get_etag(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// QueryInfo queries a file io stream for the given @attributes. This function
// blocks while querying the stream. For the asynchronous version of this
// function, see g_file_io_stream_query_info_async(). While the stream is
// blocked, the stream will set the pending flag internally, and any other
// operations on the stream will fail with G_IO_ERROR_PENDING.
// 
// Can fail if the stream was already closed (with @error being set to
// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being set
// to G_IO_ERROR_PENDING), or if querying info is not supported for the stream's
// interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED). I all cases of
// failure, nil will be returned.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set, and nil will be returned.
	func (s FileIOStream) QueryInfo(attributes string, cancellable CancellableClass) (FileInfo, error) {
var _arg0 *C.GFileIOStream // out
var _arg1 *C.char // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFileIOStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_io_stream_query_info(_arg0, _arg1, _arg2, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	
	// QueryInfoFinish finalizes the asynchronous query started by
// g_file_io_stream_query_info_async().
	func (s FileIOStream) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
var _arg0 *C.GFileIOStream // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFileIOStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_file_io_stream_query_info_finish(_arg0, _arg1, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	


	// FileIcon specifies an icon by pointing to an image file to be used as icon.
	type FileIcon struct {
		**externglib.Object
		Icon
		LoadableIcon
		
	}

	// FileIconClass is an interface that the FileIcon class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileIconClass interface {
		gextras.Objector
		_fileIcon()
	}

	func (FileIcon) _fileIcon() {}

	
	func marshalFileIcon(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileIcon(obj), nil
	}
	

	
	// NewFileIcon creates a new icon for a file.
	func NewFileIcon(file File) FileIcon {
var _arg1 *C.GFile // out
var _cret *C.GIcon // in

_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

_cret = C.g_file_icon_new(_arg1)


var _fileIcon FileIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_fileIcon = FileIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
Icon: Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
LoadableIcon: LoadableIcon{
Icon: Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _fileIcon
}
	

	
	// File gets the #GFile associated with the given @icon.
	func (i FileIcon) File() File {
var _arg0 *C.GFileIcon // out
var _cret *C.GFile // in

_arg0 = (*C.GFileIcon)(unsafe.Pointer(i.Native()))

_cret = C.g_file_icon_get_file(_arg0)


var _file File // out

_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(File)

return _file
}
	


	// FileInfo: functionality for manipulating basic metadata for files. Info
// implements methods for getting information that all files should contain, and
// allows for manipulation of extended attributes.
// 
// See [GFileAttribute][gio-GFileAttribute] for more information on how GIO
// handles file attributes.
// 
// To obtain a Info for a #GFile, use g_file_query_info() (or its async
// variant). To obtain a Info for a file input or output stream, use
// g_file_input_stream_query_info() or g_file_output_stream_query_info() (or
// their async variants).
// 
// To change the actual attributes of a file, you should then set the attribute
// in the Info and call g_file_set_attributes_from_info() or
// g_file_set_attributes_async() on a GFile.
// 
// However, not all attributes can be changed in the file. For instance, the
// actual size of a file cannot be changed via g_file_info_set_size(). You may
// call g_file_query_settable_attributes() and
// g_file_query_writable_namespaces() to discover the settable attributes of a
// particular file at runtime.
// 
// AttributeMatcher allows for searching through a Info for attributes.
	type FileInfo struct {
		**externglib.Object
		
	}

	// FileInfoClass is an interface that the FileInfo class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileInfoClass interface {
		gextras.Objector
		_fileInfo()
	}

	func (FileInfo) _fileInfo() {}

	
	func marshalFileInfo(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileInfo(obj), nil
	}
	

	
	// NewFileInfo creates a new file info structure.
	func NewFileInfo() FileInfo {
var _cret *C.GFileInfo // in

_cret = C.g_file_info_new()


var _fileInfo FileInfo // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_fileInfo = FileInfo{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _fileInfo
}
	

	
	// ClearStatus clears the status information from @info.
	func (i FileInfo) ClearStatus()  {
var _arg0 *C.GFileInfo // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

C.g_file_info_clear_status(_arg0)
}
	
	// CopyInto: first clears all of the [GFileAttribute][gio-GFileAttribute] of
// @dest_info, and then copies all of the file attributes from @src_info to
// @dest_info.
	func (s FileInfo) CopyInto(destInfo FileInfoClass)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.GFileInfo // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GFileInfo)(unsafe.Pointer(destInfo.Native()))

C.g_file_info_copy_into(_arg0, _arg1)
}
	
	// Dup duplicates a file info structure.
	func (o FileInfo) Dup() FileInfo {
var _arg0 *C.GFileInfo // out
var _cret *C.GFileInfo // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(o.Native()))

_cret = C.g_file_info_dup(_arg0)


var _fileInfo FileInfo // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)

return _fileInfo
}
	
	// AttributeAsString gets the value of a attribute, formatted as a string. This
// escapes things as needed to make the string valid UTF-8.
	func (i FileInfo) AttributeAsString(attribute string) string {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_as_string(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// AttributeBoolean gets the value of a boolean attribute. If the attribute does
// not contain a boolean value, false will be returned.
	func (i FileInfo) AttributeBoolean(attribute string) bool {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_boolean(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AttributeByteString gets the value of a byte string attribute. If the
// attribute does not contain a byte string, nil will be returned.
	func (i FileInfo) AttributeByteString(attribute string) string {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_byte_string(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// AttributeInt32 gets a signed 32-bit integer contained within the attribute.
// If the attribute does not contain a signed 32-bit integer, or is invalid, 0
// will be returned.
	func (i FileInfo) AttributeInt32(attribute string) int32 {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret C.gint32 // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_int32(_arg0, _arg1)


var _gint32 int32 // out

_gint32 = (int32)(_cret)

return _gint32
}
	
	// AttributeInt64 gets a signed 64-bit integer contained within the attribute.
// If the attribute does not contain a signed 64-bit integer, or is invalid, 0
// will be returned.
	func (i FileInfo) AttributeInt64(attribute string) int64 {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret C.gint64 // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_int64(_arg0, _arg1)


var _gint64 int64 // out

_gint64 = (int64)(_cret)

return _gint64
}
	
	// AttributeObject gets the value of a #GObject attribute. If the attribute does
// not contain a #GObject, nil will be returned.
	func (i FileInfo) AttributeObject(attribute string) **externglib.Object {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret *C.GObject // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_object(_arg0, _arg1)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// AttributeStatus gets the attribute status for an attribute key.
	func (i FileInfo) AttributeStatus(attribute string) FileAttributeStatus {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret C.GFileAttributeStatus // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_status(_arg0, _arg1)


var _fileAttributeStatus FileAttributeStatus // out

_fileAttributeStatus = FileAttributeStatus(_cret)

return _fileAttributeStatus
}
	
	// AttributeString gets the value of a string attribute. If the attribute does
// not contain a string, nil will be returned.
	func (i FileInfo) AttributeString(attribute string) string {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_string(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// AttributeStringv gets the value of a stringv attribute. If the attribute does
// not contain a stringv, nil will be returned.
	func (i FileInfo) AttributeStringv(attribute string) []string {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret **C.char

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_stringv(_arg0, _arg1)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// AttributeType gets the attribute type for an attribute key.
	func (i FileInfo) AttributeType(attribute string) FileAttributeType {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret C.GFileAttributeType // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_type(_arg0, _arg1)


var _fileAttributeType FileAttributeType // out

_fileAttributeType = FileAttributeType(_cret)

return _fileAttributeType
}
	
	// AttributeUint32 gets an unsigned 32-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 32-bit integer, or
// is invalid, 0 will be returned.
	func (i FileInfo) AttributeUint32(attribute string) uint32 {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret C.guint32 // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_uint32(_arg0, _arg1)


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}
	
	// AttributeUint64 gets a unsigned 64-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 64-bit integer, or
// is invalid, 0 will be returned.
	func (i FileInfo) AttributeUint64(attribute string) uint64 {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret C.guint64 // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_get_attribute_uint64(_arg0, _arg1)


var _guint64 uint64 // out

_guint64 = (uint64)(_cret)

return _guint64
}
	
	// ContentType gets the file's content type.
	func (i FileInfo) ContentType() string {
var _arg0 *C.GFileInfo // out
var _cret *C.char // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_content_type(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// DisplayName gets a display name for a file. This is guaranteed to always be
// set.
	func (i FileInfo) DisplayName() string {
var _arg0 *C.GFileInfo // out
var _cret *C.char // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_display_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// EditName gets the edit name for a file.
	func (i FileInfo) EditName() string {
var _arg0 *C.GFileInfo // out
var _cret *C.char // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_edit_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Etag gets the [entity tag][gfile-etag] for a given Info. See
// G_FILE_ATTRIBUTE_ETAG_VALUE.
	func (i FileInfo) Etag() string {
var _arg0 *C.GFileInfo // out
var _cret *C.char // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_etag(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// FileType gets a file's type (whether it is a regular file, symlink, etc).
// This is different from the file's content type, see
// g_file_info_get_content_type().
	func (i FileInfo) FileType() FileType {
var _arg0 *C.GFileInfo // out
var _cret C.GFileType // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_file_type(_arg0)


var _fileType FileType // out

_fileType = FileType(_cret)

return _fileType
}
	
	// Icon gets the icon for a file.
	func (i FileInfo) Icon() Icon {
var _arg0 *C.GFileInfo // out
var _cret *C.GIcon // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// IsBackup checks if a file is a backup file.
	func (i FileInfo) IsBackup() bool {
var _arg0 *C.GFileInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_is_backup(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsHidden checks if a file is hidden.
	func (i FileInfo) IsHidden() bool {
var _arg0 *C.GFileInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_is_hidden(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsSymlink checks if a file is a symlink.
	func (i FileInfo) IsSymlink() bool {
var _arg0 *C.GFileInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_is_symlink(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ModificationTime gets the modification time of the current @info and sets it
// in @result.
	func (i FileInfo) ModificationTime() glib.TimeVal {
var _arg0 *C.GFileInfo // out
var _result glib.TimeVal

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

C.g_file_info_get_modification_time(_arg0, (*C.GTimeVal)(unsafe.Pointer(&_result)))





return _result
}
	
	// Name gets the name for a file. This is guaranteed to always be set.
	func (i FileInfo) Name() string {
var _arg0 *C.GFileInfo // out
var _cret *C.char // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_name(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// Size gets the file's size (in bytes). The size is retrieved through the value
// of the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted from
// #guint64 to #goffset before returning the result.
	func (i FileInfo) Size() int64 {
var _arg0 *C.GFileInfo // out
var _cret C.goffset // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_size(_arg0)


var _gint64 int64 // out

_gint64 = (int64)(_cret)

return _gint64
}
	
	// SortOrder gets the value of the sort_order attribute from the Info. See
// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	func (i FileInfo) SortOrder() int32 {
var _arg0 *C.GFileInfo // out
var _cret C.gint32 // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_sort_order(_arg0)


var _gint32 int32 // out

_gint32 = (int32)(_cret)

return _gint32
}
	
	// SymbolicIcon gets the symbolic icon for a file.
	func (i FileInfo) SymbolicIcon() Icon {
var _arg0 *C.GFileInfo // out
var _cret *C.GIcon // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_symbolic_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// SymlinkTarget gets the symlink target for a given Info.
	func (i FileInfo) SymlinkTarget() string {
var _arg0 *C.GFileInfo // out
var _cret *C.char // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_file_info_get_symlink_target(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// HasAttribute checks if a file info structure has an attribute named
// @attribute.
	func (i FileInfo) HasAttribute(attribute string) bool {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_has_attribute(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasNamespace checks if a file info structure has an attribute in the
// specified @name_space.
	func (i FileInfo) HasNamespace(nameSpace string) bool {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(nameSpace))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_has_namespace(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ListAttributes lists the file info structure's attributes.
	func (i FileInfo) ListAttributes(nameSpace string) []string {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _cret **C.char

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(nameSpace))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_info_list_attributes(_arg0, _arg1)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// RemoveAttribute removes all cases of @attribute from @info if it exists.
	func (i FileInfo) RemoveAttribute(attribute string)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

C.g_file_info_remove_attribute(_arg0, _arg1)
}
	
	// SetAttributeBoolean sets the @attribute to contain the given @attr_value, if
// possible.
	func (i FileInfo) SetAttributeBoolean(attribute string, attrValue bool)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 C.gboolean // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
if attrValue { _arg2 = C.TRUE }

C.g_file_info_set_attribute_boolean(_arg0, _arg1, _arg2)
}
	
	// SetAttributeByteString sets the @attribute to contain the given @attr_value,
// if possible.
	func (i FileInfo) SetAttributeByteString(attribute string, attrValue string)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 *C.char // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(attrValue))
defer C.free(unsafe.Pointer(_arg2))

C.g_file_info_set_attribute_byte_string(_arg0, _arg1, _arg2)
}
	
	// SetAttributeInt32 sets the @attribute to contain the given @attr_value, if
// possible.
	func (i FileInfo) SetAttributeInt32(attribute string, attrValue int32)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 C.gint32 // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint32)(attrValue)

C.g_file_info_set_attribute_int32(_arg0, _arg1, _arg2)
}
	
	// SetAttributeInt64 sets the @attribute to contain the given @attr_value, if
// possible.
	func (i FileInfo) SetAttributeInt64(attribute string, attrValue int64)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 C.gint64 // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint64)(attrValue)

C.g_file_info_set_attribute_int64(_arg0, _arg1, _arg2)
}
	
	// SetAttributeMask sets @mask on @info to match specific attribute types.
	func (i FileInfo) SetAttributeMask(mask *FileAttributeMatcher)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.GFileAttributeMatcher // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GFileAttributeMatcher)(unsafe.Pointer(mask.Native()))

C.g_file_info_set_attribute_mask(_arg0, _arg1)
}
	
	// SetAttributeObject sets the @attribute to contain the given @attr_value, if
// possible.
	func (i FileInfo) SetAttributeObject(attribute string, attrValue **externglib.Object)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 *C.GObject // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GObject)(unsafe.Pointer(attrValue.Native()))

C.g_file_info_set_attribute_object(_arg0, _arg1, _arg2)
}
	
	// SetAttributeStatus sets the attribute status for an attribute key. This is
// only needed by external code that implement g_file_set_attributes_from_info()
// or similar functions.
// 
// The attribute must exist in @info for this to work. Otherwise false is
// returned and @info is unchanged.
	func (i FileInfo) SetAttributeStatus(attribute string, status FileAttributeStatus) bool {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 C.GFileAttributeStatus // out
var _cret C.gboolean // in

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GFileAttributeStatus)(status)

_cret = C.g_file_info_set_attribute_status(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAttributeString sets the @attribute to contain the given @attr_value, if
// possible.
	func (i FileInfo) SetAttributeString(attribute string, attrValue string)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 *C.char // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(attrValue))
defer C.free(unsafe.Pointer(_arg2))

C.g_file_info_set_attribute_string(_arg0, _arg1, _arg2)
}
	
	// SetAttributeStringv sets the @attribute to contain the given @attr_value, if
// possible.
// 
// Sinze: 2.22
	func (i FileInfo) SetAttributeStringv(attribute string, attrValue []string)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 **C.char

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.char)(C.malloc(C.ulong(len(attrValue)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(attrValue))
for i := range attrValue {
out[i] = (*C.gchar)(C.CString(attrValue[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.g_file_info_set_attribute_stringv(_arg0, _arg1, _arg2)
}
	
	// SetAttributeUint32 sets the @attribute to contain the given @attr_value, if
// possible.
	func (i FileInfo) SetAttributeUint32(attribute string, attrValue uint32)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 C.guint32 // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint32)(attrValue)

C.g_file_info_set_attribute_uint32(_arg0, _arg1, _arg2)
}
	
	// SetAttributeUint64 sets the @attribute to contain the given @attr_value, if
// possible.
	func (i FileInfo) SetAttributeUint64(attribute string, attrValue uint64)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out
var _arg2 C.guint64 // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint64)(attrValue)

C.g_file_info_set_attribute_uint64(_arg0, _arg1, _arg2)
}
	
	// SetContentType sets the content type attribute for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
	func (i FileInfo) SetContentType(contentType string)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg1))

C.g_file_info_set_content_type(_arg0, _arg1)
}
	
	// SetDisplayName sets the display name for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
	func (i FileInfo) SetDisplayName(displayName string)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(displayName))
defer C.free(unsafe.Pointer(_arg1))

C.g_file_info_set_display_name(_arg0, _arg1)
}
	
	// SetEditName sets the edit name for the current file. See
// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
	func (i FileInfo) SetEditName(editName string)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(editName))
defer C.free(unsafe.Pointer(_arg1))

C.g_file_info_set_edit_name(_arg0, _arg1)
}
	
	// SetFileType sets the file type in a Info to @type. See
// G_FILE_ATTRIBUTE_STANDARD_TYPE.
	func (i FileInfo) SetFileType(typ FileType)  {
var _arg0 *C.GFileInfo // out
var _arg1 C.GFileType // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (C.GFileType)(typ)

C.g_file_info_set_file_type(_arg0, _arg1)
}
	
	// SetIcon sets the icon for a given Info. See G_FILE_ATTRIBUTE_STANDARD_ICON.
	func (i FileInfo) SetIcon(icon Icon)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.g_file_info_set_icon(_arg0, _arg1)
}
	
	// SetIsHidden sets the "is_hidden" attribute in a Info according to @is_hidden.
// See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
	func (i FileInfo) SetIsHidden(isHidden bool)  {
var _arg0 *C.GFileInfo // out
var _arg1 C.gboolean // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
if isHidden { _arg1 = C.TRUE }

C.g_file_info_set_is_hidden(_arg0, _arg1)
}
	
	// SetIsSymlink sets the "is_symlink" attribute in a Info according to
// @is_symlink. See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
	func (i FileInfo) SetIsSymlink(isSymlink bool)  {
var _arg0 *C.GFileInfo // out
var _arg1 C.gboolean // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
if isSymlink { _arg1 = C.TRUE }

C.g_file_info_set_is_symlink(_arg0, _arg1)
}
	
	// SetModificationTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the given
// time value.
	func (i FileInfo) SetModificationTime(mtime *glib.TimeVal)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.GTimeVal // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GTimeVal)(unsafe.Pointer(mtime.Native()))

C.g_file_info_set_modification_time(_arg0, _arg1)
}
	
	// SetName sets the name attribute for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_NAME.
	func (i FileInfo) SetName(name string)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.g_file_info_set_name(_arg0, _arg1)
}
	
	// SetSize sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info to
// the given size.
	func (i FileInfo) SetSize(size int64)  {
var _arg0 *C.GFileInfo // out
var _arg1 C.goffset // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (C.goffset)(size)

C.g_file_info_set_size(_arg0, _arg1)
}
	
	// SetSortOrder sets the sort order attribute in the file info structure. See
// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	func (i FileInfo) SetSortOrder(sortOrder int32)  {
var _arg0 *C.GFileInfo // out
var _arg1 C.gint32 // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint32)(sortOrder)

C.g_file_info_set_sort_order(_arg0, _arg1)
}
	
	// SetSymbolicIcon sets the symbolic icon for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
	func (i FileInfo) SetSymbolicIcon(icon Icon)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.g_file_info_set_symbolic_icon(_arg0, _arg1)
}
	
	// SetSymlinkTarget sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute
// in the file info to the given symlink target.
	func (i FileInfo) SetSymlinkTarget(symlinkTarget string)  {
var _arg0 *C.GFileInfo // out
var _arg1 *C.char // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(symlinkTarget))
defer C.free(unsafe.Pointer(_arg1))

C.g_file_info_set_symlink_target(_arg0, _arg1)
}
	
	// UnsetAttributeMask unsets a mask set by g_file_info_set_attribute_mask(), if
// one is set.
	func (i FileInfo) UnsetAttributeMask()  {
var _arg0 *C.GFileInfo // out

_arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

C.g_file_info_unset_attribute_mask(_arg0)
}
	


	// FileInputStream: GFileInputStream provides input streams that take their
// content from a file.
// 
// GFileInputStream implements #GSeekable, which allows the input stream to jump
// to arbitrary positions in the file, provided the filesystem of the file
// allows it. To find the position of a file input stream, use
// g_seekable_tell(). To find out if a file input stream supports seeking, use
// g_seekable_can_seek(). To position a file input stream, use
// g_seekable_seek().
	type FileInputStream struct {
		InputStream
		Seekable
		
	}

	// FileInputStreamClass is an interface that the FileInputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileInputStreamClass interface {
		gextras.Objector
		_fileInputStream()
	}

	func (FileInputStream) _fileInputStream() {}

	
	func marshalFileInputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileInputStream(obj), nil
	}
	

	

	
	// QueryInfo queries a file input stream the given @attributes. This function
// blocks while querying the stream. For the asynchronous (non-blocking) version
// of this function, see g_file_input_stream_query_info_async(). While the
// stream is blocked, the stream will set the pending flag internally, and any
// other operations on the stream will fail with G_IO_ERROR_PENDING.
	func (s FileInputStream) QueryInfo(attributes string, cancellable CancellableClass) (FileInfo, error) {
var _arg0 *C.GFileInputStream // out
var _arg1 *C.char // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFileInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_input_stream_query_info(_arg0, _arg1, _arg2, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	
	// QueryInfoFinish finishes an asynchronous info query operation.
	func (s FileInputStream) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
var _arg0 *C.GFileInputStream // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFileInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_file_input_stream_query_info_finish(_arg0, _arg1, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	


	// FileMonitor monitors a file or directory for changes.
// 
// To obtain a Monitor for a file or directory, use g_file_monitor(),
// g_file_monitor_file(), or g_file_monitor_directory().
// 
// To get informed about changes to the file or directory you are monitoring,
// connect to the Monitor::changed signal. The signal will be emitted in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that the monitor was created in (though if the global default main
// context is blocked, this may cause notifications to be blocked even if the
// thread-default context is still running).
	type FileMonitor struct {
		**externglib.Object
		
	}

	// FileMonitorClass is an interface that the FileMonitor class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileMonitorClass interface {
		gextras.Objector
		_fileMonitor()
	}

	func (FileMonitor) _fileMonitor() {}

	
	func marshalFileMonitor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileMonitor(obj), nil
	}
	

	

	
	// Cancel cancels a file monitor.
	func (m FileMonitor) Cancel() bool {
var _arg0 *C.GFileMonitor // out
var _cret C.gboolean // in

_arg0 = (*C.GFileMonitor)(unsafe.Pointer(m.Native()))

_cret = C.g_file_monitor_cancel(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EmitEvent emits the Monitor::changed signal if a change has taken place.
// Should be called from file monitor implementations only.
// 
// Implementations are responsible to call this method from the [thread-default
// main context][g-main-context-push-thread-default] of the thread that the
// monitor was created in.
	func (m FileMonitor) EmitEvent(child File, otherFile File, eventType FileMonitorEvent)  {
var _arg0 *C.GFileMonitor // out
var _arg1 *C.GFile // out
var _arg2 *C.GFile // out
var _arg3 C.GFileMonitorEvent // out

_arg0 = (*C.GFileMonitor)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GFile)(unsafe.Pointer(otherFile.Native()))
_arg3 = (C.GFileMonitorEvent)(eventType)

C.g_file_monitor_emit_event(_arg0, _arg1, _arg2, _arg3)
}
	
	// IsCancelled returns whether the monitor is canceled.
	func (m FileMonitor) IsCancelled() bool {
var _arg0 *C.GFileMonitor // out
var _cret C.gboolean // in

_arg0 = (*C.GFileMonitor)(unsafe.Pointer(m.Native()))

_cret = C.g_file_monitor_is_cancelled(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetRateLimit sets the rate limit to which the @monitor will report
// consecutive change events to the same file.
	func (m FileMonitor) SetRateLimit(limitMsecs int)  {
var _arg0 *C.GFileMonitor // out
var _arg1 C.gint // out

_arg0 = (*C.GFileMonitor)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(limitMsecs)

C.g_file_monitor_set_rate_limit(_arg0, _arg1)
}
	


	// FileOutputStream: GFileOutputStream provides output streams that write their
// content to a file.
// 
// GFileOutputStream implements #GSeekable, which allows the output stream to
// jump to arbitrary positions in the file and to truncate the file, provided
// the filesystem of the file supports these operations.
// 
// To find the position of a file output stream, use g_seekable_tell(). To find
// out if a file output stream supports seeking, use g_seekable_can_seek().To
// position a file output stream, use g_seekable_seek(). To find out if a file
// output stream supports truncating, use g_seekable_can_truncate(). To truncate
// a file output stream, use g_seekable_truncate().
	type FileOutputStream struct {
		OutputStream
		Seekable
		
	}

	// FileOutputStreamClass is an interface that the FileOutputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileOutputStreamClass interface {
		gextras.Objector
		_fileOutputStream()
	}

	func (FileOutputStream) _fileOutputStream() {}

	
	func marshalFileOutputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileOutputStream(obj), nil
	}
	

	

	
	// Etag gets the entity tag for the file when it has been written. This must be
// called after the stream has been written and closed, as the etag can change
// while writing.
	func (s FileOutputStream) Etag() string {
var _arg0 *C.GFileOutputStream // out
var _cret *C.char // in

_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_file_output_stream_get_etag(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// QueryInfo queries a file output stream for the given @attributes. This
// function blocks while querying the stream. For the asynchronous version of
// this function, see g_file_output_stream_query_info_async(). While the stream
// is blocked, the stream will set the pending flag internally, and any other
// operations on the stream will fail with G_IO_ERROR_PENDING.
// 
// Can fail if the stream was already closed (with @error being set to
// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being set
// to G_IO_ERROR_PENDING), or if querying info is not supported for the stream's
// interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED). In all cases
// of failure, nil will be returned.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set, and nil will be returned.
	func (s FileOutputStream) QueryInfo(attributes string, cancellable CancellableClass) (FileInfo, error) {
var _arg0 *C.GFileOutputStream // out
var _arg1 *C.char // out
var _arg2 *C.GCancellable // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_file_output_stream_query_info(_arg0, _arg1, _arg2, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	
	// QueryInfoFinish finalizes the asynchronous query started by
// g_file_output_stream_query_info_async().
	func (s FileOutputStream) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
var _arg0 *C.GFileOutputStream // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GFileInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_file_output_stream_query_info_finish(_arg0, _arg1, &_cerr)


var _fileInfo FileInfo // out
var _goerr error // out

_fileInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(FileInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _fileInfo, _goerr
}
	


	// FilenameCompleter completes partial file and directory names given a partial
// string by looking in the file system for clues. Can return a list of possible
// completion strings for widget implementations.
	type FilenameCompleter struct {
		**externglib.Object
		
	}

	// FilenameCompleterClass is an interface that the FilenameCompleter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FilenameCompleterClass interface {
		gextras.Objector
		_filenameCompleter()
	}

	func (FilenameCompleter) _filenameCompleter() {}

	
	func marshalFilenameCompleter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFilenameCompleter(obj), nil
	}
	

	
	// NewFilenameCompleter creates a new filename completer.
	func NewFilenameCompleter() FilenameCompleter {
var _cret *C.GFilenameCompleter // in

_cret = C.g_filename_completer_new()


var _filenameCompleter FilenameCompleter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_filenameCompleter = FilenameCompleter{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _filenameCompleter
}
	

	
	// CompletionSuffix obtains a completion for @initial_text from @completer.
	func (c FilenameCompleter) CompletionSuffix(initialText string) string {
var _arg0 *C.GFilenameCompleter // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(initialText))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_filename_completer_get_completion_suffix(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Completions gets an array of completion strings for a given initial text.
	func (c FilenameCompleter) Completions(initialText string) []string {
var _arg0 *C.GFilenameCompleter // out
var _arg1 *C.char // out
var _cret **C.char

_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(initialText))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_filename_completer_get_completions(_arg0, _arg1)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// SetDirsOnly: if @dirs_only is true, @completer will only complete directory
// names, and not file names.
	func (c FilenameCompleter) SetDirsOnly(dirsOnly bool)  {
var _arg0 *C.GFilenameCompleter // out
var _arg1 C.gboolean // out

_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(c.Native()))
if dirsOnly { _arg1 = C.TRUE }

C.g_filename_completer_set_dirs_only(_arg0, _arg1)
}
	


	// FilterInputStream: base class for input stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
	type FilterInputStream struct {
		InputStream
		
	}

	// FilterInputStreamClass is an interface that the FilterInputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FilterInputStreamClass interface {
		gextras.Objector
		_filterInputStream()
	}

	func (FilterInputStream) _filterInputStream() {}

	
	func marshalFilterInputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFilterInputStream(obj), nil
	}
	

	

	
	// BaseStream gets the base stream for the filter stream.
	func (s FilterInputStream) BaseStream() InputStream {
var _arg0 *C.GFilterInputStream // out
var _cret *C.GInputStream // in

_arg0 = (*C.GFilterInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_filter_input_stream_get_base_stream(_arg0)


var _inputStream InputStream // out

_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

return _inputStream
}
	
	// CloseBaseStream returns whether the base stream will be closed when @stream
// is closed.
	func (s FilterInputStream) CloseBaseStream() bool {
var _arg0 *C.GFilterInputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GFilterInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_filter_input_stream_get_close_base_stream(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetCloseBaseStream sets whether the base stream will be closed when @stream
// is closed.
	func (s FilterInputStream) SetCloseBaseStream(closeBase bool)  {
var _arg0 *C.GFilterInputStream // out
var _arg1 C.gboolean // out

_arg0 = (*C.GFilterInputStream)(unsafe.Pointer(s.Native()))
if closeBase { _arg1 = C.TRUE }

C.g_filter_input_stream_set_close_base_stream(_arg0, _arg1)
}
	


	// FilterOutputStream: base class for output stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
	type FilterOutputStream struct {
		OutputStream
		
	}

	// FilterOutputStreamClass is an interface that the FilterOutputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FilterOutputStreamClass interface {
		gextras.Objector
		_filterOutputStream()
	}

	func (FilterOutputStream) _filterOutputStream() {}

	
	func marshalFilterOutputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFilterOutputStream(obj), nil
	}
	

	

	
	// BaseStream gets the base stream for the filter stream.
	func (s FilterOutputStream) BaseStream() OutputStream {
var _arg0 *C.GFilterOutputStream // out
var _cret *C.GOutputStream // in

_arg0 = (*C.GFilterOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_filter_output_stream_get_base_stream(_arg0)


var _outputStream OutputStream // out

_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(OutputStream)

return _outputStream
}
	
	// CloseBaseStream returns whether the base stream will be closed when @stream
// is closed.
	func (s FilterOutputStream) CloseBaseStream() bool {
var _arg0 *C.GFilterOutputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GFilterOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_filter_output_stream_get_close_base_stream(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetCloseBaseStream sets whether the base stream will be closed when @stream
// is closed.
	func (s FilterOutputStream) SetCloseBaseStream(closeBase bool)  {
var _arg0 *C.GFilterOutputStream // out
var _arg1 C.gboolean // out

_arg0 = (*C.GFilterOutputStream)(unsafe.Pointer(s.Native()))
if closeBase { _arg1 = C.TRUE }

C.g_filter_output_stream_set_close_base_stream(_arg0, _arg1)
}
	


	// IOStream: GIOStream represents an object that has both read and write
// streams. Generally the two streams act as separate input and output streams,
// but they share some common resources and state. For instance, for seekable
// streams, both streams may use the same position.
// 
// Examples of OStream objects are Connection, which represents a two-way
// network connection; and IOStream, which represents a file handle opened in
// read-write mode.
// 
// To do the actual reading and writing you need to get the substreams with
// g_io_stream_get_input_stream() and g_io_stream_get_output_stream().
// 
// The OStream object owns the input and the output streams, not the other way
// around, so keeping the substreams alive will not keep the OStream object
// alive. If the OStream object is freed it will be closed, thus closing the
// substreams, so even if the substreams stay alive they will always return
// G_IO_ERROR_CLOSED for all operations.
// 
// To close a stream use g_io_stream_close() which will close the common stream
// object and also the individual substreams. You can also close the substreams
// themselves. In most cases this only marks the substream as closed, so further
// I/O on it fails but common state in the OStream may still be open. However,
// some streams may support "half-closed" states where one direction of the
// stream is actually shut down.
// 
// Operations on OStreams cannot be started while another operation on the
// OStream or its substreams is in progress. Specifically, an application can
// read from the Stream and write to the Stream simultaneously (either in
// separate threads, or as asynchronous operations in the same thread), but an
// application cannot start any OStream operation while there is a OStream,
// Stream or Stream operation in progress, and an application cant start any
// Stream or Stream operation while there is a OStream operation in progress.
// 
// This is a product of individual stream operations being associated with a
// given Context (the thread-default context at the time the operation was
// started), rather than entire streams being associated with a single Context.
// 
// GIO may run operations on OStreams from other (worker) threads, and this may
// be exposed to application code in the behaviour of wrapper streams, such as
// InputStream or Connection. With such wrapper APIs, application code may only
// run operations on the base (wrapped) stream when the wrapper stream is idle.
// Note that the semantics of such operations may not be well-defined due to the
// state the wrapper stream leaves the base stream in (though they are
// guaranteed not to crash).
	type IOStream struct {
		**externglib.Object
		
	}

	// IOStreamClass is an interface that the IOStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IOStreamClass interface {
		gextras.Objector
		_ioStream()
	}

	func (IOStream) _ioStream() {}

	
	func marshalIOStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIOStream(obj), nil
	}
	

	

	
	// ClearPending clears the pending flag on @stream.
	func (s IOStream) ClearPending()  {
var _arg0 *C.GIOStream // out

_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

C.g_io_stream_clear_pending(_arg0)
}
	
	// Close closes the stream, releasing resources related to it. This will also
// close the individual input and output streams, if they are not already
// closed.
// 
// Once the stream is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an error.
// 
// Closing a stream will automatically flush any outstanding buffers in the
// stream.
// 
// Streams will be automatically closed when the last reference is dropped, but
// you might want to call this function to make sure resources are released as
// early as possible.
// 
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for the
// individual stream for details.
// 
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to close will
// still return G_IO_ERROR_CLOSED for all operations. Still, it is important to
// check and report the error to the user, otherwise there might be a loss of
// data as all data might not be written.
// 
// If @cancellable is not NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation was
// cancelled, the error G_IO_ERROR_CANCELLED will be returned. Cancelling a
// close will still leave the stream closed, but some streams can use a faster
// close that doesn't block to e.g. check errors.
// 
// The default implementation of this method just calls close on the individual
// input/output streams.
	func (s IOStream) Close(cancellable CancellableClass) error {
var _arg0 *C.GIOStream // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_io_stream_close(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CloseFinish closes a stream.
	func (s IOStream) CloseFinish(result AsyncResult) error {
var _arg0 *C.GIOStream // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_io_stream_close_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// InputStream gets the input stream for this object. This is used for reading.
	func (s IOStream) InputStream() InputStream {
var _arg0 *C.GIOStream // out
var _cret *C.GInputStream // in

_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

_cret = C.g_io_stream_get_input_stream(_arg0)


var _inputStream InputStream // out

_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

return _inputStream
}
	
	// OutputStream gets the output stream for this object. This is used for
// writing.
	func (s IOStream) OutputStream() OutputStream {
var _arg0 *C.GIOStream // out
var _cret *C.GOutputStream // in

_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

_cret = C.g_io_stream_get_output_stream(_arg0)


var _outputStream OutputStream // out

_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(OutputStream)

return _outputStream
}
	
	// HasPending checks if a stream has pending actions.
	func (s IOStream) HasPending() bool {
var _arg0 *C.GIOStream // out
var _cret C.gboolean // in

_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

_cret = C.g_io_stream_has_pending(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsClosed checks if a stream is closed.
	func (s IOStream) IsClosed() bool {
var _arg0 *C.GIOStream // out
var _cret C.gboolean // in

_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

_cret = C.g_io_stream_is_closed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetPending sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return false and set @error.
	func (s IOStream) SetPending() error {
var _arg0 *C.GIOStream // out
var _cerr *C.GError // in

_arg0 = (*C.GIOStream)(unsafe.Pointer(s.Native()))

C.g_io_stream_set_pending(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	// InetAddress represents an IPv4 or IPv6 internet address. Use
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to look up
// the Address for a hostname. Use g_resolver_lookup_by_address() or
// g_resolver_lookup_by_address_async() to look up the hostname for a Address.
// 
// To actually connect to a remote host, you will need a SocketAddress (which
// includes a Address as well as a port number).
	type InetAddress struct {
		**externglib.Object
		
	}

	// InetAddressClass is an interface that the InetAddress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type InetAddressClass interface {
		gextras.Objector
		_inetAddress()
	}

	func (InetAddress) _inetAddress() {}

	
	func marshalInetAddress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapInetAddress(obj), nil
	}
	

	
	// NewInetAddressAny creates a Address for the "any" address (unassigned/"don't
// care") for @family.
	func NewInetAddressAny(family SocketFamily) InetAddress {
var _arg1 C.GSocketFamily // out
var _cret *C.GInetAddress // in

_arg1 = (C.GSocketFamily)(family)

_cret = C.g_inet_address_new_any(_arg1)


var _inetAddress InetAddress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_inetAddress = InetAddress{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _inetAddress
}
	
	// NewInetAddressFromString parses @string as an IP address and creates a new
// Address.
	func NewInetAddressFromString(_string string) InetAddress {
var _arg1 *C.gchar // out
var _cret *C.GInetAddress // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_inet_address_new_from_string(_arg1)


var _inetAddress InetAddress // out

_inetAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InetAddress)

return _inetAddress
}
	
	// NewInetAddressLoopback creates a Address for the loopback address for
// @family.
	func NewInetAddressLoopback(family SocketFamily) InetAddress {
var _arg1 C.GSocketFamily // out
var _cret *C.GInetAddress // in

_arg1 = (C.GSocketFamily)(family)

_cret = C.g_inet_address_new_loopback(_arg1)


var _inetAddress InetAddress // out

_inetAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InetAddress)

return _inetAddress
}
	

	
	// Equal checks if two Address instances are equal, e.g. the same address.
	func (a InetAddress) Equal(otherAddress InetAddressClass) bool {
var _arg0 *C.GInetAddress // out
var _arg1 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GInetAddress)(unsafe.Pointer(otherAddress.Native()))

_cret = C.g_inet_address_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Family gets @address's family
	func (a InetAddress) Family() SocketFamily {
var _arg0 *C.GInetAddress // out
var _cret C.GSocketFamily // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_family(_arg0)


var _socketFamily SocketFamily // out

_socketFamily = SocketFamily(_cret)

return _socketFamily
}
	
	// IsAny tests whether @address is the "any" address for its family.
	func (a InetAddress) IsAny() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_any(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsLinkLocal tests whether @address is a link-local address (that is, if it
// identifies a host on a local network that is not connected to the Internet).
	func (a InetAddress) IsLinkLocal() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_link_local(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsLoopback tests whether @address is the loopback address for its family.
	func (a InetAddress) IsLoopback() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_loopback(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMcGlobal tests whether @address is a global multicast address.
	func (a InetAddress) IsMcGlobal() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_mc_global(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMcLinkLocal tests whether @address is a link-local multicast address.
	func (a InetAddress) IsMcLinkLocal() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_mc_link_local(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMcNodeLocal tests whether @address is a node-local multicast address.
	func (a InetAddress) IsMcNodeLocal() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_mc_node_local(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMcOrgLocal tests whether @address is an organization-local multicast
// address.
	func (a InetAddress) IsMcOrgLocal() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_mc_org_local(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMcSiteLocal tests whether @address is a site-local multicast address.
	func (a InetAddress) IsMcSiteLocal() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_mc_site_local(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMulticast tests whether @address is a multicast address.
	func (a InetAddress) IsMulticast() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_multicast(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsSiteLocal tests whether @address is a site-local address such as 10.0.0.1
// (that is, the address identifies a host on a local network that can not be
// reached directly from the Internet, but which may have outgoing Internet
// connectivity via a NAT or firewall).
	func (a InetAddress) IsSiteLocal() bool {
var _arg0 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_is_site_local(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// NativeSize gets the size of the native raw binary address for @address. This
// is the size of the data that you get from g_inet_address_to_bytes().
	func (a InetAddress) NativeSize() uint {
var _arg0 *C.GInetAddress // out
var _cret C.gsize // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_get_native_size(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	
	// String converts @address to string form.
	func (a InetAddress) String() string {
var _arg0 *C.GInetAddress // out
var _cret *C.gchar // in

_arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_address_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	// InetAddressMask represents a range of IPv4 or IPv6 addresses described by a
// base address and a length indicating how many bits of the base address are
// relevant for matching purposes. These are often given in string form. Eg,
// "10.0.0.0/8", or "fe80::/10".
	type InetAddressMask struct {
		**externglib.Object
		Initable
		
	}

	// InetAddressMaskClass is an interface that the InetAddressMask class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type InetAddressMaskClass interface {
		gextras.Objector
		_inetAddressMask()
	}

	func (InetAddressMask) _inetAddressMask() {}

	
	func marshalInetAddressMask(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapInetAddressMask(obj), nil
	}
	

	
	// NewInetAddressMask creates a new AddressMask representing all addresses whose
// first @length bits match @addr.
	func NewInetAddressMask(addr InetAddressClass, length uint) (InetAddressMask, error) {
var _arg1 *C.GInetAddress // out
var _arg2 C.guint // out
var _cret *C.GInetAddressMask // in
var _cerr *C.GError // in

_arg1 = (*C.GInetAddress)(unsafe.Pointer(addr.Native()))
_arg2 = (C.guint)(length)

_cret = C.g_inet_address_mask_new(_arg1, _arg2, &_cerr)


var _inetAddressMask InetAddressMask // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_inetAddressMask = InetAddressMask{
Object: &externglib.Object{externglib.ToGObject(obj)},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _inetAddressMask, _goerr
}
	
	// NewInetAddressMaskFromString parses @mask_string as an IP address and
// (optional) length, and creates a new AddressMask. The length, if present, is
// delimited by a "/". If it is not present, then the length is assumed to be
// the full length of the address.
	func NewInetAddressMaskFromString(maskString string) (InetAddressMask, error) {
var _arg1 *C.gchar // out
var _cret *C.GInetAddressMask // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(maskString))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_inet_address_mask_new_from_string(_arg1, &_cerr)


var _inetAddressMask InetAddressMask // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_inetAddressMask = InetAddressMask{
Object: &externglib.Object{externglib.ToGObject(obj)},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _inetAddressMask, _goerr
}
	

	
	// Equal tests if @mask and @mask2 are the same mask.
	func (m InetAddressMask) Equal(mask2 InetAddressMaskClass) bool {
var _arg0 *C.GInetAddressMask // out
var _arg1 *C.GInetAddressMask // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GInetAddressMask)(unsafe.Pointer(mask2.Native()))

_cret = C.g_inet_address_mask_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Address gets @mask's base address
	func (m InetAddressMask) Address() InetAddress {
var _arg0 *C.GInetAddressMask // out
var _cret *C.GInetAddress // in

_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))

_cret = C.g_inet_address_mask_get_address(_arg0)


var _inetAddress InetAddress // out

_inetAddress = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InetAddress)

return _inetAddress
}
	
	// Family gets the Family of @mask's address
	func (m InetAddressMask) Family() SocketFamily {
var _arg0 *C.GInetAddressMask // out
var _cret C.GSocketFamily // in

_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))

_cret = C.g_inet_address_mask_get_family(_arg0)


var _socketFamily SocketFamily // out

_socketFamily = SocketFamily(_cret)

return _socketFamily
}
	
	// Length gets @mask's length
	func (m InetAddressMask) Length() uint {
var _arg0 *C.GInetAddressMask // out
var _cret C.guint // in

_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))

_cret = C.g_inet_address_mask_get_length(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Matches tests if @address falls within the range described by @mask.
	func (m InetAddressMask) Matches(address InetAddressClass) bool {
var _arg0 *C.GInetAddressMask // out
var _arg1 *C.GInetAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GInetAddress)(unsafe.Pointer(address.Native()))

_cret = C.g_inet_address_mask_matches(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// String converts @mask back to its corresponding string form.
	func (m InetAddressMask) String() string {
var _arg0 *C.GInetAddressMask // out
var _cret *C.gchar // in

_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(m.Native()))

_cret = C.g_inet_address_mask_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	// InetSocketAddress: an IPv4 or IPv6 socket address; that is, the combination
// of a Address and a port number.
	type InetSocketAddress struct {
		SocketAddress
		SocketConnectable
		
	}

	// InetSocketAddressClass is an interface that the InetSocketAddress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type InetSocketAddressClass interface {
		gextras.Objector
		_inetSocketAddress()
	}

	func (InetSocketAddress) _inetSocketAddress() {}

	
	func marshalInetSocketAddress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapInetSocketAddress(obj), nil
	}
	

	
	// NewInetSocketAddress creates a new SocketAddress for @address and @port.
	func NewInetSocketAddress(address InetAddressClass, port uint16) InetSocketAddress {
var _arg1 *C.GInetAddress // out
var _arg2 C.guint16 // out
var _cret *C.GSocketAddress // in

_arg1 = (*C.GInetAddress)(unsafe.Pointer(address.Native()))
_arg2 = (C.guint16)(port)

_cret = C.g_inet_socket_address_new(_arg1, _arg2)


var _inetSocketAddress InetSocketAddress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_inetSocketAddress = InetSocketAddress{
SocketAddress: SocketAddress{
Object: &externglib.Object{externglib.ToGObject(obj)},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _inetSocketAddress
}
	
	// NewInetSocketAddressFromString creates a new SocketAddress for @address and
// @port.
// 
// If @address is an IPv6 address, it can also contain a scope ID (separated
// from the address by a `%`).
	func NewInetSocketAddressFromString(address string, port uint) InetSocketAddress {
var _arg1 *C.char // out
var _arg2 C.guint // out
var _cret *C.GSocketAddress // in

_arg1 = (*C.char)(C.CString(address))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint)(port)

_cret = C.g_inet_socket_address_new_from_string(_arg1, _arg2)


var _inetSocketAddress InetSocketAddress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_inetSocketAddress = InetSocketAddress{
SocketAddress: SocketAddress{
Object: &externglib.Object{externglib.ToGObject(obj)},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _inetSocketAddress
}
	

	
	// Address gets @address's Address.
	func (a InetSocketAddress) Address() InetAddress {
var _arg0 *C.GInetSocketAddress // out
var _cret *C.GInetAddress // in

_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_socket_address_get_address(_arg0)


var _inetAddress InetAddress // out

_inetAddress = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InetAddress)

return _inetAddress
}
	
	// Flowinfo gets the `sin6_flowinfo` field from @address, which must be an IPv6
// address.
	func (a InetSocketAddress) Flowinfo() uint32 {
var _arg0 *C.GInetSocketAddress // out
var _cret C.guint32 // in

_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_socket_address_get_flowinfo(_arg0)


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}
	
	// Port gets @address's port.
	func (a InetSocketAddress) Port() uint16 {
var _arg0 *C.GInetSocketAddress // out
var _cret C.guint16 // in

_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_socket_address_get_port(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// ScopeID gets the `sin6_scope_id` field from @address, which must be an IPv6
// address.
	func (a InetSocketAddress) ScopeID() uint32 {
var _arg0 *C.GInetSocketAddress // out
var _cret C.guint32 // in

_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_inet_socket_address_get_scope_id(_arg0)


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}
	


	// InputStream has functions to read from a stream (g_input_stream_read()), to
// close a stream (g_input_stream_close()) and to skip some content
// (g_input_stream_skip()).
// 
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
// 
// See the documentation for OStream for details of thread safety of streaming
// APIs.
// 
// All of these functions have async variants too.
	type InputStream struct {
		**externglib.Object
		
	}

	// InputStreamClass is an interface that the InputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type InputStreamClass interface {
		gextras.Objector
		_inputStream()
	}

	func (InputStream) _inputStream() {}

	
	func marshalInputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapInputStream(obj), nil
	}
	

	

	
	// ClearPending clears the pending flag on @stream.
	func (s InputStream) ClearPending()  {
var _arg0 *C.GInputStream // out

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

C.g_input_stream_clear_pending(_arg0)
}
	
	// Close closes the stream, releasing resources related to it.
// 
// Once the stream is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an error.
// 
// Streams will be automatically closed when the last reference is dropped, but
// you might want to call this function to make sure resources are released as
// early as possible.
// 
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for the
// individual stream for details.
// 
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to close will
// still return G_IO_ERROR_CLOSED for all operations. Still, it is important to
// check and report the error to the user.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. Cancelling a close will
// still leave the stream closed, but some streams can use a faster close that
// doesn't block to e.g. check errors.
	func (s InputStream) Close(cancellable CancellableClass) error {
var _arg0 *C.GInputStream // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_input_stream_close(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CloseFinish finishes closing a stream asynchronously, started from
// g_input_stream_close_async().
	func (s InputStream) CloseFinish(result AsyncResult) error {
var _arg0 *C.GInputStream // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_input_stream_close_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// HasPending checks if an input stream has pending actions.
	func (s InputStream) HasPending() bool {
var _arg0 *C.GInputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_input_stream_has_pending(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsClosed checks if an input stream is closed.
	func (s InputStream) IsClosed() bool {
var _arg0 *C.GInputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_input_stream_is_closed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Read tries to read @count bytes from the stream into the buffer starting at
// @buffer. Will block during this read.
// 
// If count is zero returns zero and does nothing. A value of @count larger than
// G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
// 
// On success, the number of bytes read into the buffer is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// near the end of a file. Zero is returned on end of file (or if @count is
// zero), but never otherwise.
// 
// The returned @buffer is not a nul-terminated string, it can contain nul bytes
// at any position, and this function doesn't nul-terminate the @buffer.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
// 
// On error -1 is returned and @error is set accordingly.
	func (s InputStream) Read(cancellable CancellableClass) ([]byte, int, error) {
var _arg0 *C.GInputStream // out
var _arg1 C.void
var _arg2 C.gsize // in
var _arg3 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_input_stream_read(_arg0, &_arg1, &_arg2, _arg3, &_cerr)


var _buffer []byte
var _gssize int // out
var _goerr error // out

{
src := unsafe.Slice(_arg1, _arg2)
_buffer = make([]byte, _arg2)
for i := 0; i < int(_arg2); i++ {
_buffer[i] = (byte)(src[i])
}
}
_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _buffer, _gssize, _goerr
}
	
	// ReadAll tries to read @count bytes from the stream into the buffer starting
// at @buffer. Will block during this read.
// 
// This function is similar to g_input_stream_read(), except it tries to read as
// many bytes as requested, only stopping on an error or end of stream.
// 
// On a successful read of @count bytes, or if we reached the end of the stream,
// true is returned, and @bytes_read is set to the number of bytes read into
// @buffer.
// 
// If there is an error during the operation false is returned and @error is set
// to indicate the error status.
// 
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns false (and sets @error) then @bytes_read
// will be set to the number of bytes that were successfully read before the
// error was encountered. This functionality is only available from C. If you
// need it from another language then you must write your own loop around
// g_input_stream_read().
	func (s InputStream) ReadAll(cancellable CancellableClass) ([]byte, uint, error) {
var _arg0 *C.GInputStream // out
var _arg1 C.void
var _arg2 C.gsize // in
var _arg3 C.gsize // in
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_input_stream_read_all(_arg0, &_arg1, &_arg2, &_arg3, _arg4, &_cerr)

var _buffer []byte
var _bytesRead uint // out
var _goerr error // out

{
src := unsafe.Slice(_arg1, _arg2)
_buffer = make([]byte, _arg2)
for i := 0; i < int(_arg2); i++ {
_buffer[i] = (byte)(src[i])
}
}
_bytesRead = (uint)(_arg3)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _buffer, _bytesRead, _goerr
}
	
	// ReadAllFinish finishes an asynchronous stream read operation started with
// g_input_stream_read_all_async().
// 
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns false (and sets @error) then @bytes_read
// will be set to the number of bytes that were successfully read before the
// error was encountered. This functionality is only available from C. If you
// need it from another language then you must write your own loop around
// g_input_stream_read_async().
	func (s InputStream) ReadAllFinish(result AsyncResult) (uint, error) {
var _arg0 *C.GInputStream // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gsize // in
var _cerr *C.GError // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_input_stream_read_all_finish(_arg0, _arg1, &_arg2, &_cerr)

var _bytesRead uint // out
var _goerr error // out

_bytesRead = (uint)(_arg2)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesRead, _goerr
}
	
	// ReadFinish finishes an asynchronous stream read operation.
	func (s InputStream) ReadFinish(result AsyncResult) (int, error) {
var _arg0 *C.GInputStream // out
var _arg1 *C.GAsyncResult // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_input_stream_read_finish(_arg0, _arg1, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// SetPending sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return false and set @error.
	func (s InputStream) SetPending() error {
var _arg0 *C.GInputStream // out
var _cerr *C.GError // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

C.g_input_stream_set_pending(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Skip tries to skip @count bytes from the stream. Will block during the
// operation.
// 
// This is identical to g_input_stream_read(), from a behaviour standpoint, but
// the bytes that are skipped are not returned to the user. Some streams have an
// implementation that is more efficient than reading the data.
// 
// This function is optional for inherited classes, as the default
// implementation emulates it using read.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
	func (s InputStream) Skip(count uint, cancellable CancellableClass) (int, error) {
var _arg0 *C.GInputStream // out
var _arg1 C.gsize // out
var _arg2 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.gsize)(count)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_input_stream_skip(_arg0, _arg1, _arg2, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// SkipFinish finishes a stream skip operation.
	func (s InputStream) SkipFinish(result AsyncResult) (int, error) {
var _arg0 *C.GInputStream // out
var _arg1 *C.GAsyncResult // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_input_stream_skip_finish(_arg0, _arg1, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	


	// ListStore is a simple implementation of Model that stores all items in
// memory.
// 
// It provides insertions, deletions, and lookups in logarithmic time with a
// fast path for the common case of iterating the list linearly.
	type ListStore struct {
		**externglib.Object
		ListModel
		
	}

	// ListStoreClass is an interface that the ListStore class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListStoreClass interface {
		gextras.Objector
		_listStore()
	}

	func (ListStore) _listStore() {}

	
	func marshalListStore(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListStore(obj), nil
	}
	

	
	// NewListStore creates a new Store with items of type @item_type. @item_type
// must be a subclass of #GObject.
	func NewListStore(itemType externglib.Type) ListStore {
var _arg1 C.GType // out
var _cret *C.GListStore // in

_arg1 = C.GType(itemType)

_cret = C.g_list_store_new(_arg1)


var _listStore ListStore // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_listStore = ListStore{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _listStore
}
	

	
	// Append appends @item to @store. @item must be of type Store:item-type.
// 
// This function takes a ref on @item.
// 
// Use g_list_store_splice() to append multiple items at the same time
// efficiently.
	func (s ListStore) Append(item **externglib.Object)  {
var _arg0 *C.GListStore // out
var _arg1 C.gpointer // out

_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GObject)(unsafe.Pointer(item.Native()))

C.g_list_store_append(_arg0, _arg1)
}
	
	// Find looks up the given @item in the list store by looping over the items
// until the first occurrence of @item. If @item was not found, then @position
// will not be set, and this method will return false.
// 
// If you need to compare the two items with a custom comparison function, use
// g_list_store_find_with_equal_func() with a custom Func instead.
	func (s ListStore) Find(item **externglib.Object) (uint, bool) {
var _arg0 *C.GListStore // out
var _arg1 C.gpointer // out
var _arg2 C.guint // in
var _cret C.gboolean // in

_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GObject)(unsafe.Pointer(item.Native()))

_cret = C.g_list_store_find(_arg0, _arg1, &_arg2)


var _position uint // out
var _ok bool // out

_position = (uint)(_arg2)
if _cret != 0 { _ok = true }

return _position, _ok
}
	
	// Insert inserts @item into @store at @position. @item must be of type
// Store:item-type or derived from it. @position must be smaller than the length
// of the list, or equal to it to append.
// 
// This function takes a ref on @item.
// 
// Use g_list_store_splice() to insert multiple items at the same time
// efficiently.
	func (s ListStore) Insert(position uint, item **externglib.Object)  {
var _arg0 *C.GListStore // out
var _arg1 C.guint // out
var _arg2 C.gpointer // out

_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)
_arg2 = (*C.GObject)(unsafe.Pointer(item.Native()))

C.g_list_store_insert(_arg0, _arg1, _arg2)
}
	
	// Remove removes the item from @store that is at @position. @position must be
// smaller than the current length of the list.
// 
// Use g_list_store_splice() to remove multiple items at the same time
// efficiently.
	func (s ListStore) Remove(position uint)  {
var _arg0 *C.GListStore // out
var _arg1 C.guint // out

_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)

C.g_list_store_remove(_arg0, _arg1)
}
	
	// RemoveAll removes all items from @store.
	func (s ListStore) RemoveAll()  {
var _arg0 *C.GListStore // out

_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))

C.g_list_store_remove_all(_arg0)
}
	
	// Splice changes @store by removing @n_removals items and adding @n_additions
// items to it. @additions must contain @n_additions items of type
// Store:item-type. nil is not permitted.
// 
// This function is more efficient than g_list_store_insert() and
// g_list_store_remove(), because it only emits Model::items-changed once for
// the change.
// 
// This function takes a ref on each item in @additions.
// 
// The parameters @position and @n_removals must be correct (ie: @position +
// @n_removals must be less than or equal to the length of the list at the time
// this function is called).
	func (s ListStore) Splice(position uint, nRemovals uint, additions []**externglib.Object)  {
var _arg0 *C.GListStore // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 *C.gpointer
var _arg4 C.guint

_arg0 = (*C.GListStore)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.guint)(nRemovals)
_arg4 = C.guint(len(additions))
_arg3 = (*C.gpointer)(C.malloc(C.ulong(len(additions)) * C.ulong(C.sizeof_GObject)))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(additions))
for i := range additions {
out[i] = (*C.GObject)(unsafe.Pointer(additions[i].Native()))
}
}

C.g_list_store_splice(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	


	// MemoryInputStream is a class for using arbitrary memory chunks as input for
// GIO streaming input operations.
// 
// As of GLib 2.34, InputStream implements InputStream.
	type MemoryInputStream struct {
		InputStream
		PollableInputStream
		Seekable
		
	}

	// MemoryInputStreamClass is an interface that the MemoryInputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MemoryInputStreamClass interface {
		gextras.Objector
		_memoryInputStream()
	}

	func (MemoryInputStream) _memoryInputStream() {}

	
	func marshalMemoryInputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMemoryInputStream(obj), nil
	}
	

	
	// NewMemoryInputStream creates a new empty InputStream.
	func NewMemoryInputStream() MemoryInputStream {
var _cret *C.GInputStream // in

_cret = C.g_memory_input_stream_new()


var _memoryInputStream MemoryInputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_memoryInputStream = MemoryInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
PollableInputStream: PollableInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Seekable: Seekable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _memoryInputStream
}
	

	


	// MemoryOutputStream is a class for using arbitrary memory chunks as output for
// GIO streaming output operations.
// 
// As of GLib 2.34, OutputStream trivially implements OutputStream: it always
// polls as ready.
	type MemoryOutputStream struct {
		OutputStream
		PollableOutputStream
		Seekable
		
	}

	// MemoryOutputStreamClass is an interface that the MemoryOutputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MemoryOutputStreamClass interface {
		gextras.Objector
		_memoryOutputStream()
	}

	func (MemoryOutputStream) _memoryOutputStream() {}

	
	func marshalMemoryOutputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMemoryOutputStream(obj), nil
	}
	

	
	// NewMemoryOutputStreamResizable creates a new OutputStream, using g_realloc()
// and g_free() for memory allocation.
	func NewMemoryOutputStreamResizable() MemoryOutputStream {
var _cret *C.GOutputStream // in

_cret = C.g_memory_output_stream_new_resizable()


var _memoryOutputStream MemoryOutputStream // out

_memoryOutputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MemoryOutputStream)

return _memoryOutputStream
}
	

	
	// DataSize returns the number of bytes from the start up to including the last
// byte written in the stream that has not been truncated away.
	func (o MemoryOutputStream) DataSize() uint {
var _arg0 *C.GMemoryOutputStream // out
var _cret C.gsize // in

_arg0 = (*C.GMemoryOutputStream)(unsafe.Pointer(o.Native()))

_cret = C.g_memory_output_stream_get_data_size(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	
	// Size gets the size of the currently allocated data area (available from
// g_memory_output_stream_get_data()).
// 
// You probably don't want to use this function on resizable streams. See
// g_memory_output_stream_get_data_size() instead. For resizable streams the
// size returned by this function is an implementation detail and may be change
// at any time in response to operations on the stream.
// 
// If the stream is fixed-sized (ie: no realloc was passed to
// g_memory_output_stream_new()) then this is the maximum size of the stream and
// further writes will return G_IO_ERROR_NO_SPACE.
// 
// In any case, if you want the number of bytes currently written to the stream,
// use g_memory_output_stream_get_data_size().
	func (o MemoryOutputStream) Size() uint {
var _arg0 *C.GMemoryOutputStream // out
var _cret C.gsize // in

_arg0 = (*C.GMemoryOutputStream)(unsafe.Pointer(o.Native()))

_cret = C.g_memory_output_stream_get_size(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	


	// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
// 
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
	type Menu struct {
		MenuModel
		
	}

	// MenuClass is an interface that the Menu class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuClass interface {
		gextras.Objector
		_menu()
	}

	func (Menu) _menu() {}

	
	func marshalMenu(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenu(obj), nil
	}
	

	
	// NewMenu creates a new #GMenu.
// 
// The new menu has no items.
	func NewMenu() Menu {
var _cret *C.GMenu // in

_cret = C.g_menu_new()


var _menu Menu // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_menu = Menu{
MenuModel: MenuModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menu
}
	

	
	// Append: convenience function for appending a normal menu item to the end of
// @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
	func (m Menu) Append(label string, detailedAction string)  {
var _arg0 *C.GMenu // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(detailedAction))
defer C.free(unsafe.Pointer(_arg2))

C.g_menu_append(_arg0, _arg1, _arg2)
}
	
	// AppendItem appends @item to the end of @menu.
// 
// See g_menu_insert_item() for more information.
	func (m Menu) AppendItem(item MenuItemClass)  {
var _arg0 *C.GMenu // out
var _arg1 *C.GMenuItem // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

C.g_menu_append_item(_arg0, _arg1)
}
	
	// AppendSection: convenience function for appending a section menu item to the
// end of @menu. Combine g_menu_item_new_section() and g_menu_insert_item() for
// a more flexible alternative.
	func (m Menu) AppendSection(label string, section MenuModelClass)  {
var _arg0 *C.GMenu // out
var _arg1 *C.gchar // out
var _arg2 *C.GMenuModel // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

C.g_menu_append_section(_arg0, _arg1, _arg2)
}
	
	// AppendSubmenu: convenience function for appending a submenu menu item to the
// end of @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item() for
// a more flexible alternative.
	func (m Menu) AppendSubmenu(label string, submenu MenuModelClass)  {
var _arg0 *C.GMenu // out
var _arg1 *C.gchar // out
var _arg2 *C.GMenuModel // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

C.g_menu_append_submenu(_arg0, _arg1, _arg2)
}
	
	// Freeze marks @menu as frozen.
// 
// After the menu is frozen, it is an error to attempt to make any changes to
// it. In effect this means that the #GMenu API must no longer be used.
// 
// This function causes g_menu_model_is_mutable() to begin returning false,
// which has some positive performance implications.
	func (m Menu) Freeze()  {
var _arg0 *C.GMenu // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

C.g_menu_freeze(_arg0)
}
	
	// Insert: convenience function for inserting a normal menu item into @menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
	func (m Menu) Insert(position int, label string, detailedAction string)  {
var _arg0 *C.GMenu // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(position)
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(detailedAction))
defer C.free(unsafe.Pointer(_arg3))

C.g_menu_insert(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertItem inserts @item into @menu.
// 
// The "insertion" is actually done by copying all of the attribute and link
// values of @item and using them to form a new item within @menu. As such,
// @item itself is not really inserted, but rather, a menu item that is exactly
// the same as the one presently described by @item.
// 
// This means that @item is essentially useless after the insertion occurs. Any
// changes you make to it are ignored unless it is inserted again (at which
// point its updated values will be copied).
// 
// You should probably just free @item once you're done.
// 
// There are many convenience functions to take care of common cases. See
// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as well
// as "prepend" and "append" variants of each of these functions.
	func (m Menu) InsertItem(position int, item MenuItemClass)  {
var _arg0 *C.GMenu // out
var _arg1 C.gint // out
var _arg2 *C.GMenuItem // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(position)
_arg2 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

C.g_menu_insert_item(_arg0, _arg1, _arg2)
}
	
	// InsertSection: convenience function for inserting a section menu item into
// @menu. Combine g_menu_item_new_section() and g_menu_insert_item() for a more
// flexible alternative.
	func (m Menu) InsertSection(position int, label string, section MenuModelClass)  {
var _arg0 *C.GMenu // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _arg3 *C.GMenuModel // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(position)
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

C.g_menu_insert_section(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertSubmenu: convenience function for inserting a submenu menu item into
// @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
// flexible alternative.
	func (m Menu) InsertSubmenu(position int, label string, submenu MenuModelClass)  {
var _arg0 *C.GMenu // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _arg3 *C.GMenuModel // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(position)
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

C.g_menu_insert_submenu(_arg0, _arg1, _arg2, _arg3)
}
	
	// Prepend: convenience function for prepending a normal menu item to the start
// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
	func (m Menu) Prepend(label string, detailedAction string)  {
var _arg0 *C.GMenu // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(detailedAction))
defer C.free(unsafe.Pointer(_arg2))

C.g_menu_prepend(_arg0, _arg1, _arg2)
}
	
	// PrependItem prepends @item to the start of @menu.
// 
// See g_menu_insert_item() for more information.
	func (m Menu) PrependItem(item MenuItemClass)  {
var _arg0 *C.GMenu // out
var _arg1 *C.GMenuItem // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

C.g_menu_prepend_item(_arg0, _arg1)
}
	
	// PrependSection: convenience function for prepending a section menu item to
// the start of @menu. Combine g_menu_item_new_section() and
// g_menu_insert_item() for a more flexible alternative.
	func (m Menu) PrependSection(label string, section MenuModelClass)  {
var _arg0 *C.GMenu // out
var _arg1 *C.gchar // out
var _arg2 *C.GMenuModel // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

C.g_menu_prepend_section(_arg0, _arg1, _arg2)
}
	
	// PrependSubmenu: convenience function for prepending a submenu menu item to
// the start of @menu. Combine g_menu_item_new_submenu() and
// g_menu_insert_item() for a more flexible alternative.
	func (m Menu) PrependSubmenu(label string, submenu MenuModelClass)  {
var _arg0 *C.GMenu // out
var _arg1 *C.gchar // out
var _arg2 *C.GMenuModel // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

C.g_menu_prepend_submenu(_arg0, _arg1, _arg2)
}
	
	// Remove removes an item from the menu.
// 
// @position gives the index of the item to remove.
// 
// It is an error if position is not in range the range from 0 to one less than
// the number of items in the menu.
// 
// It is not possible to remove items by identity since items are added to the
// menu simply by copying their links and attributes (ie: identity of the item
// itself is not preserved).
	func (m Menu) Remove(position int)  {
var _arg0 *C.GMenu // out
var _arg1 C.gint // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(position)

C.g_menu_remove(_arg0, _arg1)
}
	
	// RemoveAll removes all items in the menu.
	func (m Menu) RemoveAll()  {
var _arg0 *C.GMenu // out

_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

C.g_menu_remove_all(_arg0)
}
	


	// MenuAttributeIter is an opaque structure type. You must access it using the
// functions below.
	type MenuAttributeIter struct {
		**externglib.Object
		
	}

	// MenuAttributeIterClass is an interface that the MenuAttributeIter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuAttributeIterClass interface {
		gextras.Objector
		_menuAttributeIter()
	}

	func (MenuAttributeIter) _menuAttributeIter() {}

	
	func marshalMenuAttributeIter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuAttributeIter(obj), nil
	}
	

	

	
	// Name gets the name of the attribute at the current iterator position, as a
// string.
// 
// The iterator is not advanced.
	func (i MenuAttributeIter) Name() string {
var _arg0 *C.GMenuAttributeIter // out
var _cret *C.gchar // in

_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(i.Native()))

_cret = C.g_menu_attribute_iter_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// GetNext: this function combines g_menu_attribute_iter_next() with
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
// 
// First the iterator is advanced to the next (possibly first) attribute. If
// that fails, then false is returned and there are no other effects.
// 
// If successful, @name and @value are set to the name and value of the
// attribute that has just been advanced to. At this point,
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
// return the same values again.
// 
// The value returned in @name remains valid for as long as the iterator remains
// at the current position. The value returned in @value must be unreffed using
// g_variant_unref() when it is no longer in use.
	func (i MenuAttributeIter) GetNext() (string, *glib.Variant, bool) {
var _arg0 *C.GMenuAttributeIter // out
var _arg1 *C.gchar // in
var _value *glib.Variant
var _cret C.gboolean // in

_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(i.Native()))

_cret = C.g_menu_attribute_iter_get_next(_arg0, &_arg1, (**C.GVariant)(unsafe.Pointer(&_value)))


var _outName string // out

var _ok bool // out

_outName = C.GoString(_arg1)

if _cret != 0 { _ok = true }

return _outName, _value, _ok
}
	
	// Value gets the value of the attribute at the current iterator position.
// 
// The iterator is not advanced.
	func (i MenuAttributeIter) Value() *glib.Variant {
var _arg0 *C.GMenuAttributeIter // out
var _cret *C.GVariant // in

_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(i.Native()))

_cret = C.g_menu_attribute_iter_get_value(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// Next attempts to advance the iterator to the next (possibly first) attribute.
// 
// true is returned on success, or false if there are no more attributes.
// 
// You must call this function when you first acquire the iterator to advance it
// to the first attribute (and determine if the first attribute exists at all).
	func (i MenuAttributeIter) Next() bool {
var _arg0 *C.GMenuAttributeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(i.Native()))

_cret = C.g_menu_attribute_iter_next(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// MenuItem is an opaque structure type. You must access it using the functions
// below.
	type MenuItem struct {
		**externglib.Object
		
	}

	// MenuItemClass is an interface that the MenuItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuItemClass interface {
		gextras.Objector
		_menuItem()
	}

	func (MenuItem) _menuItem() {}

	
	func marshalMenuItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuItem(obj), nil
	}
	

	
	// NewMenuItem creates a new Item.
// 
// If @label is non-nil it is used to set the "label" attribute of the new item.
// 
// If @detailed_action is non-nil it is used to set the "action" and possibly
// the "target" attribute of the new item. See g_menu_item_set_detailed_action()
// for more information.
	func NewMenuItem(label string, detailedAction string) MenuItem {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret *C.GMenuItem // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(detailedAction))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_menu_item_new(_arg1, _arg2)


var _menuItem MenuItem // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_menuItem = MenuItem{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _menuItem
}
	
	// NewMenuItemFromModel creates a Item as an exact copy of an existing menu item
// in a Model.
// 
// @item_index must be valid (ie: be sure to call g_menu_model_get_n_items()
// first).
	func NewMenuItemFromModel(model MenuModelClass, itemIndex int) MenuItem {
var _arg1 *C.GMenuModel // out
var _arg2 C.gint // out
var _cret *C.GMenuItem // in

_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
_arg2 = (C.gint)(itemIndex)

_cret = C.g_menu_item_new_from_model(_arg1, _arg2)


var _menuItem MenuItem // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_menuItem = MenuItem{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _menuItem
}
	
	// NewMenuItemSection creates a new Item representing a section.
// 
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_section().
// 
// The effect of having one menu appear as a section of another is exactly as it
// sounds: the items from @section become a direct part of the menu that
// @menu_item is added to.
// 
// Visual separation is typically displayed between two non-empty sections. If
// @label is non-nil then it will be encorporated into this visual indication.
// This allows for labeled subsections of a menu.
// 
// As a simple example, consider a typical "Edit" menu from a simple program. It
// probably contains an "Undo" and "Redo" item, followed by a separator,
// followed by "Cut", "Copy" and "Paste".
// 
// This would be accomplished by creating three #GMenu instances. The first
// would be populated with the "Undo" and "Redo" items, and the second with the
// "Cut", "Copy" and "Paste" items. The first and second menus would then be
// added as submenus of the third. In XML format, this would look something like
// the following:
// 
//    <menu id='edit-menu'>
//      <section>
//        <item label='Undo'/>
//        <item label='Redo'/>
//      </section>
//      <section>
//        <item label='Cut'/>
//        <item label='Copy'/>
//        <item label='Paste'/>
//      </section>
//    </menu>
// 
// The following example is exactly equivalent. It is more illustrative of the
// exact relationship between the menus and items (keeping in mind that the
// 'link' element defines a new menu that is linked to the containing one). The
// style of the second example is more verbose and difficult to read (and
// therefore not recommended except for the purpose of understanding what is
// really going on).
// 
//    <menu id='edit-menu'>
//      <item>
//        <link name='section'>
//          <item label='Undo'/>
//          <item label='Redo'/>
//        </link>
//      </item>
//      <item>
//        <link name='section'>
//          <item label='Cut'/>
//          <item label='Copy'/>
//          <item label='Paste'/>
//        </link>
//      </item>
//    </menu>
	func NewMenuItemSection(label string, section MenuModelClass) MenuItem {
var _arg1 *C.gchar // out
var _arg2 *C.GMenuModel // out
var _cret *C.GMenuItem // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

_cret = C.g_menu_item_new_section(_arg1, _arg2)


var _menuItem MenuItem // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_menuItem = MenuItem{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _menuItem
}
	
	// NewMenuItemSubmenu creates a new Item representing a submenu.
// 
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_submenu().
	func NewMenuItemSubmenu(label string, submenu MenuModelClass) MenuItem {
var _arg1 *C.gchar // out
var _arg2 *C.GMenuModel // out
var _cret *C.GMenuItem // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

_cret = C.g_menu_item_new_submenu(_arg1, _arg2)


var _menuItem MenuItem // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_menuItem = MenuItem{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _menuItem
}
	

	
	// AttributeValue queries the named @attribute on @menu_item.
// 
// If @expected_type is specified and the attribute does not have this type, nil
// is returned. nil is also returned if the attribute simply does not exist.
	func (m MenuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
var _arg0 *C.GMenuItem // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariantType // out
var _cret *C.GVariant // in

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

_cret = C.g_menu_item_get_attribute_value(_arg0, _arg1, _arg2)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// Link queries the named @link on @menu_item.
	func (m MenuItem) Link(link string) MenuModel {
var _arg0 *C.GMenuItem // out
var _arg1 *C.gchar // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(link))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_menu_item_get_link(_arg0, _arg1)


var _menuModel MenuModel // out

_menuModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuModel)

return _menuModel
}
	
	// SetActionAndTargetValue sets or unsets the "action" and "target" attributes
// of @menu_item.
// 
// If @action is nil then both the "action" and "target" attributes are unset
// (and @target_value is ignored).
// 
// If @action is non-nil then the "action" attribute is set. The "target"
// attribute is then set to the value of @target_value if it is non-nil or unset
// otherwise.
// 
// Normal menu items (ie: not submenu, section or other custom item types) are
// expected to have the "action" attribute set to identify the action that they
// are associated with. The state type of the action help to determine the
// disposition of the menu item. See #GAction and Group for an overview of
// actions.
// 
// In general, clicking on the menu item will result in activation of the named
// action with the "target" attribute given as the parameter to the action
// invocation. If the "target" attribute is not set then the action is invoked
// with no parameter.
// 
// If the action has no state then the menu item is usually drawn as a plain
// menu item (ie: with no additional decoration).
// 
// If the action has a boolean state then the menu item is usually drawn as a
// toggle menu item (ie: with a checkmark or equivalent indication). The item
// should be marked as 'toggled' or 'checked' when the boolean state is true.
// 
// If the action has a string state then the menu item is usually drawn as a
// radio menu item (ie: with a radio bullet or equivalent indication). The item
// should be marked as 'selected' when the string state is equal to the value of
// the @target property.
// 
// See g_menu_item_set_action_and_target() or g_menu_item_set_detailed_action()
// for two equivalent calls that are probably more convenient for most uses.
	func (m MenuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant)  {
var _arg0 *C.GMenuItem // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(action))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(targetValue.Native()))

C.g_menu_item_set_action_and_target_value(_arg0, _arg1, _arg2)
}
	
	// SetAttributeValue sets or unsets an attribute on @menu_item.
// 
// The attribute to set or unset is specified by @attribute. This can be one of
// the standard attribute names G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, or a custom attribute name. Attribute names are
// restricted to lowercase characters, numbers and '-'. Furthermore, the names
// must begin with a lowercase character, must not end with a '-', and must not
// contain consecutive dashes.
// 
// must consist only of lowercase ASCII characters, digits and '-'.
// 
// If @value is non-nil then it is used as the new value for the attribute. If
// @value is nil then the attribute is unset. If the @value #GVariant is
// floating, it is consumed.
// 
// See also g_menu_item_set_attribute() for a more convenient way to do the
// same.
	func (m MenuItem) SetAttributeValue(attribute string, value *glib.Variant)  {
var _arg0 *C.GMenuItem // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

C.g_menu_item_set_attribute_value(_arg0, _arg1, _arg2)
}
	
	// SetDetailedAction sets the "action" and possibly the "target" attribute of
// @menu_item.
// 
// The format of @detailed_action is the same format parsed by
// g_action_parse_detailed_name().
// 
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but slightly
// less convenient) alternatives.
// 
// See also g_menu_item_set_action_and_target_value() for a description of the
// semantics of the action and target attributes.
	func (m MenuItem) SetDetailedAction(detailedAction string)  {
var _arg0 *C.GMenuItem // out
var _arg1 *C.gchar // out

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(detailedAction))
defer C.free(unsafe.Pointer(_arg1))

C.g_menu_item_set_detailed_action(_arg0, _arg1)
}
	
	// SetIcon sets (or unsets) the icon on @menu_item.
// 
// This call is the same as calling g_icon_serialize() and using the result as
// the value to g_menu_item_set_attribute_value() for G_MENU_ATTRIBUTE_ICON.
// 
// This API is only intended for use with "noun" menu items; things like
// bookmarks or applications in an "Open With" menu. Don't use it on menu items
// corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
// 
// If @icon is nil then the icon is unset.
	func (m MenuItem) SetIcon(icon Icon)  {
var _arg0 *C.GMenuItem // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.g_menu_item_set_icon(_arg0, _arg1)
}
	
	// SetLabel sets or unsets the "label" attribute of @menu_item.
// 
// If @label is non-nil it is used as the label for the menu item. If it is nil
// then the label attribute is unset.
	func (m MenuItem) SetLabel(label string)  {
var _arg0 *C.GMenuItem // out
var _arg1 *C.gchar // out

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.g_menu_item_set_label(_arg0, _arg1)
}
	
	// SetLink creates a link from @menu_item to @model if non-nil, or unsets it.
// 
// Links are used to establish a relationship between a particular menu item and
// another menu. For example, G_MENU_LINK_SUBMENU is used to associate a submenu
// with a particular menu item, and G_MENU_LINK_SECTION is used to create a
// section. Other types of link can be used, but there is no guarantee that
// clients will be able to make sense of them. Link types are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
	func (m MenuItem) SetLink(link string, model MenuModelClass)  {
var _arg0 *C.GMenuItem // out
var _arg1 *C.gchar // out
var _arg2 *C.GMenuModel // out

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(link))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

C.g_menu_item_set_link(_arg0, _arg1, _arg2)
}
	
	// SetSection sets or unsets the "section" link of @menu_item to @section.
// 
// The effect of having one menu appear as a section of another is exactly as it
// sounds: the items from @section become a direct part of the menu that
// @menu_item is added to. See g_menu_item_new_section() for more information
// about what it means for a menu item to be a section.
	func (m MenuItem) SetSection(section MenuModelClass)  {
var _arg0 *C.GMenuItem // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

C.g_menu_item_set_section(_arg0, _arg1)
}
	
	// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
// 
// If @submenu is non-nil, it is linked to. If it is nil then the link is unset.
// 
// The effect of having one menu appear as a submenu of another is exactly as it
// sounds.
	func (m MenuItem) SetSubmenu(submenu MenuModelClass)  {
var _arg0 *C.GMenuItem // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

C.g_menu_item_set_submenu(_arg0, _arg1)
}
	


	// MenuLinkIter is an opaque structure type. You must access it using the
// functions below.
	type MenuLinkIter struct {
		**externglib.Object
		
	}

	// MenuLinkIterClass is an interface that the MenuLinkIter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuLinkIterClass interface {
		gextras.Objector
		_menuLinkIter()
	}

	func (MenuLinkIter) _menuLinkIter() {}

	
	func marshalMenuLinkIter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuLinkIter(obj), nil
	}
	

	

	
	// Name gets the name of the link at the current iterator position.
// 
// The iterator is not advanced.
	func (i MenuLinkIter) Name() string {
var _arg0 *C.GMenuLinkIter // out
var _cret *C.gchar // in

_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(i.Native()))

_cret = C.g_menu_link_iter_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// GetNext: this function combines g_menu_link_iter_next() with
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
// 
// First the iterator is advanced to the next (possibly first) link. If that
// fails, then false is returned and there are no other effects.
// 
// If successful, @out_link and @value are set to the name and Model of the link
// that has just been advanced to. At this point, g_menu_link_iter_get_name()
// and g_menu_link_iter_get_value() will return the same values again.
// 
// The value returned in @out_link remains valid for as long as the iterator
// remains at the current position. The value returned in @value must be
// unreffed using g_object_unref() when it is no longer in use.
	func (i MenuLinkIter) GetNext() (string, MenuModel, bool) {
var _arg0 *C.GMenuLinkIter // out
var _arg1 *C.gchar // in
var _arg2 *C.GMenuModel // in
var _cret C.gboolean // in

_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(i.Native()))

_cret = C.g_menu_link_iter_get_next(_arg0, &_arg1, &_arg2)


var _outLink string // out
var _value MenuModel // out
var _ok bool // out

_outLink = C.GoString(_arg1)
_value = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg2))).(MenuModel)
if _cret != 0 { _ok = true }

return _outLink, _value, _ok
}
	
	// Value gets the linked Model at the current iterator position.
// 
// The iterator is not advanced.
	func (i MenuLinkIter) Value() MenuModel {
var _arg0 *C.GMenuLinkIter // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(i.Native()))

_cret = C.g_menu_link_iter_get_value(_arg0)


var _menuModel MenuModel // out

_menuModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuModel)

return _menuModel
}
	
	// Next attempts to advance the iterator to the next (possibly first) link.
// 
// true is returned on success, or false if there are no more links.
// 
// You must call this function when you first acquire the iterator to advance it
// to the first link (and determine if the first link exists at all).
	func (i MenuLinkIter) Next() bool {
var _arg0 *C.GMenuLinkIter // out
var _cret C.gboolean // in

_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(i.Native()))

_cret = C.g_menu_link_iter_next(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// MenuModel represents the contents of a menu -- an ordered list of menu items.
// The items are associated with actions, which can be activated through them.
// Items can be grouped in sections, and may have submenus associated with them.
// Both items and sections usually have some representation data, such as labels
// or icons. The type of the associated action (ie whether it is stateful, and
// what kind of state it has) can influence the representation of the item.
// 
// The conceptual model of menus in Model is hierarchical: sections and submenus
// are again represented by Models. Menus themselves do not define their own
// roles. Rather, the role of a particular Model is defined by the item that
// references it (or, in the case of the 'root' menu, is defined by the context
// in which it is used).
// 
// As an example, consider the visible portions of this menu:
// 
// 
// An example menu
// 
// ! (menu-example.png)
// 
// There are 8 "menus" visible in the screenshot: one menubar, two submenus and
// 5 sections:
// 
// - the toplevel menubar (containing 4 items) - the View submenu (containing 3
// sections) - the first section of the View submenu (containing 2 items) - the
// second section of the View submenu (containing 1 item) - the final section of
// the View submenu (containing 1 item) - the Highlight Mode submenu (containing
// 2 sections) - the Sources section (containing 2 items) - the Markup section
// (containing 2 items)
// 
// The [example][menu-model] illustrates the conceptual connection between these
// 8 menus. Each large block in the figure represents a menu and the smaller
// blocks within the large block represent items in that menu. Some items
// contain references to other menus.
// 
// 
// A menu example
// 
// ! (menu-model.png)
// 
// Notice that the separators visible in the [example][menu-example] appear
// nowhere in the [menu model][menu-model]. This is because separators are not
// explicitly represented in the menu model. Instead, a separator is inserted
// between any two non-empty sections of a menu. Section items can have labels
// just like any other item. In that case, a display system may show a section
// header instead of a separator.
// 
// The motivation for this abstract model of application controls is that modern
// user interfaces tend to make these controls available outside the
// application. Examples include global menus, jumplists, dash boards, etc. To
// support such uses, it is necessary to 'export' information about actions and
// their representation in menus, which is exactly what the [GActionGroup
// exporter][gio-GActionGroup-exporter] and the [GMenuModel
// exporter][gio-GMenuModel-exporter] do for Group and Model. The client-side
// counterparts to make use of the exported information are BusActionGroup and
// BusMenuModel.
// 
// The API of Model is very generic, with iterators for the attributes and links
// of an item, see g_menu_model_iterate_item_attributes() and
// g_menu_model_iterate_item_links(). The 'standard' attributes and link types
// have predefined names: G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, G_MENU_LINK_SECTION and G_MENU_LINK_SUBMENU.
// 
// Items in a Model represent active controls if they refer to an action that
// can get activated when the user interacts with the menu item. The reference
// to the action is encoded by the string id in the G_MENU_ATTRIBUTE_ACTION
// attribute. An action id uniquely identifies an action in an action group.
// Which action group(s) provide actions depends on the context in which the
// menu model is used. E.g. when the model is exported as the application menu
// of a Application, actions can be application-wide or window-specific (and
// thus come from two different action groups). By convention, the
// application-wide actions have names that start with "app.", while the names
// of window-specific actions start with "win.".
// 
// While a wide variety of stateful actions is possible, the following is the
// minimum that is expected to be supported by all users of exported menu
// information: - an action with no parameter type and no state - an action with
// no parameter type and boolean state - an action with string parameter type
// and string state
// 
// 
// Stateless
// 
// A stateless action typically corresponds to an ordinary menu item.
// 
// Selecting such a menu item will activate the action (with no parameter).
// 
// 
// Boolean State
// 
// An action with a boolean state will most typically be used with a "toggle" or
// "switch" menu item. The state can be set directly, but activating the action
// (with no parameter) results in the state being toggled.
// 
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as "checked" when the state is true.
// 
// 
// String Parameter and State
// 
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of radio
// menu items. Activating the action with a string parameter is equivalent to
// setting that parameter as the state.
// 
// Radio menu items, in addition to being associated with the action, will have
// a target value. Selecting that menu item will result in activation of the
// action with the target value as the parameter. The menu item should be
// rendered as "selected" when the state of the action is equal to the target
// value of the menu item.
	type MenuModel struct {
		**externglib.Object
		
	}

	// MenuModelClass is an interface that the MenuModel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuModelClass interface {
		gextras.Objector
		_menuModel()
	}

	func (MenuModel) _menuModel() {}

	
	func marshalMenuModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuModel(obj), nil
	}
	

	

	
	// ItemAttributeValue queries the item at position @item_index in @model for the
// attribute specified by @attribute.
// 
// If @expected_type is non-nil then it specifies the expected type of the
// attribute. If it is nil then any type will be accepted.
// 
// If the attribute exists and matches @expected_type (or if the expected type
// is unspecified) then the value is returned.
// 
// If the attribute does not exist, or does not match the expected type then nil
// is returned.
	func (m MenuModel) ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant {
var _arg0 *C.GMenuModel // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _arg3 *C.GVariantType // out
var _cret *C.GVariant // in

_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(itemIndex)
_arg2 = (*C.gchar)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

_cret = C.g_menu_model_get_item_attribute_value(_arg0, _arg1, _arg2, _arg3)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// ItemLink queries the item at position @item_index in @model for the link
// specified by @link.
// 
// If the link exists, the linked Model is returned. If the link does not exist,
// nil is returned.
	func (m MenuModel) ItemLink(itemIndex int, link string) MenuModel {
var _arg0 *C.GMenuModel // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(itemIndex)
_arg2 = (*C.gchar)(C.CString(link))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_menu_model_get_item_link(_arg0, _arg1, _arg2)


var _menuModel MenuModel // out

_menuModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuModel)

return _menuModel
}
	
	// NItems: query the number of items in @model.
	func (m MenuModel) NItems() int {
var _arg0 *C.GMenuModel // out
var _cret C.gint // in

_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))

_cret = C.g_menu_model_get_n_items(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsMutable queries if @model is mutable.
// 
// An immutable Model will never emit the Model::items-changed signal. Consumers
// of the model may make optimisations accordingly.
	func (m MenuModel) IsMutable() bool {
var _arg0 *C.GMenuModel // out
var _cret C.gboolean // in

_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))

_cret = C.g_menu_model_is_mutable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ItemsChanged requests emission of the Model::items-changed signal on @model.
// 
// This function should never be called except by Model subclasses. Any other
// calls to this function will very likely lead to a violation of the interface
// of the model.
// 
// The implementation should update its internal representation of the menu
// before emitting the signal. The implementation should further expect to
// receive queries about the new state of the menu (and particularly added menu
// items) while signal handlers are running.
// 
// The implementation must dispatch this call directly from a mainloop entry and
// not in response to calls -- particularly those from the Model API. Said
// another way: the menu must not change while user code is running without
// returning to the mainloop.
	func (m MenuModel) ItemsChanged(position int, removed int, added int)  {
var _arg0 *C.GMenuModel // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(position)
_arg2 = (C.gint)(removed)
_arg3 = (C.gint)(added)

C.g_menu_model_items_changed(_arg0, _arg1, _arg2, _arg3)
}
	
	// IterateItemAttributes creates a AttributeIter to iterate over the attributes
// of the item at position @item_index in @model.
// 
// You must free the iterator with g_object_unref() when you are done.
	func (m MenuModel) IterateItemAttributes(itemIndex int) MenuAttributeIter {
var _arg0 *C.GMenuModel // out
var _arg1 C.gint // out
var _cret *C.GMenuAttributeIter // in

_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(itemIndex)

_cret = C.g_menu_model_iterate_item_attributes(_arg0, _arg1)


var _menuAttributeIter MenuAttributeIter // out

_menuAttributeIter = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuAttributeIter)

return _menuAttributeIter
}
	
	// IterateItemLinks creates a LinkIter to iterate over the links of the item at
// position @item_index in @model.
// 
// You must free the iterator with g_object_unref() when you are done.
	func (m MenuModel) IterateItemLinks(itemIndex int) MenuLinkIter {
var _arg0 *C.GMenuModel // out
var _arg1 C.gint // out
var _cret *C.GMenuLinkIter // in

_arg0 = (*C.GMenuModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(itemIndex)

_cret = C.g_menu_model_iterate_item_links(_arg0, _arg1)


var _menuLinkIter MenuLinkIter // out

_menuLinkIter = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuLinkIter)

return _menuLinkIter
}
	


	// MountOperation provides a mechanism for interacting with the user. It can be
// used for authenticating mountable operations, such as loop mounting files,
// hard drive partitions or server locations. It can also be used to ask the
// user questions or show a list of applications preventing unmount or eject
// operations from completing.
// 
// Note that Operation is used for more than just #GMount objects  for example
// it is also used in g_drive_start() and g_drive_stop().
// 
// Users should instantiate a subclass of this that implements all the various
// callbacks to show the required dialogs, such as MountOperation. If no user
// interaction is desired (for example when automounting filesystems at login
// time), usually nil can be passed, see each method taking a Operation for
// details.
// 
// The term TCRYPT is used to mean compatible with TrueCrypt and VeraCrypt.
// TrueCrypt (https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system
// for encrypting file containers, partitions or whole disks, typically used
// with Windows. VeraCrypt (https://www.veracrypt.fr/) is a maintained fork of
// TrueCrypt with various improvements and auditing fixes.
	type MountOperation struct {
		**externglib.Object
		
	}

	// MountOperationClass is an interface that the MountOperation class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MountOperationClass interface {
		gextras.Objector
		_mountOperation()
	}

	func (MountOperation) _mountOperation() {}

	
	func marshalMountOperation(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMountOperation(obj), nil
	}
	

	
	// NewMountOperation creates a new mount operation.
	func NewMountOperation() MountOperation {
var _cret *C.GMountOperation // in

_cret = C.g_mount_operation_new()


var _mountOperation MountOperation // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_mountOperation = MountOperation{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _mountOperation
}
	

	
	// Anonymous: check to see whether the mount operation is being used for an
// anonymous user.
	func (o MountOperation) Anonymous() bool {
var _arg0 *C.GMountOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.g_mount_operation_get_anonymous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Choice gets a choice from the mount operation.
	func (o MountOperation) Choice() int {
var _arg0 *C.GMountOperation // out
var _cret C.int // in

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.g_mount_operation_get_choice(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Domain gets the domain of the mount operation.
	func (o MountOperation) Domain() string {
var _arg0 *C.GMountOperation // out
var _cret *C.char // in

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.g_mount_operation_get_domain(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IsTcryptHiddenVolume: check to see whether the mount operation is being used
// for a TCRYPT hidden volume.
	func (o MountOperation) IsTcryptHiddenVolume() bool {
var _arg0 *C.GMountOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.g_mount_operation_get_is_tcrypt_hidden_volume(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsTcryptSystemVolume: check to see whether the mount operation is being used
// for a TCRYPT system volume.
	func (o MountOperation) IsTcryptSystemVolume() bool {
var _arg0 *C.GMountOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.g_mount_operation_get_is_tcrypt_system_volume(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Password gets a password from the mount operation.
	func (o MountOperation) Password() string {
var _arg0 *C.GMountOperation // out
var _cret *C.char // in

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.g_mount_operation_get_password(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PasswordSave gets the state of saving passwords for the mount operation.
	func (o MountOperation) PasswordSave() PasswordSave {
var _arg0 *C.GMountOperation // out
var _cret C.GPasswordSave // in

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.g_mount_operation_get_password_save(_arg0)


var _passwordSave PasswordSave // out

_passwordSave = PasswordSave(_cret)

return _passwordSave
}
	
	// Pim gets a PIM from the mount operation.
	func (o MountOperation) Pim() uint {
var _arg0 *C.GMountOperation // out
var _cret C.guint // in

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.g_mount_operation_get_pim(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Username: get the user name from the mount operation.
	func (o MountOperation) Username() string {
var _arg0 *C.GMountOperation // out
var _cret *C.char // in

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.g_mount_operation_get_username(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Reply emits the Operation::reply signal.
	func (o MountOperation) Reply(result MountOperationResult)  {
var _arg0 *C.GMountOperation // out
var _arg1 C.GMountOperationResult // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.GMountOperationResult)(result)

C.g_mount_operation_reply(_arg0, _arg1)
}
	
	// SetAnonymous sets the mount operation to use an anonymous user if @anonymous
// is true.
	func (o MountOperation) SetAnonymous(anonymous bool)  {
var _arg0 *C.GMountOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
if anonymous { _arg1 = C.TRUE }

C.g_mount_operation_set_anonymous(_arg0, _arg1)
}
	
	// SetChoice sets a default choice for the mount operation.
	func (o MountOperation) SetChoice(choice int)  {
var _arg0 *C.GMountOperation // out
var _arg1 C.int // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.int)(choice)

C.g_mount_operation_set_choice(_arg0, _arg1)
}
	
	// SetDomain sets the mount operation's domain.
	func (o MountOperation) SetDomain(domain string)  {
var _arg0 *C.GMountOperation // out
var _arg1 *C.char // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.char)(C.CString(domain))
defer C.free(unsafe.Pointer(_arg1))

C.g_mount_operation_set_domain(_arg0, _arg1)
}
	
	// SetIsTcryptHiddenVolume sets the mount operation to use a hidden volume if
// @hidden_volume is true.
	func (o MountOperation) SetIsTcryptHiddenVolume(hiddenVolume bool)  {
var _arg0 *C.GMountOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
if hiddenVolume { _arg1 = C.TRUE }

C.g_mount_operation_set_is_tcrypt_hidden_volume(_arg0, _arg1)
}
	
	// SetIsTcryptSystemVolume sets the mount operation to use a system volume if
// @system_volume is true.
	func (o MountOperation) SetIsTcryptSystemVolume(systemVolume bool)  {
var _arg0 *C.GMountOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
if systemVolume { _arg1 = C.TRUE }

C.g_mount_operation_set_is_tcrypt_system_volume(_arg0, _arg1)
}
	
	// SetPassword sets the mount operation's password to @password.
	func (o MountOperation) SetPassword(password string)  {
var _arg0 *C.GMountOperation // out
var _arg1 *C.char // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.char)(C.CString(password))
defer C.free(unsafe.Pointer(_arg1))

C.g_mount_operation_set_password(_arg0, _arg1)
}
	
	// SetPasswordSave sets the state of saving passwords for the mount operation.
	func (o MountOperation) SetPasswordSave(save PasswordSave)  {
var _arg0 *C.GMountOperation // out
var _arg1 C.GPasswordSave // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.GPasswordSave)(save)

C.g_mount_operation_set_password_save(_arg0, _arg1)
}
	
	// SetPim sets the mount operation's PIM to @pim.
	func (o MountOperation) SetPim(pim uint)  {
var _arg0 *C.GMountOperation // out
var _arg1 C.guint // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.guint)(pim)

C.g_mount_operation_set_pim(_arg0, _arg1)
}
	
	// SetUsername sets the user name within @op to @username.
	func (o MountOperation) SetUsername(username string)  {
var _arg0 *C.GMountOperation // out
var _arg1 *C.char // out

_arg0 = (*C.GMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.char)(C.CString(username))
defer C.free(unsafe.Pointer(_arg1))

C.g_mount_operation_set_username(_arg0, _arg1)
}
	


	// NativeSocketAddress: a socket address of some unknown native type.
	type NativeSocketAddress struct {
		SocketAddress
		SocketConnectable
		
	}

	// NativeSocketAddressClass is an interface that the NativeSocketAddress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NativeSocketAddressClass interface {
		gextras.Objector
		_nativeSocketAddress()
	}

	func (NativeSocketAddress) _nativeSocketAddress() {}

	
	func marshalNativeSocketAddress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNativeSocketAddress(obj), nil
	}
	

	

	


	
	type NativeVolumeMonitor struct {
		VolumeMonitor
		
	}

	// NativeVolumeMonitorClass is an interface that the NativeVolumeMonitor class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NativeVolumeMonitorClass interface {
		gextras.Objector
		_nativeVolumeMonitor()
	}

	func (NativeVolumeMonitor) _nativeVolumeMonitor() {}

	
	func marshalNativeVolumeMonitor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNativeVolumeMonitor(obj), nil
	}
	

	

	


	// NetworkAddress provides an easy way to resolve a hostname and then attempt to
// connect to that host, handling the possibility of multiple IP addresses and
// multiple address families.
// 
// The enumeration results of resolved addresses *may* be cached as long as this
// object is kept alive which may have unexpected results if alive for too long.
// 
// See Connectable for an example of using the connectable interface.
	type NetworkAddress struct {
		**externglib.Object
		SocketConnectable
		
	}

	// NetworkAddressClass is an interface that the NetworkAddress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NetworkAddressClass interface {
		gextras.Objector
		_networkAddress()
	}

	func (NetworkAddress) _networkAddress() {}

	
	func marshalNetworkAddress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNetworkAddress(obj), nil
	}
	

	
	// NewNetworkAddress creates a new Connectable for connecting to the given
// @hostname and @port.
// 
// Note that depending on the configuration of the machine, a @hostname of
// `localhost` may refer to the IPv4 loopback address only, or to both IPv4 and
// IPv6; use g_network_address_new_loopback() to create a Address that is
// guaranteed to resolve to both addresses.
	func NewNetworkAddress(hostname string, port uint16) NetworkAddress {
var _arg1 *C.gchar // out
var _arg2 C.guint16 // out
var _cret *C.GSocketConnectable // in

_arg1 = (*C.gchar)(C.CString(hostname))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint16)(port)

_cret = C.g_network_address_new(_arg1, _arg2)


var _networkAddress NetworkAddress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_networkAddress = NetworkAddress{
Object: &externglib.Object{externglib.ToGObject(obj)},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _networkAddress
}
	
	// NewNetworkAddressLoopback creates a new Connectable for connecting to the
// local host over a loopback connection to the given @port. This is intended
// for use in connecting to local services which may be running on IPv4 or IPv6.
// 
// The connectable will return IPv4 and IPv6 loopback addresses, regardless of
// how the host resolves `localhost`. By contrast, g_network_address_new() will
// often only return an IPv4 address when resolving `localhost`, and an IPv6
// address for `localhost6`.
// 
// g_network_address_get_hostname() will always return `localhost` for a Address
// created with this constructor.
	func NewNetworkAddressLoopback(port uint16) NetworkAddress {
var _arg1 C.guint16 // out
var _cret *C.GSocketConnectable // in

_arg1 = (C.guint16)(port)

_cret = C.g_network_address_new_loopback(_arg1)


var _networkAddress NetworkAddress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_networkAddress = NetworkAddress{
Object: &externglib.Object{externglib.ToGObject(obj)},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _networkAddress
}
	

	
	// Hostname gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
// depending on what @addr was created with.
	func (a NetworkAddress) Hostname() string {
var _arg0 *C.GNetworkAddress // out
var _cret *C.gchar // in

_arg0 = (*C.GNetworkAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_network_address_get_hostname(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Port gets @addr's port number
	func (a NetworkAddress) Port() uint16 {
var _arg0 *C.GNetworkAddress // out
var _cret C.guint16 // in

_arg0 = (*C.GNetworkAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_network_address_get_port(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// Scheme gets @addr's scheme
	func (a NetworkAddress) Scheme() string {
var _arg0 *C.GNetworkAddress // out
var _cret *C.gchar // in

_arg0 = (*C.GNetworkAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_network_address_get_scheme(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	


	// NetworkService: like Address does with hostnames, Service provides an easy
// way to resolve a SRV record, and then attempt to connect to one of the hosts
// that implements that service, handling service priority/weighting, multiple
// IP addresses, and multiple address families.
// 
// See Target for more information about SRV records, and see Connectable for an
// example of using the connectable interface.
	type NetworkService struct {
		**externglib.Object
		SocketConnectable
		
	}

	// NetworkServiceClass is an interface that the NetworkService class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NetworkServiceClass interface {
		gextras.Objector
		_networkService()
	}

	func (NetworkService) _networkService() {}

	
	func marshalNetworkService(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNetworkService(obj), nil
	}
	

	
	// NewNetworkService creates a new Service representing the given @service,
// @protocol, and @domain. This will initially be unresolved; use the
// Connectable interface to resolve it.
	func NewNetworkService(service string, protocol string, domain string) NetworkService {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _cret *C.GSocketConnectable // in

_arg1 = (*C.gchar)(C.CString(service))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(protocol))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(domain))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.g_network_service_new(_arg1, _arg2, _arg3)


var _networkService NetworkService // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_networkService = NetworkService{
Object: &externglib.Object{externglib.ToGObject(obj)},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _networkService
}
	

	
	// Domain gets the domain that @srv serves. This might be either UTF-8 or
// ASCII-encoded, depending on what @srv was created with.
	func (s NetworkService) Domain() string {
var _arg0 *C.GNetworkService // out
var _cret *C.gchar // in

_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))

_cret = C.g_network_service_get_domain(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Protocol gets @srv's protocol name (eg, "tcp").
	func (s NetworkService) Protocol() string {
var _arg0 *C.GNetworkService // out
var _cret *C.gchar // in

_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))

_cret = C.g_network_service_get_protocol(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Scheme gets the URI scheme used to resolve proxies. By default, the service
// name is used as scheme.
	func (s NetworkService) Scheme() string {
var _arg0 *C.GNetworkService // out
var _cret *C.gchar // in

_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))

_cret = C.g_network_service_get_scheme(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Service gets @srv's service name (eg, "ldap").
	func (s NetworkService) Service() string {
var _arg0 *C.GNetworkService // out
var _cret *C.gchar // in

_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))

_cret = C.g_network_service_get_service(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetScheme set's the URI scheme used to resolve proxies. By default, the
// service name is used as scheme.
	func (s NetworkService) SetScheme(scheme string)  {
var _arg0 *C.GNetworkService // out
var _arg1 *C.gchar // out

_arg0 = (*C.GNetworkService)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(scheme))
defer C.free(unsafe.Pointer(_arg1))

C.g_network_service_set_scheme(_arg0, _arg1)
}
	


	// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
// 
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
// 
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
// 
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
// 
// A notification can be sent with g_application_send_notification().
	type Notification struct {
		**externglib.Object
		
	}

	// NotificationClass is an interface that the Notification class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NotificationClass interface {
		gextras.Objector
		_notification()
	}

	func (Notification) _notification() {}

	
	func marshalNotification(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNotification(obj), nil
	}
	

	
	// NewNotification creates a new #GNotification with @title as its title.
// 
// After populating @notification with more details, it can be sent to the
// desktop shell with g_application_send_notification(). Changing any properties
// after this call will not have any effect until resending @notification.
	func NewNotification(title string) Notification {
var _arg1 *C.gchar // out
var _cret *C.GNotification // in

_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_notification_new(_arg1)


var _notification Notification // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_notification = Notification{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _notification
}
	

	
	// AddButton adds a button to @notification that activates the action in
// @detailed_action when clicked. That action must be an application-wide action
// (starting with "app."). If @detailed_action contains a target, the action
// will be activated with that target as its parameter.
// 
// See g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
	func (n Notification) AddButton(label string, detailedAction string)  {
var _arg0 *C.GNotification // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out

_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(detailedAction))
defer C.free(unsafe.Pointer(_arg2))

C.g_notification_add_button(_arg0, _arg1, _arg2)
}
	
	// AddButtonWithTargetValue adds a button to @notification that activates
// @action when clicked. @action must be an application-wide action (it must
// start with "app.").
// 
// If @target is non-nil, @action will be activated with @target as its
// parameter.
	func (n Notification) AddButtonWithTargetValue(label string, action string, target *glib.Variant)  {
var _arg0 *C.GNotification // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.GVariant // out

_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(action))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GVariant)(unsafe.Pointer(target.Native()))

C.g_notification_add_button_with_target_value(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetBody sets the body of @notification to @body.
	func (n Notification) SetBody(body string)  {
var _arg0 *C.GNotification // out
var _arg1 *C.gchar // out

_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
_arg1 = (*C.gchar)(C.CString(body))
defer C.free(unsafe.Pointer(_arg1))

C.g_notification_set_body(_arg0, _arg1)
}
	
	// SetDefaultAction sets the default action of @notification to
// @detailed_action. This action is activated when the notification is clicked
// on.
// 
// The action in @detailed_action must be an application-wide action (it must
// start with "app."). If @detailed_action contains a target, the given action
// will be activated with that target as its parameter. See
// g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
// 
// When no default action is set, the application that the notification was sent
// on is activated.
	func (n Notification) SetDefaultAction(detailedAction string)  {
var _arg0 *C.GNotification // out
var _arg1 *C.gchar // out

_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
_arg1 = (*C.gchar)(C.CString(detailedAction))
defer C.free(unsafe.Pointer(_arg1))

C.g_notification_set_default_action(_arg0, _arg1)
}
	
	// SetDefaultActionAndTargetValue sets the default action of @notification to
// @action. This action is activated when the notification is clicked on. It
// must be an application-wide action (start with "app.").
// 
// If @target is non-nil, @action will be activated with @target as its
// parameter.
// 
// When no default action is set, the application that the notification was sent
// on is activated.
	func (n Notification) SetDefaultActionAndTargetValue(action string, target *glib.Variant)  {
var _arg0 *C.GNotification // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out

_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
_arg1 = (*C.gchar)(C.CString(action))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(target.Native()))

C.g_notification_set_default_action_and_target_value(_arg0, _arg1, _arg2)
}
	
	// SetIcon sets the icon of @notification to @icon.
	func (n Notification) SetIcon(icon Icon)  {
var _arg0 *C.GNotification // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.g_notification_set_icon(_arg0, _arg1)
}
	
	// SetPriority sets the priority of @notification to @priority. See Priority for
// possible values.
	func (n Notification) SetPriority(priority NotificationPriority)  {
var _arg0 *C.GNotification // out
var _arg1 C.GNotificationPriority // out

_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
_arg1 = (C.GNotificationPriority)(priority)

C.g_notification_set_priority(_arg0, _arg1)
}
	
	// SetTitle sets the title of @notification to @title.
	func (n Notification) SetTitle(title string)  {
var _arg0 *C.GNotification // out
var _arg1 *C.gchar // out

_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.g_notification_set_title(_arg0, _arg1)
}
	
	// SetUrgent: deprecated in favor of g_notification_set_priority().
	func (n Notification) SetUrgent(urgent bool)  {
var _arg0 *C.GNotification // out
var _arg1 C.gboolean // out

_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
if urgent { _arg1 = C.TRUE }

C.g_notification_set_urgent(_arg0, _arg1)
}
	


	// OutputStream has functions to write to a stream (g_output_stream_write()), to
// close a stream (g_output_stream_close()) and to flush pending writes
// (g_output_stream_flush()).
// 
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
// 
// See the documentation for OStream for details of thread safety of streaming
// APIs.
// 
// All of these functions have async variants too.
	type OutputStream struct {
		**externglib.Object
		
	}

	// OutputStreamClass is an interface that the OutputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type OutputStreamClass interface {
		gextras.Objector
		_outputStream()
	}

	func (OutputStream) _outputStream() {}

	
	func marshalOutputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapOutputStream(obj), nil
	}
	

	

	
	// ClearPending clears the pending flag on @stream.
	func (s OutputStream) ClearPending()  {
var _arg0 *C.GOutputStream // out

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

C.g_output_stream_clear_pending(_arg0)
}
	
	// Close closes the stream, releasing resources related to it.
// 
// Once the stream is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an error.
// 
// Closing a stream will automatically flush any outstanding buffers in the
// stream.
// 
// Streams will be automatically closed when the last reference is dropped, but
// you might want to call this function to make sure resources are released as
// early as possible.
// 
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for the
// individual stream for details.
// 
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to close will
// still return G_IO_ERROR_CLOSED for all operations. Still, it is important to
// check and report the error to the user, otherwise there might be a loss of
// data as all data might not be written.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. Cancelling a close will
// still leave the stream closed, but there some streams can use a faster close
// that doesn't block to e.g. check errors. On cancellation (as with any error)
// there is no guarantee that all written data will reach the target.
	func (s OutputStream) Close(cancellable CancellableClass) error {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_output_stream_close(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CloseFinish closes an output stream.
	func (s OutputStream) CloseFinish(result AsyncResult) error {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_output_stream_close_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Flush forces a write of all user-space buffered data for the given @stream.
// Will block during the operation. Closing the stream will implicitly cause a
// flush.
// 
// This function is optional for inherited classes.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (s OutputStream) Flush(cancellable CancellableClass) error {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_output_stream_flush(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// FlushFinish finishes flushing an output stream.
	func (s OutputStream) FlushFinish(result AsyncResult) error {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_output_stream_flush_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// HasPending checks if an output stream has pending actions.
	func (s OutputStream) HasPending() bool {
var _arg0 *C.GOutputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_output_stream_has_pending(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsClosed checks if an output stream has already been closed.
	func (s OutputStream) IsClosed() bool {
var _arg0 *C.GOutputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_output_stream_is_closed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsClosing checks if an output stream is being closed. This can be used inside
// e.g. a flush implementation to see if the flush (or other i/o operation) is
// called from within the closing operation.
	func (s OutputStream) IsClosing() bool {
var _arg0 *C.GOutputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_output_stream_is_closing(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetPending sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return false and set @error.
	func (s OutputStream) SetPending() error {
var _arg0 *C.GOutputStream // out
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

C.g_output_stream_set_pending(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Splice splices an input stream into an output stream.
	func (s OutputStream) Splice(source InputStreamClass, flags OutputStreamSpliceFlags, cancellable CancellableClass) (int, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GInputStream // out
var _arg2 C.GOutputStreamSpliceFlags // out
var _arg3 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GInputStream)(unsafe.Pointer(source.Native()))
_arg2 = (C.GOutputStreamSpliceFlags)(flags)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_output_stream_splice(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// SpliceFinish finishes an asynchronous stream splice operation.
	func (s OutputStream) SpliceFinish(result AsyncResult) (int, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GAsyncResult // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_output_stream_splice_finish(_arg0, _arg1, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// Write tries to write @count bytes from @buffer into the stream. Will block
// during the operation.
// 
// If count is 0, returns 0 and does nothing. A value of @count larger than
// G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
// 
// On success, the number of bytes written to the stream is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// on a partial I/O error, or if there is not enough storage in the stream. All
// writes block until at least one byte is written or an error occurs; 0 is
// never returned (unless @count is 0).
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
// 
// On error -1 is returned and @error is set accordingly.
	func (s OutputStream) Write(buffer []byte, cancellable CancellableClass) (int, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.void
var _arg2 C.gsize
var _arg3 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(buffer))
_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_output_stream_write(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// WriteAll tries to write @count bytes from @buffer into the stream. Will block
// during the operation.
// 
// This function is similar to g_output_stream_write(), except it tries to write
// as many bytes as requested, only stopping on an error.
// 
// On a successful write of @count bytes, true is returned, and @bytes_written
// is set to @count.
// 
// If there is an error during the operation false is returned and @error is set
// to indicate the error status.
// 
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns false (and sets @error) then @bytes_written
// will be set to the number of bytes that were successfully written before the
// error was encountered. This functionality is only available from C. If you
// need it from another language then you must write your own loop around
// g_output_stream_write().
	func (s OutputStream) WriteAll(buffer []byte, cancellable CancellableClass) (uint, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.void
var _arg2 C.gsize
var _arg3 C.gsize // in
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(buffer))
_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_output_stream_write_all(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

var _bytesWritten uint // out
var _goerr error // out

_bytesWritten = (uint)(_arg3)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesWritten, _goerr
}
	
	// WriteAllFinish finishes an asynchronous stream write operation started with
// g_output_stream_write_all_async().
// 
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns false (and sets @error) then @bytes_written
// will be set to the number of bytes that were successfully written before the
// error was encountered. This functionality is only available from C. If you
// need it from another language then you must write your own loop around
// g_output_stream_write_async().
	func (s OutputStream) WriteAllFinish(result AsyncResult) (uint, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gsize // in
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_output_stream_write_all_finish(_arg0, _arg1, &_arg2, &_cerr)

var _bytesWritten uint // out
var _goerr error // out

_bytesWritten = (uint)(_arg2)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesWritten, _goerr
}
	
	// WriteBytesFinish finishes a stream write-from-#GBytes operation.
	func (s OutputStream) WriteBytesFinish(result AsyncResult) (int, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GAsyncResult // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_output_stream_write_bytes_finish(_arg0, _arg1, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// WriteFinish finishes a stream write operation.
	func (s OutputStream) WriteFinish(result AsyncResult) (int, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GAsyncResult // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_output_stream_write_finish(_arg0, _arg1, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// Writev tries to write the bytes contained in the @n_vectors @vectors into the
// stream. Will block during the operation.
// 
// If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0 and
// does nothing.
// 
// On success, the number of bytes written to the stream is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// on a partial I/O error, or if there is not enough storage in the stream. All
// writes block until at least one byte is written or an error occurs; 0 is
// never returned (unless @n_vectors is 0 or the sum of all bytes in @vectors is
// 0).
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
// 
// Some implementations of g_output_stream_writev() may have limitations on the
// aggregate buffer size, and will return G_IO_ERROR_INVALID_ARGUMENT if these
// are exceeded. For example, when writing to a local file on UNIX platforms,
// the aggregate buffer size must not exceed G_MAXSSIZE bytes.
	func (s OutputStream) Writev(vectors []OutputVector, cancellable CancellableClass) (uint, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GOutputVector
var _arg2 C.gsize
var _arg3 C.gsize // in
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(vectors))
_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_output_stream_writev(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

var _bytesWritten uint // out
var _goerr error // out

_bytesWritten = (uint)(_arg3)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesWritten, _goerr
}
	
	// WritevAll tries to write the bytes contained in the @n_vectors @vectors into
// the stream. Will block during the operation.
// 
// This function is similar to g_output_stream_writev(), except it tries to
// write as many bytes as requested, only stopping on an error.
// 
// On a successful write of all @n_vectors vectors, true is returned, and
// @bytes_written is set to the sum of all the sizes of @vectors.
// 
// If there is an error during the operation false is returned and @error is set
// to indicate the error status.
// 
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns false (and sets @error) then @bytes_written
// will be set to the number of bytes that were successfully written before the
// error was encountered. This functionality is only available from C. If you
// need it from another language then you must write your own loop around
// g_output_stream_write().
// 
// The content of the individual elements of @vectors might be changed by this
// function.
	func (s OutputStream) WritevAll(vectors []OutputVector, cancellable CancellableClass) (uint, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GOutputVector
var _arg2 C.gsize
var _arg3 C.gsize // in
var _arg4 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(vectors))
_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_output_stream_writev_all(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

var _bytesWritten uint // out
var _goerr error // out

_bytesWritten = (uint)(_arg3)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesWritten, _goerr
}
	
	// WritevAllFinish finishes an asynchronous stream write operation started with
// g_output_stream_writev_all_async().
// 
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns false (and sets @error) then @bytes_written
// will be set to the number of bytes that were successfully written before the
// error was encountered. This functionality is only available from C. If you
// need it from another language then you must write your own loop around
// g_output_stream_writev_async().
	func (s OutputStream) WritevAllFinish(result AsyncResult) (uint, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gsize // in
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_output_stream_writev_all_finish(_arg0, _arg1, &_arg2, &_cerr)

var _bytesWritten uint // out
var _goerr error // out

_bytesWritten = (uint)(_arg2)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesWritten, _goerr
}
	
	// WritevFinish finishes a stream writev operation.
	func (s OutputStream) WritevFinish(result AsyncResult) (uint, error) {
var _arg0 *C.GOutputStream // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gsize // in
var _cerr *C.GError // in

_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_output_stream_writev_finish(_arg0, _arg1, &_arg2, &_cerr)

var _bytesWritten uint // out
var _goerr error // out

_bytesWritten = (uint)(_arg2)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesWritten, _goerr
}
	


	// Permission: a #GPermission represents the status of the caller's permission
// to perform a certain action.
// 
// You can query if the action is currently allowed and if it is possible to
// acquire the permission so that the action will be allowed in the future.
// 
// There is also an API to actually acquire the permission and one to release
// it.
// 
// As an example, a #GPermission might represent the ability for the user to
// write to a #GSettings object. This #GPermission object could then be used to
// decide if it is appropriate to show a "Click here to unlock" button in a
// dialog and to provide the mechanism to invoke when that button is clicked.
	type Permission struct {
		**externglib.Object
		
	}

	// PermissionClass is an interface that the Permission class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PermissionClass interface {
		gextras.Objector
		_permission()
	}

	func (Permission) _permission() {}

	
	func marshalPermission(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPermission(obj), nil
	}
	

	

	
	// Acquire attempts to acquire the permission represented by @permission.
// 
// The precise method by which this happens depends on the permission and the
// underlying authentication mechanism. A simple example is that a dialog may
// appear asking the user to enter their password.
// 
// You should check with g_permission_get_can_acquire() before calling this
// function.
// 
// If the permission is acquired then true is returned. Otherwise, false is
// returned and @error is set appropriately.
// 
// This call is blocking, likely for a very long time (in the case that user
// interaction is required). See g_permission_acquire_async() for the
// non-blocking version.
	func (p Permission) Acquire(cancellable CancellableClass) error {
var _arg0 *C.GPermission // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_permission_acquire(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// AcquireFinish collects the result of attempting to acquire the permission
// represented by @permission.
// 
// This is the second half of the asynchronous version of
// g_permission_acquire().
	func (p Permission) AcquireFinish(result AsyncResult) error {
var _arg0 *C.GPermission // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_permission_acquire_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Allowed gets the value of the 'allowed' property. This property is true if
// the caller currently has permission to perform the action that @permission
// represents the permission to perform.
	func (p Permission) Allowed() bool {
var _arg0 *C.GPermission // out
var _cret C.gboolean // in

_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))

_cret = C.g_permission_get_allowed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanAcquire gets the value of the 'can-acquire' property. This property is
// true if it is generally possible to acquire the permission by calling
// g_permission_acquire().
	func (p Permission) CanAcquire() bool {
var _arg0 *C.GPermission // out
var _cret C.gboolean // in

_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))

_cret = C.g_permission_get_can_acquire(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanRelease gets the value of the 'can-release' property. This property is
// true if it is generally possible to release the permission by calling
// g_permission_release().
	func (p Permission) CanRelease() bool {
var _arg0 *C.GPermission // out
var _cret C.gboolean // in

_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))

_cret = C.g_permission_get_can_release(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ImplUpdate: this function is called by the #GPermission implementation to
// update the properties of the permission. You should never call this function
// except from a #GPermission implementation.
// 
// GObject notify signals are generated, as appropriate.
	func (p Permission) ImplUpdate(allowed bool, canAcquire bool, canRelease bool)  {
var _arg0 *C.GPermission // out
var _arg1 C.gboolean // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out

_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
if allowed { _arg1 = C.TRUE }
if canAcquire { _arg2 = C.TRUE }
if canRelease { _arg3 = C.TRUE }

C.g_permission_impl_update(_arg0, _arg1, _arg2, _arg3)
}
	
	// Release attempts to release the permission represented by @permission.
// 
// The precise method by which this happens depends on the permission and the
// underlying authentication mechanism. In most cases the permission will be
// dropped immediately without further action.
// 
// You should check with g_permission_get_can_release() before calling this
// function.
// 
// If the permission is released then true is returned. Otherwise, false is
// returned and @error is set appropriately.
// 
// This call is blocking, likely for a very long time (in the case that user
// interaction is required). See g_permission_release_async() for the
// non-blocking version.
	func (p Permission) Release(cancellable CancellableClass) error {
var _arg0 *C.GPermission // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_permission_release(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ReleaseFinish collects the result of attempting to release the permission
// represented by @permission.
// 
// This is the second half of the asynchronous version of
// g_permission_release().
	func (p Permission) ReleaseFinish(result AsyncResult) error {
var _arg0 *C.GPermission // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GPermission)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_permission_release_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	// PropertyAction: a Action is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
// 
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
// 
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
// 
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
// 
// Flags types are not currently supported.
// 
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
// 
// Properties of #GVariant types are not currently supported.
// 
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
// 
// In all other cases, the parameter type will correspond to the type of the
// property.
// 
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
// 
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
// 
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
// 
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
	type PropertyAction struct {
		**externglib.Object
		Action
		
	}

	// PropertyActionClass is an interface that the PropertyAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PropertyActionClass interface {
		gextras.Objector
		_propertyAction()
	}

	func (PropertyAction) _propertyAction() {}

	
	func marshalPropertyAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPropertyAction(obj), nil
	}
	

	
	// NewPropertyAction creates a #GAction corresponding to the value of property
// @property_name on @object.
// 
// The property must be existent and readable and writable (and not
// construct-only).
// 
// This function takes a reference on @object and doesn't release it until the
// action is destroyed.
	func NewPropertyAction(name string, object **externglib.Object, propertyName string) PropertyAction {
var _arg1 *C.gchar // out
var _arg2 C.gpointer // out
var _arg3 *C.gchar // out
var _cret *C.GPropertyAction // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
_arg3 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.g_property_action_new(_arg1, _arg2, _arg3)


var _propertyAction PropertyAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_propertyAction = PropertyAction{
Object: &externglib.Object{externglib.ToGObject(obj)},
Action: Action{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _propertyAction
}
	

	


	// ProXYAddress: support for proxied SocketAddress.
	type ProXYAddress struct {
		InetSocketAddress
		SocketConnectable
		
	}

	// ProXYAddressClass is an interface that the ProXYAddress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ProXYAddressClass interface {
		gextras.Objector
		_proXYAddress()
	}

	func (ProXYAddress) _proXYAddress() {}

	
	func marshalProXYAddress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapProXYAddress(obj), nil
	}
	

	
	// NewProXYAddress creates a new Address for @inetaddr with @protocol that
// should tunnel through @dest_hostname and @dest_port.
// 
// (Note that this method doesn't set the Address:uri or
// Address:destination-protocol fields; use g_object_new() directly if you want
// to set those.)
	func NewProXYAddress(inetaddr InetAddressClass, port uint16, protocol string, destHostname string, destPort uint16, username string, password string) ProXYAddress {
var _arg1 *C.GInetAddress // out
var _arg2 C.guint16 // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _arg5 C.guint16 // out
var _arg6 *C.gchar // out
var _arg7 *C.gchar // out
var _cret *C.GSocketAddress // in

_arg1 = (*C.GInetAddress)(unsafe.Pointer(inetaddr.Native()))
_arg2 = (C.guint16)(port)
_arg3 = (*C.gchar)(C.CString(protocol))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(destHostname))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (C.guint16)(destPort)
_arg6 = (*C.gchar)(C.CString(username))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (*C.gchar)(C.CString(password))
defer C.free(unsafe.Pointer(_arg7))

_cret = C.g_proxy_address_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)


var _proxyAddress ProXYAddress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_proxyAddress = ProXYAddress{
InetSocketAddress: InetSocketAddress{
SocketAddress: SocketAddress{
Object: &externglib.Object{externglib.ToGObject(obj)},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _proxyAddress
}
	

	
	// DestinationHostname gets @proxy's destination hostname; that is, the name of
// the host that will be connected to via the proxy, not the name of the proxy
// itself.
	func (p ProXYAddress) DestinationHostname() string {
var _arg0 *C.GProxyAddress // out
var _cret *C.gchar // in

_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

_cret = C.g_proxy_address_get_destination_hostname(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// DestinationPort gets @proxy's destination port; that is, the port on the
// destination host that will be connected to via the proxy, not the port number
// of the proxy itself.
	func (p ProXYAddress) DestinationPort() uint16 {
var _arg0 *C.GProxyAddress // out
var _cret C.guint16 // in

_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

_cret = C.g_proxy_address_get_destination_port(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// DestinationProtocol gets the protocol that is being spoken to the destination
// server; eg, "http" or "ftp".
	func (p ProXYAddress) DestinationProtocol() string {
var _arg0 *C.GProxyAddress // out
var _cret *C.gchar // in

_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

_cret = C.g_proxy_address_get_destination_protocol(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Password gets @proxy's password.
	func (p ProXYAddress) Password() string {
var _arg0 *C.GProxyAddress // out
var _cret *C.gchar // in

_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

_cret = C.g_proxy_address_get_password(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Protocol gets @proxy's protocol. eg, "socks" or "http"
	func (p ProXYAddress) Protocol() string {
var _arg0 *C.GProxyAddress // out
var _cret *C.gchar // in

_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

_cret = C.g_proxy_address_get_protocol(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// URI gets the proxy URI that @proxy was constructed from.
	func (p ProXYAddress) URI() string {
var _arg0 *C.GProxyAddress // out
var _cret *C.gchar // in

_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

_cret = C.g_proxy_address_get_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Username gets @proxy's username.
	func (p ProXYAddress) Username() string {
var _arg0 *C.GProxyAddress // out
var _cret *C.gchar // in

_arg0 = (*C.GProxyAddress)(unsafe.Pointer(p.Native()))

_cret = C.g_proxy_address_get_username(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	


	// ProXYAddressEnumerator is a wrapper around AddressEnumerator which takes the
// Address instances returned by the AddressEnumerator and wraps them in Address
// instances, using the given AddressEnumerator:proxy-resolver.
// 
// This enumerator will be returned (for example, by
// g_socket_connectable_enumerate()) as appropriate when a proxy is configured;
// there should be no need to manually wrap a AddressEnumerator instance with
// one.
	type ProXYAddressEnumerator struct {
		SocketAddressEnumerator
		
	}

	// ProXYAddressEnumeratorClass is an interface that the ProXYAddressEnumerator class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ProXYAddressEnumeratorClass interface {
		gextras.Objector
		_proXYAddressEnumerator()
	}

	func (ProXYAddressEnumerator) _proXYAddressEnumerator() {}

	
	func marshalProXYAddressEnumerator(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapProXYAddressEnumerator(obj), nil
	}
	

	

	


	// Resolver provides cancellable synchronous and asynchronous DNS resolution,
// for hostnames (g_resolver_lookup_by_address(), g_resolver_lookup_by_name()
// and their async variants) and SRV (service) records
// (g_resolver_lookup_service()).
// 
// Address and Service provide wrappers around #GResolver functionality that
// also implement Connectable, making it easy to connect to a remote
// host/service.
	type Resolver struct {
		**externglib.Object
		
	}

	// ResolverClass is an interface that the Resolver class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ResolverClass interface {
		gextras.Objector
		_resolver()
	}

	func (Resolver) _resolver() {}

	
	func marshalResolver(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapResolver(obj), nil
	}
	

	

	
	// LookupByAddress: synchronously reverse-resolves @address to determine its
// associated hostname.
// 
// If the DNS resolution fails, @error (if non-nil) will be set to a value from
// Error.
// 
// If @cancellable is non-nil, it can be used to cancel the operation, in which
// case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	func (r Resolver) LookupByAddress(address InetAddressClass, cancellable CancellableClass) (string, error) {
var _arg0 *C.GResolver // out
var _arg1 *C.GInetAddress // out
var _arg2 *C.GCancellable // out
var _cret *C.gchar // in
var _cerr *C.GError // in

_arg0 = (*C.GResolver)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GInetAddress)(unsafe.Pointer(address.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_resolver_lookup_by_address(_arg0, _arg1, _arg2, &_cerr)


var _utf8 string // out
var _goerr error // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8, _goerr
}
	
	// LookupByAddressFinish retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
// 
// If the DNS resolution failed, @error (if non-nil) will be set to a value from
// Error. If the operation was cancelled, @error will be set to
// G_IO_ERROR_CANCELLED.
	func (r Resolver) LookupByAddressFinish(result AsyncResult) (string, error) {
var _arg0 *C.GResolver // out
var _arg1 *C.GAsyncResult // out
var _cret *C.gchar // in
var _cerr *C.GError // in

_arg0 = (*C.GResolver)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_resolver_lookup_by_address_finish(_arg0, _arg1, &_cerr)


var _utf8 string // out
var _goerr error // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8, _goerr
}
	
	// SetDefault sets @resolver to be the application's default resolver (reffing
// @resolver, and unreffing the previous default resolver, if any). Future calls
// to g_resolver_get_default() will return this resolver.
// 
// This can be used if an application wants to perform any sort of DNS caching
// or "pinning"; it can implement its own #GResolver that calls the original
// default resolver for DNS operations, and implements its own cache policies on
// top of that, and then set itself as the default resolver for all later code
// to use.
	func (r Resolver) SetDefault()  {
var _arg0 *C.GResolver // out

_arg0 = (*C.GResolver)(unsafe.Pointer(r.Native()))

C.g_resolver_set_default(_arg0)
}
	


	// Settings: the #GSettings class provides a convenient API for storing and
// retrieving application settings.
// 
// Reads and writes can be considered to be non-blocking. Reading settings with
// #GSettings is typically extremely fast: on approximately the same order of
// magnitude (but slower than) a Table lookup. Writing settings is also
// extremely fast in terms of time to return to your application, but can be
// extremely expensive for other threads and other processes. Many settings
// backends (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings a lot of
// work can be avoided. For dconf, the D-Bus service doesn't even need to be
// started in this case. For this reason, you should only ever modify #GSettings
// keys in response to explicit user action. Particular care should be paid to
// ensure that modifications are not made during startup -- for example, when
// setting the initial value of preferences widgets. The built-in
// g_settings_bind() functionality is careful not to write settings in response
// to notify signals as a result of modifications that it makes to widgets.
// 
// When creating a GSettings instance, you have to specify a schema that
// describes the keys in your settings and their types and default values, as
// well as some other information.
// 
// Normally, a schema has a fixed path that determines where the settings are
// stored in the conceptual global tree of settings. However, schemas can also
// be '[relocatable][gsettings-relocatable]', i.e. not equipped with a fixed
// path. This is useful e.g. when the schema describes an 'account', and you
// want to be able to store a arbitrary number of accounts.
// 
// Paths must start with and end with a forward slash character ('/') and must
// not contain two sequential slash characters. Paths should be chosen based on
// a domain name associated with the program or library to which the settings
// belong. Examples of paths are "/org/gtk/settings/file-chooser/" and
// "/ca/desrt/dconf-editor/". Paths should not start with "/apps/", "/desktop/"
// or "/system/" as they often did in GConf.
// 
// Unlike other configuration systems (like GConf), GSettings does not restrict
// keys to basic types like strings and numbers. GSettings stores values as
// #GVariant, and allows any Type for keys. Key names are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
// 
// Similar to GConf, the default values in GSettings schemas can be localized,
// but the localized values are stored in gettext catalogs and looked up with
// the domain that is specified in the `gettext-domain` attribute of the
// <schemalist> or <schema> elements and the category that is specified in the
// `l10n` attribute of the <default> element. The string which is translated
// includes all text in the <default> element, including any surrounding
// quotation marks.
// 
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the <default> element  it is recommended to
// add these comments to aid translators understand the meaning and implications
// of the default value. An optional translation `context` attribute can be set
// on the <default> element to disambiguate multiple defaults which use the same
// string.
// 
// For example:
// 
//    <!-- Translators: A list of words which are not allowed to be typed, in
//         GVariant serialization syntax.
//         See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
//    <default l10n='messages' context='Banned words'>['bad', 'words']</default>
// 
// Translations of default values must remain syntactically valid serialized
// #GVariants (e.g. retaining any surrounding quotation marks) or runtime errors
// will occur.
// 
// GSettings uses schemas in a compact binary form that is created by the
// [glib-compile-schemas][glib-compile-schemas] utility. The input is a schema
// description in an XML format.
// 
// A DTD for the gschema XML format can be found here: gschema.dtd
// (https://git.gnome.org/browse/glib/tree/gio/gschema.dtd)
// 
// The [glib-compile-schemas][glib-compile-schemas] tool expects schema files to
// have the extension `.gschema.xml`.
// 
// At runtime, schemas are identified by their id (as specified in the id
// attribute of the <schema> element). The convention for schema ids is to use a
// dotted name, similar in style to a D-Bus bus name, e.g.
// "org.gnome.SessionManager". In particular, if the settings are for a specific
// service that owns a D-Bus bus name, the D-Bus bus name and schema id should
// match. For schemas which deal with settings not associated with one named
// application, the id should not use StudlyCaps, e.g.
// "org.gnome.font-rendering".
// 
// In addition to #GVariant types, keys can have types that have enumerated
// types. These can be described by a <choice>, <enum> or <flags> element, as
// seen in the [example][schema-enumerated]. The underlying type of such a key
// is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
// g_settings_get_flags(), g_settings_set_flags() access the numeric values
// corresponding to the string value of enum and flags keys.
// 
// An example for default value:
// 
//    <schemalist>
//      <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
// 
//        <key name="greeting" type="s">
//          <default l10n="messages">"Hello, earthlings"</default>
//          <summary>A greeting</summary>
//          <description>
//            Greeting of the invading martians
//          </description>
//        </key>
// 
//        <key name="box" type="(ii)">
//          <default>(20,30)</default>
//        </key>
// 
//        <key name="empty-string" type="s">
//          <default>""</default>
//          <summary>Empty strings have to be provided in GVariant form</summary>
//        </key>
// 
//      </schema>
//    </schemalist>
// 
// An example for ranges, choices and enumerated types:
// 
//    <schemalist>
// 
//      <enum id="org.gtk.Test.myenum">
//        <value nick="first" value="1"/>
//        <value nick="second" value="2"/>
//      </enum>
// 
//      <flags id="org.gtk.Test.myflags">
//        <value nick="flag1" value="1"/>
//        <value nick="flag2" value="2"/>
//        <value nick="flag3" value="4"/>
//      </flags>
// 
//      <schema id="org.gtk.Test">
// 
//        <key name="key-with-range" type="i">
//          <range min="1" max="100"/>
//          <default>10</default>
//        </key>
// 
//        <key name="key-with-choices" type="s">
//          <choices>
//            <choice value='Elisabeth'/>
//            <choice value='Annabeth'/>
//            <choice value='Joe'/>
//          </choices>
//          <aliases>
//            <alias value='Anna' target='Annabeth'/>
//            <alias value='Beth' target='Elisabeth'/>
//          </aliases>
//          <default>'Joe'</default>
//        </key>
// 
//        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
//          <default>'first'</default>
//        </key>
// 
//        <key name='flags-key' flags='org.gtk.Test.myflags'>
//          <default>["flag1","flag2"]</default>
//        </key>
//      </schema>
//    </schemalist>
// 
// 
// Vendor overrides
// 
// Default values are defined in the schemas that get installed by an
// application. Sometimes, it is necessary for a vendor or distributor to adjust
// these defaults. Since patching the XML source for the schema is inconvenient
// and error-prone, [glib-compile-schemas][glib-compile-schemas] reads so-called
// vendor override' files. These are keyfiles in the same directory as the XML
// schema sources which can override default values. The schema id serves as the
// group name in the key file, and the values are expected in serialized
// GVariant form, as in the following example:
// 
//    [org.gtk.Example]
//    key1='string'
//    key2=1.5
// 
// glib-compile-schemas expects schema files to have the extension
// `.gschema.override`.
// 
// 
// Binding
// 
// A very convenient feature of GSettings lets you bind #GObject properties
// directly to settings, using g_settings_bind(). Once a GObject property has
// been bound to a setting, changes on either side are automatically propagated
// to the other side. GSettings handles details like mapping between GObject and
// GVariant types, and preventing infinite cycles.
// 
// This makes it very easy to hook up a preferences dialog to the underlying
// settings. To make this even more convenient, GSettings looks for a boolean
// property with the name "sensitivity" and automatically binds it to the
// writability of the bound setting. If this 'magic' gets in the way, it can be
// suppressed with the SETTINGS_BIND_NO_SENSITIVITY flag.
// 
// 
// Relocatable schemas
// 
// A relocatable schema is one with no `path` attribute specified on its
// <schema> element. By using g_settings_new_with_path(), a #GSettings object
// can be instantiated for a relocatable schema, assigning a path to the
// instance. Paths passed to g_settings_new_with_path() will typically be
// constructed dynamically from a constant prefix plus some form of instance
// identifier; but they must still be valid GSettings paths. Paths could also be
// constant and used with a globally installed schema originating from a
// dependency library.
// 
// For example, a relocatable schema could be used to store geometry information
// for different windows in an application. If the schema ID was
// `org.foo.MyApp.Window`, it could be instantiated for paths
// `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
// `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known they
// can be specified as <child> elements in the parent schema, e.g.:
// 
//    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
//      <child name="main" schema="org.foo.MyApp.Window"/>
//    </schema>
// 
// 
// Build system integration
// 
// GSettings comes with autotools integration to simplify compiling and
// installing schemas. To add GSettings support to an application, add the
// following to your `configure.ac`:
// 
//    GLIB_GSETTINGS
// 
// In the appropriate `Makefile.am`, use the following snippet to compile and
// install the named schema:
// 
//    gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
//    EXTRA_DIST = $(gsettings_SCHEMAS)
// 
//    @GSETTINGS_RULES@
// 
// No changes are needed to the build system to mark a schema XML file for
// translation. Assuming it sets the `gettext-domain` attribute, a schema may be
// marked for translation by adding it to `POTFILES.in`, assuming gettext 0.19
// is in use (the preferred method for translation):
// 
//    data/org.foo.MyApp.gschema.xml
// 
// Alternatively, if intltool 0.50.1 is in use:
// 
//    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
// 
// GSettings will use gettext to look up translations for the <summary> and
// <description> elements, and also any <default> elements which have a `l10n`
// attribute set. Translations must not be included in the `.gschema.xml` file
// by the build system, for example by using intltool XML rules with a
// `.gschema.xml.in` template.
// 
// If an enumerated type defined in a C header file is to be used in a GSettings
// schema, it can either be defined manually using an <enum> element in the
// schema XML, or it can be extracted automatically from the C header. This
// approach is preferred, as it ensures the two representations are always
// synchronised. To do so, add the following to the relevant `Makefile.am`:
// 
//    gsettings_ENUM_NAMESPACE = org.foo.MyApp
//    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
// 
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
	type Settings struct {
		**externglib.Object
		
	}

	// SettingsClass is an interface that the Settings class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SettingsClass interface {
		gextras.Objector
		_settings()
	}

	func (Settings) _settings() {}

	
	func marshalSettings(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSettings(obj), nil
	}
	

	
	// NewSettings creates a new #GSettings object with the schema specified by
// @schema_id.
// 
// It is an error for the schema to not exist: schemas are an essential part of
// a program, as they provide type information. If schemas need to be
// dynamically loaded (for example, from an optional runtime dependency),
// g_settings_schema_source_lookup() can be used to test for their existence
// before loading them.
// 
// Signals on the newly created #GSettings object will be dispatched via the
// thread-default Context in effect at the time of the call to g_settings_new().
// The new #GSettings will hold a reference on the context. See
// g_main_context_push_thread_default().
	func NewSettings(schemaId string) Settings {
var _arg1 *C.gchar // out
var _cret *C.GSettings // in

_arg1 = (*C.gchar)(C.CString(schemaId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_new(_arg1)


var _settings Settings // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_settings = Settings{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _settings
}
	
	// NewSettingsWithPath creates a new #GSettings object with the relocatable
// schema specified by @schema_id and a given path.
// 
// You only need to do this if you want to directly create a settings object
// with a schema that doesn't have a specified path of its own. That's quite
// rare.
// 
// It is a programmer error to call this function for a schema that has an
// explicitly specified path.
// 
// It is a programmer error if @path is not a valid path. A valid path begins
// and ends with '/' and does not contain two consecutive '/' characters.
	func NewSettingsWithPath(schemaId string, path string) Settings {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret *C.GSettings // in

_arg1 = (*C.gchar)(C.CString(schemaId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_settings_new_with_path(_arg1, _arg2)


var _settings Settings // out

_settings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Settings)

return _settings
}
	

	
	// Apply applies any changes that have been made to the settings. This function
// does nothing unless @settings is in 'delay-apply' mode; see
// g_settings_delay(). In the normal case settings are always applied
// immediately.
	func (s Settings) Apply()  {
var _arg0 *C.GSettings // out

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

C.g_settings_apply(_arg0)
}
	
	// Bind: create a binding between the @key in the @settings object and the
// property @property of @object.
// 
// The binding uses the default GIO mapping functions to map between the
// settings and property values. These functions handle booleans, numeric types
// and string types in a straightforward way. Use g_settings_bind_with_mapping()
// if you need a custom mapping, or map between types that are not supported by
// the default mapping functions.
// 
// Unless the @flags include G_SETTINGS_BIND_NO_SENSITIVITY, this function also
// establishes a binding between the writability of @key and the "sensitive"
// property of @object (if @object has a boolean property by that name). See
// g_settings_bind_writable() for more details about writable bindings.
// 
// Note that the lifecycle of the binding is tied to @object, and that you can
// have only one binding per object property. If you bind the same property
// twice on the same object, the second binding overrides the first one.
	func (s Settings) Bind(key string, object **externglib.Object, property string, flags SettingsBindFlags)  {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gpointer // out
var _arg3 *C.gchar // out
var _arg4 C.GSettingsBindFlags // out

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
_arg3 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (C.GSettingsBindFlags)(flags)

C.g_settings_bind(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// BindWritable: create a binding between the writability of @key in the
// @settings object and the property @property of @object. The property must be
// boolean; "sensitive" or "visible" properties of widgets are the most likely
// candidates.
// 
// Writable bindings are always uni-directional; changes of the writability of
// the setting will be propagated to the object property, not the other way.
// 
// When the @inverted argument is true, the binding inverts the value as it
// passes from the setting to the object, i.e. @property will be set to true if
// the key is not writable.
// 
// Note that the lifecycle of the binding is tied to @object, and that you can
// have only one binding per object property. If you bind the same property
// twice on the same object, the second binding overrides the first one.
	func (s Settings) BindWritable(key string, object **externglib.Object, property string, inverted bool)  {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gpointer // out
var _arg3 *C.gchar // out
var _arg4 C.gboolean // out

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
_arg3 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg3))
if inverted { _arg4 = C.TRUE }

C.g_settings_bind_writable(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// CreateAction creates a #GAction corresponding to a given #GSettings key.
// 
// The action has the same name as the key.
// 
// The value of the key becomes the state of the action and the action is
// enabled when the key is writable. Changing the state of the action results in
// the key being written to. Changes to the value or writability of the key
// cause appropriate change notifications to be emitted for the action.
// 
// For boolean-valued keys, action activations take no parameter and result in
// the toggling of the value. For all other types, activations take the new
// value for the key (which must have the correct type).
	func (s Settings) CreateAction(key string) Action {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret *C.GAction // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_create_action(_arg0, _arg1)


var _action Action // out

_action = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Action)

return _action
}
	
	// Delay changes the #GSettings object into 'delay-apply' mode. In this mode,
// changes to @settings are not immediately propagated to the backend, but kept
// locally until g_settings_apply() is called.
	func (s Settings) Delay()  {
var _arg0 *C.GSettings // out

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

C.g_settings_delay(_arg0)
}
	
	// Boolean gets the value that is stored at @key in @settings.
// 
// A convenience variant of g_settings_get() for booleans.
// 
// It is a programmer error to give a @key that isn't specified as having a
// boolean type in the schema for @settings.
	func (s Settings) Boolean(key string) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_boolean(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Child creates a child settings object which has a base path of
// `base-path/@name`, where `base-path` is the base path of @settings.
// 
// The schema for the child settings object must have been declared in the
// schema of @settings using a <child> element.
	func (s Settings) Child(name string) Settings {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret *C.GSettings // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_child(_arg0, _arg1)


var _ret Settings // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Settings)

return _ret
}
	
	// DefaultValue gets the "default value" of a key.
// 
// This is the value that would be read if g_settings_reset() were to be called
// on the key.
// 
// Note that this may be a different value than returned by
// g_settings_schema_key_get_default_value() if the system administrator has
// provided a default value.
// 
// Comparing the return values of g_settings_get_default_value() and
// g_settings_get_value() is not sufficient for determining if a value has been
// set because the user may have explicitly set the value to something that
// happens to be equal to the default. The difference here is that if the
// default changes in the future, the user's key will still be set.
// 
// This function may be useful for adding an indication to a UI of what the
// default value was before the user set it.
// 
// It is a programmer error to give a @key that isn't contained in the schema
// for @settings.
	func (s Settings) DefaultValue(key string) *glib.Variant {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret *C.GVariant // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_default_value(_arg0, _arg1)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// Double gets the value that is stored at @key in @settings.
// 
// A convenience variant of g_settings_get() for doubles.
// 
// It is a programmer error to give a @key that isn't specified as having a
// 'double' type in the schema for @settings.
	func (s Settings) Double(key string) float64 {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret C.gdouble // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_double(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Enum gets the value that is stored in @settings for @key and converts it to
// the enum value that it represents.
// 
// In order to use this function the type of the value must be a string and it
// must be marked in the schema file as an enumerated type.
// 
// It is a programmer error to give a @key that isn't contained in the schema
// for @settings or is not marked as an enumerated type.
// 
// If the value stored in the configuration database is not a valid value for
// the enumerated type then this function will return the default value.
	func (s Settings) Enum(key string) int {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret C.gint // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_enum(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Flags gets the value that is stored in @settings for @key and converts it to
// the flags value that it represents.
// 
// In order to use this function the type of the value must be an array of
// strings and it must be marked in the schema file as a flags type.
// 
// It is a programmer error to give a @key that isn't contained in the schema
// for @settings or is not marked as a flags type.
// 
// If the value stored in the configuration database is not a valid value for
// the flags type then this function will return the default value.
	func (s Settings) Flags(key string) uint {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret C.guint // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_flags(_arg0, _arg1)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// HasUnapplied returns whether the #GSettings object has any unapplied changes.
// This can only be the case if it is in 'delayed-apply' mode.
	func (s Settings) HasUnapplied() bool {
var _arg0 *C.GSettings // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

_cret = C.g_settings_get_has_unapplied(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Int gets the value that is stored at @key in @settings.
// 
// A convenience variant of g_settings_get() for 32-bit integers.
// 
// It is a programmer error to give a @key that isn't specified as having a
// int32 type in the schema for @settings.
	func (s Settings) Int(key string) int {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret C.gint // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_int(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Int64 gets the value that is stored at @key in @settings.
// 
// A convenience variant of g_settings_get() for 64-bit integers.
// 
// It is a programmer error to give a @key that isn't specified as having a
// int64 type in the schema for @settings.
	func (s Settings) Int64(key string) int64 {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret C.gint64 // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_int64(_arg0, _arg1)


var _gint64 int64 // out

_gint64 = (int64)(_cret)

return _gint64
}
	
	// Range queries the range of a key.
	func (s Settings) Range(key string) *glib.Variant {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret *C.GVariant // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_range(_arg0, _arg1)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// String gets the value that is stored at @key in @settings.
// 
// A convenience variant of g_settings_get() for strings.
// 
// It is a programmer error to give a @key that isn't specified as having a
// string type in the schema for @settings.
	func (s Settings) String(key string) string {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_string(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Strv: a convenience variant of g_settings_get() for string arrays.
// 
// It is a programmer error to give a @key that isn't specified as having an
// array of strings type in the schema for @settings.
	func (s Settings) Strv(key string) []string {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret **C.gchar

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_strv(_arg0, _arg1)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// Uint gets the value that is stored at @key in @settings.
// 
// A convenience variant of g_settings_get() for 32-bit unsigned integers.
// 
// It is a programmer error to give a @key that isn't specified as having a
// uint32 type in the schema for @settings.
	func (s Settings) Uint(key string) uint {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret C.guint // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_uint(_arg0, _arg1)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Uint64 gets the value that is stored at @key in @settings.
// 
// A convenience variant of g_settings_get() for 64-bit unsigned integers.
// 
// It is a programmer error to give a @key that isn't specified as having a
// uint64 type in the schema for @settings.
	func (s Settings) Uint64(key string) uint64 {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret C.guint64 // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_uint64(_arg0, _arg1)


var _guint64 uint64 // out

_guint64 = (uint64)(_cret)

return _guint64
}
	
	// UserValue checks the "user value" of a key, if there is one.
// 
// The user value of a key is the last value that was set by the user.
// 
// After calling g_settings_reset() this function should always return nil
// (assuming something is not wrong with the system configuration).
// 
// It is possible that g_settings_get_value() will return a different value than
// this function. This can happen in the case that the user set a value for a
// key that was subsequently locked down by the system administrator -- this
// function will return the user's old value.
// 
// This function may be useful for adding a "reset" option to a UI or for
// providing indication that a particular value has been changed.
// 
// It is a programmer error to give a @key that isn't contained in the schema
// for @settings.
	func (s Settings) UserValue(key string) *glib.Variant {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret *C.GVariant // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_user_value(_arg0, _arg1)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// Value gets the value that is stored in @settings for @key.
// 
// It is a programmer error to give a @key that isn't contained in the schema
// for @settings.
	func (s Settings) Value(key string) *glib.Variant {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret *C.GVariant // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_get_value(_arg0, _arg1)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// IsWritable finds out if a key can be written or not
	func (s Settings) IsWritable(name string) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_is_writable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ListChildren gets the list of children on @settings.
// 
// The list is exactly the list of strings for which it is not an error to call
// g_settings_get_child().
// 
// There is little reason to call this function from "normal" code, since you
// should already know what children are in your schema. This function may still
// be useful there for introspection reasons, however.
// 
// You should free the return value with g_strfreev() when you are done with it.
	func (s Settings) ListChildren() []string {
var _arg0 *C.GSettings // out
var _cret **C.gchar

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

_cret = C.g_settings_list_children(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// ListKeys introspects the list of keys on @settings.
// 
// You should probably not be calling this function from "normal" code (since
// you should already know what keys are in your schema). This function is
// intended for introspection reasons.
// 
// You should free the return value with g_strfreev() when you are done with it.
	func (s Settings) ListKeys() []string {
var _arg0 *C.GSettings // out
var _cret **C.gchar

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

_cret = C.g_settings_list_keys(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// RangeCheck checks if the given @value is of the correct type and within the
// permitted range for @key.
	func (s Settings) RangeCheck(key string, value *glib.Variant) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

_cret = C.g_settings_range_check(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Reset resets @key to its default value.
// 
// This call resets the key, as much as possible, to its default value. That
// might be the value specified in the schema or the one set by the
// administrator.
	func (s Settings) Reset(key string)  {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

C.g_settings_reset(_arg0, _arg1)
}
	
	// Revert reverts all non-applied changes to the settings. This function does
// nothing unless @settings is in 'delay-apply' mode; see g_settings_delay(). In
// the normal case settings are always applied immediately.
// 
// Change notifications will be emitted for affected keys.
	func (s Settings) Revert()  {
var _arg0 *C.GSettings // out

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

C.g_settings_revert(_arg0)
}
	
	// SetBoolean sets @key in @settings to @value.
// 
// A convenience variant of g_settings_set() for booleans.
// 
// It is a programmer error to give a @key that isn't specified as having a
// boolean type in the schema for @settings.
	func (s Settings) SetBoolean(key string, value bool) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
if value { _arg2 = C.TRUE }

_cret = C.g_settings_set_boolean(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetDouble sets @key in @settings to @value.
// 
// A convenience variant of g_settings_set() for doubles.
// 
// It is a programmer error to give a @key that isn't specified as having a
// 'double' type in the schema for @settings.
	func (s Settings) SetDouble(key string, value float64) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gdouble // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gdouble)(value)

_cret = C.g_settings_set_double(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetEnum looks up the enumerated type nick for @value and writes it to @key,
// within @settings.
// 
// It is a programmer error to give a @key that isn't contained in the schema
// for @settings or is not marked as an enumerated type, or for @value not to be
// a valid value for the named type.
// 
// After performing the write, accessing @key directly with
// g_settings_get_string() will return the 'nick' associated with @value.
	func (s Settings) SetEnum(key string, value int) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(value)

_cret = C.g_settings_set_enum(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetFlags looks up the flags type nicks for the bits specified by @value, puts
// them in an array of strings and writes the array to @key, within @settings.
// 
// It is a programmer error to give a @key that isn't contained in the schema
// for @settings or is not marked as a flags type, or for @value to contain any
// bits that are not value for the named type.
// 
// After performing the write, accessing @key directly with
// g_settings_get_strv() will return an array of 'nicks'; one for each bit in
// @value.
	func (s Settings) SetFlags(key string, value uint) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint)(value)

_cret = C.g_settings_set_flags(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetInt sets @key in @settings to @value.
// 
// A convenience variant of g_settings_set() for 32-bit integers.
// 
// It is a programmer error to give a @key that isn't specified as having a
// int32 type in the schema for @settings.
	func (s Settings) SetInt(key string, value int) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(value)

_cret = C.g_settings_set_int(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetInt64 sets @key in @settings to @value.
// 
// A convenience variant of g_settings_set() for 64-bit integers.
// 
// It is a programmer error to give a @key that isn't specified as having a
// int64 type in the schema for @settings.
	func (s Settings) SetInt64(key string, value int64) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gint64 // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint64)(value)

_cret = C.g_settings_set_int64(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetString sets @key in @settings to @value.
// 
// A convenience variant of g_settings_set() for strings.
// 
// It is a programmer error to give a @key that isn't specified as having a
// string type in the schema for @settings.
	func (s Settings) SetString(key string, value string) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_settings_set_string(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetStrv sets @key in @settings to @value.
// 
// A convenience variant of g_settings_set() for string arrays. If @value is
// nil, then @key is set to be the empty array.
// 
// It is a programmer error to give a @key that isn't specified as having an
// array of strings type in the schema for @settings.
	func (s Settings) SetStrv(key string, value []string) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 **C.gchar
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.gchar)(C.malloc(C.ulong(len(value)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(value))
for i := range value {
out[i] = (*C.gchar)(C.CString(value[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.g_settings_set_strv(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetUint sets @key in @settings to @value.
// 
// A convenience variant of g_settings_set() for 32-bit unsigned integers.
// 
// It is a programmer error to give a @key that isn't specified as having a
// uint32 type in the schema for @settings.
	func (s Settings) SetUint(key string, value uint) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint)(value)

_cret = C.g_settings_set_uint(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetUint64 sets @key in @settings to @value.
// 
// A convenience variant of g_settings_set() for 64-bit unsigned integers.
// 
// It is a programmer error to give a @key that isn't specified as having a
// uint64 type in the schema for @settings.
	func (s Settings) SetUint64(key string, value uint64) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 C.guint64 // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint64)(value)

_cret = C.g_settings_set_uint64(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetValue sets @key in @settings to @value.
// 
// It is a programmer error to give a @key that isn't contained in the schema
// for @settings or for @value to have the incorrect type, per the schema.
// 
// If @value is floating then this function consumes the reference.
	func (s Settings) SetValue(key string, value *glib.Variant) bool {
var _arg0 *C.GSettings // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out
var _cret C.gboolean // in

_arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

_cret = C.g_settings_set_value(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// SimpleAction: a Action is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of adding
// it to a ActionGroup.
// 
// See also Action.
	type SimpleAction struct {
		**externglib.Object
		Action
		
	}

	// SimpleActionClass is an interface that the SimpleAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SimpleActionClass interface {
		gextras.Objector
		_simpleAction()
	}

	func (SimpleAction) _simpleAction() {}

	
	func marshalSimpleAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSimpleAction(obj), nil
	}
	

	
	// NewSimpleAction creates a new action.
// 
// The created action is stateless. See g_simple_action_new_stateful() to create
// an action that has state.
	func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction {
var _arg1 *C.gchar // out
var _arg2 *C.GVariantType // out
var _cret *C.GSimpleAction // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))

_cret = C.g_simple_action_new(_arg1, _arg2)


var _simpleAction SimpleAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_simpleAction = SimpleAction{
Object: &externglib.Object{externglib.ToGObject(obj)},
Action: Action{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _simpleAction
}
	
	// NewSimpleActionStateful creates a new stateful action.
// 
// All future state values must have the same Type as the initial @state.
// 
// If the @state #GVariant is floating, it is consumed.
	func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) SimpleAction {
var _arg1 *C.gchar // out
var _arg2 *C.GVariantType // out
var _arg3 *C.GVariant // out
var _cret *C.GSimpleAction // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))
_arg3 = (*C.GVariant)(unsafe.Pointer(state.Native()))

_cret = C.g_simple_action_new_stateful(_arg1, _arg2, _arg3)


var _simpleAction SimpleAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_simpleAction = SimpleAction{
Object: &externglib.Object{externglib.ToGObject(obj)},
Action: Action{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _simpleAction
}
	

	
	// SetEnabled sets the action as enabled or not.
// 
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
// 
// This should only be called by the implementor of the action. Users of the
// action should not attempt to modify its enabled flag.
	func (s SimpleAction) SetEnabled(enabled bool)  {
var _arg0 *C.GSimpleAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
if enabled { _arg1 = C.TRUE }

C.g_simple_action_set_enabled(_arg0, _arg1)
}
	
	// SetState sets the state of the action.
// 
// This directly updates the 'state' property to the given value.
// 
// This should only be called by the implementor of the action. Users of the
// action should not attempt to directly modify the 'state' property. Instead,
// they should call g_action_change_state() to request the change.
// 
// If the @value GVariant is floating, it is consumed.
	func (s SimpleAction) SetState(value *glib.Variant)  {
var _arg0 *C.GSimpleAction // out
var _arg1 *C.GVariant // out

_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

C.g_simple_action_set_state(_arg0, _arg1)
}
	
	// SetStateHint sets the state hint for the action.
// 
// See g_action_get_state_hint() for more information about action state hints.
	func (s SimpleAction) SetStateHint(stateHint *glib.Variant)  {
var _arg0 *C.GSimpleAction // out
var _arg1 *C.GVariant // out

_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(stateHint.Native()))

C.g_simple_action_set_state_hint(_arg0, _arg1)
}
	


	// SimpleActionGroup is a hash table filled with #GAction objects, implementing
// the Group and Map interfaces.
	type SimpleActionGroup struct {
		**externglib.Object
		ActionGroup
		ActionMap
		
	}

	// SimpleActionGroupClass is an interface that the SimpleActionGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SimpleActionGroupClass interface {
		gextras.Objector
		_simpleActionGroup()
	}

	func (SimpleActionGroup) _simpleActionGroup() {}

	
	func marshalSimpleActionGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSimpleActionGroup(obj), nil
	}
	

	
	// NewSimpleActionGroup creates a new, empty, ActionGroup.
	func NewSimpleActionGroup() SimpleActionGroup {
var _cret *C.GSimpleActionGroup // in

_cret = C.g_simple_action_group_new()


var _simpleActionGroup SimpleActionGroup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_simpleActionGroup = SimpleActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
ActionGroup: ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ActionMap: ActionMap{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _simpleActionGroup
}
	

	
	// Insert adds an action to the action group.
// 
// If the action group already contains an action with the same name as @action
// then the old action is dropped from the group.
// 
// The action group takes its own reference on @action.
	func (s SimpleActionGroup) Insert(action Action)  {
var _arg0 *C.GSimpleActionGroup // out
var _arg1 *C.GAction // out

_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAction)(unsafe.Pointer(action.Native()))

C.g_simple_action_group_insert(_arg0, _arg1)
}
	
	// Lookup looks up the action with the name @action_name in the group.
// 
// If no such action exists, returns nil.
	func (s SimpleActionGroup) Lookup(actionName string) Action {
var _arg0 *C.GSimpleActionGroup // out
var _arg1 *C.gchar // out
var _cret *C.GAction // in

_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_simple_action_group_lookup(_arg0, _arg1)


var _action Action // out

_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

return _action
}
	
	// Remove removes the named action from the action group.
// 
// If no action of this name is in the group then nothing happens.
	func (s SimpleActionGroup) Remove(actionName string)  {
var _arg0 *C.GSimpleActionGroup // out
var _arg1 *C.gchar // out

_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

C.g_simple_action_group_remove(_arg0, _arg1)
}
	


	// SimpleAsyncResult as of GLib 2.46, AsyncResult is deprecated in favor of
// #GTask, which provides a simpler API.
// 
// AsyncResult implements Result.
// 
// GSimpleAsyncResult handles ReadyCallbacks, error reporting, operation
// cancellation and the final state of an operation, completely transparent to
// the application. Results can be returned as a pointer e.g. for functions that
// return data that is collected asynchronously, a boolean value for checking
// the success or failure of an operation, or a #gssize for operations which
// return the number of bytes modified by the operation; all of the simple
// return cases are covered.
// 
// Most of the time, an application will not need to know of the details of this
// API; it is handled transparently, and any necessary operations are handled by
// Result's interface. However, if implementing a new GIO module, for writing
// language bindings, or for complex applications that need better control of
// how asynchronous operations are completed, it is important to understand this
// functionality.
// 
// GSimpleAsyncResults are tagged with the calling function to ensure that
// asynchronous functions and their finishing functions are used together
// correctly.
// 
// To create a new AsyncResult, call g_simple_async_result_new(). If the result
// needs to be created for a #GError, use g_simple_async_result_new_from_error()
// or g_simple_async_result_new_take_error(). If a #GError is not available
// (e.g. the asynchronous operation's doesn't take a #GError argument), but the
// result still needs to be created for an error condition, use
// g_simple_async_result_new_error() (or g_simple_async_result_set_error_va() if
// your application or binding requires passing a variable argument list
// directly), and the error can then be propagated through the use of
// g_simple_async_result_propagate_error().
// 
// An asynchronous operation can be made to ignore a cancellation event by
// calling g_simple_async_result_set_handle_cancellation() with a AsyncResult
// for the operation and false. This is useful for operations that are dangerous
// to cancel, such as close (which would cause a leak if cancelled before being
// run).
// 
// GSimpleAsyncResult can integrate into GLib's event loop, Loop, or it can use
// #GThreads. g_simple_async_result_complete() will finish an I/O task directly
// from the point where it is called. g_simple_async_result_complete_in_idle()
// will finish it from an idle handler in the [thread-default main
// context][g-main-context-push-thread-default] where the AsyncResult was
// created. g_simple_async_result_run_in_thread() will run the job in a separate
// thread and then use g_simple_async_result_complete_in_idle() to deliver the
// result.
// 
// To set the results of an asynchronous function,
// g_simple_async_result_set_op_res_gpointer(),
// g_simple_async_result_set_op_res_gboolean(), and
// g_simple_async_result_set_op_res_gssize() are provided, setting the
// operation's result to a gpointer, gboolean, or gssize, respectively.
// 
// Likewise, to get the result of an asynchronous function,
// g_simple_async_result_get_op_res_gpointer(),
// g_simple_async_result_get_op_res_gboolean(), and
// g_simple_async_result_get_op_res_gssize() are provided, getting the
// operation's result as a gpointer, gboolean, and gssize, respectively.
// 
// For the details of the requirements implementations must respect, see Result.
// A typical implementation of an asynchronous operation using
// GSimpleAsyncResult looks something like this:
// 
//    static void
//    baked_cb (Cake    *cake,
//              gpointer user_data)
//    {
//      // In this example, this callback is not given a reference to the cake,
//      // so the GSimpleAsyncResult has to take a reference to it.
//      GSimpleAsyncResult *result = user_data;
// 
//      if (cake == NULL)
//        g_simple_async_result_set_error (result,
//                                         BAKER_ERRORS,
//                                         BAKER_ERROR_NO_FLOUR,
//                                         "Go to the supermarket");
//      else
//        g_simple_async_result_set_op_res_gpointer (result,
//                                                   g_object_ref (cake),
//                                                   g_object_unref);
// 
// 
//      // In this example, we assume that baked_cb is called as a callback from
//      // the mainloop, so it's safe to complete the operation synchronously here.
//      // If, however, _baker_prepare_cake () might call its callback without
//      // first returning to the mainloop  inadvisable, but some APIs do so 
//      // we would need to use g_simple_async_result_complete_in_idle().
//      g_simple_async_result_complete (result);
//      g_object_unref (result);
//    }
// 
//    void
//    baker_bake_cake_async (Baker              *self,
//                           guint               radius,
//                           GAsyncReadyCallback callback,
//                           gpointer            user_data)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
// 
//      if (radius < 3)
//        {
//          g_simple_async_report_error_in_idle (G_OBJECT (self),
//                                               callback,
//                                               user_data,
//                                               BAKER_ERRORS,
//                                               BAKER_ERROR_TOO_SMALL,
//                                               "ucm radius cakes are silly",
//                                               radius);
//          return;
//        }
// 
//      simple = g_simple_async_result_new (G_OBJECT (self),
//                                          callback,
//                                          user_data,
//                                          baker_bake_cake_async);
//      cake = _baker_get_cached_cake (self, radius);
// 
//      if (cake != NULL)
//        {
//          g_simple_async_result_set_op_res_gpointer (simple,
//                                                     g_object_ref (cake),
//                                                     g_object_unref);
//          g_simple_async_result_complete_in_idle (simple);
//          g_object_unref (simple);
//          // Drop the reference returned by _baker_get_cached_cake();
//          // the GSimpleAsyncResult has taken its own reference.
//          g_object_unref (cake);
//          return;
//        }
// 
//      _baker_prepare_cake (self, radius, baked_cb, simple);
//    }
// 
//    Cake *
//    baker_bake_cake_finish (Baker        *self,
//                            GAsyncResult *result,
//                            GError      **error)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
// 
//      g_return_val_if_fail (g_simple_async_result_is_valid (result,
//                                                            G_OBJECT (self),
//                                                            baker_bake_cake_async),
//                            NULL);
// 
//      simple = (GSimpleAsyncResult *) result;
// 
//      if (g_simple_async_result_propagate_error (simple, error))
//        return NULL;
// 
//      cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//      return g_object_ref (cake);
//    }
	type SimpleAsyncResult struct {
		**externglib.Object
		AsyncResult
		
	}

	// SimpleAsyncResultClass is an interface that the SimpleAsyncResult class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SimpleAsyncResultClass interface {
		gextras.Objector
		_simpleAsyncResult()
	}

	func (SimpleAsyncResult) _simpleAsyncResult() {}

	
	func marshalSimpleAsyncResult(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSimpleAsyncResult(obj), nil
	}
	

	

	
	// Complete completes an asynchronous I/O job immediately. Must be called in the
// thread where the asynchronous result was to be delivered, as it invokes the
// callback directly. If you are in a different thread use
// g_simple_async_result_complete_in_idle().
// 
// Calling this function takes a reference to @simple for as long as is needed
// to complete the call.
	func (s SimpleAsyncResult) Complete()  {
var _arg0 *C.GSimpleAsyncResult // out

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

C.g_simple_async_result_complete(_arg0)
}
	
	// CompleteInIdle completes an asynchronous function in an idle handler in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that @simple was initially created in (and re-pushes that context
// around the invocation of the callback).
// 
// Calling this function takes a reference to @simple for as long as is needed
// to complete the call.
	func (s SimpleAsyncResult) CompleteInIdle()  {
var _arg0 *C.GSimpleAsyncResult // out

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

C.g_simple_async_result_complete_in_idle(_arg0)
}
	
	// OpResGboolean gets the operation result boolean from within the asynchronous
// result.
	func (s SimpleAsyncResult) OpResGboolean() bool {
var _arg0 *C.GSimpleAsyncResult // out
var _cret C.gboolean // in

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

_cret = C.g_simple_async_result_get_op_res_gboolean(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// OpResGssize gets a gssize from the asynchronous result.
	func (s SimpleAsyncResult) OpResGssize() int {
var _arg0 *C.GSimpleAsyncResult // out
var _cret C.gssize // in

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

_cret = C.g_simple_async_result_get_op_res_gssize(_arg0)


var _gssize int // out

_gssize = (int)(_cret)

return _gssize
}
	
	// PropagateError propagates an error from within the simple asynchronous result
// to a given destination.
// 
// If the #GCancellable given to a prior call to
// g_simple_async_result_set_check_cancellable() is cancelled then this function
// will return true with @dest set appropriately.
	func (s SimpleAsyncResult) PropagateError() error {
var _arg0 *C.GSimpleAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))

C.g_simple_async_result_propagate_error(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetCheckCancellable sets a #GCancellable to check before dispatching results.
// 
// This function has one very specific purpose: the provided cancellable is
// checked at the time of g_simple_async_result_propagate_error() If it is
// cancelled, these functions will return an "Operation was cancelled" error
// (G_IO_ERROR_CANCELLED).
// 
// Implementors of cancellable asynchronous functions should use this in order
// to provide a guarantee to their callers that cancelling an async operation
// will reliably result in an error being returned for that operation (even if a
// positive result for the operation has already been sent as an idle to the
// main context to be dispatched).
// 
// The checking described above is done regardless of any call to the unrelated
// g_simple_async_result_set_handle_cancellation() function.
	func (s SimpleAsyncResult) SetCheckCancellable(checkCancellable CancellableClass)  {
var _arg0 *C.GSimpleAsyncResult // out
var _arg1 *C.GCancellable // out

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(checkCancellable.Native()))

C.g_simple_async_result_set_check_cancellable(_arg0, _arg1)
}
	
	// SetFromError sets the result from a #GError.
	func (s SimpleAsyncResult) SetFromError(err error)  {
var _arg0 *C.GSimpleAsyncResult // out
var _arg1 *C.GError // out

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))
defer C.g_error_free(_arg1)

C.g_simple_async_result_set_from_error(_arg0, _arg1)
}
	
	// SetHandleCancellation sets whether to handle cancellation within the
// asynchronous operation.
// 
// This function has nothing to do with
// g_simple_async_result_set_check_cancellable(). It only refers to the
// #GCancellable passed to g_simple_async_result_run_in_thread().
	func (s SimpleAsyncResult) SetHandleCancellation(handleCancellation bool)  {
var _arg0 *C.GSimpleAsyncResult // out
var _arg1 C.gboolean // out

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
if handleCancellation { _arg1 = C.TRUE }

C.g_simple_async_result_set_handle_cancellation(_arg0, _arg1)
}
	
	// SetOpResGboolean sets the operation result to a boolean within the
// asynchronous result.
	func (s SimpleAsyncResult) SetOpResGboolean(opRes bool)  {
var _arg0 *C.GSimpleAsyncResult // out
var _arg1 C.gboolean // out

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
if opRes { _arg1 = C.TRUE }

C.g_simple_async_result_set_op_res_gboolean(_arg0, _arg1)
}
	
	// SetOpResGssize sets the operation result within the asynchronous result to
// the given @op_res.
	func (s SimpleAsyncResult) SetOpResGssize(opRes int)  {
var _arg0 *C.GSimpleAsyncResult // out
var _arg1 C.gssize // out

_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(s.Native()))
_arg1 = (C.gssize)(opRes)

C.g_simple_async_result_set_op_res_gssize(_arg0, _arg1)
}
	


	// SimpleIOStream: GSimpleIOStream creates a OStream from an arbitrary Stream
// and Stream. This allows any pair of input and output streams to be used with
// OStream methods.
// 
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
	type SimpleIOStream struct {
		IOStream
		
	}

	// SimpleIOStreamClass is an interface that the SimpleIOStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SimpleIOStreamClass interface {
		gextras.Objector
		_simpleIOStream()
	}

	func (SimpleIOStream) _simpleIOStream() {}

	
	func marshalSimpleIOStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSimpleIOStream(obj), nil
	}
	

	
	// NewSimpleIOStream creates a new IOStream wrapping @input_stream and
// @output_stream. See also OStream.
	func NewSimpleIOStream(inputStream InputStreamClass, outputStream OutputStreamClass) SimpleIOStream {
var _arg1 *C.GInputStream // out
var _arg2 *C.GOutputStream // out
var _cret *C.GIOStream // in

_arg1 = (*C.GInputStream)(unsafe.Pointer(inputStream.Native()))
_arg2 = (*C.GOutputStream)(unsafe.Pointer(outputStream.Native()))

_cret = C.g_simple_io_stream_new(_arg1, _arg2)


var _simpleIOStream SimpleIOStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_simpleIOStream = SimpleIOStream{
IOStream: IOStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _simpleIOStream
}
	

	


	// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
// 
// Calling request or release will result in errors.
	type SimplePermission struct {
		Permission
		
	}

	// SimplePermissionClass is an interface that the SimplePermission class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SimplePermissionClass interface {
		gextras.Objector
		_simplePermission()
	}

	func (SimplePermission) _simplePermission() {}

	
	func marshalSimplePermission(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSimplePermission(obj), nil
	}
	

	
	// NewSimplePermission creates a new #GPermission instance that represents an
// action that is either always or never allowed.
	func NewSimplePermission(allowed bool) SimplePermission {
var _arg1 C.gboolean // out
var _cret *C.GPermission // in

if allowed { _arg1 = C.TRUE }

_cret = C.g_simple_permission_new(_arg1)


var _simplePermission SimplePermission // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_simplePermission = SimplePermission{
Permission: Permission{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _simplePermission
}
	

	


	// SimpleProXYResolver is a simple Resolver implementation that handles a single
// default proxy, multiple URI-scheme-specific proxies, and a list of hosts that
// proxies should not be used for.
// 
// ProxyResolver is never the default proxy resolver, but it can be used as the
// base class for another proxy resolver implementation, or it can be created
// and used manually, such as with g_socket_client_set_proxy_resolver().
	type SimpleProXYResolver struct {
		**externglib.Object
		ProXYResolver
		
	}

	// SimpleProXYResolverClass is an interface that the SimpleProXYResolver class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SimpleProXYResolverClass interface {
		gextras.Objector
		_simpleProXYResolver()
	}

	func (SimpleProXYResolver) _simpleProXYResolver() {}

	
	func marshalSimpleProXYResolver(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSimpleProXYResolver(obj), nil
	}
	

	

	
	// SetDefaultProXY sets the default proxy on @resolver, to be used for any URIs
// that don't match ProxyResolver:ignore-hosts or a proxy set via
// g_simple_proxy_resolver_set_uri_proxy().
// 
// If @default_proxy starts with "socks://", ProxyResolver will treat it as
// referring to all three of the socks5, socks4a, and socks4 proxy types.
	func (r SimpleProXYResolver) SetDefaultProXY(defaultProxy string)  {
var _arg0 *C.GSimpleProxyResolver // out
var _arg1 *C.gchar // out

_arg0 = (*C.GSimpleProxyResolver)(unsafe.Pointer(r.Native()))
_arg1 = (*C.gchar)(C.CString(defaultProxy))
defer C.free(unsafe.Pointer(_arg1))

C.g_simple_proxy_resolver_set_default_proxy(_arg0, _arg1)
}
	
	// SetIgnoreHosts sets the list of ignored hosts.
// 
// See ProxyResolver:ignore-hosts for more details on how the @ignore_hosts
// argument is interpreted.
	func (r SimpleProXYResolver) SetIgnoreHosts(ignoreHosts *string)  {
var _arg0 *C.GSimpleProxyResolver // out
var _arg1 **C.gchar // out

_arg0 = (*C.GSimpleProxyResolver)(unsafe.Pointer(r.Native()))
_arg1 = (**C.gchar)(C.CString(ignoreHosts))
defer C.free(unsafe.Pointer(_arg1))

C.g_simple_proxy_resolver_set_ignore_hosts(_arg0, _arg1)
}
	
	// SetURIProXY adds a URI-scheme-specific proxy to @resolver; URIs whose scheme
// matches @uri_scheme (and which don't match ProxyResolver:ignore-hosts) will
// be proxied via @proxy.
// 
// As with ProxyResolver:default-proxy, if @proxy starts with "socks://",
// ProxyResolver will treat it as referring to all three of the socks5, socks4a,
// and socks4 proxy types.
	func (r SimpleProXYResolver) SetURIProXY(uriScheme string, proxy string)  {
var _arg0 *C.GSimpleProxyResolver // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out

_arg0 = (*C.GSimpleProxyResolver)(unsafe.Pointer(r.Native()))
_arg1 = (*C.gchar)(C.CString(uriScheme))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(proxy))
defer C.free(unsafe.Pointer(_arg2))

C.g_simple_proxy_resolver_set_uri_proxy(_arg0, _arg1, _arg2)
}
	


	// Socket: a #GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API. It
// supports both the UNIX socket implementations and winsock2 on Windows.
// 
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful.
// 
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return nil.
// 
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which dont take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
// 
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
// 
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation.
// 
// All socket file descriptors are set to be close-on-exec.
// 
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
// 
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
	type Socket struct {
		**externglib.Object
		DatagramBased
		Initable
		
	}

	// SocketClass is an interface that the Socket class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SocketClass interface {
		gextras.Objector
		_socket()
	}

	func (Socket) _socket() {}

	
	func marshalSocket(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSocket(obj), nil
	}
	

	
	// NewSocket creates a new #GSocket with the defined family, type and protocol.
// If @protocol is 0 (G_SOCKET_PROTOCOL_DEFAULT) the default protocol type for
// the family and type is used.
// 
// The @protocol is a family and type specific int that specifies what kind of
// protocol to use. Protocol lists several common ones. Many families only
// support one protocol, and use 0 for this, others support several and using 0
// means to use the default protocol for the family and type.
// 
// The protocol id is passed directly to the operating system, so you can use
// protocols not listed in Protocol if you know the protocol number used for it.
	func NewSocket(family SocketFamily, typ SocketType, protocol SocketProtocol) (Socket, error) {
var _arg1 C.GSocketFamily // out
var _arg2 C.GSocketType // out
var _arg3 C.GSocketProtocol // out
var _cret *C.GSocket // in
var _cerr *C.GError // in

_arg1 = (C.GSocketFamily)(family)
_arg2 = (C.GSocketType)(typ)
_arg3 = (C.GSocketProtocol)(protocol)

_cret = C.g_socket_new(_arg1, _arg2, _arg3, &_cerr)


var _socket Socket // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_socket = Socket{
Object: &externglib.Object{externglib.ToGObject(obj)},
DatagramBased: DatagramBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socket, _goerr
}
	
	// NewSocketFromFd creates a new #GSocket from a native file descriptor or
// winsock SOCKET handle.
// 
// This reads all the settings from the file descriptor so that all properties
// should work. Note that the file descriptor will be set to non-blocking mode,
// independent on the blocking mode of the #GSocket.
// 
// On success, the returned #GSocket takes ownership of @fd. On failure, the
// caller must close @fd themselves.
// 
// Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
// descriptor. Instead, a GError will be set with code G_IO_ERROR_FAILED
	func NewSocketFromFd(fd int) (Socket, error) {
var _arg1 C.gint // out
var _cret *C.GSocket // in
var _cerr *C.GError // in

_arg1 = (C.gint)(fd)

_cret = C.g_socket_new_from_fd(_arg1, &_cerr)


var _socket Socket // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_socket = Socket{
Object: &externglib.Object{externglib.ToGObject(obj)},
DatagramBased: DatagramBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Initable: Initable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socket, _goerr
}
	

	
	// Accept: accept incoming connections on a connection-based socket. This
// removes the first outstanding connection request from the listening socket
// and creates a #GSocket object for it.
// 
// The @socket must be bound to a local address with g_socket_bind() and must be
// listening for incoming connections (g_socket_listen()).
// 
// If there are no outstanding connections then the operation will block or
// return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be notified
// of an incoming connection, wait for the G_IO_IN condition.
	func (s Socket) Accept(cancellable CancellableClass) (Socket, error) {
var _arg0 *C.GSocket // out
var _arg1 *C.GCancellable // out
var _cret *C.GSocket // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_accept(_arg0, _arg1, &_cerr)


var _ret Socket // out
var _goerr error // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _ret, _goerr
}
	
	// Bind: when a socket is created it is attached to an address family, but it
// doesn't have an address in this family. g_socket_bind() assigns the address
// (sometimes called name) of the socket.
// 
// It is generally required to bind to a local address before you can receive
// connections. (See g_socket_listen() and g_socket_accept() ). In certain
// situations, you may also want to bind a socket that will be used to initiate
// connections, though this is not normally required.
// 
// If @socket is a TCP socket, then @allow_reuse controls the setting of the
// `SO_REUSEADDR` socket option; normally it should be true for server sockets
// (sockets that you will eventually call g_socket_accept() on), and false for
// client sockets. (Failing to set this flag on a server socket may cause
// g_socket_bind() to return G_IO_ERROR_ADDRESS_IN_USE if the server program is
// stopped and then immediately restarted.)
// 
// If @socket is a UDP socket, then @allow_reuse determines whether or not other
// UDP sockets can be bound to the same address at the same time. In particular,
// you can have several UDP sockets bound to the same address, and they will all
// receive all of the multicast and broadcast packets sent to that address. (The
// behavior of unicast UDP packets to an address with multiple listeners is not
// defined.)
	func (s Socket) Bind(address SocketAddressClass, allowReuse bool) error {
var _arg0 *C.GSocket // out
var _arg1 *C.GSocketAddress // out
var _arg2 C.gboolean // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
if allowReuse { _arg2 = C.TRUE }

C.g_socket_bind(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CheckConnectResult checks and resets the pending connect error for the
// socket. This is used to check for errors when g_socket_connect() is used in
// non-blocking mode.
	func (s Socket) CheckConnectResult() error {
var _arg0 *C.GSocket // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

C.g_socket_check_connect_result(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Close closes the socket, shutting down any active connection.
// 
// Closing a socket does not wait for all outstanding I/O operations to finish,
// so the caller should not rely on them to be guaranteed to complete even if
// the close returns with no error.
// 
// Once the socket is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a socket multiple times will not return an error.
// 
// Sockets will be automatically closed when the last reference is dropped, but
// you might want to call this function to make sure resources are released as
// early as possible.
// 
// Beware that due to the way that TCP works, it is possible for recently-sent
// data to be lost if either you close a socket while the G_IO_IN condition is
// set, or else if the remote connection tries to send something to you after
// you close the socket but before it has finished reading all of the data you
// sent. There is no easy generic way to avoid this problem; the easiest fix is
// to design the network protocol such that the client will never send data "out
// of turn". Another solution is for the server to half-close the connection by
// calling g_socket_shutdown() with only the @shutdown_write flag set, and then
// wait for the client to notice this and close its side of the connection,
// after which the server can safely call g_socket_close(). (This is what
// Connection does if you call g_tcp_connection_set_graceful_disconnect(). But
// of course, this only works if the client will close its connection after the
// server does.)
	func (s Socket) Close() error {
var _arg0 *C.GSocket // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

C.g_socket_close(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ConditionCheck checks on the readiness of @socket to perform operations. The
// operations specified in @condition are checked for and masked against the
// currently-satisfied conditions on @socket. The result is returned.
// 
// Note that on Windows, it is possible for an operation to return
// G_IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check() has
// claimed that the socket is ready for writing. Rather than calling
// g_socket_condition_check() and then writing to the socket if it succeeds, it
// is generally better to simply try writing to the socket right away, and try
// again later if the initial attempt returns G_IO_ERROR_WOULD_BLOCK.
// 
// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
// conditions will always be set in the output if they are true.
// 
// This call never blocks.
	func (s Socket) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
var _arg0 *C.GSocket // out
var _arg1 C.GIOCondition // out
var _cret C.GIOCondition // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (C.GIOCondition)(condition)

_cret = C.g_socket_condition_check(_arg0, _arg1)


var _ioCondition glib.IOCondition // out

_ioCondition = glib.IOCondition(_cret)

return _ioCondition
}
	
	// ConditionTimedWait waits for up to @timeout_us microseconds for @condition to
// become true on @socket. If the condition is met, true is returned.
// 
// If @cancellable is cancelled before the condition is met, or if @timeout_us
// (or the socket's #GSocket:timeout) is reached before the condition is met,
// then false is returned and @error, if non-nil, is set to the appropriate
// value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
// 
// If you don't want a timeout, use g_socket_condition_wait(). (Alternatively,
// you can pass -1 for @timeout_us.)
// 
// Note that although @timeout_us is in microseconds for consistency with other
// GLib APIs, this function actually only has millisecond resolution, and the
// behavior is undefined if @timeout_us is not an exact number of milliseconds.
	func (s Socket) ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable CancellableClass) error {
var _arg0 *C.GSocket // out
var _arg1 C.GIOCondition // out
var _arg2 C.gint64 // out
var _arg3 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (C.GIOCondition)(condition)
_arg2 = (C.gint64)(timeoutUs)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_socket_condition_timed_wait(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ConditionWait waits for @condition to become true on @socket. When the
// condition is met, true is returned.
// 
// If @cancellable is cancelled before the condition is met, or if the socket
// has a timeout set and it is reached before the condition is met, then false
// is returned and @error, if non-nil, is set to the appropriate value
// (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
// 
// See also g_socket_condition_timed_wait().
	func (s Socket) ConditionWait(condition glib.IOCondition, cancellable CancellableClass) error {
var _arg0 *C.GSocket // out
var _arg1 C.GIOCondition // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (C.GIOCondition)(condition)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_socket_condition_wait(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ConnectSocket: connect the socket to the specified remote address.
// 
// For connection oriented socket this generally means we attempt to make a
// connection to the @address. For a connection-less socket it sets the default
// address for g_socket_send() and discards all incoming datagrams from other
// sources.
// 
// Generally connection oriented sockets can only connect once, but
// connection-less sockets can connect multiple times to change the default
// address.
// 
// If the connect call needs to do network I/O it will block, unless
// non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned and the user
// can be notified of the connection finishing by waiting for the G_IO_OUT
// condition. The result of the connection must then be checked with
// g_socket_check_connect_result().
	func (s Socket) ConnectSocket(address SocketAddressClass, cancellable CancellableClass) error {
var _arg0 *C.GSocket // out
var _arg1 *C.GSocketAddress // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_socket_connect(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ConnectionFactoryCreateConnection creates a Connection subclass of the right
// type for @socket.
	func (s Socket) ConnectionFactoryCreateConnection() SocketConnection {
var _arg0 *C.GSocket // out
var _cret *C.GSocketConnection // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_connection_factory_create_connection(_arg0)


var _socketConnection SocketConnection // out

_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)

return _socketConnection
}
	
	// AvailableBytes: get the amount of data pending in the OS input buffer,
// without blocking.
// 
// If @socket is a UDP or SCTP socket, this will return the size of just the
// next packet, even if additional packets are buffered after that one.
// 
// Note that on Windows, this function is rather inefficient in the UDP case,
// and so if you know any plausible upper bound on the size of the incoming
// packet, it is better to just do a g_socket_receive() with a buffer of that
// size, rather than calling g_socket_get_available_bytes() first and then doing
// a receive of exactly the right size.
	func (s Socket) AvailableBytes() int {
var _arg0 *C.GSocket // out
var _cret C.gssize // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_available_bytes(_arg0)


var _gssize int // out

_gssize = (int)(_cret)

return _gssize
}
	
	// Blocking gets the blocking mode of the socket. For details on blocking I/O,
// see g_socket_set_blocking().
	func (s Socket) Blocking() bool {
var _arg0 *C.GSocket // out
var _cret C.gboolean // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_blocking(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Broadcast gets the broadcast setting on @socket; if true, it is possible to
// send packets to broadcast addresses.
	func (s Socket) Broadcast() bool {
var _arg0 *C.GSocket // out
var _cret C.gboolean // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_broadcast(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Credentials returns the credentials of the foreign process connected to this
// socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX sockets).
// 
// If this operation isn't supported on the OS, the method fails with the
// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading the
// SO_PEERCRED option on the underlying socket.
// 
// This method can be expected to be available on the following platforms:
// 
// - Linux since GLib 2.26 - OpenBSD since GLib 2.30 - Solaris, Illumos and
// OpenSolaris since GLib 2.40 - NetBSD since GLib 2.42 - macOS, tvOS, iOS since
// GLib 2.66
// 
// Other ways to obtain credentials from a foreign peer includes the
// CredentialsMessage type and g_unix_connection_send_credentials() /
// g_unix_connection_receive_credentials() functions.
	func (s Socket) Credentials() (Credentials, error) {
var _arg0 *C.GSocket // out
var _cret *C.GCredentials // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_credentials(_arg0, &_cerr)


var _credentials Credentials // out
var _goerr error // out

_credentials = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Credentials)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _credentials, _goerr
}
	
	// Family gets the socket family of the socket.
	func (s Socket) Family() SocketFamily {
var _arg0 *C.GSocket // out
var _cret C.GSocketFamily // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_family(_arg0)


var _socketFamily SocketFamily // out

_socketFamily = SocketFamily(_cret)

return _socketFamily
}
	
	// Fd returns the underlying OS socket object. On unix this is a socket file
// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
// useful for doing platform specific or otherwise unusual operations on the
// socket.
	func (s Socket) Fd() int {
var _arg0 *C.GSocket // out
var _cret C.int // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_fd(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Keepalive gets the keepalive mode of the socket. For details on this, see
// g_socket_set_keepalive().
	func (s Socket) Keepalive() bool {
var _arg0 *C.GSocket // out
var _cret C.gboolean // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_keepalive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ListenBacklog gets the listen backlog setting of the socket. For details on
// this, see g_socket_set_listen_backlog().
	func (s Socket) ListenBacklog() int {
var _arg0 *C.GSocket // out
var _cret C.gint // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_listen_backlog(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// LocalAddress: try to get the local address of a bound socket. This is only
// useful if the socket has been bound to a local address, either explicitly or
// implicitly when connecting.
	func (s Socket) LocalAddress() (SocketAddress, error) {
var _arg0 *C.GSocket // out
var _cret *C.GSocketAddress // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_local_address(_arg0, &_cerr)


var _socketAddress SocketAddress // out
var _goerr error // out

_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketAddress, _goerr
}
	
	// MulticastLoopback gets the multicast loopback setting on @socket; if true
// (the default), outgoing multicast packets will be looped back to multicast
// listeners on the same host.
	func (s Socket) MulticastLoopback() bool {
var _arg0 *C.GSocket // out
var _cret C.gboolean // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_multicast_loopback(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MulticastTTL gets the multicast time-to-live setting on @socket; see
// g_socket_set_multicast_ttl() for more details.
	func (s Socket) MulticastTTL() uint {
var _arg0 *C.GSocket // out
var _cret C.guint // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_multicast_ttl(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Option gets the value of an integer-valued option on @socket, as with
// getsockopt(). (If you need to fetch a non-integer-valued option, you will
// need to call getsockopt() directly.)
// 
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system headers
// that will define most of the standard/portable socket options. For unusual
// socket protocols or platform-dependent options, you may need to include
// additional headers.
// 
// Note that even for socket options that are a single byte in size, @value is
// still a pointer to a #gint variable, not a #guchar; g_socket_get_option()
// will handle the conversion internally.
	func (s Socket) Option(level int, optname int) (int, error) {
var _arg0 *C.GSocket // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(level)
_arg2 = (C.gint)(optname)

C.g_socket_get_option(_arg0, _arg1, _arg2, &_arg3, &_cerr)

var _value int // out
var _goerr error // out

_value = (int)(_arg3)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _value, _goerr
}
	
	// Protocol gets the socket protocol id the socket was created with. In case the
// protocol is unknown, -1 is returned.
	func (s Socket) Protocol() SocketProtocol {
var _arg0 *C.GSocket // out
var _cret C.GSocketProtocol // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_protocol(_arg0)


var _socketProtocol SocketProtocol // out

_socketProtocol = SocketProtocol(_cret)

return _socketProtocol
}
	
	// RemoteAddress: try to get the remote address of a connected socket. This is
// only useful for connection oriented sockets that have been connected.
	func (s Socket) RemoteAddress() (SocketAddress, error) {
var _arg0 *C.GSocket // out
var _cret *C.GSocketAddress // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_remote_address(_arg0, &_cerr)


var _socketAddress SocketAddress // out
var _goerr error // out

_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketAddress, _goerr
}
	
	// SocketType gets the socket type of the socket.
	func (s Socket) SocketType() SocketType {
var _arg0 *C.GSocket // out
var _cret C.GSocketType // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_socket_type(_arg0)


var _socketType SocketType // out

_socketType = SocketType(_cret)

return _socketType
}
	
	// Timeout gets the timeout setting of the socket. For details on this, see
// g_socket_set_timeout().
	func (s Socket) Timeout() uint {
var _arg0 *C.GSocket // out
var _cret C.guint // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_timeout(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// TTL gets the unicast time-to-live setting on @socket; see g_socket_set_ttl()
// for more details.
	func (s Socket) TTL() uint {
var _arg0 *C.GSocket // out
var _cret C.guint // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_get_ttl(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// IsClosed checks whether a socket is closed.
	func (s Socket) IsClosed() bool {
var _arg0 *C.GSocket // out
var _cret C.gboolean // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_is_closed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsConnected: check whether the socket is connected. This is only useful for
// connection-oriented sockets.
// 
// If using g_socket_shutdown(), this function will return true until the socket
// has been shut down for reading and writing. If you do a non-blocking connect,
// this function will not return true until after you call
// g_socket_check_connect_result().
	func (s Socket) IsConnected() bool {
var _arg0 *C.GSocket // out
var _cret C.gboolean // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_is_connected(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// JoinMulticastGroup registers @socket to receive multicast messages sent to
// @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have been
// bound to an appropriate interface and port with g_socket_bind().
// 
// If @iface is nil, the system will automatically pick an interface to bind to
// based on @group.
// 
// If @source_specific is true, source-specific multicast as defined in RFC 4604
// is used. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
// 
// To bind to a given source-specific multicast address, use
// g_socket_join_multicast_group_ssm() instead.
	func (s Socket) JoinMulticastGroup(group InetAddressClass, sourceSpecific bool, iface string) error {
var _arg0 *C.GSocket // out
var _arg1 *C.GInetAddress // out
var _arg2 C.gboolean // out
var _arg3 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
if sourceSpecific { _arg2 = C.TRUE }
_arg3 = (*C.gchar)(C.CString(iface))
defer C.free(unsafe.Pointer(_arg3))

C.g_socket_join_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// JoinMulticastGroupSSM registers @socket to receive multicast messages sent to
// @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have been
// bound to an appropriate interface and port with g_socket_bind().
// 
// If @iface is nil, the system will automatically pick an interface to bind to
// based on @group.
// 
// If @source_specific is not nil, use source-specific multicast as defined in
// RFC 4604. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
// 
// Note that this function can be called multiple times for the same @group with
// different @source_specific in order to receive multicast packets from more
// than one source.
	func (s Socket) JoinMulticastGroupSSM(group InetAddressClass, sourceSpecific InetAddressClass, iface string) error {
var _arg0 *C.GSocket // out
var _arg1 *C.GInetAddress // out
var _arg2 *C.GInetAddress // out
var _arg3 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
_arg2 = (*C.GInetAddress)(unsafe.Pointer(sourceSpecific.Native()))
_arg3 = (*C.gchar)(C.CString(iface))
defer C.free(unsafe.Pointer(_arg3))

C.g_socket_join_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LeaveMulticastGroup removes @socket from the multicast group defined by
// @group, @iface, and @source_specific (which must all have the same values
// they had when you joined the group).
// 
// @socket remains bound to its address and port, and can still receive unicast
// messages after calling this.
// 
// To unbind to a given source-specific multicast address, use
// g_socket_leave_multicast_group_ssm() instead.
	func (s Socket) LeaveMulticastGroup(group InetAddressClass, sourceSpecific bool, iface string) error {
var _arg0 *C.GSocket // out
var _arg1 *C.GInetAddress // out
var _arg2 C.gboolean // out
var _arg3 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
if sourceSpecific { _arg2 = C.TRUE }
_arg3 = (*C.gchar)(C.CString(iface))
defer C.free(unsafe.Pointer(_arg3))

C.g_socket_leave_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LeaveMulticastGroupSSM removes @socket from the multicast group defined by
// @group, @iface, and @source_specific (which must all have the same values
// they had when you joined the group).
// 
// @socket remains bound to its address and port, and can still receive unicast
// messages after calling this.
	func (s Socket) LeaveMulticastGroupSSM(group InetAddressClass, sourceSpecific InetAddressClass, iface string) error {
var _arg0 *C.GSocket // out
var _arg1 *C.GInetAddress // out
var _arg2 *C.GInetAddress // out
var _arg3 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
_arg2 = (*C.GInetAddress)(unsafe.Pointer(sourceSpecific.Native()))
_arg3 = (*C.gchar)(C.CString(iface))
defer C.free(unsafe.Pointer(_arg3))

C.g_socket_leave_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Listen marks the socket as a server socket, i.e. a socket that is used to
// accept incoming requests using g_socket_accept().
// 
// Before calling this the socket must be bound to a local address using
// g_socket_bind().
// 
// To set the maximum amount of outstanding clients, use
// g_socket_set_listen_backlog().
	func (s Socket) Listen() error {
var _arg0 *C.GSocket // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

C.g_socket_listen(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Receive: receive data (up to @size bytes) from a socket. This is mainly used
// by connection-oriented sockets; it is identical to g_socket_receive_from()
// with @address set to nil.
// 
// For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
// g_socket_receive() will always read either 0 or 1 complete messages from the
// socket. If the received message is too large to fit in @buffer, then the data
// beyond @size bytes will be discarded, without any explicit indication that
// this has occurred.
// 
// For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any number of
// bytes, up to @size. If more than @size bytes have been received, the
// additional data will be returned in future calls to g_socket_receive().
// 
// If the socket is in blocking mode the call will block until there is some
// data to receive, the connection is closed, or there is an error. If there is
// no data available and the socket is in non-blocking mode, a
// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data is
// available, wait for the G_IO_IN condition.
// 
// On error -1 is returned and @error is set accordingly.
	func (s Socket) Receive(cancellable CancellableClass) ([]byte, int, error) {
var _arg0 *C.GSocket // out
var _arg1 C.gchar
var _arg2 C.gsize // in
var _arg3 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_receive(_arg0, &_arg1, &_arg2, _arg3, &_cerr)


var _buffer []byte
var _gssize int // out
var _goerr error // out

{
src := unsafe.Slice(_arg1, _arg2)
_buffer = make([]byte, _arg2)
for i := 0; i < int(_arg2); i++ {
_buffer[i] = (byte)(src[i])
}
}
_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _buffer, _gssize, _goerr
}
	
	// ReceiveFrom: receive data (up to @size bytes) from a socket.
// 
// If @address is non-nil then @address will be set equal to the source address
// of the received packet. @address is owned by the caller.
// 
// See g_socket_receive() for additional information.
	func (s Socket) ReceiveFrom(cancellable CancellableClass) (SocketAddress, []byte, int, error) {
var _arg0 *C.GSocket // out
var _arg1 *C.GSocketAddress // in
var _arg2 C.gchar
var _arg3 C.gsize // in
var _arg4 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_receive_from(_arg0, &_arg1, &_arg2, &_arg3, _arg4, &_cerr)


var _address SocketAddress // out
var _buffer []byte
var _gssize int // out
var _goerr error // out

_address = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1))).(SocketAddress)
{
src := unsafe.Slice(_arg2, _arg3)
_buffer = make([]byte, _arg3)
for i := 0; i < int(_arg3); i++ {
_buffer[i] = (byte)(src[i])
}
}
_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _address, _buffer, _gssize, _goerr
}
	
	// ReceiveMessages: receive multiple data messages from @socket in one go. This
// is the most complicated and fully-featured version of this call. For easier
// use, see g_socket_receive(), g_socket_receive_from(), and
// g_socket_receive_message().
// 
// @messages must point to an array of Message structs and @num_messages must be
// the length of this array. Each Message contains a pointer to an array of
// Vector structs describing the buffers that the data received in each message
// will be written to. Using multiple Vectors is more memory-efficient than
// manually copying data out of a single buffer to multiple sources, and more
// system-call-efficient than making multiple calls to g_socket_receive(), such
// as in scenarios where a lot of data packets need to be received (e.g.
// high-bandwidth video streaming over RTP/UDP).
// 
// @flags modify how all messages are received. The commonly available arguments
// for this are available in the MsgFlags enum, but the values there are the
// same as the system values, and the flags are passed in as-is, so you can pass
// in system-specific flags too. These flags affect the overall receive
// operation. Flags affecting individual messages are returned in Message.flags.
// 
// The other members of Message are treated as described in its documentation.
// 
// If #GSocket:blocking is true the call will block until @num_messages have
// been received, or the end of the stream is reached.
// 
// If #GSocket:blocking is false the call will return up to @num_messages
// without blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
// operating system to be received.
// 
// In blocking mode, if #GSocket:timeout is positive and is reached before any
// messages are received, G_IO_ERROR_TIMED_OUT is returned, otherwise up to
// @num_messages are returned. (Note: This is effectively the behaviour of
// `MSG_WAITFORONE` with recvmmsg().)
// 
// To be notified when messages are available, wait for the G_IO_IN condition.
// Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_socket_receive_messages() even if you were previously notified of a G_IO_IN
// condition.
// 
// If the remote peer closes the connection, any messages queued in the
// operating system will be returned, and subsequent calls to
// g_socket_receive_messages() will return 0 (with no error set).
// 
// On error -1 is returned and @error is set accordingly. An error will only be
// returned if zero messages could be received; otherwise the number of messages
// successfully received before the error will be returned.
	func (s Socket) ReceiveMessages(messages []InputMessage, flags int, cancellable CancellableClass) (int, error) {
var _arg0 *C.GSocket // out
var _arg1 *C.GInputMessage
var _arg2 C.guint
var _arg3 C.gint // out
var _arg4 *C.GCancellable // out
var _cret C.gint // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg2 = C.guint(len(messages))
_arg1 = (*C.GInputMessage)(unsafe.Pointer(&messages[0]))
_arg3 = (C.gint)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_receive_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
// except that the choice of blocking or non-blocking behavior is determined by
// the @blocking argument rather than by @socket's properties.
	func (s Socket) ReceiveWithBlocking(blocking bool, cancellable CancellableClass) ([]byte, int, error) {
var _arg0 *C.GSocket // out
var _arg1 C.gchar
var _arg2 C.gsize // in
var _arg3 C.gboolean // out
var _arg4 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
if blocking { _arg3 = C.TRUE }
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_receive_with_blocking(_arg0, &_arg1, &_arg2, _arg3, _arg4, &_cerr)


var _buffer []byte
var _gssize int // out
var _goerr error // out

{
src := unsafe.Slice(_arg1, _arg2)
_buffer = make([]byte, _arg2)
for i := 0; i < int(_arg2); i++ {
_buffer[i] = (byte)(src[i])
}
}
_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _buffer, _gssize, _goerr
}
	
	// Send tries to send @size bytes from @buffer on the socket. This is mainly
// used by connection-oriented sockets; it is identical to g_socket_send_to()
// with @address set to nil.
// 
// If the socket is in blocking mode the call will block until there is space
// for the data in the socket queue. If there is no space available and the
// socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error will be
// returned. To be notified when space is available, wait for the G_IO_OUT
// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_socket_send() even if you were previously notified of a G_IO_OUT condition.
// (On Windows in particular, this is very common due to the way the underlying
// APIs work.)
// 
// On error -1 is returned and @error is set accordingly.
	func (s Socket) Send(buffer []byte, cancellable CancellableClass) (int, error) {
var _arg0 *C.GSocket // out
var _arg1 *C.gchar
var _arg2 C.gsize
var _arg3 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(buffer))
_arg1 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_send(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// SendMessage: send data to @address on @socket. For sending multiple messages
// see g_socket_send_messages(); for easier use, see g_socket_send() and
// g_socket_send_to().
// 
// If @address is nil then the message is sent to the default receiver (set by
// g_socket_connect()).
// 
// @vectors must point to an array of Vector structs and @num_vectors must be
// the length of this array. (If @num_vectors is -1, then @vectors is assumed to
// be terminated by a Vector with a nil buffer pointer.) The Vector structs
// describe the buffers that the sent data will be gathered from. Using multiple
// Vectors is more memory-efficient than manually copying data from multiple
// sources into a single buffer, and more network-efficient than making multiple
// calls to g_socket_send().
// 
// @messages, if non-nil, is taken to point to an array of @num_messages
// ControlMessage instances. These correspond to the control messages to be sent
// on the socket. If @num_messages is -1 then @messages is treated as a
// nil-terminated array.
// 
// @flags modify how the message is sent. The commonly available arguments for
// this are available in the MsgFlags enum, but the values there are the same as
// the system values, and the flags are passed in as-is, so you can pass in
// system-specific flags too.
// 
// If the socket is in blocking mode the call will block until there is space
// for the data in the socket queue. If there is no space available and the
// socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error will be
// returned. To be notified when space is available, wait for the G_IO_OUT
// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_socket_send() even if you were previously notified of a G_IO_OUT condition.
// (On Windows in particular, this is very common due to the way the underlying
// APIs work.)
// 
// The sum of the sizes of each Vector in vectors must not be greater than
// G_MAXSSIZE. If the message can be larger than this, then it is mandatory to
// use the g_socket_send_message_with_timeout() function.
// 
// On error -1 is returned and @error is set accordingly.
	func (s Socket) SendMessage(address SocketAddressClass, vectors []OutputVector, messages []SocketControlMessageClass, flags int, cancellable CancellableClass) (int, error) {
var _arg0 *C.GSocket // out
var _arg1 *C.GSocketAddress // out
var _arg2 *C.GOutputVector
var _arg3 C.gint
var _arg4 **C.GSocketControlMessage
var _arg5 C.gint
var _arg6 C.gint // out
var _arg7 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
_arg3 = C.gint(len(vectors))
_arg2 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
_arg5 = C.gint(len(messages))
_arg4 = (**C.GSocketControlMessage)(C.malloc(C.ulong(len(messages)) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg4))
{
out := unsafe.Slice(_arg4, len(messages))
for i := range messages {
out[i] = (*C.GSocketControlMessage)(unsafe.Pointer(messages[i].Native()))
}
}
_arg6 = (C.gint)(flags)
_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_send_message(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// SendMessageWithTimeout: this behaves exactly the same as
// g_socket_send_message(), except that the choice of timeout behavior is
// determined by the @timeout_us argument rather than by @socket's properties.
// 
// On error G_POLLABLE_RETURN_FAILED is returned and @error is set accordingly,
// or if the socket is currently not writable G_POLLABLE_RETURN_WOULD_BLOCK is
// returned. @bytes_written will contain 0 in both cases.
	func (s Socket) SendMessageWithTimeout(address SocketAddressClass, vectors []OutputVector, messages []SocketControlMessageClass, flags int, timeoutUs int64, cancellable CancellableClass) (uint, PollableReturn, error) {
var _arg0 *C.GSocket // out
var _arg1 *C.GSocketAddress // out
var _arg2 *C.GOutputVector
var _arg3 C.gint
var _arg4 **C.GSocketControlMessage
var _arg5 C.gint
var _arg6 C.gint // out
var _arg7 C.gint64 // out
var _arg8 C.gsize // in
var _arg9 *C.GCancellable // out
var _cret C.GPollableReturn // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
_arg3 = C.gint(len(vectors))
_arg2 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
_arg5 = C.gint(len(messages))
_arg4 = (**C.GSocketControlMessage)(C.malloc(C.ulong(len(messages)) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg4))
{
out := unsafe.Slice(_arg4, len(messages))
for i := range messages {
out[i] = (*C.GSocketControlMessage)(unsafe.Pointer(messages[i].Native()))
}
}
_arg6 = (C.gint)(flags)
_arg7 = (C.gint64)(timeoutUs)
_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_send_message_with_timeout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_arg8, _arg9, &_cerr)


var _bytesWritten uint // out
var _pollableReturn PollableReturn // out
var _goerr error // out

_bytesWritten = (uint)(_arg8)
_pollableReturn = PollableReturn(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _bytesWritten, _pollableReturn, _goerr
}
	
	// SendMessages: send multiple data messages from @socket in one go. This is the
// most complicated and fully-featured version of this call. For easier use, see
// g_socket_send(), g_socket_send_to(), and g_socket_send_message().
// 
// @messages must point to an array of Message structs and @num_messages must be
// the length of this array. Each Message contains an address to send the data
// to, and a pointer to an array of Vector structs to describe the buffers that
// the data to be sent for each message will be gathered from. Using multiple
// Vectors is more memory-efficient than manually copying data from multiple
// sources into a single buffer, and more network-efficient than making multiple
// calls to g_socket_send(). Sending multiple messages in one go avoids the
// overhead of making a lot of syscalls in scenarios where a lot of data packets
// need to be sent (e.g. high-bandwidth video streaming over RTP/UDP), or where
// the same data needs to be sent to multiple recipients.
// 
// @flags modify how the message is sent. The commonly available arguments for
// this are available in the MsgFlags enum, but the values there are the same as
// the system values, and the flags are passed in as-is, so you can pass in
// system-specific flags too.
// 
// If the socket is in blocking mode the call will block until there is space
// for all the data in the socket queue. If there is no space available and the
// socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error will be
// returned if no data was written at all, otherwise the number of messages sent
// will be returned. To be notified when space is available, wait for the
// G_IO_OUT condition. Note though that you may still receive
// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
// notified of a G_IO_OUT condition. (On Windows in particular, this is very
// common due to the way the underlying APIs work.)
// 
// On error -1 is returned and @error is set accordingly. An error will only be
// returned if zero messages could be sent; otherwise the number of messages
// successfully sent before the error will be returned.
	func (s Socket) SendMessages(messages []OutputMessage, flags int, cancellable CancellableClass) (int, error) {
var _arg0 *C.GSocket // out
var _arg1 *C.GOutputMessage
var _arg2 C.guint
var _arg3 C.gint // out
var _arg4 *C.GCancellable // out
var _cret C.gint // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg2 = C.guint(len(messages))
_arg1 = (*C.GOutputMessage)(unsafe.Pointer(&messages[0]))
_arg3 = (C.gint)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_send_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// SendTo tries to send @size bytes from @buffer to @address. If @address is nil
// then the message is sent to the default receiver (set by g_socket_connect()).
// 
// See g_socket_send() for additional information.
	func (s Socket) SendTo(address SocketAddressClass, buffer []byte, cancellable CancellableClass) (int, error) {
var _arg0 *C.GSocket // out
var _arg1 *C.GSocketAddress // out
var _arg2 *C.gchar
var _arg3 C.gsize
var _arg4 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
_arg3 = C.gsize(len(buffer))
_arg2 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_send_to(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// SendWithBlocking: this behaves exactly the same as g_socket_send(), except
// that the choice of blocking or non-blocking behavior is determined by the
// @blocking argument rather than by @socket's properties.
	func (s Socket) SendWithBlocking(buffer []byte, blocking bool, cancellable CancellableClass) (int, error) {
var _arg0 *C.GSocket // out
var _arg1 *C.gchar
var _arg2 C.gsize
var _arg3 C.gboolean // out
var _arg4 *C.GCancellable // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(buffer))
_arg1 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
if blocking { _arg3 = C.TRUE }
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_send_with_blocking(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// SetBlocking sets the blocking mode of the socket. In blocking mode all
// operations (which dont take an explicit blocking parameter) block until they
// succeed or there is an error. In non-blocking mode all functions return
// results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
// 
// All sockets are created in blocking mode. However, note that the platform
// level socket is always non-blocking, and blocking mode is a GSocket level
// feature.
	func (s Socket) SetBlocking(blocking bool)  {
var _arg0 *C.GSocket // out
var _arg1 C.gboolean // out

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
if blocking { _arg1 = C.TRUE }

C.g_socket_set_blocking(_arg0, _arg1)
}
	
	// SetBroadcast sets whether @socket should allow sending to broadcast
// addresses. This is false by default.
	func (s Socket) SetBroadcast(broadcast bool)  {
var _arg0 *C.GSocket // out
var _arg1 C.gboolean // out

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
if broadcast { _arg1 = C.TRUE }

C.g_socket_set_broadcast(_arg0, _arg1)
}
	
	// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying socket.
// When this flag is set on a socket, the system will attempt to verify that the
// remote socket endpoint is still present if a sufficiently long period of time
// passes with no data being exchanged. If the system is unable to verify the
// presence of the remote endpoint, it will automatically close the connection.
// 
// This option is only functional on certain kinds of sockets. (Notably,
// G_SOCKET_PROTOCOL_TCP sockets.)
// 
// The exact time between pings is system- and protocol-dependent, but will
// normally be at least two hours. Most commonly, you would set this flag on a
// server socket if you want to allow clients to remain idle for long periods of
// time, but also want to ensure that connections are eventually
// garbage-collected if clients crash or become unreachable.
	func (s Socket) SetKeepalive(keepalive bool)  {
var _arg0 *C.GSocket // out
var _arg1 C.gboolean // out

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
if keepalive { _arg1 = C.TRUE }

C.g_socket_set_keepalive(_arg0, _arg1)
}
	
	// SetListenBacklog sets the maximum number of outstanding connections allowed
// when listening on this socket. If more clients than this are connecting to
// the socket and the application is not handling them on time then the new
// connections will be refused.
// 
// Note that this must be called before g_socket_listen() and has no effect if
// called after that.
	func (s Socket) SetListenBacklog(backlog int)  {
var _arg0 *C.GSocket // out
var _arg1 C.gint // out

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(backlog)

C.g_socket_set_listen_backlog(_arg0, _arg1)
}
	
	// SetMulticastLoopback sets whether outgoing multicast packets will be received
// by sockets listening on that multicast address on the same host. This is true
// by default.
	func (s Socket) SetMulticastLoopback(loopback bool)  {
var _arg0 *C.GSocket // out
var _arg1 C.gboolean // out

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
if loopback { _arg1 = C.TRUE }

C.g_socket_set_multicast_loopback(_arg0, _arg1)
}
	
	// SetMulticastTTL sets the time-to-live for outgoing multicast datagrams on
// @socket. By default, this is 1, meaning that multicast packets will not leave
// the local network.
	func (s Socket) SetMulticastTTL(ttl uint)  {
var _arg0 *C.GSocket // out
var _arg1 C.guint // out

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(ttl)

C.g_socket_set_multicast_ttl(_arg0, _arg1)
}
	
	// SetOption sets the value of an integer-valued option on @socket, as with
// setsockopt(). (If you need to set a non-integer-valued option, you will need
// to call setsockopt() directly.)
// 
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system headers
// that will define most of the standard/portable socket options. For unusual
// socket protocols or platform-dependent options, you may need to include
// additional headers.
	func (s Socket) SetOption(level int, optname int, value int) error {
var _arg0 *C.GSocket // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(level)
_arg2 = (C.gint)(optname)
_arg3 = (C.gint)(value)

C.g_socket_set_option(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetTimeout sets the time in seconds after which I/O operations on @socket
// will time out if they have not yet completed.
// 
// On a blocking socket, this means that any blocking #GSocket operation will
// time out after @timeout seconds of inactivity, returning
// G_IO_ERROR_TIMED_OUT.
// 
// On a non-blocking socket, calls to g_socket_condition_wait() will also fail
// with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
// g_socket_create_source() will trigger after @timeout seconds of inactivity,
// with the requested condition set, at which point calling g_socket_receive(),
// g_socket_send(), g_socket_check_connect_result(), etc, will fail with
// G_IO_ERROR_TIMED_OUT.
// 
// If @timeout is 0 (the default), operations will never time out on their own.
// 
// Note that if an I/O operation is interrupted by a signal, this may cause the
// timeout to be reset.
	func (s Socket) SetTimeout(timeout uint)  {
var _arg0 *C.GSocket // out
var _arg1 C.guint // out

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(timeout)

C.g_socket_set_timeout(_arg0, _arg1)
}
	
	// SetTTL sets the time-to-live for outgoing unicast packets on @socket. By
// default the platform-specific default value is used.
	func (s Socket) SetTTL(ttl uint)  {
var _arg0 *C.GSocket // out
var _arg1 C.guint // out

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(ttl)

C.g_socket_set_ttl(_arg0, _arg1)
}
	
	// Shutdown: shut down part or all of a full-duplex connection.
// 
// If @shutdown_read is true then the receiving side of the connection is shut
// down, and further reading is disallowed.
// 
// If @shutdown_write is true then the sending side of the connection is shut
// down, and further writing is disallowed.
// 
// It is allowed for both @shutdown_read and @shutdown_write to be true.
// 
// One example where it is useful to shut down only one side of a connection is
// graceful disconnect for TCP connections where you close the sending side,
// then wait for the other side to close the connection, thus ensuring that the
// other side saw all sent data.
	func (s Socket) Shutdown(shutdownRead bool, shutdownWrite bool) error {
var _arg0 *C.GSocket // out
var _arg1 C.gboolean // out
var _arg2 C.gboolean // out
var _cerr *C.GError // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
if shutdownRead { _arg1 = C.TRUE }
if shutdownWrite { _arg2 = C.TRUE }

C.g_socket_shutdown(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SpeaksIPv4 checks if a socket is capable of speaking IPv4.
// 
// IPv4 sockets are capable of speaking IPv4. On some operating systems and
// under some combinations of circumstances IPv6 sockets are also capable of
// speaking IPv4. See RFC 3493 section 3.7 for more information.
// 
// No other types of sockets are currently considered as being capable of
// speaking IPv4.
	func (s Socket) SpeaksIPv4() bool {
var _arg0 *C.GSocket // out
var _cret C.gboolean // in

_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_speaks_ipv4(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// SocketAddress is the equivalent of struct sockaddr in the BSD sockets API.
// This is an abstract class; use SocketAddress for internet sockets, or
// SocketAddress for UNIX domain sockets.
	type SocketAddress struct {
		**externglib.Object
		SocketConnectable
		
	}

	// SocketAddressClass is an interface that the SocketAddress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SocketAddressClass interface {
		gextras.Objector
		_socketAddress()
	}

	func (SocketAddress) _socketAddress() {}

	
	func marshalSocketAddress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSocketAddress(obj), nil
	}
	

	

	
	// Family gets the socket family type of @address.
	func (a SocketAddress) Family() SocketFamily {
var _arg0 *C.GSocketAddress // out
var _cret C.GSocketFamily // in

_arg0 = (*C.GSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_socket_address_get_family(_arg0)


var _socketFamily SocketFamily // out

_socketFamily = SocketFamily(_cret)

return _socketFamily
}
	
	// NativeSize gets the size of @address's native struct sockaddr. You can use
// this to allocate memory to pass to g_socket_address_to_native().
	func (a SocketAddress) NativeSize() int {
var _arg0 *C.GSocketAddress // out
var _cret C.gssize // in

_arg0 = (*C.GSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_socket_address_get_native_size(_arg0)


var _gssize int // out

_gssize = (int)(_cret)

return _gssize
}
	


	// SocketAddressEnumerator is an enumerator type for Address instances. It is
// returned by enumeration functions such as g_socket_connectable_enumerate(),
// which returns a AddressEnumerator to list each Address which could be used to
// connect to that Connectable.
// 
// Enumeration is typically a blocking operation, so the asynchronous methods
// g_socket_address_enumerator_next_async() and
// g_socket_address_enumerator_next_finish() should be used where possible.
// 
// Each AddressEnumerator can only be enumerated once. Once
// g_socket_address_enumerator_next() has returned nil, further enumeration with
// that AddressEnumerator is not possible, and it can be unreffed.
	type SocketAddressEnumerator struct {
		**externglib.Object
		
	}

	// SocketAddressEnumeratorClass is an interface that the SocketAddressEnumerator class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SocketAddressEnumeratorClass interface {
		gextras.Objector
		_socketAddressEnumerator()
	}

	func (SocketAddressEnumerator) _socketAddressEnumerator() {}

	
	func marshalSocketAddressEnumerator(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSocketAddressEnumerator(obj), nil
	}
	

	

	
	// Next retrieves the next Address from @enumerator. Note that this may block
// for some amount of time. (Eg, a Address may need to do a DNS lookup before it
// can return an address.) Use g_socket_address_enumerator_next_async() if you
// need to avoid blocking.
// 
// If @enumerator is expected to yield addresses, but for some reason is unable
// to (eg, because of a DNS error), then the first call to
// g_socket_address_enumerator_next() will return an appropriate error in
// *@error. However, if the first call to g_socket_address_enumerator_next()
// succeeds, then any further internal errors (other than @cancellable being
// triggered) will be ignored.
	func (e SocketAddressEnumerator) Next(cancellable CancellableClass) (SocketAddress, error) {
var _arg0 *C.GSocketAddressEnumerator // out
var _arg1 *C.GCancellable // out
var _cret *C.GSocketAddress // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_address_enumerator_next(_arg0, _arg1, &_cerr)


var _socketAddress SocketAddress // out
var _goerr error // out

_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketAddress, _goerr
}
	
	// NextFinish retrieves the result of a completed call to
// g_socket_address_enumerator_next_async(). See
// g_socket_address_enumerator_next() for more information about error handling.
	func (e SocketAddressEnumerator) NextFinish(result AsyncResult) (SocketAddress, error) {
var _arg0 *C.GSocketAddressEnumerator // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GSocketAddress // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_socket_address_enumerator_next_finish(_arg0, _arg1, &_cerr)


var _socketAddress SocketAddress // out
var _goerr error // out

_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketAddress, _goerr
}
	


	// SocketClient is a lightweight high-level utility class for connecting to a
// network host using a connection oriented socket type.
// 
// You create a Client object, set any options you want, and then call a sync or
// async connect operation, which returns a Connection subclass on success.
// 
// The type of the Connection object returned depends on the type of the
// underlying socket that is in use. For instance, for a TCP/IP connection it
// will be a Connection.
// 
// As Client is a lightweight object, you don't need to cache it. You can just
// create a new one any time you need one.
	type SocketClient struct {
		**externglib.Object
		
	}

	// SocketClientClass is an interface that the SocketClient class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SocketClientClass interface {
		gextras.Objector
		_socketClient()
	}

	func (SocketClient) _socketClient() {}

	
	func marshalSocketClient(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSocketClient(obj), nil
	}
	

	
	// NewSocketClient creates a new Client with the default options.
	func NewSocketClient() SocketClient {
var _cret *C.GSocketClient // in

_cret = C.g_socket_client_new()


var _socketClient SocketClient // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_socketClient = SocketClient{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _socketClient
}
	

	
	// AddApplicationProXY: enable proxy protocols to be handled by the application.
// When the indicated proxy protocol is returned by the Resolver, Client will
// consider this protocol as supported but will not try to find a #GProxy
// instance to handle handshaking. The application must check for this case by
// calling g_socket_connection_get_remote_address() on the returned Connection,
// and seeing if it's a Address of the appropriate type, to determine whether or
// not it needs to handle the proxy handshaking itself.
// 
// This should be used for proxy protocols that are dialects of another protocol
// such as HTTP proxy. It also allows cohabitation of proxy protocols that are
// reused between protocols. A good example is HTTP. It can be used to proxy
// HTTP, FTP and Gopher and can also be use as generic socket proxy through the
// HTTP CONNECT method.
// 
// When the proxy is detected as being an application proxy, TLS handshake will
// be skipped. This is required to let the application do the proxy specific
// handshake.
	func (c SocketClient) AddApplicationProXY(protocol string)  {
var _arg0 *C.GSocketClient // out
var _arg1 *C.gchar // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(protocol))
defer C.free(unsafe.Pointer(_arg1))

C.g_socket_client_add_application_proxy(_arg0, _arg1)
}
	
	// ConnectSocketClient tries to resolve the @connectable and make a network
// connection to it.
// 
// Upon a successful connection, a new Connection is constructed and returned.
// The caller owns this new object and must drop their reference to it when
// finished with it.
// 
// The type of the Connection object returned depends on the type of the
// underlying socket that is used. For instance, for a TCP/IP connection it will
// be a Connection.
// 
// The socket created will be the same family as the address that the
// @connectable resolves to, unless family is set with
// g_socket_client_set_family() or indirectly via
// g_socket_client_set_local_address(). The socket type defaults to
// G_SOCKET_TYPE_STREAM but can be set with g_socket_client_set_socket_type().
// 
// If a local address is specified with g_socket_client_set_local_address() the
// socket will be bound to this address before connecting.
	func (c SocketClient) ConnectSocketClient(connectable SocketConnectable, cancellable CancellableClass) (SocketConnection, error) {
var _arg0 *C.GSocketClient // out
var _arg1 *C.GSocketConnectable // out
var _arg2 *C.GCancellable // out
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(connectable.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_client_connect(_arg0, _arg1, _arg2, &_cerr)


var _socketConnection SocketConnection // out
var _goerr error // out

_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketConnection, _goerr
}
	
	// ConnectFinish finishes an async connect operation. See
// g_socket_client_connect_async()
	func (c SocketClient) ConnectFinish(result AsyncResult) (SocketConnection, error) {
var _arg0 *C.GSocketClient // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_socket_client_connect_finish(_arg0, _arg1, &_cerr)


var _socketConnection SocketConnection // out
var _goerr error // out

_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketConnection, _goerr
}
	
	// ConnectToHost: this is a helper function for g_socket_client_connect().
// 
// Attempts to create a TCP connection to the named host.
// 
// @host_and_port may be in any of a number of recognized formats; an IPv6
// address, an IPv4 address, or a domain name (in which case a DNS lookup is
// performed). Quoting with [] is supported for all address types. A port
// override may be specified in the usual way with a colon. Ports may be given
// as decimal numbers or symbolic names (in which case an /etc/services lookup
// is performed).
// 
// If no port override is given in @host_and_port then @default_port will be
// used as the port number to connect to.
// 
// In general, @host_and_port is expected to be provided by the user (allowing
// them to give the hostname, and a port override if necessary) and
// @default_port is expected to be provided by the application.
// 
// In the case that an IP address is given, a single connection attempt is made.
// In the case that a name is given, multiple connection attempts may be made,
// in turn and according to the number of address records in DNS, until a
// connection succeeds.
// 
// Upon a successful connection, a new Connection is constructed and returned.
// The caller owns this new object and must drop their reference to it when
// finished with it.
// 
// In the event of any failure (DNS error, service not found, no hosts
// connectable) nil is returned and @error (if non-nil) is set accordingly.
	func (c SocketClient) ConnectToHost(hostAndPort string, defaultPort uint16, cancellable CancellableClass) (SocketConnection, error) {
var _arg0 *C.GSocketClient // out
var _arg1 *C.gchar // out
var _arg2 C.guint16 // out
var _arg3 *C.GCancellable // out
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(hostAndPort))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint16)(defaultPort)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_client_connect_to_host(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _socketConnection SocketConnection // out
var _goerr error // out

_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketConnection, _goerr
}
	
	// ConnectToHostFinish finishes an async connect operation. See
// g_socket_client_connect_to_host_async()
	func (c SocketClient) ConnectToHostFinish(result AsyncResult) (SocketConnection, error) {
var _arg0 *C.GSocketClient // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_socket_client_connect_to_host_finish(_arg0, _arg1, &_cerr)


var _socketConnection SocketConnection // out
var _goerr error // out

_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketConnection, _goerr
}
	
	// ConnectToService attempts to create a TCP connection to a service.
// 
// This call looks up the SRV record for @service at @domain for the "tcp"
// protocol. It then attempts to connect, in turn, to each of the hosts
// providing the service until either a connection succeeds or there are no
// hosts remaining.
// 
// Upon a successful connection, a new Connection is constructed and returned.
// The caller owns this new object and must drop their reference to it when
// finished with it.
// 
// In the event of any failure (DNS error, service not found, no hosts
// connectable) nil is returned and @error (if non-nil) is set accordingly.
	func (c SocketClient) ConnectToService(domain string, service string, cancellable CancellableClass) (SocketConnection, error) {
var _arg0 *C.GSocketClient // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.GCancellable // out
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(domain))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(service))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_client_connect_to_service(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _socketConnection SocketConnection // out
var _goerr error // out

_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketConnection, _goerr
}
	
	// ConnectToServiceFinish finishes an async connect operation. See
// g_socket_client_connect_to_service_async()
	func (c SocketClient) ConnectToServiceFinish(result AsyncResult) (SocketConnection, error) {
var _arg0 *C.GSocketClient // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_socket_client_connect_to_service_finish(_arg0, _arg1, &_cerr)


var _socketConnection SocketConnection // out
var _goerr error // out

_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketConnection, _goerr
}
	
	// ConnectToURI: this is a helper function for g_socket_client_connect().
// 
// Attempts to create a TCP connection with a network URI.
// 
// @uri may be any valid URI containing an "authority" (hostname/port)
// component. If a port is not specified in the URI, @default_port will be used.
// TLS will be negotiated if Client:tls is true. (Client does not know to
// automatically assume TLS for certain URI schemes.)
// 
// Using this rather than g_socket_client_connect() or
// g_socket_client_connect_to_host() allows Client to determine when to use
// application-specific proxy protocols.
// 
// Upon a successful connection, a new Connection is constructed and returned.
// The caller owns this new object and must drop their reference to it when
// finished with it.
// 
// In the event of any failure (DNS error, service not found, no hosts
// connectable) nil is returned and @error (if non-nil) is set accordingly.
	func (c SocketClient) ConnectToURI(uri string, defaultPort uint16, cancellable CancellableClass) (SocketConnection, error) {
var _arg0 *C.GSocketClient // out
var _arg1 *C.gchar // out
var _arg2 C.guint16 // out
var _arg3 *C.GCancellable // out
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint16)(defaultPort)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_client_connect_to_uri(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _socketConnection SocketConnection // out
var _goerr error // out

_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketConnection, _goerr
}
	
	// ConnectToURIFinish finishes an async connect operation. See
// g_socket_client_connect_to_uri_async()
	func (c SocketClient) ConnectToURIFinish(result AsyncResult) (SocketConnection, error) {
var _arg0 *C.GSocketClient // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_socket_client_connect_to_uri_finish(_arg0, _arg1, &_cerr)


var _socketConnection SocketConnection // out
var _goerr error // out

_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketConnection, _goerr
}
	
	// EnableProXY gets the proxy enable state; see
// g_socket_client_set_enable_proxy()
	func (c SocketClient) EnableProXY() bool {
var _arg0 *C.GSocketClient // out
var _cret C.gboolean // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_client_get_enable_proxy(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Family gets the socket family of the socket client.
// 
// See g_socket_client_set_family() for details.
	func (c SocketClient) Family() SocketFamily {
var _arg0 *C.GSocketClient // out
var _cret C.GSocketFamily // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_client_get_family(_arg0)


var _socketFamily SocketFamily // out

_socketFamily = SocketFamily(_cret)

return _socketFamily
}
	
	// LocalAddress gets the local address of the socket client.
// 
// See g_socket_client_set_local_address() for details.
	func (c SocketClient) LocalAddress() SocketAddress {
var _arg0 *C.GSocketClient // out
var _cret *C.GSocketAddress // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_client_get_local_address(_arg0)


var _socketAddress SocketAddress // out

_socketAddress = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SocketAddress)

return _socketAddress
}
	
	// Protocol gets the protocol name type of the socket client.
// 
// See g_socket_client_set_protocol() for details.
	func (c SocketClient) Protocol() SocketProtocol {
var _arg0 *C.GSocketClient // out
var _cret C.GSocketProtocol // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_client_get_protocol(_arg0)


var _socketProtocol SocketProtocol // out

_socketProtocol = SocketProtocol(_cret)

return _socketProtocol
}
	
	// ProXYResolver gets the Resolver being used by @client. Normally, this will be
// the resolver returned by g_proxy_resolver_get_default(), but you can override
// it with g_socket_client_set_proxy_resolver().
	func (c SocketClient) ProXYResolver() ProXYResolver {
var _arg0 *C.GSocketClient // out
var _cret *C.GProxyResolver // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_client_get_proxy_resolver(_arg0)


var _proxyResolver ProXYResolver // out

_proxyResolver = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ProXYResolver)

return _proxyResolver
}
	
	// SocketType gets the socket type of the socket client.
// 
// See g_socket_client_set_socket_type() for details.
	func (c SocketClient) SocketType() SocketType {
var _arg0 *C.GSocketClient // out
var _cret C.GSocketType // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_client_get_socket_type(_arg0)


var _socketType SocketType // out

_socketType = SocketType(_cret)

return _socketType
}
	
	// Timeout gets the I/O timeout time for sockets created by @client.
// 
// See g_socket_client_set_timeout() for details.
	func (c SocketClient) Timeout() uint {
var _arg0 *C.GSocketClient // out
var _cret C.guint // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_client_get_timeout(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// TLS gets whether @client creates TLS connections. See
// g_socket_client_set_tls() for details.
	func (c SocketClient) TLS() bool {
var _arg0 *C.GSocketClient // out
var _cret C.gboolean // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_client_get_tls(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TLSValidationFlags gets the TLS validation flags used creating TLS
// connections via @client.
	func (c SocketClient) TLSValidationFlags() TLSCertificateFlags {
var _arg0 *C.GSocketClient // out
var _cret C.GTlsCertificateFlags // in

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_client_get_tls_validation_flags(_arg0)


var _tlsCertificateFlags TLSCertificateFlags // out

_tlsCertificateFlags = TLSCertificateFlags(_cret)

return _tlsCertificateFlags
}
	
	// SetEnableProXY sets whether or not @client attempts to make connections via a
// proxy server. When enabled (the default), Client will use a Resolver to
// determine if a proxy protocol such as SOCKS is needed, and automatically do
// the necessary proxy negotiation.
// 
// See also g_socket_client_set_proxy_resolver().
	func (c SocketClient) SetEnableProXY(enable bool)  {
var _arg0 *C.GSocketClient // out
var _arg1 C.gboolean // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
if enable { _arg1 = C.TRUE }

C.g_socket_client_set_enable_proxy(_arg0, _arg1)
}
	
	// SetFamily sets the socket family of the socket client. If this is set to
// something other than G_SOCKET_FAMILY_INVALID then the sockets created by this
// object will be of the specified family.
// 
// This might be useful for instance if you want to force the local connection
// to be an ipv4 socket, even though the address might be an ipv6 mapped to ipv4
// address.
	func (c SocketClient) SetFamily(family SocketFamily)  {
var _arg0 *C.GSocketClient // out
var _arg1 C.GSocketFamily // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (C.GSocketFamily)(family)

C.g_socket_client_set_family(_arg0, _arg1)
}
	
	// SetLocalAddress sets the local address of the socket client. The sockets
// created by this object will bound to the specified address (if not nil)
// before connecting.
// 
// This is useful if you want to ensure that the local side of the connection is
// on a specific port, or on a specific interface.
	func (c SocketClient) SetLocalAddress(address SocketAddressClass)  {
var _arg0 *C.GSocketClient // out
var _arg1 *C.GSocketAddress // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))

C.g_socket_client_set_local_address(_arg0, _arg1)
}
	
	// SetProtocol sets the protocol of the socket client. The sockets created by
// this object will use of the specified protocol.
// 
// If @protocol is G_SOCKET_PROTOCOL_DEFAULT that means to use the default
// protocol for the socket family and type.
	func (c SocketClient) SetProtocol(protocol SocketProtocol)  {
var _arg0 *C.GSocketClient // out
var _arg1 C.GSocketProtocol // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (C.GSocketProtocol)(protocol)

C.g_socket_client_set_protocol(_arg0, _arg1)
}
	
	// SetProXYResolver overrides the Resolver used by @client. You can call this if
// you want to use specific proxies, rather than using the system default proxy
// settings.
// 
// Note that whether or not the proxy resolver is actually used depends on the
// setting of Client:enable-proxy, which is not changed by this function (but
// which is true by default)
	func (c SocketClient) SetProXYResolver(proxyResolver ProXYResolver)  {
var _arg0 *C.GSocketClient // out
var _arg1 *C.GProxyResolver // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GProxyResolver)(unsafe.Pointer(proxyResolver.Native()))

C.g_socket_client_set_proxy_resolver(_arg0, _arg1)
}
	
	// SetSocketType sets the socket type of the socket client. The sockets created
// by this object will be of the specified type.
// 
// It doesn't make sense to specify a type of G_SOCKET_TYPE_DATAGRAM, as
// GSocketClient is used for connection oriented services.
	func (c SocketClient) SetSocketType(typ SocketType)  {
var _arg0 *C.GSocketClient // out
var _arg1 C.GSocketType // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (C.GSocketType)(typ)

C.g_socket_client_set_socket_type(_arg0, _arg1)
}
	
	// SetTimeout sets the I/O timeout for sockets created by @client. @timeout is a
// time in seconds, or 0 for no timeout (the default).
// 
// The timeout value affects the initial connection attempt as well, so setting
// this may cause calls to g_socket_client_connect(), etc, to fail with
// G_IO_ERROR_TIMED_OUT.
	func (c SocketClient) SetTimeout(timeout uint)  {
var _arg0 *C.GSocketClient // out
var _arg1 C.guint // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(timeout)

C.g_socket_client_set_timeout(_arg0, _arg1)
}
	
	// SetTLS sets whether @client creates TLS (aka SSL) connections. If @tls is
// true, @client will wrap its connections in a ClientConnection and perform a
// TLS handshake when connecting.
// 
// Note that since Client must return a Connection, but ClientConnection is not
// a Connection, this actually wraps the resulting ClientConnection in a
// WrapperConnection when returning it. You can use
// g_tcp_wrapper_connection_get_base_io_stream() on the return value to extract
// the ClientConnection.
// 
// If you need to modify the behavior of the TLS handshake (eg, by setting a
// client-side certificate to use, or connecting to the
// Connection::accept-certificate signal), you can connect to @client's
// Client::event signal and wait for it to be emitted with
// G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you a chance to see the
// ClientConnection before the handshake starts.
	func (c SocketClient) SetTLS(tls bool)  {
var _arg0 *C.GSocketClient // out
var _arg1 C.gboolean // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
if tls { _arg1 = C.TRUE }

C.g_socket_client_set_tls(_arg0, _arg1)
}
	
	// SetTLSValidationFlags sets the TLS validation flags used when creating TLS
// connections via @client. The default value is G_TLS_CERTIFICATE_VALIDATE_ALL.
	func (c SocketClient) SetTLSValidationFlags(flags TLSCertificateFlags)  {
var _arg0 *C.GSocketClient // out
var _arg1 C.GTlsCertificateFlags // out

_arg0 = (*C.GSocketClient)(unsafe.Pointer(c.Native()))
_arg1 = (C.GTlsCertificateFlags)(flags)

C.g_socket_client_set_tls_validation_flags(_arg0, _arg1)
}
	


	// SocketConnection is a OStream for a connected socket. They can be created
// either by Client when connecting to a host, or by Listener when accepting a
// new client.
// 
// The type of the Connection object returned from these calls depends on the
// type of the underlying socket that is in use. For instance, for a TCP/IP
// connection it will be a Connection.
// 
// Choosing what type of object to construct is done with the socket connection
// factory, and it is possible for 3rd parties to register custom socket
// connection types for specific combination of socket family/type/protocol
// using g_socket_connection_factory_register_type().
// 
// To close a Connection, use g_io_stream_close(). Closing both substreams of
// the OStream separately will not close the underlying #GSocket.
	type SocketConnection struct {
		IOStream
		
	}

	// SocketConnectionClass is an interface that the SocketConnection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SocketConnectionClass interface {
		gextras.Objector
		_socketConnection()
	}

	func (SocketConnection) _socketConnection() {}

	
	func marshalSocketConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSocketConnection(obj), nil
	}
	

	

	
	// ConnectSocketConnection: connect @connection to the specified remote address.
	func (c SocketConnection) ConnectSocketConnection(address SocketAddressClass, cancellable CancellableClass) error {
var _arg0 *C.GSocketConnection // out
var _arg1 *C.GSocketAddress // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_socket_connection_connect(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ConnectFinish gets the result of a g_socket_connection_connect_async() call.
	func (c SocketConnection) ConnectFinish(result AsyncResult) error {
var _arg0 *C.GSocketConnection // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_socket_connection_connect_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LocalAddress: try to get the local address of a socket connection.
	func (c SocketConnection) LocalAddress() (SocketAddress, error) {
var _arg0 *C.GSocketConnection // out
var _cret *C.GSocketAddress // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_connection_get_local_address(_arg0, &_cerr)


var _socketAddress SocketAddress // out
var _goerr error // out

_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketAddress, _goerr
}
	
	// RemoteAddress: try to get the remote address of a socket connection.
// 
// Since GLib 2.40, when used with g_socket_client_connect() or
// g_socket_client_connect_async(), during emission of
// G_SOCKET_CLIENT_CONNECTING, this function will return the remote address that
// will be used for the connection. This allows applications to print e.g.
// "Connecting to example.com (10.42.77.3)...".
	func (c SocketConnection) RemoteAddress() (SocketAddress, error) {
var _arg0 *C.GSocketConnection // out
var _cret *C.GSocketAddress // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_connection_get_remote_address(_arg0, &_cerr)


var _socketAddress SocketAddress // out
var _goerr error // out

_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _socketAddress, _goerr
}
	
	// Socket gets the underlying #GSocket object of the connection. This can be
// useful if you want to do something unusual on it not supported by the
// Connection APIs.
	func (c SocketConnection) Socket() Socket {
var _arg0 *C.GSocketConnection // out
var _cret *C.GSocket // in

_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_connection_get_socket(_arg0)


var _socket Socket // out

_socket = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Socket)

return _socket
}
	
	// IsConnected checks if @connection is connected. This is equivalent to calling
// g_socket_is_connected() on @connection's underlying #GSocket.
	func (c SocketConnection) IsConnected() bool {
var _arg0 *C.GSocketConnection // out
var _cret C.gboolean // in

_arg0 = (*C.GSocketConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_socket_connection_is_connected(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// SocketControlMessage: a ControlMessage is a special-purpose utility message
// that can be sent to or received from a #GSocket. These types of messages are
// often called "ancillary data".
// 
// The message can represent some sort of special instruction to or information
// from the socket or can represent a special kind of transfer to the peer (for
// example, sending a file descriptor over a UNIX socket).
// 
// These messages are sent with g_socket_send_message() and received with
// g_socket_receive_message().
// 
// To extend the set of control message that can be sent, subclass this class
// and override the get_size, get_level, get_type and serialize methods.
// 
// To extend the set of control messages that can be received, subclass this
// class and implement the deserialize method. Also, make sure your class is
// registered with the GType typesystem before calling
// g_socket_receive_message() to read such a message.
	type SocketControlMessage struct {
		**externglib.Object
		
	}

	// SocketControlMessageClass is an interface that the SocketControlMessage class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SocketControlMessageClass interface {
		gextras.Objector
		_socketControlMessage()
	}

	func (SocketControlMessage) _socketControlMessage() {}

	
	func marshalSocketControlMessage(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSocketControlMessage(obj), nil
	}
	

	

	
	// Level returns the "level" (i.e. the originating protocol) of the control
// message. This is often SOL_SOCKET.
	func (m SocketControlMessage) Level() int {
var _arg0 *C.GSocketControlMessage // out
var _cret C.int // in

_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_socket_control_message_get_level(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MsgType returns the protocol specific type of the control message. For
// instance, for UNIX fd passing this would be SCM_RIGHTS.
	func (m SocketControlMessage) MsgType() int {
var _arg0 *C.GSocketControlMessage // out
var _cret C.int // in

_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_socket_control_message_get_msg_type(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Size returns the space required for the control message, not including
// headers or alignment.
	func (m SocketControlMessage) Size() uint {
var _arg0 *C.GSocketControlMessage // out
var _cret C.gsize // in

_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_socket_control_message_get_size(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	


	// SocketListener: a Listener is an object that keeps track of a set of server
// sockets and helps you accept sockets from any of the socket, either sync or
// async.
// 
// Add addresses and ports to listen on using g_socket_listener_add_address()
// and g_socket_listener_add_inet_port(). These will be listened on until
// g_socket_listener_close() is called. Dropping your final reference to the
// Listener will not cause g_socket_listener_close() to be called implicitly, as
// some references to the Listener may be held internally.
// 
// If you want to implement a network server, also look at Service and
// SocketService which are subclasses of Listener that make this even easier.
	type SocketListener struct {
		**externglib.Object
		
	}

	// SocketListenerClass is an interface that the SocketListener class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SocketListenerClass interface {
		gextras.Objector
		_socketListener()
	}

	func (SocketListener) _socketListener() {}

	
	func marshalSocketListener(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSocketListener(obj), nil
	}
	

	
	// NewSocketListener creates a new Listener with no sockets to listen for. New
// listeners can be added with e.g. g_socket_listener_add_address() or
// g_socket_listener_add_inet_port().
	func NewSocketListener() SocketListener {
var _cret *C.GSocketListener // in

_cret = C.g_socket_listener_new()


var _socketListener SocketListener // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_socketListener = SocketListener{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _socketListener
}
	

	
	// Accept blocks waiting for a client to connect to any of the sockets added to
// the listener. Returns a Connection for the socket that was accepted.
// 
// If @source_object is not nil it will be filled out with the source object
// specified when the corresponding socket or address was added to the listener.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (l SocketListener) Accept(cancellable CancellableClass) (*externglib.Object, SocketConnection, error) {
var _arg0 *C.GSocketListener // out
var _arg1 *C.GObject // in
var _arg2 *C.GCancellable // out
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_listener_accept(_arg0, &_arg1, _arg2, &_cerr)


var _sourceObject *externglib.Object // out
var _socketConnection SocketConnection // out
var _goerr error // out

_sourceObject = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(*externglib.Object)
_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _sourceObject, _socketConnection, _goerr
}
	
	// AcceptFinish finishes an async accept operation. See
// g_socket_listener_accept_async()
	func (l SocketListener) AcceptFinish(result AsyncResult) (*externglib.Object, SocketConnection, error) {
var _arg0 *C.GSocketListener // out
var _arg1 *C.GAsyncResult // out
var _arg2 *C.GObject // in
var _cret *C.GSocketConnection // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_socket_listener_accept_finish(_arg0, _arg1, &_arg2, &_cerr)


var _sourceObject *externglib.Object // out
var _socketConnection SocketConnection // out
var _goerr error // out

_sourceObject = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(*externglib.Object)
_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _sourceObject, _socketConnection, _goerr
}
	
	// AcceptSocket blocks waiting for a client to connect to any of the sockets
// added to the listener. Returns the #GSocket that was accepted.
// 
// If you want to accept the high-level Connection, not a #GSocket, which is
// often the case, then you should use g_socket_listener_accept() instead.
// 
// If @source_object is not nil it will be filled out with the source object
// specified when the corresponding socket or address was added to the listener.
// 
// If @cancellable is not nil, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
	func (l SocketListener) AcceptSocket(cancellable CancellableClass) (*externglib.Object, Socket, error) {
var _arg0 *C.GSocketListener // out
var _arg1 *C.GObject // in
var _arg2 *C.GCancellable // out
var _cret *C.GSocket // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_socket_listener_accept_socket(_arg0, &_arg1, _arg2, &_cerr)


var _sourceObject *externglib.Object // out
var _socket Socket // out
var _goerr error // out

_sourceObject = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(*externglib.Object)
_socket = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _sourceObject, _socket, _goerr
}
	
	// AcceptSocketFinish finishes an async accept operation. See
// g_socket_listener_accept_socket_async()
	func (l SocketListener) AcceptSocketFinish(result AsyncResult) (*externglib.Object, Socket, error) {
var _arg0 *C.GSocketListener // out
var _arg1 *C.GAsyncResult // out
var _arg2 *C.GObject // in
var _cret *C.GSocket // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_socket_listener_accept_socket_finish(_arg0, _arg1, &_arg2, &_cerr)


var _sourceObject *externglib.Object // out
var _socket Socket // out
var _goerr error // out

_sourceObject = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(*externglib.Object)
_socket = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _sourceObject, _socket, _goerr
}
	
	// AddAddress creates a socket of type @type and protocol @protocol, binds it to
// @address and adds it to the set of sockets we're accepting sockets from.
// 
// Note that adding an IPv6 address, depending on the platform, may or may not
// result in a listener that also accepts IPv4 connections. For more
// deterministic behavior, see g_socket_listener_add_inet_port().
// 
// @source_object will be passed out in the various calls to accept to identify
// this particular source, which is useful if you're listening on multiple
// addresses and do different things depending on what address is connected to.
// 
// If successful and @effective_address is non-nil then it will be set to the
// address that the binding actually occurred at. This is helpful for
// determining the port number that was used for when requesting a binding to
// port 0 (ie: "any port"). This address, if requested, belongs to the caller
// and must be freed.
// 
// Call g_socket_listener_close() to stop listening on @address; this will not
// be done automatically when you drop your final reference to @listener, as
// references may be held internally.
	func (l SocketListener) AddAddress(address SocketAddressClass, typ SocketType, protocol SocketProtocol, sourceObject **externglib.Object) (SocketAddress, error) {
var _arg0 *C.GSocketListener // out
var _arg1 *C.GSocketAddress // out
var _arg2 C.GSocketType // out
var _arg3 C.GSocketProtocol // out
var _arg4 *C.GObject // out
var _arg5 *C.GSocketAddress // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
_arg2 = (C.GSocketType)(typ)
_arg3 = (C.GSocketProtocol)(protocol)
_arg4 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

C.g_socket_listener_add_address(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)

var _effectiveAddress SocketAddress // out
var _goerr error // out

_effectiveAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg5))).(SocketAddress)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _effectiveAddress, _goerr
}
	
	// AddAnyInetPort listens for TCP connections on any available port number for
// both IPv6 and IPv4 (if each is available).
// 
// This is useful if you need to have a socket for incoming connections but
// don't care about the specific port number.
// 
// @source_object will be passed out in the various calls to accept to identify
// this particular source, which is useful if you're listening on multiple
// addresses and do different things depending on what address is connected to.
	func (l SocketListener) AddAnyInetPort(sourceObject **externglib.Object) (uint16, error) {
var _arg0 *C.GSocketListener // out
var _arg1 *C.GObject // out
var _cret C.guint16 // in
var _cerr *C.GError // in

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

_cret = C.g_socket_listener_add_any_inet_port(_arg0, _arg1, &_cerr)


var _guint16 uint16 // out
var _goerr error // out

_guint16 = (uint16)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint16, _goerr
}
	
	// AddInetPort: helper function for g_socket_listener_add_address() that creates
// a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the specified
// port on all interfaces.
// 
// @source_object will be passed out in the various calls to accept to identify
// this particular source, which is useful if you're listening on multiple
// addresses and do different things depending on what address is connected to.
// 
// Call g_socket_listener_close() to stop listening on @port; this will not be
// done automatically when you drop your final reference to @listener, as
// references may be held internally.
	func (l SocketListener) AddInetPort(port uint16, sourceObject **externglib.Object) error {
var _arg0 *C.GSocketListener // out
var _arg1 C.guint16 // out
var _arg2 *C.GObject // out
var _cerr *C.GError // in

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
_arg1 = (C.guint16)(port)
_arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

C.g_socket_listener_add_inet_port(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// AddSocket adds @socket to the set of sockets that we try to accept new
// clients from. The socket must be bound to a local address and listened to.
// 
// @source_object will be passed out in the various calls to accept to identify
// this particular source, which is useful if you're listening on multiple
// addresses and do different things depending on what address is connected to.
// 
// The @socket will not be automatically closed when the @listener is finalized
// unless the listener held the final reference to the socket. Before GLib 2.42,
// the @socket was automatically closed on finalization of the @listener, even
// if references to it were held elsewhere.
	func (l SocketListener) AddSocket(socket SocketClass, sourceObject **externglib.Object) error {
var _arg0 *C.GSocketListener // out
var _arg1 *C.GSocket // out
var _arg2 *C.GObject // out
var _cerr *C.GError // in

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GSocket)(unsafe.Pointer(socket.Native()))
_arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

C.g_socket_listener_add_socket(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Close closes all the sockets in the listener.
	func (l SocketListener) Close()  {
var _arg0 *C.GSocketListener // out

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))

C.g_socket_listener_close(_arg0)
}
	
	// SetBacklog sets the listen backlog on the sockets in the listener. This must
// be called before adding any sockets, addresses or ports to the Listener (for
// example, by calling g_socket_listener_add_inet_port()) to be effective.
// 
// See g_socket_set_listen_backlog() for details
	func (l SocketListener) SetBacklog(listenBacklog int)  {
var _arg0 *C.GSocketListener // out
var _arg1 C.int // out

_arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
_arg1 = (C.int)(listenBacklog)

C.g_socket_listener_set_backlog(_arg0, _arg1)
}
	


	// SocketService: a Service is an object that represents a service that is
// provided to the network or over local sockets. When a new connection is made
// to the service the Service::incoming signal is emitted.
// 
// A Service is a subclass of Listener and you need to add the addresses you
// want to accept connections on with the Listener APIs.
// 
// There are two options for implementing a network service based on Service.
// The first is to create the service using g_socket_service_new() and to
// connect to the Service::incoming signal. The second is to subclass Service
// and override the default signal handler implementation.
// 
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested in
// writing connection handlers that contain blocking code then see
// SocketService.
// 
// The socket service runs on the main loop of the [thread-default
// context][g-main-context-push-thread-default-context] of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
	type SocketService struct {
		SocketListener
		
	}

	// SocketServiceClass is an interface that the SocketService class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SocketServiceClass interface {
		gextras.Objector
		_socketService()
	}

	func (SocketService) _socketService() {}

	
	func marshalSocketService(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSocketService(obj), nil
	}
	

	
	// NewSocketService creates a new Service with no sockets to listen for. New
// listeners can be added with e.g. g_socket_listener_add_address() or
// g_socket_listener_add_inet_port().
// 
// New services are created active, there is no need to call
// g_socket_service_start(), unless g_socket_service_stop() has been called
// before.
	func NewSocketService() SocketService {
var _cret *C.GSocketService // in

_cret = C.g_socket_service_new()


var _socketService SocketService // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_socketService = SocketService{
SocketListener: SocketListener{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _socketService
}
	

	
	// IsActive: check whether the service is active or not. An active service will
// accept new clients that connect, while a non-active service will let
// connecting clients queue up until the service is started.
	func (s SocketService) IsActive() bool {
var _arg0 *C.GSocketService // out
var _cret C.gboolean // in

_arg0 = (*C.GSocketService)(unsafe.Pointer(s.Native()))

_cret = C.g_socket_service_is_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Start restarts the service, i.e. start accepting connections from the added
// sockets when the mainloop runs. This only needs to be called after the
// service has been stopped from g_socket_service_stop().
// 
// This call is thread-safe, so it may be called from a thread handling an
// incoming client request.
	func (s SocketService) Start()  {
var _arg0 *C.GSocketService // out

_arg0 = (*C.GSocketService)(unsafe.Pointer(s.Native()))

C.g_socket_service_start(_arg0)
}
	
	// Stop stops the service, i.e. stops accepting connections from the added
// sockets when the mainloop runs.
// 
// This call is thread-safe, so it may be called from a thread handling an
// incoming client request.
// 
// Note that this only stops accepting new connections; it does not close the
// listening sockets, and you can call g_socket_service_start() again later to
// begin listening again. To close the listening sockets, call
// g_socket_listener_close(). (This will happen automatically when the Service
// is finalized.)
// 
// This must be called before calling g_socket_listener_close() as the socket
// service will start accepting connections immediately when a new socket is
// added.
	func (s SocketService) Stop()  {
var _arg0 *C.GSocketService // out

_arg0 = (*C.GSocketService)(unsafe.Pointer(s.Native()))

C.g_socket_service_stop(_arg0)
}
	


	// Subprocess allows the creation of and interaction with child processes.
// 
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
// 
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
// 
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
// 
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
// 
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
// 
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
// 
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
// 
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
// 
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
	type Subprocess struct {
		**externglib.Object
		Initable
		
	}

	// SubprocessClass is an interface that the Subprocess class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SubprocessClass interface {
		gextras.Objector
		_subprocess()
	}

	func (Subprocess) _subprocess() {}

	
	func marshalSubprocess(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSubprocess(obj), nil
	}
	

	
	// NewSubprocessV: create a new process with the given flags and argument list.
// 
// The argument list is expected to be nil-terminated.
	func NewSubprocessV(argv []string, flags SubprocessFlags) (Subprocess, error) {
var _arg1 **C.gchar
var _arg2 C.GSubprocessFlags // out
var _cret *C.GSubprocess // in
var _cerr *C.GError // in

_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(argv))
for i := range argv {
out[i] = (*C.gchar)(C.CString(argv[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}
_arg2 = (C.GSubprocessFlags)(flags)

_cret = C.g_subprocess_newv(_arg1, _arg2, &_cerr)


var _subprocess Subprocess // out
var _goerr error // out

_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Subprocess)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _subprocess, _goerr
}
	

	
	// CommunicateUTF8: like g_subprocess_communicate(), but validates the output of
// the process as UTF-8, and returns it as a regular NUL terminated string.
// 
// On error, @stdout_buf and @stderr_buf will be set to undefined values and
// should not be used.
	func (s Subprocess) CommunicateUTF8(stdinBuf string, cancellable CancellableClass) (stdoutBuf string, stderrBuf string, goerr error) {
var _arg0 *C.GSubprocess // out
var _arg1 *C.char // out
var _arg2 *C.GCancellable // out
var _arg3 *C.char // in
var _arg4 *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(stdinBuf))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_subprocess_communicate_utf8(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)

var _stdoutBuf string // out
var _stderrBuf string // out
var _goerr error // out

_stdoutBuf = C.GoString(_arg3)
defer C.free(unsafe.Pointer(_arg3))
_stderrBuf = C.GoString(_arg4)
defer C.free(unsafe.Pointer(_arg4))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _stdoutBuf, _stderrBuf, _goerr
}
	
	// CommunicateUTF8Finish: complete an invocation of
// g_subprocess_communicate_utf8_async().
	func (s Subprocess) CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, goerr error) {
var _arg0 *C.GSubprocess // out
var _arg1 *C.GAsyncResult // out
var _arg2 *C.char // in
var _arg3 *C.char // in
var _cerr *C.GError // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_subprocess_communicate_utf8_finish(_arg0, _arg1, &_arg2, &_arg3, &_cerr)

var _stdoutBuf string // out
var _stderrBuf string // out
var _goerr error // out

_stdoutBuf = C.GoString(_arg2)
defer C.free(unsafe.Pointer(_arg2))
_stderrBuf = C.GoString(_arg3)
defer C.free(unsafe.Pointer(_arg3))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _stdoutBuf, _stderrBuf, _goerr
}
	
	// ForceExit: use an operating-system specific method to attempt an immediate,
// forceful termination of the process. There is no mechanism to determine
// whether or not the request itself was successful; however, you can use
// g_subprocess_wait() to monitor the status of the process after calling this
// function.
// 
// On Unix, this function sends SIGKILL.
	func (s Subprocess) ForceExit()  {
var _arg0 *C.GSubprocess // out

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

C.g_subprocess_force_exit(_arg0)
}
	
	// ExitStatus: check the exit status of the subprocess, given that it exited
// normally. This is the value passed to the exit() system call or the return
// value from main.
// 
// This is equivalent to the system WEXITSTATUS macro.
// 
// It is an error to call this function before g_subprocess_wait() and unless
// g_subprocess_get_if_exited() returned true.
	func (s Subprocess) ExitStatus() int {
var _arg0 *C.GSubprocess // out
var _cret C.gint // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_exit_status(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Identifier: on UNIX, returns the process ID as a decimal string. On Windows,
// returns the result of GetProcessId() also as a string. If the subprocess has
// terminated, this will return nil.
	func (s Subprocess) Identifier() string {
var _arg0 *C.GSubprocess // out
var _cret *C.gchar // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_identifier(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IfExited: check if the given subprocess exited normally (ie: by way of exit()
// or return from main()).
// 
// This is equivalent to the system WIFEXITED macro.
// 
// It is an error to call this function before g_subprocess_wait() has returned.
	func (s Subprocess) IfExited() bool {
var _arg0 *C.GSubprocess // out
var _cret C.gboolean // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_if_exited(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IfSignaled: check if the given subprocess terminated in response to a signal.
// 
// This is equivalent to the system WIFSIGNALED macro.
// 
// It is an error to call this function before g_subprocess_wait() has returned.
	func (s Subprocess) IfSignaled() bool {
var _arg0 *C.GSubprocess // out
var _cret C.gboolean // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_if_signaled(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Status gets the raw status code of the process, as from waitpid().
// 
// This value has no particular meaning, but it can be used with the macros
// defined by the system headers such as WIFEXITED. It can also be used with
// g_spawn_check_exit_status().
// 
// It is more likely that you want to use g_subprocess_get_if_exited() followed
// by g_subprocess_get_exit_status().
// 
// It is an error to call this function before g_subprocess_wait() has returned.
	func (s Subprocess) Status() int {
var _arg0 *C.GSubprocess // out
var _cret C.gint // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_status(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// StderrPipe gets the Stream from which to read the stderr output of
// @subprocess.
// 
// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE,
// otherwise nil will be returned.
	func (s Subprocess) StderrPipe() InputStream {
var _arg0 *C.GSubprocess // out
var _cret *C.GInputStream // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_stderr_pipe(_arg0)


var _inputStream InputStream // out

_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

return _inputStream
}
	
	// StdinPipe gets the Stream that you can write to in order to give data to the
// stdin of @subprocess.
// 
// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE and not
// G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise nil will be returned.
	func (s Subprocess) StdinPipe() OutputStream {
var _arg0 *C.GSubprocess // out
var _cret *C.GOutputStream // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_stdin_pipe(_arg0)


var _outputStream OutputStream // out

_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(OutputStream)

return _outputStream
}
	
	// StdoutPipe gets the Stream from which to read the stdout output of
// @subprocess.
// 
// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// otherwise nil will be returned.
	func (s Subprocess) StdoutPipe() InputStream {
var _arg0 *C.GSubprocess // out
var _cret *C.GInputStream // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_stdout_pipe(_arg0)


var _inputStream InputStream // out

_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

return _inputStream
}
	
	// Successful checks if the process was "successful". A process is considered
// successful if it exited cleanly with an exit status of 0, either by way of
// the exit() system call or return from main().
// 
// It is an error to call this function before g_subprocess_wait() has returned.
	func (s Subprocess) Successful() bool {
var _arg0 *C.GSubprocess // out
var _cret C.gboolean // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_successful(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TermSig: get the signal number that caused the subprocess to terminate, given
// that it terminated due to a signal.
// 
// This is equivalent to the system WTERMSIG macro.
// 
// It is an error to call this function before g_subprocess_wait() and unless
// g_subprocess_get_if_signaled() returned true.
	func (s Subprocess) TermSig() int {
var _arg0 *C.GSubprocess // out
var _cret C.gint // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

_cret = C.g_subprocess_get_term_sig(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
// still running.
// 
// This API is race-free. If the subprocess has terminated, it will not be
// signalled.
// 
// This API is not available on Windows.
	func (s Subprocess) SendSignal(signalNum int)  {
var _arg0 *C.GSubprocess // out
var _arg1 C.gint // out

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(signalNum)

C.g_subprocess_send_signal(_arg0, _arg1)
}
	
	// Wait: synchronously wait for the subprocess to terminate.
// 
// After the process terminates you can query its exit status with functions
// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
// 
// This function does not fail in the case of the subprocess having abnormal
// termination. See g_subprocess_wait_check() for that.
// 
// Cancelling @cancellable doesn't kill the subprocess. Call
// g_subprocess_force_exit() if it is desirable.
	func (s Subprocess) Wait(cancellable CancellableClass) error {
var _arg0 *C.GSubprocess // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_subprocess_wait(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
	func (s Subprocess) WaitCheck(cancellable CancellableClass) error {
var _arg0 *C.GSubprocess // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_subprocess_wait_check(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// WaitCheckFinish collects the result of a previous call to
// g_subprocess_wait_check_async().
	func (s Subprocess) WaitCheckFinish(result AsyncResult) error {
var _arg0 *C.GSubprocess // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_subprocess_wait_check_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// WaitFinish collects the result of a previous call to
// g_subprocess_wait_async().
	func (s Subprocess) WaitFinish(result AsyncResult) error {
var _arg0 *C.GSubprocess // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_subprocess_wait_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
// 
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
	type SubprocessLauncher struct {
		**externglib.Object
		
	}

	// SubprocessLauncherClass is an interface that the SubprocessLauncher class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SubprocessLauncherClass interface {
		gextras.Objector
		_subprocessLauncher()
	}

	func (SubprocessLauncher) _subprocessLauncher() {}

	
	func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSubprocessLauncher(obj), nil
	}
	

	
	// NewSubprocessLauncher creates a new Launcher.
// 
// The launcher is created with the default options. A copy of the environment
// of the calling process is made at the time of this call and will be used as
// the environment that the process is launched in.
	func NewSubprocessLauncher(flags SubprocessFlags) SubprocessLauncher {
var _arg1 C.GSubprocessFlags // out
var _cret *C.GSubprocessLauncher // in

_arg1 = (C.GSubprocessFlags)(flags)

_cret = C.g_subprocess_launcher_new(_arg1)


var _subprocessLauncher SubprocessLauncher // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_subprocessLauncher = SubprocessLauncher{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _subprocessLauncher
}
	

	
	// Close closes all the file descriptors previously passed to the object with
// g_subprocess_launcher_take_fd(), g_subprocess_launcher_take_stderr_fd(), etc.
// 
// After calling this method, any subsequent calls to
// g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will return
// G_IO_ERROR_CLOSED. This method is idempotent if called more than once.
// 
// This function is called automatically when the Launcher is disposed, but is
// provided separately so that garbage collected language bindings can call it
// earlier to guarantee when FDs are closed.
	func (s SubprocessLauncher) Close()  {
var _arg0 *C.GSubprocessLauncher // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))

C.g_subprocess_launcher_close(_arg0)
}
	
	// env returns the value of the environment variable @variable in the
// environment of processes launched from this launcher.
// 
// On UNIX, the returned string can be an arbitrary byte string. On Windows, it
// will be UTF-8.
	func (s SubprocessLauncher) env(variable string) string {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(variable))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_subprocess_launcher_getenv(_arg0, _arg1)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// SetCwd sets the current working directory that processes will be launched
// with.
// 
// By default processes are launched with the current working directory of the
// launching process at the time of launch.
	func (s SubprocessLauncher) SetCwd(cwd string)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 *C.gchar // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(cwd))
defer C.free(unsafe.Pointer(_arg1))

C.g_subprocess_launcher_set_cwd(_arg0, _arg1)
}
	
	// SetEnviron: replace the entire environment of processes launched from this
// launcher with the given 'environ' variable.
// 
// Typically you will build this variable by using g_listenv() to copy the
// process 'environ' and using the functions g_environ_setenv(),
// g_environ_unsetenv(), etc.
// 
// As an alternative, you can use g_subprocess_launcher_setenv(),
// g_subprocess_launcher_unsetenv(), etc.
// 
// Pass an empty array to set an empty environment. Pass nil to inherit the
// parent process environment. As of GLib 2.54, the parent process environment
// will be copied when g_subprocess_launcher_set_environ() is called.
// Previously, it was copied when the subprocess was executed. This means the
// copied environment may now be modified (using g_subprocess_launcher_setenv(),
// etc.) before launching the subprocess.
// 
// On UNIX, all strings in this array can be arbitrary byte strings. On Windows,
// they should be in UTF-8.
	func (s SubprocessLauncher) SetEnviron(env []string)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 **C.gchar

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(env)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(env))
for i := range env {
out[i] = (*C.gchar)(C.CString(env[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.g_subprocess_launcher_set_environ(_arg0, _arg1)
}
	
	// SetFlags sets the flags on the launcher.
// 
// The default flags are G_SUBPROCESS_FLAGS_NONE.
// 
// You may not set flags that specify conflicting options for how to handle a
// particular stdio stream (eg: specifying both G_SUBPROCESS_FLAGS_STDIN_PIPE
// and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
// 
// You may also not set a flag that conflicts with a previous call to a function
// like g_subprocess_launcher_set_stdin_file_path() or
// g_subprocess_launcher_take_stdout_fd().
	func (s SubprocessLauncher) SetFlags(flags SubprocessFlags)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 C.GSubprocessFlags // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (C.GSubprocessFlags)(flags)

C.g_subprocess_launcher_set_flags(_arg0, _arg1)
}
	
	// SetStderrFilePath sets the file path to use as the stderr for spawned
// processes.
// 
// If @path is nil then any previously given path is unset.
// 
// The file will be created or truncated when the process is spawned, as would
// be the case if using '2>' at the shell.
// 
// If you want to send both stdout and stderr to the same file then use
// G_SUBPROCESS_FLAGS_STDERR_MERGE.
// 
// You may not set a stderr file path if a stderr fd is already set or if the
// launcher flags contain any flags directing stderr elsewhere.
// 
// This feature is only available on UNIX.
	func (s SubprocessLauncher) SetStderrFilePath(path string)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 *C.gchar // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.g_subprocess_launcher_set_stderr_file_path(_arg0, _arg1)
}
	
	// SetStdinFilePath sets the file path to use as the stdin for spawned
// processes.
// 
// If @path is nil then any previously given path is unset.
// 
// The file must exist or spawning the process will fail.
// 
// You may not set a stdin file path if a stdin fd is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
// 
// This feature is only available on UNIX.
	func (s SubprocessLauncher) SetStdinFilePath(path string)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 *C.gchar // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.g_subprocess_launcher_set_stdin_file_path(_arg0, _arg1)
}
	
	// SetStdoutFilePath sets the file path to use as the stdout for spawned
// processes.
// 
// If @path is nil then any previously given path is unset.
// 
// The file will be created or truncated when the process is spawned, as would
// be the case if using '>' at the shell.
// 
// You may not set a stdout file path if a stdout fd is already set or if the
// launcher flags contain any flags directing stdout elsewhere.
// 
// This feature is only available on UNIX.
	func (s SubprocessLauncher) SetStdoutFilePath(path string)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 *C.gchar // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.g_subprocess_launcher_set_stdout_file_path(_arg0, _arg1)
}
	
	// Setenv sets the environment variable @variable in the environment of
// processes launched from this launcher.
// 
// On UNIX, both the variable's name and value can be arbitrary byte strings,
// except that the variable's name cannot contain '='. On Windows, they should
// be in UTF-8.
	func (s SubprocessLauncher) Setenv(variable string, value string, overwrite bool)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 C.gboolean // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(variable))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg2))
if overwrite { _arg3 = C.TRUE }

C.g_subprocess_launcher_setenv(_arg0, _arg1, _arg2, _arg3)
}
	
	// Spawnv creates a #GSubprocess given a provided array of arguments.
	func (s SubprocessLauncher) Spawnv(argv []string) (Subprocess, error) {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 **C.gchar
var _cret *C.GSubprocess // in
var _cerr *C.GError // in

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(argv))
for i := range argv {
out[i] = (*C.gchar)(C.CString(argv[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.g_subprocess_launcher_spawnv(_arg0, _arg1, &_cerr)


var _subprocess Subprocess // out
var _goerr error // out

_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Subprocess)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _subprocess, _goerr
}
	
	// TakeFd: transfer an arbitrary file descriptor from parent process to the
// child. This function takes ownership of the @source_fd; it will be closed in
// the parent when @self is freed.
// 
// By default, all file descriptors from the parent will be closed. This
// function allows you to create (for example) a custom `pipe()` or
// `socketpair()` before launching the process, and choose the target descriptor
// in the child.
// 
// An example use case is GNUPG, which has a command line argument
// `--passphrase-fd` providing a file descriptor number where it expects the
// passphrase to be written.
	func (s SubprocessLauncher) TakeFd(sourceFd int, targetFd int)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(sourceFd)
_arg2 = (C.gint)(targetFd)

C.g_subprocess_launcher_take_fd(_arg0, _arg1, _arg2)
}
	
	// TakeStderrFd sets the file descriptor to use as the stderr for spawned
// processes.
// 
// If @fd is -1 then any previously given fd is unset.
// 
// Note that the default behaviour is to pass stderr through to the stderr of
// the parent process.
// 
// The passed @fd belongs to the Launcher. It will be automatically closed when
// the launcher is finalized. The file descriptor will also be closed on the
// child side when executing the spawned process.
// 
// You may not set a stderr fd if a stderr file path is already set or if the
// launcher flags contain any flags directing stderr elsewhere.
// 
// This feature is only available on UNIX.
	func (s SubprocessLauncher) TakeStderrFd(fd int)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 C.gint // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(fd)

C.g_subprocess_launcher_take_stderr_fd(_arg0, _arg1)
}
	
	// TakeStdinFd sets the file descriptor to use as the stdin for spawned
// processes.
// 
// If @fd is -1 then any previously given fd is unset.
// 
// Note that if your intention is to have the stdin of the calling process
// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better way
// to go about doing that.
// 
// The passed @fd is noted but will not be touched in the current process. It is
// therefore necessary that it be kept open by the caller until the subprocess
// is spawned. The file descriptor will also not be explicitly closed on the
// child side, so it must be marked O_CLOEXEC if that's what you want.
// 
// You may not set a stdin fd if a stdin file path is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
// 
// This feature is only available on UNIX.
	func (s SubprocessLauncher) TakeStdinFd(fd int)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 C.gint // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(fd)

C.g_subprocess_launcher_take_stdin_fd(_arg0, _arg1)
}
	
	// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
// processes.
// 
// If @fd is -1 then any previously given fd is unset.
// 
// Note that the default behaviour is to pass stdout through to the stdout of
// the parent process.
// 
// The passed @fd is noted but will not be touched in the current process. It is
// therefore necessary that it be kept open by the caller until the subprocess
// is spawned. The file descriptor will also not be explicitly closed on the
// child side, so it must be marked O_CLOEXEC if that's what you want.
// 
// You may not set a stdout fd if a stdout file path is already set or if the
// launcher flags contain any flags directing stdout elsewhere.
// 
// This feature is only available on UNIX.
	func (s SubprocessLauncher) TakeStdoutFd(fd int)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 C.gint // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(fd)

C.g_subprocess_launcher_take_stdout_fd(_arg0, _arg1)
}
	
	// Unsetenv removes the environment variable @variable from the environment of
// processes launched from this launcher.
// 
// On UNIX, the variable's name can be an arbitrary byte string not containing
// '='. On Windows, it should be in UTF-8.
	func (s SubprocessLauncher) Unsetenv(variable string)  {
var _arg0 *C.GSubprocessLauncher // out
var _arg1 *C.gchar // out

_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(variable))
defer C.free(unsafe.Pointer(_arg1))

C.g_subprocess_launcher_unsetenv(_arg0, _arg1)
}
	


	// Task: a #GTask represents and manages a cancellable "task".
// 
// 
// Asynchronous operations
// 
// The most common usage of #GTask is as a Result, to manage data during an
// asynchronous operation. You call g_task_new() in the "start" method, followed
// by g_task_set_task_data() and the like if you need to keep some additional
// data associated with the task, and then pass the task object around through
// your asynchronous operation. Eventually, you will call a method such as
// g_task_return_pointer() or g_task_return_error(), which will save the value
// you give it and then invoke the task's callback function in the
// [thread-default main context][g-main-context-push-thread-default] where it
// was created (waiting until the next iteration of the main loop first, if
// necessary). The caller will pass the #GTask back to the operation's finish
// function (as a Result), and you can use g_task_propagate_pointer() or the
// like to extract the return value.
// 
// Here is an example for using GTask as a GAsyncResult:
// 
//        static void
//        bake_cake_thread (GTask         *task,
//                          gpointer       source_object,
//                          gpointer       task_data,
//                          GCancellable  *cancellable)
//        {
//          Baker *self = source_object;
//          CakeData *cake_data = task_data;
//          Cake *cake;
//          GError *error = NULL;
// 
//          cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//                            cake_data->frosting, cake_data->message,
//                            &error);
//          if (error)
//            {
//              g_task_return_error (task, error);
//              return;
//            }
// 
//          // If the task has already been cancelled, then we don't want to add
//          // the cake to the cake cache. Likewise, we don't  want to have the
//          // task get cancelled in the middle of updating the cache.
//          // g_task_set_return_on_cancel() will return true here if it managed
//          // to disable return-on-cancel, or false if the task was cancelled
//          // before it could.
//          if (g_task_set_return_on_cancel (task, FALSE))
//            {
//              // If the caller cancels at this point, their
//              // GAsyncReadyCallback won't be invoked until we return,
//              // so we don't have to worry that this code will run at
//              // the same time as that code does. But if there were
//              // other functions that might look at the cake cache,
//              // then we'd probably need a GMutex here as well.
//              baker_add_cake_to_cache (baker, cake);
//              g_task_return_pointer (task, cake, g_object_unref);
//            }
//        }
// 
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          CakeData *cake_data;
//          GTask *task;
// 
//          cake_data = g_slice_new (CakeData);
// 
//          ...
// 
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread (task, bake_cake_thread);
//        }
// 
//        Cake *
//        baker_bake_cake_sync (Baker               *self,
//                              guint                radius,
//                              CakeFlavor           flavor,
//                              CakeFrostingType     frosting,
//                              const char          *message,
//                              GCancellable        *cancellable,
//                              GError             **error)
//        {
//          CakeData *cake_data;
//          GTask *task;
//          Cake *cake;
// 
//          cake_data = g_slice_new (CakeData);
// 
//          ...
// 
//          task = g_task_new (self, cancellable, NULL, NULL);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread_sync (task, bake_cake_thread);
// 
//          cake = g_task_propagate_pointer (task, error);
//          g_object_unref (task);
//          return cake;
//        }
// 
// 
// Porting from GSimpleAsyncResult
// 
// #GTask's API attempts to be simpler than AsyncResult's in several ways: - You
// can save task-specific data with g_task_set_task_data(), and retrieve it
// later with g_task_get_task_data(). This replaces the abuse of
// g_simple_async_result_set_op_res_gpointer() for the same purpose with
// AsyncResult. - In addition to the task data, #GTask also keeps track of the
// [priority][io-priority], #GCancellable, and Context associated with the task,
// so tasks that consist of a chain of simpler asynchronous operations will have
// easy access to those values when starting each sub-task. -
// g_task_return_error_if_cancelled() provides simplified handling for
// cancellation. In addition, cancellation overrides any other #GTask return
// value by default, like AsyncResult does when
// g_simple_async_result_set_check_cancellable() is called. (You can use
// g_task_set_check_cancellable() to turn off that behavior.) On the other hand,
// g_task_run_in_thread() guarantees that it will always run your `task_func`,
// even if the task's #GCancellable is already cancelled before the task gets a
// chance to run; you can start your `task_func` with a
// g_task_return_error_if_cancelled() check if you need the old behavior. - The
// "return" methods (eg, g_task_return_pointer()) automatically cause the task
// to be "completed" as well, and there is no need to worry about the "complete"
// vs "complete in idle" distinction. (#GTask automatically figures out whether
// the task's callback can be invoked directly, or if it needs to be sent to
// another Context, or delayed until the next iteration of the current Context.)
// - The "finish" functions for #GTask based operations are generally much
// simpler than AsyncResult ones, normally consisting of only a single call to
// g_task_propagate_pointer() or the like. Since g_task_propagate_pointer()
// "steals" the return value from the #GTask, it is not necessary to juggle
// pointers around to prevent it from being freed twice. - With AsyncResult, it
// was common to call g_simple_async_result_propagate_error() from the
// `_finish()` wrapper function, and have virtual method implementations only
// deal with successful returns. This behavior is deprecated, because it makes
// it difficult for a subclass to chain to a parent class's async methods.
// Instead, the wrapper function should just be a simple wrapper, and the
// virtual method should call an appropriate `g_task_propagate_` function. Note
// that wrapper methods can now use g_async_result_legacy_propagate_error() to
// do old-style AsyncResult error-returning behavior, and
// g_async_result_is_tagged() to check if a result is tagged as having come from
// the `_async()` wrapper function (for "short-circuit" results, such as when
// passing 0 to g_input_stream_read_async()).
	type Task struct {
		**externglib.Object
		AsyncResult
		
	}

	// TaskClass is an interface that the Task class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TaskClass interface {
		gextras.Objector
		_task()
	}

	func (Task) _task() {}

	
	func marshalTask(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTask(obj), nil
	}
	

	

	
	// Cancellable gets @task's #GCancellable
	func (t Task) Cancellable() Cancellable {
var _arg0 *C.GTask // out
var _cret *C.GCancellable // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_get_cancellable(_arg0)


var _cancellable Cancellable // out

_cancellable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Cancellable)

return _cancellable
}
	
	// CheckCancellable gets @task's check-cancellable flag. See
// g_task_set_check_cancellable() for more details.
	func (t Task) CheckCancellable() bool {
var _arg0 *C.GTask // out
var _cret C.gboolean // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_get_check_cancellable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Completed gets the value of #GTask:completed. This changes from false to true
// after the tasks callback is invoked, and will return false if called from
// inside the callback.
	func (t Task) Completed() bool {
var _arg0 *C.GTask // out
var _cret C.gboolean // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_get_completed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Context gets the Context that @task will return its result in (that is, the
// context that was the [thread-default main
// context][g-main-context-push-thread-default] at the point when @task was
// created).
// 
// This will always return a non-nil value, even if the task's context is the
// default Context.
	func (t Task) Context() *glib.MainContext {
var _arg0 *C.GTask // out
var _cret *C.GMainContext // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_get_context(_arg0)


var _mainContext *glib.MainContext // out

_mainContext = *(**glib.MainContext)(unsafe.Pointer(&_cret))

return _mainContext
}
	
	// Name gets @tasks name. See g_task_set_name().
	func (t Task) Name() string {
var _arg0 *C.GTask // out
var _cret *C.gchar // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Priority gets @task's priority
	func (t Task) Priority() int {
var _arg0 *C.GTask // out
var _cret C.gint // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_get_priority(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ReturnOnCancel gets @task's return-on-cancel flag. See
// g_task_set_return_on_cancel() for more details.
	func (t Task) ReturnOnCancel() bool {
var _arg0 *C.GTask // out
var _cret C.gboolean // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_get_return_on_cancel(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SourceObject gets the source object from @task. Like
// g_async_result_get_source_object(), but does not ref the object.
	func (t Task) SourceObject() **externglib.Object {
var _arg0 *C.GTask // out
var _cret C.gpointer // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_get_source_object(_arg0)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// HadError tests if @task resulted in an error.
	func (t Task) HadError() bool {
var _arg0 *C.GTask // out
var _cret C.gboolean // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_had_error(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PropagateBoolean gets the result of @task as a #gboolean.
// 
// If the task resulted in an error, or was cancelled, then this will instead
// return false and set @error.
// 
// Since this method transfers ownership of the return value (or error) to the
// caller, you may only call it once.
	func (t Task) PropagateBoolean() error {
var _arg0 *C.GTask // out
var _cerr *C.GError // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

C.g_task_propagate_boolean(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PropagateInt gets the result of @task as an integer (#gssize).
// 
// If the task resulted in an error, or was cancelled, then this will instead
// return -1 and set @error.
// 
// Since this method transfers ownership of the return value (or error) to the
// caller, you may only call it once.
	func (t Task) PropagateInt() (int, error) {
var _arg0 *C.GTask // out
var _cret C.gssize // in
var _cerr *C.GError // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_propagate_int(_arg0, &_cerr)


var _gssize int // out
var _goerr error // out

_gssize = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gssize, _goerr
}
	
	// PropagateValue gets the result of @task as a #GValue, and transfers ownership
// of that value to the caller. As with g_task_return_value(), this is a generic
// low-level method; g_task_propagate_pointer() and the like will usually be
// more useful for C code.
// 
// If the task resulted in an error, or was cancelled, then this will instead
// set @error and return false.
// 
// Since this method transfers ownership of the return value (or error) to the
// caller, you may only call it once.
	func (t Task) PropagateValue() (*externglib.Value, error) {
var _arg0 *C.GTask // out
var _arg1 C.GValue // in
var _cerr *C.GError // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

C.g_task_propagate_value(_arg0, &_arg1, &_cerr)

var _value *externglib.Value // out
var _goerr error // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg1))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _value, _goerr
}
	
	// ReturnBoolean sets @task's result to @result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
	func (t Task) ReturnBoolean(result bool)  {
var _arg0 *C.GTask // out
var _arg1 C.gboolean // out

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
if result { _arg1 = C.TRUE }

C.g_task_return_boolean(_arg0, _arg1)
}
	
	// ReturnError sets @task's result to @error (which @task assumes ownership of)
// and completes the task (see g_task_return_pointer() for more discussion of
// exactly what this means).
// 
// Note that since the task takes ownership of @error, and since the task may be
// completed before returning from g_task_return_error(), you cannot assume that
// @error is still valid after calling this. Call g_error_copy() on the error if
// you need to keep a local copy as well.
// 
// See also g_task_return_new_error().
	func (t Task) ReturnError(err error)  {
var _arg0 *C.GTask // out
var _arg1 *C.GError // out

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))

C.g_task_return_error(_arg0, _arg1)
}
	
	// ReturnErrorIfCancelled checks if @task's #GCancellable has been cancelled,
// and if so, sets @task's error accordingly and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
	func (t Task) ReturnErrorIfCancelled() bool {
var _arg0 *C.GTask // out
var _cret C.gboolean // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

_cret = C.g_task_return_error_if_cancelled(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ReturnInt sets @task's result to @result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
	func (t Task) ReturnInt(result int)  {
var _arg0 *C.GTask // out
var _arg1 C.gssize // out

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
_arg1 = (C.gssize)(result)

C.g_task_return_int(_arg0, _arg1)
}
	
	// ReturnValue sets @task's result to @result (by copying it) and completes the
// task.
// 
// If @result is nil then a #GValue of type TYPE_POINTER with a value of nil
// will be used for the result.
// 
// This is a very generic low-level method intended primarily for use by
// language bindings; for C code, g_task_return_pointer() and the like will
// normally be much easier to use.
	func (t Task) ReturnValue(result **externglib.Value)  {
var _arg0 *C.GTask // out
var _arg1 *C.GValue // out

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GValue)(result.GValue)

C.g_task_return_value(_arg0, _arg1)
}
	
	// SetCheckCancellable sets or clears @task's check-cancellable flag. If this is
// true (the default), then g_task_propagate_pointer(), etc, and
// g_task_had_error() will check the task's #GCancellable first, and if it has
// been cancelled, then they will consider the task to have returned an
// "Operation was cancelled" error (G_IO_ERROR_CANCELLED), regardless of any
// other error or return value the task may have had.
// 
// If @check_cancellable is false, then the #GTask will not check the
// cancellable itself, and it is up to @task's owner to do this (eg, via
// g_task_return_error_if_cancelled()).
// 
// If you are using g_task_set_return_on_cancel() as well, then you must leave
// check-cancellable set true.
	func (t Task) SetCheckCancellable(checkCancellable bool)  {
var _arg0 *C.GTask // out
var _arg1 C.gboolean // out

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
if checkCancellable { _arg1 = C.TRUE }

C.g_task_set_check_cancellable(_arg0, _arg1)
}
	
	// SetName sets @tasks name, used in debugging and profiling. The name defaults
// to nil.
// 
// The task name should describe in a human readable way what the task does. For
// example, Open file or Connect to network host. It is used to set the name
// of the #GSource used for idle completion of the task.
// 
// This function may only be called before the @task is first used in a thread
// other than the one it was constructed in.
	func (t Task) SetName(name string)  {
var _arg0 *C.GTask // out
var _arg1 *C.gchar // out

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.g_task_set_name(_arg0, _arg1)
}
	
	// SetPriority sets @task's priority. If you do not call this, it will default
// to G_PRIORITY_DEFAULT.
// 
// This will affect the priority of #GSources created with
// g_task_attach_source() and the scheduling of tasks run in threads, and can
// also be explicitly retrieved later via g_task_get_priority().
	func (t Task) SetPriority(priority int)  {
var _arg0 *C.GTask // out
var _arg1 C.gint // out

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(priority)

C.g_task_set_priority(_arg0, _arg1)
}
	
	// SetReturnOnCancel sets or clears @task's return-on-cancel flag. This is only
// meaningful for tasks run via g_task_run_in_thread() or
// g_task_run_in_thread_sync().
// 
// If @return_on_cancel is true, then cancelling @task's #GCancellable will
// immediately cause it to return, as though the task's ThreadFunc had called
// g_task_return_error_if_cancelled() and then returned.
// 
// This allows you to create a cancellable wrapper around an uninterruptible
// function. The ThreadFunc just needs to be careful that it does not modify any
// externally-visible state after it has been cancelled. To do that, the thread
// should call g_task_set_return_on_cancel() again to (atomically) set
// return-on-cancel false before making externally-visible changes; if the task
// gets cancelled before the return-on-cancel flag could be changed,
// g_task_set_return_on_cancel() will indicate this by returning false.
// 
// You can disable and re-enable this flag multiple times if you wish. If the
// task's #GCancellable is cancelled while return-on-cancel is false, then
// calling g_task_set_return_on_cancel() to set it true again will cause the
// task to be cancelled at that point.
// 
// If the task's #GCancellable is already cancelled before you call
// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the ThreadFunc will
// still be run (for consistency), but the task will also be completed right
// away.
	func (t Task) SetReturnOnCancel(returnOnCancel bool) bool {
var _arg0 *C.GTask // out
var _arg1 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
if returnOnCancel { _arg1 = C.TRUE }

_cret = C.g_task_set_return_on_cancel(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// TCPConnection: this is the subclass of Connection that is created for TCP/IP
// sockets.
	type TCPConnection struct {
		SocketConnection
		
	}

	// TCPConnectionClass is an interface that the TCPConnection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TCPConnectionClass interface {
		gextras.Objector
		_tcpConnection()
	}

	func (TCPConnection) _tcpConnection() {}

	
	func marshalTCPConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTCPConnection(obj), nil
	}
	

	

	
	// GracefulDisconnect checks if graceful disconnects are used. See
// g_tcp_connection_set_graceful_disconnect().
	func (c TCPConnection) GracefulDisconnect() bool {
var _arg0 *C.GTcpConnection // out
var _cret C.gboolean // in

_arg0 = (*C.GTcpConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tcp_connection_get_graceful_disconnect(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetGracefulDisconnect: this enables graceful disconnects on close. A graceful
// disconnect means that we signal the receiving end that the connection is
// terminated and wait for it to close the connection before closing the
// connection.
// 
// A graceful disconnect means that we can be sure that we successfully sent all
// the outstanding data to the other end, or get an error reported. However, it
// also means we have to wait for all the data to reach the other side and for
// it to acknowledge this by closing the socket, which may take a while. For
// this reason it is disabled by default.
	func (c TCPConnection) SetGracefulDisconnect(gracefulDisconnect bool)  {
var _arg0 *C.GTcpConnection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GTcpConnection)(unsafe.Pointer(c.Native()))
if gracefulDisconnect { _arg1 = C.TRUE }

C.g_tcp_connection_set_graceful_disconnect(_arg0, _arg1)
}
	


	// TCPWrapperConnection: a WrapperConnection can be used to wrap a OStream that
// is based on a #GSocket, but which is not actually a Connection. This is used
// by Client so that it can always return a Connection, even when the connection
// it has actually created is not directly a Connection.
	type TCPWrapperConnection struct {
		TCPConnection
		
	}

	// TCPWrapperConnectionClass is an interface that the TCPWrapperConnection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TCPWrapperConnectionClass interface {
		gextras.Objector
		_tcpWrapperConnection()
	}

	func (TCPWrapperConnection) _tcpWrapperConnection() {}

	
	func marshalTCPWrapperConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTCPWrapperConnection(obj), nil
	}
	

	
	// NewTCPWrapperConnection wraps @base_io_stream and @socket together as a
// Connection.
	func NewTCPWrapperConnection(baseIoStream IOStreamClass, socket SocketClass) TCPWrapperConnection {
var _arg1 *C.GIOStream // out
var _arg2 *C.GSocket // out
var _cret *C.GSocketConnection // in

_arg1 = (*C.GIOStream)(unsafe.Pointer(baseIoStream.Native()))
_arg2 = (*C.GSocket)(unsafe.Pointer(socket.Native()))

_cret = C.g_tcp_wrapper_connection_new(_arg1, _arg2)


var _tcpWrapperConnection TCPWrapperConnection // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_tcpWrapperConnection = TCPWrapperConnection{
TCPConnection: TCPConnection{
SocketConnection: SocketConnection{
IOStream: IOStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _tcpWrapperConnection
}
	

	
	// BaseIOStream gets @conn's base OStream
	func (c TCPWrapperConnection) BaseIOStream() IOStream {
var _arg0 *C.GTcpWrapperConnection // out
var _cret *C.GIOStream // in

_arg0 = (*C.GTcpWrapperConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tcp_wrapper_connection_get_base_io_stream(_arg0)


var _ioStream IOStream // out

_ioStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IOStream)

return _ioStream
}
	


	// TestDBus: a helper class for testing code which uses D-Bus without touching
// the user's session bus.
// 
// Note that DBus modifies the users environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
// 
// 
// Creating unit tests using GTestDBus
// 
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
// 
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
// 
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
// 
//    [D-BUS Service]
//    Name=org.gtk.GDBus.Examples.ObjectManager
//    Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
// 
// You will also need to indicate this service directory in your test fixtures,
// so you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as:
// 
//       -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
// 
//    Once you have a service definition file which is local to your source tree,
// 
// you can proceed to set up a GTest fixture using the DBus scaffolding.
// 
// An example of a test fixture for D-Bus services can be found here:
// gdbus-test-fixture.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
// 
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
// 
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your
// schemas in the above fixture_setup() routine.
// 
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas:
// 
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
// 
//        CLEANFILES += gschemas.compiled
	type TestDBus struct {
		**externglib.Object
		
	}

	// TestDBusClass is an interface that the TestDBus class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TestDBusClass interface {
		gextras.Objector
		_testDBus()
	}

	func (TestDBus) _testDBus() {}

	
	func marshalTestDBus(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTestDBus(obj), nil
	}
	

	
	// NewTestDBus: create a new DBus object.
	func NewTestDBus(flags TestDBusFlags) TestDBus {
var _arg1 C.GTestDBusFlags // out
var _cret *C.GTestDBus // in

_arg1 = (C.GTestDBusFlags)(flags)

_cret = C.g_test_dbus_new(_arg1)


var _testDBus TestDBus // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_testDBus = TestDBus{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _testDBus
}
	

	
	// AddServiceDir: add a path where dbus-daemon will look up .service files. This
// can't be called after g_test_dbus_up().
	func (s TestDBus) AddServiceDir(path string)  {
var _arg0 *C.GTestDBus // out
var _arg1 *C.gchar // out

_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.g_test_dbus_add_service_dir(_arg0, _arg1)
}
	
	// Down: stop the session bus started by g_test_dbus_up().
// 
// This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
// to be destroyed. This is done to ensure that the next unit test won't get a
// leaked singleton from this test.
	func (s TestDBus) Down()  {
var _arg0 *C.GTestDBus // out

_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

C.g_test_dbus_down(_arg0)
}
	
	// BusAddress: get the address on which dbus-daemon is running. If
// g_test_dbus_up() has not been called yet, nil is returned. This can be used
// with g_dbus_connection_new_for_address().
	func (s TestDBus) BusAddress() string {
var _arg0 *C.GTestDBus // out
var _cret *C.gchar // in

_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

_cret = C.g_test_dbus_get_bus_address(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Flags: get the flags of the DBus object.
	func (s TestDBus) Flags() TestDBusFlags {
var _arg0 *C.GTestDBus // out
var _cret C.GTestDBusFlags // in

_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

_cret = C.g_test_dbus_get_flags(_arg0)


var _testDBusFlags TestDBusFlags // out

_testDBusFlags = TestDBusFlags(_cret)

return _testDBusFlags
}
	
	// Stop: stop the session bus started by g_test_dbus_up().
// 
// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests wanting
// to verify behaviour after the session bus has been stopped can use this
// function but should still call g_test_dbus_down() when done.
	func (s TestDBus) Stop()  {
var _arg0 *C.GTestDBus // out

_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

C.g_test_dbus_stop(_arg0)
}
	
	// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
// call, it is safe for unit tests to start sending messages on the session bus.
// 
// If this function is called from setup callback of g_test_add(),
// g_test_dbus_down() must be called in its teardown callback.
// 
// If this function is called from unit test's main(), then g_test_dbus_down()
// must be called after g_test_run().
	func (s TestDBus) Up()  {
var _arg0 *C.GTestDBus // out

_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

C.g_test_dbus_up(_arg0)
}
	


	// ThemedIcon is an implementation of #GIcon that supports icon themes. Icon
// contains a list of all of the icons present in an icon theme, so that icons
// can be looked up quickly. Icon does not provide actual pixmaps for icons,
// just the icon names. Ideally something like gtk_icon_theme_choose_icon()
// should be used to resolve the list of names so that fallback icons work
// nicely with themes that inherit other themes.
	type ThemedIcon struct {
		**externglib.Object
		Icon
		
	}

	// ThemedIconClass is an interface that the ThemedIcon class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ThemedIconClass interface {
		gextras.Objector
		_themedIcon()
	}

	func (ThemedIcon) _themedIcon() {}

	
	func marshalThemedIcon(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapThemedIcon(obj), nil
	}
	

	
	// NewThemedIcon creates a new themed icon for @iconname.
	func NewThemedIcon(iconname string) ThemedIcon {
var _arg1 *C.char // out
var _cret *C.GIcon // in

_arg1 = (*C.char)(C.CString(iconname))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_themed_icon_new(_arg1)


var _themedIcon ThemedIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_themedIcon = ThemedIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
Icon: Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _themedIcon
}
	
	// NewThemedIconFromNames creates a new themed icon for @iconnames.
	func NewThemedIconFromNames(iconnames []string) ThemedIcon {
var _arg1 **C.char
var _arg2 C.int
var _cret *C.GIcon // in

_arg2 = C.int(len(iconnames))
_arg1 = (**C.char)(C.malloc(C.ulong(len(iconnames)) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(iconnames))
for i := range iconnames {
out[i] = (*C.char)(C.CString(iconnames[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.g_themed_icon_new_from_names(_arg1, _arg2)


var _themedIcon ThemedIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_themedIcon = ThemedIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
Icon: Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _themedIcon
}
	
	// NewThemedIconWithDefaultFallbacks creates a new themed icon for @iconname,
// and all the names that can be created by shortening @iconname at '-'
// characters.
// 
// In the following example, @icon1 and @icon2 are equivalent:
// 
//    const char *names[] = {
//      "gnome-dev-cdrom-audio",
//      "gnome-dev-cdrom",
//      "gnome-dev",
//      "gnome"
//    };
// 
//    icon1 = g_themed_icon_new_from_names (names, 4);
//    icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
	func NewThemedIconWithDefaultFallbacks(iconname string) ThemedIcon {
var _arg1 *C.char // out
var _cret *C.GIcon // in

_arg1 = (*C.char)(C.CString(iconname))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_themed_icon_new_with_default_fallbacks(_arg1)


var _themedIcon ThemedIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_themedIcon = ThemedIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
Icon: Icon{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _themedIcon
}
	

	
	// AppendName: append a name to the list of icons from within @icon.
// 
// Note that doing so invalidates the hash computed by prior calls to
// g_icon_hash().
	func (i ThemedIcon) AppendName(iconname string)  {
var _arg0 *C.GThemedIcon // out
var _arg1 *C.char // out

_arg0 = (*C.GThemedIcon)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(iconname))
defer C.free(unsafe.Pointer(_arg1))

C.g_themed_icon_append_name(_arg0, _arg1)
}
	
	// Names gets the names of icons from within @icon.
	func (i ThemedIcon) Names() []string {
var _arg0 *C.GThemedIcon // out
var _cret **C.gchar

_arg0 = (*C.GThemedIcon)(unsafe.Pointer(i.Native()))

_cret = C.g_themed_icon_get_names(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// PrependName: prepend a name to the list of icons from within @icon.
// 
// Note that doing so invalidates the hash computed by prior calls to
// g_icon_hash().
	func (i ThemedIcon) PrependName(iconname string)  {
var _arg0 *C.GThemedIcon // out
var _arg1 *C.char // out

_arg0 = (*C.GThemedIcon)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(iconname))
defer C.free(unsafe.Pointer(_arg1))

C.g_themed_icon_prepend_name(_arg0, _arg1)
}
	


	// ThreadedSocketService: a SocketService is a simple subclass of Service that
// handles incoming connections by creating a worker thread and dispatching the
// connection to it by emitting the SocketService::run signal in the new thread.
// 
// The signal handler may perform blocking IO and need not return until the
// connection is closed.
// 
// The service is implemented using a thread pool, so there is a limited amount
// of threads available to serve incoming requests. The service automatically
// stops the Service from accepting new connections when all threads are busy.
// 
// As with Service, you may connect to SocketService::run, or subclass and
// override the default handler.
	type ThreadedSocketService struct {
		SocketService
		
	}

	// ThreadedSocketServiceClass is an interface that the ThreadedSocketService class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ThreadedSocketServiceClass interface {
		gextras.Objector
		_threadedSocketService()
	}

	func (ThreadedSocketService) _threadedSocketService() {}

	
	func marshalThreadedSocketService(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapThreadedSocketService(obj), nil
	}
	

	
	// NewThreadedSocketService creates a new SocketService with no listeners.
// Listeners must be added with one of the Listener "add" methods.
	func NewThreadedSocketService(maxThreads int) ThreadedSocketService {
var _arg1 C.int // out
var _cret *C.GSocketService // in

_arg1 = (C.int)(maxThreads)

_cret = C.g_threaded_socket_service_new(_arg1)


var _threadedSocketService ThreadedSocketService // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_threadedSocketService = ThreadedSocketService{
SocketService: SocketService{
SocketListener: SocketListener{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _threadedSocketService
}
	

	


	// TLSCertificate: a certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate received by
// a client from a server), or the combination of a certificate and a private
// key (which is needed when acting as a ServerConnection).
	type TLSCertificate struct {
		**externglib.Object
		
	}

	// TLSCertificateClass is an interface that the TLSCertificate class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TLSCertificateClass interface {
		gextras.Objector
		_tlsCertificate()
	}

	func (TLSCertificate) _tlsCertificate() {}

	
	func marshalTLSCertificate(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTLSCertificate(obj), nil
	}
	

	
	// NewTLSCertificateFromFile creates a Certificate from the PEM-encoded data in
// @file. The returned certificate will be the first certificate found in @file.
// As of GLib 2.44, if @file contains more certificates it will try to load a
// certificate chain. All certificates will be verified in the order found
// (top-level certificate should be the last one in the file) and the
// Certificate:issuer property of each certificate will be set accordingly if
// the verification succeeds. If any certificate in the chain cannot be
// verified, the first certificate in the file will still be returned.
// 
// If @file cannot be read or parsed, the function will return nil and set
// @error. Otherwise, this behaves like g_tls_certificate_new_from_pem().
	func NewTLSCertificateFromFile(file string) (TLSCertificate, error) {
var _arg1 *C.gchar // out
var _cret *C.GTlsCertificate // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(file))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_tls_certificate_new_from_file(_arg1, &_cerr)


var _tlsCertificate TLSCertificate // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_tlsCertificate = TLSCertificate{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificate, _goerr
}
	
	// NewTLSCertificateFromFiles creates a Certificate from the PEM-encoded data in
// @cert_file and @key_file. The returned certificate will be the first
// certificate found in @cert_file. As of GLib 2.44, if @cert_file contains more
// certificates it will try to load a certificate chain. All certificates will
// be verified in the order found (top-level certificate should be the last one
// in the file) and the Certificate:issuer property of each certificate will be
// set accordingly if the verification succeeds. If any certificate in the chain
// cannot be verified, the first certificate in the file will still be returned.
// 
// If either file cannot be read or parsed, the function will return nil and set
// @error. Otherwise, this behaves like g_tls_certificate_new_from_pem().
	func NewTLSCertificateFromFiles(certFile string, keyFile string) (TLSCertificate, error) {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret *C.GTlsCertificate // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(certFile))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(keyFile))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_tls_certificate_new_from_files(_arg1, _arg2, &_cerr)


var _tlsCertificate TLSCertificate // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_tlsCertificate = TLSCertificate{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificate, _goerr
}
	
	// NewTLSCertificateFromPem creates a Certificate from the PEM-encoded data in
// @data. If @data includes both a certificate and a private key, then the
// returned certificate will include the private key data as well. (See the
// Certificate:private-key-pem property for information about supported
// formats.)
// 
// The returned certificate will be the first certificate found in @data. As of
// GLib 2.44, if @data contains more certificates it will try to load a
// certificate chain. All certificates will be verified in the order found
// (top-level certificate should be the last one in the file) and the
// Certificate:issuer property of each certificate will be set accordingly if
// the verification succeeds. If any certificate in the chain cannot be
// verified, the first certificate in the file will still be returned.
	func NewTLSCertificateFromPem(data string, length int) (TLSCertificate, error) {
var _arg1 *C.gchar // out
var _arg2 C.gssize // out
var _cret *C.GTlsCertificate // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(data))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gssize)(length)

_cret = C.g_tls_certificate_new_from_pem(_arg1, _arg2, &_cerr)


var _tlsCertificate TLSCertificate // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_tlsCertificate = TLSCertificate{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificate, _goerr
}
	
	// NewTLSCertificateFromPkcs11Uris creates a Certificate from a PKCS \#11 URI.
// 
// An example @pkcs11_uri would be
// `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01`
// 
// Where the tokens layout is:
// 
// ` Object 0: URL:
// pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=private20key;type=private
// Type: Private key (RSA-2048) ID: 01
// 
// Object 1: URL:
// pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=Certificate20for20Authentication;type=cert
// Type: X.509 Certificate (RSA-2048) ID: 01 `
// 
// In this case the certificate and private key would both be detected and used
// as expected. @pkcs_uri may also just reference an X.509 certificate object
// and then optionally @private_key_pkcs11_uri allows using a private key
// exposed under a different URI.
// 
// Note that the private key is not accessed until usage and may fail or require
// a PIN later.
	func NewTLSCertificateFromPkcs11Uris(pkcs11Uri string, privateKeyPkcs11Uri string) (TLSCertificate, error) {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret *C.GTlsCertificate // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(pkcs11Uri))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(privateKeyPkcs11Uri))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_tls_certificate_new_from_pkcs11_uris(_arg1, _arg2, &_cerr)


var _tlsCertificate TLSCertificate // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_tlsCertificate = TLSCertificate{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificate, _goerr
}
	

	
	// Issuer gets the Certificate representing @cert's issuer, if known
	func (c TLSCertificate) Issuer() TLSCertificate {
var _arg0 *C.GTlsCertificate // out
var _cret *C.GTlsCertificate // in

_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_certificate_get_issuer(_arg0)


var _tlsCertificate TLSCertificate // out

_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

return _tlsCertificate
}
	
	// IsSame: check if two Certificate objects represent the same certificate. The
// raw DER byte data of the two certificates are checked for equality. This has
// the effect that two certificates may compare equal even if their
// Certificate:issuer, Certificate:private-key, or Certificate:private-key-pem
// properties differ.
	func (c TLSCertificate) IsSame(certTwo TLSCertificateClass) bool {
var _arg0 *C.GTlsCertificate // out
var _arg1 *C.GTlsCertificate // out
var _cret C.gboolean // in

_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certTwo.Native()))

_cret = C.g_tls_certificate_is_same(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Verify: this verifies @cert and returns a set of CertificateFlags indicating
// any problems found with it. This can be used to verify a certificate outside
// the context of making a connection, or to check a certificate against a CA
// that is not part of the system CA database.
// 
// If @identity is not nil, @cert's name(s) will be compared against it, and
// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value if it does not
// match. If @identity is nil, that bit will never be set in the return value.
// 
// If @trusted_ca is not nil, then @cert (or one of the certificates in its
// chain) must be signed by it, or else G_TLS_CERTIFICATE_UNKNOWN_CA will be set
// in the return value. If @trusted_ca is nil, that bit will never be set in the
// return value.
// 
// (All other CertificateFlags values will always be set or unset as
// appropriate.)
	func (c TLSCertificate) Verify(identity SocketConnectable, trustedCa TLSCertificateClass) TLSCertificateFlags {
var _arg0 *C.GTlsCertificate // out
var _arg1 *C.GSocketConnectable // out
var _arg2 *C.GTlsCertificate // out
var _cret C.GTlsCertificateFlags // in

_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(identity.Native()))
_arg2 = (*C.GTlsCertificate)(unsafe.Pointer(trustedCa.Native()))

_cret = C.g_tls_certificate_verify(_arg0, _arg1, _arg2)


var _tlsCertificateFlags TLSCertificateFlags // out

_tlsCertificateFlags = TLSCertificateFlags(_cret)

return _tlsCertificateFlags
}
	


	// TLSConnection is the base TLS connection class type, which wraps a OStream
// and provides TLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side TLS,
// respectively.
// 
// For DTLS (Datagram TLS) support, see Connection.
	type TLSConnection struct {
		IOStream
		
	}

	// TLSConnectionClass is an interface that the TLSConnection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TLSConnectionClass interface {
		gextras.Objector
		_tlsConnection()
	}

	func (TLSConnection) _tlsConnection() {}

	
	func marshalTLSConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTLSConnection(obj), nil
	}
	

	

	
	// EmitAcceptCertificate: used by Connection implementations to emit the
// Connection::accept-certificate signal.
	func (c TLSConnection) EmitAcceptCertificate(peerCert TLSCertificateClass, errors TLSCertificateFlags) bool {
var _arg0 *C.GTlsConnection // out
var _arg1 *C.GTlsCertificate // out
var _arg2 C.GTlsCertificateFlags // out
var _cret C.gboolean // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(peerCert.Native()))
_arg2 = (C.GTlsCertificateFlags)(errors)

_cret = C.g_tls_connection_emit_accept_certificate(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Certificate gets @conn's certificate, as set by
// g_tls_connection_set_certificate().
	func (c TLSConnection) Certificate() TLSCertificate {
var _arg0 *C.GTlsConnection // out
var _cret *C.GTlsCertificate // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_connection_get_certificate(_arg0)


var _tlsCertificate TLSCertificate // out

_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

return _tlsCertificate
}
	
	// ChannelBindingData: query the TLS backend for TLS channel binding data of
// @type for @conn.
// 
// This call retrieves TLS channel binding data as specified in RFC 5056
// (https://tools.ietf.org/html/rfc5056), RFC 5929
// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding data is
// returned in @data. The @data is resized by the callee using Array buffer
// management and will be freed when the @data is destroyed by
// g_byte_array_unref(). If @data is nil, it will only check whether TLS backend
// is able to fetch the data (e.g. whether @type is supported by the TLS
// backend). It does not guarantee that the data will be available though. That
// could happen if TLS connection does not support @type or the binding data is
// not available yet due to additional negotiation or input required.
	func (c TLSConnection) ChannelBindingData(typ TLSChannelBindingType) ([]byte, error) {
var _arg0 *C.GTlsConnection // out
var _arg1 C.GTlsChannelBindingType // out
var _arg2 C.GByteArray
var _cerr *C.GError // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.GTlsChannelBindingType)(typ)

C.g_tls_connection_get_channel_binding_data(_arg0, _arg1, &_arg2, &_cerr)

var _data []byte
var _goerr error // out

{
var i int
var z C.guint8
for p := _arg2; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_arg2, i)
_data = make([]byte, i)
for i := range src {
_data[i] = (byte)(src[i])
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _data, _goerr
}
	
	// Database gets the certificate database that @conn uses to verify peer
// certificates. See g_tls_connection_set_database().
	func (c TLSConnection) Database() TLSDatabase {
var _arg0 *C.GTlsConnection // out
var _cret *C.GTlsDatabase // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_connection_get_database(_arg0)


var _tlsDatabase TLSDatabase // out

_tlsDatabase = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSDatabase)

return _tlsDatabase
}
	
	// Interaction: get the object that will be used to interact with the user. It
// will be used for things like prompting the user for passwords. If nil is
// returned, then no user interaction will occur for this connection.
	func (c TLSConnection) Interaction() TLSInteraction {
var _arg0 *C.GTlsConnection // out
var _cret *C.GTlsInteraction // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_connection_get_interaction(_arg0)


var _tlsInteraction TLSInteraction // out

_tlsInteraction = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSInteraction)

return _tlsInteraction
}
	
	// NegotiatedProtocol gets the name of the application-layer protocol negotiated
// during the handshake.
// 
// If the peer did not use the ALPN extension, or did not advertise a protocol
// that matched one of @conn's protocols, or the TLS backend does not support
// ALPN, then this will be nil. See g_tls_connection_set_advertised_protocols().
	func (c TLSConnection) NegotiatedProtocol() string {
var _arg0 *C.GTlsConnection // out
var _cret *C.gchar // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_connection_get_negotiated_protocol(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PeerCertificate gets @conn's peer's certificate after the handshake has
// completed or failed. (It is not set during the emission of
// Connection::accept-certificate.)
	func (c TLSConnection) PeerCertificate() TLSCertificate {
var _arg0 *C.GTlsConnection // out
var _cret *C.GTlsCertificate // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_connection_get_peer_certificate(_arg0)


var _tlsCertificate TLSCertificate // out

_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

return _tlsCertificate
}
	
	// PeerCertificateErrors gets the errors associated with validating @conn's
// peer's certificate, after the handshake has completed or failed. (It is not
// set during the emission of Connection::accept-certificate.)
	func (c TLSConnection) PeerCertificateErrors() TLSCertificateFlags {
var _arg0 *C.GTlsConnection // out
var _cret C.GTlsCertificateFlags // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_connection_get_peer_certificate_errors(_arg0)


var _tlsCertificateFlags TLSCertificateFlags // out

_tlsCertificateFlags = TLSCertificateFlags(_cret)

return _tlsCertificateFlags
}
	
	// RehandshakeMode gets @conn rehandshaking mode. See
// g_tls_connection_set_rehandshake_mode() for details.
	func (c TLSConnection) RehandshakeMode() TLSRehandshakeMode {
var _arg0 *C.GTlsConnection // out
var _cret C.GTlsRehandshakeMode // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_connection_get_rehandshake_mode(_arg0)


var _tlsRehandshakeMode TLSRehandshakeMode // out

_tlsRehandshakeMode = TLSRehandshakeMode(_cret)

return _tlsRehandshakeMode
}
	
	// RequireCloseNotify tests whether or not @conn expects a proper TLS close
// notification when the connection is closed. See
// g_tls_connection_set_require_close_notify() for details.
	func (c TLSConnection) RequireCloseNotify() bool {
var _arg0 *C.GTlsConnection // out
var _cret C.gboolean // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_connection_get_require_close_notify(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseSystemCertdb gets whether @conn uses the system certificate database to
// verify peer certificates. See g_tls_connection_set_use_system_certdb().
	func (c TLSConnection) UseSystemCertdb() bool {
var _arg0 *C.GTlsConnection // out
var _cret C.gboolean // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

_cret = C.g_tls_connection_get_use_system_certdb(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Handshake attempts a TLS handshake on @conn.
// 
// On the client side, it is never necessary to call this method; although the
// connection needs to perform a handshake after connecting (or after sending a
// "STARTTLS"-type command), Connection will handle this for you automatically
// when you try to send or receive data on the connection. You can call
// g_tls_connection_handshake() manually if you want to know whether the initial
// handshake succeeded or failed (as opposed to just immediately trying to use
// @conn to read or write, in which case, if it fails, it may not be possible to
// tell if it failed before or after completing the handshake), but beware that
// servers may reject client authentication after the handshake has completed,
// so a successful handshake does not indicate the connection will be usable.
// 
// Likewise, on the server side, although a handshake is necessary at the
// beginning of the communication, you do not need to call this function
// explicitly unless you want clearer error reporting.
// 
// Previously, calling g_tls_connection_handshake() after the initial handshake
// would trigger a rehandshake; however, this usage was deprecated in GLib 2.60
// because rehandshaking was removed from the TLS protocol in TLS 1.3. Since
// GLib 2.64, calling this function after the initial handshake will no longer
// do anything.
// 
// When using a Connection created by Client, the Client performs the initial
// handshake, so calling this function manually is not recommended.
// 
// Connection::accept_certificate may be emitted during the handshake.
	func (c TLSConnection) Handshake(cancellable CancellableClass) error {
var _arg0 *C.GTlsConnection // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_tls_connection_handshake(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// HandshakeFinish: finish an asynchronous TLS handshake operation. See
// g_tls_connection_handshake() for more information.
	func (c TLSConnection) HandshakeFinish(result AsyncResult) error {
var _arg0 *C.GTlsConnection // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_tls_connection_handshake_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAdvertisedProtocols sets the list of application-layer protocols to
// advertise that the caller is willing to speak on this connection. The
// Application-Layer Protocol Negotiation (ALPN) extension will be used to
// negotiate a compatible protocol with the peer; use
// g_tls_connection_get_negotiated_protocol() to find the negotiated protocol
// after the handshake. Specifying nil for the the value of @protocols will
// disable ALPN negotiation.
// 
// See IANA TLS ALPN Protocol IDs
// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
// for a list of registered protocol IDs.
	func (c TLSConnection) SetAdvertisedProtocols(protocols []string)  {
var _arg0 *C.GTlsConnection // out
var _arg1 **C.gchar

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(protocols)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(protocols))
for i := range protocols {
out[i] = (*C.gchar)(C.CString(protocols[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.g_tls_connection_set_advertised_protocols(_arg0, _arg1)
}
	
	// SetCertificate: this sets the certificate that @conn will present to its peer
// during the TLS handshake. For a ServerConnection, it is mandatory to set
// this, and that will normally be done at construct time.
// 
// For a ClientConnection, this is optional. If a handshake fails with
// G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server requires a
// certificate, and if you try connecting again, you should call this method
// first. You can call g_tls_client_connection_get_accepted_cas() on the failed
// connection to get a list of Certificate Authorities that the server will
// accept certificates from.
// 
// (It is also possible that a server will allow the connection with or without
// a certificate; in that case, if you don't provide a certificate, you can tell
// that the server requested one by the fact that
// g_tls_client_connection_get_accepted_cas() will return non-nil.)
	func (c TLSConnection) SetCertificate(certificate TLSCertificateClass)  {
var _arg0 *C.GTlsConnection // out
var _arg1 *C.GTlsCertificate // out

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))

C.g_tls_connection_set_certificate(_arg0, _arg1)
}
	
	// SetDatabase sets the certificate database that is used to verify peer
// certificates. This is set to the default database by default. See
// g_tls_backend_get_default_database(). If set to nil, then peer certificate
// validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
// Connection::accept-certificate will always be emitted on client-side
// connections, unless that bit is not set in
// ClientConnection:validation-flags).
	func (c TLSConnection) SetDatabase(database TLSDatabaseClass)  {
var _arg0 *C.GTlsConnection // out
var _arg1 *C.GTlsDatabase // out

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(database.Native()))

C.g_tls_connection_set_database(_arg0, _arg1)
}
	
	// SetInteraction: set the object that will be used to interact with the user.
// It will be used for things like prompting the user for passwords.
// 
// The @interaction argument will normally be a derived subclass of Interaction.
// nil can also be provided if no user interaction should occur for this
// connection.
	func (c TLSConnection) SetInteraction(interaction TLSInteractionClass)  {
var _arg0 *C.GTlsConnection // out
var _arg1 *C.GTlsInteraction // out

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))

C.g_tls_connection_set_interaction(_arg0, _arg1)
}
	
	// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
// longer supported and will have no effect. With TLS 1.3, rehandshaking has
// been removed from the TLS protocol, replaced by separate post-handshake
// authentication and rekey operations.
	func (c TLSConnection) SetRehandshakeMode(mode TLSRehandshakeMode)  {
var _arg0 *C.GTlsConnection // out
var _arg1 C.GTlsRehandshakeMode // out

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.GTlsRehandshakeMode)(mode)

C.g_tls_connection_set_rehandshake_mode(_arg0, _arg1)
}
	
	// SetRequireCloseNotify sets whether or not @conn expects a proper TLS close
// notification before the connection is closed. If this is true (the default),
// then @conn will expect to receive a TLS close notification from its peer
// before the connection is closed, and will return a G_TLS_ERROR_EOF error if
// the connection is closed without proper notification (since this may indicate
// a network error, or man-in-the-middle attack).
// 
// In some protocols, the application will know whether or not the connection
// was closed cleanly based on application-level data (because the
// application-level data includes a length field, or is somehow
// self-delimiting); in this case, the close notify is redundant and sometimes
// omitted. (TLS 1.1 explicitly allows this; in TLS 1.0 it is technically an
// error, but often done anyway.) You can use
// g_tls_connection_set_require_close_notify() to tell @conn to allow an
// "unannounced" connection close, in which case the close will show up as a
// 0-length read, as in a non-TLS Connection, and it is up to the application to
// check that the data has been fully received.
// 
// Note that this only affects the behavior when the peer closes the connection;
// when the application calls g_io_stream_close() itself on @conn, this will
// send a close notification regardless of the setting of this property. If you
// explicitly want to do an unclean close, you can close @conn's
// Connection:base-io-stream rather than closing @conn itself, but note that
// this may only be done when no other operations are pending on @conn or the
// base I/O stream.
	func (c TLSConnection) SetRequireCloseNotify(requireCloseNotify bool)  {
var _arg0 *C.GTlsConnection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
if requireCloseNotify { _arg1 = C.TRUE }

C.g_tls_connection_set_require_close_notify(_arg0, _arg1)
}
	
	// SetUseSystemCertdb sets whether @conn uses the system certificate database to
// verify peer certificates. This is true by default. If set to false, then peer
// certificate validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA error
// (meaning Connection::accept-certificate will always be emitted on client-side
// connections, unless that bit is not set in
// ClientConnection:validation-flags).
	func (c TLSConnection) SetUseSystemCertdb(useSystemCertdb bool)  {
var _arg0 *C.GTlsConnection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
if useSystemCertdb { _arg1 = C.TRUE }

C.g_tls_connection_set_use_system_certdb(_arg0, _arg1)
}
	


	// TLSDatabase is used to look up certificates and other information from a
// certificate or key store. It is an abstract base class which TLS library
// specific subtypes override.
// 
// A Database may be accessed from multiple threads by the TLS backend. All
// implementations are required to be fully thread-safe.
// 
// Most common client applications will not directly interact with Database. It
// is used internally by Connection.
	type TLSDatabase struct {
		**externglib.Object
		
	}

	// TLSDatabaseClass is an interface that the TLSDatabase class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TLSDatabaseClass interface {
		gextras.Objector
		_tlsDatabase()
	}

	func (TLSDatabase) _tlsDatabase() {}

	
	func marshalTLSDatabase(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTLSDatabase(obj), nil
	}
	

	

	
	// CreateCertificateHandle: create a handle string for the certificate. The
// database will only be able to create a handle for certificates that originate
// from the database. In cases where the database cannot create a handle for a
// certificate, nil will be returned.
// 
// This handle should be stable across various instances of the application, and
// between applications. If a certificate is modified in the database, then it
// is not guaranteed that this handle will continue to point to it.
	func (s TLSDatabase) CreateCertificateHandle(certificate TLSCertificateClass) string {
var _arg0 *C.GTlsDatabase // out
var _arg1 *C.GTlsCertificate // out
var _cret *C.gchar // in

_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))

_cret = C.g_tls_database_create_certificate_handle(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// LookupCertificateForHandle: look up a certificate by its handle.
// 
// The handle should have been created by calling
// g_tls_database_create_certificate_handle() on a Database object of the same
// TLS backend. The handle is designed to remain valid across instantiations of
// the database.
// 
// If the handle is no longer valid, or does not point to a certificate in this
// database, then nil will be returned.
// 
// This function can block, use
// g_tls_database_lookup_certificate_for_handle_async() to perform the lookup
// operation asynchronously.
	func (s TLSDatabase) LookupCertificateForHandle(handle string, interaction TLSInteractionClass, flags TLSDatabaseLookupFlags, cancellable CancellableClass) (TLSCertificate, error) {
var _arg0 *C.GTlsDatabase // out
var _arg1 *C.gchar // out
var _arg2 *C.GTlsInteraction // out
var _arg3 C.GTlsDatabaseLookupFlags // out
var _arg4 *C.GCancellable // out
var _cret *C.GTlsCertificate // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(handle))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))
_arg3 = (C.GTlsDatabaseLookupFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_tls_database_lookup_certificate_for_handle(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _tlsCertificate TLSCertificate // out
var _goerr error // out

_tlsCertificate = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSCertificate)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificate, _goerr
}
	
	// LookupCertificateForHandleFinish: finish an asynchronous lookup of a
// certificate by its handle. See g_tls_database_lookup_certificate_for_handle()
// for more information.
// 
// If the handle is no longer valid, or does not point to a certificate in this
// database, then nil will be returned.
	func (s TLSDatabase) LookupCertificateForHandleFinish(result AsyncResult) (TLSCertificate, error) {
var _arg0 *C.GTlsDatabase // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GTlsCertificate // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_tls_database_lookup_certificate_for_handle_finish(_arg0, _arg1, &_cerr)


var _tlsCertificate TLSCertificate // out
var _goerr error // out

_tlsCertificate = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSCertificate)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificate, _goerr
}
	
	// LookupCertificateIssuer: look up the issuer of @certificate in the database.
// 
// The Certificate:issuer property of @certificate is not modified, and the two
// certificates are not hooked into a chain.
// 
// This function can block, use g_tls_database_lookup_certificate_issuer_async()
// to perform the lookup operation asynchronously.
	func (s TLSDatabase) LookupCertificateIssuer(certificate TLSCertificateClass, interaction TLSInteractionClass, flags TLSDatabaseLookupFlags, cancellable CancellableClass) (TLSCertificate, error) {
var _arg0 *C.GTlsDatabase // out
var _arg1 *C.GTlsCertificate // out
var _arg2 *C.GTlsInteraction // out
var _arg3 C.GTlsDatabaseLookupFlags // out
var _arg4 *C.GCancellable // out
var _cret *C.GTlsCertificate // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))
_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))
_arg3 = (C.GTlsDatabaseLookupFlags)(flags)
_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_tls_database_lookup_certificate_issuer(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _tlsCertificate TLSCertificate // out
var _goerr error // out

_tlsCertificate = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSCertificate)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificate, _goerr
}
	
	// LookupCertificateIssuerFinish: finish an asynchronous lookup issuer
// operation. See g_tls_database_lookup_certificate_issuer() for more
// information.
	func (s TLSDatabase) LookupCertificateIssuerFinish(result AsyncResult) (TLSCertificate, error) {
var _arg0 *C.GTlsDatabase // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GTlsCertificate // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_tls_database_lookup_certificate_issuer_finish(_arg0, _arg1, &_cerr)


var _tlsCertificate TLSCertificate // out
var _goerr error // out

_tlsCertificate = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TLSCertificate)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificate, _goerr
}
	
	// VerifyChain determines the validity of a certificate chain after looking up
// and adding any missing certificates to the chain.
// 
// @chain is a chain of Certificate objects each pointing to the next
// certificate in the chain by its Certificate:issuer property. The chain may
// initially consist of one or more certificates. After the verification process
// is complete, @chain may be modified by adding missing certificates, or
// removing extra certificates. If a certificate anchor was found, then it is
// added to the @chain.
// 
// @purpose describes the purpose (or usage) for which the certificate is being
// used. Typically @purpose will be set to
// TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER which means that the certificate is
// being used to authenticate a server (and we are acting as the client).
// 
// The @identity is used to ensure the server certificate is valid for the
// expected peer identity. If the identity does not match the certificate,
// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value. If @identity
// is nil, that bit will never be set in the return value. The peer identity may
// also be used to check for pinned certificates (trust exceptions) in the
// database. These may override the normal verification process on a
// host-by-host basis.
// 
// Currently there are no @flags, and G_TLS_DATABASE_VERIFY_NONE should be used.
// 
// If @chain is found to be valid, then the return value will be 0. If @chain is
// found to be invalid, then the return value will indicate the problems found.
// If the function is unable to determine whether @chain is valid or not (eg,
// because @cancellable is triggered before it completes) then the return value
// will be G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set accordingly.
// @error is not set when @chain is successfully analyzed but found to be
// invalid.
// 
// This function can block, use g_tls_database_verify_chain_async() to perform
// the verification operation asynchronously.
	func (s TLSDatabase) VerifyChain(chain TLSCertificateClass, purpose string, identity SocketConnectable, interaction TLSInteractionClass, flags TLSDatabaseVerifyFlags, cancellable CancellableClass) (TLSCertificateFlags, error) {
var _arg0 *C.GTlsDatabase // out
var _arg1 *C.GTlsCertificate // out
var _arg2 *C.gchar // out
var _arg3 *C.GSocketConnectable // out
var _arg4 *C.GTlsInteraction // out
var _arg5 C.GTlsDatabaseVerifyFlags // out
var _arg6 *C.GCancellable // out
var _cret C.GTlsCertificateFlags // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(chain.Native()))
_arg2 = (*C.gchar)(C.CString(purpose))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GSocketConnectable)(unsafe.Pointer(identity.Native()))
_arg4 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))
_arg5 = (C.GTlsDatabaseVerifyFlags)(flags)
_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_tls_database_verify_chain(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_cerr)


var _tlsCertificateFlags TLSCertificateFlags // out
var _goerr error // out

_tlsCertificateFlags = TLSCertificateFlags(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificateFlags, _goerr
}
	
	// VerifyChainFinish: finish an asynchronous verify chain operation. See
// g_tls_database_verify_chain() for more information.
// 
// If @chain is found to be valid, then the return value will be 0. If @chain is
// found to be invalid, then the return value will indicate the problems found.
// If the function is unable to determine whether @chain is valid or not (eg,
// because @cancellable is triggered before it completes) then the return value
// will be G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set accordingly.
// @error is not set when @chain is successfully analyzed but found to be
// invalid.
	func (s TLSDatabase) VerifyChainFinish(result AsyncResult) (TLSCertificateFlags, error) {
var _arg0 *C.GTlsDatabase // out
var _arg1 *C.GAsyncResult // out
var _cret C.GTlsCertificateFlags // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_tls_database_verify_chain_finish(_arg0, _arg1, &_cerr)


var _tlsCertificateFlags TLSCertificateFlags // out
var _goerr error // out

_tlsCertificateFlags = TLSCertificateFlags(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsCertificateFlags, _goerr
}
	


	// TLSInteraction provides a mechanism for the TLS connection and database code
// to interact with the user. It can be used to ask the user for passwords.
// 
// To use a Interaction with a TLS connection use
// g_tls_connection_set_interaction().
// 
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
// 
// Callers should use the 'invoke' functions like
// g_tls_interaction_invoke_ask_password() to run interaction methods. These
// functions make sure that the interaction is invoked in the main loop and not
// in the current thread, if the current thread is not running the main loop.
// 
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
// it must also implement the corresponding finish method.
	type TLSInteraction struct {
		**externglib.Object
		
	}

	// TLSInteractionClass is an interface that the TLSInteraction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TLSInteractionClass interface {
		gextras.Objector
		_tlsInteraction()
	}

	func (TLSInteraction) _tlsInteraction() {}

	
	func marshalTLSInteraction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTLSInteraction(obj), nil
	}
	

	

	
	// AskPassword: run synchronous interaction to ask the user for a password. In
// general, g_tls_interaction_invoke_ask_password() should be used instead of
// this function.
// 
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will be
// filled in and then @callback will be called. Alternatively the user may abort
// this password request, which will usually abort the TLS connection.
// 
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
	func (i TLSInteraction) AskPassword(password TLSPasswordClass, cancellable CancellableClass) (TLSInteractionResult, error) {
var _arg0 *C.GTlsInteraction // out
var _arg1 *C.GTlsPassword // out
var _arg2 *C.GCancellable // out
var _cret C.GTlsInteractionResult // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GTlsPassword)(unsafe.Pointer(password.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_tls_interaction_ask_password(_arg0, _arg1, _arg2, &_cerr)


var _tlsInteractionResult TLSInteractionResult // out
var _goerr error // out

_tlsInteractionResult = TLSInteractionResult(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsInteractionResult, _goerr
}
	
	// AskPasswordFinish: complete an ask password user interaction request. This
// should be once the g_tls_interaction_ask_password_async() completion callback
// is called.
// 
// If G_TLS_INTERACTION_HANDLED is returned, then the Password passed to
// g_tls_interaction_ask_password() will have its password filled in.
// 
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code.
	func (i TLSInteraction) AskPasswordFinish(result AsyncResult) (TLSInteractionResult, error) {
var _arg0 *C.GTlsInteraction // out
var _arg1 *C.GAsyncResult // out
var _cret C.GTlsInteractionResult // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_tls_interaction_ask_password_finish(_arg0, _arg1, &_cerr)


var _tlsInteractionResult TLSInteractionResult // out
var _goerr error // out

_tlsInteractionResult = TLSInteractionResult(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsInteractionResult, _goerr
}
	
	// InvokeAskPassword: invoke the interaction to ask the user for a password. It
// invokes this interaction in the main loop, specifically the Context returned
// by g_main_context_get_thread_default() when the interaction is created. This
// is called by called by Connection or Database to ask the user for a password.
// 
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will be
// filled in and then @callback will be called. Alternatively the user may abort
// this password request, which will usually abort the TLS connection.
// 
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
// 
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
	func (i TLSInteraction) InvokeAskPassword(password TLSPasswordClass, cancellable CancellableClass) (TLSInteractionResult, error) {
var _arg0 *C.GTlsInteraction // out
var _arg1 *C.GTlsPassword // out
var _arg2 *C.GCancellable // out
var _cret C.GTlsInteractionResult // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GTlsPassword)(unsafe.Pointer(password.Native()))
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_tls_interaction_invoke_ask_password(_arg0, _arg1, _arg2, &_cerr)


var _tlsInteractionResult TLSInteractionResult // out
var _goerr error // out

_tlsInteractionResult = TLSInteractionResult(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsInteractionResult, _goerr
}
	
	// InvokeRequestCertificate: invoke the interaction to ask the user to choose a
// certificate to use with the connection. It invokes this interaction in the
// main loop, specifically the Context returned by
// g_main_context_get_thread_default() when the interaction is created. This is
// called by called by Connection when the peer requests a certificate during
// the handshake.
// 
// Derived subclasses usually implement a certificate selector, although they
// may also choose to provide a certificate from elsewhere. Alternatively the
// user may abort this certificate request, which may or may not abort the TLS
// connection.
// 
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
// 
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
	func (i TLSInteraction) InvokeRequestCertificate(connection TLSConnectionClass, flags TLSCertificateRequestFlags, cancellable CancellableClass) (TLSInteractionResult, error) {
var _arg0 *C.GTlsInteraction // out
var _arg1 *C.GTlsConnection // out
var _arg2 C.GTlsCertificateRequestFlags // out
var _arg3 *C.GCancellable // out
var _cret C.GTlsInteractionResult // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GTlsConnection)(unsafe.Pointer(connection.Native()))
_arg2 = (C.GTlsCertificateRequestFlags)(flags)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_tls_interaction_invoke_request_certificate(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _tlsInteractionResult TLSInteractionResult // out
var _goerr error // out

_tlsInteractionResult = TLSInteractionResult(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsInteractionResult, _goerr
}
	
	// RequestCertificate: run synchronous interaction to ask the user to choose a
// certificate to use with the connection. In general,
// g_tls_interaction_invoke_request_certificate() should be used instead of this
// function.
// 
// Derived subclasses usually implement a certificate selector, although they
// may also choose to provide a certificate from elsewhere. Alternatively the
// user may abort this certificate request, which will usually abort the TLS
// connection.
// 
// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed to
// g_tls_interaction_request_certificate() will have had its
// Connection:certificate filled in.
// 
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
	func (i TLSInteraction) RequestCertificate(connection TLSConnectionClass, flags TLSCertificateRequestFlags, cancellable CancellableClass) (TLSInteractionResult, error) {
var _arg0 *C.GTlsInteraction // out
var _arg1 *C.GTlsConnection // out
var _arg2 C.GTlsCertificateRequestFlags // out
var _arg3 *C.GCancellable // out
var _cret C.GTlsInteractionResult // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GTlsConnection)(unsafe.Pointer(connection.Native()))
_arg2 = (C.GTlsCertificateRequestFlags)(flags)
_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_tls_interaction_request_certificate(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _tlsInteractionResult TLSInteractionResult // out
var _goerr error // out

_tlsInteractionResult = TLSInteractionResult(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsInteractionResult, _goerr
}
	
	// RequestCertificateFinish: complete a request certificate user interaction
// request. This should be once the
// g_tls_interaction_request_certificate_async() completion callback is called.
// 
// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed to
// g_tls_interaction_request_certificate_async() will have had its
// Connection:certificate filled in.
// 
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code.
	func (i TLSInteraction) RequestCertificateFinish(result AsyncResult) (TLSInteractionResult, error) {
var _arg0 *C.GTlsInteraction // out
var _arg1 *C.GAsyncResult // out
var _cret C.GTlsInteractionResult // in
var _cerr *C.GError // in

_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_tls_interaction_request_certificate_finish(_arg0, _arg1, &_cerr)


var _tlsInteractionResult TLSInteractionResult // out
var _goerr error // out

_tlsInteractionResult = TLSInteractionResult(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _tlsInteractionResult, _goerr
}
	


	// TLSPassword holds a password used in TLS.
	type TLSPassword struct {
		**externglib.Object
		
	}

	// TLSPasswordClass is an interface that the TLSPassword class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TLSPasswordClass interface {
		gextras.Objector
		_tlsPassword()
	}

	func (TLSPassword) _tlsPassword() {}

	
	func marshalTLSPassword(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTLSPassword(obj), nil
	}
	

	
	// NewTLSPassword: create a new Password object.
	func NewTLSPassword(flags TLSPasswordFlags, description string) TLSPassword {
var _arg1 C.GTlsPasswordFlags // out
var _arg2 *C.gchar // out
var _cret *C.GTlsPassword // in

_arg1 = (C.GTlsPasswordFlags)(flags)
_arg2 = (*C.gchar)(C.CString(description))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.g_tls_password_new(_arg1, _arg2)


var _tlsPassword TLSPassword // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_tlsPassword = TLSPassword{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _tlsPassword
}
	

	
	// Description: get a description string about what the password will be used
// for.
	func (p TLSPassword) Description() string {
var _arg0 *C.GTlsPassword // out
var _cret *C.gchar // in

_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))

_cret = C.g_tls_password_get_description(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Flags: get flags about the password.
	func (p TLSPassword) Flags() TLSPasswordFlags {
var _arg0 *C.GTlsPassword // out
var _cret C.GTlsPasswordFlags // in

_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))

_cret = C.g_tls_password_get_flags(_arg0)


var _tlsPasswordFlags TLSPasswordFlags // out

_tlsPasswordFlags = TLSPasswordFlags(_cret)

return _tlsPasswordFlags
}
	
	// Value: get the password value. If @length is not nil then it will be filled
// in with the length of the password value. (Note that the password value is
// not nul-terminated, so you can only pass nil for @length in contexts where
// you know the password will have a certain fixed length.)
	func (p TLSPassword) Value(length *uint) *byte {
var _arg0 *C.GTlsPassword // out
var _arg1 *C.gsize // out
var _cret *C.guchar // in

_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gsize)(unsafe.Pointer(length))

_cret = C.g_tls_password_get_value(_arg0, _arg1)


var _guint8 *byte // out

_guint8 = (*byte)(_cret)

return _guint8
}
	
	// Warning: get a user readable translated warning. Usually this warning is a
// representation of the password flags returned from
// g_tls_password_get_flags().
	func (p TLSPassword) Warning() string {
var _arg0 *C.GTlsPassword // out
var _cret *C.gchar // in

_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))

_cret = C.g_tls_password_get_warning(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetDescription: set a description string about what the password will be used
// for.
	func (p TLSPassword) SetDescription(description string)  {
var _arg0 *C.GTlsPassword // out
var _arg1 *C.gchar // out

_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(description))
defer C.free(unsafe.Pointer(_arg1))

C.g_tls_password_set_description(_arg0, _arg1)
}
	
	// SetFlags: set flags about the password.
	func (p TLSPassword) SetFlags(flags TLSPasswordFlags)  {
var _arg0 *C.GTlsPassword // out
var _arg1 C.GTlsPasswordFlags // out

_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
_arg1 = (C.GTlsPasswordFlags)(flags)

C.g_tls_password_set_flags(_arg0, _arg1)
}
	
	// SetValue: set the value for this password. The @value will be copied by the
// password object.
// 
// Specify the @length, for a non-nul-terminated password. Pass -1 as @length if
// using a nul-terminated password, and @length will be calculated
// automatically. (Note that the terminating nul is not considered part of the
// password in this case.)
	func (p TLSPassword) SetValue(value []byte)  {
var _arg0 *C.GTlsPassword // out
var _arg1 *C.guchar
var _arg2 C.gssize

_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
_arg2 = C.gssize(len(value))
_arg1 = (*C.guchar)(unsafe.Pointer(&value[0]))

C.g_tls_password_set_value(_arg0, _arg1, _arg2)
}
	
	// SetWarning: set a user readable translated warning. Usually this warning is a
// representation of the password flags returned from
// g_tls_password_get_flags().
	func (p TLSPassword) SetWarning(warning string)  {
var _arg0 *C.GTlsPassword // out
var _arg1 *C.gchar // out

_arg0 = (*C.GTlsPassword)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(warning))
defer C.free(unsafe.Pointer(_arg1))

C.g_tls_password_set_warning(_arg0, _arg1)
}
	


	// UnixConnection: this is the subclass of Connection that is created for UNIX
// domain sockets.
// 
// It contains functions to do some of the UNIX socket specific functionality
// like passing file descriptors.
// 
// Note that `<gio/gunixconnection.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
	type UnixConnection struct {
		SocketConnection
		
	}

	// UnixConnectionClass is an interface that the UnixConnection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type UnixConnectionClass interface {
		gextras.Objector
		_unixConnection()
	}

	func (UnixConnection) _unixConnection() {}

	
	func marshalUnixConnection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapUnixConnection(obj), nil
	}
	

	

	
	// ReceiveCredentials receives credentials from the sending end of the
// connection. The sending end has to call g_unix_connection_send_credentials()
// (or similar) for this to work.
// 
// As well as reading the credentials this also reads (and discards) a single
// byte from the stream, as this is required for credentials passing to work on
// some implementations.
// 
// This method can be expected to be available on the following platforms:
// 
// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since GLib
// 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd since GLib
// 2.40
// 
// Other ways to exchange credentials with a foreign peer includes the
// CredentialsMessage type and g_socket_get_credentials() function.
	func (c UnixConnection) ReceiveCredentials(cancellable CancellableClass) (Credentials, error) {
var _arg0 *C.GUnixConnection // out
var _arg1 *C.GCancellable // out
var _cret *C.GCredentials // in
var _cerr *C.GError // in

_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_unix_connection_receive_credentials(_arg0, _arg1, &_cerr)


var _credentials Credentials // out
var _goerr error // out

_credentials = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Credentials)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _credentials, _goerr
}
	
	// ReceiveCredentialsFinish finishes an asynchronous receive credentials
// operation started with g_unix_connection_receive_credentials_async().
	func (c UnixConnection) ReceiveCredentialsFinish(result AsyncResult) (Credentials, error) {
var _arg0 *C.GUnixConnection // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GCredentials // in
var _cerr *C.GError // in

_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

_cret = C.g_unix_connection_receive_credentials_finish(_arg0, _arg1, &_cerr)


var _credentials Credentials // out
var _goerr error // out

_credentials = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Credentials)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _credentials, _goerr
}
	
	// ReceiveFd receives a file descriptor from the sending end of the connection.
// The sending end has to call g_unix_connection_send_fd() for this to work.
// 
// As well as reading the fd this also reads a single byte from the stream, as
// this is required for fd passing to work on some implementations.
	func (c UnixConnection) ReceiveFd(cancellable CancellableClass) (int, error) {
var _arg0 *C.GUnixConnection // out
var _arg1 *C.GCancellable // out
var _cret C.gint // in
var _cerr *C.GError // in

_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

_cret = C.g_unix_connection_receive_fd(_arg0, _arg1, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// SendCredentials passes the credentials of the current user the receiving side
// of the connection. The receiving end has to call
// g_unix_connection_receive_credentials() (or similar) to accept the
// credentials.
// 
// As well as sending the credentials this also writes a single NUL byte to the
// stream, as this is required for credentials passing to work on some
// implementations.
// 
// This method can be expected to be available on the following platforms:
// 
// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since GLib
// 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd since GLib
// 2.40
// 
// Other ways to exchange credentials with a foreign peer includes the
// CredentialsMessage type and g_socket_get_credentials() function.
	func (c UnixConnection) SendCredentials(cancellable CancellableClass) error {
var _arg0 *C.GUnixConnection // out
var _arg1 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_unix_connection_send_credentials(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SendCredentialsFinish finishes an asynchronous send credentials operation
// started with g_unix_connection_send_credentials_async().
	func (c UnixConnection) SendCredentialsFinish(result AsyncResult) error {
var _arg0 *C.GUnixConnection // out
var _arg1 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.g_unix_connection_send_credentials_finish(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SendFd passes a file descriptor to the receiving side of the connection. The
// receiving end has to call g_unix_connection_receive_fd() to accept the file
// descriptor.
// 
// As well as sending the fd this also writes a single byte to the stream, as
// this is required for fd passing to work on some implementations.
	func (c UnixConnection) SendFd(fd int, cancellable CancellableClass) error {
var _arg0 *C.GUnixConnection // out
var _arg1 C.gint // out
var _arg2 *C.GCancellable // out
var _cerr *C.GError // in

_arg0 = (*C.GUnixConnection)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(fd)
_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

C.g_unix_connection_send_fd(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	// UnixCredentialsMessage: this ControlMessage contains a #GCredentials
// instance. It may be sent using g_socket_send_message() and received using
// g_socket_receive_message() over UNIX sockets (ie: sockets in the
// G_SOCKET_FAMILY_UNIX family).
// 
// For an easier way to send and receive credentials over stream-oriented UNIX
// sockets, see g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials(). To receive credentials of a foreign
// process connected to a socket, use g_socket_get_credentials().
	type UnixCredentialsMessage struct {
		SocketControlMessage
		
	}

	// UnixCredentialsMessageClass is an interface that the UnixCredentialsMessage class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type UnixCredentialsMessageClass interface {
		gextras.Objector
		_unixCredentialsMessage()
	}

	func (UnixCredentialsMessage) _unixCredentialsMessage() {}

	
	func marshalUnixCredentialsMessage(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapUnixCredentialsMessage(obj), nil
	}
	

	
	// NewUnixCredentialsMessage creates a new CredentialsMessage with credentials
// matching the current processes.
	func NewUnixCredentialsMessage() UnixCredentialsMessage {
var _cret *C.GSocketControlMessage // in

_cret = C.g_unix_credentials_message_new()


var _unixCredentialsMessage UnixCredentialsMessage // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixCredentialsMessage = UnixCredentialsMessage{
SocketControlMessage: SocketControlMessage{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _unixCredentialsMessage
}
	
	// NewUnixCredentialsMessageWithCredentials creates a new CredentialsMessage
// holding @credentials.
	func NewUnixCredentialsMessageWithCredentials(credentials CredentialsClass) UnixCredentialsMessage {
var _arg1 *C.GCredentials // out
var _cret *C.GSocketControlMessage // in

_arg1 = (*C.GCredentials)(unsafe.Pointer(credentials.Native()))

_cret = C.g_unix_credentials_message_new_with_credentials(_arg1)


var _unixCredentialsMessage UnixCredentialsMessage // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixCredentialsMessage = UnixCredentialsMessage{
SocketControlMessage: SocketControlMessage{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _unixCredentialsMessage
}
	

	
	// Credentials gets the credentials stored in @message.
	func (m UnixCredentialsMessage) Credentials() Credentials {
var _arg0 *C.GUnixCredentialsMessage // out
var _cret *C.GCredentials // in

_arg0 = (*C.GUnixCredentialsMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_credentials_message_get_credentials(_arg0)


var _credentials Credentials // out

_credentials = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Credentials)

return _credentials
}
	


	// UnixFDList: a FDList contains a list of file descriptors. It owns the file
// descriptors that it contains, closing them when finalized.
// 
// It may be wrapped in a FDMessage and sent over a #GSocket in the
// G_SOCKET_FAMILY_UNIX family by using g_socket_send_message() and received
// using g_socket_receive_message().
// 
// Note that `<gio/gunixfdlist.h>` belongs to the UNIX-specific GIO interfaces,
// thus you have to use the `gio-unix-2.0.pc` pkg-config file when using it.
	type UnixFDList struct {
		**externglib.Object
		
	}

	// UnixFDListClass is an interface that the UnixFDList class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type UnixFDListClass interface {
		gextras.Objector
		_unixFDList()
	}

	func (UnixFDList) _unixFDList() {}

	
	func marshalUnixFDList(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapUnixFDList(obj), nil
	}
	

	
	// NewUnixFDList creates a new FDList containing no file descriptors.
	func NewUnixFDList() UnixFDList {
var _cret *C.GUnixFDList // in

_cret = C.g_unix_fd_list_new()


var _unixFDList UnixFDList // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixFDList = UnixFDList{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _unixFDList
}
	
	// NewUnixFDListFromArray creates a new FDList containing the file descriptors
// given in @fds. The file descriptors become the property of the new list and
// may no longer be used by the caller. The array itself is owned by the caller.
// 
// Each file descriptor in the array should be set to close-on-exec.
// 
// If @n_fds is -1 then @fds must be terminated with -1.
	func NewUnixFDListFromArray(fds []int) UnixFDList {
var _arg1 *C.gint
var _arg2 C.gint
var _cret *C.GUnixFDList // in

_arg2 = C.gint(len(fds))
_arg1 = (*C.gint)(unsafe.Pointer(&fds[0]))

_cret = C.g_unix_fd_list_new_from_array(_arg1, _arg2)


var _unixFDList UnixFDList // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixFDList = UnixFDList{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _unixFDList
}
	

	
	// Append adds a file descriptor to @list.
// 
// The file descriptor is duplicated using dup(). You keep your copy of the
// descriptor and the copy contained in @list will be closed when @list is
// finalized.
// 
// A possible cause of failure is exceeding the per-process or system-wide file
// descriptor limit.
// 
// The index of the file descriptor in the list is returned. If you use this
// index with g_unix_fd_list_get() then you will receive back a duplicated copy
// of the same file descriptor.
	func (l UnixFDList) Append(fd int) (int, error) {
var _arg0 *C.GUnixFDList // out
var _arg1 C.gint // out
var _cret C.gint // in
var _cerr *C.GError // in

_arg0 = (*C.GUnixFDList)(unsafe.Pointer(l.Native()))
_arg1 = (C.gint)(fd)

_cret = C.g_unix_fd_list_append(_arg0, _arg1, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// Get gets a file descriptor out of @list.
// 
// @index_ specifies the index of the file descriptor to get. It is a programmer
// error for @index_ to be out of range; see g_unix_fd_list_get_length().
// 
// The file descriptor is duplicated using dup() and set as close-on-exec before
// being returned. You must call close() on it when you are done.
// 
// A possible cause of failure is exceeding the per-process or system-wide file
// descriptor limit.
	func (l UnixFDList) Get(index_ int) (int, error) {
var _arg0 *C.GUnixFDList // out
var _arg1 C.gint // out
var _cret C.gint // in
var _cerr *C.GError // in

_arg0 = (*C.GUnixFDList)(unsafe.Pointer(l.Native()))
_arg1 = (C.gint)(index_)

_cret = C.g_unix_fd_list_get(_arg0, _arg1, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// Length gets the length of @list (ie: the number of file descriptors contained
// within).
	func (l UnixFDList) Length() int {
var _arg0 *C.GUnixFDList // out
var _cret C.gint // in

_arg0 = (*C.GUnixFDList)(unsafe.Pointer(l.Native()))

_cret = C.g_unix_fd_list_get_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	


	// UnixFDMessage: this ControlMessage contains a FDList. It may be sent using
// g_socket_send_message() and received using g_socket_receive_message() over
// UNIX sockets (ie: sockets in the G_SOCKET_FAMILY_UNIX family). The file
// descriptors are copied between processes by the kernel.
// 
// For an easier way to send and receive file descriptors over stream-oriented
// UNIX sockets, see g_unix_connection_send_fd() and
// g_unix_connection_receive_fd().
// 
// Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
	type UnixFDMessage struct {
		SocketControlMessage
		
	}

	// UnixFDMessageClass is an interface that the UnixFDMessage class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type UnixFDMessageClass interface {
		gextras.Objector
		_unixFDMessage()
	}

	func (UnixFDMessage) _unixFDMessage() {}

	
	func marshalUnixFDMessage(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapUnixFDMessage(obj), nil
	}
	

	
	// NewUnixFDMessage creates a new FDMessage containing an empty file descriptor
// list.
	func NewUnixFDMessage() UnixFDMessage {
var _cret *C.GSocketControlMessage // in

_cret = C.g_unix_fd_message_new()


var _unixFDMessage UnixFDMessage // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixFDMessage = UnixFDMessage{
SocketControlMessage: SocketControlMessage{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _unixFDMessage
}
	
	// NewUnixFDMessageWithFdList creates a new FDMessage containing @list.
	func NewUnixFDMessageWithFdList(fdList UnixFDListClass) UnixFDMessage {
var _arg1 *C.GUnixFDList // out
var _cret *C.GSocketControlMessage // in

_arg1 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

_cret = C.g_unix_fd_message_new_with_fd_list(_arg1)


var _unixFDMessage UnixFDMessage // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixFDMessage = UnixFDMessage{
SocketControlMessage: SocketControlMessage{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _unixFDMessage
}
	

	
	// AppendFd adds a file descriptor to @message.
// 
// The file descriptor is duplicated using dup(). You keep your copy of the
// descriptor and the copy contained in @message will be closed when @message is
// finalized.
// 
// A possible cause of failure is exceeding the per-process or system-wide file
// descriptor limit.
	func (m UnixFDMessage) AppendFd(fd int) error {
var _arg0 *C.GUnixFDMessage // out
var _arg1 C.gint // out
var _cerr *C.GError // in

_arg0 = (*C.GUnixFDMessage)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(fd)

C.g_unix_fd_message_append_fd(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// FdList gets the FDList contained in @message. This function does not return a
// reference to the caller, but the returned list is valid for the lifetime of
// @message.
	func (m UnixFDMessage) FdList() UnixFDList {
var _arg0 *C.GUnixFDMessage // out
var _cret *C.GUnixFDList // in

_arg0 = (*C.GUnixFDMessage)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_fd_message_get_fd_list(_arg0)


var _unixFDList UnixFDList // out

_unixFDList = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(UnixFDList)

return _unixFDList
}
	


	// UnixInputStream implements Stream for reading from a UNIX file descriptor,
// including asynchronous operations. (If the file descriptor refers to a socket
// or pipe, this will use poll() to do asynchronous I/O. If it refers to a
// regular file, it will fall back to doing asynchronous I/O in another thread.)
// 
// Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
	type UnixInputStream struct {
		InputStream
		FileDescriptorBased
		PollableInputStream
		
	}

	// UnixInputStreamClass is an interface that the UnixInputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type UnixInputStreamClass interface {
		gextras.Objector
		_unixInputStream()
	}

	func (UnixInputStream) _unixInputStream() {}

	
	func marshalUnixInputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapUnixInputStream(obj), nil
	}
	

	
	// NewUnixInputStream creates a new InputStream for the given @fd.
// 
// If @close_fd is true, the file descriptor will be closed when the stream is
// closed.
	func NewUnixInputStream(fd int, closeFd bool) UnixInputStream {
var _arg1 C.gint // out
var _arg2 C.gboolean // out
var _cret *C.GInputStream // in

_arg1 = (C.gint)(fd)
if closeFd { _arg2 = C.TRUE }

_cret = C.g_unix_input_stream_new(_arg1, _arg2)


var _unixInputStream UnixInputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixInputStream = UnixInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FileDescriptorBased: FileDescriptorBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
PollableInputStream: PollableInputStream{
InputStream: InputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _unixInputStream
}
	

	
	// CloseFd returns whether the file descriptor of @stream will be closed when
// the stream is closed.
	func (s UnixInputStream) CloseFd() bool {
var _arg0 *C.GUnixInputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GUnixInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_unix_input_stream_get_close_fd(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Fd: return the UNIX file descriptor that the stream reads from.
	func (s UnixInputStream) Fd() int {
var _arg0 *C.GUnixInputStream // out
var _cret C.gint // in

_arg0 = (*C.GUnixInputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_unix_input_stream_get_fd(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SetCloseFd sets whether the file descriptor of @stream shall be closed when
// the stream is closed.
	func (s UnixInputStream) SetCloseFd(closeFd bool)  {
var _arg0 *C.GUnixInputStream // out
var _arg1 C.gboolean // out

_arg0 = (*C.GUnixInputStream)(unsafe.Pointer(s.Native()))
if closeFd { _arg1 = C.TRUE }

C.g_unix_input_stream_set_close_fd(_arg0, _arg1)
}
	


	// UnixMountMonitor watches Mounts for changes.
	type UnixMountMonitor struct {
		**externglib.Object
		
	}

	// UnixMountMonitorClass is an interface that the UnixMountMonitor class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type UnixMountMonitorClass interface {
		gextras.Objector
		_unixMountMonitor()
	}

	func (UnixMountMonitor) _unixMountMonitor() {}

	
	func marshalUnixMountMonitor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapUnixMountMonitor(obj), nil
	}
	

	
	// NewUnixMountMonitor: deprecated alias for g_unix_mount_monitor_get().
// 
// This function was never a true constructor, which is why it was renamed.
	func NewUnixMountMonitor() UnixMountMonitor {
var _cret *C.GUnixMountMonitor // in

_cret = C.g_unix_mount_monitor_new()


var _unixMountMonitor UnixMountMonitor // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixMountMonitor = UnixMountMonitor{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _unixMountMonitor
}
	

	
	// SetRateLimit: this function does nothing.
// 
// Before 2.44, this was a partially-effective way of controlling the rate at
// which events would be reported under some uncommon circumstances. Since
// @mount_monitor is a singleton, it also meant that calling this function would
// have side effects for other users of the monitor.
	func (m UnixMountMonitor) SetRateLimit(limitMsec int)  {
var _arg0 *C.GUnixMountMonitor // out
var _arg1 C.int // out

_arg0 = (*C.GUnixMountMonitor)(unsafe.Pointer(m.Native()))
_arg1 = (C.int)(limitMsec)

C.g_unix_mount_monitor_set_rate_limit(_arg0, _arg1)
}
	


	// UnixOutputStream implements Stream for writing to a UNIX file descriptor,
// including asynchronous operations. (If the file descriptor refers to a socket
// or pipe, this will use poll() to do asynchronous I/O. If it refers to a
// regular file, it will fall back to doing asynchronous I/O in another thread.)
// 
// Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
	type UnixOutputStream struct {
		OutputStream
		FileDescriptorBased
		PollableOutputStream
		
	}

	// UnixOutputStreamClass is an interface that the UnixOutputStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type UnixOutputStreamClass interface {
		gextras.Objector
		_unixOutputStream()
	}

	func (UnixOutputStream) _unixOutputStream() {}

	
	func marshalUnixOutputStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapUnixOutputStream(obj), nil
	}
	

	
	// NewUnixOutputStream creates a new OutputStream for the given @fd.
// 
// If @close_fd, is true, the file descriptor will be closed when the output
// stream is destroyed.
	func NewUnixOutputStream(fd int, closeFd bool) UnixOutputStream {
var _arg1 C.gint // out
var _arg2 C.gboolean // out
var _cret *C.GOutputStream // in

_arg1 = (C.gint)(fd)
if closeFd { _arg2 = C.TRUE }

_cret = C.g_unix_output_stream_new(_arg1, _arg2)


var _unixOutputStream UnixOutputStream // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixOutputStream = UnixOutputStream{
OutputStream: OutputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FileDescriptorBased: FileDescriptorBased{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
PollableOutputStream: PollableOutputStream{
OutputStream: OutputStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _unixOutputStream
}
	

	
	// CloseFd returns whether the file descriptor of @stream will be closed when
// the stream is closed.
	func (s UnixOutputStream) CloseFd() bool {
var _arg0 *C.GUnixOutputStream // out
var _cret C.gboolean // in

_arg0 = (*C.GUnixOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_unix_output_stream_get_close_fd(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Fd: return the UNIX file descriptor that the stream writes to.
	func (s UnixOutputStream) Fd() int {
var _arg0 *C.GUnixOutputStream // out
var _cret C.gint // in

_arg0 = (*C.GUnixOutputStream)(unsafe.Pointer(s.Native()))

_cret = C.g_unix_output_stream_get_fd(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SetCloseFd sets whether the file descriptor of @stream shall be closed when
// the stream is closed.
	func (s UnixOutputStream) SetCloseFd(closeFd bool)  {
var _arg0 *C.GUnixOutputStream // out
var _arg1 C.gboolean // out

_arg0 = (*C.GUnixOutputStream)(unsafe.Pointer(s.Native()))
if closeFd { _arg1 = C.TRUE }

C.g_unix_output_stream_set_close_fd(_arg0, _arg1)
}
	


	// UnixSocketAddress: support for UNIX-domain (also known as local) sockets.
// 
// UNIX domain sockets are generally visible in the filesystem. However, some
// systems support abstract socket names which are not visible in the filesystem
// and not affected by the filesystem permissions, visibility, etc. Currently
// this is only supported under Linux. If you attempt to use abstract sockets on
// other systems, function calls may return G_IO_ERROR_NOT_SUPPORTED errors. You
// can use g_unix_socket_address_abstract_names_supported() to see if abstract
// names are supported.
// 
// Note that `<gio/gunixsocketaddress.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
	type UnixSocketAddress struct {
		SocketAddress
		SocketConnectable
		
	}

	// UnixSocketAddressClass is an interface that the UnixSocketAddress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type UnixSocketAddressClass interface {
		gextras.Objector
		_unixSocketAddress()
	}

	func (UnixSocketAddress) _unixSocketAddress() {}

	
	func marshalUnixSocketAddress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapUnixSocketAddress(obj), nil
	}
	

	
	// NewUnixSocketAddress creates a new SocketAddress for @path.
// 
// To create abstract socket addresses, on systems that support that, use
// g_unix_socket_address_new_abstract().
	func NewUnixSocketAddress(path string) UnixSocketAddress {
var _arg1 *C.gchar // out
var _cret *C.GSocketAddress // in

_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_unix_socket_address_new(_arg1)


var _unixSocketAddress UnixSocketAddress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixSocketAddress = UnixSocketAddress{
SocketAddress: SocketAddress{
Object: &externglib.Object{externglib.ToGObject(obj)},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _unixSocketAddress
}
	
	// NewUnixSocketAddressAbstract creates a new
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED SocketAddress for @path.
	func NewUnixSocketAddressAbstract(path []byte) UnixSocketAddress {
var _arg1 *C.gchar
var _arg2 C.gint
var _cret *C.GSocketAddress // in

_arg2 = C.gint(len(path))
_arg1 = (*C.gchar)(unsafe.Pointer(&path[0]))

_cret = C.g_unix_socket_address_new_abstract(_arg1, _arg2)


var _unixSocketAddress UnixSocketAddress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixSocketAddress = UnixSocketAddress{
SocketAddress: SocketAddress{
Object: &externglib.Object{externglib.ToGObject(obj)},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _unixSocketAddress
}
	
	// NewUnixSocketAddressWithType creates a new SocketAddress of type @type with
// name @path.
// 
// If @type is G_UNIX_SOCKET_ADDRESS_PATH, this is equivalent to calling
// g_unix_socket_address_new().
// 
// If @type is G_UNIX_SOCKET_ADDRESS_ANONYMOUS, @path and @path_len will be
// ignored.
// 
// If @path_type is G_UNIX_SOCKET_ADDRESS_ABSTRACT, then @path_len bytes of
// @path will be copied to the socket's path, and only those bytes will be
// considered part of the name. (If @path_len is -1, then @path is assumed to be
// NUL-terminated.) For example, if @path was "test", then calling
// g_socket_address_get_native_size() on the returned socket would return 7 (2
// bytes of overhead, 1 byte for the abstract-socket indicator byte, and 4 bytes
// for the name "test").
// 
// If @path_type is G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, then @path_len bytes
// of @path will be copied to the socket's path, the rest of the path will be
// padded with 0 bytes, and the entire zero-padded buffer will be considered the
// name. (As above, if @path_len is -1, then @path is assumed to be
// NUL-terminated.) In this case, g_socket_address_get_native_size() will always
// return the full size of a `struct sockaddr_un`, although
// g_unix_socket_address_get_path_len() will still return just the length of
// @path.
// 
// G_UNIX_SOCKET_ADDRESS_ABSTRACT is preferred over
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED for new programs. Of course, when
// connecting to a server created by another process, you must use the
// appropriate type corresponding to how that process created its listening
// socket.
	func NewUnixSocketAddressWithType(path []byte, typ UnixSocketAddressType) UnixSocketAddress {
var _arg1 *C.gchar
var _arg2 C.gint
var _arg3 C.GUnixSocketAddressType // out
var _cret *C.GSocketAddress // in

_arg2 = C.gint(len(path))
_arg1 = (*C.gchar)(unsafe.Pointer(&path[0]))
_arg3 = (C.GUnixSocketAddressType)(typ)

_cret = C.g_unix_socket_address_new_with_type(_arg1, _arg2, _arg3)


var _unixSocketAddress UnixSocketAddress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_unixSocketAddress = UnixSocketAddress{
SocketAddress: SocketAddress{
Object: &externglib.Object{externglib.ToGObject(obj)},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
SocketConnectable: SocketConnectable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _unixSocketAddress
}
	

	
	// AddressType gets @address's type.
	func (a UnixSocketAddress) AddressType() UnixSocketAddressType {
var _arg0 *C.GUnixSocketAddress // out
var _cret C.GUnixSocketAddressType // in

_arg0 = (*C.GUnixSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_unix_socket_address_get_address_type(_arg0)


var _unixSocketAddressType UnixSocketAddressType // out

_unixSocketAddressType = UnixSocketAddressType(_cret)

return _unixSocketAddressType
}
	
	// IsAbstract tests if @address is abstract.
	func (a UnixSocketAddress) IsAbstract() bool {
var _arg0 *C.GUnixSocketAddress // out
var _cret C.gboolean // in

_arg0 = (*C.GUnixSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_unix_socket_address_get_is_abstract(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Path gets @address's path, or for abstract sockets the "name".
// 
// Guaranteed to be zero-terminated, but an abstract socket may contain embedded
// zeros, and thus you should use g_unix_socket_address_get_path_len() to get
// the true length of this string.
	func (a UnixSocketAddress) Path() string {
var _arg0 *C.GUnixSocketAddress // out
var _cret *C.char // in

_arg0 = (*C.GUnixSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_unix_socket_address_get_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PathLen gets the length of @address's path.
// 
// For details, see g_unix_socket_address_get_path().
	func (a UnixSocketAddress) PathLen() uint {
var _arg0 *C.GUnixSocketAddress // out
var _cret C.gsize // in

_arg0 = (*C.GUnixSocketAddress)(unsafe.Pointer(a.Native()))

_cret = C.g_unix_socket_address_get_path_len(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	


	// VFS: entry point for using GIO functionality.
	type VFS struct {
		**externglib.Object
		
	}

	// VFSClass is an interface that the VFS class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VFSClass interface {
		gextras.Objector
		_vfS()
	}

	func (VFS) _vfS() {}

	
	func marshalVFS(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVFS(obj), nil
	}
	

	

	
	// FileForPath gets a #GFile for @path.
	func (v VFS) FileForPath(path string) File {
var _arg0 *C.GVfs // out
var _arg1 *C.char // out
var _cret *C.GFile // in

_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))
_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_vfs_get_file_for_path(_arg0, _arg1)


var _file File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _file
}
	
	// FileForURI gets a #GFile for @uri.
// 
// This operation never fails, but the returned object might not support any I/O
// operation if the URI is malformed or if the URI scheme is not supported.
	func (v VFS) FileForURI(uri string) File {
var _arg0 *C.GVfs // out
var _arg1 *C.char // out
var _cret *C.GFile // in

_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_vfs_get_file_for_uri(_arg0, _arg1)


var _file File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _file
}
	
	// SupportedURISchemes gets a list of URI schemes supported by @vfs.
	func (v VFS) SupportedURISchemes() []string {
var _arg0 *C.GVfs // out
var _cret **C.gchar

_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))

_cret = C.g_vfs_get_supported_uri_schemes(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// IsActive checks if the VFS is active.
	func (v VFS) IsActive() bool {
var _arg0 *C.GVfs // out
var _cret C.gboolean // in

_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))

_cret = C.g_vfs_is_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ParseName: this operation never fails, but the returned object might not
// support any I/O operations if the @parse_name cannot be parsed by the #GVfs
// module.
	func (v VFS) ParseName(parseName string) File {
var _arg0 *C.GVfs // out
var _arg1 *C.char // out
var _cret *C.GFile // in

_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))
_arg1 = (*C.char)(C.CString(parseName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_vfs_parse_name(_arg0, _arg1)


var _file File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(File)

return _file
}
	
	// UnregisterURIScheme unregisters the URI handler for @scheme previously
// registered with g_vfs_register_uri_scheme().
	func (v VFS) UnregisterURIScheme(scheme string) bool {
var _arg0 *C.GVfs // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GVfs)(unsafe.Pointer(v.Native()))
_arg1 = (*C.char)(C.CString(scheme))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_vfs_unregister_uri_scheme(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// VolumeMonitor is for listing the user interesting devices and volumes on the
// computer. In other words, what a file selector or file manager would show in
// a sidebar.
// 
// Monitor is not [thread-default-context
// aware][g-main-context-push-thread-default], and so should not be used other
// than from the main thread, with no thread-default-context active.
// 
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
	type VolumeMonitor struct {
		**externglib.Object
		
	}

	// VolumeMonitorClass is an interface that the VolumeMonitor class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VolumeMonitorClass interface {
		gextras.Objector
		_volumeMonitor()
	}

	func (VolumeMonitor) _volumeMonitor() {}

	
	func marshalVolumeMonitor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVolumeMonitor(obj), nil
	}
	

	

	
	// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid())
	func (v VolumeMonitor) MountForUUID(uuid string) Mount {
var _arg0 *C.GVolumeMonitor // out
var _arg1 *C.char // out
var _cret *C.GMount // in

_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(v.Native()))
_arg1 = (*C.char)(C.CString(uuid))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_volume_monitor_get_mount_for_uuid(_arg0, _arg1)


var _mount Mount // out

_mount = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Mount)

return _mount
}
	
	// VolumeForUUID finds a #GVolume object by its UUID (see g_volume_get_uuid())
	func (v VolumeMonitor) VolumeForUUID(uuid string) Volume {
var _arg0 *C.GVolumeMonitor // out
var _arg1 *C.char // out
var _cret *C.GVolume // in

_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(v.Native()))
_arg1 = (*C.char)(C.CString(uuid))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_volume_monitor_get_volume_for_uuid(_arg0, _arg1)


var _volume Volume // out

_volume = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Volume)

return _volume
}
	


	// ZlibCompressor: zlib decompression
	type ZlibCompressor struct {
		**externglib.Object
		Converter
		
	}

	// ZlibCompressorClass is an interface that the ZlibCompressor class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ZlibCompressorClass interface {
		gextras.Objector
		_zlibCompressor()
	}

	func (ZlibCompressor) _zlibCompressor() {}

	
	func marshalZlibCompressor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapZlibCompressor(obj), nil
	}
	

	
	// NewZlibCompressor creates a new Compressor.
	func NewZlibCompressor(format ZlibCompressorFormat, level int) ZlibCompressor {
var _arg1 C.GZlibCompressorFormat // out
var _arg2 C.int // out
var _cret *C.GZlibCompressor // in

_arg1 = (C.GZlibCompressorFormat)(format)
_arg2 = (C.int)(level)

_cret = C.g_zlib_compressor_new(_arg1, _arg2)


var _zlibCompressor ZlibCompressor // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_zlibCompressor = ZlibCompressor{
Object: &externglib.Object{externglib.ToGObject(obj)},
Converter: Converter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _zlibCompressor
}
	

	
	// FileInfo returns the Compressor:file-info property.
	func (c ZlibCompressor) FileInfo() FileInfo {
var _arg0 *C.GZlibCompressor // out
var _cret *C.GFileInfo // in

_arg0 = (*C.GZlibCompressor)(unsafe.Pointer(c.Native()))

_cret = C.g_zlib_compressor_get_file_info(_arg0)


var _fileInfo FileInfo // out

_fileInfo = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FileInfo)

return _fileInfo
}
	
	// SetFileInfo sets @file_info in @compressor. If non-nil, and @compressor's
// Compressor:format property is G_ZLIB_COMPRESSOR_FORMAT_GZIP, it will be used
// to set the file name and modification time in the GZIP header of the
// compressed data.
// 
// Note: it is an error to call this function while a compression is in
// progress; it may only be called immediately after creation of @compressor, or
// after resetting it with g_converter_reset().
	func (c ZlibCompressor) SetFileInfo(fileInfo FileInfoClass)  {
var _arg0 *C.GZlibCompressor // out
var _arg1 *C.GFileInfo // out

_arg0 = (*C.GZlibCompressor)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFileInfo)(unsafe.Pointer(fileInfo.Native()))

C.g_zlib_compressor_set_file_info(_arg0, _arg1)
}
	


	// ZlibDecompressor: zlib decompression
	type ZlibDecompressor struct {
		**externglib.Object
		Converter
		
	}

	// ZlibDecompressorClass is an interface that the ZlibDecompressor class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ZlibDecompressorClass interface {
		gextras.Objector
		_zlibDecompressor()
	}

	func (ZlibDecompressor) _zlibDecompressor() {}

	
	func marshalZlibDecompressor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapZlibDecompressor(obj), nil
	}
	

	
	// NewZlibDecompressor creates a new Decompressor.
	func NewZlibDecompressor(format ZlibCompressorFormat) ZlibDecompressor {
var _arg1 C.GZlibCompressorFormat // out
var _cret *C.GZlibDecompressor // in

_arg1 = (C.GZlibCompressorFormat)(format)

_cret = C.g_zlib_decompressor_new(_arg1)


var _zlibDecompressor ZlibDecompressor // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_zlibDecompressor = ZlibDecompressor{
Object: &externglib.Object{externglib.ToGObject(obj)},
Converter: Converter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _zlibDecompressor
}
	

	
	// FileInfo retrieves the Info constructed from the GZIP header data of
// compressed data processed by @compressor, or nil if @decompressor's
// Decompressor:format property is not G_ZLIB_COMPRESSOR_FORMAT_GZIP, or the
// header data was not fully processed yet, or it not present in the data stream
// at all.
	func (d ZlibDecompressor) FileInfo() FileInfo {
var _arg0 *C.GZlibDecompressor // out
var _cret *C.GFileInfo // in

_arg0 = (*C.GZlibDecompressor)(unsafe.Pointer(d.Native()))

_cret = C.g_zlib_decompressor_get_file_info(_arg0)


var _fileInfo FileInfo // out

_fileInfo = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FileInfo)

return _fileInfo
}
	


	// DBusAnnotationInfo: information about an annotation.
	type DBusAnnotationInfo struct {
		Native C.GDBusAnnotationInfo
	}

	
	func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*DBusAnnotationInfo)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (d *DBusAnnotationInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	
	// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
	func (i *DBusAnnotationInfo) Ref() *DBusAnnotationInfo {
var _arg0 *C.GDBusAnnotationInfo // out
var _cret *C.GDBusAnnotationInfo // in

_arg0 = (*C.GDBusAnnotationInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_annotation_info_ref(_arg0)


var _dBusAnnotationInfo *DBusAnnotationInfo // out

_dBusAnnotationInfo = *(**DBusAnnotationInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_dBusAnnotationInfo, func(v *DBusAnnotationInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _dBusAnnotationInfo
}
	
	// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
	func (i *DBusAnnotationInfo) Unref()  {
var _arg0 *C.GDBusAnnotationInfo // out

_arg0 = (*C.GDBusAnnotationInfo)(unsafe.Pointer(i.Native()))

C.g_dbus_annotation_info_unref(_arg0)
}
	


	// DBusArgInfo: information about an argument for a method or a signal.
	type DBusArgInfo struct {
		Native C.GDBusArgInfo
	}

	
	func marshalDBusArgInfo(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*DBusArgInfo)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (d *DBusArgInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	
	// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
	func (i *DBusArgInfo) Ref() *DBusArgInfo {
var _arg0 *C.GDBusArgInfo // out
var _cret *C.GDBusArgInfo // in

_arg0 = (*C.GDBusArgInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_arg_info_ref(_arg0)


var _dBusArgInfo *DBusArgInfo // out

_dBusArgInfo = *(**DBusArgInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_dBusArgInfo, func(v *DBusArgInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _dBusArgInfo
}
	
	// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
	func (i *DBusArgInfo) Unref()  {
var _arg0 *C.GDBusArgInfo // out

_arg0 = (*C.GDBusArgInfo)(unsafe.Pointer(i.Native()))

C.g_dbus_arg_info_unref(_arg0)
}
	


	// DBusErrorEntry: struct used in g_dbus_error_register_error_domain().
	type DBusErrorEntry struct {
		Native C.GDBusErrorEntry
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (d *DBusErrorEntry) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	


	// DBusInterfaceInfo: information about a D-Bus interface.
	type DBusInterfaceInfo struct {
		Native C.GDBusInterfaceInfo
	}

	
	func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*DBusInterfaceInfo)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (d *DBusInterfaceInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	
	// CacheBuild builds a lookup-cache to speed up
// g_dbus_interface_info_lookup_method(), g_dbus_interface_info_lookup_signal()
// and g_dbus_interface_info_lookup_property().
// 
// If this has already been called with @info, the existing cache is used and
// its use count is increased.
// 
// Note that @info cannot be modified until
// g_dbus_interface_info_cache_release() is called.
	func (i *DBusInterfaceInfo) CacheBuild()  {
var _arg0 *C.GDBusInterfaceInfo // out

_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

C.g_dbus_interface_info_cache_build(_arg0)
}
	
	// CacheRelease decrements the usage count for the cache for @info built by
// g_dbus_interface_info_cache_build() (if any) and frees the resources used by
// the cache if the usage count drops to zero.
	func (i *DBusInterfaceInfo) CacheRelease()  {
var _arg0 *C.GDBusInterfaceInfo // out

_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

C.g_dbus_interface_info_cache_release(_arg0)
}
	
	// LookupMethod looks up information about a method.
// 
// The cost of this function is O(n) in number of methods unless
// g_dbus_interface_info_cache_build() has been used on @info.
	func (i *DBusInterfaceInfo) LookupMethod(name string) *DBusMethodInfo {
var _arg0 *C.GDBusInterfaceInfo // out
var _arg1 *C.gchar // out
var _cret *C.GDBusMethodInfo // in

_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_interface_info_lookup_method(_arg0, _arg1)


var _dBusMethodInfo *DBusMethodInfo // out

_dBusMethodInfo = *(**DBusMethodInfo)(unsafe.Pointer(&_cret))

return _dBusMethodInfo
}
	
	// LookupProperty looks up information about a property.
// 
// The cost of this function is O(n) in number of properties unless
// g_dbus_interface_info_cache_build() has been used on @info.
	func (i *DBusInterfaceInfo) LookupProperty(name string) *DBusPropertyInfo {
var _arg0 *C.GDBusInterfaceInfo // out
var _arg1 *C.gchar // out
var _cret *C.GDBusPropertyInfo // in

_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_interface_info_lookup_property(_arg0, _arg1)


var _dBusPropertyInfo *DBusPropertyInfo // out

_dBusPropertyInfo = *(**DBusPropertyInfo)(unsafe.Pointer(&_cret))

return _dBusPropertyInfo
}
	
	// LookupSignal looks up information about a signal.
// 
// The cost of this function is O(n) in number of signals unless
// g_dbus_interface_info_cache_build() has been used on @info.
	func (i *DBusInterfaceInfo) LookupSignal(name string) *DBusSignalInfo {
var _arg0 *C.GDBusInterfaceInfo // out
var _arg1 *C.gchar // out
var _cret *C.GDBusSignalInfo // in

_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_interface_info_lookup_signal(_arg0, _arg1)


var _dBusSignalInfo *DBusSignalInfo // out

_dBusSignalInfo = *(**DBusSignalInfo)(unsafe.Pointer(&_cret))

return _dBusSignalInfo
}
	
	// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
	func (i *DBusInterfaceInfo) Ref() *DBusInterfaceInfo {
var _arg0 *C.GDBusInterfaceInfo // out
var _cret *C.GDBusInterfaceInfo // in

_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_interface_info_ref(_arg0)


var _dBusInterfaceInfo *DBusInterfaceInfo // out

_dBusInterfaceInfo = *(**DBusInterfaceInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_dBusInterfaceInfo, func(v *DBusInterfaceInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _dBusInterfaceInfo
}
	
	// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
	func (i *DBusInterfaceInfo) Unref()  {
var _arg0 *C.GDBusInterfaceInfo // out

_arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

C.g_dbus_interface_info_unref(_arg0)
}
	


	// DBusInterfaceVTable: virtual table for handling properties and method calls
// for a D-Bus interface.
// 
// Since 2.38, if you want to handle getting/setting D-Bus properties
// asynchronously, give nil as your get_property() or set_property() function.
// The D-Bus call will be directed to your @method_call function, with the
// provided @interface_name set to "org.freedesktop.DBus.Properties".
// 
// Ownership of the BusMethodInvocation object passed to the method_call()
// function is transferred to your handler; you must call one of the methods of
// BusMethodInvocation to return a reply (possibly empty), or an error. These
// functions also take ownership of the passed-in invocation object, so unless
// the invocation object has otherwise been referenced, it will be then be
// freed. Calling one of these functions may be done within your method_call()
// implementation but it also can be done at a later point to handle the method
// asynchronously.
// 
// The usual checks on the validity of the calls is performed. For `Get` calls,
// an error is automatically returned if the property does not exist or the
// permissions do not allow access. The same checks are performed for `Set`
// calls, and the provided value is also checked for being the correct type.
// 
// For both `Get` and `Set` calls, the BusMethodInvocation passed to the
// @method_call handler can be queried with
// g_dbus_method_invocation_get_property_info() to get a pointer to the
// BusPropertyInfo of the property.
// 
// If you have readable properties specified in your interface info, you must
// ensure that you either provide a non-nil @get_property() function or provide
// implementations of both the `Get` and `GetAll` methods on
// org.freedesktop.DBus.Properties interface in your @method_call function. Note
// that the required return type of the `Get` call is `(v)`, not the type of the
// property. `GetAll` expects a return value of type `a{sv}`.
// 
// If you have writable properties specified in your interface info, you must
// ensure that you either provide a non-nil @set_property() function or provide
// an implementation of the `Set` call. If implementing the call, you must
// return the value of type G_VARIANT_TYPE_UNIT.
	type DBusInterfaceVTable struct {
		Native C.GDBusInterfaceVTable
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (d *DBusInterfaceVTable) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	


	// DBusMethodInfo: information about a method on an D-Bus interface.
	type DBusMethodInfo struct {
		Native C.GDBusMethodInfo
	}

	
	func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*DBusMethodInfo)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (d *DBusMethodInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	
	// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
	func (i *DBusMethodInfo) Ref() *DBusMethodInfo {
var _arg0 *C.GDBusMethodInfo // out
var _cret *C.GDBusMethodInfo // in

_arg0 = (*C.GDBusMethodInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_method_info_ref(_arg0)


var _dBusMethodInfo *DBusMethodInfo // out

_dBusMethodInfo = *(**DBusMethodInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_dBusMethodInfo, func(v *DBusMethodInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _dBusMethodInfo
}
	
	// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
	func (i *DBusMethodInfo) Unref()  {
var _arg0 *C.GDBusMethodInfo // out

_arg0 = (*C.GDBusMethodInfo)(unsafe.Pointer(i.Native()))

C.g_dbus_method_info_unref(_arg0)
}
	


	// DBusNodeInfo: information about nodes in a remote object hierarchy.
	type DBusNodeInfo struct {
		Native C.GDBusNodeInfo
	}

	
	func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*DBusNodeInfo)(unsafe.Pointer(b))
	}
	

	
	
	// NewDBusNodeInfoForXML constructs a struct DBusNodeInfo.
	func NewDBusNodeInfoForXML(xmlData string) (*DBusNodeInfo, error) {
var _arg1 *C.gchar // out
var _cret *C.GDBusNodeInfo // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(xmlData))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_node_info_new_for_xml(_arg1, &_cerr)


var _dBusNodeInfo *DBusNodeInfo // out
var _goerr error // out

_dBusNodeInfo = *(**DBusNodeInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_dBusNodeInfo, func(v *DBusNodeInfo) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _dBusNodeInfo, _goerr
}
	
	

	

	// Native returns the underlying C source pointer.
	func (d *DBusNodeInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	
	// LookupInterface looks up information about an interface.
// 
// The cost of this function is O(n) in number of interfaces.
	func (i *DBusNodeInfo) LookupInterface(name string) *DBusInterfaceInfo {
var _arg0 *C.GDBusNodeInfo // out
var _arg1 *C.gchar // out
var _cret *C.GDBusInterfaceInfo // in

_arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_dbus_node_info_lookup_interface(_arg0, _arg1)


var _dBusInterfaceInfo *DBusInterfaceInfo // out

_dBusInterfaceInfo = *(**DBusInterfaceInfo)(unsafe.Pointer(&_cret))

return _dBusInterfaceInfo
}
	
	// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
	func (i *DBusNodeInfo) Ref() *DBusNodeInfo {
var _arg0 *C.GDBusNodeInfo // out
var _cret *C.GDBusNodeInfo // in

_arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_node_info_ref(_arg0)


var _dBusNodeInfo *DBusNodeInfo // out

_dBusNodeInfo = *(**DBusNodeInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_dBusNodeInfo, func(v *DBusNodeInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _dBusNodeInfo
}
	
	// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
	func (i *DBusNodeInfo) Unref()  {
var _arg0 *C.GDBusNodeInfo // out

_arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))

C.g_dbus_node_info_unref(_arg0)
}
	


	// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
	type DBusPropertyInfo struct {
		Native C.GDBusPropertyInfo
	}

	
	func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*DBusPropertyInfo)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (d *DBusPropertyInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	
	// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
	func (i *DBusPropertyInfo) Ref() *DBusPropertyInfo {
var _arg0 *C.GDBusPropertyInfo // out
var _cret *C.GDBusPropertyInfo // in

_arg0 = (*C.GDBusPropertyInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_property_info_ref(_arg0)


var _dBusPropertyInfo *DBusPropertyInfo // out

_dBusPropertyInfo = *(**DBusPropertyInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_dBusPropertyInfo, func(v *DBusPropertyInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _dBusPropertyInfo
}
	
	// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
	func (i *DBusPropertyInfo) Unref()  {
var _arg0 *C.GDBusPropertyInfo // out

_arg0 = (*C.GDBusPropertyInfo)(unsafe.Pointer(i.Native()))

C.g_dbus_property_info_unref(_arg0)
}
	


	// DBusSignalInfo: information about a signal on a D-Bus interface.
	type DBusSignalInfo struct {
		Native C.GDBusSignalInfo
	}

	
	func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*DBusSignalInfo)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (d *DBusSignalInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	
	// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
	func (i *DBusSignalInfo) Ref() *DBusSignalInfo {
var _arg0 *C.GDBusSignalInfo // out
var _cret *C.GDBusSignalInfo // in

_arg0 = (*C.GDBusSignalInfo)(unsafe.Pointer(i.Native()))

_cret = C.g_dbus_signal_info_ref(_arg0)


var _dBusSignalInfo *DBusSignalInfo // out

_dBusSignalInfo = *(**DBusSignalInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_dBusSignalInfo, func(v *DBusSignalInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _dBusSignalInfo
}
	
	// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
	func (i *DBusSignalInfo) Unref()  {
var _arg0 *C.GDBusSignalInfo // out

_arg0 = (*C.GDBusSignalInfo)(unsafe.Pointer(i.Native()))

C.g_dbus_signal_info_unref(_arg0)
}
	


	// DBusSubtreeVTable: virtual table for handling subtrees registered with
// g_dbus_connection_register_subtree().
	type DBusSubtreeVTable struct {
		Native C.GDBusSubtreeVTable
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (d *DBusSubtreeVTable) Native() uintptr {
		return uintptr(unsafe.Pointer(&d.Native))
	}

	

	


	// FileAttributeInfo: information about a specific attribute.
	type FileAttributeInfo struct {
		Native C.GFileAttributeInfo
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (f *FileAttributeInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&f.Native))
	}

	

	


	// FileAttributeInfoList acts as a lightweight registry for possible valid file
// attributes. The registry stores Key-Value pair formats as AttributeInfos.
	type FileAttributeInfoList struct {
		Native C.GFileAttributeInfoList
	}

	
	func marshalFileAttributeInfoList(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*FileAttributeInfoList)(unsafe.Pointer(b))
	}
	

	
	
	// NewFileAttributeInfoList constructs a struct FileAttributeInfoList.
	func NewFileAttributeInfoList() *FileAttributeInfoList {
var _cret *C.GFileAttributeInfoList // in

_cret = C.g_file_attribute_info_list_new()


var _fileAttributeInfoList *FileAttributeInfoList // out

_fileAttributeInfoList = *(**FileAttributeInfoList)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
  C.free(unsafe.Pointer(v.Native()))
})

return _fileAttributeInfoList
}
	
	

	

	// Native returns the underlying C source pointer.
	func (f *FileAttributeInfoList) Native() uintptr {
		return uintptr(unsafe.Pointer(&f.Native))
	}

	

	
	// Add adds a new attribute with @name to the @list, setting its @type and
// @flags.
	func (l *FileAttributeInfoList) Add(name string, typ FileAttributeType, flags FileAttributeInfoFlags)  {
var _arg0 *C.GFileAttributeInfoList // out
var _arg1 *C.char // out
var _arg2 C.GFileAttributeType // out
var _arg3 C.GFileAttributeInfoFlags // out

_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GFileAttributeType)(typ)
_arg3 = (C.GFileAttributeInfoFlags)(flags)

C.g_file_attribute_info_list_add(_arg0, _arg1, _arg2, _arg3)
}
	
	// Dup makes a duplicate of a file attribute info list.
	func (l *FileAttributeInfoList) Dup() *FileAttributeInfoList {
var _arg0 *C.GFileAttributeInfoList // out
var _cret *C.GFileAttributeInfoList // in

_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))

_cret = C.g_file_attribute_info_list_dup(_arg0)


var _fileAttributeInfoList *FileAttributeInfoList // out

_fileAttributeInfoList = *(**FileAttributeInfoList)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
  C.free(unsafe.Pointer(v.Native()))
})

return _fileAttributeInfoList
}
	
	// Lookup gets the file attribute with the name @name from @list.
	func (l *FileAttributeInfoList) Lookup(name string) *FileAttributeInfo {
var _arg0 *C.GFileAttributeInfoList // out
var _arg1 *C.char // out
var _cret *C.GFileAttributeInfo // in

_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_attribute_info_list_lookup(_arg0, _arg1)


var _fileAttributeInfo *FileAttributeInfo // out

_fileAttributeInfo = *(**FileAttributeInfo)(unsafe.Pointer(&_cret))

return _fileAttributeInfo
}
	
	// Ref references a file attribute info list.
	func (l *FileAttributeInfoList) Ref() *FileAttributeInfoList {
var _arg0 *C.GFileAttributeInfoList // out
var _cret *C.GFileAttributeInfoList // in

_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))

_cret = C.g_file_attribute_info_list_ref(_arg0)


var _fileAttributeInfoList *FileAttributeInfoList // out

_fileAttributeInfoList = *(**FileAttributeInfoList)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fileAttributeInfoList, func(v *FileAttributeInfoList) {
  C.free(unsafe.Pointer(v.Native()))
})

return _fileAttributeInfoList
}
	
	// Unref removes a reference from the given @list. If the reference count falls
// to zero, the @list is deleted.
	func (l *FileAttributeInfoList) Unref()  {
var _arg0 *C.GFileAttributeInfoList // out

_arg0 = (*C.GFileAttributeInfoList)(unsafe.Pointer(l.Native()))

C.g_file_attribute_info_list_unref(_arg0)
}
	


	// FileAttributeMatcher determines if a string matches a file attribute.
	type FileAttributeMatcher struct {
		Native C.GFileAttributeMatcher
	}

	
	func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*FileAttributeMatcher)(unsafe.Pointer(b))
	}
	

	
	
	// NewFileAttributeMatcher constructs a struct FileAttributeMatcher.
	func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher {
var _arg1 *C.char // out
var _cret *C.GFileAttributeMatcher // in

_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_attribute_matcher_new(_arg1)


var _fileAttributeMatcher *FileAttributeMatcher // out

_fileAttributeMatcher = *(**FileAttributeMatcher)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fileAttributeMatcher, func(v *FileAttributeMatcher) {
  C.free(unsafe.Pointer(v.Native()))
})

return _fileAttributeMatcher
}
	
	

	

	// Native returns the underlying C source pointer.
	func (f *FileAttributeMatcher) Native() uintptr {
		return uintptr(unsafe.Pointer(&f.Native))
	}

	

	
	// EnumerateNamespace checks if the matcher will match all of the keys in a
// given namespace. This will always return true if a wildcard character is in
// use (e.g. if matcher was created with "standard::*" and @ns is "standard", or
// if matcher was created using "*" and namespace is anything.)
// 
// TODO: this is awkwardly worded.
	func (m *FileAttributeMatcher) EnumerateNamespace(ns string) bool {
var _arg0 *C.GFileAttributeMatcher // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(ns))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_attribute_matcher_enumerate_namespace(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EnumerateNext gets the next matched attribute from a AttributeMatcher.
	func (m *FileAttributeMatcher) EnumerateNext() string {
var _arg0 *C.GFileAttributeMatcher // out
var _cret *C.char // in

_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))

_cret = C.g_file_attribute_matcher_enumerate_next(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Matches checks if an attribute will be matched by an attribute matcher. If
// the matcher was created with the "*" matching string, this function will
// always return true.
	func (m *FileAttributeMatcher) Matches(attribute string) bool {
var _arg0 *C.GFileAttributeMatcher // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_attribute_matcher_matches(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MatchesOnly checks if a attribute matcher only matches a given attribute.
// Always returns false if "*" was used when creating the matcher.
	func (m *FileAttributeMatcher) MatchesOnly(attribute string) bool {
var _arg0 *C.GFileAttributeMatcher // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_file_attribute_matcher_matches_only(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Ref references a file attribute matcher.
	func (m *FileAttributeMatcher) Ref() *FileAttributeMatcher {
var _arg0 *C.GFileAttributeMatcher // out
var _cret *C.GFileAttributeMatcher // in

_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))

_cret = C.g_file_attribute_matcher_ref(_arg0)


var _fileAttributeMatcher *FileAttributeMatcher // out

_fileAttributeMatcher = *(**FileAttributeMatcher)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fileAttributeMatcher, func(v *FileAttributeMatcher) {
  C.free(unsafe.Pointer(v.Native()))
})

return _fileAttributeMatcher
}
	
	// Subtract subtracts all attributes of @subtract from @matcher and returns a
// matcher that supports those attributes.
// 
// Note that currently it is not possible to remove a single attribute when the
// @matcher matches the whole namespace - or remove a namespace or attribute
// when the matcher matches everything. This is a limitation of the current
// implementation, but may be fixed in the future.
	func (m *FileAttributeMatcher) Subtract(subtract *FileAttributeMatcher) *FileAttributeMatcher {
var _arg0 *C.GFileAttributeMatcher // out
var _arg1 *C.GFileAttributeMatcher // out
var _cret *C.GFileAttributeMatcher // in

_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GFileAttributeMatcher)(unsafe.Pointer(subtract.Native()))

_cret = C.g_file_attribute_matcher_subtract(_arg0, _arg1)


var _fileAttributeMatcher *FileAttributeMatcher // out

_fileAttributeMatcher = *(**FileAttributeMatcher)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fileAttributeMatcher, func(v *FileAttributeMatcher) {
  C.free(unsafe.Pointer(v.Native()))
})

return _fileAttributeMatcher
}
	
	// String prints what the matcher is matching against. The format will be equal
// to the format passed to g_file_attribute_matcher_new(). The output however,
// might not be identical, as the matcher may decide to use a different order or
// omit needless parts.
	func (m *FileAttributeMatcher) String() string {
var _arg0 *C.GFileAttributeMatcher // out
var _cret *C.char // in

_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))

_cret = C.g_file_attribute_matcher_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Unref unreferences @matcher. If the reference count falls below 1, the
// @matcher is automatically freed.
	func (m *FileAttributeMatcher) Unref()  {
var _arg0 *C.GFileAttributeMatcher // out

_arg0 = (*C.GFileAttributeMatcher)(unsafe.Pointer(m.Native()))

C.g_file_attribute_matcher_unref(_arg0)
}
	


	// IOExtension is an opaque data structure and can only be accessed using the
// following functions.
	type IOExtension struct {
		Native C.GIOExtension
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (i *IOExtension) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	
	// Name gets the name under which @extension was registered.
// 
// Note that the same type may be registered as extension for multiple extension
// points, under different names.
	func (e *IOExtension) Name() string {
var _arg0 *C.GIOExtension // out
var _cret *C.char // in

_arg0 = (*C.GIOExtension)(unsafe.Pointer(e.Native()))

_cret = C.g_io_extension_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Priority gets the priority with which @extension was registered.
	func (e *IOExtension) Priority() int {
var _arg0 *C.GIOExtension // out
var _cret C.gint // in

_arg0 = (*C.GIOExtension)(unsafe.Pointer(e.Native()))

_cret = C.g_io_extension_get_priority(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Type gets the type associated with @extension.
	func (e *IOExtension) Type() externglib.Type {
var _arg0 *C.GIOExtension // out
var _cret C.GType // in

_arg0 = (*C.GIOExtension)(unsafe.Pointer(e.Native()))

_cret = C.g_io_extension_get_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	


	// IOExtensionPoint is an opaque data structure and can only be accessed using
// the following functions.
	type IOExtensionPoint struct {
		Native C.GIOExtensionPoint
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (i *IOExtensionPoint) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	
	// ExtensionByName finds a OExtension for an extension point by name.
	func (e *IOExtensionPoint) ExtensionByName(name string) *IOExtension {
var _arg0 *C.GIOExtensionPoint // out
var _arg1 *C.char // out
var _cret *C.GIOExtension // in

_arg0 = (*C.GIOExtensionPoint)(unsafe.Pointer(e.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_io_extension_point_get_extension_by_name(_arg0, _arg1)


var _ioExtension *IOExtension // out

_ioExtension = *(**IOExtension)(unsafe.Pointer(&_cret))

return _ioExtension
}
	
	// RequiredType gets the required type for @extension_point.
	func (e *IOExtensionPoint) RequiredType() externglib.Type {
var _arg0 *C.GIOExtensionPoint // out
var _cret C.GType // in

_arg0 = (*C.GIOExtensionPoint)(unsafe.Pointer(e.Native()))

_cret = C.g_io_extension_point_get_required_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// SetRequiredType sets the required type for @extension_point to @type. All
// implementations must henceforth have this type.
	func (e *IOExtensionPoint) SetRequiredType(typ externglib.Type)  {
var _arg0 *C.GIOExtensionPoint // out
var _arg1 C.GType // out

_arg0 = (*C.GIOExtensionPoint)(unsafe.Pointer(e.Native()))
_arg1 = C.GType(typ)

C.g_io_extension_point_set_required_type(_arg0, _arg1)
}
	


	// IOModuleScope represents a scope for loading IO modules. A scope can be used
// for blocking duplicate modules, or blocking a module you don't want to load.
// 
// The scope can be used with g_io_modules_load_all_in_directory_with_scope() or
// g_io_modules_scan_all_in_directory_with_scope().
	type IOModuleScope struct {
		Native C.GIOModuleScope
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (i *IOModuleScope) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	
	// Block: block modules with the given @basename from being loaded when this
// scope is used with g_io_modules_scan_all_in_directory_with_scope() or
// g_io_modules_load_all_in_directory_with_scope().
	func (s *IOModuleScope) Block(basename string)  {
var _arg0 *C.GIOModuleScope // out
var _arg1 *C.gchar // out

_arg0 = (*C.GIOModuleScope)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(basename))
defer C.free(unsafe.Pointer(_arg1))

C.g_io_module_scope_block(_arg0, _arg1)
}
	
	// Free: free a module scope.
	func (s *IOModuleScope) Free()  {
var _arg0 *C.GIOModuleScope // out

_arg0 = (*C.GIOModuleScope)(unsafe.Pointer(s.Native()))

C.g_io_module_scope_free(_arg0)
}
	


	// IOSchedulerJob: opaque class for defining and scheduling IO jobs.
	type IOSchedulerJob struct {
		Native C.GIOSchedulerJob
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (i *IOSchedulerJob) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	


	
	type IOStreamAdapter struct {
		Native C.GIOStreamAdapter
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (i *IOStreamAdapter) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	


	// InputMessage: structure used for scatter/gather data input when receiving
// multiple messages or packets in one go. You generally pass in an array of
// empty Vectors and the operation will use all the buffers as if they were one
// buffer, and will set @bytes_received to the total number of bytes received
// across all Vectors.
// 
// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from the
// POSIX sockets API (see `man 2 recvmmsg`).
// 
// If @address is non-nil then it is set to the source address the message was
// received from, and the caller must free it afterwards.
// 
// If @control_messages is non-nil then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. @num_control_messages is set to the number of elements in this
// array, which may be zero.
// 
// Flags relevant to this message will be returned in @flags. For example,
// `MSG_EOR` or `MSG_TRUNC`.
	type InputMessage struct {
		Native C.GInputMessage
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (i *InputMessage) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	


	// InputVector: structure used for scatter/gather data input. You generally pass
// in an array of Vectors and the operation will store the read data starting in
// the first buffer, switching to the next as needed.
	type InputVector struct {
		Native C.GInputVector
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (i *InputVector) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	


	// OutputMessage: structure used for scatter/gather data output when sending
// multiple messages or packets in one go. You generally pass in an array of
// Vectors and the operation will use all the buffers as if they were one
// buffer.
// 
// If @address is nil then the message is sent to the default receiver (as
// previously set by g_socket_connect()).
	type OutputMessage struct {
		Native C.GOutputMessage
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (o *OutputMessage) Native() uintptr {
		return uintptr(unsafe.Pointer(&o.Native))
	}

	

	


	// OutputVector: structure used for scatter/gather data output. You generally
// pass in an array of Vectors and the operation will use all the buffers as if
// they were one buffer.
	type OutputVector struct {
		Native C.GOutputVector
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (o *OutputVector) Native() uintptr {
		return uintptr(unsafe.Pointer(&o.Native))
	}

	

	


	// Resource applications and libraries often contain binary or textual data that
// is really part of the application, rather than user data. For instance
// Builder .ui files, splashscreen images, GMenu markup XML, CSS files, icons,
// etc. These are often shipped as files in `$datadir/appname`, or manually
// included as literal strings in the code.
// 
// The #GResource API and the [glib-compile-resources][glib-compile-resources]
// program provide a convenient and efficient alternative to this which has some
// nice properties. You maintain the files as normal files, so its easy to edit
// them, but during the build the files are combined into a binary bundle that
// is linked into the executable. This means that loading the resource files are
// efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in
// the filesystem). It also makes it easier to create relocatable applications.
// 
// Resource files can also be marked as compressed. Such files will be included
// in the resource bundle in a compressed form, but will be automatically
// uncompressed when the resource is used. This is very useful e.g. for larger
// text files that are parsed once (or rarely) and then thrown away.
// 
// Resource files can also be marked to be preprocessed, by setting the value of
// the `preprocess` attribute to a comma-separated list of preprocessing
// options. The only options currently supported are:
// 
// `xml-stripblanks` which will use the xmllint command to strip ignorable
// whitespace from the XML file. For this to work, the `XMLLINT` environment
// variable must be set to the full path to the xmllint executable, or xmllint
// must be in the `PATH`; otherwise the preprocessing step is skipped.
// 
// `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
// `gdk-pixbuf-pixdata` command to convert images to the Pixdata format, which
// allows you to create pixbufs directly using the data inside the resource
// file, rather than an (uncompressed) copy of it. For this, the
// `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
// `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
// `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will abort.
// `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as #GResource
// supports embedding modern image formats just as well. Instead of using it,
// embed a PNG or SVG file in your #GResource.
// 
// `json-stripblanks` which will use the `json-glib-format` command to strip
// ignorable whitespace from the JSON file. For this to work, the
// `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
// `json-glib-format` executable, or it must be in the `PATH`; otherwise the
// preprocessing step is skipped. In addition, at least version 1.6 of
// `json-glib-format` is required.
// 
// Resource files will be exported in the GResource namespace using the
// combination of the given `prefix` and the filename from the `file` element.
// The `alias` attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
// 
// Resource bundles are created by the
// [glib-compile-resources][glib-compile-resources] program which takes an XML
// file that describes the bundle, and a set of files that the XML references.
// These are combined into a binary resource bundle.
// 
// An example resource description:
// 
//    <?xml version="1.0" encoding="UTF-8"?>
//    <gresources>
//      <gresource prefix="/org/gtk/Example">
//        <file>data/splashscreen.png</file>
//        <file compressed="true">dialog.ui</file>
//        <file preprocess="xml-stripblanks">menumarkup.xml</file>
//        <file alias="example.css">data/example.css</file>
//      </gresource>
//    </gresources>
// 
// This will create a resource bundle with the following files:
// 
//    /org/gtk/Example/data/splashscreen.png
//    /org/gtk/Example/dialog.ui
//    /org/gtk/Example/menumarkup.xml
//    /org/gtk/Example/example.css
// 
// Note that all resources in the process share the same namespace, so use
// Java-style path prefixes (like in the above example) to avoid conflicts.
// 
// You can then use [glib-compile-resources][glib-compile-resources] to compile
// the XML to a binary bundle that you can load with g_resource_load(). However,
// its more common to use the --generate-source and --generate-header arguments
// to create a source file and header to link directly into your application.
// This will generate `get_resource()`, `register_resource()` and
// `unregister_resource()` functions, prefixed by the `--c-name` argument passed
// to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
// the generated #GResource object. The register and unregister functions
// register the resource so its files can be accessed using
// g_resources_lookup_data().
// 
// Once a #GResource has been created and registered all the data in it can be
// accessed globally in the process by using API calls like
// g_resources_open_stream() to stream the data or g_resources_lookup_data() to
// get a direct pointer to the data. You can also use URIs like
// "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access the
// resource data.
// 
// Some higher-level APIs, such as Application, will automatically load
// resources from certain well-known paths in the resource namespace as a
// convenience. See the documentation for those APIs for details.
// 
// There are two forms of the generated source, the default version uses the
// compiler support for constructor and destructor functions (where available)
// to automatically create and register the #GResource on startup or library
// load time. If you pass `--manual-register`, two functions to
// register/unregister the resource are created instead. This requires an
// explicit initialization call in your application/library, but it works on all
// platforms, even on the minor ones where constructors are not supported.
// (Constructor support is available for at least Win32, Mac OS and Linux.)
// 
// Note that resource data can point directly into the data segment of e.g. a
// library, so if you are unloading libraries during runtime you need to be very
// careful with keeping around pointers to data from a resource, as this goes
// away when the library is unloaded. However, in practice this is not generally
// a problem, since most resource accesses are for your own resources, and
// resource data is often used once, during parsing, and then released.
// 
// When debugging a program or testing a change to an installed version, it is
// often useful to be able to replace resources in the program or library,
// without recompiling, for debugging or quick hacking and testing purposes.
// Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment
// variable to selectively overlay resources with replacements from the
// filesystem. It is a G_SEARCHPATH_SEPARATOR-separated list of substitutions to
// perform during resource lookups. It is ignored when running in a setuid
// process.
// 
// A substitution has the form
// 
//    /org/gtk/libgtk=/home/desrt/gtk-overlay
// 
// The part before the `=` is the resource subpath for which the overlay
// applies. The part after is a filesystem path which contains files and
// subdirectories as you would like to be loaded as resources with the
// equivalent names.
// 
// In the example above, if an application tried to load a resource with the
// resource path `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check
// the filesystem path `/home/desrt/gtk-overlay/ui/gtkdialog.ui`. If a file was
// found there, it would be used instead. This is an overlay, not an outright
// replacement, which means that if a file is not found at that path, the
// built-in version will be used instead. Whiteouts are not currently supported.
// 
// Substitutions must start with a slash, and must not contain a trailing slash
// before the '='. The path after the slash should ideally be absolute, but this
// is not strictly required. It is possible to overlay the location of a single
// resource with an individual file.
	type Resource struct {
		Native C.GResource
	}

	
	func marshalResource(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*Resource)(unsafe.Pointer(b))
	}
	

	
	
	

	

	// Native returns the underlying C source pointer.
	func (r *Resource) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	
	// EnumerateChildren returns all the names of children at the specified @path in
// the resource. The return result is a nil terminated list of strings which
// should be released with g_strfreev().
// 
// If @path is invalid or does not exist in the #GResource,
// G_RESOURCE_ERROR_NOT_FOUND will be returned.
// 
// @lookup_flags controls the behaviour of the lookup.
	func (r *Resource) EnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
var _arg0 *C.GResource // out
var _arg1 *C.char // out
var _arg2 C.GResourceLookupFlags // out
var _cret **C.char
var _cerr *C.GError // in

_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))
_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GResourceLookupFlags)(lookupFlags)

_cret = C.g_resource_enumerate_children(_arg0, _arg1, _arg2, &_cerr)


var _utf8s []string
var _goerr error // out

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _utf8s, _goerr
}
	
	// Info looks for a file at the specified @path in the resource and if found
// returns information about it.
// 
// @lookup_flags controls the behaviour of the lookup.
	func (r *Resource) Info(path string, lookupFlags ResourceLookupFlags) (uint, uint32, error) {
var _arg0 *C.GResource // out
var _arg1 *C.char // out
var _arg2 C.GResourceLookupFlags // out
var _arg3 C.gsize // in
var _arg4 C.guint32 // in
var _cerr *C.GError // in

_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))
_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GResourceLookupFlags)(lookupFlags)

C.g_resource_get_info(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)

var _size uint // out
var _flags uint32 // out
var _goerr error // out

_size = (uint)(_arg3)
_flags = (uint32)(_arg4)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _size, _flags, _goerr
}
	
	// OpenStream looks for a file at the specified @path in the resource and
// returns a Stream that lets you read the data.
// 
// @lookup_flags controls the behaviour of the lookup.
	func (r *Resource) OpenStream(path string, lookupFlags ResourceLookupFlags) (InputStream, error) {
var _arg0 *C.GResource // out
var _arg1 *C.char // out
var _arg2 C.GResourceLookupFlags // out
var _cret *C.GInputStream // in
var _cerr *C.GError // in

_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))
_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GResourceLookupFlags)(lookupFlags)

_cret = C.g_resource_open_stream(_arg0, _arg1, _arg2, &_cerr)


var _inputStream InputStream // out
var _goerr error // out

_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(InputStream)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _inputStream, _goerr
}
	
	// Ref: atomically increments the reference count of @resource by one. This
// function is MT-safe and may be called from any thread.
	func (r *Resource) Ref() *Resource {
var _arg0 *C.GResource // out
var _cret *C.GResource // in

_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))

_cret = C.g_resource_ref(_arg0)


var _ret *Resource // out

_ret = *(**Resource)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_ret, func(v *Resource) {
  C.free(unsafe.Pointer(v.Native()))
})

return _ret
}
	
	// Unref: atomically decrements the reference count of @resource by one. If the
// reference count drops to 0, all memory allocated by the resource is released.
// This function is MT-safe and may be called from any thread.
	func (r *Resource) Unref()  {
var _arg0 *C.GResource // out

_arg0 = (*C.GResource)(unsafe.Pointer(r.Native()))

C.g_resource_unref(_arg0)
}
	


	// SettingsSchema: the SchemaSource and Schema APIs provide a mechanism for
// advanced control over the loading of schemas and a mechanism for
// introspecting their content.
// 
// Plugin loading systems that wish to provide plugins a way to access settings
// face the problem of how to make the schemas for these settings visible to
// GSettings. Typically, a plugin will want to ship the schema along with itself
// and it won't be installed into the standard system directories for schemas.
// 
// SchemaSource provides a mechanism for dealing with this by allowing the
// creation of a new 'schema source' from which schemas can be acquired. This
// schema source can then become part of the metadata associated with the plugin
// and queried whenever the plugin requires access to some settings.
// 
// Consider the following example:
// 
//    {
//      GSettings *settings;
//      gint some_value;
// 
//      settings = plugin_get_settings (self, NULL);
//      some_value = g_settings_get_int (settings, "some-value");
//      ...
//    }
// 
// It's also possible that the plugin system expects the schema source files
// (ie: .gschema.xml files) instead of a gschemas.compiled file. In that case,
// the plugin loading system must compile the schemas for itself before
// attempting to create the settings source.
	type SettingsSchema struct {
		Native C.GSettingsSchema
	}

	
	func marshalSettingsSchema(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*SettingsSchema)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (s *SettingsSchema) Native() uintptr {
		return uintptr(unsafe.Pointer(&s.Native))
	}

	

	
	// ID: get the ID of @schema.
	func (s *SettingsSchema) ID() string {
var _arg0 *C.GSettingsSchema // out
var _cret *C.gchar // in

_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

_cret = C.g_settings_schema_get_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Key gets the key named @name from @schema.
// 
// It is a programmer error to request a key that does not exist. See
// g_settings_schema_list_keys().
	func (s *SettingsSchema) Key(name string) *SettingsSchemaKey {
var _arg0 *C.GSettingsSchema // out
var _arg1 *C.gchar // out
var _cret *C.GSettingsSchemaKey // in

_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_schema_get_key(_arg0, _arg1)


var _settingsSchemaKey *SettingsSchemaKey // out

_settingsSchemaKey = *(**SettingsSchemaKey)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_settingsSchemaKey, func(v *SettingsSchemaKey) {
  C.free(unsafe.Pointer(v.Native()))
})

return _settingsSchemaKey
}
	
	// Path gets the path associated with @schema, or nil.
// 
// Schemas may be single-instance or relocatable. Single-instance schemas
// correspond to exactly one set of keys in the backend database: those located
// at the path returned by this function.
// 
// Relocatable schemas can be referenced by other schemas and can therefore
// describe multiple sets of keys at different locations. For relocatable
// schemas, this function will return nil.
	func (s *SettingsSchema) Path() string {
var _arg0 *C.GSettingsSchema // out
var _cret *C.gchar // in

_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

_cret = C.g_settings_schema_get_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// HasKey checks if @schema has a key named @name.
	func (s *SettingsSchema) HasKey(name string) bool {
var _arg0 *C.GSettingsSchema // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.g_settings_schema_has_key(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ListChildren gets the list of children in @schema.
// 
// You should free the return value with g_strfreev() when you are done with it.
	func (s *SettingsSchema) ListChildren() []string {
var _arg0 *C.GSettingsSchema // out
var _cret **C.gchar

_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

_cret = C.g_settings_schema_list_children(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// ListKeys introspects the list of keys on @schema.
// 
// You should probably not be calling this function from "normal" code (since
// you should already know what keys are in your schema). This function is
// intended for introspection reasons.
	func (s *SettingsSchema) ListKeys() []string {
var _arg0 *C.GSettingsSchema // out
var _cret **C.gchar

_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

_cret = C.g_settings_schema_list_keys(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// Ref: increase the reference count of @schema, returning a new reference.
	func (s *SettingsSchema) Ref() *SettingsSchema {
var _arg0 *C.GSettingsSchema // out
var _cret *C.GSettingsSchema // in

_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

_cret = C.g_settings_schema_ref(_arg0)


var _settingsSchema *SettingsSchema // out

_settingsSchema = *(**SettingsSchema)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_settingsSchema, func(v *SettingsSchema) {
  C.free(unsafe.Pointer(v.Native()))
})

return _settingsSchema
}
	
	// Unref: decrease the reference count of @schema, possibly freeing it.
	func (s *SettingsSchema) Unref()  {
var _arg0 *C.GSettingsSchema // out

_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

C.g_settings_schema_unref(_arg0)
}
	


	// SettingsSchemaKey is an opaque data structure and can only be accessed using
// the following functions.
	type SettingsSchemaKey struct {
		Native C.GSettingsSchemaKey
	}

	
	func marshalSettingsSchemaKey(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*SettingsSchemaKey)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (s *SettingsSchemaKey) Native() uintptr {
		return uintptr(unsafe.Pointer(&s.Native))
	}

	

	
	// DefaultValue gets the default value for @key.
// 
// Note that this is the default value according to the schema. System
// administrator defaults and lockdown are not visible via this API.
	func (k *SettingsSchemaKey) DefaultValue() *glib.Variant {
var _arg0 *C.GSettingsSchemaKey // out
var _cret *C.GVariant // in

_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

_cret = C.g_settings_schema_key_get_default_value(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// Description gets the description for @key.
// 
// If no description has been provided in the schema for @key, returns nil.
// 
// The description can be one sentence to several paragraphs in length.
// Paragraphs are delimited with a double newline. Descriptions can be
// translated and the value returned from this function is is the current
// locale.
// 
// This function is slow. The summary and description information for the
// schemas is not stored in the compiled schema database so this function has to
// parse all of the source XML files in the schema directory.
	func (k *SettingsSchemaKey) Description() string {
var _arg0 *C.GSettingsSchemaKey // out
var _cret *C.gchar // in

_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

_cret = C.g_settings_schema_key_get_description(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Name gets the name of @key.
	func (k *SettingsSchemaKey) Name() string {
var _arg0 *C.GSettingsSchemaKey // out
var _cret *C.gchar // in

_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

_cret = C.g_settings_schema_key_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Range queries the range of a key.
// 
// This function will return a #GVariant that fully describes the range of
// values that are valid for @key.
// 
// The type of #GVariant returned is `(sv)`. The string describes the type of
// range restriction in effect. The type and meaning of the value contained in
// the variant depends on the string.
// 
// If the string is `'type'` then the variant contains an empty array. The
// element type of that empty array is the expected type of value and all values
// of that type are valid.
// 
// If the string is `'enum'` then the variant contains an array enumerating the
// possible values. Each item in the array is a possible valid value and no
// other values are valid.
// 
// If the string is `'flags'` then the variant contains an array. Each item in
// the array is a value that may appear zero or one times in an array to be used
// as the value for this key. For example, if the variant contained the array
// `['x', 'y']` then the valid values for the key would be `[]`, `['x']`,
// `['y']`, `['x', 'y']` and `['y', 'x']`.
// 
// Finally, if the string is `'range'` then the variant contains a pair of
// like-typed values -- the minimum and maximum permissible values for this key.
// 
// This information should not be used by normal programs. It is considered to
// be a hint for introspection purposes. Normal programs should already know
// what is permitted by their own schema. The format may change in any way in
// the future -- but particularly, new forms may be added to the possibilities
// described above.
// 
// You should free the returned value with g_variant_unref() when it is no
// longer needed.
	func (k *SettingsSchemaKey) Range() *glib.Variant {
var _arg0 *C.GSettingsSchemaKey // out
var _cret *C.GVariant // in

_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

_cret = C.g_settings_schema_key_get_range(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_variant, func(v *glib.Variant) {
  C.free(unsafe.Pointer(v.Native()))
})

return _variant
}
	
	// Summary gets the summary for @key.
// 
// If no summary has been provided in the schema for @key, returns nil.
// 
// The summary is a short description of the purpose of the key; usually one
// short sentence. Summaries can be translated and the value returned from this
// function is is the current locale.
// 
// This function is slow. The summary and description information for the
// schemas is not stored in the compiled schema database so this function has to
// parse all of the source XML files in the schema directory.
	func (k *SettingsSchemaKey) Summary() string {
var _arg0 *C.GSettingsSchemaKey // out
var _cret *C.gchar // in

_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

_cret = C.g_settings_schema_key_get_summary(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ValueType gets the Type of @key.
	func (k *SettingsSchemaKey) ValueType() *glib.VariantType {
var _arg0 *C.GSettingsSchemaKey // out
var _cret *C.GVariantType // in

_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

_cret = C.g_settings_schema_key_get_value_type(_arg0)


var _variantType *glib.VariantType // out

_variantType = *(**glib.VariantType)(unsafe.Pointer(&_cret))

return _variantType
}
	
	// RangeCheck checks if the given @value is of the correct type and within the
// permitted range for @key.
// 
// It is a programmer error if @value is not of the correct type -- you must
// check for this first.
	func (k *SettingsSchemaKey) RangeCheck(value *glib.Variant) bool {
var _arg0 *C.GSettingsSchemaKey // out
var _arg1 *C.GVariant // out
var _cret C.gboolean // in

_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

_cret = C.g_settings_schema_key_range_check(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Ref: increase the reference count of @key, returning a new reference.
	func (k *SettingsSchemaKey) Ref() *SettingsSchemaKey {
var _arg0 *C.GSettingsSchemaKey // out
var _cret *C.GSettingsSchemaKey // in

_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

_cret = C.g_settings_schema_key_ref(_arg0)


var _settingsSchemaKey *SettingsSchemaKey // out

_settingsSchemaKey = *(**SettingsSchemaKey)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_settingsSchemaKey, func(v *SettingsSchemaKey) {
  C.free(unsafe.Pointer(v.Native()))
})

return _settingsSchemaKey
}
	
	// Unref: decrease the reference count of @key, possibly freeing it.
	func (k *SettingsSchemaKey) Unref()  {
var _arg0 *C.GSettingsSchemaKey // out

_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

C.g_settings_schema_key_unref(_arg0)
}
	


	// SettingsSchemaSource: this is an opaque structure type. You may not access it
// directly.
	type SettingsSchemaSource struct {
		Native C.GSettingsSchemaSource
	}

	
	func marshalSettingsSchemaSource(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*SettingsSchemaSource)(unsafe.Pointer(b))
	}
	

	
	
	// NewSettingsSchemaSourceFromDirectory constructs a struct SettingsSchemaSource.
	func NewSettingsSchemaSourceFromDirectory(directory string, parent *SettingsSchemaSource, trusted bool) (*SettingsSchemaSource, error) {
var _arg1 *C.gchar // out
var _arg2 *C.GSettingsSchemaSource // out
var _arg3 C.gboolean // out
var _cret *C.GSettingsSchemaSource // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(directory))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GSettingsSchemaSource)(unsafe.Pointer(parent.Native()))
if trusted { _arg3 = C.TRUE }

_cret = C.g_settings_schema_source_new_from_directory(_arg1, _arg2, _arg3, &_cerr)


var _settingsSchemaSource *SettingsSchemaSource // out
var _goerr error // out

_settingsSchemaSource = *(**SettingsSchemaSource)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_settingsSchemaSource, func(v *SettingsSchemaSource) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _settingsSchemaSource, _goerr
}
	
	

	

	// Native returns the underlying C source pointer.
	func (s *SettingsSchemaSource) Native() uintptr {
		return uintptr(unsafe.Pointer(&s.Native))
	}

	

	
	// ListSchemas lists the schemas in a given source.
// 
// If @recursive is true then include parent sources. If false then only include
// the schemas from one source (ie: one directory). You probably want true.
// 
// Non-relocatable schemas are those for which you can call g_settings_new().
// Relocatable schemas are those for which you must use
// g_settings_new_with_path().
// 
// Do not call this function from normal programs. This is designed for use by
// database editors, commandline tools, etc.
	func (s *SettingsSchemaSource) ListSchemas(recursive bool) (nonRelocatable []string, relocatable []string) {
var _arg0 *C.GSettingsSchemaSource // out
var _arg1 C.gboolean // out
var _arg2 **C.gchar
var _arg3 **C.gchar

_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))
if recursive { _arg1 = C.TRUE }

C.g_settings_schema_source_list_schemas(_arg0, _arg1, &_arg2, &_arg3)

var _nonRelocatable []string
var _relocatable []string

{
var i int
var z *C.gchar
for p := _arg2; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_arg2, i)
_nonRelocatable = make([]string, i)
for i := range src {
_nonRelocatable[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}
{
var i int
var z *C.gchar
for p := _arg3; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_arg3, i)
_relocatable = make([]string, i)
for i := range src {
_relocatable[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _nonRelocatable, _relocatable
}
	
	// Lookup looks up a schema with the identifier @schema_id in @source.
// 
// This function is not required for normal uses of #GSettings but it may be
// useful to authors of plugin management systems or to those who want to
// introspect the content of schemas.
// 
// If the schema isn't found directly in @source and @recursive is true then the
// parent sources will also be checked.
// 
// If the schema isn't found, nil is returned.
	func (s *SettingsSchemaSource) Lookup(schemaId string, recursive bool) *SettingsSchema {
var _arg0 *C.GSettingsSchemaSource // out
var _arg1 *C.gchar // out
var _arg2 C.gboolean // out
var _cret *C.GSettingsSchema // in

_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(schemaId))
defer C.free(unsafe.Pointer(_arg1))
if recursive { _arg2 = C.TRUE }

_cret = C.g_settings_schema_source_lookup(_arg0, _arg1, _arg2)


var _settingsSchema *SettingsSchema // out

_settingsSchema = *(**SettingsSchema)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_settingsSchema, func(v *SettingsSchema) {
  C.free(unsafe.Pointer(v.Native()))
})

return _settingsSchema
}
	
	// Ref: increase the reference count of @source, returning a new reference.
	func (s *SettingsSchemaSource) Ref() *SettingsSchemaSource {
var _arg0 *C.GSettingsSchemaSource // out
var _cret *C.GSettingsSchemaSource // in

_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))

_cret = C.g_settings_schema_source_ref(_arg0)


var _settingsSchemaSource *SettingsSchemaSource // out

_settingsSchemaSource = *(**SettingsSchemaSource)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_settingsSchemaSource, func(v *SettingsSchemaSource) {
  C.free(unsafe.Pointer(v.Native()))
})

return _settingsSchemaSource
}
	
	// Unref: decrease the reference count of @source, possibly freeing it.
	func (s *SettingsSchemaSource) Unref()  {
var _arg0 *C.GSettingsSchemaSource // out

_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))

C.g_settings_schema_source_unref(_arg0)
}
	


	// SrvTarget: SRV (service) records are used by some network protocols to
// provide service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain; rather than
// connecting directly to "example.com" or assuming a specific server hostname
// like "xmpp.example.com", an XMPP client would look up the "xmpp-client" SRV
// record for "example.com", and then connect to whatever host was pointed to by
// that record.
// 
// You can use g_resolver_lookup_service() or g_resolver_lookup_service_async()
// to find the Targets for a given service. However, if you are simply planning
// to connect to the remote service, you can use Service's Connectable interface
// and not need to worry about Target at all.
	type SrvTarget struct {
		Native C.GSrvTarget
	}

	
	func marshalSrvTarget(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*SrvTarget)(unsafe.Pointer(b))
	}
	

	
	
	// NewSrvTarget constructs a struct SrvTarget.
	func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget {
var _arg1 *C.gchar // out
var _arg2 C.guint16 // out
var _arg3 C.guint16 // out
var _arg4 C.guint16 // out
var _cret *C.GSrvTarget // in

_arg1 = (*C.gchar)(C.CString(hostname))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint16)(port)
_arg3 = (C.guint16)(priority)
_arg4 = (C.guint16)(weight)

_cret = C.g_srv_target_new(_arg1, _arg2, _arg3, _arg4)


var _srvTarget *SrvTarget // out

_srvTarget = *(**SrvTarget)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_srvTarget, func(v *SrvTarget) {
  C.free(unsafe.Pointer(v.Native()))
})

return _srvTarget
}
	
	

	

	// Native returns the underlying C source pointer.
	func (s *SrvTarget) Native() uintptr {
		return uintptr(unsafe.Pointer(&s.Native))
	}

	

	
	// Copy copies @target
	func (t *SrvTarget) Copy() *SrvTarget {
var _arg0 *C.GSrvTarget // out
var _cret *C.GSrvTarget // in

_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

_cret = C.g_srv_target_copy(_arg0)


var _srvTarget *SrvTarget // out

_srvTarget = *(**SrvTarget)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_srvTarget, func(v *SrvTarget) {
  C.free(unsafe.Pointer(v.Native()))
})

return _srvTarget
}
	
	// Free frees @target
	func (t *SrvTarget) Free()  {
var _arg0 *C.GSrvTarget // out

_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

C.g_srv_target_free(_arg0)
}
	
	// Hostname gets @target's hostname (in ASCII form; if you are going to present
// this to the user, you should use g_hostname_is_ascii_encoded() to check if it
// contains encoded Unicode segments, and use g_hostname_to_unicode() to convert
// it if it does.)
	func (t *SrvTarget) Hostname() string {
var _arg0 *C.GSrvTarget // out
var _cret *C.gchar // in

_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

_cret = C.g_srv_target_get_hostname(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Port gets @target's port
	func (t *SrvTarget) Port() uint16 {
var _arg0 *C.GSrvTarget // out
var _cret C.guint16 // in

_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

_cret = C.g_srv_target_get_port(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// Priority gets @target's priority. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in RFC 2782.
	func (t *SrvTarget) Priority() uint16 {
var _arg0 *C.GSrvTarget // out
var _cret C.guint16 // in

_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

_cret = C.g_srv_target_get_priority(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// Weight gets @target's weight. You should not need to look at this; #GResolver
// already sorts the targets according to the algorithm in RFC 2782.
	func (t *SrvTarget) Weight() uint16 {
var _arg0 *C.GSrvTarget // out
var _cret C.guint16 // in

_arg0 = (*C.GSrvTarget)(unsafe.Pointer(t.Native()))

_cret = C.g_srv_target_get_weight(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	


	// StaticResource is an opaque data structure and can only be accessed using the
// following functions.
	type StaticResource struct {
		Native C.GStaticResource
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (s *StaticResource) Native() uintptr {
		return uintptr(unsafe.Pointer(&s.Native))
	}

	

	
	// Fini: finalized a GResource initialized by g_static_resource_init().
// 
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
	func (s *StaticResource) Fini()  {
var _arg0 *C.GStaticResource // out

_arg0 = (*C.GStaticResource)(unsafe.Pointer(s.Native()))

C.g_static_resource_fini(_arg0)
}
	
	// Resource gets the GResource that was registered by a call to
// g_static_resource_init().
// 
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
	func (s *StaticResource) Resource() *Resource {
var _arg0 *C.GStaticResource // out
var _cret *C.GResource // in

_arg0 = (*C.GStaticResource)(unsafe.Pointer(s.Native()))

_cret = C.g_static_resource_get_resource(_arg0)


var _resource *Resource // out

_resource = *(**Resource)(unsafe.Pointer(&_cret))

return _resource
}
	
	// Init initializes a GResource from static data using a GStaticResource.
// 
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
	func (s *StaticResource) Init()  {
var _arg0 *C.GStaticResource // out

_arg0 = (*C.GStaticResource)(unsafe.Pointer(s.Native()))

C.g_static_resource_init(_arg0)
}
	


	// UnixMountEntry defines a Unix mount entry (e.g.
// <filename>/media/cdrom</filename>). This corresponds roughly to a mtab entry.
	type UnixMountEntry struct {
		Native C.GUnixMountEntry
	}

	
	func marshalUnixMountEntry(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*UnixMountEntry)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (u *UnixMountEntry) Native() uintptr {
		return uintptr(unsafe.Pointer(&u.Native))
	}

	

	


	// UnixMountPoint defines a Unix mount point (e.g. <filename>/dev</filename>).
// This corresponds roughly to a fstab entry.
	type UnixMountPoint struct {
		Native C.GUnixMountPoint
	}

	
	func marshalUnixMountPoint(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*UnixMountPoint)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (u *UnixMountPoint) Native() uintptr {
		return uintptr(unsafe.Pointer(&u.Native))
	}

	

	
	// Compare compares two unix mount points.
	func (m *UnixMountPoint) Compare(mount2 *UnixMountPoint) int {
var _arg0 *C.GUnixMountPoint // out
var _arg1 *C.GUnixMountPoint // out
var _cret C.gint // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GUnixMountPoint)(unsafe.Pointer(mount2.Native()))

_cret = C.g_unix_mount_point_compare(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Copy makes a copy of @mount_point.
	func (m *UnixMountPoint) Copy() *UnixMountPoint {
var _arg0 *C.GUnixMountPoint // out
var _cret *C.GUnixMountPoint // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_copy(_arg0)


var _unixMountPoint *UnixMountPoint // out

_unixMountPoint = *(**UnixMountPoint)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_unixMountPoint, func(v *UnixMountPoint) {
  C.free(unsafe.Pointer(v.Native()))
})

return _unixMountPoint
}
	
	// Free frees a unix mount point.
	func (m *UnixMountPoint) Free()  {
var _arg0 *C.GUnixMountPoint // out

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

C.g_unix_mount_point_free(_arg0)
}
	
	// DevicePath gets the device path for a unix mount point.
	func (m *UnixMountPoint) DevicePath() string {
var _arg0 *C.GUnixMountPoint // out
var _cret *C.char // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_get_device_path(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// FSType gets the file system type for the mount point.
	func (m *UnixMountPoint) FSType() string {
var _arg0 *C.GUnixMountPoint // out
var _cret *C.char // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_get_fs_type(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// MountPath gets the mount path for a unix mount point.
	func (m *UnixMountPoint) MountPath() string {
var _arg0 *C.GUnixMountPoint // out
var _cret *C.char // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_get_mount_path(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// Options gets the options for the mount point.
	func (m *UnixMountPoint) Options() string {
var _arg0 *C.GUnixMountPoint // out
var _cret *C.char // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_get_options(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// GuessCanEject guesses whether a Unix mount point can be ejected.
	func (m *UnixMountPoint) GuessCanEject() bool {
var _arg0 *C.GUnixMountPoint // out
var _cret C.gboolean // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_guess_can_eject(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// GuessIcon guesses the icon of a Unix mount point.
	func (m *UnixMountPoint) GuessIcon() Icon {
var _arg0 *C.GUnixMountPoint // out
var _cret *C.GIcon // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_guess_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// GuessName guesses the name of a Unix mount point. The result is a translated
// string.
	func (m *UnixMountPoint) GuessName() string {
var _arg0 *C.GUnixMountPoint // out
var _cret *C.char // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_guess_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// GuessSymbolicIcon guesses the symbolic icon of a Unix mount point.
	func (m *UnixMountPoint) GuessSymbolicIcon() Icon {
var _arg0 *C.GUnixMountPoint // out
var _cret *C.GIcon // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_guess_symbolic_icon(_arg0)


var _icon Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Icon)

return _icon
}
	
	// IsLoopback checks if a unix mount point is a loopback device.
	func (m *UnixMountPoint) IsLoopback() bool {
var _arg0 *C.GUnixMountPoint // out
var _cret C.gboolean // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_is_loopback(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsReadonly checks if a unix mount point is read only.
	func (m *UnixMountPoint) IsReadonly() bool {
var _arg0 *C.GUnixMountPoint // out
var _cret C.gboolean // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_is_readonly(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsUserMountable checks if a unix mount point is mountable by the user.
	func (m *UnixMountPoint) IsUserMountable() bool {
var _arg0 *C.GUnixMountPoint // out
var _cret C.gboolean // in

_arg0 = (*C.GUnixMountPoint)(unsafe.Pointer(m.Native()))

_cret = C.g_unix_mount_point_is_user_mountable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
