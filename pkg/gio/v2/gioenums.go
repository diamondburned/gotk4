// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeDataStreamByteOrder     = coreglib.Type(C.g_data_stream_byte_order_get_type())
	GTypeDataStreamNewlineType   = coreglib.Type(C.g_data_stream_newline_type_get_type())
	GTypeFileAttributeStatus     = coreglib.Type(C.g_file_attribute_status_get_type())
	GTypeFileAttributeType       = coreglib.Type(C.g_file_attribute_type_get_type())
	GTypeFileMonitorEvent        = coreglib.Type(C.g_file_monitor_event_get_type())
	GTypeFileType                = coreglib.Type(C.g_file_type_get_type())
	GTypeFilesystemPreviewType   = coreglib.Type(C.g_filesystem_preview_type_get_type())
	GTypeIOErrorEnum             = coreglib.Type(C.g_io_error_enum_get_type())
	GTypeMountOperationResult    = coreglib.Type(C.g_mount_operation_result_get_type())
	GTypePasswordSave            = coreglib.Type(C.g_password_save_get_type())
	GTypeAppInfoCreateFlags      = coreglib.Type(C.g_app_info_create_flags_get_type())
	GTypeAskPasswordFlags        = coreglib.Type(C.g_ask_password_flags_get_type())
	GTypeFileAttributeInfoFlags  = coreglib.Type(C.g_file_attribute_info_flags_get_type())
	GTypeFileCopyFlags           = coreglib.Type(C.g_file_copy_flags_get_type())
	GTypeFileCreateFlags         = coreglib.Type(C.g_file_create_flags_get_type())
	GTypeFileMonitorFlags        = coreglib.Type(C.g_file_monitor_flags_get_type())
	GTypeFileQueryInfoFlags      = coreglib.Type(C.g_file_query_info_flags_get_type())
	GTypeMountMountFlags         = coreglib.Type(C.g_mount_mount_flags_get_type())
	GTypeMountUnmountFlags       = coreglib.Type(C.g_mount_unmount_flags_get_type())
	GTypeOutputStreamSpliceFlags = coreglib.Type(C.g_output_stream_splice_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDataStreamByteOrder, F: marshalDataStreamByteOrder},
		coreglib.TypeMarshaler{T: GTypeDataStreamNewlineType, F: marshalDataStreamNewlineType},
		coreglib.TypeMarshaler{T: GTypeFileAttributeStatus, F: marshalFileAttributeStatus},
		coreglib.TypeMarshaler{T: GTypeFileAttributeType, F: marshalFileAttributeType},
		coreglib.TypeMarshaler{T: GTypeFileMonitorEvent, F: marshalFileMonitorEvent},
		coreglib.TypeMarshaler{T: GTypeFileType, F: marshalFileType},
		coreglib.TypeMarshaler{T: GTypeFilesystemPreviewType, F: marshalFilesystemPreviewType},
		coreglib.TypeMarshaler{T: GTypeIOErrorEnum, F: marshalIOErrorEnum},
		coreglib.TypeMarshaler{T: GTypeMountOperationResult, F: marshalMountOperationResult},
		coreglib.TypeMarshaler{T: GTypePasswordSave, F: marshalPasswordSave},
		coreglib.TypeMarshaler{T: GTypeAppInfoCreateFlags, F: marshalAppInfoCreateFlags},
		coreglib.TypeMarshaler{T: GTypeAskPasswordFlags, F: marshalAskPasswordFlags},
		coreglib.TypeMarshaler{T: GTypeFileAttributeInfoFlags, F: marshalFileAttributeInfoFlags},
		coreglib.TypeMarshaler{T: GTypeFileCopyFlags, F: marshalFileCopyFlags},
		coreglib.TypeMarshaler{T: GTypeFileCreateFlags, F: marshalFileCreateFlags},
		coreglib.TypeMarshaler{T: GTypeFileMonitorFlags, F: marshalFileMonitorFlags},
		coreglib.TypeMarshaler{T: GTypeFileQueryInfoFlags, F: marshalFileQueryInfoFlags},
		coreglib.TypeMarshaler{T: GTypeMountMountFlags, F: marshalMountMountFlags},
		coreglib.TypeMarshaler{T: GTypeMountUnmountFlags, F: marshalMountUnmountFlags},
		coreglib.TypeMarshaler{T: GTypeOutputStreamSpliceFlags, F: marshalOutputStreamSpliceFlags},
	})
}

// DataStreamByteOrder is used to ensure proper endianness of streaming data
// sources across various machine architectures.
type DataStreamByteOrder C.gint

const (
	// DataStreamByteOrderBigEndian selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = iota
	// DataStreamByteOrderLittleEndian selects Little Endian byte order.
	DataStreamByteOrderLittleEndian
	// DataStreamByteOrderHostEndian selects endianness based on host machine's
	// architecture.
	DataStreamByteOrderHostEndian
)

func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
	return DataStreamByteOrder(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DataStreamByteOrder.
func (d DataStreamByteOrder) String() string {
	switch d {
	case DataStreamByteOrderBigEndian:
		return "BigEndian"
	case DataStreamByteOrderLittleEndian:
		return "LittleEndian"
	case DataStreamByteOrderHostEndian:
		return "HostEndian"
	default:
		return fmt.Sprintf("DataStreamByteOrder(%d)", d)
	}
}

// DataStreamNewlineType is used when checking for or setting the line endings
// for a given file.
type DataStreamNewlineType C.gint

const (
	// DataStreamNewlineTypeLf selects "LF" line endings, common on most modern
	// UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = iota
	// DataStreamNewlineTypeCr selects "CR" line endings.
	DataStreamNewlineTypeCr
	// DataStreamNewlineTypeCrLf selects "CR, LF" line ending, common on
	// Microsoft Windows.
	DataStreamNewlineTypeCrLf
	// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
	DataStreamNewlineTypeAny
)

func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
	return DataStreamNewlineType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DataStreamNewlineType.
func (d DataStreamNewlineType) String() string {
	switch d {
	case DataStreamNewlineTypeLf:
		return "Lf"
	case DataStreamNewlineTypeCr:
		return "Cr"
	case DataStreamNewlineTypeCrLf:
		return "CrLf"
	case DataStreamNewlineTypeAny:
		return "Any"
	default:
		return fmt.Sprintf("DataStreamNewlineType(%d)", d)
	}
}

// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
type FileAttributeStatus C.gint

const (
	// FileAttributeStatusUnset: attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = iota
	// FileAttributeStatusSet: attribute value is set.
	FileAttributeStatusSet
	// FileAttributeStatusErrorSetting indicates an error in setting the value.
	FileAttributeStatusErrorSetting
)

func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
	return FileAttributeStatus(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileAttributeStatus.
func (f FileAttributeStatus) String() string {
	switch f {
	case FileAttributeStatusUnset:
		return "Unset"
	case FileAttributeStatusSet:
		return "Set"
	case FileAttributeStatusErrorSetting:
		return "ErrorSetting"
	default:
		return fmt.Sprintf("FileAttributeStatus(%d)", f)
	}
}

// FileAttributeType: data types for file attributes.
type FileAttributeType C.gint

const (
	// FileAttributeTypeInvalid indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = iota
	// FileAttributeTypeString: null terminated UTF8 string.
	FileAttributeTypeString
	// FileAttributeTypeByteString: zero terminated string of non-zero bytes.
	FileAttributeTypeByteString
	// FileAttributeTypeBoolean: boolean value.
	FileAttributeTypeBoolean
	// FileAttributeTypeUint32: unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32
	// FileAttributeTypeInt32: signed 4-byte/32-bit integer.
	FileAttributeTypeInt32
	// FileAttributeTypeUint64: unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64
	// FileAttributeTypeInt64: signed 8-byte/64-bit integer.
	FileAttributeTypeInt64
	// FileAttributeTypeObject: #GObject.
	FileAttributeTypeObject
	// FileAttributeTypeStringv: NULL terminated char **. Since 2.22.
	FileAttributeTypeStringv
)

func marshalFileAttributeType(p uintptr) (interface{}, error) {
	return FileAttributeType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileAttributeType.
func (f FileAttributeType) String() string {
	switch f {
	case FileAttributeTypeInvalid:
		return "Invalid"
	case FileAttributeTypeString:
		return "String"
	case FileAttributeTypeByteString:
		return "ByteString"
	case FileAttributeTypeBoolean:
		return "Boolean"
	case FileAttributeTypeUint32:
		return "Uint32"
	case FileAttributeTypeInt32:
		return "Int32"
	case FileAttributeTypeUint64:
		return "Uint64"
	case FileAttributeTypeInt64:
		return "Int64"
	case FileAttributeTypeObject:
		return "Object"
	case FileAttributeTypeStringv:
		return "Stringv"
	default:
		return fmt.Sprintf("FileAttributeType(%d)", f)
	}
}

// FileMonitorEvent specifies what type of event a monitor event is.
type FileMonitorEvent C.gint

const (
	// FileMonitorEventChanged: file changed.
	FileMonitorEventChanged FileMonitorEvent = iota
	// FileMonitorEventChangesDoneHint: hint that this was probably the last
	// change in a set of changes.
	FileMonitorEventChangesDoneHint
	// FileMonitorEventDeleted: file was deleted.
	FileMonitorEventDeleted
	// FileMonitorEventCreated: file was created.
	FileMonitorEventCreated
	// FileMonitorEventAttributeChanged: file attribute was changed.
	FileMonitorEventAttributeChanged
	// FileMonitorEventPreUnmount: file location will soon be unmounted.
	FileMonitorEventPreUnmount
	// FileMonitorEventUnmounted: file location was unmounted.
	FileMonitorEventUnmounted
	// FileMonitorEventMoved: file was moved -- only sent if the (deprecated)
	// G_FILE_MONITOR_SEND_MOVED flag is set.
	FileMonitorEventMoved
	// FileMonitorEventRenamed: file was renamed within the current directory --
	// only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46.
	FileMonitorEventRenamed
	// FileMonitorEventMovedIn: file was moved into the monitored directory from
	// another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is
	// set. Since: 2.46.
	FileMonitorEventMovedIn
	// FileMonitorEventMovedOut: file was moved out of the monitored directory
	// to another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
	FileMonitorEventMovedOut
)

func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
	return FileMonitorEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileMonitorEvent.
func (f FileMonitorEvent) String() string {
	switch f {
	case FileMonitorEventChanged:
		return "Changed"
	case FileMonitorEventChangesDoneHint:
		return "ChangesDoneHint"
	case FileMonitorEventDeleted:
		return "Deleted"
	case FileMonitorEventCreated:
		return "Created"
	case FileMonitorEventAttributeChanged:
		return "AttributeChanged"
	case FileMonitorEventPreUnmount:
		return "PreUnmount"
	case FileMonitorEventUnmounted:
		return "Unmounted"
	case FileMonitorEventMoved:
		return "Moved"
	case FileMonitorEventRenamed:
		return "Renamed"
	case FileMonitorEventMovedIn:
		return "MovedIn"
	case FileMonitorEventMovedOut:
		return "MovedOut"
	default:
		return fmt.Sprintf("FileMonitorEvent(%d)", f)
	}
}

// FileType indicates the file's on-disk type.
//
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type; use
// Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a file is
// a symlink or not. This is due to the fact that NTFS does not have a single
// filesystem object type for symbolic links - it has files that symlink to
// files, and directories that symlink to directories. Type enumeration cannot
// precisely represent this important distinction, which is why all Windows
// symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
type FileType C.gint

const (
	// FileTypeUnknown file's type is unknown.
	FileTypeUnknown FileType = iota
	// FileTypeRegular: file handle represents a regular file.
	FileTypeRegular
	// FileTypeDirectory: file handle represents a directory.
	FileTypeDirectory
	// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
	FileTypeSymbolicLink
	// FileTypeSpecial: file is a "special" file, such as a socket, fifo, block
	// device, or character device.
	FileTypeSpecial
	// FileTypeShortcut: file is a shortcut (Windows systems).
	FileTypeShortcut
	// FileTypeMountable: file is a mountable location.
	FileTypeMountable
)

func marshalFileType(p uintptr) (interface{}, error) {
	return FileType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileType.
func (f FileType) String() string {
	switch f {
	case FileTypeUnknown:
		return "Unknown"
	case FileTypeRegular:
		return "Regular"
	case FileTypeDirectory:
		return "Directory"
	case FileTypeSymbolicLink:
		return "SymbolicLink"
	case FileTypeSpecial:
		return "Special"
	case FileTypeShortcut:
		return "Shortcut"
	case FileTypeMountable:
		return "Mountable"
	default:
		return fmt.Sprintf("FileType(%d)", f)
	}
}

// FilesystemPreviewType indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType C.gint

const (
	// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = iota
	// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
	FilesystemPreviewTypeIfLocal
	// FilesystemPreviewTypeNever: never preview files.
	FilesystemPreviewTypeNever
)

func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
	return FilesystemPreviewType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FilesystemPreviewType.
func (f FilesystemPreviewType) String() string {
	switch f {
	case FilesystemPreviewTypeIfAlways:
		return "IfAlways"
	case FilesystemPreviewTypeIfLocal:
		return "IfLocal"
	case FilesystemPreviewTypeNever:
		return "Never"
	default:
		return fmt.Sprintf("FilesystemPreviewType(%d)", f)
	}
}

// IOErrorEnum: error codes returned by GIO functions.
//
// Note that this domain may be extended in future GLib releases. In general,
// new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before. You
// should therefore avoid writing code like
//
//    if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
//      {
//        // Assume that this is EPRINTERONFIRE
//        ...
//      }
//
// but should instead treat all unrecognized error codes the same as
// IO_ERROR_FAILED.
//
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
type IOErrorEnum C.gint

const (
	// IOErrorFailed: generic error condition for when an operation fails and no
	// more specific OErrorEnum value is defined.
	IOErrorFailed IOErrorEnum = 0
	// IOErrorNotFound: file not found.
	IOErrorNotFound IOErrorEnum = 1
	// IOErrorExists: file already exists.
	IOErrorExists IOErrorEnum = 2
	// IOErrorIsDirectory: file is a directory.
	IOErrorIsDirectory IOErrorEnum = 3
	// IOErrorNotDirectory: file is not a directory.
	IOErrorNotDirectory IOErrorEnum = 4
	// IOErrorNotEmpty: file is a directory that isn't empty.
	IOErrorNotEmpty IOErrorEnum = 5
	// IOErrorNotRegularFile: file is not a regular file.
	IOErrorNotRegularFile IOErrorEnum = 6
	// IOErrorNotSymbolicLink: file is not a symbolic link.
	IOErrorNotSymbolicLink IOErrorEnum = 7
	// IOErrorNotMountableFile: file cannot be mounted.
	IOErrorNotMountableFile IOErrorEnum = 8
	// IOErrorFilenameTooLong: filename is too many characters.
	IOErrorFilenameTooLong IOErrorEnum = 9
	// IOErrorInvalidFilename: filename is invalid or contains invalid
	// characters.
	IOErrorInvalidFilename IOErrorEnum = 10
	// IOErrorTooManyLinks: file contains too many symbolic links.
	IOErrorTooManyLinks IOErrorEnum = 11
	// IOErrorNoSpace: no space left on drive.
	IOErrorNoSpace IOErrorEnum = 12
	// IOErrorInvalidArgument: invalid argument.
	IOErrorInvalidArgument IOErrorEnum = 13
	// IOErrorPermissionDenied: permission denied.
	IOErrorPermissionDenied IOErrorEnum = 14
	// IOErrorNotSupported: operation (or one of its parameters) not supported.
	IOErrorNotSupported IOErrorEnum = 15
	// IOErrorNotMounted: file isn't mounted.
	IOErrorNotMounted IOErrorEnum = 16
	// IOErrorAlreadyMounted: file is already mounted.
	IOErrorAlreadyMounted IOErrorEnum = 17
	// IOErrorClosed: file was closed.
	IOErrorClosed IOErrorEnum = 18
	// IOErrorCancelled: operation was cancelled. See #GCancellable.
	IOErrorCancelled IOErrorEnum = 19
	// IOErrorPending operations are still pending.
	IOErrorPending IOErrorEnum = 20
	// IOErrorReadOnly: file is read only.
	IOErrorReadOnly IOErrorEnum = 21
	// IOErrorCantCreateBackup: backup couldn't be created.
	IOErrorCantCreateBackup IOErrorEnum = 22
	// IOErrorWrongETag file's Entity Tag was incorrect.
	IOErrorWrongETag IOErrorEnum = 23
	// IOErrorTimedOut: operation timed out.
	IOErrorTimedOut IOErrorEnum = 24
	// IOErrorWouldRecurse: operation would be recursive.
	IOErrorWouldRecurse IOErrorEnum = 25
	// IOErrorBusy: file is busy.
	IOErrorBusy IOErrorEnum = 26
	// IOErrorWouldBlock: operation would block.
	IOErrorWouldBlock IOErrorEnum = 27
	// IOErrorHostNotFound: host couldn't be found (remote operations).
	IOErrorHostNotFound IOErrorEnum = 28
	// IOErrorWouldMerge: operation would merge files.
	IOErrorWouldMerge IOErrorEnum = 29
	// IOErrorFailedHandled: operation failed and a helper program has already
	// interacted with the user. Do not display any error dialog.
	IOErrorFailedHandled IOErrorEnum = 30
	// IOErrorTooManyOpenFiles: current process has too many files open and
	// can't open any more. Duplicate descriptors do count toward this limit.
	// Since 2.20.
	IOErrorTooManyOpenFiles IOErrorEnum = 31
	// IOErrorNotInitialized: object has not been initialized. Since 2.22.
	IOErrorNotInitialized IOErrorEnum = 32
	// IOErrorAddressInUse: requested address is already in use. Since 2.22.
	IOErrorAddressInUse IOErrorEnum = 33
	// IOErrorPartialInput: need more input to finish operation. Since 2.24.
	IOErrorPartialInput IOErrorEnum = 34
	// IOErrorInvalidData: input data was invalid. Since 2.24.
	IOErrorInvalidData IOErrorEnum = 35
	// IOErrorDBusError: remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
	IOErrorDBusError IOErrorEnum = 36
	// IOErrorHostUnreachable: host unreachable. Since 2.26.
	IOErrorHostUnreachable IOErrorEnum = 37
	// IOErrorNetworkUnreachable: network unreachable. Since 2.26.
	IOErrorNetworkUnreachable IOErrorEnum = 38
	// IOErrorConnectionRefused: connection refused. Since 2.26.
	IOErrorConnectionRefused IOErrorEnum = 39
	// IOErrorProxyFailed: connection to proxy server failed. Since 2.26.
	IOErrorProxyFailed IOErrorEnum = 40
	// IOErrorProxyAuthFailed: proxy authentication failed. Since 2.26.
	IOErrorProxyAuthFailed IOErrorEnum = 41
	// IOErrorProxyNeedAuth: proxy server needs authentication. Since 2.26.
	IOErrorProxyNeedAuth IOErrorEnum = 42
	// IOErrorProxyNotAllowed: proxy connection is not allowed by ruleset. Since
	// 2.26.
	IOErrorProxyNotAllowed IOErrorEnum = 43
	// IOErrorBrokenPipe: broken pipe. Since 2.36.
	IOErrorBrokenPipe IOErrorEnum = 44
	// IOErrorConnectionClosed: connection closed by peer. Note that this is the
	// same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection closed"
	// errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
	IOErrorConnectionClosed IOErrorEnum = 44
	// IOErrorNotConnected: transport endpoint is not connected. Since 2.44.
	IOErrorNotConnected IOErrorEnum = 45
	// IOErrorMessageTooLarge: message too large. Since 2.48.
	IOErrorMessageTooLarge IOErrorEnum = 46
)

func marshalIOErrorEnum(p uintptr) (interface{}, error) {
	return IOErrorEnum(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IOErrorEnum.
func (i IOErrorEnum) String() string {
	switch i {
	case IOErrorFailed:
		return "Failed"
	case IOErrorNotFound:
		return "NotFound"
	case IOErrorExists:
		return "Exists"
	case IOErrorIsDirectory:
		return "IsDirectory"
	case IOErrorNotDirectory:
		return "NotDirectory"
	case IOErrorNotEmpty:
		return "NotEmpty"
	case IOErrorNotRegularFile:
		return "NotRegularFile"
	case IOErrorNotSymbolicLink:
		return "NotSymbolicLink"
	case IOErrorNotMountableFile:
		return "NotMountableFile"
	case IOErrorFilenameTooLong:
		return "FilenameTooLong"
	case IOErrorInvalidFilename:
		return "InvalidFilename"
	case IOErrorTooManyLinks:
		return "TooManyLinks"
	case IOErrorNoSpace:
		return "NoSpace"
	case IOErrorInvalidArgument:
		return "InvalidArgument"
	case IOErrorPermissionDenied:
		return "PermissionDenied"
	case IOErrorNotSupported:
		return "NotSupported"
	case IOErrorNotMounted:
		return "NotMounted"
	case IOErrorAlreadyMounted:
		return "AlreadyMounted"
	case IOErrorClosed:
		return "Closed"
	case IOErrorCancelled:
		return "Cancelled"
	case IOErrorPending:
		return "Pending"
	case IOErrorReadOnly:
		return "ReadOnly"
	case IOErrorCantCreateBackup:
		return "CantCreateBackup"
	case IOErrorWrongETag:
		return "WrongETag"
	case IOErrorTimedOut:
		return "TimedOut"
	case IOErrorWouldRecurse:
		return "WouldRecurse"
	case IOErrorBusy:
		return "Busy"
	case IOErrorWouldBlock:
		return "WouldBlock"
	case IOErrorHostNotFound:
		return "HostNotFound"
	case IOErrorWouldMerge:
		return "WouldMerge"
	case IOErrorFailedHandled:
		return "FailedHandled"
	case IOErrorTooManyOpenFiles:
		return "TooManyOpenFiles"
	case IOErrorNotInitialized:
		return "NotInitialized"
	case IOErrorAddressInUse:
		return "AddressInUse"
	case IOErrorPartialInput:
		return "PartialInput"
	case IOErrorInvalidData:
		return "InvalidData"
	case IOErrorDBusError:
		return "DBusError"
	case IOErrorHostUnreachable:
		return "HostUnreachable"
	case IOErrorNetworkUnreachable:
		return "NetworkUnreachable"
	case IOErrorConnectionRefused:
		return "ConnectionRefused"
	case IOErrorProxyFailed:
		return "ProxyFailed"
	case IOErrorProxyAuthFailed:
		return "ProxyAuthFailed"
	case IOErrorProxyNeedAuth:
		return "ProxyNeedAuth"
	case IOErrorProxyNotAllowed:
		return "ProxyNotAllowed"
	case IOErrorBrokenPipe:
		return "BrokenPipe"
	case IOErrorNotConnected:
		return "NotConnected"
	case IOErrorMessageTooLarge:
		return "MessageTooLarge"
	default:
		return fmt.Sprintf("IOErrorEnum(%d)", i)
	}
}

// MountOperationResult is returned as a result when a request for information
// is send by the mounting operation.
type MountOperationResult C.gint

const (
	// MountOperationHandled: request was fulfilled and the user specified data
	// is now available.
	MountOperationHandled MountOperationResult = iota
	// MountOperationAborted: user requested the mount operation to be aborted.
	MountOperationAborted
	// MountOperationUnhandled: request was unhandled (i.e. not implemented).
	MountOperationUnhandled
)

func marshalMountOperationResult(p uintptr) (interface{}, error) {
	return MountOperationResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MountOperationResult.
func (m MountOperationResult) String() string {
	switch m {
	case MountOperationHandled:
		return "Handled"
	case MountOperationAborted:
		return "Aborted"
	case MountOperationUnhandled:
		return "Unhandled"
	default:
		return fmt.Sprintf("MountOperationResult(%d)", m)
	}
}

// PasswordSave is used to indicate the lifespan of a saved password.
//
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to, and
// later retrieves it again from there.
type PasswordSave C.gint

const (
	// PasswordSaveNever: never save a password.
	PasswordSaveNever PasswordSave = iota
	// PasswordSaveForSession: save a password for the session.
	PasswordSaveForSession
	// PasswordSavePermanently: save a password permanently.
	PasswordSavePermanently
)

func marshalPasswordSave(p uintptr) (interface{}, error) {
	return PasswordSave(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PasswordSave.
func (p PasswordSave) String() string {
	switch p {
	case PasswordSaveNever:
		return "Never"
	case PasswordSaveForSession:
		return "ForSession"
	case PasswordSavePermanently:
		return "Permanently"
	default:
		return fmt.Sprintf("PasswordSave(%d)", p)
	}
}

// AppInfoCreateFlags flags used when creating a Info.
type AppInfoCreateFlags C.guint

const (
	// AppInfoCreateNone: no flags.
	AppInfoCreateNone AppInfoCreateFlags = 0b0
	// AppInfoCreateNeedsTerminal: application opens in a terminal window.
	AppInfoCreateNeedsTerminal AppInfoCreateFlags = 0b1
	// AppInfoCreateSupportsURIs: application supports URI arguments.
	AppInfoCreateSupportsURIs AppInfoCreateFlags = 0b10
	// AppInfoCreateSupportsStartupNotification: application supports startup
	// notification. Since 2.26.
	AppInfoCreateSupportsStartupNotification AppInfoCreateFlags = 0b100
)

func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
	return AppInfoCreateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AppInfoCreateFlags.
func (a AppInfoCreateFlags) String() string {
	if a == 0 {
		return "AppInfoCreateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(111)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AppInfoCreateNone:
			builder.WriteString("None|")
		case AppInfoCreateNeedsTerminal:
			builder.WriteString("NeedsTerminal|")
		case AppInfoCreateSupportsURIs:
			builder.WriteString("SupportsURIs|")
		case AppInfoCreateSupportsStartupNotification:
			builder.WriteString("SupportsStartupNotification|")
		default:
			builder.WriteString(fmt.Sprintf("AppInfoCreateFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AppInfoCreateFlags) Has(other AppInfoCreateFlags) bool {
	return (a & other) == other
}

// AskPasswordFlags are used to request specific information from the user, or
// to notify the user of their choices in an authentication situation.
type AskPasswordFlags C.guint

const (
	// AskPasswordNeedPassword: operation requires a password.
	AskPasswordNeedPassword AskPasswordFlags = 0b1
	// AskPasswordNeedUsername: operation requires a username.
	AskPasswordNeedUsername AskPasswordFlags = 0b10
	// AskPasswordNeedDomain: operation requires a domain.
	AskPasswordNeedDomain AskPasswordFlags = 0b100
	// AskPasswordSavingSupported: operation supports saving settings.
	AskPasswordSavingSupported AskPasswordFlags = 0b1000
	// AskPasswordAnonymousSupported: operation supports anonymous users.
	AskPasswordAnonymousSupported AskPasswordFlags = 0b10000
	// AskPasswordTcrypt: operation takes TCRYPT parameters (Since: 2.58).
	AskPasswordTcrypt AskPasswordFlags = 0b100000
)

func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
	return AskPasswordFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AskPasswordFlags.
func (a AskPasswordFlags) String() string {
	if a == 0 {
		return "AskPasswordFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(144)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AskPasswordNeedPassword:
			builder.WriteString("NeedPassword|")
		case AskPasswordNeedUsername:
			builder.WriteString("NeedUsername|")
		case AskPasswordNeedDomain:
			builder.WriteString("NeedDomain|")
		case AskPasswordSavingSupported:
			builder.WriteString("SavingSupported|")
		case AskPasswordAnonymousSupported:
			builder.WriteString("AnonymousSupported|")
		case AskPasswordTcrypt:
			builder.WriteString("Tcrypt|")
		default:
			builder.WriteString(fmt.Sprintf("AskPasswordFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AskPasswordFlags) Has(other AskPasswordFlags) bool {
	return (a & other) == other
}

// FileAttributeInfoFlags flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags C.guint

const (
	// FileAttributeInfoNone: no flags set.
	FileAttributeInfoNone FileAttributeInfoFlags = 0b0
	// FileAttributeInfoCopyWithFile: copy the attribute values when the file is
	// copied.
	FileAttributeInfoCopyWithFile FileAttributeInfoFlags = 0b1
	// FileAttributeInfoCopyWhenMoved: copy the attribute values when the file
	// is moved.
	FileAttributeInfoCopyWhenMoved FileAttributeInfoFlags = 0b10
)

func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
	return FileAttributeInfoFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileAttributeInfoFlags.
func (f FileAttributeInfoFlags) String() string {
	if f == 0 {
		return "FileAttributeInfoFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileAttributeInfoNone:
			builder.WriteString("None|")
		case FileAttributeInfoCopyWithFile:
			builder.WriteString("CopyWithFile|")
		case FileAttributeInfoCopyWhenMoved:
			builder.WriteString("CopyWhenMoved|")
		default:
			builder.WriteString(fmt.Sprintf("FileAttributeInfoFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileAttributeInfoFlags) Has(other FileAttributeInfoFlags) bool {
	return (f & other) == other
}

// FileCopyFlags flags used when copying or moving files.
type FileCopyFlags C.guint

const (
	// FileCopyNone: no flags set.
	FileCopyNone FileCopyFlags = 0b0
	// FileCopyOverwrite: overwrite any existing files.
	FileCopyOverwrite FileCopyFlags = 0b1
	// FileCopyBackup: make a backup of any existing files.
	FileCopyBackup FileCopyFlags = 0b10
	// FileCopyNofollowSymlinks: don't follow symlinks.
	FileCopyNofollowSymlinks FileCopyFlags = 0b100
	// FileCopyAllMetadata: copy all file metadata instead of just default set
	// used for copy (see Info).
	FileCopyAllMetadata FileCopyFlags = 0b1000
	// FileCopyNoFallbackForMove: don't use copy and delete fallback if native
	// move not supported.
	FileCopyNoFallbackForMove FileCopyFlags = 0b10000
	// FileCopyTargetDefaultPerms leaves target file with default perms, instead
	// of setting the source file perms.
	FileCopyTargetDefaultPerms FileCopyFlags = 0b100000
)

func marshalFileCopyFlags(p uintptr) (interface{}, error) {
	return FileCopyFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileCopyFlags.
func (f FileCopyFlags) String() string {
	if f == 0 {
		return "FileCopyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(143)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileCopyNone:
			builder.WriteString("None|")
		case FileCopyOverwrite:
			builder.WriteString("Overwrite|")
		case FileCopyBackup:
			builder.WriteString("Backup|")
		case FileCopyNofollowSymlinks:
			builder.WriteString("NofollowSymlinks|")
		case FileCopyAllMetadata:
			builder.WriteString("AllMetadata|")
		case FileCopyNoFallbackForMove:
			builder.WriteString("NoFallbackForMove|")
		case FileCopyTargetDefaultPerms:
			builder.WriteString("TargetDefaultPerms|")
		default:
			builder.WriteString(fmt.Sprintf("FileCopyFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileCopyFlags) Has(other FileCopyFlags) bool {
	return (f & other) == other
}

// FileCreateFlags flags used when an operation may create a file.
type FileCreateFlags C.guint

const (
	// FileCreateNone: no flags set.
	FileCreateNone FileCreateFlags = 0b0
	// FileCreatePrivate: create a file that can only be accessed by the current
	// user.
	FileCreatePrivate FileCreateFlags = 0b1
	// FileCreateReplaceDestination: replace the destination as if it didn't
	// exist before. Don't try to keep any old permissions, replace instead of
	// following links. This is generally useful if you're doing a "copy over"
	// rather than a "save new version of" replace operation. You can think of
	// it as "unlink destination" before writing to it, although the
	// implementation may not be exactly like that. This flag can only be used
	// with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20.
	FileCreateReplaceDestination FileCreateFlags = 0b10
)

func marshalFileCreateFlags(p uintptr) (interface{}, error) {
	return FileCreateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileCreateFlags.
func (f FileCreateFlags) String() string {
	if f == 0 {
		return "FileCreateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(61)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileCreateNone:
			builder.WriteString("None|")
		case FileCreatePrivate:
			builder.WriteString("Private|")
		case FileCreateReplaceDestination:
			builder.WriteString("ReplaceDestination|")
		default:
			builder.WriteString(fmt.Sprintf("FileCreateFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileCreateFlags) Has(other FileCreateFlags) bool {
	return (f & other) == other
}

// FileMonitorFlags flags used to set what a Monitor will watch for.
type FileMonitorFlags C.guint

const (
	// FileMonitorNone: no flags set.
	FileMonitorNone FileMonitorFlags = 0b0
	// FileMonitorWatchMounts: watch for mount events.
	FileMonitorWatchMounts FileMonitorFlags = 0b1
	// FileMonitorSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorSendMoved FileMonitorFlags = 0b10
	// FileMonitorWatchHardLinks: watch for changes to the file made via another
	// hard link. Since 2.36.
	FileMonitorWatchHardLinks FileMonitorFlags = 0b100
	// FileMonitorWatchMoves: watch for rename operations on a monitored
	// directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
	FileMonitorWatchMoves FileMonitorFlags = 0b1000
)

func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
	return FileMonitorFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileMonitorFlags.
func (f FileMonitorFlags) String() string {
	if f == 0 {
		return "FileMonitorFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(107)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileMonitorNone:
			builder.WriteString("None|")
		case FileMonitorWatchMounts:
			builder.WriteString("WatchMounts|")
		case FileMonitorSendMoved:
			builder.WriteString("SendMoved|")
		case FileMonitorWatchHardLinks:
			builder.WriteString("WatchHardLinks|")
		case FileMonitorWatchMoves:
			builder.WriteString("WatchMoves|")
		default:
			builder.WriteString(fmt.Sprintf("FileMonitorFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileMonitorFlags) Has(other FileMonitorFlags) bool {
	return (f & other) == other
}

// FileQueryInfoFlags flags used when querying a Info.
type FileQueryInfoFlags C.guint

const (
	// FileQueryInfoNone: no flags set.
	FileQueryInfoNone FileQueryInfoFlags = 0b0
	// FileQueryInfoNofollowSymlinks: don't follow symlinks.
	FileQueryInfoNofollowSymlinks FileQueryInfoFlags = 0b1
)

func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
	return FileQueryInfoFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileQueryInfoFlags.
func (f FileQueryInfoFlags) String() string {
	if f == 0 {
		return "FileQueryInfoFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(47)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileQueryInfoNone:
			builder.WriteString("None|")
		case FileQueryInfoNofollowSymlinks:
			builder.WriteString("NofollowSymlinks|")
		default:
			builder.WriteString(fmt.Sprintf("FileQueryInfoFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileQueryInfoFlags) Has(other FileQueryInfoFlags) bool {
	return (f & other) == other
}

// MountMountFlags flags used when mounting a mount.
type MountMountFlags C.guint

const (
	// MountMountNone: no flags set.
	MountMountNone MountMountFlags = 0b0
)

func marshalMountMountFlags(p uintptr) (interface{}, error) {
	return MountMountFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MountMountFlags.
func (m MountMountFlags) String() string {
	if m == 0 {
		return "MountMountFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(14)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MountMountNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("MountMountFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MountMountFlags) Has(other MountMountFlags) bool {
	return (m & other) == other
}

// MountUnmountFlags flags used when an unmounting a mount.
type MountUnmountFlags C.guint

const (
	// MountUnmountNone: no flags set.
	MountUnmountNone MountUnmountFlags = 0b0
	// MountUnmountForce: unmount even if there are outstanding file operations
	// on the mount.
	MountUnmountForce MountUnmountFlags = 0b1
)

func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
	return MountUnmountFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MountUnmountFlags.
func (m MountUnmountFlags) String() string {
	if m == 0 {
		return "MountUnmountFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(34)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MountUnmountNone:
			builder.WriteString("None|")
		case MountUnmountForce:
			builder.WriteString("Force|")
		default:
			builder.WriteString(fmt.Sprintf("MountUnmountFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MountUnmountFlags) Has(other MountUnmountFlags) bool {
	return (m & other) == other
}

// OutputStreamSpliceFlags determine how streams should be spliced.
type OutputStreamSpliceFlags C.guint

const (
	// OutputStreamSpliceNone: do not close either stream.
	OutputStreamSpliceNone OutputStreamSpliceFlags = 0b0
	// OutputStreamSpliceCloseSource: close the source stream after the splice.
	OutputStreamSpliceCloseSource OutputStreamSpliceFlags = 0b1
	// OutputStreamSpliceCloseTarget: close the target stream after the splice.
	OutputStreamSpliceCloseTarget OutputStreamSpliceFlags = 0b10
)

func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
	return OutputStreamSpliceFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for OutputStreamSpliceFlags.
func (o OutputStreamSpliceFlags) String() string {
	if o == 0 {
		return "OutputStreamSpliceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for o != 0 {
		next := o & (o - 1)
		bit := o - next

		switch bit {
		case OutputStreamSpliceNone:
			builder.WriteString("None|")
		case OutputStreamSpliceCloseSource:
			builder.WriteString("CloseSource|")
		case OutputStreamSpliceCloseTarget:
			builder.WriteString("CloseTarget|")
		default:
			builder.WriteString(fmt.Sprintf("OutputStreamSpliceFlags(0b%b)|", bit))
		}

		o = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if o contains other.
func (o OutputStreamSpliceFlags) Has(other OutputStreamSpliceFlags) bool {
	return (o & other) == other
}
