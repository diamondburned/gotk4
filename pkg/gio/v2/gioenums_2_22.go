// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeDriveStartStopType = coreglib.Type(C.g_drive_start_stop_type_get_type())
	GTypeResolverError      = coreglib.Type(C.g_resolver_error_get_type())
	GTypeSocketFamily       = coreglib.Type(C.g_socket_family_get_type())
	GTypeSocketProtocol     = coreglib.Type(C.g_socket_protocol_get_type())
	GTypeSocketType         = coreglib.Type(C.g_socket_type_get_type())
	GTypeDriveStartFlags    = coreglib.Type(C.g_drive_start_flags_get_type())
	GTypeSocketMsgFlags     = coreglib.Type(C.g_socket_msg_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDriveStartStopType, F: marshalDriveStartStopType},
		coreglib.TypeMarshaler{T: GTypeResolverError, F: marshalResolverError},
		coreglib.TypeMarshaler{T: GTypeSocketFamily, F: marshalSocketFamily},
		coreglib.TypeMarshaler{T: GTypeSocketProtocol, F: marshalSocketProtocol},
		coreglib.TypeMarshaler{T: GTypeSocketType, F: marshalSocketType},
		coreglib.TypeMarshaler{T: GTypeDriveStartFlags, F: marshalDriveStartFlags},
		coreglib.TypeMarshaler{T: GTypeSocketMsgFlags, F: marshalSocketMsgFlags},
	})
}

// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
type DriveStartStopType C.gint

const (
	// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = iota
	// DriveStartStopTypeShutdown: stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
	DriveStartStopTypeShutdown
	// DriveStartStopTypeNetwork: start/stop methods are used for
	// connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork
	// DriveStartStopTypeMultidisk: start/stop methods will assemble/disassemble
	// a virtual drive from several physical drives.
	DriveStartStopTypeMultidisk
	// DriveStartStopTypePassword: start/stop methods will unlock/lock the
	// disk (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command).
	DriveStartStopTypePassword
)

func marshalDriveStartStopType(p uintptr) (interface{}, error) {
	return DriveStartStopType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DriveStartStopType.
func (d DriveStartStopType) String() string {
	switch d {
	case DriveStartStopTypeUnknown:
		return "Unknown"
	case DriveStartStopTypeShutdown:
		return "Shutdown"
	case DriveStartStopTypeNetwork:
		return "Network"
	case DriveStartStopTypeMultidisk:
		return "Multidisk"
	case DriveStartStopTypePassword:
		return "Password"
	default:
		return fmt.Sprintf("DriveStartStopType(%d)", d)
	}
}

// ResolverError: error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError C.gint

const (
	// ResolverErrorNotFound: requested name/address/service was not found.
	ResolverErrorNotFound ResolverError = iota
	// ResolverErrorTemporaryFailure: requested information could not be looked
	// up due to a network error or similar problem.
	ResolverErrorTemporaryFailure
	// ResolverErrorInternal: unknown error.
	ResolverErrorInternal
)

func marshalResolverError(p uintptr) (interface{}, error) {
	return ResolverError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResolverError.
func (r ResolverError) String() string {
	switch r {
	case ResolverErrorNotFound:
		return "NotFound"
	case ResolverErrorTemporaryFailure:
		return "TemporaryFailure"
	case ResolverErrorInternal:
		return "Internal"
	default:
		return fmt.Sprintf("ResolverError(%d)", r)
	}
}

// SocketFamily: protocol family of a Address. (These values are identical to
// the system defines AF_INET, AF_INET6 and AF_UNIX, if available.).
type SocketFamily C.gint

const (
	// SocketFamilyInvalid: no address family.
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyUnix: UNIX domain family.
	SocketFamilyUnix SocketFamily = 1
	// SocketFamilyIPv4: IPv4 family.
	SocketFamilyIPv4 SocketFamily = 2
	// SocketFamilyIPv6: IPv6 family.
	SocketFamilyIPv6 SocketFamily = 10
)

func marshalSocketFamily(p uintptr) (interface{}, error) {
	return SocketFamily(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketFamily.
func (s SocketFamily) String() string {
	switch s {
	case SocketFamilyInvalid:
		return "Invalid"
	case SocketFamilyUnix:
		return "Unix"
	case SocketFamilyIPv4:
		return "IPv4"
	case SocketFamilyIPv6:
		return "IPv6"
	default:
		return fmt.Sprintf("SocketFamily(%d)", s)
	}
}

// SocketProtocol: protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
//
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
type SocketProtocol C.gint

const (
	// SocketProtocolUnknown: protocol type is unknown.
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault: default protocol for the family/type.
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTCP: TCP over IP.
	SocketProtocolTCP SocketProtocol = 6
	// SocketProtocolUDP: UDP over IP.
	SocketProtocolUDP SocketProtocol = 17
	// SocketProtocolSCTP: SCTP over IP.
	SocketProtocolSCTP SocketProtocol = 132
)

func marshalSocketProtocol(p uintptr) (interface{}, error) {
	return SocketProtocol(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketProtocol.
func (s SocketProtocol) String() string {
	switch s {
	case SocketProtocolUnknown:
		return "Unknown"
	case SocketProtocolDefault:
		return "Default"
	case SocketProtocolTCP:
		return "TCP"
	case SocketProtocolUDP:
		return "UDP"
	case SocketProtocolSCTP:
		return "SCTP"
	default:
		return fmt.Sprintf("SocketProtocol(%d)", s)
	}
}

// SocketType flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
type SocketType C.gint

const (
	// SocketTypeInvalid: type unknown or wrong.
	SocketTypeInvalid SocketType = iota
	// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream
	// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP).
	SocketTypeDatagram
	// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket
)

func marshalSocketType(p uintptr) (interface{}, error) {
	return SocketType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketType.
func (s SocketType) String() string {
	switch s {
	case SocketTypeInvalid:
		return "Invalid"
	case SocketTypeStream:
		return "Stream"
	case SocketTypeDatagram:
		return "Datagram"
	case SocketTypeSeqpacket:
		return "Seqpacket"
	default:
		return fmt.Sprintf("SocketType(%d)", s)
	}
}

// DriveStartFlags flags used when starting a drive.
type DriveStartFlags C.guint

const (
	// DriveStartNone: no flags set.
	DriveStartNone DriveStartFlags = 0b0
)

func marshalDriveStartFlags(p uintptr) (interface{}, error) {
	return DriveStartFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DriveStartFlags.
func (d DriveStartFlags) String() string {
	if d == 0 {
		return "DriveStartFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(14)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DriveStartNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("DriveStartFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DriveStartFlags) Has(other DriveStartFlags) bool {
	return (d & other) == other
}

// SocketMsgFlags flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
type SocketMsgFlags C.guint

const (
	// SocketMsgNone: no flags.
	SocketMsgNone SocketMsgFlags = 0b0
	// SocketMsgOob: request to send/receive out of band data.
	SocketMsgOob SocketMsgFlags = 0b1
	// SocketMsgPeek: read data from the socket without removing it from the
	// queue.
	SocketMsgPeek SocketMsgFlags = 0b10
	// SocketMsgDontroute: don't use a gateway to send out the packet, only send
	// to hosts on directly connected networks.
	SocketMsgDontroute SocketMsgFlags = 0b100
)

func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
	return SocketMsgFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SocketMsgFlags.
func (s SocketMsgFlags) String() string {
	if s == 0 {
		return "SocketMsgFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(59)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SocketMsgNone:
			builder.WriteString("None|")
		case SocketMsgOob:
			builder.WriteString("Oob|")
		case SocketMsgPeek:
			builder.WriteString("Peek|")
		case SocketMsgDontroute:
			builder.WriteString("Dontroute|")
		default:
			builder.WriteString(fmt.Sprintf("SocketMsgFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SocketMsgFlags) Has(other SocketMsgFlags) bool {
	return (s & other) == other
}
