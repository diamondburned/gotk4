// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeBusType                = coreglib.Type(C.g_bus_type_get_type())
	GTypeCredentialsType        = coreglib.Type(C.g_credentials_type_get_type())
	GTypeDBusError              = coreglib.Type(C.g_dbus_error_get_type())
	GTypeDBusMessageByteOrder   = coreglib.Type(C.g_dbus_message_byte_order_get_type())
	GTypeDBusMessageHeaderField = coreglib.Type(C.g_dbus_message_header_field_get_type())
	GTypeDBusMessageType        = coreglib.Type(C.g_dbus_message_type_get_type())
	GTypeBusNameOwnerFlags      = coreglib.Type(C.g_bus_name_owner_flags_get_type())
	GTypeBusNameWatcherFlags    = coreglib.Type(C.g_bus_name_watcher_flags_get_type())
	GTypeDBusCallFlags          = coreglib.Type(C.g_dbus_call_flags_get_type())
	GTypeDBusCapabilityFlags    = coreglib.Type(C.g_dbus_capability_flags_get_type())
	GTypeDBusConnectionFlags    = coreglib.Type(C.g_dbus_connection_flags_get_type())
	GTypeDBusMessageFlags       = coreglib.Type(C.g_dbus_message_flags_get_type())
	GTypeDBusPropertyInfoFlags  = coreglib.Type(C.g_dbus_property_info_flags_get_type())
	GTypeDBusProxyFlags         = coreglib.Type(C.g_dbus_proxy_flags_get_type())
	GTypeDBusSendMessageFlags   = coreglib.Type(C.g_dbus_send_message_flags_get_type())
	GTypeDBusServerFlags        = coreglib.Type(C.g_dbus_server_flags_get_type())
	GTypeDBusSignalFlags        = coreglib.Type(C.g_dbus_signal_flags_get_type())
	GTypeDBusSubtreeFlags       = coreglib.Type(C.g_dbus_subtree_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBusType, F: marshalBusType},
		coreglib.TypeMarshaler{T: GTypeCredentialsType, F: marshalCredentialsType},
		coreglib.TypeMarshaler{T: GTypeDBusError, F: marshalDBusError},
		coreglib.TypeMarshaler{T: GTypeDBusMessageByteOrder, F: marshalDBusMessageByteOrder},
		coreglib.TypeMarshaler{T: GTypeDBusMessageHeaderField, F: marshalDBusMessageHeaderField},
		coreglib.TypeMarshaler{T: GTypeDBusMessageType, F: marshalDBusMessageType},
		coreglib.TypeMarshaler{T: GTypeBusNameOwnerFlags, F: marshalBusNameOwnerFlags},
		coreglib.TypeMarshaler{T: GTypeBusNameWatcherFlags, F: marshalBusNameWatcherFlags},
		coreglib.TypeMarshaler{T: GTypeDBusCallFlags, F: marshalDBusCallFlags},
		coreglib.TypeMarshaler{T: GTypeDBusCapabilityFlags, F: marshalDBusCapabilityFlags},
		coreglib.TypeMarshaler{T: GTypeDBusConnectionFlags, F: marshalDBusConnectionFlags},
		coreglib.TypeMarshaler{T: GTypeDBusMessageFlags, F: marshalDBusMessageFlags},
		coreglib.TypeMarshaler{T: GTypeDBusPropertyInfoFlags, F: marshalDBusPropertyInfoFlags},
		coreglib.TypeMarshaler{T: GTypeDBusProxyFlags, F: marshalDBusProxyFlags},
		coreglib.TypeMarshaler{T: GTypeDBusSendMessageFlags, F: marshalDBusSendMessageFlags},
		coreglib.TypeMarshaler{T: GTypeDBusServerFlags, F: marshalDBusServerFlags},
		coreglib.TypeMarshaler{T: GTypeDBusSignalFlags, F: marshalDBusSignalFlags},
		coreglib.TypeMarshaler{T: GTypeDBusSubtreeFlags, F: marshalDBusSubtreeFlags},
	})
}

// BusType: enumeration for well-known message buses.
type BusType C.gint

const (
	// BusTypeStarter alias for the message bus that activated the process,
	// if any.
	BusTypeStarter BusType = -1
	// BusTypeNone: not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem: system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession: login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p uintptr) (interface{}, error) {
	return BusType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BusType.
func (b BusType) String() string {
	switch b {
	case BusTypeStarter:
		return "Starter"
	case BusTypeNone:
		return "None"
	case BusTypeSystem:
		return "System"
	case BusTypeSession:
		return "Session"
	default:
		return fmt.Sprintf("BusType(%d)", b)
	}
}

// CredentialsType: enumeration describing different kinds of native credential
// types.
type CredentialsType C.gint

const (
	// CredentialsTypeInvalid indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = iota
	// CredentialsTypeLinuxUcred: native credentials type is a struct ucred.
	CredentialsTypeLinuxUcred
	// CredentialsTypeFreebsdCmsgcred: native credentials type is a struct
	// cmsgcred.
	CredentialsTypeFreebsdCmsgcred
	// CredentialsTypeOpenbsdSockpeercred: native credentials type is a struct
	// sockpeercred. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred
	// CredentialsTypeSolarisUcred: native credentials type is a ucred_t.
	// Added in 2.40.
	CredentialsTypeSolarisUcred
	// CredentialsTypeNetbsdUnpcbid: native credentials type is a struct
	// unpcbid. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid
	// CredentialsTypeAppleXucred: native credentials type is a struct xucred.
	// Added in 2.66.
	CredentialsTypeAppleXucred
)

func marshalCredentialsType(p uintptr) (interface{}, error) {
	return CredentialsType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CredentialsType.
func (c CredentialsType) String() string {
	switch c {
	case CredentialsTypeInvalid:
		return "Invalid"
	case CredentialsTypeLinuxUcred:
		return "LinuxUcred"
	case CredentialsTypeFreebsdCmsgcred:
		return "FreebsdCmsgcred"
	case CredentialsTypeOpenbsdSockpeercred:
		return "OpenbsdSockpeercred"
	case CredentialsTypeSolarisUcred:
		return "SolarisUcred"
	case CredentialsTypeNetbsdUnpcbid:
		return "NetbsdUnpcbid"
	case CredentialsTypeAppleXucred:
		return "AppleXucred"
	default:
		return fmt.Sprintf("CredentialsType(%d)", c)
	}
}

// DBusError: error codes for the G_DBUS_ERROR error domain.
type DBusError C.gint

const (
	// DBusErrorFailed: generic error; "something went wrong" - see the error
	// message for more.
	DBusErrorFailed DBusError = iota
	// DBusErrorNoMemory: there was not enough memory to complete an operation.
	DBusErrorNoMemory
	// DBusErrorServiceUnknown bus doesn't know how to launch a service to
	// supply the bus name you wanted.
	DBusErrorServiceUnknown
	// DBusErrorNameHasNoOwner bus name you referenced doesn't exist (i.e.
	// no application owns it).
	DBusErrorNameHasNoOwner
	// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
	DBusErrorNoReply
	// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
	DBusErrorIOError
	// DBusErrorBadAddress d-Bus bus address was malformed.
	DBusErrorBadAddress
	// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
	DBusErrorNotSupported
	// DBusErrorLimitsExceeded: some limited resource is exhausted.
	DBusErrorLimitsExceeded
	// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
	DBusErrorAccessDenied
	// DBusErrorAuthFailed: authentication didn't work.
	DBusErrorAuthFailed
	// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
	DBusErrorNoServer
	// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimeout
	// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
	DBusErrorNoNetwork
	// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
	DBusErrorAddressInUse
	// DBusErrorDisconnected: connection is disconnected and you're trying to
	// use it.
	DBusErrorDisconnected
	// DBusErrorInvalidArgs: invalid arguments passed to a method call.
	DBusErrorInvalidArgs
	// DBusErrorFileNotFound: missing file.
	DBusErrorFileNotFound
	// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
	DBusErrorFileExists
	// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
	DBusErrorUnknownMethod
	// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimedOut
	// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
	DBusErrorMatchRuleNotFound
	// DBusErrorMatchRuleInvalid: match rule isn't syntactically valid.
	DBusErrorMatchRuleInvalid
	// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
	DBusErrorSpawnExecFailed
	// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
	DBusErrorSpawnForkFailed
	// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
	DBusErrorSpawnChildExited
	// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
	DBusErrorSpawnChildSignaled
	// DBusErrorSpawnFailed: while starting a new process, something went wrong.
	DBusErrorSpawnFailed
	// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
	DBusErrorSpawnSetupFailed
	// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
	DBusErrorSpawnConfigInvalid
	// DBusErrorSpawnServiceInvalid bus name was not valid.
	DBusErrorSpawnServiceInvalid
	// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
	DBusErrorSpawnServiceNotFound
	// DBusErrorSpawnPermissionsInvalid permissions are incorrect on the setuid
	// helper.
	DBusErrorSpawnPermissionsInvalid
	// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
	DBusErrorSpawnFileInvalid
	// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
	DBusErrorSpawnNoMemory
	// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
	DBusErrorUnixProcessIDUnknown
	// DBusErrorInvalidSignature: type signature is not valid.
	DBusErrorInvalidSignature
	// DBusErrorInvalidFileContent: file contains invalid syntax or is otherwise
	// broken.
	DBusErrorInvalidFileContent
	// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
	DBusErrorSelinuxSecurityContextUnknown
	// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
	DBusErrorAdtAuditDataUnknown
	// DBusErrorObjectPathInUse there's already an object with the requested
	// object path.
	DBusErrorObjectPathInUse
	// DBusErrorUnknownObject: object you invoked a method on isn't known.
	// Since 2.42.
	DBusErrorUnknownObject
	// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42.
	DBusErrorUnknownInterface
	// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42.
	DBusErrorUnknownProperty
	// DBusErrorPropertyReadOnly: property you tried to set is read-only.
	// Since 2.42.
	DBusErrorPropertyReadOnly
)

func marshalDBusError(p uintptr) (interface{}, error) {
	return DBusError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusError.
func (d DBusError) String() string {
	switch d {
	case DBusErrorFailed:
		return "Failed"
	case DBusErrorNoMemory:
		return "NoMemory"
	case DBusErrorServiceUnknown:
		return "ServiceUnknown"
	case DBusErrorNameHasNoOwner:
		return "NameHasNoOwner"
	case DBusErrorNoReply:
		return "NoReply"
	case DBusErrorIOError:
		return "IOError"
	case DBusErrorBadAddress:
		return "BadAddress"
	case DBusErrorNotSupported:
		return "NotSupported"
	case DBusErrorLimitsExceeded:
		return "LimitsExceeded"
	case DBusErrorAccessDenied:
		return "AccessDenied"
	case DBusErrorAuthFailed:
		return "AuthFailed"
	case DBusErrorNoServer:
		return "NoServer"
	case DBusErrorTimeout:
		return "Timeout"
	case DBusErrorNoNetwork:
		return "NoNetwork"
	case DBusErrorAddressInUse:
		return "AddressInUse"
	case DBusErrorDisconnected:
		return "Disconnected"
	case DBusErrorInvalidArgs:
		return "InvalidArgs"
	case DBusErrorFileNotFound:
		return "FileNotFound"
	case DBusErrorFileExists:
		return "FileExists"
	case DBusErrorUnknownMethod:
		return "UnknownMethod"
	case DBusErrorTimedOut:
		return "TimedOut"
	case DBusErrorMatchRuleNotFound:
		return "MatchRuleNotFound"
	case DBusErrorMatchRuleInvalid:
		return "MatchRuleInvalid"
	case DBusErrorSpawnExecFailed:
		return "SpawnExecFailed"
	case DBusErrorSpawnForkFailed:
		return "SpawnForkFailed"
	case DBusErrorSpawnChildExited:
		return "SpawnChildExited"
	case DBusErrorSpawnChildSignaled:
		return "SpawnChildSignaled"
	case DBusErrorSpawnFailed:
		return "SpawnFailed"
	case DBusErrorSpawnSetupFailed:
		return "SpawnSetupFailed"
	case DBusErrorSpawnConfigInvalid:
		return "SpawnConfigInvalid"
	case DBusErrorSpawnServiceInvalid:
		return "SpawnServiceInvalid"
	case DBusErrorSpawnServiceNotFound:
		return "SpawnServiceNotFound"
	case DBusErrorSpawnPermissionsInvalid:
		return "SpawnPermissionsInvalid"
	case DBusErrorSpawnFileInvalid:
		return "SpawnFileInvalid"
	case DBusErrorSpawnNoMemory:
		return "SpawnNoMemory"
	case DBusErrorUnixProcessIDUnknown:
		return "UnixProcessIDUnknown"
	case DBusErrorInvalidSignature:
		return "InvalidSignature"
	case DBusErrorInvalidFileContent:
		return "InvalidFileContent"
	case DBusErrorSelinuxSecurityContextUnknown:
		return "SelinuxSecurityContextUnknown"
	case DBusErrorAdtAuditDataUnknown:
		return "AdtAuditDataUnknown"
	case DBusErrorObjectPathInUse:
		return "ObjectPathInUse"
	case DBusErrorUnknownObject:
		return "UnknownObject"
	case DBusErrorUnknownInterface:
		return "UnknownInterface"
	case DBusErrorUnknownProperty:
		return "UnknownProperty"
	case DBusErrorPropertyReadOnly:
		return "PropertyReadOnly"
	default:
		return fmt.Sprintf("DBusError(%d)", d)
	}
}

// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
type DBusMessageByteOrder C.gint

const (
	// DBusMessageByteOrderBigEndian: byte order is big endian.
	DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
	// DBusMessageByteOrderLittleEndian: byte order is little endian.
	DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
)

func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
	return DBusMessageByteOrder(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusMessageByteOrder.
func (d DBusMessageByteOrder) String() string {
	switch d {
	case DBusMessageByteOrderBigEndian:
		return "BigEndian"
	case DBusMessageByteOrderLittleEndian:
		return "LittleEndian"
	default:
		return fmt.Sprintf("DBusMessageByteOrder(%d)", d)
	}
}

// DBusMessageHeaderField: header fields used in BusMessage.
type DBusMessageHeaderField C.gint

const (
	// DBusMessageHeaderFieldInvalid: not a valid header field.
	DBusMessageHeaderFieldInvalid DBusMessageHeaderField = iota
	// DBusMessageHeaderFieldPath: object path.
	DBusMessageHeaderFieldPath
	// DBusMessageHeaderFieldInterface: interface name.
	DBusMessageHeaderFieldInterface
	// DBusMessageHeaderFieldMember: method or signal name.
	DBusMessageHeaderFieldMember
	// DBusMessageHeaderFieldErrorName: name of the error that occurred.
	DBusMessageHeaderFieldErrorName
	// DBusMessageHeaderFieldReplySerial: serial number the message is a reply
	// to.
	DBusMessageHeaderFieldReplySerial
	// DBusMessageHeaderFieldDestination: name the message is intended for.
	DBusMessageHeaderFieldDestination
	// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
	DBusMessageHeaderFieldSender
	// DBusMessageHeaderFieldSignature: signature of the message body.
	DBusMessageHeaderFieldSignature
	// DBusMessageHeaderFieldNumUnixFds: number of UNIX file descriptors that
	// accompany the message.
	DBusMessageHeaderFieldNumUnixFds
)

func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
	return DBusMessageHeaderField(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusMessageHeaderField.
func (d DBusMessageHeaderField) String() string {
	switch d {
	case DBusMessageHeaderFieldInvalid:
		return "Invalid"
	case DBusMessageHeaderFieldPath:
		return "Path"
	case DBusMessageHeaderFieldInterface:
		return "Interface"
	case DBusMessageHeaderFieldMember:
		return "Member"
	case DBusMessageHeaderFieldErrorName:
		return "ErrorName"
	case DBusMessageHeaderFieldReplySerial:
		return "ReplySerial"
	case DBusMessageHeaderFieldDestination:
		return "Destination"
	case DBusMessageHeaderFieldSender:
		return "Sender"
	case DBusMessageHeaderFieldSignature:
		return "Signature"
	case DBusMessageHeaderFieldNumUnixFds:
		return "NumUnixFds"
	default:
		return fmt.Sprintf("DBusMessageHeaderField(%d)", d)
	}
}

// DBusMessageType: message types used in BusMessage.
type DBusMessageType C.gint

const (
	// DBusMessageTypeInvalid: message is of invalid type.
	DBusMessageTypeInvalid DBusMessageType = iota
	// DBusMessageTypeMethodCall: method call.
	DBusMessageTypeMethodCall
	// DBusMessageTypeMethodReturn: method reply.
	DBusMessageTypeMethodReturn
	// DBusMessageTypeError: error reply.
	DBusMessageTypeError
	// DBusMessageTypeSignal: signal emission.
	DBusMessageTypeSignal
)

func marshalDBusMessageType(p uintptr) (interface{}, error) {
	return DBusMessageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusMessageType.
func (d DBusMessageType) String() string {
	switch d {
	case DBusMessageTypeInvalid:
		return "Invalid"
	case DBusMessageTypeMethodCall:
		return "MethodCall"
	case DBusMessageTypeMethodReturn:
		return "MethodReturn"
	case DBusMessageTypeError:
		return "Error"
	case DBusMessageTypeSignal:
		return "Signal"
	default:
		return fmt.Sprintf("DBusMessageType(%d)", d)
	}
}

// BusNameOwnerFlags flags used in g_bus_own_name().
type BusNameOwnerFlags C.guint

const (
	// BusNameOwnerFlagsNone: no flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0b0
	// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 0b1
	// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the
	// name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 0b10
	// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns
	// the name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54).
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 0b100
)

func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
	return BusNameOwnerFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BusNameOwnerFlags.
func (b BusNameOwnerFlags) String() string {
	if b == 0 {
		return "BusNameOwnerFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(108)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BusNameOwnerFlagsNone:
			builder.WriteString("None|")
		case BusNameOwnerFlagsAllowReplacement:
			builder.WriteString("AllowReplacement|")
		case BusNameOwnerFlagsReplace:
			builder.WriteString("Replace|")
		case BusNameOwnerFlagsDoNotQueue:
			builder.WriteString("DoNotQueue|")
		default:
			builder.WriteString(fmt.Sprintf("BusNameOwnerFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BusNameOwnerFlags) Has(other BusNameOwnerFlags) bool {
	return (b & other) == other
}

// BusNameWatcherFlags flags used in g_bus_watch_name().
type BusNameWatcherFlags C.guint

const (
	// BusNameWatcherFlagsNone: no flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0b0
	// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 0b1
)

func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
	return BusNameWatcherFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BusNameWatcherFlags.
func (b BusNameWatcherFlags) String() string {
	if b == 0 {
		return "BusNameWatcherFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(52)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BusNameWatcherFlagsNone:
			builder.WriteString("None|")
		case BusNameWatcherFlagsAutoStart:
			builder.WriteString("AutoStart|")
		default:
			builder.WriteString(fmt.Sprintf("BusNameWatcherFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BusNameWatcherFlags) Has(other BusNameWatcherFlags) bool {
	return (b & other) == other
}

// DBusCallFlags flags used in g_dbus_connection_call() and similar APIs.
type DBusCallFlags C.guint

const (
	// DBusCallFlagsNone: no flags set.
	DBusCallFlagsNone DBusCallFlags = 0b0
	// DBusCallFlagsNoAutoStart bus must not launch an owner for the destination
	// name in response to this method invocation.
	DBusCallFlagsNoAutoStart DBusCallFlags = 0b1
	// DBusCallFlagsAllowInteractiveAuthorization: caller is prepared to wait
	// for interactive authorization. Since 2.46.
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 0b10
)

func marshalDBusCallFlags(p uintptr) (interface{}, error) {
	return DBusCallFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusCallFlags.
func (d DBusCallFlags) String() string {
	if d == 0 {
		return "DBusCallFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(85)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusCallFlagsNone:
			builder.WriteString("None|")
		case DBusCallFlagsNoAutoStart:
			builder.WriteString("NoAutoStart|")
		case DBusCallFlagsAllowInteractiveAuthorization:
			builder.WriteString("AllowInteractiveAuthorization|")
		default:
			builder.WriteString(fmt.Sprintf("DBusCallFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusCallFlags) Has(other DBusCallFlags) bool {
	return (d & other) == other
}

// DBusCapabilityFlags capabilities negotiated with the remote peer.
type DBusCapabilityFlags C.guint

const (
	// DBusCapabilityFlagsNone: no flags set.
	DBusCapabilityFlagsNone DBusCapabilityFlags = 0b0
	// DBusCapabilityFlagsUnixFdPassing connection supports exchanging UNIX file
	// descriptors with the remote peer.
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 0b1
)

func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
	return DBusCapabilityFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusCapabilityFlags.
func (d DBusCapabilityFlags) String() string {
	if d == 0 {
		return "DBusCapabilityFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(56)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusCapabilityFlagsNone:
			builder.WriteString("None|")
		case DBusCapabilityFlagsUnixFdPassing:
			builder.WriteString("UnixFdPassing|")
		default:
			builder.WriteString(fmt.Sprintf("DBusCapabilityFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusCapabilityFlags) Has(other DBusCapabilityFlags) bool {
	return (d & other) == other
}

// DBusConnectionFlags flags used when creating a new BusConnection.
type DBusConnectionFlags C.guint

const (
	// DBusConnectionFlagsNone: no flags set.
	DBusConnectionFlagsNone DBusConnectionFlags = 0b0
	// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
	DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 0b1
	// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
	DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 0b10
	// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 0b100
	// DBusConnectionFlagsMessageBusConnection pass this flag if connecting to
	// a peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
	DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 0b1000
	// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
	DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 0b10000
	// DBusConnectionFlagsAuthenticationRequireSameUser: when authenticating as
	// a server, require the UID of the peer to be the same as the UID of the
	// server. (Since: 2.68).
	DBusConnectionFlagsAuthenticationRequireSameUser DBusConnectionFlags = 0b100000
)

func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
	return DBusConnectionFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusConnectionFlags.
func (d DBusConnectionFlags) String() string {
	if d == 0 {
		return "DBusConnectionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusConnectionFlagsNone:
			builder.WriteString("None|")
		case DBusConnectionFlagsAuthenticationClient:
			builder.WriteString("AuthenticationClient|")
		case DBusConnectionFlagsAuthenticationServer:
			builder.WriteString("AuthenticationServer|")
		case DBusConnectionFlagsAuthenticationAllowAnonymous:
			builder.WriteString("AuthenticationAllowAnonymous|")
		case DBusConnectionFlagsMessageBusConnection:
			builder.WriteString("MessageBusConnection|")
		case DBusConnectionFlagsDelayMessageProcessing:
			builder.WriteString("DelayMessageProcessing|")
		case DBusConnectionFlagsAuthenticationRequireSameUser:
			builder.WriteString("AuthenticationRequireSameUser|")
		default:
			builder.WriteString(fmt.Sprintf("DBusConnectionFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusConnectionFlags) Has(other DBusConnectionFlags) bool {
	return (d & other) == other
}

// DBusMessageFlags: message flags used in BusMessage.
type DBusMessageFlags C.guint

const (
	// DBusMessageFlagsNone: no flags set.
	DBusMessageFlagsNone DBusMessageFlags = 0b0
	// DBusMessageFlagsNoReplyExpected: reply is not expected.
	DBusMessageFlagsNoReplyExpected DBusMessageFlags = 0b1
	// DBusMessageFlagsNoAutoStart bus must not launch an owner for the
	// destination name in response to this message.
	DBusMessageFlagsNoAutoStart DBusMessageFlags = 0b10
	// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 0b100
)

func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
	return DBusMessageFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusMessageFlags.
func (d DBusMessageFlags) String() string {
	if d == 0 {
		return "DBusMessageFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(126)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusMessageFlagsNone:
			builder.WriteString("None|")
		case DBusMessageFlagsNoReplyExpected:
			builder.WriteString("NoReplyExpected|")
		case DBusMessageFlagsNoAutoStart:
			builder.WriteString("NoAutoStart|")
		case DBusMessageFlagsAllowInteractiveAuthorization:
			builder.WriteString("AllowInteractiveAuthorization|")
		default:
			builder.WriteString(fmt.Sprintf("DBusMessageFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusMessageFlags) Has(other DBusMessageFlags) bool {
	return (d & other) == other
}

// DBusPropertyInfoFlags flags describing the access control of a D-Bus
// property.
type DBusPropertyInfoFlags C.guint

const (
	// DBusPropertyInfoFlagsNone: no flags set.
	DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0b0
	// DBusPropertyInfoFlagsReadable: property is readable.
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 0b1
	// DBusPropertyInfoFlagsWritable: property is writable.
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 0b10
)

func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
	return DBusPropertyInfoFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusPropertyInfoFlags.
func (d DBusPropertyInfoFlags) String() string {
	if d == 0 {
		return "DBusPropertyInfoFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(85)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusPropertyInfoFlagsNone:
			builder.WriteString("None|")
		case DBusPropertyInfoFlagsReadable:
			builder.WriteString("Readable|")
		case DBusPropertyInfoFlagsWritable:
			builder.WriteString("Writable|")
		default:
			builder.WriteString(fmt.Sprintf("DBusPropertyInfoFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusPropertyInfoFlags) Has(other DBusPropertyInfoFlags) bool {
	return (d & other) == other
}

// DBusProxyFlags flags used when constructing an instance of a BusProxy derived
// class.
type DBusProxyFlags C.guint

const (
	// DBusProxyFlagsNone: no flags set.
	DBusProxyFlagsNone DBusProxyFlags = 0b0
	// DBusProxyFlagsDoNotLoadProperties: don't load properties.
	DBusProxyFlagsDoNotLoadProperties DBusProxyFlags = 0b1
	// DBusProxyFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
	DBusProxyFlagsDoNotConnectSignals DBusProxyFlags = 0b10
	// DBusProxyFlagsDoNotAutoStart: if the proxy is for a well-known name,
	// do not ask the bus to launch an owner during proxy initialization or
	// a method call. This flag is only meaningful in proxies for well-known
	// names.
	DBusProxyFlagsDoNotAutoStart DBusProxyFlags = 0b100
	// DBusProxyFlagsGetInvalidatedProperties: if set,
	// the property value for any __invalidated property__ will be
	// (asynchronously) retrieved upon receiving the PropertiesChanged
	// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
	DBusProxyFlagsGetInvalidatedProperties DBusProxyFlags = 0b1000
	// DBusProxyFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call.
	// This flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
	DBusProxyFlagsDoNotAutoStartAtConstruction DBusProxyFlags = 0b10000
)

func marshalDBusProxyFlags(p uintptr) (interface{}, error) {
	return DBusProxyFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusProxyFlags.
func (d DBusProxyFlags) String() string {
	if d == 0 {
		return "DBusProxyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(197)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusProxyFlagsNone:
			builder.WriteString("None|")
		case DBusProxyFlagsDoNotLoadProperties:
			builder.WriteString("DoNotLoadProperties|")
		case DBusProxyFlagsDoNotConnectSignals:
			builder.WriteString("DoNotConnectSignals|")
		case DBusProxyFlagsDoNotAutoStart:
			builder.WriteString("DoNotAutoStart|")
		case DBusProxyFlagsGetInvalidatedProperties:
			builder.WriteString("GetInvalidatedProperties|")
		case DBusProxyFlagsDoNotAutoStartAtConstruction:
			builder.WriteString("DoNotAutoStartAtConstruction|")
		default:
			builder.WriteString(fmt.Sprintf("DBusProxyFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusProxyFlags) Has(other DBusProxyFlags) bool {
	return (d & other) == other
}

// DBusSendMessageFlags flags used when sending BusMessages on a BusConnection.
type DBusSendMessageFlags C.guint

const (
	// DBusSendMessageFlagsNone: no flags set.
	DBusSendMessageFlagsNone DBusSendMessageFlags = 0b0
	// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 0b1
)

func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
	return DBusSendMessageFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusSendMessageFlags.
func (d DBusSendMessageFlags) String() string {
	if d == 0 {
		return "DBusSendMessageFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(59)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusSendMessageFlagsNone:
			builder.WriteString("None|")
		case DBusSendMessageFlagsPreserveSerial:
			builder.WriteString("PreserveSerial|")
		default:
			builder.WriteString(fmt.Sprintf("DBusSendMessageFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusSendMessageFlags) Has(other DBusSendMessageFlags) bool {
	return (d & other) == other
}

// DBusServerFlags flags used when creating a BusServer.
type DBusServerFlags C.guint

const (
	// DBusServerFlagsNone: no flags set.
	DBusServerFlagsNone DBusServerFlags = 0b0
	// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
	DBusServerFlagsRunInThread DBusServerFlags = 0b1
	// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 0b10
	// DBusServerFlagsAuthenticationRequireSameUser: require the UID of the
	// peer to be the same as the UID of the server when authenticating. (Since:
	// 2.68).
	DBusServerFlagsAuthenticationRequireSameUser DBusServerFlags = 0b100
)

func marshalDBusServerFlags(p uintptr) (interface{}, error) {
	return DBusServerFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusServerFlags.
func (d DBusServerFlags) String() string {
	if d == 0 {
		return "DBusServerFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(135)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusServerFlagsNone:
			builder.WriteString("None|")
		case DBusServerFlagsRunInThread:
			builder.WriteString("RunInThread|")
		case DBusServerFlagsAuthenticationAllowAnonymous:
			builder.WriteString("AuthenticationAllowAnonymous|")
		case DBusServerFlagsAuthenticationRequireSameUser:
			builder.WriteString("AuthenticationRequireSameUser|")
		default:
			builder.WriteString(fmt.Sprintf("DBusServerFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusServerFlags) Has(other DBusServerFlags) bool {
	return (d & other) == other
}

// DBusSignalFlags flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
type DBusSignalFlags C.guint

const (
	// DBusSignalFlagsNone: no flags set.
	DBusSignalFlagsNone DBusSignalFlags = 0b0
	// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
	DBusSignalFlagsNoMatchRule DBusSignalFlags = 0b1
	// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 0b10
	// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
	DBusSignalFlagsMatchArg0Path DBusSignalFlags = 0b100
)

func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
	return DBusSignalFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusSignalFlags.
func (d DBusSignalFlags) String() string {
	if d == 0 {
		return "DBusSignalFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(109)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusSignalFlagsNone:
			builder.WriteString("None|")
		case DBusSignalFlagsNoMatchRule:
			builder.WriteString("NoMatchRule|")
		case DBusSignalFlagsMatchArg0Namespace:
			builder.WriteString("MatchArg0Namespace|")
		case DBusSignalFlagsMatchArg0Path:
			builder.WriteString("MatchArg0Path|")
		default:
			builder.WriteString(fmt.Sprintf("DBusSignalFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusSignalFlags) Has(other DBusSignalFlags) bool {
	return (d & other) == other
}

// DBusSubtreeFlags flags passed to g_dbus_connection_register_subtree().
type DBusSubtreeFlags C.guint

const (
	// DBusSubtreeFlagsNone: no flags set.
	DBusSubtreeFlagsNone DBusSubtreeFlags = 0b0
	// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 0b1
)

func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
	return DBusSubtreeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusSubtreeFlags.
func (d DBusSubtreeFlags) String() string {
	if d == 0 {
		return "DBusSubtreeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(64)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusSubtreeFlagsNone:
			builder.WriteString("None|")
		case DBusSubtreeFlagsDispatchToUnenumeratedNodes:
			builder.WriteString("DispatchToUnenumeratedNodes|")
		default:
			builder.WriteString(fmt.Sprintf("DBusSubtreeFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusSubtreeFlags) Has(other DBusSubtreeFlags) bool {
	return (d & other) == other
}
