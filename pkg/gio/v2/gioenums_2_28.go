// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeTLSAuthenticationMode = coreglib.Type(C.g_tls_authentication_mode_get_type())
	GTypeTLSError              = coreglib.Type(C.g_tls_error_get_type())
	GTypeTLSRehandshakeMode    = coreglib.Type(C.g_tls_rehandshake_mode_get_type())
	GTypeApplicationFlags      = coreglib.Type(C.g_application_flags_get_type())
	GTypeIOStreamSpliceFlags   = coreglib.Type(C.g_io_stream_splice_flags_get_type())
	GTypeTLSCertificateFlags   = coreglib.Type(C.g_tls_certificate_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTLSAuthenticationMode, F: marshalTLSAuthenticationMode},
		coreglib.TypeMarshaler{T: GTypeTLSError, F: marshalTLSError},
		coreglib.TypeMarshaler{T: GTypeTLSRehandshakeMode, F: marshalTLSRehandshakeMode},
		coreglib.TypeMarshaler{T: GTypeApplicationFlags, F: marshalApplicationFlags},
		coreglib.TypeMarshaler{T: GTypeIOStreamSpliceFlags, F: marshalIOStreamSpliceFlags},
		coreglib.TypeMarshaler{T: GTypeTLSCertificateFlags, F: marshalTLSCertificateFlags},
	})
}

// TLSAuthenticationMode: client authentication mode for a ServerConnection.
type TLSAuthenticationMode C.gint

const (
	// TLSAuthenticationNone: client authentication not required.
	TLSAuthenticationNone TLSAuthenticationMode = iota
	// TLSAuthenticationRequested: client authentication is requested.
	TLSAuthenticationRequested
	// TLSAuthenticationRequired: client authentication is required.
	TLSAuthenticationRequired
)

func marshalTLSAuthenticationMode(p uintptr) (interface{}, error) {
	return TLSAuthenticationMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSAuthenticationMode.
func (t TLSAuthenticationMode) String() string {
	switch t {
	case TLSAuthenticationNone:
		return "None"
	case TLSAuthenticationRequested:
		return "Requested"
	case TLSAuthenticationRequired:
		return "Required"
	default:
		return fmt.Sprintf("TLSAuthenticationMode(%d)", t)
	}
}

// TLSError: error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TLSError C.gint

const (
	// TLSErrorUnavailable: no TLS provider is available.
	TLSErrorUnavailable TLSError = iota
	// TLSErrorMisc miscellaneous TLS error.
	TLSErrorMisc
	// TLSErrorBadCertificate: certificate presented could not be parsed or
	// failed validation.
	TLSErrorBadCertificate
	// TLSErrorNotTLS: TLS handshake failed because the peer does not seem to be
	// a TLS server.
	TLSErrorNotTLS
	// TLSErrorHandshake: TLS handshake failed because the peer's certificate
	// was not acceptable.
	TLSErrorHandshake
	// TLSErrorCertificateRequired: TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
	TLSErrorCertificateRequired
	// TLSErrorEOF: TLS connection was closed without proper notice, which may
	// indicate an attack. See g_tls_connection_set_require_close_notify().
	TLSErrorEOF
	// TLSErrorInappropriateFallback: TLS handshake failed because the client
	// sent the fallback SCSV, indicating a protocol downgrade attack. Since:
	// 2.60.
	TLSErrorInappropriateFallback
)

func marshalTLSError(p uintptr) (interface{}, error) {
	return TLSError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSError.
func (t TLSError) String() string {
	switch t {
	case TLSErrorUnavailable:
		return "Unavailable"
	case TLSErrorMisc:
		return "Misc"
	case TLSErrorBadCertificate:
		return "BadCertificate"
	case TLSErrorNotTLS:
		return "NotTLS"
	case TLSErrorHandshake:
		return "Handshake"
	case TLSErrorCertificateRequired:
		return "CertificateRequired"
	case TLSErrorEOF:
		return "EOF"
	case TLSErrorInappropriateFallback:
		return "InappropriateFallback"
	default:
		return fmt.Sprintf("TLSError(%d)", t)
	}
}

// TLSRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
//
// Deprecated: Changing the rehandshake mode is no longer required for
// compatibility. Also, rehandshaking has been removed from the TLS protocol in
// TLS 1.3.
type TLSRehandshakeMode C.gint

const (
	// TLSRehandshakeNever: never allow rehandshaking.
	TLSRehandshakeNever TLSRehandshakeMode = iota
	// TLSRehandshakeSafely: allow safe rehandshaking only.
	TLSRehandshakeSafely
	// TLSRehandshakeUnsafely: allow unsafe rehandshaking.
	TLSRehandshakeUnsafely
)

func marshalTLSRehandshakeMode(p uintptr) (interface{}, error) {
	return TLSRehandshakeMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSRehandshakeMode.
func (t TLSRehandshakeMode) String() string {
	switch t {
	case TLSRehandshakeNever:
		return "Never"
	case TLSRehandshakeSafely:
		return "Safely"
	case TLSRehandshakeUnsafely:
		return "Unsafely"
	default:
		return fmt.Sprintf("TLSRehandshakeMode(%d)", t)
	}
}

// ApplicationFlags flags used to define the behaviour of a #GApplication.
type ApplicationFlags C.guint

const (
	// ApplicationFlagsNone: default.
	ApplicationFlagsNone ApplicationFlags = 0b0
	// ApplicationIsService: run as a service. In this mode, registration fails
	// if the service is already running, and the application will initially
	// wait up to 10 seconds for an initial activation message to arrive.
	ApplicationIsService ApplicationFlags = 0b1
	// ApplicationIsLauncher: don't try to become the primary instance.
	ApplicationIsLauncher ApplicationFlags = 0b10
	// ApplicationHandlesOpen: this application handles opening files (in the
	// primary instance). Note that this flag only affects the default
	// implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
	ApplicationHandlesOpen ApplicationFlags = 0b100
	// ApplicationHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
	ApplicationHandlesCommandLine ApplicationFlags = 0b1000
	// ApplicationSendEnvironment: send the environment of the launching process
	// to the primary instance. Set this flag if your application is expected to
	// behave differently depending on certain environment variables. For
	// instance, an editor might be expected to use the GIT_COMMITTER_NAME
	// environment variable when editing a git commit message. The environment
	// is available to the #GApplication::command-line signal handler, via
	// g_application_command_line_getenv().
	ApplicationSendEnvironment ApplicationFlags = 0b10000
	// ApplicationNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID is
	// given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
	ApplicationNonUnique ApplicationFlags = 0b100000
	// ApplicationCanOverrideAppID: allow users to override the application ID
	// from the command line with --gapplication-app-id. Since: 2.48.
	ApplicationCanOverrideAppID ApplicationFlags = 0b1000000
	// ApplicationAllowReplacement: allow another instance to take over the bus
	// name. Since: 2.60.
	ApplicationAllowReplacement ApplicationFlags = 0b10000000
	// ApplicationReplace: take over from another instance. This flag is usually
	// set by passing --gapplication-replace on the commandline. Since: 2.60.
	ApplicationReplace ApplicationFlags = 0b100000000
)

func marshalApplicationFlags(p uintptr) (interface{}, error) {
	return ApplicationFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ApplicationFlags.
func (a ApplicationFlags) String() string {
	if a == 0 {
		return "ApplicationFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(239)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case ApplicationFlagsNone:
			builder.WriteString("FlagsNone|")
		case ApplicationIsService:
			builder.WriteString("IsService|")
		case ApplicationIsLauncher:
			builder.WriteString("IsLauncher|")
		case ApplicationHandlesOpen:
			builder.WriteString("HandlesOpen|")
		case ApplicationHandlesCommandLine:
			builder.WriteString("HandlesCommandLine|")
		case ApplicationSendEnvironment:
			builder.WriteString("SendEnvironment|")
		case ApplicationNonUnique:
			builder.WriteString("NonUnique|")
		case ApplicationCanOverrideAppID:
			builder.WriteString("CanOverrideAppID|")
		case ApplicationAllowReplacement:
			builder.WriteString("AllowReplacement|")
		case ApplicationReplace:
			builder.WriteString("Replace|")
		default:
			builder.WriteString(fmt.Sprintf("ApplicationFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a ApplicationFlags) Has(other ApplicationFlags) bool {
	return (a & other) == other
}

// IOStreamSpliceFlags determine how streams should be spliced.
type IOStreamSpliceFlags C.guint

const (
	// IOStreamSpliceNone: do not close either stream.
	IOStreamSpliceNone IOStreamSpliceFlags = 0b0
	// IOStreamSpliceCloseStream1: close the first stream after the splice.
	IOStreamSpliceCloseStream1 IOStreamSpliceFlags = 0b1
	// IOStreamSpliceCloseStream2: close the second stream after the splice.
	IOStreamSpliceCloseStream2 IOStreamSpliceFlags = 0b10
	// IOStreamSpliceWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
	IOStreamSpliceWaitForBoth IOStreamSpliceFlags = 0b100
)

func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
	return IOStreamSpliceFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for IOStreamSpliceFlags.
func (i IOStreamSpliceFlags) String() string {
	if i == 0 {
		return "IOStreamSpliceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(98)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case IOStreamSpliceNone:
			builder.WriteString("None|")
		case IOStreamSpliceCloseStream1:
			builder.WriteString("CloseStream1|")
		case IOStreamSpliceCloseStream2:
			builder.WriteString("CloseStream2|")
		case IOStreamSpliceWaitForBoth:
			builder.WriteString("WaitForBoth|")
		default:
			builder.WriteString(fmt.Sprintf("IOStreamSpliceFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i IOStreamSpliceFlags) Has(other IOStreamSpliceFlags) bool {
	return (i & other) == other
}

// TLSCertificateFlags: set of flags describing TLS certification validation.
// This can be used to set which validation steps to perform (eg, with
// g_tls_client_connection_set_validation_flags()), or to describe why a
// particular certificate was rejected (eg, in Connection::accept-certificate).
type TLSCertificateFlags C.guint

const (
	// TLSCertificateUnknownCa: signing certificate authority is not known.
	TLSCertificateUnknownCa TLSCertificateFlags = 0b1
	// TLSCertificateBadIdentity: certificate does not match the expected
	// identity of the site that it was retrieved from.
	TLSCertificateBadIdentity TLSCertificateFlags = 0b10
	// TLSCertificateNotActivated certificate's activation time is still in the
	// future.
	TLSCertificateNotActivated TLSCertificateFlags = 0b100
	// TLSCertificateExpired: certificate has expired.
	TLSCertificateExpired TLSCertificateFlags = 0b1000
	// TLSCertificateRevoked: certificate has been revoked according to the
	// Connection's certificate revocation list.
	TLSCertificateRevoked TLSCertificateFlags = 0b10000
	// TLSCertificateInsecure certificate's algorithm is considered insecure.
	TLSCertificateInsecure TLSCertificateFlags = 0b100000
	// TLSCertificateGenericError: some other error occurred validating the
	// certificate.
	TLSCertificateGenericError TLSCertificateFlags = 0b1000000
	// TLSCertificateValidateAll: combination of all of the above flags.
	TLSCertificateValidateAll TLSCertificateFlags = 0b1111111
)

func marshalTLSCertificateFlags(p uintptr) (interface{}, error) {
	return TLSCertificateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TLSCertificateFlags.
func (t TLSCertificateFlags) String() string {
	if t == 0 {
		return "TLSCertificateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(196)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TLSCertificateUnknownCa:
			builder.WriteString("UnknownCa|")
		case TLSCertificateBadIdentity:
			builder.WriteString("BadIdentity|")
		case TLSCertificateNotActivated:
			builder.WriteString("NotActivated|")
		case TLSCertificateExpired:
			builder.WriteString("Expired|")
		case TLSCertificateRevoked:
			builder.WriteString("Revoked|")
		case TLSCertificateInsecure:
			builder.WriteString("Insecure|")
		case TLSCertificateGenericError:
			builder.WriteString("GenericError|")
		case TLSCertificateValidateAll:
			builder.WriteString("ValidateAll|")
		default:
			builder.WriteString(fmt.Sprintf("TLSCertificateFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TLSCertificateFlags) Has(other TLSCertificateFlags) bool {
	return (t & other) == other
}
