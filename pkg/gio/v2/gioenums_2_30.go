// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeIOModuleScopeFlags           = coreglib.Type(C.g_io_module_scope_flags_get_type())
	GTypeTLSDatabaseLookupFlags       = coreglib.Type(C.g_tls_database_lookup_flags_get_type())
	GTypeTLSInteractionResult         = coreglib.Type(C.g_tls_interaction_result_get_type())
	GTypeDBusInterfaceSkeletonFlags   = coreglib.Type(C.g_dbus_interface_skeleton_flags_get_type())
	GTypeDBusObjectManagerClientFlags = coreglib.Type(C.g_dbus_object_manager_client_flags_get_type())
	GTypeTLSDatabaseVerifyFlags       = coreglib.Type(C.g_tls_database_verify_flags_get_type())
	GTypeTLSPasswordFlags             = coreglib.Type(C.g_tls_password_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIOModuleScopeFlags, F: marshalIOModuleScopeFlags},
		coreglib.TypeMarshaler{T: GTypeTLSDatabaseLookupFlags, F: marshalTLSDatabaseLookupFlags},
		coreglib.TypeMarshaler{T: GTypeTLSInteractionResult, F: marshalTLSInteractionResult},
		coreglib.TypeMarshaler{T: GTypeDBusInterfaceSkeletonFlags, F: marshalDBusInterfaceSkeletonFlags},
		coreglib.TypeMarshaler{T: GTypeDBusObjectManagerClientFlags, F: marshalDBusObjectManagerClientFlags},
		coreglib.TypeMarshaler{T: GTypeTLSDatabaseVerifyFlags, F: marshalTLSDatabaseVerifyFlags},
		coreglib.TypeMarshaler{T: GTypeTLSPasswordFlags, F: marshalTLSPasswordFlags},
	})
}

// IOModuleScopeFlags flags for use with g_io_module_scope_new().
type IOModuleScopeFlags C.gint

const (
	// IOModuleScopeNone: no module scan flags.
	IOModuleScopeNone IOModuleScopeFlags = iota
	// IOModuleScopeBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
	IOModuleScopeBlockDuplicates
)

func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
	return IOModuleScopeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IOModuleScopeFlags.
func (i IOModuleScopeFlags) String() string {
	switch i {
	case IOModuleScopeNone:
		return "None"
	case IOModuleScopeBlockDuplicates:
		return "BlockDuplicates"
	default:
		return fmt.Sprintf("IOModuleScopeFlags(%d)", i)
	}
}

// TLSDatabaseLookupFlags flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
type TLSDatabaseLookupFlags C.gint

const (
	// TLSDatabaseLookupNone: no lookup flags.
	TLSDatabaseLookupNone TLSDatabaseLookupFlags = iota
	// TLSDatabaseLookupKeypair: restrict lookup to certificates that have a
	// private key.
	TLSDatabaseLookupKeypair
)

func marshalTLSDatabaseLookupFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseLookupFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSDatabaseLookupFlags.
func (t TLSDatabaseLookupFlags) String() string {
	switch t {
	case TLSDatabaseLookupNone:
		return "None"
	case TLSDatabaseLookupKeypair:
		return "Keypair"
	default:
		return fmt.Sprintf("TLSDatabaseLookupFlags(%d)", t)
	}
}

// TLSInteractionResult is returned by various functions in Interaction when
// finishing an interaction request.
type TLSInteractionResult C.gint

const (
	// TLSInteractionUnhandled: interaction was unhandled (i.e. not
	// implemented).
	TLSInteractionUnhandled TLSInteractionResult = iota
	// TLSInteractionHandled: interaction completed, and resulting data is
	// available.
	TLSInteractionHandled
	// TLSInteractionFailed: interaction has failed, or was cancelled. and the
	// operation should be aborted.
	TLSInteractionFailed
)

func marshalTLSInteractionResult(p uintptr) (interface{}, error) {
	return TLSInteractionResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSInteractionResult.
func (t TLSInteractionResult) String() string {
	switch t {
	case TLSInteractionUnhandled:
		return "Unhandled"
	case TLSInteractionHandled:
		return "Handled"
	case TLSInteractionFailed:
		return "Failed"
	default:
		return fmt.Sprintf("TLSInteractionResult(%d)", t)
	}
}

// DBusInterfaceSkeletonFlags flags describing the behavior of a
// BusInterfaceSkeleton instance.
type DBusInterfaceSkeletonFlags C.guint

const (
	// DBusInterfaceSkeletonFlagsNone: no flags set.
	DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0b0
	// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 0b1
)

func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
	return DBusInterfaceSkeletonFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusInterfaceSkeletonFlags.
func (d DBusInterfaceSkeletonFlags) String() string {
	if d == 0 {
		return "DBusInterfaceSkeletonFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(88)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusInterfaceSkeletonFlagsNone:
			builder.WriteString("None|")
		case DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread:
			builder.WriteString("HandleMethodInvocationsInThread|")
		default:
			builder.WriteString(fmt.Sprintf("DBusInterfaceSkeletonFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusInterfaceSkeletonFlags) Has(other DBusInterfaceSkeletonFlags) bool {
	return (d & other) == other
}

// DBusObjectManagerClientFlags flags used when constructing a
// BusObjectManagerClient.
type DBusObjectManagerClientFlags C.guint

const (
	// DBusObjectManagerClientFlagsNone: no flags set.
	DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0b0
	// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager
	// is for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 0b1
)

func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
	return DBusObjectManagerClientFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusObjectManagerClientFlags.
func (d DBusObjectManagerClientFlags) String() string {
	if d == 0 {
		return "DBusObjectManagerClientFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(75)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusObjectManagerClientFlagsNone:
			builder.WriteString("None|")
		case DBusObjectManagerClientFlagsDoNotAutoStart:
			builder.WriteString("DoNotAutoStart|")
		default:
			builder.WriteString(fmt.Sprintf("DBusObjectManagerClientFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusObjectManagerClientFlags) Has(other DBusObjectManagerClientFlags) bool {
	return (d & other) == other
}

// TLSDatabaseVerifyFlags flags for g_tls_database_verify_chain().
type TLSDatabaseVerifyFlags C.guint

const (
	// TLSDatabaseVerifyNone: no verification flags.
	TLSDatabaseVerifyNone TLSDatabaseVerifyFlags = 0b0
)

func marshalTLSDatabaseVerifyFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseVerifyFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TLSDatabaseVerifyFlags.
func (t TLSDatabaseVerifyFlags) String() string {
	if t == 0 {
		return "TLSDatabaseVerifyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(21)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TLSDatabaseVerifyNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("TLSDatabaseVerifyFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TLSDatabaseVerifyFlags) Has(other TLSDatabaseVerifyFlags) bool {
	return (t & other) == other
}

// TLSPasswordFlags various flags for the password.
type TLSPasswordFlags C.guint

const (
	// TLSPasswordNone: no flags.
	TLSPasswordNone TLSPasswordFlags = 0b0
	// TLSPasswordRetry: password was wrong, and the user should retry.
	TLSPasswordRetry TLSPasswordFlags = 0b10
	// TLSPasswordManyTries: hint to the user that the password has been wrong
	// many times, and the user may not have many chances left.
	TLSPasswordManyTries TLSPasswordFlags = 0b100
	// TLSPasswordFinalTry: hint to the user that this is the last try to get
	// this password right.
	TLSPasswordFinalTry TLSPasswordFlags = 0b1000
)

func marshalTLSPasswordFlags(p uintptr) (interface{}, error) {
	return TLSPasswordFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TLSPasswordFlags.
func (t TLSPasswordFlags) String() string {
	if t == 0 {
		return "TLSPasswordFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(73)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TLSPasswordNone:
			builder.WriteString("None|")
		case TLSPasswordRetry:
			builder.WriteString("Retry|")
		case TLSPasswordManyTries:
			builder.WriteString("ManyTries|")
		case TLSPasswordFinalTry:
			builder.WriteString("FinalTry|")
		default:
			builder.WriteString(fmt.Sprintf("TLSPasswordFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TLSPasswordFlags) Has(other TLSPasswordFlags) bool {
	return (t & other) == other
}
