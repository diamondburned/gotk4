// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_settings_get_type()), F: marshalSettings},
	})
}

// SettingsBindGetMapping: the type for the function that is used to convert
// from #GSettings to an object property. The @value is already initialized to
// hold values of the appropriate type.
type SettingsBindGetMapping func() (ok bool)

//export gotk4_SettingsBindGetMapping
func gotk4_SettingsBindGetMapping(arg0 *C.GValue, arg1 *C.GVariant, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(SettingsBindGetMapping)
	ok := fn()

	if ok {
		cret = C.gboolean(1)
	}
}

// SettingsBindSetMapping: the type for the function that is used to convert an
// object property value to a #GVariant for storing it in #GSettings.
type SettingsBindSetMapping func() (variant *glib.Variant)

//export gotk4_SettingsBindSetMapping
func gotk4_SettingsBindSetMapping(arg0 *C.GValue, arg1 *C.GVariantType, arg2 C.gpointer) *C.GVariant {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(SettingsBindSetMapping)
	variant := fn()

	cret = (*C.GVariant)(unsafe.Pointer(variant.Native()))
}

// SettingsGetMapping: the type of the function that is used to convert from a
// value stored in a #GSettings to a value that is useful to the application.
//
// If the value is successfully mapped, the result should be stored at @result
// and true returned. If mapping fails (for example, if @value is not in the
// right format) then false should be returned.
//
// If @value is nil then it means that the mapping function is being given a
// "last chance" to successfully return a valid value. true must be returned in
// this case.
type SettingsGetMapping func() (result interface{}, ok bool)

//export gotk4_SettingsGetMapping
func gotk4_SettingsGetMapping(arg0 *C.GVariant, arg1 *C.gpointer, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(SettingsGetMapping)
	result, ok := fn()

	arg1 = *C.gpointer(result)
	if ok {
		cret = C.gboolean(1)
	}
}

// Settings: the #GSettings class provides a convenient API for storing and
// retrieving application settings.
//
// Reads and writes can be considered to be non-blocking. Reading settings with
// #GSettings is typically extremely fast: on approximately the same order of
// magnitude (but slower than) a Table lookup. Writing settings is also
// extremely fast in terms of time to return to your application, but can be
// extremely expensive for other threads and other processes. Many settings
// backends (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings a lot of
// work can be avoided. For dconf, the D-Bus service doesn't even need to be
// started in this case. For this reason, you should only ever modify #GSettings
// keys in response to explicit user action. Particular care should be paid to
// ensure that modifications are not made during startup -- for example, when
// setting the initial value of preferences widgets. The built-in
// g_settings_bind() functionality is careful not to write settings in response
// to notify signals as a result of modifications that it makes to widgets.
//
// When creating a GSettings instance, you have to specify a schema that
// describes the keys in your settings and their types and default values, as
// well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings are
// stored in the conceptual global tree of settings. However, schemas can also
// be '[relocatable][gsettings-relocatable]', i.e. not equipped with a fixed
// path. This is useful e.g. when the schema describes an 'account', and you
// want to be able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character ('/') and must
// not contain two sequential slash characters. Paths should be chosen based on
// a domain name associated with the program or library to which the settings
// belong. Examples of paths are "/org/gtk/settings/file-chooser/" and
// "/ca/desrt/dconf-editor/". Paths should not start with "/apps/", "/desktop/"
// or "/system/" as they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not restrict
// keys to basic types like strings and numbers. GSettings stores values as
// #GVariant, and allows any Type for keys. Key names are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be localized,
// but the localized values are stored in gettext catalogs and looked up with
// the domain that is specified in the `gettext-domain` attribute of the
// <schemalist> or <schema> elements and the category that is specified in the
// `l10n` attribute of the <default> element. The string which is translated
// includes all text in the <default> element, including any surrounding
// quotation marks.
//
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the <default> element â€” it is recommended to
// add these comments to aid translators understand the meaning and implications
// of the default value. An optional translation `context` attribute can be set
// on the <default> element to disambiguate multiple defaults which use the same
// string.
//
// For example:
//
//    <!-- Translators: A list of words which are not allowed to be typed, in
//         GVariant serialization syntax.
//         See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
//    <default l10n='messages' context='Banned words'>['bad', 'words']</default>
//
// Translations of default values must remain syntactically valid serialized
// #GVariants (e.g. retaining any surrounding quotation marks) or runtime errors
// will occur.
//
// GSettings uses schemas in a compact binary form that is created by the
// [glib-compile-schemas][glib-compile-schemas] utility. The input is a schema
// description in an XML format.
//
// A DTD for the gschema XML format can be found here: gschema.dtd
// (https://git.gnome.org/browse/glib/tree/gio/gschema.dtd)
//
// The [glib-compile-schemas][glib-compile-schemas] tool expects schema files to
// have the extension `.gschema.xml`.
//
// At runtime, schemas are identified by their id (as specified in the id
// attribute of the <schema> element). The convention for schema ids is to use a
// dotted name, similar in style to a D-Bus bus name, e.g.
// "org.gnome.SessionManager". In particular, if the settings are for a specific
// service that owns a D-Bus bus name, the D-Bus bus name and schema id should
// match. For schemas which deal with settings not associated with one named
// application, the id should not use StudlyCaps, e.g.
// "org.gnome.font-rendering".
//
// In addition to #GVariant types, keys can have types that have enumerated
// types. These can be described by a <choice>, <enum> or <flags> element, as
// seen in the [example][schema-enumerated]. The underlying type of such a key
// is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
// g_settings_get_flags(), g_settings_set_flags() access the numeric values
// corresponding to the string value of enum and flags keys.
//
// An example for default value:
//
//    <schemalist>
//      <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
//
//        <key name="greeting" type="s">
//          <default l10n="messages">"Hello, earthlings"</default>
//          <summary>A greeting</summary>
//          <description>
//            Greeting of the invading martians
//          </description>
//        </key>
//
//        <key name="box" type="(ii)">
//          <default>(20,30)</default>
//        </key>
//
//        <key name="empty-string" type="s">
//          <default>""</default>
//          <summary>Empty strings have to be provided in GVariant form</summary>
//        </key>
//
//      </schema>
//    </schemalist>
//
// An example for ranges, choices and enumerated types:
//
//    <schemalist>
//
//      <enum id="org.gtk.Test.myenum">
//        <value nick="first" value="1"/>
//        <value nick="second" value="2"/>
//      </enum>
//
//      <flags id="org.gtk.Test.myflags">
//        <value nick="flag1" value="1"/>
//        <value nick="flag2" value="2"/>
//        <value nick="flag3" value="4"/>
//      </flags>
//
//      <schema id="org.gtk.Test">
//
//        <key name="key-with-range" type="i">
//          <range min="1" max="100"/>
//          <default>10</default>
//        </key>
//
//        <key name="key-with-choices" type="s">
//          <choices>
//            <choice value='Elisabeth'/>
//            <choice value='Annabeth'/>
//            <choice value='Joe'/>
//          </choices>
//          <aliases>
//            <alias value='Anna' target='Annabeth'/>
//            <alias value='Beth' target='Elisabeth'/>
//          </aliases>
//          <default>'Joe'</default>
//        </key>
//
//        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
//          <default>'first'</default>
//        </key>
//
//        <key name='flags-key' flags='org.gtk.Test.myflags'>
//          <default>["flag1","flag2"]</default>
//        </key>
//      </schema>
//    </schemalist>
//
//
// Vendor overrides
//
// Default values are defined in the schemas that get installed by an
// application. Sometimes, it is necessary for a vendor or distributor to adjust
// these defaults. Since patching the XML source for the schema is inconvenient
// and error-prone, [glib-compile-schemas][glib-compile-schemas] reads so-called
// vendor override' files. These are keyfiles in the same directory as the XML
// schema sources which can override default values. The schema id serves as the
// group name in the key file, and the values are expected in serialized
// GVariant form, as in the following example:
//
//    [org.gtk.Example]
//    key1='string'
//    key2=1.5
//
// glib-compile-schemas expects schema files to have the extension
// `.gschema.override`.
//
//
// Binding
//
// A very convenient feature of GSettings lets you bind #GObject properties
// directly to settings, using g_settings_bind(). Once a GObject property has
// been bound to a setting, changes on either side are automatically propagated
// to the other side. GSettings handles details like mapping between GObject and
// GVariant types, and preventing infinite cycles.
//
// This makes it very easy to hook up a preferences dialog to the underlying
// settings. To make this even more convenient, GSettings looks for a boolean
// property with the name "sensitivity" and automatically binds it to the
// writability of the bound setting. If this 'magic' gets in the way, it can be
// suppressed with the SETTINGS_BIND_NO_SENSITIVITY flag.
//
//
// Relocatable schemas
//
// A relocatable schema is one with no `path` attribute specified on its
// <schema> element. By using g_settings_new_with_path(), a #GSettings object
// can be instantiated for a relocatable schema, assigning a path to the
// instance. Paths passed to g_settings_new_with_path() will typically be
// constructed dynamically from a constant prefix plus some form of instance
// identifier; but they must still be valid GSettings paths. Paths could also be
// constant and used with a globally installed schema originating from a
// dependency library.
//
// For example, a relocatable schema could be used to store geometry information
// for different windows in an application. If the schema ID was
// `org.foo.MyApp.Window`, it could be instantiated for paths
// `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
// `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known they
// can be specified as <child> elements in the parent schema, e.g.:
//
//    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
//      <child name="main" schema="org.foo.MyApp.Window"/>
//    </schema>
//
//
// Build system integration
//
// GSettings comes with autotools integration to simplify compiling and
// installing schemas. To add GSettings support to an application, add the
// following to your `configure.ac`:
//
//    GLIB_GSETTINGS
//
// In the appropriate `Makefile.am`, use the following snippet to compile and
// install the named schema:
//
//    gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
//    EXTRA_DIST = $(gsettings_SCHEMAS)
//
//    @GSETTINGS_RULES@
//
// No changes are needed to the build system to mark a schema XML file for
// translation. Assuming it sets the `gettext-domain` attribute, a schema may be
// marked for translation by adding it to `POTFILES.in`, assuming gettext 0.19
// is in use (the preferred method for translation):
//
//    data/org.foo.MyApp.gschema.xml
//
// Alternatively, if intltool 0.50.1 is in use:
//
//    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
//
// GSettings will use gettext to look up translations for the <summary> and
// <description> elements, and also any <default> elements which have a `l10n`
// attribute set. Translations must not be included in the `.gschema.xml` file
// by the build system, for example by using intltool XML rules with a
// `.gschema.xml.in` template.
//
// If an enumerated type defined in a C header file is to be used in a GSettings
// schema, it can either be defined manually using an <enum> element in the
// schema XML, or it can be extracted automatically from the C header. This
// approach is preferred, as it ensures the two representations are always
// synchronised. To do so, add the following to the relevant `Makefile.am`:
//
//    gsettings_ENUM_NAMESPACE = org.foo.MyApp
//    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
//
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
type Settings interface {
	gextras.Objector

	// Apply applies any changes that have been made to the settings. This
	// function does nothing unless @settings is in 'delay-apply' mode; see
	// g_settings_delay(). In the normal case settings are always applied
	// immediately.
	Apply()
	// Bind: create a binding between the @key in the @settings object and the
	// property @property of @object.
	//
	// The binding uses the default GIO mapping functions to map between the
	// settings and property values. These functions handle booleans, numeric
	// types and string types in a straightforward way. Use
	// g_settings_bind_with_mapping() if you need a custom mapping, or map
	// between types that are not supported by the default mapping functions.
	//
	// Unless the @flags include G_SETTINGS_BIND_NO_SENSITIVITY, this function
	// also establishes a binding between the writability of @key and the
	// "sensitive" property of @object (if @object has a boolean property by
	// that name). See g_settings_bind_writable() for more details about
	// writable bindings.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	Bind(key string, object gextras.Objector, property string, flags SettingsBindFlags)
	// BindWithMapping: create a binding between the @key in the @settings
	// object and the property @property of @object.
	//
	// The binding uses the provided mapping functions to map between settings
	// and property values.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	BindWithMapping()
	// BindWritable: create a binding between the writability of @key in the
	// @settings object and the property @property of @object. The property must
	// be boolean; "sensitive" or "visible" properties of widgets are the most
	// likely candidates.
	//
	// Writable bindings are always uni-directional; changes of the writability
	// of the setting will be propagated to the object property, not the other
	// way.
	//
	// When the @inverted argument is true, the binding inverts the value as it
	// passes from the setting to the object, i.e. @property will be set to true
	// if the key is not writable.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	BindWritable(key string, object gextras.Objector, property string, inverted bool)
	// CreateAction creates a #GAction corresponding to a given #GSettings key.
	//
	// The action has the same name as the key.
	//
	// The value of the key becomes the state of the action and the action is
	// enabled when the key is writable. Changing the state of the action
	// results in the key being written to. Changes to the value or writability
	// of the key cause appropriate change notifications to be emitted for the
	// action.
	//
	// For boolean-valued keys, action activations take no parameter and result
	// in the toggling of the value. For all other types, activations take the
	// new value for the key (which must have the correct type).
	CreateAction(key string) Action
	// Delay changes the #GSettings object into 'delay-apply' mode. In this
	// mode, changes to @settings are not immediately propagated to the backend,
	// but kept locally until g_settings_apply() is called.
	Delay()
	// Boolean gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for booleans.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// boolean type in the schema for @settings.
	Boolean(key string) bool
	// Child creates a child settings object which has a base path of
	// `base-path/@name`, where `base-path` is the base path of @settings.
	//
	// The schema for the child settings object must have been declared in the
	// schema of @settings using a <child> element.
	Child(name string) Settings
	// DefaultValue gets the "default value" of a key.
	//
	// This is the value that would be read if g_settings_reset() were to be
	// called on the key.
	//
	// Note that this may be a different value than returned by
	// g_settings_schema_key_get_default_value() if the system administrator has
	// provided a default value.
	//
	// Comparing the return values of g_settings_get_default_value() and
	// g_settings_get_value() is not sufficient for determining if a value has
	// been set because the user may have explicitly set the value to something
	// that happens to be equal to the default. The difference here is that if
	// the default changes in the future, the user's key will still be set.
	//
	// This function may be useful for adding an indication to a UI of what the
	// default value was before the user set it.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	DefaultValue(key string) *glib.Variant
	// Double gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for doubles.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// 'double' type in the schema for @settings.
	Double(key string) float64
	// Enum gets the value that is stored in @settings for @key and converts it
	// to the enum value that it represents.
	//
	// In order to use this function the type of the value must be a string and
	// it must be marked in the schema file as an enumerated type.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as an enumerated type.
	//
	// If the value stored in the configuration database is not a valid value
	// for the enumerated type then this function will return the default value.
	Enum(key string) int
	// Flags gets the value that is stored in @settings for @key and converts it
	// to the flags value that it represents.
	//
	// In order to use this function the type of the value must be an array of
	// strings and it must be marked in the schema file as a flags type.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as a flags type.
	//
	// If the value stored in the configuration database is not a valid value
	// for the flags type then this function will return the default value.
	Flags(key string) uint
	// HasUnapplied returns whether the #GSettings object has any unapplied
	// changes. This can only be the case if it is in 'delayed-apply' mode.
	HasUnapplied() bool
	// Int gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 32-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int32 type in the schema for @settings.
	Int(key string) int
	// Int64 gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 64-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int64 type in the schema for @settings.
	Int64(key string) int64
	// Mapped gets the value that is stored at @key in @settings, subject to
	// application-level validation/mapping.
	//
	// You should use this function when the application needs to perform some
	// processing on the value of the key (for example, parsing). The @mapping
	// function performs that processing. If the function indicates that the
	// processing was unsuccessful (due to a parse error, for example) then the
	// mapping is tried again with another value.
	//
	// This allows a robust 'fall back to defaults' behaviour to be implemented
	// somewhat automatically.
	//
	// The first value that is tried is the user's setting for the key. If the
	// mapping function fails to map this value, other values may be tried in an
	// unspecified order (system or site defaults, translated schema default
	// values, untranslated schema default values, etc).
	//
	// If the mapping function fails for all possible values, one additional
	// attempt is made: the mapping function is called with a nil value. If the
	// mapping function still indicates failure at this point then the
	// application will be aborted.
	//
	// The result parameter for the @mapping function is pointed to a #gpointer
	// which is initially set to nil. The same pointer is given to each
	// invocation of @mapping. The final value of that #gpointer is what is
	// returned by this function. nil is valid; it is returned just as any other
	// value would be.
	Mapped() interface{}
	// Range queries the range of a key.
	Range(key string) *glib.Variant
	// String gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for strings.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// string type in the schema for @settings.
	String(key string) string
	// Strv: a convenience variant of g_settings_get() for string arrays.
	//
	// It is a programmer error to give a @key that isn't specified as having an
	// array of strings type in the schema for @settings.
	Strv(key string) []string
	// Uint gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 32-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint32 type in the schema for @settings.
	Uint(key string) uint
	// Uint64 gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 64-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint64 type in the schema for @settings.
	Uint64(key string) uint64
	// UserValue checks the "user value" of a key, if there is one.
	//
	// The user value of a key is the last value that was set by the user.
	//
	// After calling g_settings_reset() this function should always return nil
	// (assuming something is not wrong with the system configuration).
	//
	// It is possible that g_settings_get_value() will return a different value
	// than this function. This can happen in the case that the user set a value
	// for a key that was subsequently locked down by the system administrator
	// -- this function will return the user's old value.
	//
	// This function may be useful for adding a "reset" option to a UI or for
	// providing indication that a particular value has been changed.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	UserValue(key string) *glib.Variant
	// Value gets the value that is stored in @settings for @key.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	Value(key string) *glib.Variant
	// IsWritable finds out if a key can be written or not
	IsWritable(name string) bool
	// ListChildren gets the list of children on @settings.
	//
	// The list is exactly the list of strings for which it is not an error to
	// call g_settings_get_child().
	//
	// There is little reason to call this function from "normal" code, since
	// you should already know what children are in your schema. This function
	// may still be useful there for introspection reasons, however.
	//
	// You should free the return value with g_strfreev() when you are done with
	// it.
	ListChildren() []string
	// ListKeys introspects the list of keys on @settings.
	//
	// You should probably not be calling this function from "normal" code
	// (since you should already know what keys are in your schema). This
	// function is intended for introspection reasons.
	//
	// You should free the return value with g_strfreev() when you are done with
	// it.
	ListKeys() []string
	// RangeCheck checks if the given @value is of the correct type and within
	// the permitted range for @key.
	RangeCheck(key string, value *glib.Variant) bool
	// Reset resets @key to its default value.
	//
	// This call resets the key, as much as possible, to its default value. That
	// might be the value specified in the schema or the one set by the
	// administrator.
	Reset(key string)
	// Revert reverts all non-applied changes to the settings. This function
	// does nothing unless @settings is in 'delay-apply' mode; see
	// g_settings_delay(). In the normal case settings are always applied
	// immediately.
	//
	// Change notifications will be emitted for affected keys.
	Revert()
	// SetBoolean sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for booleans.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// boolean type in the schema for @settings.
	SetBoolean(key string, value bool) bool
	// SetDouble sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for doubles.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// 'double' type in the schema for @settings.
	SetDouble(key string, value float64) bool
	// SetEnum looks up the enumerated type nick for @value and writes it to
	// @key, within @settings.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as an enumerated type, or for
	// @value not to be a valid value for the named type.
	//
	// After performing the write, accessing @key directly with
	// g_settings_get_string() will return the 'nick' associated with @value.
	SetEnum(key string, value int) bool
	// SetFlags looks up the flags type nicks for the bits specified by @value,
	// puts them in an array of strings and writes the array to @key, within
	// @settings.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as a flags type, or for @value to
	// contain any bits that are not value for the named type.
	//
	// After performing the write, accessing @key directly with
	// g_settings_get_strv() will return an array of 'nicks'; one for each bit
	// in @value.
	SetFlags(key string, value uint) bool
	// SetInt sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 32-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int32 type in the schema for @settings.
	SetInt(key string, value int) bool
	// SetInt64 sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 64-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int64 type in the schema for @settings.
	SetInt64(key string, value int64) bool
	// SetString sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for strings.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// string type in the schema for @settings.
	SetString(key string, value string) bool
	// SetStrv sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for string arrays. If @value is
	// nil, then @key is set to be the empty array.
	//
	// It is a programmer error to give a @key that isn't specified as having an
	// array of strings type in the schema for @settings.
	SetStrv(key string, value []string) bool
	// SetUint sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 32-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint32 type in the schema for @settings.
	SetUint(key string, value uint) bool
	// SetUint64 sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 64-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint64 type in the schema for @settings.
	SetUint64(key string, value uint64) bool
	// SetValue sets @key in @settings to @value.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or for @value to have the incorrect type, per the
	// schema.
	//
	// If @value is floating then this function consumes the reference.
	SetValue(key string, value *glib.Variant) bool
}

// settings implements the Settings interface.
type settings struct {
	gextras.Objector
}

var _ Settings = (*settings)(nil)

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return Settings{
		Objector: obj,
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

// NewSettings constructs a class Settings.
func NewSettings(schemaId string) Settings {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(schemaId))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GSettings

	cret = C.g_settings_new(arg1)

	var settings Settings

	settings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Settings)

	return settings
}

// NewSettingsFull constructs a class Settings.
func NewSettingsFull(schema *SettingsSchema, backend SettingsBackend, path string) Settings {
	var arg1 *C.GSettingsSchema
	var arg2 *C.GSettingsBackend
	var arg3 *C.gchar

	arg1 = (*C.GSettingsSchema)(unsafe.Pointer(schema.Native()))
	arg2 = (*C.GSettingsBackend)(unsafe.Pointer(backend.Native()))
	arg3 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg3))

	var cret C.GSettings

	cret = C.g_settings_new_full(arg1, arg2, arg3)

	var settings Settings

	settings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Settings)

	return settings
}

// NewSettingsWithBackend constructs a class Settings.
func NewSettingsWithBackend(schemaId string, backend SettingsBackend) Settings {
	var arg1 *C.gchar
	var arg2 *C.GSettingsBackend

	arg1 = (*C.gchar)(C.CString(schemaId))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GSettingsBackend)(unsafe.Pointer(backend.Native()))

	var cret C.GSettings

	cret = C.g_settings_new_with_backend(arg1, arg2)

	var settings Settings

	settings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Settings)

	return settings
}

// NewSettingsWithBackendAndPath constructs a class Settings.
func NewSettingsWithBackendAndPath(schemaId string, backend SettingsBackend, path string) Settings {
	var arg1 *C.gchar
	var arg2 *C.GSettingsBackend
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(schemaId))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GSettingsBackend)(unsafe.Pointer(backend.Native()))
	arg3 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg3))

	var cret C.GSettings

	cret = C.g_settings_new_with_backend_and_path(arg1, arg2, arg3)

	var settings Settings

	settings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Settings)

	return settings
}

// NewSettingsWithPath constructs a class Settings.
func NewSettingsWithPath(schemaId string, path string) Settings {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(schemaId))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.GSettings

	cret = C.g_settings_new_with_path(arg1, arg2)

	var settings Settings

	settings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Settings)

	return settings
}

// Apply applies any changes that have been made to the settings. This
// function does nothing unless @settings is in 'delay-apply' mode; see
// g_settings_delay(). In the normal case settings are always applied
// immediately.
func (s settings) Apply() {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	C.g_settings_apply(arg0)
}

// Bind: create a binding between the @key in the @settings object and the
// property @property of @object.
//
// The binding uses the default GIO mapping functions to map between the
// settings and property values. These functions handle booleans, numeric
// types and string types in a straightforward way. Use
// g_settings_bind_with_mapping() if you need a custom mapping, or map
// between types that are not supported by the default mapping functions.
//
// Unless the @flags include G_SETTINGS_BIND_NO_SENSITIVITY, this function
// also establishes a binding between the writability of @key and the
// "sensitive" property of @object (if @object has a boolean property by
// that name). See g_settings_bind_writable() for more details about
// writable bindings.
//
// Note that the lifecycle of the binding is tied to @object, and that you
// can have only one binding per object property. If you bind the same
// property twice on the same object, the second binding overrides the first
// one.
func (s settings) Bind(key string, object gextras.Objector, property string, flags SettingsBindFlags) {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gpointer
	var arg3 *C.gchar
	var arg4 C.GSettingsBindFlags

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
	arg3 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (C.GSettingsBindFlags)(flags)

	C.g_settings_bind(arg0, arg1, arg2, arg3, arg4)
}

// BindWithMapping: create a binding between the @key in the @settings
// object and the property @property of @object.
//
// The binding uses the provided mapping functions to map between settings
// and property values.
//
// Note that the lifecycle of the binding is tied to @object, and that you
// can have only one binding per object property. If you bind the same
// property twice on the same object, the second binding overrides the first
// one.
func (s settings) BindWithMapping() {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	C.g_settings_bind_with_mapping(arg0)
}

// BindWritable: create a binding between the writability of @key in the
// @settings object and the property @property of @object. The property must
// be boolean; "sensitive" or "visible" properties of widgets are the most
// likely candidates.
//
// Writable bindings are always uni-directional; changes of the writability
// of the setting will be propagated to the object property, not the other
// way.
//
// When the @inverted argument is true, the binding inverts the value as it
// passes from the setting to the object, i.e. @property will be set to true
// if the key is not writable.
//
// Note that the lifecycle of the binding is tied to @object, and that you
// can have only one binding per object property. If you bind the same
// property twice on the same object, the second binding overrides the first
// one.
func (s settings) BindWritable(key string, object gextras.Objector, property string, inverted bool) {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gpointer
	var arg3 *C.gchar
	var arg4 C.gboolean

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
	arg3 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg3))
	if inverted {
		arg4 = C.gboolean(1)
	}

	C.g_settings_bind_writable(arg0, arg1, arg2, arg3, arg4)
}

// CreateAction creates a #GAction corresponding to a given #GSettings key.
//
// The action has the same name as the key.
//
// The value of the key becomes the state of the action and the action is
// enabled when the key is writable. Changing the state of the action
// results in the key being written to. Changes to the value or writability
// of the key cause appropriate change notifications to be emitted for the
// action.
//
// For boolean-valued keys, action activations take no parameter and result
// in the toggling of the value. For all other types, activations take the
// new value for the key (which must have the correct type).
func (s settings) CreateAction(key string) Action {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GAction

	cret = C.g_settings_create_action(arg0, arg1)

	var action Action

	action = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Action)

	return action
}

// Delay changes the #GSettings object into 'delay-apply' mode. In this
// mode, changes to @settings are not immediately propagated to the backend,
// but kept locally until g_settings_apply() is called.
func (s settings) Delay() {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	C.g_settings_delay(arg0)
}

// Boolean gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for booleans.
//
// It is a programmer error to give a @key that isn't specified as having a
// boolean type in the schema for @settings.
func (s settings) Boolean(key string) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean

	cret = C.g_settings_get_boolean(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Child creates a child settings object which has a base path of
// `base-path/@name`, where `base-path` is the base path of @settings.
//
// The schema for the child settings object must have been declared in the
// schema of @settings using a <child> element.
func (s settings) Child(name string) Settings {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GSettings

	cret = C.g_settings_get_child(arg0, arg1)

	var ret Settings

	ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Settings)

	return ret
}

// DefaultValue gets the "default value" of a key.
//
// This is the value that would be read if g_settings_reset() were to be
// called on the key.
//
// Note that this may be a different value than returned by
// g_settings_schema_key_get_default_value() if the system administrator has
// provided a default value.
//
// Comparing the return values of g_settings_get_default_value() and
// g_settings_get_value() is not sufficient for determining if a value has
// been set because the user may have explicitly set the value to something
// that happens to be equal to the default. The difference here is that if
// the default changes in the future, the user's key will still be set.
//
// This function may be useful for adding an indication to a UI of what the
// default value was before the user set it.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings.
func (s settings) DefaultValue(key string) *glib.Variant {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GVariant

	cret = C.g_settings_get_default_value(arg0, arg1)

	var variant *glib.Variant

	variant = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return variant
}

// Double gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for doubles.
//
// It is a programmer error to give a @key that isn't specified as having a
// 'double' type in the schema for @settings.
func (s settings) Double(key string) float64 {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gdouble

	cret = C.g_settings_get_double(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// Enum gets the value that is stored in @settings for @key and converts it
// to the enum value that it represents.
//
// In order to use this function the type of the value must be a string and
// it must be marked in the schema file as an enumerated type.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as an enumerated type.
//
// If the value stored in the configuration database is not a valid value
// for the enumerated type then this function will return the default value.
func (s settings) Enum(key string) int {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gint

	cret = C.g_settings_get_enum(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// Flags gets the value that is stored in @settings for @key and converts it
// to the flags value that it represents.
//
// In order to use this function the type of the value must be an array of
// strings and it must be marked in the schema file as a flags type.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as a flags type.
//
// If the value stored in the configuration database is not a valid value
// for the flags type then this function will return the default value.
func (s settings) Flags(key string) uint {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.guint

	cret = C.g_settings_get_flags(arg0, arg1)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// HasUnapplied returns whether the #GSettings object has any unapplied
// changes. This can only be the case if it is in 'delayed-apply' mode.
func (s settings) HasUnapplied() bool {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.g_settings_get_has_unapplied(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Int gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 32-bit integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// int32 type in the schema for @settings.
func (s settings) Int(key string) int {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gint

	cret = C.g_settings_get_int(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// Int64 gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 64-bit integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// int64 type in the schema for @settings.
func (s settings) Int64(key string) int64 {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gint64

	cret = C.g_settings_get_int64(arg0, arg1)

	var gint64 int64

	gint64 = (int64)(cret)

	return gint64
}

// Mapped gets the value that is stored at @key in @settings, subject to
// application-level validation/mapping.
//
// You should use this function when the application needs to perform some
// processing on the value of the key (for example, parsing). The @mapping
// function performs that processing. If the function indicates that the
// processing was unsuccessful (due to a parse error, for example) then the
// mapping is tried again with another value.
//
// This allows a robust 'fall back to defaults' behaviour to be implemented
// somewhat automatically.
//
// The first value that is tried is the user's setting for the key. If the
// mapping function fails to map this value, other values may be tried in an
// unspecified order (system or site defaults, translated schema default
// values, untranslated schema default values, etc).
//
// If the mapping function fails for all possible values, one additional
// attempt is made: the mapping function is called with a nil value. If the
// mapping function still indicates failure at this point then the
// application will be aborted.
//
// The result parameter for the @mapping function is pointed to a #gpointer
// which is initially set to nil. The same pointer is given to each
// invocation of @mapping. The final value of that #gpointer is what is
// returned by this function. nil is valid; it is returned just as any other
// value would be.
func (s settings) Mapped() interface{} {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	var cret C.gpointer

	cret = C.g_settings_get_mapped(arg0)

	var gpointer interface{}

	gpointer = (interface{})(cret)

	return gpointer
}

// Range queries the range of a key.
func (s settings) Range(key string) *glib.Variant {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GVariant

	cret = C.g_settings_get_range(arg0, arg1)

	var variant *glib.Variant

	variant = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return variant
}

// String gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for strings.
//
// It is a programmer error to give a @key that isn't specified as having a
// string type in the schema for @settings.
func (s settings) String(key string) string {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar

	cret = C.g_settings_get_string(arg0, arg1)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// Strv: a convenience variant of g_settings_get() for string arrays.
//
// It is a programmer error to give a @key that isn't specified as having an
// array of strings type in the schema for @settings.
func (s settings) Strv(key string) []string {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret **C.gchar

	cret = C.g_settings_get_strv(arg0, arg1)

	var utf8s []string

	{
		var length int
		for p := cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		utf8s = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			utf8s = C.GoString(cret)
			defer C.free(unsafe.Pointer(cret))
		}
	}

	return utf8s
}

// Uint gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 32-bit unsigned integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// uint32 type in the schema for @settings.
func (s settings) Uint(key string) uint {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.guint

	cret = C.g_settings_get_uint(arg0, arg1)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// Uint64 gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 64-bit unsigned integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// uint64 type in the schema for @settings.
func (s settings) Uint64(key string) uint64 {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.guint64

	cret = C.g_settings_get_uint64(arg0, arg1)

	var guint64 uint64

	guint64 = (uint64)(cret)

	return guint64
}

// UserValue checks the "user value" of a key, if there is one.
//
// The user value of a key is the last value that was set by the user.
//
// After calling g_settings_reset() this function should always return nil
// (assuming something is not wrong with the system configuration).
//
// It is possible that g_settings_get_value() will return a different value
// than this function. This can happen in the case that the user set a value
// for a key that was subsequently locked down by the system administrator
// -- this function will return the user's old value.
//
// This function may be useful for adding a "reset" option to a UI or for
// providing indication that a particular value has been changed.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings.
func (s settings) UserValue(key string) *glib.Variant {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GVariant

	cret = C.g_settings_get_user_value(arg0, arg1)

	var variant *glib.Variant

	variant = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return variant
}

// Value gets the value that is stored in @settings for @key.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings.
func (s settings) Value(key string) *glib.Variant {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GVariant

	cret = C.g_settings_get_value(arg0, arg1)

	var variant *glib.Variant

	variant = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return variant
}

// IsWritable finds out if a key can be written or not
func (s settings) IsWritable(name string) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean

	cret = C.g_settings_is_writable(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ListChildren gets the list of children on @settings.
//
// The list is exactly the list of strings for which it is not an error to
// call g_settings_get_child().
//
// There is little reason to call this function from "normal" code, since
// you should already know what children are in your schema. This function
// may still be useful there for introspection reasons, however.
//
// You should free the return value with g_strfreev() when you are done with
// it.
func (s settings) ListChildren() []string {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	var cret **C.gchar

	cret = C.g_settings_list_children(arg0)

	var utf8s []string

	{
		var length int
		for p := cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		utf8s = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			utf8s = C.GoString(cret)
			defer C.free(unsafe.Pointer(cret))
		}
	}

	return utf8s
}

// ListKeys introspects the list of keys on @settings.
//
// You should probably not be calling this function from "normal" code
// (since you should already know what keys are in your schema). This
// function is intended for introspection reasons.
//
// You should free the return value with g_strfreev() when you are done with
// it.
func (s settings) ListKeys() []string {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	var cret **C.gchar

	cret = C.g_settings_list_keys(arg0)

	var utf8s []string

	{
		var length int
		for p := cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		utf8s = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			utf8s = C.GoString(cret)
			defer C.free(unsafe.Pointer(cret))
		}
	}

	return utf8s
}

// RangeCheck checks if the given @value is of the correct type and within
// the permitted range for @key.
func (s settings) RangeCheck(key string, value *glib.Variant) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	var cret C.gboolean

	cret = C.g_settings_range_check(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Reset resets @key to its default value.
//
// This call resets the key, as much as possible, to its default value. That
// might be the value specified in the schema or the one set by the
// administrator.
func (s settings) Reset(key string) {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.g_settings_reset(arg0, arg1)
}

// Revert reverts all non-applied changes to the settings. This function
// does nothing unless @settings is in 'delay-apply' mode; see
// g_settings_delay(). In the normal case settings are always applied
// immediately.
//
// Change notifications will be emitted for affected keys.
func (s settings) Revert() {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))

	C.g_settings_revert(arg0)
}

// SetBoolean sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for booleans.
//
// It is a programmer error to give a @key that isn't specified as having a
// boolean type in the schema for @settings.
func (s settings) SetBoolean(key string, value bool) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	if value {
		arg2 = C.gboolean(1)
	}

	var cret C.gboolean

	cret = C.g_settings_set_boolean(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetDouble sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for doubles.
//
// It is a programmer error to give a @key that isn't specified as having a
// 'double' type in the schema for @settings.
func (s settings) SetDouble(key string, value float64) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gdouble

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(value)

	var cret C.gboolean

	cret = C.g_settings_set_double(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetEnum looks up the enumerated type nick for @value and writes it to
// @key, within @settings.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as an enumerated type, or for
// @value not to be a valid value for the named type.
//
// After performing the write, accessing @key directly with
// g_settings_get_string() will return the 'nick' associated with @value.
func (s settings) SetEnum(key string, value int) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(value)

	var cret C.gboolean

	cret = C.g_settings_set_enum(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetFlags looks up the flags type nicks for the bits specified by @value,
// puts them in an array of strings and writes the array to @key, within
// @settings.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as a flags type, or for @value to
// contain any bits that are not value for the named type.
//
// After performing the write, accessing @key directly with
// g_settings_get_strv() will return an array of 'nicks'; one for each bit
// in @value.
func (s settings) SetFlags(key string, value uint) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.guint

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(value)

	var cret C.gboolean

	cret = C.g_settings_set_flags(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetInt sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 32-bit integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// int32 type in the schema for @settings.
func (s settings) SetInt(key string, value int) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(value)

	var cret C.gboolean

	cret = C.g_settings_set_int(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetInt64 sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 64-bit integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// int64 type in the schema for @settings.
func (s settings) SetInt64(key string, value int64) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gint64

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint64(value)

	var cret C.gboolean

	cret = C.g_settings_set_int64(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetString sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for strings.
//
// It is a programmer error to give a @key that isn't specified as having a
// string type in the schema for @settings.
func (s settings) SetString(key string, value string) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.gboolean

	cret = C.g_settings_set_string(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetStrv sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for string arrays. If @value is
// nil, then @key is set to be the empty array.
//
// It is a programmer error to give a @key that isn't specified as having an
// array of strings type in the schema for @settings.
func (s settings) SetStrv(key string, value []string) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 **C.gchar

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (**C.gchar)(C.malloc((len(value) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg2))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg2), int(len(value)))

		for i := range value {
			arg2 = (*C.gchar)(C.CString(value))
			defer C.free(unsafe.Pointer(arg2))
		}
	}

	var cret C.gboolean

	cret = C.g_settings_set_strv(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetUint sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 32-bit unsigned integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// uint32 type in the schema for @settings.
func (s settings) SetUint(key string, value uint) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.guint

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(value)

	var cret C.gboolean

	cret = C.g_settings_set_uint(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetUint64 sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 64-bit unsigned integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// uint64 type in the schema for @settings.
func (s settings) SetUint64(key string, value uint64) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.guint64

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint64(value)

	var cret C.gboolean

	cret = C.g_settings_set_uint64(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetValue sets @key in @settings to @value.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or for @value to have the incorrect type, per the
// schema.
//
// If @value is floating then this function consumes the reference.
func (s settings) SetValue(key string, value *glib.Variant) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	var cret C.gboolean

	cret = C.g_settings_set_value(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}
