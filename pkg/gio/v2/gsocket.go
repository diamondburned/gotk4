// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_socket_get_type()), F: marshalSocket},
	})
}

type SocketPrivate struct {
	native C.GSocketPrivate
}

// WrapSocketPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSocketPrivate(ptr unsafe.Pointer) *SocketPrivate {
	if ptr == nil {
		return nil
	}

	return (*SocketPrivate)(ptr)
}

func marshalSocketPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSocketPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SocketPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Socket: a #GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API. It
// supports both the UNIX socket implementations and winsock2 on Windows.
//
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful.
//
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return nil.
//
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which don’t take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation.
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
type Socket interface {
	gextras.Objector
	DatagramBased
	Initable

	// Accept: accept incoming connections on a connection-based socket. This
	// removes the first outstanding connection request from the listening
	// socket and creates a #GSocket object for it.
	//
	// The @socket must be bound to a local address with g_socket_bind() and
	// must be listening for incoming connections (g_socket_listen()).
	//
	// If there are no outstanding connections then the operation will block or
	// return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be
	// notified of an incoming connection, wait for the G_IO_IN condition.
	Accept(cancellable Cancellable) (socket Socket, err error)
	// Bind: when a socket is created it is attached to an address family, but
	// it doesn't have an address in this family. g_socket_bind() assigns the
	// address (sometimes called name) of the socket.
	//
	// It is generally required to bind to a local address before you can
	// receive connections. (See g_socket_listen() and g_socket_accept() ). In
	// certain situations, you may also want to bind a socket that will be used
	// to initiate connections, though this is not normally required.
	//
	// If @socket is a TCP socket, then @allow_reuse controls the setting of the
	// `SO_REUSEADDR` socket option; normally it should be true for server
	// sockets (sockets that you will eventually call g_socket_accept() on), and
	// false for client sockets. (Failing to set this flag on a server socket
	// may cause g_socket_bind() to return G_IO_ERROR_ADDRESS_IN_USE if the
	// server program is stopped and then immediately restarted.)
	//
	// If @socket is a UDP socket, then @allow_reuse determines whether or not
	// other UDP sockets can be bound to the same address at the same time. In
	// particular, you can have several UDP sockets bound to the same address,
	// and they will all receive all of the multicast and broadcast packets sent
	// to that address. (The behavior of unicast UDP packets to an address with
	// multiple listeners is not defined.)
	Bind(address SocketAddress, allowReuse bool) error
	// CheckConnectResult checks and resets the pending connect error for the
	// socket. This is used to check for errors when g_socket_connect() is used
	// in non-blocking mode.
	CheckConnectResult() error
	// Close closes the socket, shutting down any active connection.
	//
	// Closing a socket does not wait for all outstanding I/O operations to
	// finish, so the caller should not rely on them to be guaranteed to
	// complete even if the close returns with no error.
	//
	// Once the socket is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a socket multiple times will not return an
	// error.
	//
	// Sockets will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Beware that due to the way that TCP works, it is possible for
	// recently-sent data to be lost if either you close a socket while the
	// G_IO_IN condition is set, or else if the remote connection tries to send
	// something to you after you close the socket but before it has finished
	// reading all of the data you sent. There is no easy generic way to avoid
	// this problem; the easiest fix is to design the network protocol such that
	// the client will never send data "out of turn". Another solution is for
	// the server to half-close the connection by calling g_socket_shutdown()
	// with only the @shutdown_write flag set, and then wait for the client to
	// notice this and close its side of the connection, after which the server
	// can safely call g_socket_close(). (This is what Connection does if you
	// call g_tcp_connection_set_graceful_disconnect(). But of course, this only
	// works if the client will close its connection after the server does.)
	Close() error
	// ConditionCheck checks on the readiness of @socket to perform operations.
	// The operations specified in @condition are checked for and masked against
	// the currently-satisfied conditions on @socket. The result is returned.
	//
	// Note that on Windows, it is possible for an operation to return
	// G_IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check()
	// has claimed that the socket is ready for writing. Rather than calling
	// g_socket_condition_check() and then writing to the socket if it succeeds,
	// it is generally better to simply try writing to the socket right away,
	// and try again later if the initial attempt returns
	// G_IO_ERROR_WOULD_BLOCK.
	//
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
	// conditions will always be set in the output if they are true.
	//
	// This call never blocks.
	ConditionCheck(condition glib.IOCondition) glib.IOCondition
	// ConditionTimedWait waits for up to @timeout_us microseconds for
	// @condition to become true on @socket. If the condition is met, true is
	// returned.
	//
	// If @cancellable is cancelled before the condition is met, or if
	// @timeout_us (or the socket's #GSocket:timeout) is reached before the
	// condition is met, then false is returned and @error, if non-nil, is set
	// to the appropriate value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	//
	// If you don't want a timeout, use g_socket_condition_wait().
	// (Alternatively, you can pass -1 for @timeout_us.)
	//
	// Note that although @timeout_us is in microseconds for consistency with
	// other GLib APIs, this function actually only has millisecond resolution,
	// and the behavior is undefined if @timeout_us is not an exact number of
	// milliseconds.
	ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) error
	// ConditionWait waits for @condition to become true on @socket. When the
	// condition is met, true is returned.
	//
	// If @cancellable is cancelled before the condition is met, or if the
	// socket has a timeout set and it is reached before the condition is met,
	// then false is returned and @error, if non-nil, is set to the appropriate
	// value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	//
	// See also g_socket_condition_timed_wait().
	ConditionWait(condition glib.IOCondition, cancellable Cancellable) error
	// Connect: connect the socket to the specified remote address.
	//
	// For connection oriented socket this generally means we attempt to make a
	// connection to the @address. For a connection-less socket it sets the
	// default address for g_socket_send() and discards all incoming datagrams
	// from other sources.
	//
	// Generally connection oriented sockets can only connect once, but
	// connection-less sockets can connect multiple times to change the default
	// address.
	//
	// If the connect call needs to do network I/O it will block, unless
	// non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned and the
	// user can be notified of the connection finishing by waiting for the
	// G_IO_OUT condition. The result of the connection must then be checked
	// with g_socket_check_connect_result().
	Connect(address SocketAddress, cancellable Cancellable) error
	// ConnectionFactoryCreateConnection creates a Connection subclass of the
	// right type for @socket.
	ConnectionFactoryCreateConnection() SocketConnection
	// CreateSource creates a #GSource that can be attached to a GMainContext to
	// monitor for the availability of the specified @condition on the socket.
	// The #GSource keeps a reference to the @socket.
	//
	// The callback on the source is of the SourceFunc type.
	//
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in @condition; these
	// conditions will always be reported output if they are true.
	//
	// @cancellable if not nil can be used to cancel the source, which will
	// cause the source to trigger, reporting the current condition (which is
	// likely 0 unless cancellation happened at the same time as a condition
	// change). You can check for this in the callback using
	// g_cancellable_is_cancelled().
	//
	// If @socket has a timeout set, and it is reached before @condition occurs,
	// the source will then trigger anyway, reporting G_IO_IN or G_IO_OUT
	// depending on @condition. However, @socket will have been marked as having
	// had a timeout, and so the next #GSocket I/O method you call will then
	// fail with a G_IO_ERROR_TIMED_OUT.
	CreateSource(condition glib.IOCondition, cancellable Cancellable) *glib.Source
	// AvailableBytes: get the amount of data pending in the OS input buffer,
	// without blocking.
	//
	// If @socket is a UDP or SCTP socket, this will return the size of just the
	// next packet, even if additional packets are buffered after that one.
	//
	// Note that on Windows, this function is rather inefficient in the UDP
	// case, and so if you know any plausible upper bound on the size of the
	// incoming packet, it is better to just do a g_socket_receive() with a
	// buffer of that size, rather than calling g_socket_get_available_bytes()
	// first and then doing a receive of exactly the right size.
	AvailableBytes() int
	// Blocking gets the blocking mode of the socket. For details on blocking
	// I/O, see g_socket_set_blocking().
	Blocking() bool
	// Broadcast gets the broadcast setting on @socket; if true, it is possible
	// to send packets to broadcast addresses.
	Broadcast() bool
	// Credentials returns the credentials of the foreign process connected to
	// this socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX
	// sockets).
	//
	// If this operation isn't supported on the OS, the method fails with the
	// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading
	// the SO_PEERCRED option on the underlying socket.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - OpenBSD since GLib 2.30 - Solaris, Illumos and
	// OpenSolaris since GLib 2.40 - NetBSD since GLib 2.42 - macOS, tvOS, iOS
	// since GLib 2.66
	//
	// Other ways to obtain credentials from a foreign peer includes the
	// CredentialsMessage type and g_unix_connection_send_credentials() /
	// g_unix_connection_receive_credentials() functions.
	Credentials() (credentials Credentials, err error)
	// Family gets the socket family of the socket.
	Family() SocketFamily
	// Fd returns the underlying OS socket object. On unix this is a socket file
	// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
	// useful for doing platform specific or otherwise unusual operations on the
	// socket.
	Fd() int
	// Keepalive gets the keepalive mode of the socket. For details on this, see
	// g_socket_set_keepalive().
	Keepalive() bool
	// ListenBacklog gets the listen backlog setting of the socket. For details
	// on this, see g_socket_set_listen_backlog().
	ListenBacklog() int
	// LocalAddress: try to get the local address of a bound socket. This is
	// only useful if the socket has been bound to a local address, either
	// explicitly or implicitly when connecting.
	LocalAddress() (socketAddress SocketAddress, err error)
	// MulticastLoopback gets the multicast loopback setting on @socket; if true
	// (the default), outgoing multicast packets will be looped back to
	// multicast listeners on the same host.
	MulticastLoopback() bool
	// MulticastTtl gets the multicast time-to-live setting on @socket; see
	// g_socket_set_multicast_ttl() for more details.
	MulticastTtl() uint
	// Option gets the value of an integer-valued option on @socket, as with
	// getsockopt(). (If you need to fetch a non-integer-valued option, you will
	// need to call getsockopt() directly.)
	//
	// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
	// headers that will define most of the standard/portable socket options.
	// For unusual socket protocols or platform-dependent options, you may need
	// to include additional headers.
	//
	// Note that even for socket options that are a single byte in size, @value
	// is still a pointer to a #gint variable, not a #guchar;
	// g_socket_get_option() will handle the conversion internally.
	Option(level int, optname int) (value int, err error)
	// Protocol gets the socket protocol id the socket was created with. In case
	// the protocol is unknown, -1 is returned.
	Protocol() SocketProtocol
	// RemoteAddress: try to get the remote address of a connected socket. This
	// is only useful for connection oriented sockets that have been connected.
	RemoteAddress() (socketAddress SocketAddress, err error)
	// SocketType gets the socket type of the socket.
	SocketType() SocketType
	// Timeout gets the timeout setting of the socket. For details on this, see
	// g_socket_set_timeout().
	Timeout() uint
	// Ttl gets the unicast time-to-live setting on @socket; see
	// g_socket_set_ttl() for more details.
	Ttl() uint
	// IsClosed checks whether a socket is closed.
	IsClosed() bool
	// IsConnected: check whether the socket is connected. This is only useful
	// for connection-oriented sockets.
	//
	// If using g_socket_shutdown(), this function will return true until the
	// socket has been shut down for reading and writing. If you do a
	// non-blocking connect, this function will not return true until after you
	// call g_socket_check_connect_result().
	IsConnected() bool
	// JoinMulticastGroup registers @socket to receive multicast messages sent
	// to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have
	// been bound to an appropriate interface and port with g_socket_bind().
	//
	// If @iface is nil, the system will automatically pick an interface to bind
	// to based on @group.
	//
	// If @source_specific is true, source-specific multicast as defined in RFC
	// 4604 is used. Note that on older platforms this may fail with a
	// G_IO_ERROR_NOT_SUPPORTED error.
	//
	// To bind to a given source-specific multicast address, use
	// g_socket_join_multicast_group_ssm() instead.
	JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) error
	// JoinMulticastGroupSsm registers @socket to receive multicast messages
	// sent to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must
	// have been bound to an appropriate interface and port with
	// g_socket_bind().
	//
	// If @iface is nil, the system will automatically pick an interface to bind
	// to based on @group.
	//
	// If @source_specific is not nil, use source-specific multicast as defined
	// in RFC 4604. Note that on older platforms this may fail with a
	// G_IO_ERROR_NOT_SUPPORTED error.
	//
	// Note that this function can be called multiple times for the same @group
	// with different @source_specific in order to receive multicast packets
	// from more than one source.
	JoinMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) error
	// LeaveMulticastGroup removes @socket from the multicast group defined by
	// @group, @iface, and @source_specific (which must all have the same values
	// they had when you joined the group).
	//
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	//
	// To unbind to a given source-specific multicast address, use
	// g_socket_leave_multicast_group_ssm() instead.
	LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) error
	// LeaveMulticastGroupSsm removes @socket from the multicast group defined
	// by @group, @iface, and @source_specific (which must all have the same
	// values they had when you joined the group).
	//
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	LeaveMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) error
	// Listen marks the socket as a server socket, i.e. a socket that is used to
	// accept incoming requests using g_socket_accept().
	//
	// Before calling this the socket must be bound to a local address using
	// g_socket_bind().
	//
	// To set the maximum amount of outstanding clients, use
	// g_socket_set_listen_backlog().
	Listen() error
	// Receive: receive data (up to @size bytes) from a socket. This is mainly
	// used by connection-oriented sockets; it is identical to
	// g_socket_receive_from() with @address set to nil.
	//
	// For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
	// g_socket_receive() will always read either 0 or 1 complete messages from
	// the socket. If the received message is too large to fit in @buffer, then
	// the data beyond @size bytes will be discarded, without any explicit
	// indication that this has occurred.
	//
	// For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
	// number of bytes, up to @size. If more than @size bytes have been
	// received, the additional data will be returned in future calls to
	// g_socket_receive().
	//
	// If the socket is in blocking mode the call will block until there is some
	// data to receive, the connection is closed, or there is an error. If there
	// is no data available and the socket is in non-blocking mode, a
	// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data
	// is available, wait for the G_IO_IN condition.
	//
	// On error -1 is returned and @error is set accordingly.
	Receive(cancellable Cancellable) (buffer []byte, size uint, gssize int, err error)
	// ReceiveFrom: receive data (up to @size bytes) from a socket.
	//
	// If @address is non-nil then @address will be set equal to the source
	// address of the received packet. @address is owned by the caller.
	//
	// See g_socket_receive() for additional information.
	ReceiveFrom(cancellable Cancellable) (address SocketAddress, buffer []byte, size uint, gssize int, err error)
	// ReceiveMessage: receive data from a socket. For receiving multiple
	// messages, see g_socket_receive_messages(); for easier use, see
	// g_socket_receive() and g_socket_receive_from().
	//
	// If @address is non-nil then @address will be set equal to the source
	// address of the received packet. @address is owned by the caller.
	//
	// @vector must point to an array of Vector structs and @num_vectors must be
	// the length of this array. These structs describe the buffers that
	// received data will be scattered into. If @num_vectors is -1, then
	// @vectors is assumed to be terminated by a Vector with a nil buffer
	// pointer.
	//
	// As a special case, if @num_vectors is 0 (in which case, @vectors may of
	// course be nil), then a single byte is received and discarded. This is to
	// facilitate the common practice of sending a single '\0' byte for the
	// purposes of transferring ancillary data.
	//
	// @messages, if non-nil, will be set to point to a newly-allocated array of
	// ControlMessage instances or nil if no such messages was received. These
	// correspond to the control messages received from the kernel, one
	// ControlMessage per message from the kernel. This array is nil-terminated
	// and must be freed by the caller using g_free() after calling
	// g_object_unref() on each element. If @messages is nil, any control
	// messages received will be discarded.
	//
	// @num_messages, if non-nil, will be set to the number of control messages
	// received.
	//
	// If both @messages and @num_messages are non-nil, then @num_messages gives
	// the number of ControlMessage instances in @messages (ie: not including
	// the nil terminator).
	//
	// @flags is an in/out parameter. The commonly available arguments for this
	// are available in the MsgFlags enum, but the values there are the same as
	// the system values, and the flags are passed in as-is, so you can pass in
	// system-specific flags too (and g_socket_receive_message() may pass
	// system-specific flags out). Flags passed in to the parameter affect the
	// receive operation; flags returned out of it are relevant to the specific
	// returned message.
	//
	// As with g_socket_receive(), data may be discarded if @socket is
	// G_SOCKET_TYPE_DATAGRAM or G_SOCKET_TYPE_SEQPACKET and you do not provide
	// enough buffer space to read a complete message. You can pass
	// G_SOCKET_MSG_PEEK in @flags to peek at the current message without
	// removing it from the receive queue, but there is no portable way to find
	// out the length of the message other than by reading it into a
	// sufficiently-large buffer.
	//
	// If the socket is in blocking mode the call will block until there is some
	// data to receive, the connection is closed, or there is an error. If there
	// is no data available and the socket is in non-blocking mode, a
	// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data
	// is available, wait for the G_IO_IN condition.
	//
	// On error -1 is returned and @error is set accordingly.
	ReceiveMessage(vectors []InputVector, flags int, cancellable Cancellable) (address SocketAddress, messages []SocketControlMessage, numMessages int, gssize int, err error)
	// ReceiveMessages: receive multiple data messages from @socket in one go.
	// This is the most complicated and fully-featured version of this call. For
	// easier use, see g_socket_receive(), g_socket_receive_from(), and
	// g_socket_receive_message().
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains a pointer to an
	// array of Vector structs describing the buffers that the data received in
	// each message will be written to. Using multiple Vectors is more
	// memory-efficient than manually copying data out of a single buffer to
	// multiple sources, and more system-call-efficient than making multiple
	// calls to g_socket_receive(), such as in scenarios where a lot of data
	// packets need to be received (e.g. high-bandwidth video streaming over
	// RTP/UDP).
	//
	// @flags modify how all messages are received. The commonly available
	// arguments for this are available in the MsgFlags enum, but the values
	// there are the same as the system values, and the flags are passed in
	// as-is, so you can pass in system-specific flags too. These flags affect
	// the overall receive operation. Flags affecting individual messages are
	// returned in Message.flags.
	//
	// The other members of Message are treated as described in its
	// documentation.
	//
	// If #GSocket:blocking is true the call will block until @num_messages have
	// been received, or the end of the stream is reached.
	//
	// If #GSocket:blocking is false the call will return up to @num_messages
	// without blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in
	// the operating system to be received.
	//
	// In blocking mode, if #GSocket:timeout is positive and is reached before
	// any messages are received, G_IO_ERROR_TIMED_OUT is returned, otherwise up
	// to @num_messages are returned. (Note: This is effectively the behaviour
	// of `MSG_WAITFORONE` with recvmmsg().)
	//
	// To be notified when messages are available, wait for the G_IO_IN
	// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
	// from g_socket_receive_messages() even if you were previously notified of
	// a G_IO_IN condition.
	//
	// If the remote peer closes the connection, any messages queued in the
	// operating system will be returned, and subsequent calls to
	// g_socket_receive_messages() will return 0 (with no error set).
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be received; otherwise the number of
	// messages successfully received before the error will be returned.
	ReceiveMessages(messages []InputMessage, flags int, cancellable Cancellable) (gint int, err error)
	// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
	// except that the choice of blocking or non-blocking behavior is determined
	// by the @blocking argument rather than by @socket's properties.
	ReceiveWithBlocking(blocking bool, cancellable Cancellable) (buffer []byte, size uint, gssize int, err error)
	// Send tries to send @size bytes from @buffer on the socket. This is mainly
	// used by connection-oriented sockets; it is identical to
	// g_socket_send_to() with @address set to nil.
	//
	// If the socket is in blocking mode the call will block until there is
	// space for the data in the socket queue. If there is no space available
	// and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
	// will be returned. To be notified when space is available, wait for the
	// G_IO_OUT condition. Note though that you may still receive
	// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
	// notified of a G_IO_OUT condition. (On Windows in particular, this is very
	// common due to the way the underlying APIs work.)
	//
	// On error -1 is returned and @error is set accordingly.
	Send(buffer []byte, cancellable Cancellable) (gssize int, err error)
	// SendMessage: send data to @address on @socket. For sending multiple
	// messages see g_socket_send_messages(); for easier use, see
	// g_socket_send() and g_socket_send_to().
	//
	// If @address is nil then the message is sent to the default receiver (set
	// by g_socket_connect()).
	//
	// @vectors must point to an array of Vector structs and @num_vectors must
	// be the length of this array. (If @num_vectors is -1, then @vectors is
	// assumed to be terminated by a Vector with a nil buffer pointer.) The
	// Vector structs describe the buffers that the sent data will be gathered
	// from. Using multiple Vectors is more memory-efficient than manually
	// copying data from multiple sources into a single buffer, and more
	// network-efficient than making multiple calls to g_socket_send().
	//
	// @messages, if non-nil, is taken to point to an array of @num_messages
	// ControlMessage instances. These correspond to the control messages to be
	// sent on the socket. If @num_messages is -1 then @messages is treated as a
	// nil-terminated array.
	//
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the MsgFlags enum, but the values there are the
	// same as the system values, and the flags are passed in as-is, so you can
	// pass in system-specific flags too.
	//
	// If the socket is in blocking mode the call will block until there is
	// space for the data in the socket queue. If there is no space available
	// and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
	// will be returned. To be notified when space is available, wait for the
	// G_IO_OUT condition. Note though that you may still receive
	// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
	// notified of a G_IO_OUT condition. (On Windows in particular, this is very
	// common due to the way the underlying APIs work.)
	//
	// The sum of the sizes of each Vector in vectors must not be greater than
	// G_MAXSSIZE. If the message can be larger than this, then it is mandatory
	// to use the g_socket_send_message_with_timeout() function.
	//
	// On error -1 is returned and @error is set accordingly.
	SendMessage(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, cancellable Cancellable) (gssize int, err error)
	// SendMessageWithTimeout: this behaves exactly the same as
	// g_socket_send_message(), except that the choice of timeout behavior is
	// determined by the @timeout_us argument rather than by @socket's
	// properties.
	//
	// On error G_POLLABLE_RETURN_FAILED is returned and @error is set
	// accordingly, or if the socket is currently not writable
	// G_POLLABLE_RETURN_WOULD_BLOCK is returned. @bytes_written will contain 0
	// in both cases.
	SendMessageWithTimeout(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, timeoutUs int64, cancellable Cancellable) (bytesWritten uint, pollableReturn PollableReturn, err error)
	// SendMessages: send multiple data messages from @socket in one go. This is
	// the most complicated and fully-featured version of this call. For easier
	// use, see g_socket_send(), g_socket_send_to(), and
	// g_socket_send_message().
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains an address to
	// send the data to, and a pointer to an array of Vector structs to describe
	// the buffers that the data to be sent for each message will be gathered
	// from. Using multiple Vectors is more memory-efficient than manually
	// copying data from multiple sources into a single buffer, and more
	// network-efficient than making multiple calls to g_socket_send(). Sending
	// multiple messages in one go avoids the overhead of making a lot of
	// syscalls in scenarios where a lot of data packets need to be sent (e.g.
	// high-bandwidth video streaming over RTP/UDP), or where the same data
	// needs to be sent to multiple recipients.
	//
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the MsgFlags enum, but the values there are the
	// same as the system values, and the flags are passed in as-is, so you can
	// pass in system-specific flags too.
	//
	// If the socket is in blocking mode the call will block until there is
	// space for all the data in the socket queue. If there is no space
	// available and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK
	// error will be returned if no data was written at all, otherwise the
	// number of messages sent will be returned. To be notified when space is
	// available, wait for the G_IO_OUT condition. Note though that you may
	// still receive G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you
	// were previously notified of a G_IO_OUT condition. (On Windows in
	// particular, this is very common due to the way the underlying APIs work.)
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be sent; otherwise the number of
	// messages successfully sent before the error will be returned.
	SendMessages(messages []OutputMessage, flags int, cancellable Cancellable) (gint int, err error)
	// SendTo tries to send @size bytes from @buffer to @address. If @address is
	// nil then the message is sent to the default receiver (set by
	// g_socket_connect()).
	//
	// See g_socket_send() for additional information.
	SendTo(address SocketAddress, buffer []byte, cancellable Cancellable) (gssize int, err error)
	// SendWithBlocking: this behaves exactly the same as g_socket_send(),
	// except that the choice of blocking or non-blocking behavior is determined
	// by the @blocking argument rather than by @socket's properties.
	SendWithBlocking(buffer []byte, blocking bool, cancellable Cancellable) (gssize int, err error)
	// SetBlocking sets the blocking mode of the socket. In blocking mode all
	// operations (which don’t take an explicit blocking parameter) block until
	// they succeed or there is an error. In non-blocking mode all functions
	// return results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
	//
	// All sockets are created in blocking mode. However, note that the platform
	// level socket is always non-blocking, and blocking mode is a GSocket level
	// feature.
	SetBlocking(blocking bool)
	// SetBroadcast sets whether @socket should allow sending to broadcast
	// addresses. This is false by default.
	SetBroadcast(broadcast bool)
	// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying
	// socket. When this flag is set on a socket, the system will attempt to
	// verify that the remote socket endpoint is still present if a sufficiently
	// long period of time passes with no data being exchanged. If the system is
	// unable to verify the presence of the remote endpoint, it will
	// automatically close the connection.
	//
	// This option is only functional on certain kinds of sockets. (Notably,
	// G_SOCKET_PROTOCOL_TCP sockets.)
	//
	// The exact time between pings is system- and protocol-dependent, but will
	// normally be at least two hours. Most commonly, you would set this flag on
	// a server socket if you want to allow clients to remain idle for long
	// periods of time, but also want to ensure that connections are eventually
	// garbage-collected if clients crash or become unreachable.
	SetKeepalive(keepalive bool)
	// SetListenBacklog sets the maximum number of outstanding connections
	// allowed when listening on this socket. If more clients than this are
	// connecting to the socket and the application is not handling them on time
	// then the new connections will be refused.
	//
	// Note that this must be called before g_socket_listen() and has no effect
	// if called after that.
	SetListenBacklog(backlog int)
	// SetMulticastLoopback sets whether outgoing multicast packets will be
	// received by sockets listening on that multicast address on the same host.
	// This is true by default.
	SetMulticastLoopback(loopback bool)
	// SetMulticastTtl sets the time-to-live for outgoing multicast datagrams on
	// @socket. By default, this is 1, meaning that multicast packets will not
	// leave the local network.
	SetMulticastTtl(ttl uint)
	// SetOption sets the value of an integer-valued option on @socket, as with
	// setsockopt(). (If you need to set a non-integer-valued option, you will
	// need to call setsockopt() directly.)
	//
	// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
	// headers that will define most of the standard/portable socket options.
	// For unusual socket protocols or platform-dependent options, you may need
	// to include additional headers.
	SetOption(level int, optname int, value int) error
	// SetTimeout sets the time in seconds after which I/O operations on @socket
	// will time out if they have not yet completed.
	//
	// On a blocking socket, this means that any blocking #GSocket operation
	// will time out after @timeout seconds of inactivity, returning
	// G_IO_ERROR_TIMED_OUT.
	//
	// On a non-blocking socket, calls to g_socket_condition_wait() will also
	// fail with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
	// g_socket_create_source() will trigger after @timeout seconds of
	// inactivity, with the requested condition set, at which point calling
	// g_socket_receive(), g_socket_send(), g_socket_check_connect_result(),
	// etc, will fail with G_IO_ERROR_TIMED_OUT.
	//
	// If @timeout is 0 (the default), operations will never time out on their
	// own.
	//
	// Note that if an I/O operation is interrupted by a signal, this may cause
	// the timeout to be reset.
	SetTimeout(timeout uint)
	// SetTtl sets the time-to-live for outgoing unicast packets on @socket. By
	// default the platform-specific default value is used.
	SetTtl(ttl uint)
	// Shutdown: shut down part or all of a full-duplex connection.
	//
	// If @shutdown_read is true then the receiving side of the connection is
	// shut down, and further reading is disallowed.
	//
	// If @shutdown_write is true then the sending side of the connection is
	// shut down, and further writing is disallowed.
	//
	// It is allowed for both @shutdown_read and @shutdown_write to be true.
	//
	// One example where it is useful to shut down only one side of a connection
	// is graceful disconnect for TCP connections where you close the sending
	// side, then wait for the other side to close the connection, thus ensuring
	// that the other side saw all sent data.
	Shutdown(shutdownRead bool, shutdownWrite bool) error
	// SpeaksIpv4 checks if a socket is capable of speaking IPv4.
	//
	// IPv4 sockets are capable of speaking IPv4. On some operating systems and
	// under some combinations of circumstances IPv6 sockets are also capable of
	// speaking IPv4. See RFC 3493 section 3.7 for more information.
	//
	// No other types of sockets are currently considered as being capable of
	// speaking IPv4.
	SpeaksIpv4() bool
}

// socket implements the Socket interface.
type socket struct {
	gextras.Objector
	DatagramBased
	Initable
}

var _ Socket = (*socket)(nil)

// WrapSocket wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocket(obj *externglib.Object) Socket {
	return Socket{
		Objector:      obj,
		DatagramBased: WrapDatagramBased(obj),
		Initable:      WrapInitable(obj),
	}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocket(obj), nil
}

// NewSocket constructs a class Socket.
func NewSocket(family SocketFamily, typ SocketType, protocol SocketProtocol) (socket Socket, err error) {
	var arg1 C.GSocketFamily
	var arg2 C.GSocketType
	var arg3 C.GSocketProtocol
	var gError *C.GError

	arg1 = (C.GSocketFamily)(family)
	arg2 = (C.GSocketType)(typ)
	arg3 = (C.GSocketProtocol)(protocol)

	ret := C.g_socket_new(arg1, arg2, arg3, &gError)

	var ret0 Socket
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Socket)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewSocketFromFd constructs a class Socket.
func NewSocketFromFd(fd int) (socket Socket, err error) {
	var arg1 C.gint
	var gError *C.GError

	arg1 = C.gint(fd)

	ret := C.g_socket_new_from_fd(arg1, &gError)

	var ret0 Socket
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Socket)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Accept: accept incoming connections on a connection-based socket. This
// removes the first outstanding connection request from the listening
// socket and creates a #GSocket object for it.
//
// The @socket must be bound to a local address with g_socket_bind() and
// must be listening for incoming connections (g_socket_listen()).
//
// If there are no outstanding connections then the operation will block or
// return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be
// notified of an incoming connection, wait for the G_IO_IN condition.
func (s socket) Accept(cancellable Cancellable) (socket Socket, err error) {
	var arg0 *C.GSocket
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_accept(arg0, arg1, &gError)

	var ret0 Socket
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Socket)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Bind: when a socket is created it is attached to an address family, but
// it doesn't have an address in this family. g_socket_bind() assigns the
// address (sometimes called name) of the socket.
//
// It is generally required to bind to a local address before you can
// receive connections. (See g_socket_listen() and g_socket_accept() ). In
// certain situations, you may also want to bind a socket that will be used
// to initiate connections, though this is not normally required.
//
// If @socket is a TCP socket, then @allow_reuse controls the setting of the
// `SO_REUSEADDR` socket option; normally it should be true for server
// sockets (sockets that you will eventually call g_socket_accept() on), and
// false for client sockets. (Failing to set this flag on a server socket
// may cause g_socket_bind() to return G_IO_ERROR_ADDRESS_IN_USE if the
// server program is stopped and then immediately restarted.)
//
// If @socket is a UDP socket, then @allow_reuse determines whether or not
// other UDP sockets can be bound to the same address at the same time. In
// particular, you can have several UDP sockets bound to the same address,
// and they will all receive all of the multicast and broadcast packets sent
// to that address. (The behavior of unicast UDP packets to an address with
// multiple listeners is not defined.)
func (s socket) Bind(address SocketAddress, allowReuse bool) error {
	var arg0 *C.GSocket
	var arg1 *C.GSocketAddress
	var arg2 C.gboolean
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	if allowReuse {
		arg2 = C.TRUE
	}

	ret := C.g_socket_bind(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// CheckConnectResult checks and resets the pending connect error for the
// socket. This is used to check for errors when g_socket_connect() is used
// in non-blocking mode.
func (s socket) CheckConnectResult() error {
	var arg0 *C.GSocket
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_check_connect_result(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Close closes the socket, shutting down any active connection.
//
// Closing a socket does not wait for all outstanding I/O operations to
// finish, so the caller should not rely on them to be guaranteed to
// complete even if the close returns with no error.
//
// Once the socket is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a socket multiple times will not return an
// error.
//
// Sockets will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are
// released as early as possible.
//
// Beware that due to the way that TCP works, it is possible for
// recently-sent data to be lost if either you close a socket while the
// G_IO_IN condition is set, or else if the remote connection tries to send
// something to you after you close the socket but before it has finished
// reading all of the data you sent. There is no easy generic way to avoid
// this problem; the easiest fix is to design the network protocol such that
// the client will never send data "out of turn". Another solution is for
// the server to half-close the connection by calling g_socket_shutdown()
// with only the @shutdown_write flag set, and then wait for the client to
// notice this and close its side of the connection, after which the server
// can safely call g_socket_close(). (This is what Connection does if you
// call g_tcp_connection_set_graceful_disconnect(). But of course, this only
// works if the client will close its connection after the server does.)
func (s socket) Close() error {
	var arg0 *C.GSocket
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_close(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ConditionCheck checks on the readiness of @socket to perform operations.
// The operations specified in @condition are checked for and masked against
// the currently-satisfied conditions on @socket. The result is returned.
//
// Note that on Windows, it is possible for an operation to return
// G_IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check()
// has claimed that the socket is ready for writing. Rather than calling
// g_socket_condition_check() and then writing to the socket if it succeeds,
// it is generally better to simply try writing to the socket right away,
// and try again later if the initial attempt returns
// G_IO_ERROR_WOULD_BLOCK.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
// conditions will always be set in the output if they are true.
//
// This call never blocks.
func (s socket) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var arg0 *C.GSocket
	var arg1 C.GIOCondition

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (C.GIOCondition)(condition)

	ret := C.g_socket_condition_check(arg0, arg1)

	var ret0 glib.IOCondition

	ret0 = glib.IOCondition(ret)

	return ret0
}

// ConditionTimedWait waits for up to @timeout_us microseconds for
// @condition to become true on @socket. If the condition is met, true is
// returned.
//
// If @cancellable is cancelled before the condition is met, or if
// @timeout_us (or the socket's #GSocket:timeout) is reached before the
// condition is met, then false is returned and @error, if non-nil, is set
// to the appropriate value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// If you don't want a timeout, use g_socket_condition_wait().
// (Alternatively, you can pass -1 for @timeout_us.)
//
// Note that although @timeout_us is in microseconds for consistency with
// other GLib APIs, this function actually only has millisecond resolution,
// and the behavior is undefined if @timeout_us is not an exact number of
// milliseconds.
func (s socket) ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) error {
	var arg0 *C.GSocket
	var arg1 C.GIOCondition
	var arg2 C.gint64
	var arg3 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (C.GIOCondition)(condition)
	arg2 = C.gint64(timeoutUs)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_condition_timed_wait(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ConditionWait waits for @condition to become true on @socket. When the
// condition is met, true is returned.
//
// If @cancellable is cancelled before the condition is met, or if the
// socket has a timeout set and it is reached before the condition is met,
// then false is returned and @error, if non-nil, is set to the appropriate
// value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// See also g_socket_condition_timed_wait().
func (s socket) ConditionWait(condition glib.IOCondition, cancellable Cancellable) error {
	var arg0 *C.GSocket
	var arg1 C.GIOCondition
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (C.GIOCondition)(condition)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_condition_wait(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Connect: connect the socket to the specified remote address.
//
// For connection oriented socket this generally means we attempt to make a
// connection to the @address. For a connection-less socket it sets the
// default address for g_socket_send() and discards all incoming datagrams
// from other sources.
//
// Generally connection oriented sockets can only connect once, but
// connection-less sockets can connect multiple times to change the default
// address.
//
// If the connect call needs to do network I/O it will block, unless
// non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned and the
// user can be notified of the connection finishing by waiting for the
// G_IO_OUT condition. The result of the connection must then be checked
// with g_socket_check_connect_result().
func (s socket) Connect(address SocketAddress, cancellable Cancellable) error {
	var arg0 *C.GSocket
	var arg1 *C.GSocketAddress
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_connect(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ConnectionFactoryCreateConnection creates a Connection subclass of the
// right type for @socket.
func (s socket) ConnectionFactoryCreateConnection() SocketConnection {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_connection_factory_create_connection(arg0)

	var ret0 SocketConnection

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(SocketConnection)

	return ret0
}

// CreateSource creates a #GSource that can be attached to a GMainContext to
// monitor for the availability of the specified @condition on the socket.
// The #GSource keeps a reference to the @socket.
//
// The callback on the source is of the SourceFunc type.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in @condition; these
// conditions will always be reported output if they are true.
//
// @cancellable if not nil can be used to cancel the source, which will
// cause the source to trigger, reporting the current condition (which is
// likely 0 unless cancellation happened at the same time as a condition
// change). You can check for this in the callback using
// g_cancellable_is_cancelled().
//
// If @socket has a timeout set, and it is reached before @condition occurs,
// the source will then trigger anyway, reporting G_IO_IN or G_IO_OUT
// depending on @condition. However, @socket will have been marked as having
// had a timeout, and so the next #GSocket I/O method you call will then
// fail with a G_IO_ERROR_TIMED_OUT.
func (s socket) CreateSource(condition glib.IOCondition, cancellable Cancellable) *glib.Source {
	var arg0 *C.GSocket
	var arg1 C.GIOCondition
	var arg2 *C.GCancellable

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (C.GIOCondition)(condition)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_create_source(arg0, arg1, arg2)

	var ret0 *glib.Source

	{
		ret0 = glib.WrapSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Source) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AvailableBytes: get the amount of data pending in the OS input buffer,
// without blocking.
//
// If @socket is a UDP or SCTP socket, this will return the size of just the
// next packet, even if additional packets are buffered after that one.
//
// Note that on Windows, this function is rather inefficient in the UDP
// case, and so if you know any plausible upper bound on the size of the
// incoming packet, it is better to just do a g_socket_receive() with a
// buffer of that size, rather than calling g_socket_get_available_bytes()
// first and then doing a receive of exactly the right size.
func (s socket) AvailableBytes() int {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_available_bytes(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Blocking gets the blocking mode of the socket. For details on blocking
// I/O, see g_socket_set_blocking().
func (s socket) Blocking() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_blocking(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Broadcast gets the broadcast setting on @socket; if true, it is possible
// to send packets to broadcast addresses.
func (s socket) Broadcast() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_broadcast(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Credentials returns the credentials of the foreign process connected to
// this socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX
// sockets).
//
// If this operation isn't supported on the OS, the method fails with the
// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading
// the SO_PEERCRED option on the underlying socket.
//
// This method can be expected to be available on the following platforms:
//
// - Linux since GLib 2.26 - OpenBSD since GLib 2.30 - Solaris, Illumos and
// OpenSolaris since GLib 2.40 - NetBSD since GLib 2.42 - macOS, tvOS, iOS
// since GLib 2.66
//
// Other ways to obtain credentials from a foreign peer includes the
// CredentialsMessage type and g_unix_connection_send_credentials() /
// g_unix_connection_receive_credentials() functions.
func (s socket) Credentials() (credentials Credentials, err error) {
	var arg0 *C.GSocket
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_credentials(arg0, &gError)

	var ret0 Credentials
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Credentials)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Family gets the socket family of the socket.
func (s socket) Family() SocketFamily {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_family(arg0)

	var ret0 SocketFamily

	ret0 = SocketFamily(ret)

	return ret0
}

// Fd returns the underlying OS socket object. On unix this is a socket file
// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
// useful for doing platform specific or otherwise unusual operations on the
// socket.
func (s socket) Fd() int {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_fd(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Keepalive gets the keepalive mode of the socket. For details on this, see
// g_socket_set_keepalive().
func (s socket) Keepalive() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_keepalive(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ListenBacklog gets the listen backlog setting of the socket. For details
// on this, see g_socket_set_listen_backlog().
func (s socket) ListenBacklog() int {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_listen_backlog(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// LocalAddress: try to get the local address of a bound socket. This is
// only useful if the socket has been bound to a local address, either
// explicitly or implicitly when connecting.
func (s socket) LocalAddress() (socketAddress SocketAddress, err error) {
	var arg0 *C.GSocket
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_local_address(arg0, &gError)

	var ret0 SocketAddress
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(SocketAddress)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// MulticastLoopback gets the multicast loopback setting on @socket; if true
// (the default), outgoing multicast packets will be looped back to
// multicast listeners on the same host.
func (s socket) MulticastLoopback() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_multicast_loopback(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// MulticastTtl gets the multicast time-to-live setting on @socket; see
// g_socket_set_multicast_ttl() for more details.
func (s socket) MulticastTtl() uint {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_multicast_ttl(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Option gets the value of an integer-valued option on @socket, as with
// getsockopt(). (If you need to fetch a non-integer-valued option, you will
// need to call getsockopt() directly.)
//
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
// headers that will define most of the standard/portable socket options.
// For unusual socket protocols or platform-dependent options, you may need
// to include additional headers.
//
// Note that even for socket options that are a single byte in size, @value
// is still a pointer to a #gint variable, not a #guchar;
// g_socket_get_option() will handle the conversion internally.
func (s socket) Option(level int, optname int) (value int, err error) {
	var arg0 *C.GSocket
	var arg1 C.gint
	var arg2 C.gint
	var arg3 *C.gint // out
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = C.gint(level)
	arg2 = C.gint(optname)

	ret := C.g_socket_get_option(arg0, arg1, arg2, &arg3, &gError)

	var ret0 int
	var goError error

	ret0 = int(arg3)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Protocol gets the socket protocol id the socket was created with. In case
// the protocol is unknown, -1 is returned.
func (s socket) Protocol() SocketProtocol {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_protocol(arg0)

	var ret0 SocketProtocol

	ret0 = SocketProtocol(ret)

	return ret0
}

// RemoteAddress: try to get the remote address of a connected socket. This
// is only useful for connection oriented sockets that have been connected.
func (s socket) RemoteAddress() (socketAddress SocketAddress, err error) {
	var arg0 *C.GSocket
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_remote_address(arg0, &gError)

	var ret0 SocketAddress
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(SocketAddress)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SocketType gets the socket type of the socket.
func (s socket) SocketType() SocketType {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_socket_type(arg0)

	var ret0 SocketType

	ret0 = SocketType(ret)

	return ret0
}

// Timeout gets the timeout setting of the socket. For details on this, see
// g_socket_set_timeout().
func (s socket) Timeout() uint {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_timeout(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Ttl gets the unicast time-to-live setting on @socket; see
// g_socket_set_ttl() for more details.
func (s socket) Ttl() uint {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_get_ttl(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IsClosed checks whether a socket is closed.
func (s socket) IsClosed() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_is_closed(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsConnected: check whether the socket is connected. This is only useful
// for connection-oriented sockets.
//
// If using g_socket_shutdown(), this function will return true until the
// socket has been shut down for reading and writing. If you do a
// non-blocking connect, this function will not return true until after you
// call g_socket_check_connect_result().
func (s socket) IsConnected() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_is_connected(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// JoinMulticastGroup registers @socket to receive multicast messages sent
// to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have
// been bound to an appropriate interface and port with g_socket_bind().
//
// If @iface is nil, the system will automatically pick an interface to bind
// to based on @group.
//
// If @source_specific is true, source-specific multicast as defined in RFC
// 4604 is used. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// To bind to a given source-specific multicast address, use
// g_socket_join_multicast_group_ssm() instead.
func (s socket) JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) error {
	var arg0 *C.GSocket
	var arg1 *C.GInetAddress
	var arg2 C.gboolean
	var arg3 *C.gchar
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GInetAddress)(group.Native())
	if sourceSpecific {
		arg2 = C.TRUE
	}
	arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_socket_join_multicast_group(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// JoinMulticastGroupSsm registers @socket to receive multicast messages
// sent to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must
// have been bound to an appropriate interface and port with
// g_socket_bind().
//
// If @iface is nil, the system will automatically pick an interface to bind
// to based on @group.
//
// If @source_specific is not nil, use source-specific multicast as defined
// in RFC 4604. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// Note that this function can be called multiple times for the same @group
// with different @source_specific in order to receive multicast packets
// from more than one source.
func (s socket) JoinMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) error {
	var arg0 *C.GSocket
	var arg1 *C.GInetAddress
	var arg2 *C.GInetAddress
	var arg3 *C.gchar
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GInetAddress)(group.Native())
	arg2 = (*C.GInetAddress)(sourceSpecific.Native())
	arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_socket_join_multicast_group_ssm(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LeaveMulticastGroup removes @socket from the multicast group defined by
// @group, @iface, and @source_specific (which must all have the same values
// they had when you joined the group).
//
// @socket remains bound to its address and port, and can still receive
// unicast messages after calling this.
//
// To unbind to a given source-specific multicast address, use
// g_socket_leave_multicast_group_ssm() instead.
func (s socket) LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) error {
	var arg0 *C.GSocket
	var arg1 *C.GInetAddress
	var arg2 C.gboolean
	var arg3 *C.gchar
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GInetAddress)(group.Native())
	if sourceSpecific {
		arg2 = C.TRUE
	}
	arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_socket_leave_multicast_group(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LeaveMulticastGroupSsm removes @socket from the multicast group defined
// by @group, @iface, and @source_specific (which must all have the same
// values they had when you joined the group).
//
// @socket remains bound to its address and port, and can still receive
// unicast messages after calling this.
func (s socket) LeaveMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) error {
	var arg0 *C.GSocket
	var arg1 *C.GInetAddress
	var arg2 *C.GInetAddress
	var arg3 *C.gchar
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GInetAddress)(group.Native())
	arg2 = (*C.GInetAddress)(sourceSpecific.Native())
	arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_socket_leave_multicast_group_ssm(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Listen marks the socket as a server socket, i.e. a socket that is used to
// accept incoming requests using g_socket_accept().
//
// Before calling this the socket must be bound to a local address using
// g_socket_bind().
//
// To set the maximum amount of outstanding clients, use
// g_socket_set_listen_backlog().
func (s socket) Listen() error {
	var arg0 *C.GSocket
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_listen(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Receive: receive data (up to @size bytes) from a socket. This is mainly
// used by connection-oriented sockets; it is identical to
// g_socket_receive_from() with @address set to nil.
//
// For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
// g_socket_receive() will always read either 0 or 1 complete messages from
// the socket. If the received message is too large to fit in @buffer, then
// the data beyond @size bytes will be discarded, without any explicit
// indication that this has occurred.
//
// For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
// number of bytes, up to @size. If more than @size bytes have been
// received, the additional data will be returned in future calls to
// g_socket_receive().
//
// If the socket is in blocking mode the call will block until there is some
// data to receive, the connection is closed, or there is an error. If there
// is no data available and the socket is in non-blocking mode, a
// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data
// is available, wait for the G_IO_IN condition.
//
// On error -1 is returned and @error is set accordingly.
func (s socket) Receive(cancellable Cancellable) (buffer []byte, size uint, gssize int, err error) {
	var arg0 *C.GSocket
	var arg1 *C.gchar // out
	var arg2 C.gsize  // out
	var arg3 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_receive(arg0, &arg1, &arg2, arg3, &gError)

	var ret0 []byte
	var ret1 uint
	var ret2 int
	var goError error

	{
		ret0 = make([]byte, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = byte(src)
		}
	}

	ret1 = uint(arg2)

	ret2 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// ReceiveFrom: receive data (up to @size bytes) from a socket.
//
// If @address is non-nil then @address will be set equal to the source
// address of the received packet. @address is owned by the caller.
//
// See g_socket_receive() for additional information.
func (s socket) ReceiveFrom(cancellable Cancellable) (address SocketAddress, buffer []byte, size uint, gssize int, err error) {
	var arg0 *C.GSocket
	var arg1 **C.GSocketAddress // out
	var arg2 *C.gchar           // out
	var arg3 C.gsize            // out
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_receive_from(arg0, &arg1, &arg2, &arg3, arg4, &gError)

	var ret0 SocketAddress
	var ret1 []byte
	var ret2 uint
	var ret3 int
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg1.Native()))).(SocketAddress)

	{
		ret1 = make([]byte, arg3)
		for i := 0; i < uintptr(arg3); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = byte(src)
		}
	}

	ret2 = uint(arg3)

	ret3 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, ret3, goError
}

// ReceiveMessage: receive data from a socket. For receiving multiple
// messages, see g_socket_receive_messages(); for easier use, see
// g_socket_receive() and g_socket_receive_from().
//
// If @address is non-nil then @address will be set equal to the source
// address of the received packet. @address is owned by the caller.
//
// @vector must point to an array of Vector structs and @num_vectors must be
// the length of this array. These structs describe the buffers that
// received data will be scattered into. If @num_vectors is -1, then
// @vectors is assumed to be terminated by a Vector with a nil buffer
// pointer.
//
// As a special case, if @num_vectors is 0 (in which case, @vectors may of
// course be nil), then a single byte is received and discarded. This is to
// facilitate the common practice of sending a single '\0' byte for the
// purposes of transferring ancillary data.
//
// @messages, if non-nil, will be set to point to a newly-allocated array of
// ControlMessage instances or nil if no such messages was received. These
// correspond to the control messages received from the kernel, one
// ControlMessage per message from the kernel. This array is nil-terminated
// and must be freed by the caller using g_free() after calling
// g_object_unref() on each element. If @messages is nil, any control
// messages received will be discarded.
//
// @num_messages, if non-nil, will be set to the number of control messages
// received.
//
// If both @messages and @num_messages are non-nil, then @num_messages gives
// the number of ControlMessage instances in @messages (ie: not including
// the nil terminator).
//
// @flags is an in/out parameter. The commonly available arguments for this
// are available in the MsgFlags enum, but the values there are the same as
// the system values, and the flags are passed in as-is, so you can pass in
// system-specific flags too (and g_socket_receive_message() may pass
// system-specific flags out). Flags passed in to the parameter affect the
// receive operation; flags returned out of it are relevant to the specific
// returned message.
//
// As with g_socket_receive(), data may be discarded if @socket is
// G_SOCKET_TYPE_DATAGRAM or G_SOCKET_TYPE_SEQPACKET and you do not provide
// enough buffer space to read a complete message. You can pass
// G_SOCKET_MSG_PEEK in @flags to peek at the current message without
// removing it from the receive queue, but there is no portable way to find
// out the length of the message other than by reading it into a
// sufficiently-large buffer.
//
// If the socket is in blocking mode the call will block until there is some
// data to receive, the connection is closed, or there is an error. If there
// is no data available and the socket is in non-blocking mode, a
// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data
// is available, wait for the G_IO_IN condition.
//
// On error -1 is returned and @error is set accordingly.
func (s socket) ReceiveMessage(vectors []InputVector, flags int, cancellable Cancellable) (address SocketAddress, messages []SocketControlMessage, numMessages int, gssize int, err error) {
	var arg0 *C.GSocket
	var arg1 **C.GSocketAddress // out
	var arg2 *C.GInputVector
	var arg3 C.gint
	var arg4 ***C.GSocketControlMessage // out
	var arg5 *C.gint                    // out
	var arg6 *C.gint
	var arg7 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg2 = (*C.GInputVector)(unsafe.Pointer(&vectors[0]))
	arg3 = len(vectors)
	defer runtime.KeepAlive(vectors)
	arg6 = (*C.gint)(flags)
	arg7 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_receive_message(arg0, &arg1, arg2, arg3, &arg4, &arg5, arg6, arg7, &gError)

	var ret0 SocketAddress
	var ret1 []SocketControlMessage
	var ret2 int
	var ret3 int
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg1.Native()))).(SocketAddress)

	{
		ret1 = make([]SocketControlMessage, arg5)
		for i := 0; i < uintptr(arg5); i++ {
			src := (**C.GSocketControlMessage)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(src.Native()))).(SocketControlMessage)
		}
	}

	ret2 = int(arg5)

	ret3 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, ret3, goError
}

// ReceiveMessages: receive multiple data messages from @socket in one go.
// This is the most complicated and fully-featured version of this call. For
// easier use, see g_socket_receive(), g_socket_receive_from(), and
// g_socket_receive_message().
//
// @messages must point to an array of Message structs and @num_messages
// must be the length of this array. Each Message contains a pointer to an
// array of Vector structs describing the buffers that the data received in
// each message will be written to. Using multiple Vectors is more
// memory-efficient than manually copying data out of a single buffer to
// multiple sources, and more system-call-efficient than making multiple
// calls to g_socket_receive(), such as in scenarios where a lot of data
// packets need to be received (e.g. high-bandwidth video streaming over
// RTP/UDP).
//
// @flags modify how all messages are received. The commonly available
// arguments for this are available in the MsgFlags enum, but the values
// there are the same as the system values, and the flags are passed in
// as-is, so you can pass in system-specific flags too. These flags affect
// the overall receive operation. Flags affecting individual messages are
// returned in Message.flags.
//
// The other members of Message are treated as described in its
// documentation.
//
// If #GSocket:blocking is true the call will block until @num_messages have
// been received, or the end of the stream is reached.
//
// If #GSocket:blocking is false the call will return up to @num_messages
// without blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in
// the operating system to be received.
//
// In blocking mode, if #GSocket:timeout is positive and is reached before
// any messages are received, G_IO_ERROR_TIMED_OUT is returned, otherwise up
// to @num_messages are returned. (Note: This is effectively the behaviour
// of `MSG_WAITFORONE` with recvmmsg().)
//
// To be notified when messages are available, wait for the G_IO_IN
// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
// from g_socket_receive_messages() even if you were previously notified of
// a G_IO_IN condition.
//
// If the remote peer closes the connection, any messages queued in the
// operating system will be returned, and subsequent calls to
// g_socket_receive_messages() will return 0 (with no error set).
//
// On error -1 is returned and @error is set accordingly. An error will only
// be returned if zero messages could be received; otherwise the number of
// messages successfully received before the error will be returned.
func (s socket) ReceiveMessages(messages []InputMessage, flags int, cancellable Cancellable) (gint int, err error) {
	var arg0 *C.GSocket
	var arg1 *C.GInputMessage
	var arg2 C.guint
	var arg3 C.gint
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	{
		var dst []C.GInputMessage
		ptr := C.malloc(C.sizeof_GInputMessage * len(messages))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(messages)
		sliceHeader.Cap = len(messages)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(messages); i++ {
			src := messages[i]
			dst[i] = (C.GInputMessage)(src.Native())
		}

		arg1 = (*C.GInputMessage)(unsafe.Pointer(ptr))
		arg2 = len(messages)
	}
	arg3 = C.gint(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_receive_messages(arg0, arg1, arg2, arg3, arg4, &gError)

	var ret0 int
	var goError error

	ret0 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
// except that the choice of blocking or non-blocking behavior is determined
// by the @blocking argument rather than by @socket's properties.
func (s socket) ReceiveWithBlocking(blocking bool, cancellable Cancellable) (buffer []byte, size uint, gssize int, err error) {
	var arg0 *C.GSocket
	var arg1 *C.gchar // out
	var arg2 C.gsize  // out
	var arg3 C.gboolean
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	if blocking {
		arg3 = C.TRUE
	}
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_receive_with_blocking(arg0, &arg1, &arg2, arg3, arg4, &gError)

	var ret0 []byte
	var ret1 uint
	var ret2 int
	var goError error

	{
		ret0 = make([]byte, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = byte(src)
		}
	}

	ret1 = uint(arg2)

	ret2 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// Send tries to send @size bytes from @buffer on the socket. This is mainly
// used by connection-oriented sockets; it is identical to
// g_socket_send_to() with @address set to nil.
//
// If the socket is in blocking mode the call will block until there is
// space for the data in the socket queue. If there is no space available
// and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
// will be returned. To be notified when space is available, wait for the
// G_IO_OUT condition. Note though that you may still receive
// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
// notified of a G_IO_OUT condition. (On Windows in particular, this is very
// common due to the way the underlying APIs work.)
//
// On error -1 is returned and @error is set accordingly.
func (s socket) Send(buffer []byte, cancellable Cancellable) (gssize int, err error) {
	var arg0 *C.GSocket
	var arg1 *C.gchar
	var arg2 C.gsize
	var arg3 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
	arg2 = len(buffer)
	defer runtime.KeepAlive(buffer)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_send(arg0, arg1, arg2, arg3, &gError)

	var ret0 int
	var goError error

	ret0 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SendMessage: send data to @address on @socket. For sending multiple
// messages see g_socket_send_messages(); for easier use, see
// g_socket_send() and g_socket_send_to().
//
// If @address is nil then the message is sent to the default receiver (set
// by g_socket_connect()).
//
// @vectors must point to an array of Vector structs and @num_vectors must
// be the length of this array. (If @num_vectors is -1, then @vectors is
// assumed to be terminated by a Vector with a nil buffer pointer.) The
// Vector structs describe the buffers that the sent data will be gathered
// from. Using multiple Vectors is more memory-efficient than manually
// copying data from multiple sources into a single buffer, and more
// network-efficient than making multiple calls to g_socket_send().
//
// @messages, if non-nil, is taken to point to an array of @num_messages
// ControlMessage instances. These correspond to the control messages to be
// sent on the socket. If @num_messages is -1 then @messages is treated as a
// nil-terminated array.
//
// @flags modify how the message is sent. The commonly available arguments
// for this are available in the MsgFlags enum, but the values there are the
// same as the system values, and the flags are passed in as-is, so you can
// pass in system-specific flags too.
//
// If the socket is in blocking mode the call will block until there is
// space for the data in the socket queue. If there is no space available
// and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
// will be returned. To be notified when space is available, wait for the
// G_IO_OUT condition. Note though that you may still receive
// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
// notified of a G_IO_OUT condition. (On Windows in particular, this is very
// common due to the way the underlying APIs work.)
//
// The sum of the sizes of each Vector in vectors must not be greater than
// G_MAXSSIZE. If the message can be larger than this, then it is mandatory
// to use the g_socket_send_message_with_timeout() function.
//
// On error -1 is returned and @error is set accordingly.
func (s socket) SendMessage(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, cancellable Cancellable) (gssize int, err error) {
	var arg0 *C.GSocket
	var arg1 *C.GSocketAddress
	var arg2 *C.GOutputVector
	var arg3 C.gint
	var arg4 **C.GSocketControlMessage
	var arg5 C.gint
	var arg6 C.gint
	var arg7 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	arg2 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	arg3 = len(vectors)
	defer runtime.KeepAlive(vectors)
	{
		var dst []*C.GSocketControlMessage
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(messages))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(messages)
		sliceHeader.Cap = len(messages)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(messages); i++ {
			src := messages[i]
			dst[i] = (*C.GSocketControlMessage)(src.Native())
		}

		arg4 = (**C.GSocketControlMessage)(unsafe.Pointer(ptr))
		arg5 = len(messages)
	}
	arg6 = C.gint(flags)
	arg7 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_send_message(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, &gError)

	var ret0 int
	var goError error

	ret0 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SendMessageWithTimeout: this behaves exactly the same as
// g_socket_send_message(), except that the choice of timeout behavior is
// determined by the @timeout_us argument rather than by @socket's
// properties.
//
// On error G_POLLABLE_RETURN_FAILED is returned and @error is set
// accordingly, or if the socket is currently not writable
// G_POLLABLE_RETURN_WOULD_BLOCK is returned. @bytes_written will contain 0
// in both cases.
func (s socket) SendMessageWithTimeout(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, timeoutUs int64, cancellable Cancellable) (bytesWritten uint, pollableReturn PollableReturn, err error) {
	var arg0 *C.GSocket
	var arg1 *C.GSocketAddress
	var arg2 *C.GOutputVector
	var arg3 C.gint
	var arg4 **C.GSocketControlMessage
	var arg5 C.gint
	var arg6 C.gint
	var arg7 C.gint64
	var arg8 *C.gsize // out
	var arg9 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	arg2 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	arg3 = len(vectors)
	defer runtime.KeepAlive(vectors)
	{
		var dst []*C.GSocketControlMessage
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(messages))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(messages)
		sliceHeader.Cap = len(messages)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(messages); i++ {
			src := messages[i]
			dst[i] = (*C.GSocketControlMessage)(src.Native())
		}

		arg4 = (**C.GSocketControlMessage)(unsafe.Pointer(ptr))
		arg5 = len(messages)
	}
	arg6 = C.gint(flags)
	arg7 = C.gint64(timeoutUs)
	arg9 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_send_message_with_timeout(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, &arg8, arg9, &gError)

	var ret0 uint
	var ret1 PollableReturn
	var goError error

	ret0 = uint(arg8)

	ret1 = PollableReturn(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// SendMessages: send multiple data messages from @socket in one go. This is
// the most complicated and fully-featured version of this call. For easier
// use, see g_socket_send(), g_socket_send_to(), and
// g_socket_send_message().
//
// @messages must point to an array of Message structs and @num_messages
// must be the length of this array. Each Message contains an address to
// send the data to, and a pointer to an array of Vector structs to describe
// the buffers that the data to be sent for each message will be gathered
// from. Using multiple Vectors is more memory-efficient than manually
// copying data from multiple sources into a single buffer, and more
// network-efficient than making multiple calls to g_socket_send(). Sending
// multiple messages in one go avoids the overhead of making a lot of
// syscalls in scenarios where a lot of data packets need to be sent (e.g.
// high-bandwidth video streaming over RTP/UDP), or where the same data
// needs to be sent to multiple recipients.
//
// @flags modify how the message is sent. The commonly available arguments
// for this are available in the MsgFlags enum, but the values there are the
// same as the system values, and the flags are passed in as-is, so you can
// pass in system-specific flags too.
//
// If the socket is in blocking mode the call will block until there is
// space for all the data in the socket queue. If there is no space
// available and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK
// error will be returned if no data was written at all, otherwise the
// number of messages sent will be returned. To be notified when space is
// available, wait for the G_IO_OUT condition. Note though that you may
// still receive G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you
// were previously notified of a G_IO_OUT condition. (On Windows in
// particular, this is very common due to the way the underlying APIs work.)
//
// On error -1 is returned and @error is set accordingly. An error will only
// be returned if zero messages could be sent; otherwise the number of
// messages successfully sent before the error will be returned.
func (s socket) SendMessages(messages []OutputMessage, flags int, cancellable Cancellable) (gint int, err error) {
	var arg0 *C.GSocket
	var arg1 *C.GOutputMessage
	var arg2 C.guint
	var arg3 C.gint
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	{
		var dst []C.GOutputMessage
		ptr := C.malloc(C.sizeof_GOutputMessage * len(messages))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(messages)
		sliceHeader.Cap = len(messages)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(messages); i++ {
			src := messages[i]
			dst[i] = (C.GOutputMessage)(src.Native())
		}

		arg1 = (*C.GOutputMessage)(unsafe.Pointer(ptr))
		arg2 = len(messages)
	}
	arg3 = C.gint(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_send_messages(arg0, arg1, arg2, arg3, arg4, &gError)

	var ret0 int
	var goError error

	ret0 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SendTo tries to send @size bytes from @buffer to @address. If @address is
// nil then the message is sent to the default receiver (set by
// g_socket_connect()).
//
// See g_socket_send() for additional information.
func (s socket) SendTo(address SocketAddress, buffer []byte, cancellable Cancellable) (gssize int, err error) {
	var arg0 *C.GSocket
	var arg1 *C.GSocketAddress
	var arg2 *C.gchar
	var arg3 C.gsize
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	arg2 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
	arg3 = len(buffer)
	defer runtime.KeepAlive(buffer)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_send_to(arg0, arg1, arg2, arg3, arg4, &gError)

	var ret0 int
	var goError error

	ret0 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SendWithBlocking: this behaves exactly the same as g_socket_send(),
// except that the choice of blocking or non-blocking behavior is determined
// by the @blocking argument rather than by @socket's properties.
func (s socket) SendWithBlocking(buffer []byte, blocking bool, cancellable Cancellable) (gssize int, err error) {
	var arg0 *C.GSocket
	var arg1 *C.gchar
	var arg2 C.gsize
	var arg3 C.gboolean
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
	arg2 = len(buffer)
	defer runtime.KeepAlive(buffer)
	if blocking {
		arg3 = C.TRUE
	}
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_send_with_blocking(arg0, arg1, arg2, arg3, arg4, &gError)

	var ret0 int
	var goError error

	ret0 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SetBlocking sets the blocking mode of the socket. In blocking mode all
// operations (which don’t take an explicit blocking parameter) block until
// they succeed or there is an error. In non-blocking mode all functions
// return results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
//
// All sockets are created in blocking mode. However, note that the platform
// level socket is always non-blocking, and blocking mode is a GSocket level
// feature.
func (s socket) SetBlocking(blocking bool) {
	var arg0 *C.GSocket
	var arg1 C.gboolean

	arg0 = (*C.GSocket)(s.Native())
	if blocking {
		arg1 = C.TRUE
	}

	C.g_socket_set_blocking(arg0, arg1)
}

// SetBroadcast sets whether @socket should allow sending to broadcast
// addresses. This is false by default.
func (s socket) SetBroadcast(broadcast bool) {
	var arg0 *C.GSocket
	var arg1 C.gboolean

	arg0 = (*C.GSocket)(s.Native())
	if broadcast {
		arg1 = C.TRUE
	}

	C.g_socket_set_broadcast(arg0, arg1)
}

// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying
// socket. When this flag is set on a socket, the system will attempt to
// verify that the remote socket endpoint is still present if a sufficiently
// long period of time passes with no data being exchanged. If the system is
// unable to verify the presence of the remote endpoint, it will
// automatically close the connection.
//
// This option is only functional on certain kinds of sockets. (Notably,
// G_SOCKET_PROTOCOL_TCP sockets.)
//
// The exact time between pings is system- and protocol-dependent, but will
// normally be at least two hours. Most commonly, you would set this flag on
// a server socket if you want to allow clients to remain idle for long
// periods of time, but also want to ensure that connections are eventually
// garbage-collected if clients crash or become unreachable.
func (s socket) SetKeepalive(keepalive bool) {
	var arg0 *C.GSocket
	var arg1 C.gboolean

	arg0 = (*C.GSocket)(s.Native())
	if keepalive {
		arg1 = C.TRUE
	}

	C.g_socket_set_keepalive(arg0, arg1)
}

// SetListenBacklog sets the maximum number of outstanding connections
// allowed when listening on this socket. If more clients than this are
// connecting to the socket and the application is not handling them on time
// then the new connections will be refused.
//
// Note that this must be called before g_socket_listen() and has no effect
// if called after that.
func (s socket) SetListenBacklog(backlog int) {
	var arg0 *C.GSocket
	var arg1 C.gint

	arg0 = (*C.GSocket)(s.Native())
	arg1 = C.gint(backlog)

	C.g_socket_set_listen_backlog(arg0, arg1)
}

// SetMulticastLoopback sets whether outgoing multicast packets will be
// received by sockets listening on that multicast address on the same host.
// This is true by default.
func (s socket) SetMulticastLoopback(loopback bool) {
	var arg0 *C.GSocket
	var arg1 C.gboolean

	arg0 = (*C.GSocket)(s.Native())
	if loopback {
		arg1 = C.TRUE
	}

	C.g_socket_set_multicast_loopback(arg0, arg1)
}

// SetMulticastTtl sets the time-to-live for outgoing multicast datagrams on
// @socket. By default, this is 1, meaning that multicast packets will not
// leave the local network.
func (s socket) SetMulticastTtl(ttl uint) {
	var arg0 *C.GSocket
	var arg1 C.guint

	arg0 = (*C.GSocket)(s.Native())
	arg1 = C.guint(ttl)

	C.g_socket_set_multicast_ttl(arg0, arg1)
}

// SetOption sets the value of an integer-valued option on @socket, as with
// setsockopt(). (If you need to set a non-integer-valued option, you will
// need to call setsockopt() directly.)
//
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
// headers that will define most of the standard/portable socket options.
// For unusual socket protocols or platform-dependent options, you may need
// to include additional headers.
func (s socket) SetOption(level int, optname int, value int) error {
	var arg0 *C.GSocket
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	arg1 = C.gint(level)
	arg2 = C.gint(optname)
	arg3 = C.gint(value)

	ret := C.g_socket_set_option(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetTimeout sets the time in seconds after which I/O operations on @socket
// will time out if they have not yet completed.
//
// On a blocking socket, this means that any blocking #GSocket operation
// will time out after @timeout seconds of inactivity, returning
// G_IO_ERROR_TIMED_OUT.
//
// On a non-blocking socket, calls to g_socket_condition_wait() will also
// fail with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
// g_socket_create_source() will trigger after @timeout seconds of
// inactivity, with the requested condition set, at which point calling
// g_socket_receive(), g_socket_send(), g_socket_check_connect_result(),
// etc, will fail with G_IO_ERROR_TIMED_OUT.
//
// If @timeout is 0 (the default), operations will never time out on their
// own.
//
// Note that if an I/O operation is interrupted by a signal, this may cause
// the timeout to be reset.
func (s socket) SetTimeout(timeout uint) {
	var arg0 *C.GSocket
	var arg1 C.guint

	arg0 = (*C.GSocket)(s.Native())
	arg1 = C.guint(timeout)

	C.g_socket_set_timeout(arg0, arg1)
}

// SetTtl sets the time-to-live for outgoing unicast packets on @socket. By
// default the platform-specific default value is used.
func (s socket) SetTtl(ttl uint) {
	var arg0 *C.GSocket
	var arg1 C.guint

	arg0 = (*C.GSocket)(s.Native())
	arg1 = C.guint(ttl)

	C.g_socket_set_ttl(arg0, arg1)
}

// Shutdown: shut down part or all of a full-duplex connection.
//
// If @shutdown_read is true then the receiving side of the connection is
// shut down, and further reading is disallowed.
//
// If @shutdown_write is true then the sending side of the connection is
// shut down, and further writing is disallowed.
//
// It is allowed for both @shutdown_read and @shutdown_write to be true.
//
// One example where it is useful to shut down only one side of a connection
// is graceful disconnect for TCP connections where you close the sending
// side, then wait for the other side to close the connection, thus ensuring
// that the other side saw all sent data.
func (s socket) Shutdown(shutdownRead bool, shutdownWrite bool) error {
	var arg0 *C.GSocket
	var arg1 C.gboolean
	var arg2 C.gboolean
	var gError *C.GError

	arg0 = (*C.GSocket)(s.Native())
	if shutdownRead {
		arg1 = C.TRUE
	}
	if shutdownWrite {
		arg2 = C.TRUE
	}

	ret := C.g_socket_shutdown(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SpeaksIpv4 checks if a socket is capable of speaking IPv4.
//
// IPv4 sockets are capable of speaking IPv4. On some operating systems and
// under some combinations of circumstances IPv6 sockets are also capable of
// speaking IPv4. See RFC 3493 section 3.7 for more information.
//
// No other types of sockets are currently considered as being capable of
// speaking IPv4.
func (s socket) SpeaksIpv4() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(s.Native())

	ret := C.g_socket_speaks_ipv4(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}
