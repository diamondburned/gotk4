// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_main_context_get_type()), F: marshalMainContext},
		{T: externglib.Type(C.g_main_loop_get_type()), F: marshalMainLoop},
		{T: externglib.Type(C.g_source_get_type()), F: marshalSource},
	})
}

// MainContextPusher: opaque type. See g_main_context_pusher_new() for details.
type MainContextPusher = C.void

// SourceFunc specifies the type of function passed to g_timeout_add(),
// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
//
// When calling g_source_set_callback(), you may need to cast a function of a
// different type to this type. Use G_SOURCE_FUNC() to avoid warnings about
// incompatible function types.
type SourceFunc func(userData cgo.Handle) (ok bool)

//export gotk4_SourceFunc
func gotk4_SourceFunc(arg0 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	var userData cgo.Handle // out

	userData = (cgo.Handle)(unsafe.Pointer(arg0))

	fn := v.(SourceFunc)
	ok := fn(userData)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// GetCurrentTime: equivalent to the UNIX gettimeofday() function, but portable.
//
// You may find g_get_real_time() to be more convenient.
//
// Deprecated: Val is not year-2038-safe. Use g_get_real_time() instead.
func GetCurrentTime(result *TimeVal) {
	var _arg1 *C.GTimeVal // out

	_arg1 = (*C.GTimeVal)(unsafe.Pointer(result))

	C.g_get_current_time(_arg1)
}

// GetMonotonicTime queries the system monotonic time.
//
// The monotonic clock will always increase and doesn't suffer discontinuities
// when the user (or NTP) changes the system time. It may or may not continue to
// tick during times where the machine is suspended.
//
// We try to use the clock that corresponds as closely as possible to the
// passage of time as measured by system calls such as poll() but it may not
// always be possible to do this.
func GetMonotonicTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_monotonic_time()

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// GetRealTime queries the system wall-clock time.
//
// This call is functionally equivalent to g_get_current_time() except that the
// return value is often more convenient than dealing with a Val.
//
// You should only use this call if you are actually interested in the real
// wall-clock time. g_get_monotonic_time() is probably more useful for measuring
// intervals.
func GetRealTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_real_time()

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// IdleRemoveByData removes the idle function with the given data.
func IdleRemoveByData(data cgo.Handle) bool {
	var _arg1 C.gpointer // out
	var _cret C.gboolean // in

	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.g_idle_remove_by_data(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewIdleSource creates a new idle source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed. Note that the
// default priority for idle sources is G_PRIORITY_DEFAULT_IDLE, as compared to
// other sources which have a default priority of G_PRIORITY_DEFAULT.
func NewIdleSource() *Source {
	var _cret *C.GSource // in

	_cret = C.g_idle_source_new()

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(_source, func(v *Source) {
		C.g_source_unref((*C.GSource)(unsafe.Pointer(v)))
	})

	return _source
}

// MainCurrentSource returns the currently firing source for this thread.
func MainCurrentSource() *Source {
	var _cret *C.GSource // in

	_cret = C.g_main_current_source()

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(_source, func(v *Source) {
		C.g_source_unref((*C.GSource)(unsafe.Pointer(v)))
	})

	return _source
}

// MainDepth returns the depth of the stack of calls to
// g_main_context_dispatch() on any Context in the current thread. That is, when
// called from the toplevel, it gives 0. When called from within a callback from
// g_main_context_iteration() (or g_main_loop_run(), etc.) it returns 1. When
// called from within a callback to a recursive call to
// g_main_context_iteration(), it returns 2. And so forth.
//
// This function is useful in a situation like the following: Imagine an
// extremely simple "garbage collected" system.
//
//    gpointer
//    allocate_memory (gsize size)
//    {
//      FreeListBlock *block = g_new (FreeListBlock, 1);
//      block->mem = g_malloc (size);
//      block->depth = g_main_depth ();
//      free_list = g_list_prepend (free_list, block);
//      return block->mem;
//    }
//
//    void
//    free_allocated_memory (void)
//    {
//      GList *l;
//
//      int depth = g_main_depth ();
//      for (l = free_list; l; );
//        {
//          GList *next = l->next;
//          FreeListBlock *block = l->data;
//          if (block->depth > depth)
//            {
//              g_free (block->mem);
//              g_free (block);
//              free_list = g_list_delete_link (free_list, l);
//            }
//
//          l = next;
//        }
//      }
//
// There is a temptation to use g_main_depth() to solve problems with
// reentrancy. For instance, while waiting for data to be received from the
// network in response to a menu item, the menu item might be selected again. It
// might seem that one could make the menu item's callback return immediately
// and do nothing if g_main_depth() returns a value greater than 1. However,
// this should be avoided since the user then sees selecting the menu item do
// nothing. Furthermore, you'll find yourself adding these checks all over your
// code, since there are doubtless many, many things that the user could do.
// Instead, you can use the following techniques:
//
// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent the user from
// interacting with elements while the main loop is recursing.
//
// 2. Avoid main loop recursion in situations where you can't handle arbitrary
// callbacks. Instead, structure your code so that you simply return to the main
// loop and then get called again when there is more work to do.
func MainDepth() int {
	var _cret C.gint // in

	_cret = C.g_main_depth()

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NewTimeoutSource creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func NewTimeoutSource(interval uint) *Source {
	var _arg1 C.guint    // out
	var _cret *C.GSource // in

	_arg1 = C.guint(interval)

	_cret = C.g_timeout_source_new(_arg1)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(_source, func(v *Source) {
		C.g_source_unref((*C.GSource)(unsafe.Pointer(v)))
	})

	return _source
}

// TimeoutSourceNewSeconds creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The scheduling granularity/accuracy of this timeout source will be in
// seconds.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func TimeoutSourceNewSeconds(interval uint) *Source {
	var _arg1 C.guint    // out
	var _cret *C.GSource // in

	_arg1 = C.guint(interval)

	_cret = C.g_timeout_source_new_seconds(_arg1)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(_source, func(v *Source) {
		C.g_source_unref((*C.GSource)(unsafe.Pointer(v)))
	})

	return _source
}

// MainContext: `GMainContext` struct is an opaque data type representing a set
// of sources to be handled in a main loop.
type MainContext struct {
	native C.GMainContext
}

func marshalMainContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MainContext)(unsafe.Pointer(b)), nil
}

// NewMainContext constructs a struct MainContext.
func NewMainContext() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_new()

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(unsafe.Pointer(_cret))
	C.g_main_context_ref(_cret)
	runtime.SetFinalizer(_mainContext, func(v *MainContext) {
		C.g_main_context_unref((*C.GMainContext)(unsafe.Pointer(v)))
	})

	return _mainContext
}

// Native returns the underlying C source pointer.
func (m *MainContext) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// Acquire tries to become the owner of the specified context. If some other
// thread is the owner of the context, returns false immediately. Ownership is
// properly recursive: the owner can require ownership again and will release
// ownership when g_main_context_release() is called as many times as
// g_main_context_acquire().
//
// You must be the owner of a context before you can call
// g_main_context_prepare(), g_main_context_query(), g_main_context_check(),
// g_main_context_dispatch().
func (context *MainContext) Acquire() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	_cret = C.g_main_context_acquire(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddPoll adds a file descriptor to the set of file descriptors polled for this
// context. This will very seldom be used directly. Instead a typical event
// source will use g_source_add_unix_fd() instead.
func (context *MainContext) AddPoll(fd *PollFD, priority int) {
	var _arg0 *C.GMainContext // out
	var _arg1 *C.GPollFD      // out
	var _arg2 C.gint          // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))
	_arg1 = (*C.GPollFD)(unsafe.Pointer(fd))
	_arg2 = C.gint(priority)

	C.g_main_context_add_poll(_arg0, _arg1, _arg2)
}

// Check passes the results of polling back to the main loop. You should be
// careful to pass @fds and its length @n_fds as received from
// g_main_context_query(), as this functions relies on assumptions on how @fds
// is filled.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (context *MainContext) Check(maxPriority int, fds []PollFD) bool {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // out
	var _arg2 *C.GPollFD
	var _arg3 C.gint
	var _cret C.gboolean // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))
	_arg1 = C.gint(maxPriority)
	_arg3 = C.gint(len(fds))
	_arg2 = (*C.GPollFD)(unsafe.Pointer(&fds[0]))

	_cret = C.g_main_context_check(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dispatch dispatches all pending sources.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (context *MainContext) Dispatch() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	C.g_main_context_dispatch(_arg0)
}

// FindSourceByFuncsUserData finds a source with the given source functions and
// user data. If multiple sources exist with the same source function and user
// data, the first one found will be returned.
func (context *MainContext) FindSourceByFuncsUserData(funcs *SourceFuncs, userData cgo.Handle) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 *C.GSourceFuncs // out
	var _arg2 C.gpointer      // out
	var _cret *C.GSource      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))
	_arg1 = (*C.GSourceFuncs)(unsafe.Pointer(funcs))
	_arg2 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_main_context_find_source_by_funcs_user_data(_arg0, _arg1, _arg2)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(_source, func(v *Source) {
		C.g_source_unref((*C.GSource)(unsafe.Pointer(v)))
	})

	return _source
}

// FindSourceByID finds a #GSource given a pair of context and ID.
//
// It is a programmer error to attempt to look up a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a source
// ID which may have already been removed. An example is when scheduling an idle
// to run in another thread with g_idle_add(): the idle may already have run and
// been removed by the time this function is called on its (now invalid) source
// ID. This source ID may have been reissued, leading to the operation being
// performed against the wrong source.
func (context *MainContext) FindSourceByID(sourceId uint) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 C.guint         // out
	var _cret *C.GSource      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))
	_arg1 = C.guint(sourceId)

	_cret = C.g_main_context_find_source_by_id(_arg0, _arg1)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(_source, func(v *Source) {
		C.g_source_unref((*C.GSource)(unsafe.Pointer(v)))
	})

	return _source
}

// FindSourceByUserData finds a source with the given user data for the
// callback. If multiple sources exist with the same user data, the first one
// found will be returned.
func (context *MainContext) FindSourceByUserData(userData cgo.Handle) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gpointer      // out
	var _cret *C.GSource      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))
	_arg1 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_main_context_find_source_by_user_data(_arg0, _arg1)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(_source, func(v *Source) {
		C.g_source_unref((*C.GSource)(unsafe.Pointer(v)))
	})

	return _source
}

// IsOwner determines whether this thread holds the (recursive) ownership of
// this Context. This is useful to know before waiting on another thread that
// may be blocking to get ownership of @context.
func (context *MainContext) IsOwner() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	_cret = C.g_main_context_is_owner(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iteration runs a single iteration for the given main loop. This involves
// checking to see if any event sources are ready to be processed, then if no
// events sources are ready and @may_block is true, waiting for a source to
// become ready, then dispatching the highest priority events sources that are
// ready. Otherwise, if @may_block is false sources are not waited to become
// ready, only those highest priority events sources will be dispatched (if
// any), that are ready at this given moment without further waiting.
//
// Note that even when @may_block is true, it is still possible for
// g_main_context_iteration() to return false, since the wait may be interrupted
// for other reasons than an event source becoming ready.
func (context *MainContext) Iteration(mayBlock bool) bool {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))
	if mayBlock {
		_arg1 = C.TRUE
	}

	_cret = C.g_main_context_iteration(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pending checks if any sources have pending events for the given context.
func (context *MainContext) Pending() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	_cret = C.g_main_context_pending(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopThreadDefault pops @context off the thread-default context stack
// (verifying that it was on the top of the stack).
func (context *MainContext) PopThreadDefault() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	C.g_main_context_pop_thread_default(_arg0)
}

// Prepare prepares to poll sources within a main loop. The resulting
// information for polling is determined by calling g_main_context_query ().
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (context *MainContext) Prepare() (int, bool) {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	_cret = C.g_main_context_prepare(_arg0, &_arg1)

	var _priority int // out
	var _ok bool      // out

	_priority = int(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _priority, _ok
}

// PushThreadDefault acquires @context and sets it as the thread-default context
// for the current thread. This will cause certain asynchronous operations (such
// as most [gio][gio]-based I/O) which are started in this thread to run under
// @context and deliver their results to its main loop, rather than running
// under the global default context in the main thread. Note that calling this
// function changes the context returned by g_main_context_get_thread_default(),
// not the one returned by g_main_context_default(), so it does not affect the
// context used by functions like g_idle_add().
//
// Normally you would call this function shortly after creating a new thread,
// passing it a Context which will be run by a Loop in that thread, to set a new
// default context for all async operations in that thread. In this case you may
// not need to ever call g_main_context_pop_thread_default(), assuming you want
// the new Context to be the default for the whole lifecycle of the thread.
//
// If you don't have control over how the new thread was created (e.g. in the
// new thread isn't newly created, or if the thread life cycle is managed by a
// Pool), it is always suggested to wrap the logic that needs to use the new
// Context inside a g_main_context_push_thread_default() /
// g_main_context_pop_thread_default() pair, otherwise threads that are re-used
// will end up never explicitly releasing the Context reference they hold.
//
// In some cases you may want to schedule a single operation in a non-default
// context, or temporarily use a non-default context in the main thread. In that
// case, you can wrap the call to the asynchronous operation inside a
// g_main_context_push_thread_default() / g_main_context_pop_thread_default()
// pair, but it is up to you to ensure that no other asynchronous operations
// accidentally get started while the non-default context is active.
//
// Beware that libraries that predate this function may not correctly handle
// being used from a thread with a thread-default context. Eg, see
// g_file_supports_thread_contexts().
func (context *MainContext) PushThreadDefault() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	C.g_main_context_push_thread_default(_arg0)
}

// Ref increases the reference count on a Context object by one.
func (context *MainContext) ref() *MainContext {
	var _arg0 *C.GMainContext // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	_cret = C.g_main_context_ref(_arg0)

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(unsafe.Pointer(_cret))
	C.g_main_context_ref(_cret)
	runtime.SetFinalizer(_mainContext, func(v *MainContext) {
		C.g_main_context_unref((*C.GMainContext)(unsafe.Pointer(v)))
	})

	return _mainContext
}

// Release releases ownership of a context previously acquired by this thread
// with g_main_context_acquire(). If the context was acquired multiple times,
// the ownership will be released only when g_main_context_release() is called
// as many times as it was acquired.
func (context *MainContext) Release() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	C.g_main_context_release(_arg0)
}

// RemovePoll removes file descriptor from the set of file descriptors to be
// polled for a particular context.
func (context *MainContext) RemovePoll(fd *PollFD) {
	var _arg0 *C.GMainContext // out
	var _arg1 *C.GPollFD      // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))
	_arg1 = (*C.GPollFD)(unsafe.Pointer(fd))

	C.g_main_context_remove_poll(_arg0, _arg1)
}

// Unref decreases the reference count on a Context object by one. If the result
// is zero, free the context and free all associated memory.
func (context *MainContext) unref() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	C.g_main_context_unref(_arg0)
}

// Wakeup: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (context *MainContext) Wakeup() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(context))

	C.g_main_context_wakeup(_arg0)
}

// MainLoop: `GMainLoop` struct is an opaque data type representing the main
// event loop of a GLib or GTK+ application.
type MainLoop struct {
	native C.GMainLoop
}

func marshalMainLoop(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MainLoop)(unsafe.Pointer(b)), nil
}

// NewMainLoop constructs a struct MainLoop.
func NewMainLoop(context *MainContext, isRunning bool) *MainLoop {
	var _arg1 *C.GMainContext // out
	var _arg2 C.gboolean      // out
	var _cret *C.GMainLoop    // in

	_arg1 = (*C.GMainContext)(unsafe.Pointer(context))
	if isRunning {
		_arg2 = C.TRUE
	}

	_cret = C.g_main_loop_new(_arg1, _arg2)

	var _mainLoop *MainLoop // out

	_mainLoop = (*MainLoop)(unsafe.Pointer(_cret))
	C.g_main_loop_ref(_cret)
	runtime.SetFinalizer(_mainLoop, func(v *MainLoop) {
		C.g_main_loop_unref((*C.GMainLoop)(unsafe.Pointer(v)))
	})

	return _mainLoop
}

// Native returns the underlying C source pointer.
func (m *MainLoop) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// Context returns the Context of @loop.
func (loop *MainLoop) Context() *MainContext {
	var _arg0 *C.GMainLoop    // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(loop))

	_cret = C.g_main_loop_get_context(_arg0)

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(unsafe.Pointer(_cret))
	C.g_main_context_ref(_cret)
	runtime.SetFinalizer(_mainContext, func(v *MainContext) {
		C.g_main_context_unref((*C.GMainContext)(unsafe.Pointer(v)))
	})

	return _mainContext
}

// IsRunning checks to see if the main loop is currently being run via
// g_main_loop_run().
func (loop *MainLoop) IsRunning() bool {
	var _arg0 *C.GMainLoop // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(loop))

	_cret = C.g_main_loop_is_running(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Quit stops a Loop from running. Any calls to g_main_loop_run() for the loop
// will return.
//
// Note that sources that have already been dispatched when g_main_loop_quit()
// is called will still be executed.
func (loop *MainLoop) Quit() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(loop))

	C.g_main_loop_quit(_arg0)
}

// Ref increases the reference count on a Loop object by one.
func (loop *MainLoop) ref() *MainLoop {
	var _arg0 *C.GMainLoop // out
	var _cret *C.GMainLoop // in

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(loop))

	_cret = C.g_main_loop_ref(_arg0)

	var _mainLoop *MainLoop // out

	_mainLoop = (*MainLoop)(unsafe.Pointer(_cret))
	C.g_main_loop_ref(_cret)
	runtime.SetFinalizer(_mainLoop, func(v *MainLoop) {
		C.g_main_loop_unref((*C.GMainLoop)(unsafe.Pointer(v)))
	})

	return _mainLoop
}

// Run runs a main loop until g_main_loop_quit() is called on the loop. If this
// is called for the thread of the loop's Context, it will process events from
// the loop, otherwise it will simply wait.
func (loop *MainLoop) Run() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(loop))

	C.g_main_loop_run(_arg0)
}

// Unref decreases the reference count on a Loop object by one. If the result is
// zero, free the loop and free all associated memory.
func (loop *MainLoop) unref() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(loop))

	C.g_main_loop_unref(_arg0)
}

// Source: `GSource` struct is an opaque data type representing an event source.
type Source struct {
	native C.GSource
}

func marshalSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Source)(unsafe.Pointer(b)), nil
}

// NewSource constructs a struct Source.
func NewSource(sourceFuncs *SourceFuncs, structSize uint) *Source {
	var _arg1 *C.GSourceFuncs // out
	var _arg2 C.guint         // out
	var _cret *C.GSource      // in

	_arg1 = (*C.GSourceFuncs)(unsafe.Pointer(sourceFuncs))
	_arg2 = C.guint(structSize)

	_cret = C.g_source_new(_arg1, _arg2)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(_source, func(v *Source) {
		C.g_source_unref((*C.GSource)(unsafe.Pointer(v)))
	})

	return _source
}

// Native returns the underlying C source pointer.
func (s *Source) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// AddChildSource adds @child_source to @source as a "polled" source; when
// @source is added to a Context, @child_source will be automatically added with
// the same priority, when @child_source is triggered, it will cause @source to
// dispatch (in addition to calling its own callback), and when @source is
// destroyed, it will destroy @child_source as well. (@source will also still be
// dispatched if its own prepare/check functions indicate that it is ready.)
//
// If you don't need @child_source to do anything on its own when it triggers,
// you can call g_source_set_dummy_callback() on it to set a callback that does
// nothing (except return true if appropriate).
//
// @source will hold a reference on @child_source while @child_source is
// attached to it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (source *Source) AddChildSource(childSource *Source) {
	var _arg0 *C.GSource // out
	var _arg1 *C.GSource // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (*C.GSource)(unsafe.Pointer(childSource))

	C.g_source_add_child_source(_arg0, _arg1)
}

// AddPoll adds a file descriptor to the set of file descriptors polled for this
// source. This is usually combined with g_source_new() to add an event source.
// The event source's check function will typically test the @revents field in
// the FD struct and return true if events need to be processed.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// Using this API forces the linear scanning of event sources on each main loop
// iteration. Newly-written event sources should try to use
// g_source_add_unix_fd() instead of this API.
func (source *Source) AddPoll(fd *PollFD) {
	var _arg0 *C.GSource // out
	var _arg1 *C.GPollFD // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (*C.GPollFD)(unsafe.Pointer(fd))

	C.g_source_add_poll(_arg0, _arg1)
}

// Attach adds a #GSource to a @context so that it will be executed within that
// context. Remove it by calling g_source_destroy().
//
// This function is safe to call from any thread, regardless of which thread the
// @context is running in.
func (source *Source) Attach(context *MainContext) uint {
	var _arg0 *C.GSource      // out
	var _arg1 *C.GMainContext // out
	var _cret C.guint         // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (*C.GMainContext)(unsafe.Pointer(context))

	_cret = C.g_source_attach(_arg0, _arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Destroy removes a source from its Context, if any, and mark it as destroyed.
// The source cannot be subsequently added to another context. It is safe to
// call this on sources which have already been removed from their context.
//
// This does not unref the #GSource: if you still hold a reference, use
// g_source_unref() to drop it.
//
// This function is safe to call from any thread, regardless of which thread the
// Context is running in.
func (source *Source) Destroy() {
	var _arg0 *C.GSource // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	C.g_source_destroy(_arg0)
}

// CanRecurse checks whether a source is allowed to be called recursively. see
// g_source_set_can_recurse().
func (source *Source) CanRecurse() bool {
	var _arg0 *C.GSource // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	_cret = C.g_source_get_can_recurse(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Context gets the Context with which the source is associated.
//
// You can call this on a source that has been destroyed, provided that the
// Context it was attached to still exists (in which case it will return that
// Context). In particular, you can always call this function on the source
// returned from g_main_current_source(). But calling this function on a source
// whose Context has been destroyed is an error.
func (source *Source) Context() *MainContext {
	var _arg0 *C.GSource      // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	_cret = C.g_source_get_context(_arg0)

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(unsafe.Pointer(_cret))
	C.g_main_context_ref(_cret)
	runtime.SetFinalizer(_mainContext, func(v *MainContext) {
		C.g_main_context_unref((*C.GMainContext)(unsafe.Pointer(v)))
	})

	return _mainContext
}

// CurrentTime: this function ignores @source and is otherwise the same as
// g_get_current_time().
//
// Deprecated: use g_source_get_time() instead.
func (source *Source) CurrentTime(timeval *TimeVal) {
	var _arg0 *C.GSource  // out
	var _arg1 *C.GTimeVal // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (*C.GTimeVal)(unsafe.Pointer(timeval))

	C.g_source_get_current_time(_arg0, _arg1)
}

// ID returns the numeric ID for a particular source. The ID of a source is a
// positive integer which is unique within a particular main loop context. The
// reverse mapping from ID to source is done by
// g_main_context_find_source_by_id().
//
// You can only call this function while the source is associated to a Context
// instance; calling this function before g_source_attach() or after
// g_source_destroy() yields undefined behavior. The ID returned is unique
// within the Context instance passed to g_source_attach().
func (source *Source) ID() uint {
	var _arg0 *C.GSource // out
	var _cret C.guint    // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	_cret = C.g_source_get_id(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Name gets a name for the source, used in debugging and profiling. The name
// may be LL if it has never been set with g_source_set_name().
func (source *Source) Name() string {
	var _arg0 *C.GSource // out
	var _cret *C.char    // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	_cret = C.g_source_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Priority gets the priority of a source.
func (source *Source) Priority() int {
	var _arg0 *C.GSource // out
	var _cret C.gint     // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	_cret = C.g_source_get_priority(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ReadyTime gets the "ready time" of @source, as set by
// g_source_set_ready_time().
//
// Any time before the current monotonic time (including 0) is an indication
// that the source will fire immediately.
func (source *Source) ReadyTime() int64 {
	var _arg0 *C.GSource // out
	var _cret C.gint64   // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	_cret = C.g_source_get_ready_time(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Time gets the time to be used when checking this source. The advantage of
// calling this function over calling g_get_monotonic_time() directly is that
// when checking multiple sources, GLib can cache a single value instead of
// having to repeatedly get the system monotonic time.
//
// The time here is the system monotonic time, if available, or some other
// reasonable alternative otherwise. See g_get_monotonic_time().
func (source *Source) Time() int64 {
	var _arg0 *C.GSource // out
	var _cret C.gint64   // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	_cret = C.g_source_get_time(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// IsDestroyed returns whether @source has been destroyed.
//
// This is important when you operate upon your objects from within idle
// handlers, but may have freed the object before the dispatch of your idle
// handler.
//
//    static gboolean
//    idle_callback (gpointer data)
//    {
//      SomeWidget *self = data;
//
//      g_mutex_lock (&self->idle_id_mutex);
//      if (!g_source_is_destroyed (g_main_current_source ()))
//        {
//          // do stuff with self
//        }
//      g_mutex_unlock (&self->idle_id_mutex);
//
//      return FALSE;
//    }
//
// Calls to this function from a thread other than the one acquired by the
// Context the #GSource is attached to are typically redundant, as the source
// could be destroyed immediately after this function returns. However, once a
// source is destroyed it cannot be un-destroyed, so this function can be used
// for opportunistic checks from any thread.
func (source *Source) IsDestroyed() bool {
	var _arg0 *C.GSource // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	_cret = C.g_source_is_destroyed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryUnixFd queries the events reported for the fd corresponding to @tag on
// @source during the last poll.
//
// The return value of this function is only defined when the function is called
// from the check or dispatch functions for @source.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (source *Source) QueryUnixFd(tag cgo.Handle) IOCondition {
	var _arg0 *C.GSource     // out
	var _arg1 C.gpointer     // out
	var _cret C.GIOCondition // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (C.gpointer)(unsafe.Pointer(tag))

	_cret = C.g_source_query_unix_fd(_arg0, _arg1)

	var _ioCondition IOCondition // out

	_ioCondition = IOCondition(_cret)

	return _ioCondition
}

// Ref increases the reference count on a source by one.
func (source *Source) ref() *Source {
	var _arg0 *C.GSource // out
	var _cret *C.GSource // in

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	_cret = C.g_source_ref(_arg0)

	var _ret *Source // out

	_ret = (*Source)(unsafe.Pointer(_cret))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(_ret, func(v *Source) {
		C.g_source_unref((*C.GSource)(unsafe.Pointer(v)))
	})

	return _ret
}

// RemoveChildSource detaches @child_source from @source and destroys it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (source *Source) RemoveChildSource(childSource *Source) {
	var _arg0 *C.GSource // out
	var _arg1 *C.GSource // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (*C.GSource)(unsafe.Pointer(childSource))

	C.g_source_remove_child_source(_arg0, _arg1)
}

// RemovePoll removes a file descriptor from the set of file descriptors polled
// for this source.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (source *Source) RemovePoll(fd *PollFD) {
	var _arg0 *C.GSource // out
	var _arg1 *C.GPollFD // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (*C.GPollFD)(unsafe.Pointer(fd))

	C.g_source_remove_poll(_arg0, _arg1)
}

// RemoveUnixFd reverses the effect of a previous call to
// g_source_add_unix_fd().
//
// You only need to call this if you want to remove an fd from being watched
// while keeping the same source around. In the normal case you will just want
// to destroy the source.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (source *Source) RemoveUnixFd(tag cgo.Handle) {
	var _arg0 *C.GSource // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (C.gpointer)(unsafe.Pointer(tag))

	C.g_source_remove_unix_fd(_arg0, _arg1)
}

// SetCallbackIndirect sets the callback function storing the data as a
// refcounted callback "object". This is used internally. Note that calling
// g_source_set_callback_indirect() assumes an initial reference count on
// @callback_data, and thus @callback_funcs->unref will eventually be called
// once more than @callback_funcs->ref.
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
func (source *Source) SetCallbackIndirect(callbackData cgo.Handle, callbackFuncs *SourceCallbackFuncs) {
	var _arg0 *C.GSource              // out
	var _arg1 C.gpointer              // out
	var _arg2 *C.GSourceCallbackFuncs // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (C.gpointer)(unsafe.Pointer(callbackData))
	_arg2 = (*C.GSourceCallbackFuncs)(unsafe.Pointer(callbackFuncs))

	C.g_source_set_callback_indirect(_arg0, _arg1, _arg2)
}

// SetCanRecurse sets whether a source can be called recursively. If
// @can_recurse is true, then while the source is being dispatched then this
// source will be processed normally. Otherwise, all processing of this source
// is blocked until the dispatch function returns.
func (source *Source) SetCanRecurse(canRecurse bool) {
	var _arg0 *C.GSource // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	if canRecurse {
		_arg1 = C.TRUE
	}

	C.g_source_set_can_recurse(_arg0, _arg1)
}

// SetFuncs sets the source functions (can be used to override default
// implementations) of an unattached source.
func (source *Source) SetFuncs(funcs *SourceFuncs) {
	var _arg0 *C.GSource      // out
	var _arg1 *C.GSourceFuncs // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (*C.GSourceFuncs)(unsafe.Pointer(funcs))

	C.g_source_set_funcs(_arg0, _arg1)
}

// SetName sets a name for the source, used in debugging and profiling. The name
// defaults to LL.
//
// The source name should describe in a human-readable way what the source does.
// For example, "X11 event queue" or "GTK+ repaint idle handler" or whatever it
// is.
//
// It is permitted to call this function multiple times, but is not recommended
// due to the potential performance impact. For example, one could change the
// name in the "check" function of a Funcs to include details like the event
// type in the source name.
//
// Use caution if changing the name while another thread may be accessing it
// with g_source_get_name(); that function does not copy the value, and changing
// the value will free it while the other thread may be attempting to use it.
func (source *Source) SetName(name string) {
	var _arg0 *C.GSource // out
	var _arg1 *C.char    // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_source_set_name(_arg0, _arg1)
}

// SetPriority sets the priority of a source. While the main loop is being run,
// a source will be dispatched if it is ready to be dispatched and no sources at
// a higher (numerically smaller) priority are ready to be dispatched.
//
// A child source always has the same priority as its parent. It is not
// permitted to change the priority of a source once it has been added as a
// child of another source.
func (source *Source) SetPriority(priority int) {
	var _arg0 *C.GSource // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = C.gint(priority)

	C.g_source_set_priority(_arg0, _arg1)
}

// SetReadyTime sets a #GSource to be dispatched when the given monotonic time
// is reached (or passed). If the monotonic time is in the past (as it always
// will be if @ready_time is 0) then the source will be dispatched immediately.
//
// If @ready_time is -1 then the source is never woken up on the basis of the
// passage of time.
//
// Dispatching the source does not reset the ready time. You should do so
// yourself, from the source dispatch function.
//
// Note that if you have a pair of sources where the ready time of one suggests
// that it will be delivered first but the priority for the other suggests that
// it would be delivered first, and the ready time for both sources is reached
// during the same main context iteration, then the order of dispatch is
// undefined.
//
// It is a no-op to call this function on a #GSource which has already been
// destroyed with g_source_destroy().
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (source *Source) SetReadyTime(readyTime int64) {
	var _arg0 *C.GSource // out
	var _arg1 C.gint64   // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))
	_arg1 = C.gint64(readyTime)

	C.g_source_set_ready_time(_arg0, _arg1)
}

// Unref decreases the reference count of a source by one. If the resulting
// reference count is zero the source and associated memory will be destroyed.
func (source *Source) unref() {
	var _arg0 *C.GSource // out

	_arg0 = (*C.GSource)(unsafe.Pointer(source))

	C.g_source_unref(_arg0)
}

// SourceCallbackFuncs: `GSourceCallbackFuncs` struct contains functions for
// managing callback objects.
type SourceCallbackFuncs struct {
	native C.GSourceCallbackFuncs
}

// Native returns the underlying C source pointer.
func (s *SourceCallbackFuncs) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SourceFuncs: `GSourceFuncs` struct contains a table of functions used to
// handle event sources in a generic manner.
//
// For idle sources, the prepare and check functions always return true to
// indicate that the source is always ready to be processed. The prepare
// function also returns a timeout value of 0 to ensure that the poll() call
// doesn't block (since that would be time wasted which could have been spent
// running the idle function).
//
// For timeout sources, the prepare and check functions both return true if the
// timeout interval has expired. The prepare function also returns a timeout
// value to ensure that the poll() call doesn't block too long and miss the next
// timeout.
//
// For file descriptor sources, the prepare function typically returns false,
// since it must wait until poll() has been called before it knows whether any
// events need to be processed. It sets the returned timeout to -1 to indicate
// that it doesn't mind how long the poll() call blocks. In the check function,
// it tests the results of the poll() call to see if the required condition has
// been met, and returns true if so.
type SourceFuncs struct {
	native C.GSourceFuncs
}

// Native returns the underlying C source pointer.
func (s *SourceFuncs) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}
