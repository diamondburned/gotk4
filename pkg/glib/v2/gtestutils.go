// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

// TestFileType: the type of file to return the filename for, when used with
// g_test_build_filename().
//
// These two options correspond rather directly to the 'dist' and 'built'
// terminology that automake uses and are explicitly used to distinguish between
// the 'srcdir' and 'builddir' being separate. All files in your project should
// either be dist (in the `EXTRA_DIST` or `dist_schema_DATA` sense, in which
// case they will always be in the srcdir) or built (in the `BUILT_SOURCES`
// sense, in which case they will always be in the builddir).
//
// Note: as a general rule of automake, files that are generated only as part of
// the build-from-git process (but then are distributed with the tarball) always
// go in srcdir (even if doing a srcdir != builddir build from git) and are
// considered as distributed files.
type TestFileType int

const (
	// TestFileTypeDist: a file that was included in the distribution tarball
	TestFileTypeDist TestFileType = 0
	// TestFileTypeBuilt: a file that was built on the compiling machine
	TestFileTypeBuilt TestFileType = 1
)

type TestLogType int

const (
	TestLogTypeNone        TestLogType = 0
	TestLogTypeError       TestLogType = 1
	TestLogTypeStartBinary TestLogType = 2
	TestLogTypeListCase    TestLogType = 3
	TestLogTypeSkipCase    TestLogType = 4
	TestLogTypeStartCase   TestLogType = 5
	TestLogTypeStopCase    TestLogType = 6
	TestLogTypeMinResult   TestLogType = 7
	TestLogTypeMaxResult   TestLogType = 8
	TestLogTypeMessage     TestLogType = 9
	TestLogTypeStartSuite  TestLogType = 10
	TestLogTypeStopSuite   TestLogType = 11
)

type TestResult int

const (
	TestResultSuccess    TestResult = 0
	TestResultSkipped    TestResult = 1
	TestResultFailure    TestResult = 2
	TestResultIncomplete TestResult = 3
)

// TestSubprocessFlags flags to pass to g_test_trap_subprocess() to control
// input and output.
//
// Note that in contrast with g_test_trap_fork(), the default is to not show
// stdout and stderr.
type TestSubprocessFlags int

const (
	// TestSubprocessFlagsStdin: if this flag is given, the child process will
	// inherit the parent's stdin. Otherwise, the child's stdin is redirected to
	// `/dev/null`.
	TestSubprocessFlagsStdin TestSubprocessFlags = 1
	// TestSubprocessFlagsStdout: if this flag is given, the child process will
	// inherit the parent's stdout. Otherwise, the child's stdout will not be
	// visible, but it will be captured to allow later tests with
	// g_test_trap_assert_stdout().
	TestSubprocessFlagsStdout TestSubprocessFlags = 2
	// TestSubprocessFlagsStderr: if this flag is given, the child process will
	// inherit the parent's stderr. Otherwise, the child's stderr will not be
	// visible, but it will be captured to allow later tests with
	// g_test_trap_assert_stderr().
	TestSubprocessFlagsStderr TestSubprocessFlags = 4
)

// TestTrapFlags: test traps are guards around forked tests. These flags
// determine what traps to set.
type TestTrapFlags int

const (
	// TestTrapFlagsSilenceStdout: redirect stdout of the test child to
	// `/dev/null` so it cannot be observed on the console during test runs. The
	// actual output is still captured though to allow later tests with
	// g_test_trap_assert_stdout().
	TestTrapFlagsSilenceStdout TestTrapFlags = 128
	// TestTrapFlagsSilenceStderr: redirect stderr of the test child to
	// `/dev/null` so it cannot be observed on the console during test runs. The
	// actual output is still captured though to allow later tests with
	// g_test_trap_assert_stderr().
	TestTrapFlagsSilenceStderr TestTrapFlags = 256
	// TestTrapFlagsInheritStdin: if this flag is given, stdin of the child
	// process is shared with stdin of its parent process. It is redirected to
	// `/dev/null` otherwise.
	TestTrapFlagsInheritStdin TestTrapFlags = 512
)

// TestDataFunc: the type used for test case functions that take an extra
// pointer argument.
type TestDataFunc func()

//export gotk4_TestDataFunc
func gotk4_TestDataFunc(arg0 C.gpointer) {
	v := box.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TestDataFunc)
	fn()
}

// TestFixtureFunc: the type used for functions that operate on test fixtures.
// This is used for the fixture setup and teardown functions as well as for the
// testcases themselves.
//
// @user_data is a pointer to the data that was given when registering the test
// case.
//
// @fixture will be a pointer to the area of memory allocated by the test
// framework, of the size requested. If the requested size was zero then
// @fixture will be equal to @user_data.
type TestFixtureFunc func()

//export gotk4_TestFixtureFunc
func gotk4_TestFixtureFunc(arg0 C.gpointer, arg1 C.gpointer) {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TestFixtureFunc)
	fn()
}

// TestLogFatalFunc specifies the prototype of fatal log handler functions.
type TestLogFatalFunc func() (ok bool)

//export gotk4_TestLogFatalFunc
func gotk4_TestLogFatalFunc(arg0 *C.gchar, arg1 C.GLogLevelFlags, arg2 *C.gchar, arg3 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TestLogFatalFunc)
	fn(ok)

	if ok {
		cret = C.gboolean(1)
	}
}

func AssertionMessage(domain string, file string, line int, fn string, message string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char

	arg1 = (*C.char)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.char)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.char)(C.CString(message))
	defer C.free(unsafe.Pointer(arg5))

	C.g_assertion_message(arg1, arg2, arg3, arg4, arg5)
}

func AssertionMessageCmpstr(domain string, file string, line int, fn string, expr string, arg1 string, cmp string, arg2 string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char
	var arg6 *C.char
	var arg7 *C.char
	var arg8 *C.char

	arg1 = (*C.char)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.char)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.char)(C.CString(expr))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.char)(C.CString(arg1))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.char)(C.CString(cmp))
	defer C.free(unsafe.Pointer(arg7))
	arg8 = (*C.char)(C.CString(arg2))
	defer C.free(unsafe.Pointer(arg8))

	C.g_assertion_message_cmpstr(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

func AssertionMessageCmpstrv(domain string, file string, line int, fn string, expr string, arg1 string, arg2 string, firstWrongIdx uint) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char
	var arg6 **C.char
	var arg7 **C.char
	var arg8 C.gsize

	arg1 = (*C.char)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.char)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.char)(C.CString(expr))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (**C.char)(C.CString(arg1))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (**C.char)(C.CString(arg2))
	defer C.free(unsafe.Pointer(arg7))
	arg8 = C.gsize(firstWrongIdx)

	C.g_assertion_message_cmpstrv(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// AssertionMessageExpr: internal function used to print messages from the
// public g_assert() and g_assert_not_reached() macros.
func AssertionMessageExpr(domain string, file string, line int, fn string, expr string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char

	arg1 = (*C.char)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.char)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.char)(C.CString(expr))
	defer C.free(unsafe.Pointer(arg5))

	C.g_assertion_message_expr(arg1, arg2, arg3, arg4, arg5)
}

// Strcmp0 compares @str1 and @str2 like strcmp(). Handles nil gracefully by
// sorting it before non-nil strings. Comparing two nil pointers returns 0.
func Strcmp0(str1 string, str2 string) int {
	var arg1 *C.char
	var arg2 *C.char

	arg1 = (*C.char)(C.CString(str1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(str2))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.int
	var goret int

	cret = C.g_strcmp0(arg1, arg2)

	goret = int(cret)

	return goret
}

// TestAddDataFuncFull: create a new test case, as with g_test_add_data_func(),
// but freeing @test_data after the test run is complete.
func TestAddDataFuncFull() {
	C.g_test_add_data_func_full(arg1, arg2, arg3, arg4)
}

func TestAssertExpectedMessagesInternal(domain string, file string, line int, fn string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char

	arg1 = (*C.char)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.char)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))

	C.g_test_assert_expected_messages_internal(arg1, arg2, arg3, arg4)
}

// TestBug: this function adds a message to test reports that associates a bug
// URI with a test case. Bug URIs are constructed from a base URI set with
// g_test_bug_base() and @bug_uri_snippet. If g_test_bug_base() has not been
// called, it is assumed to be the empty string, so a full URI can be provided
// to g_test_bug() instead.
func TestBug(bugURISnippet string) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(bugURISnippet))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_bug(arg1)
}

// TestBugBase: specify the base URI for bug reports.
//
// The base URI is used to construct bug report messages for g_test_message()
// when g_test_bug() is called. Calling this function outside of a test case
// sets the default base URI for all test cases. Calling it from within a test
// case changes the base URI for the scope of the test case only. Bug URIs are
// constructed by appending a bug specific URI portion to @uri_pattern, or by
// replacing the special string '\s' within @uri_pattern if that is present.
//
// If g_test_bug_base() is not called, bug URIs are formed solely from the value
// provided by g_test_bug().
func TestBugBase(uriPattern string) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(uriPattern))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_bug_base(arg1)
}

// TestCreateSuite: create a new test suite with the name @suite_name.
func TestCreateSuite(suiteName string) *TestSuite {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(suiteName))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GTestSuite
	var goret *TestSuite

	cret = C.g_test_create_suite(arg1)

	goret = WrapTestSuite(unsafe.Pointer(cret))

	return goret
}

// TestExpectMessage indicates that a message with the given @log_domain and
// @log_level, with text matching @pattern, is expected to be logged. When this
// message is logged, it will not be printed, and the test case will not abort.
//
// This API may only be used with the old logging API (g_log() without
// G_LOG_USE_STRUCTURED defined). It will not work with the structured logging
// API. See [Testing for Messages][testing-for-messages].
//
// Use g_test_assert_expected_messages() to assert that all previously-expected
// messages have been seen and suppressed.
//
// You can call this multiple times in a row, if multiple messages are expected
// as a result of a single call. (The messages must appear in the same order as
// the calls to g_test_expect_message().)
//
// For example:
//
//    // g_main_context_push_thread_default() should fail if the
//    // context is already owned by another thread.
//    g_test_expect_message (G_LOG_DOMAIN,
//                           G_LOG_LEVEL_CRITICAL,
//                           "assertion*acquired_context*failed");
//    g_main_context_push_thread_default (bad_context);
//    g_test_assert_expected_messages ();
//
// Note that you cannot use this to test g_error() messages, since g_error()
// intentionally never returns even if the program doesn't abort; use
// g_test_trap_subprocess() in this case.
//
// If messages at G_LOG_LEVEL_DEBUG are emitted, but not explicitly expected via
// g_test_expect_message() then they will be ignored.
func TestExpectMessage(logDomain string, logLevel LogLevelFlags, pattern string) {
	var arg1 *C.gchar
	var arg2 C.GLogLevelFlags
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GLogLevelFlags)(logLevel)
	arg3 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg3))

	C.g_test_expect_message(arg1, arg2, arg3)
}

// TestFail indicates that a test failed. This function can be called multiple
// times from the same test. You can use this function if your test failed in a
// recoverable way.
//
// Do not use this function if the failure of a test could cause other tests to
// malfunction.
//
// Calling this function will not stop the test from running, you need to return
// from the test function yourself. So you can produce additional diagnostic
// messages or even continue running the test.
//
// If not called from inside a test, this function does nothing.
func TestFail() {
	C.g_test_fail()
}

// TestFailed returns whether a test has already failed. This will be the case
// when g_test_fail(), g_test_incomplete() or g_test_skip() have been called,
// but also if an assertion has failed.
//
// This can be useful to return early from a test if continuing after a failed
// assertion might be harmful.
//
// The return value of this function is only meaningful if it is called from
// inside a test function.
func TestFailed() bool {
	var cret C.gboolean
	var goret bool

	cret = C.g_test_failed()

	if cret {
		goret = true
	}

	return goret
}

// TestGetDir gets the pathname of the directory containing test files of the
// type specified by @file_type.
//
// This is approximately the same as calling g_test_build_filename("."), but you
// don't need to free the return value.
func TestGetDir(fileType TestFileType) string {
	var arg1 C.GTestFileType

	arg1 = (C.GTestFileType)(fileType)

	var cret *C.gchar
	var goret string

	cret = C.g_test_get_dir(arg1)

	goret = C.GoString(cret)

	return goret
}

// TestGetPath gets the test path for the test currently being run.
//
// In essence, it will be the same string passed as the first argument to e.g.
// g_test_add() when the test was added.
//
// This function returns a valid string only within a test function.
func TestGetPath() string {
	var cret *C.char
	var goret string

	cret = C.g_test_get_path()

	goret = C.GoString(cret)

	return goret
}

// TestGetRoot: get the toplevel test suite for the test path API.
func TestGetRoot() *TestSuite {
	var cret *C.GTestSuite
	var goret *TestSuite

	cret = C.g_test_get_root()

	goret = WrapTestSuite(unsafe.Pointer(cret))

	return goret
}

// TestIncomplete indicates that a test failed because of some incomplete
// functionality. This function can be called multiple times from the same test.
//
// Calling this function will not stop the test from running, you need to return
// from the test function yourself. So you can produce additional diagnostic
// messages or even continue running the test.
//
// If not called from inside a test, this function does nothing.
func TestIncomplete(msg string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(msg))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_incomplete(arg1)
}

// TestLogSetFatalHandler installs a non-error fatal log handler which can be
// used to decide whether log messages which are counted as fatal abort the
// program.
//
// The use case here is that you are running a test case that depends on
// particular libraries or circumstances and cannot prevent certain known
// critical or warning messages. So you install a handler that compares the
// domain and message to precisely not abort in such a case.
//
// Note that the handler is reset at the beginning of any test case, so you have
// to set it inside each test function which needs the special behavior.
//
// This handler has no effect on g_error messages.
//
// This handler also has no effect on structured log messages (using
// g_log_structured() or g_log_structured_array()). To change the fatal
// behaviour for specific log messages, programs must install a custom log
// writer function using g_log_set_writer_func().See [Using Structured
// Logging][using-structured-logging].
func TestLogSetFatalHandler() {
	C.g_test_log_set_fatal_handler(arg1, arg2)
}

func TestLogTypeName(logType TestLogType) string {
	var arg1 C.GTestLogType

	arg1 = (C.GTestLogType)(logType)

	var cret *C.char
	var goret string

	cret = C.g_test_log_type_name(arg1)

	goret = C.GoString(cret)

	return goret
}

// TestQueueFree: enqueue a pointer to be released with g_free() during the next
// teardown phase. This is equivalent to calling g_test_queue_destroy() with a
// destroy callback of g_free().
func TestQueueFree(gfreePointer interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(gfreePointer)

	C.g_test_queue_free(arg1)
}

// TestRandDouble: get a reproducible random floating point number, see
// g_test_rand_int() for details on test case random numbers.
func TestRandDouble() float64 {
	var cret C.double
	var goret float64

	cret = C.g_test_rand_double()

	goret = float64(cret)

	return goret
}

// TestRandDoubleRange: get a reproducible random floating pointer number out of
// a specified range, see g_test_rand_int() for details on test case random
// numbers.
func TestRandDoubleRange(rangeStart float64, rangeEnd float64) float64 {
	var arg1 C.double
	var arg2 C.double

	arg1 = C.double(rangeStart)
	arg2 = C.double(rangeEnd)

	var cret C.double
	var goret float64

	cret = C.g_test_rand_double_range(arg1, arg2)

	goret = float64(cret)

	return goret
}

// TestRandInt: get a reproducible random integer number.
//
// The random numbers generated by the g_test_rand_*() family of functions
// change with every new test program start, unless the --seed option is given
// when starting test programs.
//
// For individual test cases however, the random number generator is reseeded,
// to avoid dependencies between tests and to make --seed effective for all test
// cases.
func TestRandInt() int32 {
	var cret C.gint32
	var goret int32

	cret = C.g_test_rand_int()

	goret = int32(cret)

	return goret
}

// TestRandIntRange: get a reproducible random integer number out of a specified
// range, see g_test_rand_int() for details on test case random numbers.
func TestRandIntRange(begin int32, end int32) int32 {
	var arg1 C.gint32
	var arg2 C.gint32

	arg1 = C.gint32(begin)
	arg2 = C.gint32(end)

	var cret C.gint32
	var goret int32

	cret = C.g_test_rand_int_range(arg1, arg2)

	goret = int32(cret)

	return goret
}

// TestRun runs all tests under the toplevel suite which can be retrieved with
// g_test_get_root(). Similar to g_test_run_suite(), the test cases to be run
// are filtered according to test path arguments (`-p testpath` and `-s
// testpath`) as parsed by g_test_init(). g_test_run_suite() or g_test_run() may
// only be called once in a program.
//
// In general, the tests and sub-suites within each suite are run in the order
// in which they are defined. However, note that prior to GLib 2.36, there was a
// bug in the `g_test_add_*` functions which caused them to create multiple
// suites with the same name, meaning that if you created tests "/foo/simple",
// "/bar/simple", and "/foo/using-bar" in that order, they would get run in that
// order (since g_test_run() would run the first "/foo" suite, then the "/bar"
// suite, then the second "/foo" suite). As of 2.36, this bug is fixed, and
// adding the tests in that order would result in a running order of
// "/foo/simple", "/foo/using-bar", "/bar/simple". If this new ordering is
// sub-optimal (because it puts more-complicated tests before simpler ones,
// making it harder to figure out exactly what has failed), you can fix it by
// changing the test paths to group tests by suite in a way that will result in
// the desired running order. Eg, "/simple/foo", "/simple/bar",
// "/complex/foo-using-bar".
//
// However, you should never make the actual result of a test depend on the
// order that tests are run in. If you need to ensure that some particular code
// runs before or after a given test case, use g_test_add(), which lets you
// specify setup and teardown functions.
//
// If all tests are skipped or marked as incomplete (expected failures), this
// function will return 0 if producing TAP output, or 77 (treated as "skip test"
// by Automake) otherwise.
func TestRun() int {
	var cret C.int
	var goret int

	cret = C.g_test_run()

	goret = int(cret)

	return goret
}

// TestRunSuite: execute the tests within @suite and all nested Suites. The test
// suites to be executed are filtered according to test path arguments (`-p
// testpath` and `-s testpath`) as parsed by g_test_init(). See the g_test_run()
// documentation for more information on the order that tests are run in.
//
// g_test_run_suite() or g_test_run() may only be called once in a program.
func TestRunSuite(suite *TestSuite) int {
	var arg1 *C.GTestSuite

	arg1 = (*C.GTestSuite)(unsafe.Pointer(suite.Native()))

	var cret C.int
	var goret int

	cret = C.g_test_run_suite(arg1)

	goret = int(cret)

	return goret
}

// TestSetNonfatalAssertions changes the behaviour of the various `g_assert_*()`
// macros, g_test_assert_expected_messages() and the various
// `g_test_trap_assert_*()` macros to not abort to program, but instead call
// g_test_fail() and continue. (This also changes the behavior of g_test_fail()
// so that it will not cause the test program to abort after completing the
// failed test.)
//
// Note that the g_assert_not_reached() and g_assert() macros are not affected
// by this.
//
// This function can only be called after g_test_init().
func TestSetNonfatalAssertions() {
	C.g_test_set_nonfatal_assertions()
}

// TestSkip indicates that a test was skipped.
//
// Calling this function will not stop the test from running, you need to return
// from the test function yourself. So you can produce additional diagnostic
// messages or even continue running the test.
//
// If not called from inside a test, this function does nothing.
func TestSkip(msg string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(msg))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_skip(arg1)
}

// TestSubprocess returns true (after g_test_init() has been called) if the test
// program is running under g_test_trap_subprocess().
func TestSubprocess() bool {
	var cret C.gboolean
	var goret bool

	cret = C.g_test_subprocess()

	if cret {
		goret = true
	}

	return goret
}

// TestSummary: set the summary for a test, which describes what the test
// checks, and how it goes about checking it. This may be included in test
// report output, and is useful documentation for anyone reading the source code
// or modifying a test in future. It must be a single line.
//
// This should be called at the top of a test function.
//
// For example:
//
//    static void
//    test_array_sort (void)
//    {
//      g_test_summary ("Test my_array_sort() sorts the array correctly and stably, "
//                      "including testing zero length and one-element arrays.");
//
//      â€¦
//    }
func TestSummary(summary string) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(summary))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_summary(arg1)
}

// TestTimerElapsed: get the time since the last start of the timer with
// g_test_timer_start().
func TestTimerElapsed() float64 {
	var cret C.double
	var goret float64

	cret = C.g_test_timer_elapsed()

	goret = float64(cret)

	return goret
}

// TestTimerLast: report the last result of g_test_timer_elapsed().
func TestTimerLast() float64 {
	var cret C.double
	var goret float64

	cret = C.g_test_timer_last()

	goret = float64(cret)

	return goret
}

// TestTimerStart: start a timing test. Call g_test_timer_elapsed() when the
// task is supposed to be done. Call this function again to restart the timer.
func TestTimerStart() {
	C.g_test_timer_start()
}

func TestTrapAssertions(domain string, file string, line int, fn string, assertionFlags uint64, pattern string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 C.guint64
	var arg6 *C.char

	arg1 = (*C.char)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.char)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.guint64(assertionFlags)
	arg6 = (*C.char)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg6))

	C.g_test_trap_assertions(arg1, arg2, arg3, arg4, arg5, arg6)
}

// TestTrapFork: fork the current test program to execute a test case that might
// not return or that might abort.
//
// If @usec_timeout is non-0, the forked test case is aborted and considered
// failing if its run time exceeds it.
//
// The forking behavior can be configured with the TrapFlags flags.
//
// In the following example, the test code forks, the forked child process
// produces some sample output and exits successfully. The forking parent
// process then asserts successful child program termination and validates child
// program outputs.
//
//    static void
//    test_fork_patterns (void)
//    {
//      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR))
//        {
//          g_print ("some stdout text: somagic17\n");
//          g_printerr ("some stderr text: semagic43\n");
//          exit (0); // successful test run
//        }
//      g_test_trap_assert_passed ();
//      g_test_trap_assert_stdout ("*somagic17*");
//      g_test_trap_assert_stderr ("*semagic43*");
//    }
func TestTrapFork(usecTimeout uint64, testTrapFlags TestTrapFlags) bool {
	var arg1 C.guint64
	var arg2 C.GTestTrapFlags

	arg1 = C.guint64(usecTimeout)
	arg2 = (C.GTestTrapFlags)(testTrapFlags)

	var cret C.gboolean
	var goret bool

	cret = C.g_test_trap_fork(arg1, arg2)

	if cret {
		goret = true
	}

	return goret
}

// TestTrapHasPassed: check the result of the last g_test_trap_subprocess()
// call.
func TestTrapHasPassed() bool {
	var cret C.gboolean
	var goret bool

	cret = C.g_test_trap_has_passed()

	if cret {
		goret = true
	}

	return goret
}

// TestTrapReachedTimeout: check the result of the last g_test_trap_subprocess()
// call.
func TestTrapReachedTimeout() bool {
	var cret C.gboolean
	var goret bool

	cret = C.g_test_trap_reached_timeout()

	if cret {
		goret = true
	}

	return goret
}

// TestTrapSubprocess respawns the test program to run only @test_path in a
// subprocess. This can be used for a test case that might not return, or that
// might abort.
//
// If @test_path is nil then the same test is re-run in a subprocess. You can
// use g_test_subprocess() to determine whether the test is in a subprocess or
// not.
//
// @test_path can also be the name of the parent test, followed by
// "`/subprocess/`" and then a name for the specific subtest (or just ending
// with "`/subprocess`" if the test only has one child test); tests with names
// of this form will automatically be skipped in the parent process.
//
// If @usec_timeout is non-0, the test subprocess is aborted and considered
// failing if its run time exceeds it.
//
// The subprocess behavior can be configured with the SubprocessFlags flags.
//
// You can use methods such as g_test_trap_assert_passed(),
// g_test_trap_assert_failed(), and g_test_trap_assert_stderr() to check the
// results of the subprocess. (But note that g_test_trap_assert_stdout() and
// g_test_trap_assert_stderr() cannot be used if @test_flags specifies that the
// child should inherit the parent stdout/stderr.)
//
// If your `main ()` needs to behave differently in the subprocess, you can call
// g_test_subprocess() (after calling g_test_init()) to see whether you are in a
// subprocess.
//
// The following example tests that calling `my_object_new(1000000)` will abort
// with an error message.
//
//      static void
//      test_create_large_object (void)
//      {
//        if (g_test_subprocess ())
//          {
//            my_object_new (1000000);
//            return;
//          }
//
//        // Reruns this same test in a subprocess
//        g_test_trap_subprocess (NULL, 0, 0);
//        g_test_trap_assert_failed ();
//        g_test_trap_assert_stderr ("*ERROR*too large*");
//      }
//
//      int
//      main (int argc, char **argv)
//      {
//        g_test_init (&argc, &argv, NULL);
//
//        g_test_add_func ("/myobject/create_large_object",
//                         test_create_large_object);
//        return g_test_run ();
//      }
func TestTrapSubprocess(testPath string, usecTimeout uint64, testFlags TestSubprocessFlags) {
	var arg1 *C.char
	var arg2 C.guint64
	var arg3 C.GTestSubprocessFlags

	arg1 = (*C.char)(C.CString(testPath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint64(usecTimeout)
	arg3 = (C.GTestSubprocessFlags)(testFlags)

	C.g_test_trap_subprocess(arg1, arg2, arg3)
}

// TestCase: an opaque structure representing a test case.
type TestCase struct {
	native C.GTestCase
}

// WrapTestCase wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTestCase(ptr unsafe.Pointer) *TestCase {
	if ptr == nil {
		return nil
	}

	return (*TestCase)(ptr)
}

func marshalTestCase(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTestCase(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TestCase) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TestConfig struct {
	native C.GTestConfig
}

// WrapTestConfig wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTestConfig(ptr unsafe.Pointer) *TestConfig {
	if ptr == nil {
		return nil
	}

	return (*TestConfig)(ptr)
}

func marshalTestConfig(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTestConfig(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TestConfig) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TestInitialized gets the field inside the struct.
func (t *TestConfig) TestInitialized() bool {
	var v bool
	if t.native.test_initialized {
		v = true
	}
	return v
}

// TestQuick gets the field inside the struct.
func (t *TestConfig) TestQuick() bool {
	var v bool
	if t.native.test_quick {
		v = true
	}
	return v
}

// TestPerf gets the field inside the struct.
func (t *TestConfig) TestPerf() bool {
	var v bool
	if t.native.test_perf {
		v = true
	}
	return v
}

// TestVerbose gets the field inside the struct.
func (t *TestConfig) TestVerbose() bool {
	var v bool
	if t.native.test_verbose {
		v = true
	}
	return v
}

// TestQuiet gets the field inside the struct.
func (t *TestConfig) TestQuiet() bool {
	var v bool
	if t.native.test_quiet {
		v = true
	}
	return v
}

// TestUndefined gets the field inside the struct.
func (t *TestConfig) TestUndefined() bool {
	var v bool
	if t.native.test_undefined {
		v = true
	}
	return v
}

type TestLogBuffer struct {
	native C.GTestLogBuffer
}

// WrapTestLogBuffer wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTestLogBuffer(ptr unsafe.Pointer) *TestLogBuffer {
	if ptr == nil {
		return nil
	}

	return (*TestLogBuffer)(ptr)
}

func marshalTestLogBuffer(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTestLogBuffer(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TestLogBuffer) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Free: internal function for gtester to free test log messages, no ABI
// guarantees provided.
func (t *TestLogBuffer) Free() {
	var arg0 *C.GTestLogBuffer

	arg0 = (*C.GTestLogBuffer)(unsafe.Pointer(t.Native()))

	C.g_test_log_buffer_free(arg0)
}

// Push: internal function for gtester to decode test log messages, no ABI
// guarantees provided.
func (t *TestLogBuffer) Push(nBytes uint, bytes byte) {
	var arg0 *C.GTestLogBuffer
	var arg1 C.guint
	var arg2 *C.guint8

	arg0 = (*C.GTestLogBuffer)(unsafe.Pointer(t.Native()))
	arg1 = C.guint(nBytes)
	arg2 = *C.guint8(bytes)

	C.g_test_log_buffer_push(arg0, arg1, arg2)
}

// TestSuite: an opaque structure representing a test suite.
type TestSuite struct {
	native C.GTestSuite
}

// WrapTestSuite wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTestSuite(ptr unsafe.Pointer) *TestSuite {
	if ptr == nil {
		return nil
	}

	return (*TestSuite)(ptr)
}

func marshalTestSuite(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTestSuite(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TestSuite) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Add adds @test_case to @suite.
func (s *TestSuite) Add(testCase *TestCase) {
	var arg0 *C.GTestSuite
	var arg1 *C.GTestCase

	arg0 = (*C.GTestSuite)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GTestCase)(unsafe.Pointer(testCase.Native()))

	C.g_test_suite_add(arg0, arg1)
}

// AddSuite adds @nestedsuite to @suite.
func (s *TestSuite) AddSuite(nestedsuite *TestSuite) {
	var arg0 *C.GTestSuite
	var arg1 *C.GTestSuite

	arg0 = (*C.GTestSuite)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GTestSuite)(unsafe.Pointer(nestedsuite.Native()))

	C.g_test_suite_add_suite(arg0, arg1)
}
