// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"fmt"
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_variant_builder_get_type()), F: marshalVariantBuilder},
		{T: externglib.Type(C.g_variant_dict_get_type()), F: marshalVariantDict},
		{T: externglib.Type(C.G_TYPE_VARIANT), F: marshalVariant},
	})
}

// VariantClass: range of possible top-level types of #GVariant instances.
type VariantClass C.gint

const (
	// VariantClassBoolean is a boolean.
	VariantClassBoolean VariantClass = 98
	// VariantClassByte is a byte.
	VariantClassByte VariantClass = 121
	// VariantClassInt16 is a signed 16 bit integer.
	VariantClassInt16 VariantClass = 110
	// VariantClassUint16 is an unsigned 16 bit integer.
	VariantClassUint16 VariantClass = 113
	// VariantClassInt32 is a signed 32 bit integer.
	VariantClassInt32 VariantClass = 105
	// VariantClassUint32 is an unsigned 32 bit integer.
	VariantClassUint32 VariantClass = 117
	// VariantClassInt64 is a signed 64 bit integer.
	VariantClassInt64 VariantClass = 120
	// VariantClassUint64 is an unsigned 64 bit integer.
	VariantClassUint64 VariantClass = 116
	// VariantClassHandle is a file handle index.
	VariantClassHandle VariantClass = 104
	// VariantClassDouble is a double precision floating point value.
	VariantClassDouble VariantClass = 100
	// VariantClassString is a normal string.
	VariantClassString VariantClass = 115
	// VariantClassObjectPath is a D-Bus object path string.
	VariantClassObjectPath VariantClass = 111
	// VariantClassSignature is a D-Bus signature string.
	VariantClassSignature VariantClass = 103
	// VariantClassVariant is a variant.
	VariantClassVariant VariantClass = 118
	// VariantClassMaybe is a maybe-typed value.
	VariantClassMaybe VariantClass = 109
	// VariantClassArray is an array.
	VariantClassArray VariantClass = 97
	// VariantClassTuple is a tuple.
	VariantClassTuple VariantClass = 40
	// VariantClassDictEntry is a dictionary entry.
	VariantClassDictEntry VariantClass = 123
)

// String returns the name in string for VariantClass.
func (v VariantClass) String() string {
	switch v {
	case VariantClassBoolean:
		return "Boolean"
	case VariantClassByte:
		return "Byte"
	case VariantClassInt16:
		return "Int16"
	case VariantClassUint16:
		return "Uint16"
	case VariantClassInt32:
		return "Int32"
	case VariantClassUint32:
		return "Uint32"
	case VariantClassInt64:
		return "Int64"
	case VariantClassUint64:
		return "Uint64"
	case VariantClassHandle:
		return "Handle"
	case VariantClassDouble:
		return "Double"
	case VariantClassString:
		return "String"
	case VariantClassObjectPath:
		return "ObjectPath"
	case VariantClassSignature:
		return "Signature"
	case VariantClassVariant:
		return "Variant"
	case VariantClassMaybe:
		return "Maybe"
	case VariantClassArray:
		return "Array"
	case VariantClassTuple:
		return "Tuple"
	case VariantClassDictEntry:
		return "DictEntry"
	default:
		return fmt.Sprintf("VariantClass(%d)", v)
	}
}

// VariantParseError: error codes returned by parsing text-format GVariants.
type VariantParseError C.gint

const (
	// VariantParseErrorFailed: generic error (unused).
	VariantParseErrorFailed VariantParseError = iota
	// VariantParseErrorBasicTypeExpected: non-basic Type was given where a
	// basic type was expected.
	VariantParseErrorBasicTypeExpected
	// VariantParseErrorCannotInferType: cannot infer the Type.
	VariantParseErrorCannotInferType
	// VariantParseErrorDefiniteTypeExpected: indefinite Type was given where a
	// definite type was expected.
	VariantParseErrorDefiniteTypeExpected
	// VariantParseErrorInputNotAtEnd: extra data after parsing finished.
	VariantParseErrorInputNotAtEnd
	// VariantParseErrorInvalidCharacter: invalid character in number or unicode
	// escape.
	VariantParseErrorInvalidCharacter
	// VariantParseErrorInvalidFormatString: not a valid #GVariant format
	// string.
	VariantParseErrorInvalidFormatString
	// VariantParseErrorInvalidObjectPath: not a valid object path.
	VariantParseErrorInvalidObjectPath
	// VariantParseErrorInvalidSignature: not a valid type signature.
	VariantParseErrorInvalidSignature
	// VariantParseErrorInvalidTypeString: not a valid #GVariant type string.
	VariantParseErrorInvalidTypeString
	// VariantParseErrorNoCommonType: could not find a common type for array
	// entries.
	VariantParseErrorNoCommonType
	// VariantParseErrorNumberOutOfRange: numerical value is out of range of the
	// given type.
	VariantParseErrorNumberOutOfRange
	// VariantParseErrorNumberTooBig: numerical value is out of range for any
	// type.
	VariantParseErrorNumberTooBig
	// VariantParseErrorTypeError: cannot parse as variant of the specified
	// type.
	VariantParseErrorTypeError
	// VariantParseErrorUnexpectedToken: unexpected token was encountered.
	VariantParseErrorUnexpectedToken
	// VariantParseErrorUnknownKeyword: unknown keyword was encountered.
	VariantParseErrorUnknownKeyword
	// VariantParseErrorUnterminatedStringConstant: unterminated string
	// constant.
	VariantParseErrorUnterminatedStringConstant
	// VariantParseErrorValueExpected: no value given.
	VariantParseErrorValueExpected
	// VariantParseErrorRecursion: variant was too deeply nested; #GVariant is
	// only guaranteed to handle nesting up to 64 levels (Since: 2.64).
	VariantParseErrorRecursion
)

// String returns the name in string for VariantParseError.
func (v VariantParseError) String() string {
	switch v {
	case VariantParseErrorFailed:
		return "Failed"
	case VariantParseErrorBasicTypeExpected:
		return "BasicTypeExpected"
	case VariantParseErrorCannotInferType:
		return "CannotInferType"
	case VariantParseErrorDefiniteTypeExpected:
		return "DefiniteTypeExpected"
	case VariantParseErrorInputNotAtEnd:
		return "InputNotAtEnd"
	case VariantParseErrorInvalidCharacter:
		return "InvalidCharacter"
	case VariantParseErrorInvalidFormatString:
		return "InvalidFormatString"
	case VariantParseErrorInvalidObjectPath:
		return "InvalidObjectPath"
	case VariantParseErrorInvalidSignature:
		return "InvalidSignature"
	case VariantParseErrorInvalidTypeString:
		return "InvalidTypeString"
	case VariantParseErrorNoCommonType:
		return "NoCommonType"
	case VariantParseErrorNumberOutOfRange:
		return "NumberOutOfRange"
	case VariantParseErrorNumberTooBig:
		return "NumberTooBig"
	case VariantParseErrorTypeError:
		return "TypeError"
	case VariantParseErrorUnexpectedToken:
		return "UnexpectedToken"
	case VariantParseErrorUnknownKeyword:
		return "UnknownKeyword"
	case VariantParseErrorUnterminatedStringConstant:
		return "UnterminatedStringConstant"
	case VariantParseErrorValueExpected:
		return "ValueExpected"
	case VariantParseErrorRecursion:
		return "Recursion"
	default:
		return fmt.Sprintf("VariantParseError(%d)", v)
	}
}

// Variant is a variant datatype; it can contain one or more values along with
// information about the type of the values.
//
// A #GVariant may contain simple types, like an integer, or a boolean value; or
// complex types, like an array of two strings, or a dictionary of key value
// pairs. A #GVariant is also immutable: once it's been created neither its type
// nor its content can be modified further.
//
// GVariant is useful whenever data needs to be serialized, for example when
// sending method parameters in D-Bus, or when saving settings using GSettings.
//
// When creating a new #GVariant, you pass the data you want to store in it
// along with a string representing the type of data you wish to pass to it.
//
// For instance, if you want to create a #GVariant holding an integer value you
// can use:
//
//    GVariant *v = g_variant_new ("u", 40);
//
// The string "u" in the first argument tells #GVariant that the data passed to
// the constructor (40) is going to be an unsigned integer.
//
// More advanced examples of #GVariant in use can be found in documentation for
// [GVariant format strings][gvariant-format-strings-pointers].
//
// The range of possible values is determined by the type.
//
// The type system used by #GVariant is Type.
//
// #GVariant instances always have a type and a value (which are given at
// construction time). The type and value of a #GVariant instance can never
// change other than by the #GVariant itself being destroyed. A #GVariant cannot
// contain a pointer.
//
// #GVariant is reference counted using g_variant_ref() and g_variant_unref().
// #GVariant also has floating reference counts -- see g_variant_ref_sink().
//
// #GVariant is completely threadsafe. A #GVariant instance can be concurrently
// accessed in any way from any number of threads without problems.
//
// #GVariant is heavily optimised for dealing with data in serialised form. It
// works particularly well with data located in memory-mapped files. It can
// perform nearly all deserialisation operations in a small constant time,
// usually touching only a single memory page. Serialised #GVariant data can
// also be sent over the network.
//
// #GVariant is largely compatible with D-Bus. Almost all types of #GVariant
// instances can be sent over D-Bus. See Type for exceptions. (However,
// #GVariant's serialisation format is not the same as the serialisation format
// of a D-Bus message body: use BusMessage, in the gio library, for those.)
//
// For space-efficiency, the #GVariant serialisation format does not
// automatically include the variant's length, type or endianness, which must
// either be implied from context (such as knowledge that a particular file
// format always contains a little-endian G_VARIANT_TYPE_VARIANT which occupies
// the whole length of the file) or supplied out-of-band (for instance, a
// length, type and/or endianness indicator could be placed at the beginning of
// a file, network message or network stream).
//
// A #GVariant's size is limited mainly by any lower level operating system
// constraints, such as the number of bits in #gsize. For example, it is
// reasonable to have a 2GB file mapped into memory with File, and call
// g_variant_new_from_data() on it.
//
// For convenience to C programmers, #GVariant features powerful varargs-based
// value construction and destruction. This feature is designed to be embedded
// in other libraries.
//
// There is a Python-inspired text language for describing #GVariant values.
// #GVariant includes a printer for this language and a parser with type
// inferencing.
//
//
// Memory Use
//
// #GVariant tries to be quite efficient with respect to memory use. This
// section gives a rough idea of how much memory is used by the current
// implementation. The information here is subject to change in the future.
//
// The memory allocated by #GVariant can be grouped into 4 broad purposes:
// memory for serialised data, memory for the type information cache, buffer
// management memory and memory for the #GVariant structure itself.
//
//
// Serialised Data Memory
//
// This is the memory that is used for storing GVariant data in serialised form.
// This is what would be sent over the network or what would end up on disk, not
// counting any indicator of the endianness, or of the length or type of the
// top-level variant.
//
// The amount of memory required to store a boolean is 1 byte. 16, 32 and 64 bit
// integers and double precision floating point numbers use their "natural"
// size. Strings (including object path and signature strings) are stored with a
// nul terminator, and as such use the length of the string plus 1 byte.
//
// Maybe types use no space at all to represent the null value and use the same
// amount of space (sometimes plus one byte) as the equivalent non-maybe-typed
// value to represent the non-null case.
//
// Arrays use the amount of space required to store each of their members,
// concatenated. Additionally, if the items stored in an array are not of a
// fixed-size (ie: strings, other arrays, etc) then an additional framing offset
// is stored for each item. The size of this offset is either 1, 2 or 4 bytes
// depending on the overall size of the container. Additionally, extra padding
// bytes are added as required for alignment of child values.
//
// Tuples (including dictionary entries) use the amount of space required to
// store each of their members, concatenated, plus one framing offset (as per
// arrays) for each non-fixed-sized item in the tuple, except for the last one.
// Additionally, extra padding bytes are added as required for alignment of
// child values.
//
// Variants use the same amount of space as the item inside of the variant, plus
// 1 byte, plus the length of the type string for the item inside the variant.
//
// As an example, consider a dictionary mapping strings to variants. In the case
// that the dictionary is empty, 0 bytes are required for the serialisation.
//
// If we add an item "width" that maps to the int32 value of 500 then we will
// use 4 byte to store the int32 (so 6 for the variant containing it) and 6
// bytes for the string. The variant must be aligned to 8 after the 6 bytes of
// the string, so that's 2 extra bytes. 6 (string) + 2 (padding) + 6 (variant)
// is 14 bytes used for the dictionary entry. An additional 1 byte is added to
// the array as a framing offset making a total of 15 bytes.
//
// If we add another entry, "title" that maps to a nullable string that happens
// to have a value of null, then we use 0 bytes for the null value (and 3 bytes
// for the variant to contain it along with its type string) plus 6 bytes for
// the string. Again, we need 2 padding bytes. That makes a total of 6 + 2 + 3 =
// 11 bytes.
//
// We now require extra padding between the two items in the array. After the 14
// bytes of the first item, that's 2 bytes required. We now require 2 framing
// offsets for an extra two bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the
// entire two-item dictionary.
//
//
// Type Information Cache
//
// For each GVariant type that currently exists in the program a type
// information structure is kept in the type information cache. The type
// information structure is required for rapid deserialisation.
//
// Continuing with the above example, if a #GVariant exists with the type
// "a{sv}" then a type information struct will exist for "a{sv}", "{sv}", "s",
// and "v". Multiple uses of the same type will share the same type information.
// Additionally, all single-digit types are stored in read-only static memory
// and do not contribute to the writable memory footprint of a program using
// #GVariant.
//
// Aside from the type information structures stored in read-only memory, there
// are two forms of type information. One is used for container types where
// there is a single element type: arrays and maybe types. The other is used for
// container types where there are multiple element types: tuples and dictionary
// entries.
//
// Array type info structures are 6 * sizeof (void *), plus the memory required
// to store the type string itself. This means that on 32-bit systems, the cache
// entry for "a{sv}" would require 30 bytes of memory (plus malloc overhead).
//
// Tuple type info structures are 6 * sizeof (void *), plus 4 * sizeof (void *)
// for each item in the tuple, plus the memory required to store the type string
// itself. A 2-item tuple, for example, would have a type information structure
// that consumed writable memory in the size of 14 * sizeof (void *) (plus type
// string) This means that on 32-bit systems, the cache entry for "{sv}" would
// require 61 bytes of memory (plus malloc overhead).
//
// This means that in total, for our "a{sv}" example, 91 bytes of type
// information would be allocated.
//
// The type information cache, additionally, uses a Table to store and look up
// the cached items and stores a pointer to this hash table in static storage.
// The hash table is freed when there are zero items in the type cache.
//
// Although these sizes may seem large it is important to remember that a
// program will probably only have a very small number of different types of
// values in it and that only one type information structure is required for
// many different values of the same type.
//
//
// Buffer Management Memory
//
// #GVariant uses an internal buffer management structure to deal with the
// various different possible sources of serialised data that it uses. The
// buffer is responsible for ensuring that the correct call is made when the
// data is no longer in use by #GVariant. This may involve a g_free() or a
// g_slice_free() or even g_mapped_file_unref().
//
// One buffer management structure is used for each chunk of serialised data.
// The size of the buffer management structure is 4 * (void *). On 32-bit
// systems, that's 16 bytes.
//
//
// GVariant structure
//
// The size of a #GVariant structure is 6 * (void *). On 32-bit systems, that's
// 24 bytes.
//
// #GVariant structures only exist if they are explicitly created with API
// calls. For example, if a #GVariant is constructed out of serialised data for
// the example given above (with the dictionary) then although there are 9
// individual values that comprise the entire dictionary (two keys, two values,
// two variants containing the values, two dictionary entries, plus the
// dictionary itself), only 1 #GVariant instance exists -- the one referring to
// the dictionary.
//
// If calls are made to start accessing the other values then #GVariant
// instances will exist for those values only for as long as they are in use
// (ie: until you call g_variant_unref()). The type information is shared. The
// serialised data and the buffer management structure for that serialised data
// is shared by the child.
//
//
// Summary
//
// To put the entire example together, for our dictionary mapping strings to
// variants (with two entries, as given above), we are using 91 bytes of memory
// for type information, 29 bytes of memory for the serialised data, 16 bytes
// for buffer management and 24 bytes for the #GVariant instance, or a total of
// 160 bytes, plus malloc overhead. If we were to use
// g_variant_get_child_value() to access the two dictionary entries, we would
// use an additional 48 bytes. If we were to have other dictionaries of the same
// type, we would use more memory for the serialised data and buffer management
// for those dictionaries, but the type information would be shared.
//
// An instance of this type is always passed by reference.
type Variant struct {
	*variant
}

// variant is the struct that's finalized.
type variant struct {
	native *C.GVariant
}

// NewVariantArray constructs a struct Variant.
func NewVariantArray(childType *VariantType, children []*Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 **C.GVariant    // out
	var _arg3 C.gsize
	var _cret *C.GVariant // in

	if childType != nil {
		_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(childType)))
	}
	if children != nil {
		_arg3 = (C.gsize)(len(children))
		_arg2 = (**C.GVariant)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice((**C.GVariant)(_arg2), len(children))
			for i := range children {
				out[i] = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(children[i])))
			}
		}
	}

	_cret = C.g_variant_new_array(_arg1, _arg2, _arg3)
	runtime.KeepAlive(childType)
	runtime.KeepAlive(children)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantBoolean constructs a struct Variant.
func NewVariantBoolean(value bool) *Variant {
	var _arg1 C.gboolean  // out
	var _cret *C.GVariant // in

	if value {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_new_boolean(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantByte constructs a struct Variant.
func NewVariantByte(value byte) *Variant {
	var _arg1 C.guint8    // out
	var _cret *C.GVariant // in

	_arg1 = C.guint8(value)

	_cret = C.g_variant_new_byte(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantBytestring constructs a struct Variant.
func NewVariantBytestring(str []byte) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_bytestring(_arg1)
	runtime.KeepAlive(str)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantBytestringArray constructs a struct Variant.
func NewVariantBytestringArray(strv []string) *Variant {
	var _arg1 **C.gchar // out
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = (C.gssize)(len(strv))
	_arg1 = (**C.gchar)(C.calloc(C.size_t(len(strv)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.gchar)(_arg1), len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(strv[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_bytestring_array(_arg1, _arg2)
	runtime.KeepAlive(strv)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantDictEntry constructs a struct Variant.
func NewVariantDictEntry(key, value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _arg2 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(key)))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_new_dict_entry(_arg1, _arg2)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantDouble constructs a struct Variant.
func NewVariantDouble(value float64) *Variant {
	var _arg1 C.gdouble   // out
	var _cret *C.GVariant // in

	_arg1 = C.gdouble(value)

	_cret = C.g_variant_new_double(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantFixedArray constructs a struct Variant.
func NewVariantFixedArray(elementType *VariantType, elements cgo.Handle, nElements, elementSize uint) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize         // out
	var _arg4 C.gsize         // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(elementType)))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(elements))
	_arg3 = C.gsize(nElements)
	_arg4 = C.gsize(elementSize)

	_cret = C.g_variant_new_fixed_array(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(elementType)
	runtime.KeepAlive(elements)
	runtime.KeepAlive(nElements)
	runtime.KeepAlive(elementSize)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantFromBytes constructs a struct Variant.
func NewVariantFromBytes(typ *VariantType, bytes *Bytes, trusted bool) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 *C.GBytes       // out
	var _arg3 C.gboolean      // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))
	_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	if trusted {
		_arg3 = C.TRUE
	}

	_cret = C.g_variant_new_from_bytes(_arg1, _arg2, _arg3)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(trusted)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantHandle constructs a struct Variant.
func NewVariantHandle(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint32(value)

	_cret = C.g_variant_new_handle(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantInt16 constructs a struct Variant.
func NewVariantInt16(value int16) *Variant {
	var _arg1 C.gint16    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint16(value)

	_cret = C.g_variant_new_int16(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantInt32 constructs a struct Variant.
func NewVariantInt32(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint32(value)

	_cret = C.g_variant_new_int32(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantInt64 constructs a struct Variant.
func NewVariantInt64(value int64) *Variant {
	var _arg1 C.gint64    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint64(value)

	_cret = C.g_variant_new_int64(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantMaybe constructs a struct Variant.
func NewVariantMaybe(childType *VariantType, child *Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 *C.GVariant     // out
	var _cret *C.GVariant     // in

	if childType != nil {
		_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(childType)))
	}
	if child != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(child)))
	}

	_cret = C.g_variant_new_maybe(_arg1, _arg2)
	runtime.KeepAlive(childType)
	runtime.KeepAlive(child)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantObjectPath constructs a struct Variant.
func NewVariantObjectPath(objectPath string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_object_path(_arg1)
	runtime.KeepAlive(objectPath)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantObjv constructs a struct Variant.
func NewVariantObjv(strv []string) *Variant {
	var _arg1 **C.gchar // out
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = (C.gssize)(len(strv))
	_arg1 = (**C.gchar)(C.calloc(C.size_t(len(strv)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.gchar)(_arg1), len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(strv[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_objv(_arg1, _arg2)
	runtime.KeepAlive(strv)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantSignature constructs a struct Variant.
func NewVariantSignature(signature string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(signature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_signature(_arg1)
	runtime.KeepAlive(signature)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantString constructs a struct Variant.
func NewVariantString(str string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_string(_arg1)
	runtime.KeepAlive(str)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantStrv constructs a struct Variant.
func NewVariantStrv(strv []string) *Variant {
	var _arg1 **C.gchar // out
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = (C.gssize)(len(strv))
	_arg1 = (**C.gchar)(C.calloc(C.size_t(len(strv)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.gchar)(_arg1), len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(strv[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_strv(_arg1, _arg2)
	runtime.KeepAlive(strv)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantTuple constructs a struct Variant.
func NewVariantTuple(children []*Variant) *Variant {
	var _arg1 **C.GVariant // out
	var _arg2 C.gsize
	var _cret *C.GVariant // in

	_arg2 = (C.gsize)(len(children))
	_arg1 = (**C.GVariant)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GVariant)(_arg1), len(children))
		for i := range children {
			out[i] = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(children[i])))
		}
	}

	_cret = C.g_variant_new_tuple(_arg1, _arg2)
	runtime.KeepAlive(children)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantUint16 constructs a struct Variant.
func NewVariantUint16(value uint16) *Variant {
	var _arg1 C.guint16   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint16(value)

	_cret = C.g_variant_new_uint16(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantUint32 constructs a struct Variant.
func NewVariantUint32(value uint32) *Variant {
	var _arg1 C.guint32   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint32(value)

	_cret = C.g_variant_new_uint32(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantUint64 constructs a struct Variant.
func NewVariantUint64(value uint64) *Variant {
	var _arg1 C.guint64   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint64(value)

	_cret = C.g_variant_new_uint64(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantVariant constructs a struct Variant.
func NewVariantVariant(value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_new_variant(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Byteswap performs a byteswapping operation on the contents of value. The
// result is that all multi-byte numeric data contained in value is byteswapped.
// That includes 16, 32, and 64bit signed and unsigned integers as well as file
// handles and double precision floating point values.
//
// This function is an identity mapping on any value that does not contain
// multi-byte numeric data. That include strings, booleans, bytes and containers
// containing only these things (recursively).
//
// The returned value is always in normal form and is marked as trusted.
func (value *Variant) Byteswap() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_byteswap(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// CheckFormatString checks if calling g_variant_get() with format_string on
// value would be valid from a type-compatibility standpoint. format_string is
// assumed to be a valid format string (from a syntactic standpoint).
//
// If copy_only is TRUE then this function additionally checks that it would be
// safe to call g_variant_unref() on value immediately after the call to
// g_variant_get() without invalidating the result. This is only possible if
// deep copies are made (ie: there are no pointers to the data inside of the
// soon-to-be-freed #GVariant instance). If this check fails then a g_critical()
// is printed and FALSE is returned.
//
// This function is meant to be used by functions that wish to provide varargs
// accessors to #GVariant values of uncertain values (eg: g_variant_lookup() or
// g_menu_model_get_item_attribute()).
func (value *Variant) CheckFormatString(formatString string, copyOnly bool) bool {
	var _arg0 *C.GVariant // out
	var _arg1 *C.gchar    // out
	var _arg2 C.gboolean  // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(formatString)))
	defer C.free(unsafe.Pointer(_arg1))
	if copyOnly {
		_arg2 = C.TRUE
	}

	_cret = C.g_variant_check_format_string(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(formatString)
	runtime.KeepAlive(copyOnly)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Classify classifies value according to its top-level type.
func (value *Variant) Classify() VariantClass {
	var _arg0 *C.GVariant     // out
	var _cret C.GVariantClass // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_classify(_arg0)
	runtime.KeepAlive(value)

	var _variantClass VariantClass // out

	_variantClass = VariantClass(_cret)

	return _variantClass
}

// Compare compares one and two.
//
// The types of one and two are #gconstpointer only to allow use of this
// function with #GTree, Array, etc. They must each be a #GVariant.
//
// Comparison is only defined for basic types (ie: booleans, numbers, strings).
// For booleans, FALSE is less than TRUE. Numbers are ordered in the usual way.
// Strings are in ASCII lexographical order.
//
// It is a programmer error to attempt to compare container values or two values
// that have types that are not exactly equal. For example, you cannot compare a
// 32-bit signed integer with a 32-bit unsigned integer. Also note that this
// function is not particularly well-behaved when it comes to comparison of
// doubles; in particular, the handling of incomparable values (ie: NaN) is
// undefined.
//
// If you only require an equality comparison, g_variant_equal() is more
// general.
func (one *Variant) Compare(two *Variant) int {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gint          // in

	_arg0 = C.gconstpointer(gextras.StructNative(unsafe.Pointer(one)))
	_arg1 = C.gconstpointer(gextras.StructNative(unsafe.Pointer(two)))

	_cret = C.g_variant_compare(_arg0, _arg1)
	runtime.KeepAlive(one)
	runtime.KeepAlive(two)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DupBytestring: similar to g_variant_get_bytestring() except that instead of
// returning a constant string, the string is duplicated.
//
// The return value must be freed using g_free().
func (value *Variant) DupBytestring() []byte {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_bytestring(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _guint8s []byte // out

	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))

	return _guint8s
}

// DupBytestringArray gets the contents of an array of array of bytes #GVariant.
// This call makes a deep copy; the return result should be released with
// g_strfreev().
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
func (value *Variant) DupBytestringArray() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_bytestring_array(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice(_cret, _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// DupObjv gets the contents of an array of object paths #GVariant. This call
// makes a deep copy; the return result should be released with g_strfreev().
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
func (value *Variant) DupObjv() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_objv(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice(_cret, _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// DupString: similar to g_variant_get_string() except that instead of returning
// a constant string, the string is duplicated.
//
// The string will always be UTF-8 encoded.
//
// The return value must be freed using g_free().
func (value *Variant) DupString() (uint, string) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_string(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _length uint // out
	var _utf8 string // out

	_length = uint(_arg1)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	C.free(unsafe.Pointer(_cret))

	return _length, _utf8
}

// DupStrv gets the contents of an array of strings #GVariant. This call makes a
// deep copy; the return result should be released with g_strfreev().
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
func (value *Variant) DupStrv() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_strv(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice(_cret, _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Equal checks if one and two have the same type and value.
//
// The types of one and two are #gconstpointer only to allow use of this
// function with Table. They must each be a #GVariant.
func (one *Variant) Equal(two *Variant) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = C.gconstpointer(gextras.StructNative(unsafe.Pointer(one)))
	_arg1 = C.gconstpointer(gextras.StructNative(unsafe.Pointer(two)))

	_cret = C.g_variant_equal(_arg0, _arg1)
	runtime.KeepAlive(one)
	runtime.KeepAlive(two)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Boolean returns the boolean value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_BOOLEAN.
func (value *Variant) Boolean() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_boolean(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Byte returns the byte value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_BYTE.
func (value *Variant) Byte() byte {
	var _arg0 *C.GVariant // out
	var _cret C.guint8    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_byte(_arg0)
	runtime.KeepAlive(value)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// Bytestring returns the string value of a #GVariant instance with an
// array-of-bytes type. The string has no particular encoding.
//
// If the array does not end with a nul terminator character, the empty string
// is returned. For this reason, you can always trust that a non-NULL
// nul-terminated string will be returned by this function.
//
// If the array contains a nul terminator character somewhere other than the
// last byte then the returned string is the string, up to the first such nul
// character.
//
// g_variant_get_fixed_array() should be used instead if the array contains
// arbitrary data that could not be nul-terminated or could contain nul bytes.
//
// It is an error to call this function with a value that is not an array of
// bytes.
//
// The return value remains valid as long as value exists.
func (value *Variant) Bytestring() []byte {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_bytestring(_arg0)
	runtime.KeepAlive(value)

	var _guint8s []byte // out

	{
		var i int
		var z C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = byte(src[i])
		}
	}

	return _guint8s
}

// BytestringArray gets the contents of an array of array of bytes #GVariant.
// This call makes a shallow copy; the return result should be released with
// g_free(), but the individual strings must not be modified.
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
func (value *Variant) BytestringArray() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_bytestring_array(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice(_cret, _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// ChildValue reads a child item out of a container #GVariant instance. This
// includes variants, maybes, arrays, tuples and dictionary entries. It is an
// error to call this function on any other type of #GVariant.
//
// It is an error if index_ is greater than the number of child items in the
// container. See g_variant_n_children().
//
// The returned value is never floating. You should free it with
// g_variant_unref() when you're done with it.
//
// Note that values borrowed from the returned child are not guaranteed to still
// be valid after the child is freed even if you still hold a reference to
// value, if value has not been serialised at the time this function is called.
// To avoid this, you can serialize value by calling g_variant_get_data() and
// optionally ignoring the return value.
//
// There may be implementation specific restrictions on deeply nested values,
// which would result in the unit tuple being returned as the child value,
// instead of further nested children. #GVariant is guaranteed to handle nesting
// up to at least 64 levels.
//
// This function is O(1).
func (value *Variant) ChildValue(index_ uint) *Variant {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg1 = C.gsize(index_)

	_cret = C.g_variant_get_child_value(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index_)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Data returns a pointer to the serialised form of a #GVariant instance. The
// returned data may not be in fully-normalised form if read from an untrusted
// source. The returned data must not be freed; it remains valid for as long as
// value exists.
//
// If value is a fixed-sized value that was deserialised from a corrupted
// serialised container then NULL may be returned. In this case, the proper
// thing to do is typically to use the appropriate number of nul bytes in place
// of value. If value is not fixed-sized then NULL is never returned.
//
// In the case that value is already in serialised form, this function is O(1).
// If the value is not already in serialised form, serialisation occurs
// implicitly and is approximately O(n) in the size of the result.
//
// To deserialise the data returned by this function, in addition to the
// serialised data, you must know the type of the #GVariant, and (if the machine
// might be different) the endianness of the machine that stored it. As a
// result, file formats or network messages that incorporate serialised
// #GVariants must include this information either implicitly (for instance "the
// file always contains a G_VARIANT_TYPE_VARIANT and it is always in
// little-endian order") or explicitly (by storing the type and/or endianness in
// addition to the serialised data).
func (value *Variant) Data() cgo.Handle {
	var _arg0 *C.GVariant     // out
	var _cret C.gconstpointer // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_data(_arg0)
	runtime.KeepAlive(value)

	var _gpointer cgo.Handle // out

	_gpointer = (cgo.Handle)(unsafe.Pointer(_cret))

	return _gpointer
}

// DataAsBytes returns a pointer to the serialised form of a #GVariant instance.
// The semantics of this function are exactly the same as g_variant_get_data(),
// except that the returned #GBytes holds a reference to the variant data.
func (value *Variant) DataAsBytes() *Bytes {
	var _arg0 *C.GVariant // out
	var _cret *C.GBytes   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_data_as_bytes(_arg0)
	runtime.KeepAlive(value)

	var _bytes *Bytes // out

	_bytes = (*Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Double returns the double precision floating point value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_DOUBLE.
func (value *Variant) Double() float64 {
	var _arg0 *C.GVariant // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_double(_arg0)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Handle returns the 32-bit signed integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_HANDLE.
//
// By convention, handles are indexes into an array of file descriptors that are
// sent alongside a D-Bus message. If you're not interacting with D-Bus, you
// probably don't need them.
func (value *Variant) Handle() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_handle(_arg0)
	runtime.KeepAlive(value)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// Int16 returns the 16-bit signed integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_INT16.
func (value *Variant) Int16() int16 {
	var _arg0 *C.GVariant // out
	var _cret C.gint16    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_int16(_arg0)
	runtime.KeepAlive(value)

	var _gint16 int16 // out

	_gint16 = int16(_cret)

	return _gint16
}

// Int32 returns the 32-bit signed integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_INT32.
func (value *Variant) Int32() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_int32(_arg0)
	runtime.KeepAlive(value)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// Int64 returns the 64-bit signed integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_INT64.
func (value *Variant) Int64() int64 {
	var _arg0 *C.GVariant // out
	var _cret C.gint64    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_int64(_arg0)
	runtime.KeepAlive(value)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Maybe: given a maybe-typed #GVariant instance, extract its value. If the
// value is Nothing, then this function returns NULL.
func (value *Variant) Maybe() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_maybe(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// NormalForm gets a #GVariant instance that has the same value as value and is
// trusted to be in normal form.
//
// If value is already trusted to be in normal form then a new reference to
// value is returned.
//
// If value is not already trusted, then it is scanned to check if it is in
// normal form. If it is found to be in normal form then it is marked as trusted
// and a new reference to it is returned.
//
// If value is found not to be in normal form then a new trusted #GVariant is
// created with the same value as value.
//
// It makes sense to call this function if you've received #GVariant data from
// untrusted sources and you want to ensure your serialised output is definitely
// in normal form.
//
// If value is already in normal form, a new reference will be returned (which
// will be floating if value is floating). If it is not in normal form, the
// newly created #GVariant will be returned with a single non-floating
// reference. Typically, g_variant_take_ref() should be called on the return
// value from this function to guarantee ownership of a single non-floating
// reference to it.
func (value *Variant) NormalForm() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_normal_form(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Objv gets the contents of an array of object paths #GVariant. This call makes
// a shallow copy; the return result should be released with g_free(), but the
// individual strings must not be modified.
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
func (value *Variant) Objv() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_objv(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice(_cret, _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Size determines the number of bytes that would be required to store value
// with g_variant_store().
//
// If value has a fixed-sized type then this function always returned that fixed
// size.
//
// In the case that value is already in serialised form or the size has already
// been calculated (ie: this function has been called before) then this function
// is O(1). Otherwise, the size is calculated, an operation which is
// approximately O(n) in the number of values involved.
func (value *Variant) Size() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_size(_arg0)
	runtime.KeepAlive(value)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// String returns the string value of a #GVariant instance with a string type.
// This includes the types G_VARIANT_TYPE_STRING, G_VARIANT_TYPE_OBJECT_PATH and
// G_VARIANT_TYPE_SIGNATURE.
//
// The string will always be UTF-8 encoded, will never be NULL, and will never
// contain nul bytes.
//
// If length is non-NULL then the length of the string (in bytes) is returned
// there. For trusted values, this information is already known. Untrusted
// values will be validated and, if valid, a strlen() will be performed. If
// invalid, a default value will be returned  for G_VARIANT_TYPE_OBJECT_PATH,
// this is "/", and for other types it is the empty string.
//
// It is an error to call this function with a value of any type other than
// those three.
//
// The return value remains valid as long as value exists.
func (value *Variant) String() string {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_string(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8 string

	_utf8 = C.GoStringN(_cret, C.int(_arg1))

	return _utf8
}

// Strv gets the contents of an array of strings #GVariant. This call makes a
// shallow copy; the return result should be released with g_free(), but the
// individual strings must not be modified.
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
func (value *Variant) Strv() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_strv(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice(_cret, _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Type determines the type of value.
//
// The return value is valid for the lifetime of value and must not be freed.
func (value *Variant) Type() *VariantType {
	var _arg0 *C.GVariant     // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_type(_arg0)
	runtime.KeepAlive(value)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _variantType
}

// TypeString returns the type string of value. Unlike the result of calling
// g_variant_type_peek_string(), this string is nul-terminated. This string
// belongs to #GVariant and must not be freed.
func (value *Variant) TypeString() string {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_type_string(_arg0)
	runtime.KeepAlive(value)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Uint16 returns the 16-bit unsigned integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_UINT16.
func (value *Variant) Uint16() uint16 {
	var _arg0 *C.GVariant // out
	var _cret C.guint16   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_uint16(_arg0)
	runtime.KeepAlive(value)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Uint32 returns the 32-bit unsigned integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_UINT32.
func (value *Variant) Uint32() uint32 {
	var _arg0 *C.GVariant // out
	var _cret C.guint32   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_uint32(_arg0)
	runtime.KeepAlive(value)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Uint64 returns the 64-bit unsigned integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_UINT64.
func (value *Variant) Uint64() uint64 {
	var _arg0 *C.GVariant // out
	var _cret C.guint64   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_uint64(_arg0)
	runtime.KeepAlive(value)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Variant unboxes value. The result is the #GVariant instance that was
// contained in value.
func (value *Variant) Variant() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_variant(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Hash generates a hash value for a #GVariant instance.
//
// The output of this function is guaranteed to be the same for a given value
// only per-process. It may change between different processor architectures or
// even different versions of GLib. Do not use this function as a basis for
// building protocols or file formats.
//
// The type of value is #gconstpointer only to allow use of this function with
// Table. value must be a #GVariant.
func (value *Variant) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = C.gconstpointer(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_hash(_arg0)
	runtime.KeepAlive(value)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsContainer checks if value is a container.
func (value *Variant) IsContainer() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_is_container(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFloating checks whether value has a floating reference count.
//
// This function should only ever be used to assert that a given variant is or
// is not floating, or for debug purposes. To acquire a reference to a variant
// that might be floating, always use g_variant_ref_sink() or
// g_variant_take_ref().
//
// See g_variant_ref_sink() for more information about floating reference
// counts.
func (value *Variant) IsFloating() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_is_floating(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsNormalForm checks if value is in normal form.
//
// The main reason to do this is to detect if a given chunk of serialised data
// is in normal form: load the data into a #GVariant using
// g_variant_new_from_data() and then use this function to check.
//
// If value is found to be in normal form then it will be marked as being
// trusted. If the value was already marked as being trusted then this function
// will immediately return TRUE.
//
// There may be implementation specific restrictions on deeply nested values.
// GVariant is guaranteed to handle nesting up to at least 64 levels.
func (value *Variant) IsNormalForm() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_is_normal_form(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsOfType checks if a value has a type matching the provided type.
func (value *Variant) IsOfType(typ *VariantType) bool {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_is_of_type(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupValue looks up a value in a dictionary #GVariant.
//
// This function works with dictionaries of the type a{s*} (and equally well
// with type a{o*}, but we only further discuss the string case for sake of
// clarity).
//
// In the event that dictionary has the type a{sv}, the expected_type string
// specifies what type of value is expected to be inside of the variant. If the
// value inside the variant has a different type then NULL is returned. In the
// event that dictionary has a value type other than v then expected_type must
// directly match the value type and it is used to unpack the value directly or
// an error occurs.
//
// In either case, if key is not found in dictionary, NULL is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// expected_type was specified then any non-NULL return value will have this
// type.
//
// This function is currently implemented with a linear scan. If you plan to do
// many lookups then Dict may be more efficient.
func (dictionary *Variant) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(dictionary)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	if expectedType != nil {
		_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(expectedType)))
	}

	_cret = C.g_variant_lookup_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dictionary)
	runtime.KeepAlive(key)
	runtime.KeepAlive(expectedType)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// NChildren determines the number of children in a container #GVariant
// instance. This includes variants, maybes, arrays, tuples and dictionary
// entries. It is an error to call this function on any other type of #GVariant.
//
// For variants, the return value is always 1. For values with maybe types, it
// is always zero or one. For arrays, it is the length of the array. For tuples
// it is the number of tuple items (which depends only on the type). For
// dictionary entries, it is always 2
//
// This function is O(1).
func (value *Variant) NChildren() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_n_children(_arg0)
	runtime.KeepAlive(value)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Print pretty-prints value in the format understood by g_variant_parse().
//
// The format is described [here][gvariant-text].
//
// If type_annotate is TRUE, then type information is included in the output.
func (value *Variant) Print(typeAnnotate bool) string {
	var _arg0 *C.GVariant // out
	var _arg1 C.gboolean  // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	if typeAnnotate {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_print(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(typeAnnotate)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	C.free(unsafe.Pointer(_cret))

	return _utf8
}

// RefSink uses a floating reference count system. All functions with names
// starting with g_variant_new_ return floating references.
//
// Calling g_variant_ref_sink() on a #GVariant with a floating reference will
// convert the floating reference into a full reference. Calling
// g_variant_ref_sink() on a non-floating #GVariant results in an additional
// normal reference being added.
//
// In other words, if the value is floating, then this call "assumes ownership"
// of the floating reference, converting it to a normal reference. If the value
// is not floating, then this call adds a new normal reference increasing the
// reference count by one.
//
// All calls that result in a #GVariant instance being inserted into a container
// will call g_variant_ref_sink() on the instance. This means that if the value
// was just created (and has only its floating reference) then the container
// will assume sole ownership of the value at that point and the caller will not
// need to unreference it. This makes certain common styles of programming much
// easier while still maintaining normal refcounting semantics in situations
// where values are not floating.
func (value *Variant) RefSink() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_ref_sink(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Store stores the serialised form of value at data. data should be large
// enough. See g_variant_get_size().
//
// The stored data is in machine native byte order but may not be in
// fully-normalised form if read from an untrusted source. See
// g_variant_get_normal_form() for a solution.
//
// As with g_variant_get_data(), to be able to deserialise the serialised
// variant successfully, its type and (if the destination machine might be
// different) its endianness must also be available.
//
// This function is approximately O(n) in the size of data.
func (value *Variant) Store(data cgo.Handle) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gpointer  // out

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	C.g_variant_store(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(data)
}

// VariantIsObjectPath determines if a given string is a valid D-Bus object
// path. You should ensure that a string is a valid D-Bus object path before
// passing it to g_variant_new_object_path().
//
// A valid object path starts with / followed by zero or more sequences of
// characters separated by / characters. Each sequence must contain only the
// characters [A-Z][a-z][0-9]_. No sequence (including the one following the
// final / character) may be empty.
//
// The function takes the following parameters:
//
//    - str: normal C nul-terminated string.
//
func VariantIsObjectPath(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_is_object_path(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VariantIsSignature determines if a given string is a valid D-Bus type
// signature. You should ensure that a string is a valid D-Bus type signature
// before passing it to g_variant_new_signature().
//
// D-Bus type signatures consist of zero or more definite Type strings in
// sequence.
//
// The function takes the following parameters:
//
//    - str: normal C nul-terminated string.
//
func VariantIsSignature(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_is_signature(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VariantParseErrorPrintContext pretty-prints a message showing the context of
// a #GVariant parse error within the string for which parsing was attempted.
//
// The resulting string is suitable for output to the console or other monospace
// media where newlines are treated in the usual way.
//
// The message will typically look something like one of the following:
//
//    unterminated string constant:
//      (1, 2, 3, 'abc
//                ^^^^
//
// or
//
//    unable to find a common type:
//      [1, 2, 3, 'str']
//       ^        ^^^^^
//
// The format of the message may change in a future version.
//
// error must have come from a failed attempt to g_variant_parse() and
// source_str must be exactly the same string that caused the error. If
// source_str was not nul-terminated when you passed it to g_variant_parse()
// then you must add nul termination before using this function.
//
// The function takes the following parameters:
//
//    - err from the ParseError domain.
//    - sourceStr: string that was given to the parser.
//
func VariantParseErrorPrintContext(err error, sourceStr string) string {
	var _arg1 *C.GError // out
	var _arg2 *C.gchar  // out
	var _cret *C.gchar  // in

	_arg1 = (*C.GError)(gerror.New(err))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(sourceStr)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_variant_parse_error_print_context(_arg1, _arg2)
	runtime.KeepAlive(err)
	runtime.KeepAlive(sourceStr)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VariantBuilder: utility type for constructing container-type #GVariant
// instances.
//
// This is an opaque structure and may only be accessed using the following
// functions.
//
// Builder is not threadsafe in any way. Do not attempt to access it from more
// than one thread.
//
// An instance of this type is always passed by reference.
type VariantBuilder struct {
	*variantBuilder
}

// variantBuilder is the struct that's finalized.
type variantBuilder struct {
	native *C.GVariantBuilder
}

func marshalVariantBuilder(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VariantBuilder{&variantBuilder{(*C.GVariantBuilder)(b)}}, nil
}

// NewVariantBuilder constructs a struct VariantBuilder.
func NewVariantBuilder(typ *VariantType) *VariantBuilder {
	var _arg1 *C.GVariantType    // out
	var _cret *C.GVariantBuilder // in

	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_builder_new(_arg1)
	runtime.KeepAlive(typ)

	var _variantBuilder *VariantBuilder // out

	_variantBuilder = (*VariantBuilder)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantBuilder)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_builder_unref((*C.GVariantBuilder)(intern.C))
		},
	)

	return _variantBuilder
}

// AddValue adds value to builder.
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed. Some examples of this are putting
// different types of items into an array, putting the wrong types or number of
// items in a tuple, putting more than one value into a variant, etc.
//
// If value is a floating reference (see g_variant_ref_sink()), the builder
// instance takes ownership of value.
func (builder *VariantBuilder) AddValue(value *Variant) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariant        // out

	_arg0 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_variant_builder_add_value(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(value)
}

// Close closes the subcontainer inside the given builder that was opened by the
// most recent call to g_variant_builder_open().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: too few values added to the
// subcontainer).
func (builder *VariantBuilder) Close() {
	var _arg0 *C.GVariantBuilder // out

	_arg0 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))

	C.g_variant_builder_close(_arg0)
	runtime.KeepAlive(builder)
}

// End ends the builder process and returns the constructed value.
//
// It is not permissible to use builder in any way after this call except for
// reference counting operations (in the case of a heap-allocated Builder) or by
// reinitialising it with g_variant_builder_init() (in the case of
// stack-allocated). This means that for the stack-allocated builders there is
// no need to call g_variant_builder_clear() after the call to
// g_variant_builder_end().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: insufficient number of items added
// to a container with a specific number of children required). It is also an
// error to call this function if the builder was created with an indefinite
// array or maybe type and no children have been added; in this case it is
// impossible to infer the type of the empty array.
func (builder *VariantBuilder) End() *Variant {
	var _arg0 *C.GVariantBuilder // out
	var _cret *C.GVariant        // in

	_arg0 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))

	_cret = C.g_variant_builder_end(_arg0)
	runtime.KeepAlive(builder)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Open opens a subcontainer inside the given builder. When done adding items to
// the subcontainer, g_variant_builder_close() must be called. type is the type
// of the container: so to build a tuple of several values, type must include
// the tuple itself.
//
// It is an error to call this function in any way that would cause an
// inconsistent value to be constructed (ie: adding too many values or a value
// of an incorrect type).
//
// Example of building a nested variant:
//
//    GVariantBuilder builder;
//    guint32 some_number = get_number ();
//    g_autoptr (GHashTable) some_dict = get_dict ();
//    GHashTableIter iter;
//    const gchar *key;
//    const GVariant *value;
//    g_autoptr (GVariant) output = NULL;
//
//    g_variant_builder_init (&builder, G_VARIANT_TYPE ("(ua{sv})"));
//    g_variant_builder_add (&builder, "u", some_number);
//    g_variant_builder_open (&builder, G_VARIANT_TYPE ("a{sv}"));
//
//    g_hash_table_iter_init (&iter, some_dict);
//    while (g_hash_table_iter_next (&iter, (gpointer *) &key, (gpointer *) &value))
//      {
//        g_variant_builder_open (&builder, G_VARIANT_TYPE ("{sv}"));
//        g_variant_builder_add (&builder, "s", key);
//        g_variant_builder_add (&builder, "v", value);
//        g_variant_builder_close (&builder);
//      }
//
//    g_variant_builder_close (&builder);
//
//    output = g_variant_builder_end (&builder);.
func (builder *VariantBuilder) Open(typ *VariantType) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariantType    // out

	_arg0 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	C.g_variant_builder_open(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typ)
}

// VariantDict is a mutable interface to #GVariant dictionaries.
//
// It can be used for doing a sequence of dictionary lookups in an efficient way
// on an existing #GVariant dictionary or it can be used to construct new
// dictionaries with a hashtable-like interface. It can also be used for taking
// existing dictionaries and modifying them in order to create new ones.
//
// Dict can only be used with G_VARIANT_TYPE_VARDICT dictionaries.
//
// It is possible to use Dict allocated on the stack or on the heap. When using
// a stack-allocated Dict, you begin with a call to g_variant_dict_init() and
// free the resources with a call to g_variant_dict_clear().
//
// Heap-allocated Dict follows normal refcounting rules: you allocate it with
// g_variant_dict_new() and use g_variant_dict_ref() and g_variant_dict_unref().
//
// g_variant_dict_end() is used to convert the Dict back into a dictionary-type
// #GVariant. When used with stack-allocated instances, this also implicitly
// frees all associated memory, but for heap-allocated instances, you must still
// call g_variant_dict_unref() afterwards.
//
// You will typically want to use a heap-allocated Dict when you expose it as
// part of an API. For most other uses, the stack-allocated form will be more
// convenient.
//
// Consider the following two examples that do the same thing in each style:
// take an existing dictionary and look up the "count" uint32 key, adding 1 to
// it if it is found, or returning an error if the key is not found. Each
// returns the new dictionary as a floating #GVariant.
//
// Using a stack-allocated GVariantDict
//
//      GVariant *
//      add_to_count (GVariant  *orig,
//                    GError   **error)
//      {
//        GVariantDict *dict;
//        GVariant *result;
//        guint32 count;
//
//        dict = g_variant_dict_new (orig);
//
//        if (g_variant_dict_lookup (dict, "count", "u", &count))
//          {
//            g_variant_dict_insert (dict, "count", "u", count + 1);
//            result = g_variant_dict_end (dict);
//          }
//        else
//          {
//            g_set_error (...);
//            result = NULL;
//          }
//
//        g_variant_dict_unref (dict);
//
//        return result;
//      }
//
// An instance of this type is always passed by reference.
type VariantDict struct {
	*variantDict
}

// variantDict is the struct that's finalized.
type variantDict struct {
	native *C.GVariantDict
}

func marshalVariantDict(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VariantDict{&variantDict{(*C.GVariantDict)(b)}}, nil
}

// NewVariantDict constructs a struct VariantDict.
func NewVariantDict(fromAsv *Variant) *VariantDict {
	var _arg1 *C.GVariant     // out
	var _cret *C.GVariantDict // in

	if fromAsv != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(fromAsv)))
	}

	_cret = C.g_variant_dict_new(_arg1)
	runtime.KeepAlive(fromAsv)

	var _variantDict *VariantDict // out

	_variantDict = (*VariantDict)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantDict)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_dict_unref((*C.GVariantDict)(intern.C))
		},
	)

	return _variantDict
}

// Clear releases all memory associated with a Dict without freeing the Dict
// structure itself.
//
// It typically only makes sense to do this on a stack-allocated Dict if you
// want to abort building the value part-way through. This function need not be
// called if you call g_variant_dict_end() and it also doesn't need to be called
// on dicts allocated with g_variant_dict_new (see g_variant_dict_unref() for
// that).
//
// It is valid to call this function on either an initialised Dict or one that
// was previously cleared by an earlier call to g_variant_dict_clear() but it is
// not valid to call this function on uninitialised memory.
func (dict *VariantDict) Clear() {
	var _arg0 *C.GVariantDict // out

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))

	C.g_variant_dict_clear(_arg0)
	runtime.KeepAlive(dict)
}

// Contains checks if key exists in dict.
func (dict *VariantDict) Contains(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_contains(_arg0, _arg1)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// End returns the current value of dict as a #GVariant of type
// G_VARIANT_TYPE_VARDICT, clearing it in the process.
//
// It is not permissible to use dict in any way after this call except for
// reference counting operations (in the case of a heap-allocated Dict) or by
// reinitialising it with g_variant_dict_init() (in the case of
// stack-allocated).
func (dict *VariantDict) End() *Variant {
	var _arg0 *C.GVariantDict // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))

	_cret = C.g_variant_dict_end(_arg0)
	runtime.KeepAlive(dict)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// InsertValue inserts (or replaces) a key in a Dict.
//
// value is consumed if it is floating.
func (dict *VariantDict) InsertValue(key string, value *Variant) {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_variant_dict_insert_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// LookupValue looks up a value in a Dict.
//
// If key is not found in dictionary, NULL is returned.
//
// The expected_type string specifies what type of value is expected. If the
// value associated with key has a different type then NULL is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// expected_type was specified then any non-NULL return value will have this
// type.
func (dict *VariantDict) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	if expectedType != nil {
		_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(expectedType)))
	}

	_cret = C.g_variant_dict_lookup_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)
	runtime.KeepAlive(expectedType)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Remove removes a key and its associated value from a Dict.
func (dict *VariantDict) Remove(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_remove(_arg0, _arg1)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func marshalVariant(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Variant{&variant{(*C.GVariant)(b)}}, nil
}

// Foreach iterates over items in value. The iteration breaks out once f
// returns true. This method wraps around g_variant_iter_new.
func (value *Variant) Foreach(f func(*Variant) (stop bool)) {
	valueNative := (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	var iter C.GVariantIter
	C.g_variant_iter_init(&iter, valueNative)

	next := func() *Variant {
		item := C.g_variant_iter_next_value(&iter)
		if item == nil {
			return nil
		}

		variant := (*Variant)(gextras.NewStructNative(unsafe.Pointer(item)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)

		return variant
	}

	for item := next(); item != nil; item = next() {
		if f(item) {
			break
		}
	}

	runtime.KeepAlive(value)
}
