// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gsk/gsk.h>
// extern void _gotk4_gsk4_ParseErrorFunc(GskParseLocation*, GskParseLocation*, GError*, gpointer);
import "C"

// GType values.
var (
	GTypeBlendMode                   = coreglib.Type(C.gsk_blend_mode_get_type())
	GTypeCorner                      = coreglib.Type(C.gsk_corner_get_type())
	GTypeGLUniformType               = coreglib.Type(C.gsk_gl_uniform_type_get_type())
	GTypeRenderNodeType              = coreglib.Type(C.gsk_render_node_type_get_type())
	GTypeScalingFilter               = coreglib.Type(C.gsk_scaling_filter_get_type())
	GTypeSerializationError          = coreglib.Type(C.gsk_serialization_error_get_type())
	GTypeTransformCategory           = coreglib.Type(C.gsk_transform_category_get_type())
	GTypeBlendNode                   = coreglib.Type(C.gsk_blend_node_get_type())
	GTypeBlurNode                    = coreglib.Type(C.gsk_blur_node_get_type())
	GTypeBorderNode                  = coreglib.Type(C.gsk_border_node_get_type())
	GTypeCairoNode                   = coreglib.Type(C.gsk_cairo_node_get_type())
	GTypeCairoRenderer               = coreglib.Type(C.gsk_cairo_renderer_get_type())
	GTypeClipNode                    = coreglib.Type(C.gsk_clip_node_get_type())
	GTypeColorMatrixNode             = coreglib.Type(C.gsk_color_matrix_node_get_type())
	GTypeColorNode                   = coreglib.Type(C.gsk_color_node_get_type())
	GTypeConicGradientNode           = coreglib.Type(C.gsk_conic_gradient_node_get_type())
	GTypeContainerNode               = coreglib.Type(C.gsk_container_node_get_type())
	GTypeCrossFadeNode               = coreglib.Type(C.gsk_cross_fade_node_get_type())
	GTypeDebugNode                   = coreglib.Type(C.gsk_debug_node_get_type())
	GTypeGLShader                    = coreglib.Type(C.gsk_gl_shader_get_type())
	GTypeGLShaderNode                = coreglib.Type(C.gsk_gl_shader_node_get_type())
	GTypeInsetShadowNode             = coreglib.Type(C.gsk_inset_shadow_node_get_type())
	GTypeLinearGradientNode          = coreglib.Type(C.gsk_linear_gradient_node_get_type())
	GTypeOpacityNode                 = coreglib.Type(C.gsk_opacity_node_get_type())
	GTypeOutsetShadowNode            = coreglib.Type(C.gsk_outset_shadow_node_get_type())
	GTypeRadialGradientNode          = coreglib.Type(C.gsk_radial_gradient_node_get_type())
	GTypeRenderNode                  = coreglib.Type(C.gsk_render_node_get_type())
	GTypeRenderer                    = coreglib.Type(C.gsk_renderer_get_type())
	GTypeRepeatNode                  = coreglib.Type(C.gsk_repeat_node_get_type())
	GTypeRepeatingLinearGradientNode = coreglib.Type(C.gsk_repeating_linear_gradient_node_get_type())
	GTypeRepeatingRadialGradientNode = coreglib.Type(C.gsk_repeating_radial_gradient_node_get_type())
	GTypeRoundedClipNode             = coreglib.Type(C.gsk_rounded_clip_node_get_type())
	GTypeShadowNode                  = coreglib.Type(C.gsk_shadow_node_get_type())
	GTypeTextNode                    = coreglib.Type(C.gsk_text_node_get_type())
	GTypeTextureNode                 = coreglib.Type(C.gsk_texture_node_get_type())
	GTypeTransformNode               = coreglib.Type(C.gsk_transform_node_get_type())
	GTypeShaderArgsBuilder           = coreglib.Type(C.gsk_shader_args_builder_get_type())
	GTypeTransform                   = coreglib.Type(C.gsk_transform_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBlendMode, F: marshalBlendMode},
		coreglib.TypeMarshaler{T: GTypeCorner, F: marshalCorner},
		coreglib.TypeMarshaler{T: GTypeGLUniformType, F: marshalGLUniformType},
		coreglib.TypeMarshaler{T: GTypeRenderNodeType, F: marshalRenderNodeType},
		coreglib.TypeMarshaler{T: GTypeScalingFilter, F: marshalScalingFilter},
		coreglib.TypeMarshaler{T: GTypeSerializationError, F: marshalSerializationError},
		coreglib.TypeMarshaler{T: GTypeTransformCategory, F: marshalTransformCategory},
		coreglib.TypeMarshaler{T: GTypeBlendNode, F: marshalBlendNode},
		coreglib.TypeMarshaler{T: GTypeBlurNode, F: marshalBlurNode},
		coreglib.TypeMarshaler{T: GTypeBorderNode, F: marshalBorderNode},
		coreglib.TypeMarshaler{T: GTypeCairoNode, F: marshalCairoNode},
		coreglib.TypeMarshaler{T: GTypeCairoRenderer, F: marshalCairoRenderer},
		coreglib.TypeMarshaler{T: GTypeClipNode, F: marshalClipNode},
		coreglib.TypeMarshaler{T: GTypeColorMatrixNode, F: marshalColorMatrixNode},
		coreglib.TypeMarshaler{T: GTypeColorNode, F: marshalColorNode},
		coreglib.TypeMarshaler{T: GTypeConicGradientNode, F: marshalConicGradientNode},
		coreglib.TypeMarshaler{T: GTypeContainerNode, F: marshalContainerNode},
		coreglib.TypeMarshaler{T: GTypeCrossFadeNode, F: marshalCrossFadeNode},
		coreglib.TypeMarshaler{T: GTypeDebugNode, F: marshalDebugNode},
		coreglib.TypeMarshaler{T: GTypeGLShader, F: marshalGLShader},
		coreglib.TypeMarshaler{T: GTypeGLShaderNode, F: marshalGLShaderNode},
		coreglib.TypeMarshaler{T: GTypeInsetShadowNode, F: marshalInsetShadowNode},
		coreglib.TypeMarshaler{T: GTypeLinearGradientNode, F: marshalLinearGradientNode},
		coreglib.TypeMarshaler{T: GTypeOpacityNode, F: marshalOpacityNode},
		coreglib.TypeMarshaler{T: GTypeOutsetShadowNode, F: marshalOutsetShadowNode},
		coreglib.TypeMarshaler{T: GTypeRadialGradientNode, F: marshalRadialGradientNode},
		coreglib.TypeMarshaler{T: GTypeRenderNode, F: marshalRenderNode},
		coreglib.TypeMarshaler{T: GTypeRenderer, F: marshalRenderer},
		coreglib.TypeMarshaler{T: GTypeRepeatNode, F: marshalRepeatNode},
		coreglib.TypeMarshaler{T: GTypeRepeatingLinearGradientNode, F: marshalRepeatingLinearGradientNode},
		coreglib.TypeMarshaler{T: GTypeRepeatingRadialGradientNode, F: marshalRepeatingRadialGradientNode},
		coreglib.TypeMarshaler{T: GTypeRoundedClipNode, F: marshalRoundedClipNode},
		coreglib.TypeMarshaler{T: GTypeShadowNode, F: marshalShadowNode},
		coreglib.TypeMarshaler{T: GTypeTextNode, F: marshalTextNode},
		coreglib.TypeMarshaler{T: GTypeTextureNode, F: marshalTextureNode},
		coreglib.TypeMarshaler{T: GTypeTransformNode, F: marshalTransformNode},
		coreglib.TypeMarshaler{T: GTypeShaderArgsBuilder, F: marshalShaderArgsBuilder},
		coreglib.TypeMarshaler{T: GTypeTransform, F: marshalTransform},
	})
}

// BlendMode: blend modes available for render nodes.
//
// The implementation of each blend mode is deferred to the rendering pipeline.
//
// See https://www.w3.org/TR/compositing-1/#blending for more information on
// blending and blend modes.
type BlendMode C.gint

const (
	// BlendModeDefault: default blend mode, which specifies no blending.
	BlendModeDefault BlendMode = iota
	// BlendModeMultiply: source color is multiplied by the destination and
	// replaces the destination.
	BlendModeMultiply
	// BlendModeScreen multiplies the complements of the destination and source
	// color values, then complements the result.
	BlendModeScreen
	// BlendModeOverlay multiplies or screens the colors, depending on the
	// destination color value. This is the inverse of hard-list.
	BlendModeOverlay
	// BlendModeDarken selects the darker of the destination and source colors.
	BlendModeDarken
	// BlendModeLighten selects the lighter of the destination and source
	// colors.
	BlendModeLighten
	// BlendModeColorDodge brightens the destination color to reflect the source
	// color.
	BlendModeColorDodge
	// BlendModeColorBurn darkens the destination color to reflect the source
	// color.
	BlendModeColorBurn
	// BlendModeHardLight multiplies or screens the colors, depending on the
	// source color value.
	BlendModeHardLight
	// BlendModeSoftLight darkens or lightens the colors, depending on the
	// source color value.
	BlendModeSoftLight
	// BlendModeDifference subtracts the darker of the two constituent colors
	// from the lighter color.
	BlendModeDifference
	// BlendModeExclusion produces an effect similar to that of the difference
	// mode but lower in contrast.
	BlendModeExclusion
	// BlendModeColor creates a color with the hue and saturation of the source
	// color and the luminosity of the destination color.
	BlendModeColor
	// BlendModeHue creates a color with the hue of the source color and the
	// saturation and luminosity of the destination color.
	BlendModeHue
	// BlendModeSaturation creates a color with the saturation of the source
	// color and the hue and luminosity of the destination color.
	BlendModeSaturation
	// BlendModeLuminosity creates a color with the luminosity of the source
	// color and the hue and saturation of the destination color.
	BlendModeLuminosity
)

func marshalBlendMode(p uintptr) (interface{}, error) {
	return BlendMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BlendMode.
func (b BlendMode) String() string {
	switch b {
	case BlendModeDefault:
		return "Default"
	case BlendModeMultiply:
		return "Multiply"
	case BlendModeScreen:
		return "Screen"
	case BlendModeOverlay:
		return "Overlay"
	case BlendModeDarken:
		return "Darken"
	case BlendModeLighten:
		return "Lighten"
	case BlendModeColorDodge:
		return "ColorDodge"
	case BlendModeColorBurn:
		return "ColorBurn"
	case BlendModeHardLight:
		return "HardLight"
	case BlendModeSoftLight:
		return "SoftLight"
	case BlendModeDifference:
		return "Difference"
	case BlendModeExclusion:
		return "Exclusion"
	case BlendModeColor:
		return "Color"
	case BlendModeHue:
		return "Hue"
	case BlendModeSaturation:
		return "Saturation"
	case BlendModeLuminosity:
		return "Luminosity"
	default:
		return fmt.Sprintf("BlendMode(%d)", b)
	}
}

// Corner: corner indices used by RoundedRect.
type Corner C.gint

const (
	// CornerTopLeft: top left corner.
	CornerTopLeft Corner = iota
	// CornerTopRight: top right corner.
	CornerTopRight
	// CornerBottomRight: bottom right corner.
	CornerBottomRight
	// CornerBottomLeft: bottom left corner.
	CornerBottomLeft
)

func marshalCorner(p uintptr) (interface{}, error) {
	return Corner(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Corner.
func (c Corner) String() string {
	switch c {
	case CornerTopLeft:
		return "TopLeft"
	case CornerTopRight:
		return "TopRight"
	case CornerBottomRight:
		return "BottomRight"
	case CornerBottomLeft:
		return "BottomLeft"
	default:
		return fmt.Sprintf("Corner(%d)", c)
	}
}

// GLUniformType: this defines the types of the uniforms that GskGLShaders
// declare.
//
// It defines both what the type is called in the GLSL shader code, and what the
// corresponding C type is on the Gtk side.
type GLUniformType C.gint

const (
	// GLUniformTypeNone: no type, used for uninitialized or unspecified values.
	GLUniformTypeNone GLUniformType = iota
	// GLUniformTypeFloat: float uniform.
	GLUniformTypeFloat
	// GLUniformTypeInt: GLSL int / gint32 uniform.
	GLUniformTypeInt
	// GLUniformTypeUint: GLSL uint / guint32 uniform.
	GLUniformTypeUint
	// GLUniformTypeBool: GLSL bool / gboolean uniform.
	GLUniformTypeBool
	// GLUniformTypeVec2: GLSL vec2 / graphene_vec2_t uniform.
	GLUniformTypeVec2
	// GLUniformTypeVec3: GLSL vec3 / graphene_vec3_t uniform.
	GLUniformTypeVec3
	// GLUniformTypeVec4: GLSL vec4 / graphene_vec4_t uniform.
	GLUniformTypeVec4
)

func marshalGLUniformType(p uintptr) (interface{}, error) {
	return GLUniformType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLUniformType.
func (g GLUniformType) String() string {
	switch g {
	case GLUniformTypeNone:
		return "None"
	case GLUniformTypeFloat:
		return "Float"
	case GLUniformTypeInt:
		return "Int"
	case GLUniformTypeUint:
		return "Uint"
	case GLUniformTypeBool:
		return "Bool"
	case GLUniformTypeVec2:
		return "Vec2"
	case GLUniformTypeVec3:
		return "Vec3"
	case GLUniformTypeVec4:
		return "Vec4"
	default:
		return fmt.Sprintf("GLUniformType(%d)", g)
	}
}

// RenderNodeType: type of a node determines what the node is rendering.
type RenderNodeType C.gint

const (
	// NotARenderNodeType: error type. No node will ever have this type.
	NotARenderNodeType RenderNodeType = iota
	// ContainerNodeType: node containing a stack of children.
	ContainerNodeType
	// CairoNodeType: node drawing a #cairo_surface_t.
	CairoNodeType
	// ColorNodeType: node drawing a single color rectangle.
	ColorNodeType
	// LinearGradientNodeType: node drawing a linear gradient.
	LinearGradientNodeType
	// RepeatingLinearGradientNodeType: node drawing a repeating linear
	// gradient.
	RepeatingLinearGradientNodeType
	// RadialGradientNodeType: node drawing a radial gradient.
	RadialGradientNodeType
	// RepeatingRadialGradientNodeType: node drawing a repeating radial
	// gradient.
	RepeatingRadialGradientNodeType
	// ConicGradientNodeType: node drawing a conic gradient.
	ConicGradientNodeType
	// BorderNodeType: node stroking a border around an area.
	BorderNodeType
	// TextureNodeType: node drawing a Texture.
	TextureNodeType
	// InsetShadowNodeType: node drawing an inset shadow.
	InsetShadowNodeType
	// OutsetShadowNodeType: node drawing an outset shadow.
	OutsetShadowNodeType
	// TransformNodeType: node that renders its child after applying a matrix
	// transform.
	TransformNodeType
	// OpacityNodeType: node that changes the opacity of its child.
	OpacityNodeType
	// ColorMatrixNodeType: node that applies a color matrix to every pixel.
	ColorMatrixNodeType
	// RepeatNodeType: node that repeats the child's contents.
	RepeatNodeType
	// ClipNodeType: node that clips its child to a rectangular area.
	ClipNodeType
	// RoundedClipNodeType: node that clips its child to a rounded rectangle.
	RoundedClipNodeType
	// ShadowNodeType: node that draws a shadow below its child.
	ShadowNodeType
	// BlendNodeType: node that blends two children together.
	BlendNodeType
	// CrossFadeNodeType: node that cross-fades between two children.
	CrossFadeNodeType
	// TextNodeType: node containing a glyph string.
	TextNodeType
	// BlurNodeType: node that applies a blur.
	BlurNodeType
	// DebugNodeType: debug information that does not affect the rendering.
	DebugNodeType
	// GLShaderNodeType: node that uses OpenGL fragment shaders to render.
	GLShaderNodeType
)

func marshalRenderNodeType(p uintptr) (interface{}, error) {
	return RenderNodeType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RenderNodeType.
func (r RenderNodeType) String() string {
	switch r {
	case NotARenderNodeType:
		return "NotARenderNode"
	case ContainerNodeType:
		return "ContainerNode"
	case CairoNodeType:
		return "CairoNode"
	case ColorNodeType:
		return "ColorNode"
	case LinearGradientNodeType:
		return "LinearGradientNode"
	case RepeatingLinearGradientNodeType:
		return "RepeatingLinearGradientNode"
	case RadialGradientNodeType:
		return "RadialGradientNode"
	case RepeatingRadialGradientNodeType:
		return "RepeatingRadialGradientNode"
	case ConicGradientNodeType:
		return "ConicGradientNode"
	case BorderNodeType:
		return "BorderNode"
	case TextureNodeType:
		return "TextureNode"
	case InsetShadowNodeType:
		return "InsetShadowNode"
	case OutsetShadowNodeType:
		return "OutsetShadowNode"
	case TransformNodeType:
		return "TransformNode"
	case OpacityNodeType:
		return "OpacityNode"
	case ColorMatrixNodeType:
		return "ColorMatrixNode"
	case RepeatNodeType:
		return "RepeatNode"
	case ClipNodeType:
		return "ClipNode"
	case RoundedClipNodeType:
		return "RoundedClipNode"
	case ShadowNodeType:
		return "ShadowNode"
	case BlendNodeType:
		return "BlendNode"
	case CrossFadeNodeType:
		return "CrossFadeNode"
	case TextNodeType:
		return "TextNode"
	case BlurNodeType:
		return "BlurNode"
	case DebugNodeType:
		return "DebugNode"
	case GLShaderNodeType:
		return "GLShaderNode"
	default:
		return fmt.Sprintf("RenderNodeType(%d)", r)
	}
}

// ScalingFilter filters used when scaling texture data.
//
// The actual implementation of each filter is deferred to the rendering
// pipeline.
type ScalingFilter C.gint

const (
	// ScalingFilterLinear: linear interpolation filter.
	ScalingFilterLinear ScalingFilter = iota
	// ScalingFilterNearest: nearest neighbor interpolation filter.
	ScalingFilterNearest
	// ScalingFilterTrilinear: linear interpolation along each axis, plus mipmap
	// generation, with linear interpolation along the mipmap levels.
	ScalingFilterTrilinear
)

func marshalScalingFilter(p uintptr) (interface{}, error) {
	return ScalingFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScalingFilter.
func (s ScalingFilter) String() string {
	switch s {
	case ScalingFilterLinear:
		return "Linear"
	case ScalingFilterNearest:
		return "Nearest"
	case ScalingFilterTrilinear:
		return "Trilinear"
	default:
		return fmt.Sprintf("ScalingFilter(%d)", s)
	}
}

// SerializationError errors that can happen during (de)serialization.
type SerializationError C.gint

const (
	// SerializationUnsupportedFormat: format can not be identified.
	SerializationUnsupportedFormat SerializationError = iota
	// SerializationUnsupportedVersion: version of the data is not understood.
	SerializationUnsupportedVersion
	// SerializationInvalidData: given data may not exist in a proper
	// serialization.
	SerializationInvalidData
)

func marshalSerializationError(p uintptr) (interface{}, error) {
	return SerializationError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SerializationError.
func (s SerializationError) String() string {
	switch s {
	case SerializationUnsupportedFormat:
		return "UnsupportedFormat"
	case SerializationUnsupportedVersion:
		return "UnsupportedVersion"
	case SerializationInvalidData:
		return "InvalidData"
	default:
		return fmt.Sprintf("SerializationError(%d)", s)
	}
}

// The function returns the following values:
//
func SerializationErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gsk_serialization_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// TransformCategory categories of matrices relevant for GSK and GTK.
//
// Note that any category includes matrices of all later categories.
// So if you want to for example check if a matrix is a 2D matrix, category >=
// GSK_TRANSFORM_CATEGORY_2D is the way to do this.
//
// Also keep in mind that rounding errors may cause matrices to not conform
// to their categories. Otherwise, matrix operations done via multiplication
// will not worsen categories. So for the matrix multiplication C = A * B,
// category(C) = MIN (category(A), category(B)).
type TransformCategory C.gint

const (
	// TransformCategoryUnknown: category of the matrix has not been determined.
	TransformCategoryUnknown TransformCategory = iota
	// TransformCategoryAny: analyzing the matrix concluded that it does not fit
	// in any other category.
	TransformCategoryAny
	// TransformCategory3D: matrix is a 3D matrix. This means that the w column
	// (the last column) has the values (0, 0, 0, 1).
	TransformCategory3D
	// TransformCategory2D: matrix is a 2D matrix. This is equivalent to
	// graphene_matrix_is_2d() returning TRUE. In particular, this means that
	// Cairo can deal with the matrix.
	TransformCategory2D
	// TransformCategory2DAffine: matrix is a combination of 2D scale and 2D
	// translation operations. In particular, this means that any rectangle can
	// be transformed exactly using this matrix.
	TransformCategory2DAffine
	// TransformCategory2DTranslate: matrix is a 2D translation.
	TransformCategory2DTranslate
	// TransformCategoryIdentity: matrix is the identity matrix.
	TransformCategoryIdentity
)

func marshalTransformCategory(p uintptr) (interface{}, error) {
	return TransformCategory(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TransformCategory.
func (t TransformCategory) String() string {
	switch t {
	case TransformCategoryUnknown:
		return "Unknown"
	case TransformCategoryAny:
		return "Any"
	case TransformCategory3D:
		return "3D"
	case TransformCategory2D:
		return "2D"
	case TransformCategory2DAffine:
		return "2DAffine"
	case TransformCategory2DTranslate:
		return "2DTranslate"
	case TransformCategoryIdentity:
		return "Identity"
	default:
		return fmt.Sprintf("TransformCategory(%d)", t)
	}
}

// ParseErrorFunc: type of callback that is called when an error occurs during
// node deserialization.
type ParseErrorFunc func(start, end *ParseLocation, err error)

// BlendNode: render node applying a blending function between its two child
// nodes.
type BlendNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*BlendNode)(nil)
)

func wrapBlendNode(obj *coreglib.Object) *BlendNode {
	return &BlendNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalBlendNode(p uintptr) (interface{}, error) {
	return wrapBlendNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBlendNode creates a GskRenderNode that will use blend_mode to blend the
// top node onto the bottom node.
//
// The function takes the following parameters:
//
//   - bottom node to be drawn.
//   - top: node to be blended onto the bottom node.
//   - blendMode: blend mode to use.
//
// The function returns the following values:
//
//   - blendNode: new GskRenderNode.
//
func NewBlendNode(bottom, top RenderNoder, blendMode BlendMode) *BlendNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.GskBlendMode   // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(bottom).Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(top).Native()))
	_arg3 = C.GskBlendMode(blendMode)

	_cret = C.gsk_blend_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bottom)
	runtime.KeepAlive(top)
	runtime.KeepAlive(blendMode)

	var _blendNode *BlendNode // out

	_blendNode = wrapBlendNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blendNode
}

// BlendMode retrieves the blend mode used by node.
//
// The function returns the following values:
//
//   - blendMode: blend mode.
//
func (node *BlendNode) BlendMode() BlendMode {
	var _arg0 *C.GskRenderNode // out
	var _cret C.GskBlendMode   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_blend_node_get_blend_mode(_arg0)
	runtime.KeepAlive(node)

	var _blendMode BlendMode // out

	_blendMode = BlendMode(_cret)

	return _blendMode
}

// BottomChild retrieves the bottom GskRenderNode child of the node.
//
// The function returns the following values:
//
//   - renderNode: bottom child node.
//
func (node *BlendNode) BottomChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_blend_node_get_bottom_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// TopChild retrieves the top GskRenderNode child of the node.
//
// The function returns the following values:
//
//   - renderNode: top child node.
//
func (node *BlendNode) TopChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_blend_node_get_top_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// BlurNode: render node applying a blur effect to its single child.
type BlurNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*BlurNode)(nil)
)

func wrapBlurNode(obj *coreglib.Object) *BlurNode {
	return &BlurNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalBlurNode(p uintptr) (interface{}, error) {
	return wrapBlurNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBlurNode creates a render node that blurs the child.
//
// The function takes the following parameters:
//
//   - child node to blur.
//   - radius: blur radius.
//
// The function returns the following values:
//
//   - blurNode: new GskRenderNode.
//
func NewBlurNode(child RenderNoder, radius float32) *BlurNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.float(radius)

	_cret = C.gsk_blur_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(radius)

	var _blurNode *BlurNode // out

	_blurNode = wrapBlurNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blurNode
}

// Child retrieves the child GskRenderNode of the blur node.
//
// The function returns the following values:
//
//   - renderNode: blurred child node.
//
func (node *BlurNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_blur_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Radius retrieves the blur radius of the node.
//
// The function returns the following values:
//
//   - gfloat: blur radius.
//
func (node *BlurNode) Radius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_blur_node_get_radius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// BorderNode: render node for a border.
type BorderNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*BorderNode)(nil)
)

func wrapBorderNode(obj *coreglib.Object) *BorderNode {
	return &BorderNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalBorderNode(p uintptr) (interface{}, error) {
	return wrapBorderNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBorderNode creates a GskRenderNode that will stroke a border rectangle
// inside the given outline.
//
// The 4 sides of the border can have different widths and colors.
//
// The function takes the following parameters:
//
//   - outline describing the outline of the border.
//   - borderWidth: stroke width of the border on the top, right, bottom and
//     left side respectively.
//   - borderColor: color used on the top, right, bottom and left side.
//
// The function returns the following values:
//
//   - borderNode: new GskRenderNode.
//
func NewBorderNode(outline *RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) *BorderNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.float          // out
	var _arg3 *C.GdkRGBA        // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
	{
		var out [4]C.GdkRGBA
		_arg3 = &out[0]
		for i := 0; i < 4; i++ {
			out[i] = *(*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer((&borderColor[i]))))
		}
	}

	_cret = C.gsk_border_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(borderWidth)
	runtime.KeepAlive(borderColor)

	var _borderNode *BorderNode // out

	_borderNode = wrapBorderNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _borderNode
}

// Colors retrieves the colors of the border.
//
// The function returns the following values:
//
//   - rgbA: array of 4 RGBA structs for the top, right, bottom and left color
//     of the border.
//
func (node *BorderNode) Colors() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_border_node_get_colors(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Outline retrieves the outline of the border.
//
// The function returns the following values:
//
//   - roundedRect: outline of the border.
//
func (node *BorderNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_border_node_get_outline(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Widths retrieves the stroke widths of the border.
//
// The function returns the following values:
//
//   - gfloats: array of 4 floats for the top, right, bottom and left stroke
//     width of the border, respectively.
//
func (node *BorderNode) Widths() [4]float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.float         // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_border_node_get_widths(_arg0)
	runtime.KeepAlive(node)

	var _gfloats [4]float32 // out

	_gfloats = *(*[4]float32)(unsafe.Pointer(&_cret))

	return _gfloats
}

// CairoNode: render node for a Cairo surface.
type CairoNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*CairoNode)(nil)
)

func wrapCairoNode(obj *coreglib.Object) *CairoNode {
	return &CairoNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalCairoNode(p uintptr) (interface{}, error) {
	return wrapCairoNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCairoNode creates a GskRenderNode that will render a cairo surface into
// the area given by bounds.
//
// You can draw to the cairo surface using gsk.CairoNode.GetDrawContext().
//
// The function takes the following parameters:
//
//   - bounds: rectangle to render to.
//
// The function returns the following values:
//
//   - cairoNode: new GskRenderNode.
//
func NewCairoNode(bounds *graphene.Rect) *CairoNode {
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gsk_cairo_node_new(_arg1)
	runtime.KeepAlive(bounds)

	var _cairoNode *CairoNode // out

	_cairoNode = wrapCairoNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cairoNode
}

// DrawContext creates a Cairo context for drawing using the surface associated
// to the render node.
//
// If no surface exists yet, a surface will be created optimized for rendering
// to renderer.
//
// The function returns the following values:
//
//   - context: cairo context used for drawing; use cairo_destroy() when done
//     drawing.
//
func (node *CairoNode) DrawContext() *cairo.Context {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.cairo_t       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_cairo_node_get_draw_context(_arg0)
	runtime.KeepAlive(node)

	var _context *cairo.Context // out

	_context = cairo.WrapContext(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	return _context
}

// Surface retrieves the Cairo surface used by the render node.
//
// The function returns the following values:
//
//   - surface: cairo surface.
//
func (node *CairoNode) Surface() *cairo.Surface {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_cairo_node_get_surface(_arg0)
	runtime.KeepAlive(node)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	C.cairo_surface_reference(_cret)
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// CairoRenderer: GSK renderer that is using cairo.
//
// Since it is using cairo, this renderer cannot support 3D transformations.
type CairoRenderer struct {
	_ [0]func() // equal guard
	Renderer
}

var (
	_ Rendererer = (*CairoRenderer)(nil)
)

func wrapCairoRenderer(obj *coreglib.Object) *CairoRenderer {
	return &CairoRenderer{
		Renderer: Renderer{
			Object: obj,
		},
	}
}

func marshalCairoRenderer(p uintptr) (interface{}, error) {
	return wrapCairoRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCairoRenderer creates a new Cairo renderer.
//
// The Cairo renderer is the fallback renderer drawing in ways similar to how
// GTK 3 drew its content. Its primary use is as comparison tool.
//
// The Cairo renderer is incomplete. It cannot render 3D transformed content and
// will instead render an error marker. Its usage should be avoided.
//
// The function returns the following values:
//
//   - cairoRenderer: new Cairo renderer.
//
func NewCairoRenderer() *CairoRenderer {
	var _cret *C.GskRenderer // in

	_cret = C.gsk_cairo_renderer_new()

	var _cairoRenderer *CairoRenderer // out

	_cairoRenderer = wrapCairoRenderer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cairoRenderer
}

// ClipNode: render node applying a rectangular clip to its single child node.
type ClipNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*ClipNode)(nil)
)

func wrapClipNode(obj *coreglib.Object) *ClipNode {
	return &ClipNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalClipNode(p uintptr) (interface{}, error) {
	return wrapClipNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewClipNode creates a GskRenderNode that will clip the child to the area
// given by clip.
//
// The function takes the following parameters:
//
//   - child: node to draw.
//   - clip to apply.
//
// The function returns the following values:
//
//   - clipNode: new GskRenderNode.
//
func NewClipNode(child RenderNoder, clip *graphene.Rect) *ClipNode {
	var _arg1 *C.GskRenderNode   // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(clip)))

	_cret = C.gsk_clip_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _clipNode *ClipNode // out

	_clipNode = wrapClipNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _clipNode
}

// Child gets the child node that is getting clipped by the given node.
//
// The function returns the following values:
//
//   - renderNode: child that is getting clipped.
//
func (node *ClipNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_clip_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the clip rectangle for node.
//
// The function returns the following values:
//
//   - rect: clip rectangle.
//
func (node *ClipNode) Clip() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_clip_node_get_clip(_arg0)
	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rect
}

// ColorMatrixNode: render node controlling the color matrix of its single child
// node.
type ColorMatrixNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*ColorMatrixNode)(nil)
)

func wrapColorMatrixNode(obj *coreglib.Object) *ColorMatrixNode {
	return &ColorMatrixNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalColorMatrixNode(p uintptr) (interface{}, error) {
	return wrapColorMatrixNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewColorMatrixNode creates a GskRenderNode that will drawn the child with
// color_matrix.
//
// In particular, the node will transform the operation
//
//    pixel = color_matrix * pixel + color_offset
//
// for every pixel.
//
// The function takes the following parameters:
//
//   - child: node to draw.
//   - colorMatrix: matrix to apply.
//   - colorOffset values to add to the color.
//
// The function returns the following values:
//
//   - colorMatrixNode: new GskRenderNode.
//
func NewColorMatrixNode(child RenderNoder, colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) *ColorMatrixNode {
	var _arg1 *C.GskRenderNode     // out
	var _arg2 *C.graphene_matrix_t // out
	var _arg3 *C.graphene_vec4_t   // out
	var _cret *C.GskRenderNode     // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.graphene_matrix_t)(gextras.StructNative(unsafe.Pointer(colorMatrix)))
	_arg3 = (*C.graphene_vec4_t)(gextras.StructNative(unsafe.Pointer(colorOffset)))

	_cret = C.gsk_color_matrix_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(child)
	runtime.KeepAlive(colorMatrix)
	runtime.KeepAlive(colorOffset)

	var _colorMatrixNode *ColorMatrixNode // out

	_colorMatrixNode = wrapColorMatrixNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorMatrixNode
}

// Child gets the child node that is getting its colors modified by the given
// node.
//
// The function returns the following values:
//
//   - renderNode: child that is getting its colors modified.
//
func (node *ColorMatrixNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_color_matrix_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ColorMatrix retrieves the color matrix used by the node.
//
// The function returns the following values:
//
//   - matrix: 4x4 color matrix.
//
func (node *ColorMatrixNode) ColorMatrix() *graphene.Matrix {
	var _arg0 *C.GskRenderNode     // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_color_matrix_node_get_color_matrix(_arg0)
	runtime.KeepAlive(node)

	var _matrix *graphene.Matrix // out

	_matrix = (*graphene.Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _matrix
}

// ColorOffset retrieves the color offset used by the node.
//
// The function returns the following values:
//
//   - vec4: color vector.
//
func (node *ColorMatrixNode) ColorOffset() *graphene.Vec4 {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_color_matrix_node_get_color_offset(_arg0)
	runtime.KeepAlive(node)

	var _vec4 *graphene.Vec4 // out

	_vec4 = (*graphene.Vec4)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _vec4
}

// ColorNode: render node for a solid color.
type ColorNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*ColorNode)(nil)
)

func wrapColorNode(obj *coreglib.Object) *ColorNode {
	return &ColorNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalColorNode(p uintptr) (interface{}, error) {
	return wrapColorNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewColorNode creates a GskRenderNode that will render the color specified by
// rgba into the area given by bounds.
//
// The function takes the following parameters:
//
//   - rgba: GdkRGBA specifying a color.
//   - bounds: rectangle to render the color into.
//
// The function returns the following values:
//
//   - colorNode: new GskRenderNode.
//
func NewColorNode(rgba *gdk.RGBA, bounds *graphene.Rect) *ColorNode {
	var _arg1 *C.GdkRGBA         // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gsk_color_node_new(_arg1, _arg2)
	runtime.KeepAlive(rgba)
	runtime.KeepAlive(bounds)

	var _colorNode *ColorNode // out

	_colorNode = wrapColorNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorNode
}

// Color retrieves the color of the given node.
//
// The function returns the following values:
//
//   - rgbA: color of the node.
//
func (node *ColorNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_color_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// ConicGradientNode: render node for a conic gradient.
type ConicGradientNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*ConicGradientNode)(nil)
)

func wrapConicGradientNode(obj *coreglib.Object) *ConicGradientNode {
	return &ConicGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalConicGradientNode(p uintptr) (interface{}, error) {
	return wrapConicGradientNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewConicGradientNode creates a GskRenderNode that draws a conic gradient.
//
// The conic gradient starts around center in the direction of rotation.
// A rotation of 0 means that the gradient points up. Color stops are then added
// clockwise.
//
// The function takes the following parameters:
//
//   - bounds of the node.
//   - center of the gradient.
//   - rotation of the gradient in degrees.
//   - colorStops: pointer to an array of GskColorStop defining the gradient.
//     The offsets of all color stops must be increasing. The first stop's
//     offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//   - conicGradientNode: new GskRenderNode.
//
func NewConicGradientNode(bounds *graphene.Rect, center *graphene.Point, rotation float32, colorStops []ColorStop) *ConicGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(rotation)
	_arg5 = (C.gsize)(len(colorStops))
	_arg4 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg4), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_conic_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(rotation)
	runtime.KeepAlive(colorStops)

	var _conicGradientNode *ConicGradientNode // out

	_conicGradientNode = wrapConicGradientNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _conicGradientNode
}

// Angle retrieves the angle for the gradient in radians, normalized in [0,
// 2 * PI].
//
// The angle is starting at the top and going clockwise, as expressed in the css
// specification:
//
//    angle = 90 - gsk_conic_gradient_node_get_rotation().
//
// The function returns the following values:
//
//   - gfloat: angle for the gradient.
//
func (node *ConicGradientNode) Angle() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_conic_gradient_node_get_angle(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Center retrieves the center pointer for the gradient.
//
// The function returns the following values:
//
//   - point: center point for the gradient.
//
func (node *ConicGradientNode) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_conic_gradient_node_get_center(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// ColorStops retrieves the color stops in the gradient.
//
// The function returns the following values:
//
//   - colorStops: color stops in the gradient.
//
func (node *ConicGradientNode) ColorStops() []ColorStop {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskColorStop  // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_conic_gradient_node_get_color_stops(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _colorStops []ColorStop // out

	{
		src := unsafe.Slice((*C.GskColorStop)(_cret), _arg1)
		_colorStops = make([]ColorStop, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_colorStops[i] = *(*ColorStop)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _colorStops
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//   - gsize: number of color stops.
//
func (node *ConicGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_conic_gradient_node_get_n_color_stops(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Rotation retrieves the rotation for the gradient in degrees.
//
// The function returns the following values:
//
//   - gfloat: rotation for the gradient.
//
func (node *ConicGradientNode) Rotation() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_conic_gradient_node_get_rotation(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ContainerNode: render node that can contain other render nodes.
type ContainerNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*ContainerNode)(nil)
)

func wrapContainerNode(obj *coreglib.Object) *ContainerNode {
	return &ContainerNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalContainerNode(p uintptr) (interface{}, error) {
	return wrapContainerNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewContainerNode creates a new GskRenderNode instance for holding the given
// children.
//
// The new node will acquire a reference to each of the children.
//
// The function takes the following parameters:
//
//   - children of the node.
//
// The function returns the following values:
//
//   - containerNode: new GskRenderNode.
//
func NewContainerNode(children []RenderNoder) *ContainerNode {
	var _arg1 **C.GskRenderNode // out
	var _arg2 C.guint
	var _cret *C.GskRenderNode // in

	_arg2 = (C.guint)(len(children))
	_arg1 = (**C.GskRenderNode)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GskRenderNode)(_arg1), len(children))
		for i := range children {
			out[i] = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(children[i]).Native()))
		}
	}

	_cret = C.gsk_container_node_new(_arg1, _arg2)
	runtime.KeepAlive(children)

	var _containerNode *ContainerNode // out

	_containerNode = wrapContainerNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _containerNode
}

// Child gets one of the children of container.
//
// The function takes the following parameters:
//
//   - idx: position of the child to get.
//
// The function returns the following values:
//
//   - renderNode: idx'th child of container.
//
func (node *ContainerNode) Child(idx uint) RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_container_node_get_child(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren retrieves the number of direct children of node.
//
// The function returns the following values:
//
//   - guint: number of children of the GskRenderNode.
//
func (node *ContainerNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_container_node_get_n_children(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CrossFadeNode: render node cross fading between two child nodes.
type CrossFadeNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*CrossFadeNode)(nil)
)

func wrapCrossFadeNode(obj *coreglib.Object) *CrossFadeNode {
	return &CrossFadeNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalCrossFadeNode(p uintptr) (interface{}, error) {
	return wrapCrossFadeNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCrossFadeNode creates a GskRenderNode that will do a cross-fade between
// start and end.
//
// The function takes the following parameters:
//
//   - start node to be drawn.
//   - end: node to be cross_fadeed onto the start node.
//   - progress: how far the fade has progressed from start to end. The value
//     will be clamped to the range [0 ... 1].
//
// The function returns the following values:
//
//   - crossFadeNode: new GskRenderNode.
//
func NewCrossFadeNode(start, end RenderNoder, progress float32) *CrossFadeNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(start).Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(end).Native()))
	_arg3 = C.float(progress)

	_cret = C.gsk_cross_fade_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(progress)

	var _crossFadeNode *CrossFadeNode // out

	_crossFadeNode = wrapCrossFadeNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _crossFadeNode
}

// EndChild retrieves the child GskRenderNode at the end of the cross-fade.
//
// The function returns the following values:
//
//   - renderNode: GskRenderNode.
//
func (node *CrossFadeNode) EndChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_cross_fade_node_get_end_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Progress retrieves the progress value of the cross fade.
//
// The function returns the following values:
//
//   - gfloat progress value, between 0 and 1.
//
func (node *CrossFadeNode) Progress() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_cross_fade_node_get_progress(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// StartChild retrieves the child GskRenderNode at the beginning of the
// cross-fade.
//
// The function returns the following values:
//
//   - renderNode: GskRenderNode.
//
func (node *CrossFadeNode) StartChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_cross_fade_node_get_start_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// DebugNode: render node that emits a debugging message when drawing its child
// node.
type DebugNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*DebugNode)(nil)
)

func wrapDebugNode(obj *coreglib.Object) *DebugNode {
	return &DebugNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalDebugNode(p uintptr) (interface{}, error) {
	return wrapDebugNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDebugNode creates a GskRenderNode that will add debug information about
// the given child.
//
// Adding this node has no visual effect.
//
// The function takes the following parameters:
//
//   - child to add debug info for.
//   - message: debug message.
//
// The function returns the following values:
//
//   - debugNode: new GskRenderNode.
//
func NewDebugNode(child RenderNoder, message string) *DebugNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.char          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(message)))

	_cret = C.gsk_debug_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(message)

	var _debugNode *DebugNode // out

	_debugNode = wrapDebugNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _debugNode
}

// Child gets the child node that is getting drawn by the given node.
//
// The function returns the following values:
//
//   - renderNode: child GskRenderNode.
//
func (node *DebugNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_debug_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Message gets the debug message that was set on this node.
//
// The function returns the following values:
//
//   - utf8: debug message.
//
func (node *DebugNode) Message() string {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.char          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_debug_node_get_message(_arg0)
	runtime.KeepAlive(node)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GLShaderOverrides contains methods that are overridable.
type GLShaderOverrides struct {
}

func defaultGLShaderOverrides(v *GLShader) GLShaderOverrides {
	return GLShaderOverrides{}
}

// GLShader: GskGLShader is a snippet of GLSL that is meant to run in the
// fragment shader of the rendering pipeline.
//
// A fragment shader gets the coordinates being rendered as input and produces
// the pixel values for that particular pixel. Additionally, the shader can
// declare a set of other input arguments, called uniforms (as they are uniform
// over all the calls to your shader in each instance of use). A shader can also
// receive up to 4 textures that it can use as input when producing the pixel
// data.
//
// GskGLShader is usually used with gtk_snapshot_push_gl_shader() to produce a
// gsk.GLShaderNode in the rendering hierarchy, and then its input textures are
// constructed by rendering the child nodes to textures before rendering the
// shader node itself. (You can pass texture nodes as children if you want to
// directly use a texture as input).
//
// The actual shader code is GLSL code that gets combined with some other code
// into the fragment shader. Since the exact capabilities of the GPU driver
// differs between different OpenGL drivers and hardware, GTK adds some defines
// that you can use to ensure your GLSL code runs on as many drivers as it can.
//
// If the OpenGL driver is GLES, then the shader language version is set to 100,
// and GSK_GLES will be defined in the shader.
//
// Otherwise, if the OpenGL driver does not support the 3.2 core profile,
// then the shader will run with language version 110 for GL2 and 130 for GL3,
// and GSK_LEGACY will be defined in the shader.
//
// If the OpenGL driver supports the 3.2 code profile, it will be used,
// the shader language version is set to 150, and GSK_GL3 will be defined in the
// shader.
//
// The main function the shader must implement is:
//
//    void mainImage(out vec4 fragColor,
//                   in vec2 fragCoord,
//                   in vec2 resolution,
//                   in vec2 uv)
//
// Where the input fragCoord is the coordinate of the pixel we're currently
// rendering, relative to the boundary rectangle that was specified in the
// GskGLShaderNode, and resolution is the width and height of that rectangle.
// This is in the typical GTK coordinate system with the origin in the top left.
// uv contains the u and v coordinates that can be used to index a texture at
// the corresponding point. These coordinates are in the [0..1]x[0..1] region,
// with 0, 0 being in the lower left corder (which is typical for OpenGL).
//
// The output fragColor should be a RGBA color (with premultiplied alpha) that
// will be used as the output for the specified pixel location. Note that this
// output will be automatically clipped to the clip region of the glshader node.
//
// In addition to the function arguments the shader can define up to 4 uniforms
// for textures which must be called u_textureN (i.e. u_texture1 to u_texture4)
// as well as any custom uniforms you want of types int, uint, bool, float,
// vec2, vec3 or vec4.
//
// All textures sources contain premultiplied alpha colors, but if some there
// are outer sources of colors there is a gsk_premultiply() helper to compute
// premultiplication when needed.
//
// Note that GTK parses the uniform declarations, so each uniform has to be on a
// line by itself with no other code, like so:
//
//    uniform float u_time;
//    uniform vec3 u_color;
//    uniform sampler2D u_texture1;
//    uniform sampler2D u_texture2;
//
// GTK uses the the "gsk" namespace in the symbols it uses in the shader,
// so your code should not use any symbols with the prefix gsk or GSK. There are
// some helper functions declared that you can use:
//
//    vec4 GskTexture(sampler2D sampler, vec2 texCoords);
//
// This samples a texture (e.g. u_texture1) at the specified coordinates, and
// containes some helper ifdefs to ensure that it works on all OpenGL versions.
//
// You can compile the shader yourself using gsk.GLShader.Compile(), otherwise
// the GSK renderer will do it when it handling the glshader node. If errors
// occurs, the returned error will include the glsl sources, so you can see
// what GSK was passing to the compiler. You can also set GSK_DEBUG=shaders in
// the environment to see the sources and other relevant information about all
// shaders that GSK is handling.
//
// An example shader
//
//    uniform float position;
//    uniform sampler2D u_texture1;
//    uniform sampler2D u_texture2;
//
//    void mainImage(out vec4 fragColor,
//                   in vec2 fragCoord,
//                   in vec2 resolution,
//                   in vec2 uv) {
//      vec4 source1 = GskTexture(u_texture1, uv);
//      vec4 source2 = GskTexture(u_texture2, uv);
//
//      fragColor = position * source1 + (1.0 - position) * source2;
//    }.
type GLShader struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*GLShader)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLShader, *GLShaderClass, GLShaderOverrides](
		GTypeGLShader,
		initGLShaderClass,
		wrapGLShader,
		defaultGLShaderOverrides,
	)
}

func initGLShaderClass(gclass unsafe.Pointer, overrides GLShaderOverrides, classInitFunc func(*GLShaderClass)) {
	if classInitFunc != nil {
		class := (*GLShaderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLShader(obj *coreglib.Object) *GLShader {
	return &GLShader{
		Object: obj,
	}
}

func marshalGLShader(p uintptr) (interface{}, error) {
	return wrapGLShader(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGLShaderFromBytes creates a GskGLShader that will render pixels using the
// specified code.
//
// The function takes the following parameters:
//
//   - sourcecode: GLSL sourcecode for the shader, as a GBytes.
//
// The function returns the following values:
//
//   - glShader: new GskGLShader.
//
func NewGLShaderFromBytes(sourcecode *glib.Bytes) *GLShader {
	var _arg1 *C.GBytes      // out
	var _cret *C.GskGLShader // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(sourcecode)))

	_cret = C.gsk_gl_shader_new_from_bytes(_arg1)
	runtime.KeepAlive(sourcecode)

	var _glShader *GLShader // out

	_glShader = wrapGLShader(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glShader
}

// NewGLShaderFromResource creates a GskGLShader that will render pixels using
// the specified code.
//
// The function takes the following parameters:
//
//   - resourcePath: path to a resource that contains the GLSL sourcecode for
//     the shader.
//
// The function returns the following values:
//
//   - glShader: new GskGLShader.
//
func NewGLShaderFromResource(resourcePath string) *GLShader {
	var _arg1 *C.char        // out
	var _cret *C.GskGLShader // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gsk_gl_shader_new_from_resource(_arg1)
	runtime.KeepAlive(resourcePath)

	var _glShader *GLShader // out

	_glShader = wrapGLShader(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glShader
}

// Compile tries to compile the shader for the given renderer.
//
// If there is a problem, this function returns FALSE and reports an error.
// You should use this function before relying on the shader for rendering and
// use a fallback with a simpler shader or without shaders if it fails.
//
// Note that this will modify the rendering state (for example change the
// current GL context) and requires the renderer to be set up. This means
// that the widget has to be realized. Commonly you want to call this from the
// realize signal of a widget, or during widget snapshot.
//
// The function takes the following parameters:
//
//   - renderer: GskRenderer.
//
func (shader *GLShader) Compile(renderer Rendererer) error {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.GskRenderer // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GskRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.gsk_gl_shader_compile(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(renderer)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// FindUniformByName looks for a uniform by the name name, and returns the index
// of the uniform, or -1 if it was not found.
//
// The function takes the following parameters:
//
//   - name: uniform name.
//
// The function returns the following values:
//
//   - gint: index of the uniform, or -1.
//
func (shader *GLShader) FindUniformByName(name string) int {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.char        // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gsk_gl_shader_find_uniform_by_name(_arg0, _arg1)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ArgBool gets the value of the uniform idx in the args block.
//
// The uniform must be of bool type.
//
// The function takes the following parameters:
//
//   - args: uniform arguments.
//   - idx: index of the uniform.
//
// The function returns the following values:
//
//   - ok: value.
//
func (shader *GLShader) ArgBool(args *glib.Bytes, idx int) bool {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.GBytes      // out
	var _arg2 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg2 = C.int(idx)

	_cret = C.gsk_gl_shader_get_arg_bool(_arg0, _arg1, _arg2)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(args)
	runtime.KeepAlive(idx)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ArgFloat gets the value of the uniform idx in the args block.
//
// The uniform must be of float type.
//
// The function takes the following parameters:
//
//   - args: uniform arguments.
//   - idx: index of the uniform.
//
// The function returns the following values:
//
//   - gfloat: value.
//
func (shader *GLShader) ArgFloat(args *glib.Bytes, idx int) float32 {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.GBytes      // out
	var _arg2 C.int          // out
	var _cret C.float        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg2 = C.int(idx)

	_cret = C.gsk_gl_shader_get_arg_float(_arg0, _arg1, _arg2)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(args)
	runtime.KeepAlive(idx)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ArgInt gets the value of the uniform idx in the args block.
//
// The uniform must be of int type.
//
// The function takes the following parameters:
//
//   - args: uniform arguments.
//   - idx: index of the uniform.
//
// The function returns the following values:
//
//   - gint32: value.
//
func (shader *GLShader) ArgInt(args *glib.Bytes, idx int) int32 {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.GBytes      // out
	var _arg2 C.int          // out
	var _cret C.gint32       // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg2 = C.int(idx)

	_cret = C.gsk_gl_shader_get_arg_int(_arg0, _arg1, _arg2)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(args)
	runtime.KeepAlive(idx)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// ArgUint gets the value of the uniform idx in the args block.
//
// The uniform must be of uint type.
//
// The function takes the following parameters:
//
//   - args: uniform arguments.
//   - idx: index of the uniform.
//
// The function returns the following values:
//
//   - guint32: value.
//
func (shader *GLShader) ArgUint(args *glib.Bytes, idx int) uint32 {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.GBytes      // out
	var _arg2 C.int          // out
	var _cret C.guint32      // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg2 = C.int(idx)

	_cret = C.gsk_gl_shader_get_arg_uint(_arg0, _arg1, _arg2)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(args)
	runtime.KeepAlive(idx)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// ArgVec2 gets the value of the uniform idx in the args block.
//
// The uniform must be of vec2 type.
//
// The function takes the following parameters:
//
//   - args: uniform arguments.
//   - idx: index of the uniform.
//   - outValue: location to store the uniform value in.
//
func (shader *GLShader) ArgVec2(args *glib.Bytes, idx int, outValue *graphene.Vec2) {
	var _arg0 *C.GskGLShader     // out
	var _arg1 *C.GBytes          // out
	var _arg2 C.int              // out
	var _arg3 *C.graphene_vec2_t // out

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg2 = C.int(idx)
	_arg3 = (*C.graphene_vec2_t)(gextras.StructNative(unsafe.Pointer(outValue)))

	C.gsk_gl_shader_get_arg_vec2(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(args)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(outValue)
}

// ArgVec3 gets the value of the uniform idx in the args block.
//
// The uniform must be of vec3 type.
//
// The function takes the following parameters:
//
//   - args: uniform arguments.
//   - idx: index of the uniform.
//   - outValue: location to store the uniform value in.
//
func (shader *GLShader) ArgVec3(args *glib.Bytes, idx int, outValue *graphene.Vec3) {
	var _arg0 *C.GskGLShader     // out
	var _arg1 *C.GBytes          // out
	var _arg2 C.int              // out
	var _arg3 *C.graphene_vec3_t // out

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg2 = C.int(idx)
	_arg3 = (*C.graphene_vec3_t)(gextras.StructNative(unsafe.Pointer(outValue)))

	C.gsk_gl_shader_get_arg_vec3(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(args)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(outValue)
}

// ArgVec4 gets the value of the uniform idx in the args block.
//
// The uniform must be of vec4 type.
//
// The function takes the following parameters:
//
//   - args: uniform arguments.
//   - idx: index of the uniform.
//   - outValue: location to store set the uniform value in.
//
func (shader *GLShader) ArgVec4(args *glib.Bytes, idx int, outValue *graphene.Vec4) {
	var _arg0 *C.GskGLShader     // out
	var _arg1 *C.GBytes          // out
	var _arg2 C.int              // out
	var _arg3 *C.graphene_vec4_t // out

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg2 = C.int(idx)
	_arg3 = (*C.graphene_vec4_t)(gextras.StructNative(unsafe.Pointer(outValue)))

	C.gsk_gl_shader_get_arg_vec4(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(args)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(outValue)
}

// ArgsSize: get the size of the data block used to specify arguments for this
// shader.
//
// The function returns the following values:
//
//   - gsize: size of the data block.
//
func (shader *GLShader) ArgsSize() uint {
	var _arg0 *C.GskGLShader // out
	var _cret C.gsize        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	_cret = C.gsk_gl_shader_get_args_size(_arg0)
	runtime.KeepAlive(shader)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// NTextures returns the number of textures that the shader requires.
//
// This can be used to check that the a passed shader works in your usecase.
// It is determined by looking at the highest u_textureN value that the shader
// defines.
//
// The function returns the following values:
//
//   - gint: number of texture inputs required by shader.
//
func (shader *GLShader) NTextures() int {
	var _arg0 *C.GskGLShader // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	_cret = C.gsk_gl_shader_get_n_textures(_arg0)
	runtime.KeepAlive(shader)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NUniforms: get the number of declared uniforms for this shader.
//
// The function returns the following values:
//
//   - gint: number of declared uniforms.
//
func (shader *GLShader) NUniforms() int {
	var _arg0 *C.GskGLShader // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	_cret = C.gsk_gl_shader_get_n_uniforms(_arg0)
	runtime.KeepAlive(shader)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Resource gets the resource path for the GLSL sourcecode being used to render
// this shader.
//
// The function returns the following values:
//
//   - utf8: resource path for the shader, or NULL if none.
//
func (shader *GLShader) Resource() string {
	var _arg0 *C.GskGLShader // out
	var _cret *C.char        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	_cret = C.gsk_gl_shader_get_resource(_arg0)
	runtime.KeepAlive(shader)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Source gets the GLSL sourcecode being used to render this shader.
//
// The function returns the following values:
//
//   - bytes: source code for the shader.
//
func (shader *GLShader) Source() *glib.Bytes {
	var _arg0 *C.GskGLShader // out
	var _cret *C.GBytes      // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	_cret = C.gsk_gl_shader_get_source(_arg0)
	runtime.KeepAlive(shader)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_bytes_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// UniformName: get the name of the declared uniform for this shader at index
// idx.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//
// The function returns the following values:
//
//   - utf8: name of the declared uniform.
//
func (shader *GLShader) UniformName(idx int) string {
	var _arg0 *C.GskGLShader // out
	var _arg1 C.int          // out
	var _cret *C.char        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = C.int(idx)

	_cret = C.gsk_gl_shader_get_uniform_name(_arg0, _arg1)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(idx)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UniformOffset: get the offset into the data block where data for this
// uniforms is stored.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//
// The function returns the following values:
//
//   - gint: data offset.
//
func (shader *GLShader) UniformOffset(idx int) int {
	var _arg0 *C.GskGLShader // out
	var _arg1 C.int          // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = C.int(idx)

	_cret = C.gsk_gl_shader_get_uniform_offset(_arg0, _arg1)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(idx)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UniformType: get the type of the declared uniform for this shader at index
// idx.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//
// The function returns the following values:
//
//   - glUniformType: type of the declared uniform.
//
func (shader *GLShader) UniformType(idx int) GLUniformType {
	var _arg0 *C.GskGLShader     // out
	var _arg1 C.int              // out
	var _cret C.GskGLUniformType // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = C.int(idx)

	_cret = C.gsk_gl_shader_get_uniform_type(_arg0, _arg1)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(idx)

	var _glUniformType GLUniformType // out

	_glUniformType = GLUniformType(_cret)

	return _glUniformType
}

// GLShaderNode: render node using a GL shader when drawing its children nodes.
type GLShaderNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*GLShaderNode)(nil)
)

func wrapGLShaderNode(obj *coreglib.Object) *GLShaderNode {
	return &GLShaderNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalGLShaderNode(p uintptr) (interface{}, error) {
	return wrapGLShaderNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGLShaderNode creates a GskRenderNode that will render the given shader
// into the area given by bounds.
//
// The args is a block of data to use for uniform input, as per types
// and offsets defined by the shader. Normally this is generated by
// gsk.GLShader.FormatArgs() or gsk.ShaderArgsBuilder.
//
// See gsk.GLShader for details about how the shader should be written.
//
// All the children will be rendered into textures (if they aren't already
// GskTextureNodes, which will be used directly). These textures will be sent as
// input to the shader.
//
// If the renderer doesn't support GL shaders, or if there is any problem
// when compiling the shader, then the node will draw pink. You should use
// gsk.GLShader.Compile() to ensure the shader will work for the renderer before
// using it.
//
// The function takes the following parameters:
//
//   - shader: GLShader.
//   - bounds: rectangle to render the shader into.
//   - args arguments for the uniforms.
//   - children: array of child nodes, these will be rendered to textures and
//     used as input.
//
// The function returns the following values:
//
//   - glShaderNode: new GskRenderNode.
//
func NewGLShaderNode(shader *GLShader, bounds *graphene.Rect, args *glib.Bytes, children []RenderNoder) *GLShaderNode {
	var _arg1 *C.GskGLShader     // out
	var _arg2 *C.graphene_rect_t // out
	var _arg3 *C.GBytes          // out
	var _arg4 **C.GskRenderNode  // out
	var _arg5 C.guint
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg3 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg5 = (C.guint)(len(children))
	_arg4 = (**C.GskRenderNode)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((**C.GskRenderNode)(_arg4), len(children))
		for i := range children {
			out[i] = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(children[i]).Native()))
		}
	}

	_cret = C.gsk_gl_shader_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(args)
	runtime.KeepAlive(children)

	var _glShaderNode *GLShaderNode // out

	_glShaderNode = wrapGLShaderNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glShaderNode
}

// Args gets args for the node.
//
// The function returns the following values:
//
//   - bytes with the uniform arguments.
//
func (node *GLShaderNode) Args() *glib.Bytes {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GBytes        // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_gl_shader_node_get_args(_arg0)
	runtime.KeepAlive(node)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_bytes_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Child gets one of the children.
//
// The function takes the following parameters:
//
//   - idx: position of the child to get.
//
// The function returns the following values:
//
//   - renderNode: idx'th child of node.
//
func (node *GLShaderNode) Child(idx uint) RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_gl_shader_node_get_child(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren returns the number of children.
//
// The function returns the following values:
//
//   - guint: number of children.
//
func (node *GLShaderNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_gl_shader_node_get_n_children(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Shader gets shader code for the node.
//
// The function returns the following values:
//
//   - glShader: GLShader shader.
//
func (node *GLShaderNode) Shader() *GLShader {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskGLShader   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_gl_shader_node_get_shader(_arg0)
	runtime.KeepAlive(node)

	var _glShader *GLShader // out

	_glShader = wrapGLShader(coreglib.Take(unsafe.Pointer(_cret)))

	return _glShader
}

// InsetShadowNode: render node for an inset shadow.
type InsetShadowNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*InsetShadowNode)(nil)
)

func wrapInsetShadowNode(obj *coreglib.Object) *InsetShadowNode {
	return &InsetShadowNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalInsetShadowNode(p uintptr) (interface{}, error) {
	return wrapInsetShadowNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewInsetShadowNode creates a GskRenderNode that will render an inset shadow
// into the box given by outline.
//
// The function takes the following parameters:
//
//   - outline of the region containing the shadow.
//   - color of the shadow.
//   - dx: horizontal offset of shadow.
//   - dy: vertical offset of shadow.
//   - spread: how far the shadow spreads towards the inside.
//   - blurRadius: how much blur to apply to the shadow.
//
// The function returns the following values:
//
//   - insetShadowNode: new GskRenderNode.
//
func NewInsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) *InsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_inset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _insetShadowNode *InsetShadowNode // out

	_insetShadowNode = wrapInsetShadowNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _insetShadowNode
}

// BlurRadius retrieves the blur radius to apply to the shadow.
//
// The function returns the following values:
//
//   - gfloat: blur radius, in pixels.
//
func (node *InsetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_inset_shadow_node_get_blur_radius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the inset shadow.
//
// The function returns the following values:
//
//   - rgbA: color of the shadow.
//
func (node *InsetShadowNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_inset_shadow_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Dx retrieves the horizontal offset of the inset shadow.
//
// The function returns the following values:
//
//   - gfloat: offset, in pixels.
//
func (node *InsetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_inset_shadow_node_get_dx(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the inset shadow.
//
// The function returns the following values:
//
//   - gfloat: offset, in pixels.
//
func (node *InsetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_inset_shadow_node_get_dy(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the inset shadow.
//
// The function returns the following values:
//
//   - roundedRect: rounded rectangle.
//
func (node *InsetShadowNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_inset_shadow_node_get_outline(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads inwards.
//
// The function returns the following values:
//
//   - gfloat: size of the shadow, in pixels.
//
func (node *InsetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_inset_shadow_node_get_spread(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// LinearGradientNode: render node for a linear gradient.
type LinearGradientNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*LinearGradientNode)(nil)
)

func wrapLinearGradientNode(obj *coreglib.Object) *LinearGradientNode {
	return &LinearGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalLinearGradientNode(p uintptr) (interface{}, error) {
	return wrapLinearGradientNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewLinearGradientNode creates a GskRenderNode that will create a linear
// gradient from the given points and color stops, and render that into the area
// given by bounds.
//
// The function takes the following parameters:
//
//   - bounds: rectangle to render the linear gradient into.
//   - start: point at which the linear gradient will begin.
//   - end: point at which the linear gradient will finish.
//   - colorStops: pointer to an array of GskColorStop defining the gradient.
//     The offsets of all color stops must be increasing. The first stop's
//     offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//   - linearGradientNode: new GskRenderNode.
//
func NewLinearGradientNode(bounds *graphene.Rect, start, end *graphene.Point, colorStops []ColorStop) *LinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(end)))
	_arg5 = (C.gsize)(len(colorStops))
	_arg4 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg4), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _linearGradientNode *LinearGradientNode // out

	_linearGradientNode = wrapLinearGradientNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _linearGradientNode
}

// ColorStops retrieves the color stops in the gradient.
//
// The function returns the following values:
//
//   - colorStops: color stops in the gradient.
//
func (node *LinearGradientNode) ColorStops() []ColorStop {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskColorStop  // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_linear_gradient_node_get_color_stops(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _colorStops []ColorStop // out

	{
		src := unsafe.Slice((*C.GskColorStop)(_cret), _arg1)
		_colorStops = make([]ColorStop, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_colorStops[i] = *(*ColorStop)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _colorStops
}

// End retrieves the final point of the linear gradient.
//
// The function returns the following values:
//
//   - point: final point.
//
func (node *LinearGradientNode) End() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_linear_gradient_node_get_end(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//   - gsize: number of color stops.
//
func (node *LinearGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_linear_gradient_node_get_n_color_stops(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the initial point of the linear gradient.
//
// The function returns the following values:
//
//   - point: initial point.
//
func (node *LinearGradientNode) Start() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_linear_gradient_node_get_start(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// OpacityNode: render node controlling the opacity of its single child node.
type OpacityNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*OpacityNode)(nil)
)

func wrapOpacityNode(obj *coreglib.Object) *OpacityNode {
	return &OpacityNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalOpacityNode(p uintptr) (interface{}, error) {
	return wrapOpacityNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewOpacityNode creates a GskRenderNode that will drawn the child with reduced
// opacity.
//
// The function takes the following parameters:
//
//   - child: node to draw.
//   - opacity to apply.
//
// The function returns the following values:
//
//   - opacityNode: new GskRenderNode.
//
func NewOpacityNode(child RenderNoder, opacity float32) *OpacityNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.float(opacity)

	_cret = C.gsk_opacity_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(opacity)

	var _opacityNode *OpacityNode // out

	_opacityNode = wrapOpacityNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _opacityNode
}

// Child gets the child node that is getting opacityed by the given node.
//
// The function returns the following values:
//
//   - renderNode: child that is getting opacityed.
//
func (node *OpacityNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_opacity_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Opacity gets the transparency factor for an opacity node.
//
// The function returns the following values:
//
//   - gfloat: opacity factor.
//
func (node *OpacityNode) Opacity() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_opacity_node_get_opacity(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// OutsetShadowNode: render node for an outset shadow.
type OutsetShadowNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*OutsetShadowNode)(nil)
)

func wrapOutsetShadowNode(obj *coreglib.Object) *OutsetShadowNode {
	return &OutsetShadowNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalOutsetShadowNode(p uintptr) (interface{}, error) {
	return wrapOutsetShadowNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewOutsetShadowNode creates a GskRenderNode that will render an outset shadow
// around the box given by outline.
//
// The function takes the following parameters:
//
//   - outline of the region surrounded by shadow.
//   - color of the shadow.
//   - dx: horizontal offset of shadow.
//   - dy: vertical offset of shadow.
//   - spread: how far the shadow spreads towards the inside.
//   - blurRadius: how much blur to apply to the shadow.
//
// The function returns the following values:
//
//   - outsetShadowNode: new GskRenderNode.
//
func NewOutsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) *OutsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_outset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _outsetShadowNode *OutsetShadowNode // out

	_outsetShadowNode = wrapOutsetShadowNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _outsetShadowNode
}

// BlurRadius retrieves the blur radius of the shadow.
//
// The function returns the following values:
//
//   - gfloat: blur radius, in pixels.
//
func (node *OutsetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_outset_shadow_node_get_blur_radius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the outset shadow.
//
// The function returns the following values:
//
//   - rgbA: color.
//
func (node *OutsetShadowNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_outset_shadow_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Dx retrieves the horizontal offset of the outset shadow.
//
// The function returns the following values:
//
//   - gfloat: offset, in pixels.
//
func (node *OutsetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_outset_shadow_node_get_dx(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the outset shadow.
//
// The function returns the following values:
//
//   - gfloat: offset, in pixels.
//
func (node *OutsetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_outset_shadow_node_get_dy(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the outset shadow.
//
// The function returns the following values:
//
//   - roundedRect: rounded rectangle.
//
func (node *OutsetShadowNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_outset_shadow_node_get_outline(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads outwards.
//
// The function returns the following values:
//
//   - gfloat: size of the shadow, in pixels.
//
func (node *OutsetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_outset_shadow_node_get_spread(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RadialGradientNode: render node for a radial gradient.
type RadialGradientNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*RadialGradientNode)(nil)
)

func wrapRadialGradientNode(obj *coreglib.Object) *RadialGradientNode {
	return &RadialGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRadialGradientNode(p uintptr) (interface{}, error) {
	return wrapRadialGradientNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewRadialGradientNode creates a GskRenderNode that draws a radial gradient.
//
// The radial gradient starts around center. The size of the gradient is
// dictated by hradius in horizontal orientation and by vradius in vertial
// orientation.
//
// The function takes the following parameters:
//
//   - bounds of the node.
//   - center of the gradient.
//   - hradius: horizontal radius.
//   - vradius: vertical radius.
//   - start: percentage >= 0 that defines the start of the gradient around
//     center.
//   - end: percentage >= 0 that defines the end of the gradient around center.
//   - colorStops: pointer to an array of GskColorStop defining the gradient.
//     The offsets of all color stops must be increasing. The first stop's
//     offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//   - radialGradientNode: new GskRenderNode.
//
func NewRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius, vradius, start, end float32, colorStops []ColorStop) *RadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop     // out
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = (C.gsize)(len(colorStops))
	_arg7 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg7))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg7), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(hradius)
	runtime.KeepAlive(vradius)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _radialGradientNode *RadialGradientNode // out

	_radialGradientNode = wrapRadialGradientNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _radialGradientNode
}

// Center retrieves the center pointer for the gradient.
//
// The function returns the following values:
//
//   - point: center point for the gradient.
//
func (node *RadialGradientNode) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_radial_gradient_node_get_center(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// ColorStops retrieves the color stops in the gradient.
//
// The function returns the following values:
//
//   - colorStops: color stops in the gradient.
//
func (node *RadialGradientNode) ColorStops() []ColorStop {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskColorStop  // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_radial_gradient_node_get_color_stops(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _colorStops []ColorStop // out

	{
		src := unsafe.Slice((*C.GskColorStop)(_cret), _arg1)
		_colorStops = make([]ColorStop, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_colorStops[i] = *(*ColorStop)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _colorStops
}

// End retrieves the end value for the gradient.
//
// The function returns the following values:
//
//   - gfloat: end value for the gradient.
//
func (node *RadialGradientNode) End() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_radial_gradient_node_get_end(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Hradius retrieves the horizonal radius for the gradient.
//
// The function returns the following values:
//
//   - gfloat: horizontal radius for the gradient.
//
func (node *RadialGradientNode) Hradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_radial_gradient_node_get_hradius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//   - gsize: number of color stops.
//
func (node *RadialGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_radial_gradient_node_get_n_color_stops(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the start value for the gradient.
//
// The function returns the following values:
//
//   - gfloat: start value for the gradient.
//
func (node *RadialGradientNode) Start() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_radial_gradient_node_get_start(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Vradius retrieves the vertical radius for the gradient.
//
// The function returns the following values:
//
//   - gfloat: vertical radius for the gradient.
//
func (node *RadialGradientNode) Vradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_radial_gradient_node_get_vradius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RenderNode: GskRenderNode is the basic block in a scene graph to be rendered
// using GskRenderer.
//
// Each node has a parent, except the top-level node; each node may have
// children nodes.
//
// Each node has an associated drawing surface, which has the size of the
// rectangle set when creating it.
//
// Render nodes are meant to be transient; once they have been associated to
// a gsk.Renderer it's safe to release any reference you have on them. All
// gsk.RenderNodes are immutable, you can only specify their properties during
// construction.
type RenderNode struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*RenderNode)(nil)
)

// RenderNoder describes types inherited from class RenderNode.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RenderNoder interface {
	coreglib.Objector
	baseRenderNode() *RenderNode
}

var _ RenderNoder = (*RenderNode)(nil)

func wrapRenderNode(obj *coreglib.Object) *RenderNode {
	return &RenderNode{
		Object: obj,
	}
}

func marshalRenderNode(p uintptr) (interface{}, error) {
	return wrapRenderNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (node *RenderNode) baseRenderNode() *RenderNode {
	return node
}

// BaseRenderNode returns the underlying base object.
func BaseRenderNode(obj RenderNoder) *RenderNode {
	return obj.baseRenderNode()
}

// Draw the contents of node to the given cairo context.
//
// Typically, you'll use this function to implement fallback rendering of
// GskRenderNodes on an intermediate Cairo context, instead of using the drawing
// context associated to a GdkSurface's rendering buffer.
//
// For advanced nodes that cannot be supported using Cairo, in particular for
// nodes doing 3D operations, this function may fail.
//
// The function takes the following parameters:
//
//   - cr: cairo context to draw to.
//
func (node *RenderNode) Draw(cr *cairo.Context) {
	var _arg0 *C.GskRenderNode // out
	var _arg1 *C.cairo_t       // out

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	C.gsk_render_node_draw(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(cr)
}

// Bounds retrieves the boundaries of the node.
//
// The node will not draw outside of its boundaries.
//
// The function returns the following values:
//
//   - bounds: return location for the boundaries.
//
func (node *RenderNode) Bounds() *graphene.Rect {
	var _arg0 *C.GskRenderNode  // out
	var _arg1 C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	C.gsk_render_node_get_bounds(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _bounds *graphene.Rect // out

	_bounds = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _bounds
}

// NodeType returns the type of the node.
//
// The function returns the following values:
//
//   - renderNodeType: type of the GskRenderNode.
//
func (node *RenderNode) NodeType() RenderNodeType {
	var _arg0 *C.GskRenderNode    // out
	var _cret C.GskRenderNodeType // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_render_node_get_node_type(_arg0)
	runtime.KeepAlive(node)

	var _renderNodeType RenderNodeType // out

	_renderNodeType = RenderNodeType(_cret)

	return _renderNodeType
}

// Serialize serializes the node for later deserialization via
// gsk_render_node_deserialize(). No guarantees are made about the
// format used other than that the same version of GTK will be able to
// deserialize the result of a call to gsk_render_node_serialize() and
// gsk_render_node_deserialize() will correctly reject files it cannot open that
// were created with previous versions of GTK.
//
// The intended use of this functions is testing, benchmarking and debugging.
// The format is not meant as a permanent storage format.
//
// The function returns the following values:
//
//   - bytes representing the node.
//
func (node *RenderNode) Serialize() *glib.Bytes {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GBytes        // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_render_node_serialize(_arg0)
	runtime.KeepAlive(node)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// WriteToFile: this function is equivalent to calling
// gsk_render_node_serialize() followed by g_file_set_contents().
//
// See those two functions for details on the arguments.
//
// It is mostly intended for use inside a debugger to quickly dump a render node
// to a file for later inspection.
//
// The function takes the following parameters:
//
//   - filename: file to save it to.
//
func (node *RenderNode) WriteToFile(filename string) error {
	var _arg0 *C.GskRenderNode // out
	var _arg1 *C.char          // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gsk_render_node_write_to_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(node)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RenderNodeDeserialize loads data previously created via
// gsk_render_node_serialize().
//
// For a discussion of the supported format, see that function.
//
// The function takes the following parameters:
//
//   - bytes containing the data.
//   - errorFunc (optional): callback on parsing errors or NULL.
//
// The function returns the following values:
//
//   - renderNode (optional): new GskRenderNode or NULL on error.
//
func RenderNodeDeserialize(bytes *glib.Bytes, errorFunc ParseErrorFunc) RenderNoder {
	var _arg1 *C.GBytes           // out
	var _arg2 C.GskParseErrorFunc // out
	var _arg3 C.gpointer
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	if errorFunc != nil {
		_arg2 = (*[0]byte)(C._gotk4_gsk4_ParseErrorFunc)
		_arg3 = C.gpointer(gbox.Assign(errorFunc))
		defer gbox.Delete(uintptr(_arg3))
	}

	_cret = C.gsk_render_node_deserialize(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(errorFunc)

	var _renderNode RenderNoder // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(RenderNoder)
				return ok
			})
			rv, ok := casted.(RenderNoder)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
			}
			_renderNode = rv
		}
	}

	return _renderNode
}

// Renderer: GskRenderer is a class that renders a scene graph defined via a
// tree of gsk.RenderNode instances.
//
// Typically you will use a GskRenderer instance to repeatedly call
// gsk.Renderer.Render() to update the contents of its associated gdk.Surface.
//
// It is necessary to realize a GskRenderer instance using
// gsk.Renderer.Realize() before calling gsk.Renderer.Render(), in order to
// create the appropriate windowing system resources needed to render the scene.
type Renderer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Renderer)(nil)
)

// Rendererer describes types inherited from class Renderer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Rendererer interface {
	coreglib.Objector
	baseRenderer() *Renderer
}

var _ Rendererer = (*Renderer)(nil)

func wrapRenderer(obj *coreglib.Object) *Renderer {
	return &Renderer{
		Object: obj,
	}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	return wrapRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (renderer *Renderer) baseRenderer() *Renderer {
	return renderer
}

// BaseRenderer returns the underlying base object.
func BaseRenderer(obj Rendererer) *Renderer {
	return obj.baseRenderer()
}

// NewRendererForSurface creates an appropriate GskRenderer instance for the
// given surface.
//
// If the GSK_RENDERER environment variable is set, GSK will try that renderer
// first, before trying the backend-specific default. The ultimate fallback is
// the cairo renderer.
//
// The renderer will be realized before it is returned.
//
// The function takes the following parameters:
//
//   - surface: GdkSurface.
//
// The function returns the following values:
//
//   - renderer (optional): GskRenderer.
//
func NewRendererForSurface(surface gdk.Surfacer) *Renderer {
	var _arg1 *C.GdkSurface  // out
	var _cret *C.GskRenderer // in

	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gsk_renderer_new_for_surface(_arg1)
	runtime.KeepAlive(surface)

	var _renderer *Renderer // out

	if _cret != nil {
		_renderer = wrapRenderer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _renderer
}

// Surface retrieves the GdkSurface set using gsk_enderer_realize().
//
// If the renderer has not been realized yet, NULL will be returned.
//
// The function returns the following values:
//
//   - surface (optional): GdkSurface.
//
func (renderer *Renderer) Surface() gdk.Surfacer {
	var _arg0 *C.GskRenderer // out
	var _cret *C.GdkSurface  // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gsk_renderer_get_surface(_arg0)
	runtime.KeepAlive(renderer)

	var _surface gdk.Surfacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Surfacer)
				return ok
			})
			rv, ok := casted.(gdk.Surfacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
			}
			_surface = rv
		}
	}

	return _surface
}

// IsRealized checks whether the renderer is realized or not.
//
// The function returns the following values:
//
//   - ok: TRUE if the GskRenderer was realized, and FALSE otherwise.
//
func (renderer *Renderer) IsRealized() bool {
	var _arg0 *C.GskRenderer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gsk_renderer_is_realized(_arg0)
	runtime.KeepAlive(renderer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Realize creates the resources needed by the renderer to render the scene
// graph.
//
// The function takes the following parameters:
//
//   - surface: GdkSurface renderer will be used on.
//
func (renderer *Renderer) Realize(surface gdk.Surfacer) error {
	var _arg0 *C.GskRenderer // out
	var _arg1 *C.GdkSurface  // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C.gsk_renderer_realize(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(surface)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Render renders the scene graph, described by a tree of GskRenderNode
// instances, ensuring that the given region gets redrawn.
//
// Renderers must ensure that changes of the contents given by the root node
// as well as the area given by region are redrawn. They are however free to
// not redraw any pixel outside of region if they can guarantee that it didn't
// change.
//
// The renderer will acquire a reference on the GskRenderNode tree while the
// rendering is in progress.
//
// The function takes the following parameters:
//
//   - root: GskRenderNode.
//   - region (optional): cairo_region_t that must be redrawn or NULL for the
//     whole window.
//
func (renderer *Renderer) Render(root RenderNoder, region *cairo.Region) {
	var _arg0 *C.GskRenderer    // out
	var _arg1 *C.GskRenderNode  // out
	var _arg2 *C.cairo_region_t // out

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(root).Native()))
	if region != nil {
		_arg2 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	}

	C.gsk_renderer_render(_arg0, _arg1, _arg2)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(root)
	runtime.KeepAlive(region)
}

// RenderTexture renders the scene graph, described by a tree of GskRenderNode
// instances, to a GdkTexture.
//
// The renderer will acquire a reference on the GskRenderNode tree while the
// rendering is in progress.
//
// If you want to apply any transformations to root, you should put it into a
// transform node and pass that node instead.
//
// The function takes the following parameters:
//
//   - root: GskRenderNode.
//   - viewport (optional): section to draw or NULL to use root's bounds.
//
// The function returns the following values:
//
//   - texture: GdkTexture with the rendered contents of root.
//
func (renderer *Renderer) RenderTexture(root RenderNoder, viewport *graphene.Rect) gdk.Texturer {
	var _arg0 *C.GskRenderer     // out
	var _arg1 *C.GskRenderNode   // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GdkTexture      // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(root).Native()))
	if viewport != nil {
		_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(viewport)))
	}

	_cret = C.gsk_renderer_render_texture(_arg0, _arg1, _arg2)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(root)
	runtime.KeepAlive(viewport)

	var _texture gdk.Texturer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Texturer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Texturer)
			return ok
		})
		rv, ok := casted.(gdk.Texturer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Texturer")
		}
		_texture = rv
	}

	return _texture
}

// Unrealize releases all the resources created by gsk_renderer_realize().
func (renderer *Renderer) Unrealize() {
	var _arg0 *C.GskRenderer // out

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.gsk_renderer_unrealize(_arg0)
	runtime.KeepAlive(renderer)
}

// RepeatNode: render node repeating its single child node.
type RepeatNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*RepeatNode)(nil)
)

func wrapRepeatNode(obj *coreglib.Object) *RepeatNode {
	return &RepeatNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRepeatNode(p uintptr) (interface{}, error) {
	return wrapRepeatNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewRepeatNode creates a GskRenderNode that will repeat the drawing of child
// across the given bounds.
//
// The function takes the following parameters:
//
//   - bounds of the area to be painted.
//   - child to repeat.
//   - childBounds (optional): area of the child to repeat or NULL to use the
//     child's bounds.
//
// The function returns the following values:
//
//   - repeatNode: new GskRenderNode.
//
func NewRepeatNode(bounds *graphene.Rect, child RenderNoder, childBounds *graphene.Rect) *RepeatNode {
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.GskRenderNode   // out
	var _arg3 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if childBounds != nil {
		_arg3 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(childBounds)))
	}

	_cret = C.gsk_repeat_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(child)
	runtime.KeepAlive(childBounds)

	var _repeatNode *RepeatNode // out

	_repeatNode = wrapRepeatNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatNode
}

// Child retrieves the child of node.
//
// The function returns the following values:
//
//   - renderNode: GskRenderNode.
//
func (node *RepeatNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_repeat_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ChildBounds retrieves the bounding rectangle of the child of node.
//
// The function returns the following values:
//
//   - rect: bounding rectangle.
//
func (node *RepeatNode) ChildBounds() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_repeat_node_get_child_bounds(_arg0)
	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rect
}

// RepeatingLinearGradientNode: render node for a repeating linear gradient.
type RepeatingLinearGradientNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*RepeatingLinearGradientNode)(nil)
)

func wrapRepeatingLinearGradientNode(obj *coreglib.Object) *RepeatingLinearGradientNode {
	return &RepeatingLinearGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRepeatingLinearGradientNode(p uintptr) (interface{}, error) {
	return wrapRepeatingLinearGradientNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewRepeatingLinearGradientNode creates a GskRenderNode that will create a
// repeating linear gradient from the given points and color stops, and render
// that into the area given by bounds.
//
// The function takes the following parameters:
//
//   - bounds: rectangle to render the linear gradient into.
//   - start: point at which the linear gradient will begin.
//   - end: point at which the linear gradient will finish.
//   - colorStops: pointer to an array of GskColorStop defining the gradient.
//     The offsets of all color stops must be increasing. The first stop's
//     offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//   - repeatingLinearGradientNode: new GskRenderNode.
//
func NewRepeatingLinearGradientNode(bounds *graphene.Rect, start, end *graphene.Point, colorStops []ColorStop) *RepeatingLinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(end)))
	_arg5 = (C.gsize)(len(colorStops))
	_arg4 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg4), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_repeating_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _repeatingLinearGradientNode *RepeatingLinearGradientNode // out

	_repeatingLinearGradientNode = wrapRepeatingLinearGradientNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingLinearGradientNode
}

// RepeatingRadialGradientNode: render node for a repeating radial gradient.
type RepeatingRadialGradientNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*RepeatingRadialGradientNode)(nil)
)

func wrapRepeatingRadialGradientNode(obj *coreglib.Object) *RepeatingRadialGradientNode {
	return &RepeatingRadialGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRepeatingRadialGradientNode(p uintptr) (interface{}, error) {
	return wrapRepeatingRadialGradientNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewRepeatingRadialGradientNode creates a GskRenderNode that draws a repeating
// radial gradient.
//
// The radial gradient starts around center. The size of the gradient is
// dictated by hradius in horizontal orientation and by vradius in vertial
// orientation.
//
// The function takes the following parameters:
//
//   - bounds of the node.
//   - center of the gradient.
//   - hradius: horizontal radius.
//   - vradius: vertical radius.
//   - start: percentage >= 0 that defines the start of the gradient around
//     center.
//   - end: percentage >= 0 that defines the end of the gradient around center.
//   - colorStops: pointer to an array of GskColorStop defining the gradient.
//     The offsets of all color stops must be increasing. The first stop's
//     offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//   - repeatingRadialGradientNode: new GskRenderNode.
//
func NewRepeatingRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius, vradius, start, end float32, colorStops []ColorStop) *RepeatingRadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop     // out
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = (C.gsize)(len(colorStops))
	_arg7 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg7))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg7), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_repeating_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(hradius)
	runtime.KeepAlive(vradius)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _repeatingRadialGradientNode *RepeatingRadialGradientNode // out

	_repeatingRadialGradientNode = wrapRepeatingRadialGradientNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingRadialGradientNode
}

// RoundedClipNode: render node applying a rounded rectangle clip to its single
// child.
type RoundedClipNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*RoundedClipNode)(nil)
)

func wrapRoundedClipNode(obj *coreglib.Object) *RoundedClipNode {
	return &RoundedClipNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRoundedClipNode(p uintptr) (interface{}, error) {
	return wrapRoundedClipNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewRoundedClipNode creates a GskRenderNode that will clip the child to the
// area given by clip.
//
// The function takes the following parameters:
//
//   - child: node to draw.
//   - clip to apply.
//
// The function returns the following values:
//
//   - roundedClipNode: new GskRenderNode.
//
func NewRoundedClipNode(child RenderNoder, clip *RoundedRect) *RoundedClipNode {
	var _arg1 *C.GskRenderNode  // out
	var _arg2 *C.GskRoundedRect // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(clip)))

	_cret = C.gsk_rounded_clip_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _roundedClipNode *RoundedClipNode // out

	_roundedClipNode = wrapRoundedClipNode(coreglib.Take(unsafe.Pointer(_cret)))

	return _roundedClipNode
}

// Child gets the child node that is getting clipped by the given node.
//
// The function returns the following values:
//
//   - renderNode: child that is getting clipped.
//
func (node *RoundedClipNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_rounded_clip_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the rounded rectangle used to clip the contents of the node.
//
// The function returns the following values:
//
//   - roundedRect: rounded rectangle.
//
func (node *RoundedClipNode) Clip() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_rounded_clip_node_get_clip(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// ShadowNode: render node drawing one or more shadows behind its single child
// node.
type ShadowNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*ShadowNode)(nil)
)

func wrapShadowNode(obj *coreglib.Object) *ShadowNode {
	return &ShadowNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalShadowNode(p uintptr) (interface{}, error) {
	return wrapShadowNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewShadowNode creates a GskRenderNode that will draw a child with the given
// shadows below it.
//
// The function takes the following parameters:
//
//   - child: node to draw.
//   - shadows to apply.
//
// The function returns the following values:
//
//   - shadowNode: new GskRenderNode.
//
func NewShadowNode(child RenderNoder, shadows []Shadow) *ShadowNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskShadow     // out
	var _arg3 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg3 = (C.gsize)(len(shadows))
	_arg2 = (*C.GskShadow)(C.calloc(C.size_t(len(shadows)), C.size_t(C.sizeof_GskShadow)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GskShadow)(_arg2), len(shadows))
		for i := range shadows {
			out[i] = *(*C.GskShadow)(gextras.StructNative(unsafe.Pointer((&shadows[i]))))
		}
	}

	_cret = C.gsk_shadow_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(child)
	runtime.KeepAlive(shadows)

	var _shadowNode *ShadowNode // out

	_shadowNode = wrapShadowNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shadowNode
}

// Child retrieves the child GskRenderNode of the shadow node.
//
// The function returns the following values:
//
//   - renderNode: child render node.
//
func (node *ShadowNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_shadow_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NShadows retrieves the number of shadows in the node.
//
// The function returns the following values:
//
//   - gsize: number of shadows.
//
func (node *ShadowNode) NShadows() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_shadow_node_get_n_shadows(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Shadow retrieves the shadow data at the given index i.
//
// The function takes the following parameters:
//
//   - i: given index.
//
// The function returns the following values:
//
//   - shadow data.
//
func (node *ShadowNode) Shadow(i uint) *Shadow {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.gsize          // out
	var _cret *C.GskShadow     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = C.gsize(i)

	_cret = C.gsk_shadow_node_get_shadow(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(i)

	var _shadow *Shadow // out

	_shadow = (*Shadow)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _shadow
}

// TextNode: render node drawing a set of glyphs.
type TextNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*TextNode)(nil)
)

func wrapTextNode(obj *coreglib.Object) *TextNode {
	return &TextNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalTextNode(p uintptr) (interface{}, error) {
	return wrapTextNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTextNode creates a render node that renders the given glyphs.
//
// Note that color may not be used if the font contains color glyphs.
//
// The function takes the following parameters:
//
//   - font containing the glyphs.
//   - glyphs to render.
//   - color: foreground color to render with.
//   - offset of the baseline.
//
// The function returns the following values:
//
//   - textNode (optional): new GskRenderNode.
//
func NewTextNode(font pango.Fonter, glyphs *pango.GlyphString, color *gdk.RGBA, offset *graphene.Point) *TextNode {
	var _arg1 *C.PangoFont        // out
	var _arg2 *C.PangoGlyphString // out
	var _arg3 *C.GdkRGBA          // out
	var _arg4 *C.graphene_point_t // out
	var _cret *C.GskRenderNode    // in

	_arg1 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg2 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg3 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg4 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(offset)))

	_cret = C.gsk_text_node_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(color)
	runtime.KeepAlive(offset)

	var _textNode *TextNode // out

	if _cret != nil {
		_textNode = wrapTextNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _textNode
}

// Color retrieves the color used by the text node.
//
// The function returns the following values:
//
//   - rgbA: text color.
//
func (node *TextNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_text_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Font returns the font used by the text node.
//
// The function returns the following values:
//
//   - font: font.
//
func (node *TextNode) Font() pango.Fonter {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.PangoFont     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_text_node_get_font(_arg0)
	runtime.KeepAlive(node)

	var _font pango.Fonter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(pango.Fonter)
			return ok
		})
		rv, ok := casted.(pango.Fonter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
		}
		_font = rv
	}

	return _font
}

// Glyphs retrieves the glyph information in the node.
//
// The function returns the following values:
//
//   - glyphInfos: glyph information.
//
func (node *TextNode) Glyphs() []pango.GlyphInfo {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.PangoGlyphInfo // in
	var _arg1 C.guint           // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_text_node_get_glyphs(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _glyphInfos []pango.GlyphInfo // out

	{
		src := unsafe.Slice((*C.PangoGlyphInfo)(_cret), _arg1)
		_glyphInfos = make([]pango.GlyphInfo, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_glyphInfos[i] = *(*pango.GlyphInfo)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _glyphInfos
}

// NumGlyphs retrieves the number of glyphs in the text node.
//
// The function returns the following values:
//
//   - guint: number of glyphs.
//
func (node *TextNode) NumGlyphs() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_text_node_get_num_glyphs(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Offset retrieves the offset applied to the text.
//
// The function returns the following values:
//
//   - point with the horizontal and vertical offsets.
//
func (node *TextNode) Offset() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_text_node_get_offset(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// HasColorGlyphs checks whether the text node has color glyphs.
//
// The function returns the following values:
//
//   - ok: TRUE if the text node has color glyphs.
//
func (node *TextNode) HasColorGlyphs() bool {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_text_node_has_color_glyphs(_arg0)
	runtime.KeepAlive(node)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextureNode: render node for a Texture.
type TextureNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*TextureNode)(nil)
)

func wrapTextureNode(obj *coreglib.Object) *TextureNode {
	return &TextureNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalTextureNode(p uintptr) (interface{}, error) {
	return wrapTextureNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTextureNode creates a GskRenderNode that will render the given texture
// into the area given by bounds.
//
// The function takes the following parameters:
//
//   - texture: GdkTexture.
//   - bounds: rectangle to render the texture into.
//
// The function returns the following values:
//
//   - textureNode: new GskRenderNode.
//
func NewTextureNode(texture gdk.Texturer, bounds *graphene.Rect) *TextureNode {
	var _arg1 *C.GdkTexture      // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gsk_texture_node_new(_arg1, _arg2)
	runtime.KeepAlive(texture)
	runtime.KeepAlive(bounds)

	var _textureNode *TextureNode // out

	_textureNode = wrapTextureNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textureNode
}

// Texture retrieves the GdkTexture used when creating this GskRenderNode.
//
// The function returns the following values:
//
//   - texture: GdkTexture.
//
func (node *TextureNode) Texture() gdk.Texturer {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkTexture    // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_texture_node_get_texture(_arg0)
	runtime.KeepAlive(node)

	var _texture gdk.Texturer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Texturer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Texturer)
			return ok
		})
		rv, ok := casted.(gdk.Texturer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Texturer")
		}
		_texture = rv
	}

	return _texture
}

// TransformNode: render node applying a GskTransform to its single child node.
type TransformNode struct {
	_ [0]func() // equal guard
	RenderNode
}

var (
	_ RenderNoder = (*TransformNode)(nil)
)

func wrapTransformNode(obj *coreglib.Object) *TransformNode {
	return &TransformNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalTransformNode(p uintptr) (interface{}, error) {
	return wrapTransformNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTransformNode creates a GskRenderNode that will transform the given child
// with the given transform.
//
// The function takes the following parameters:
//
//   - child: node to transform.
//   - transform to apply.
//
// The function returns the following values:
//
//   - transformNode: new GskRenderNode.
//
func NewTransformNode(child RenderNoder, transform *Transform) *TransformNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskTransform  // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(transform)))

	_cret = C.gsk_transform_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(transform)

	var _transformNode *TransformNode // out

	_transformNode = wrapTransformNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _transformNode
}

// Child gets the child node that is getting transformed by the given node.
//
// The function returns the following values:
//
//   - renderNode: child that is getting transformed.
//
func (node *TransformNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_transform_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Transform retrieves the GskTransform used by the node.
//
// The function returns the following values:
//
//   - transform: GskTransform.
//
func (node *TransformNode) Transform() *Transform {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskTransform  // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_cret = C.gsk_transform_node_get_transform(_arg0)
	runtime.KeepAlive(node)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// ColorStop: color stop in a gradient node.
//
// An instance of this type is always passed by reference.
type ColorStop struct {
	*colorStop
}

// colorStop is the struct that's finalized.
type colorStop struct {
	native *C.GskColorStop
}

// Offset: offset of the color stop.
func (c *ColorStop) Offset() float32 {
	valptr := &c.native.offset
	var _v float32 // out
	_v = float32(*valptr)
	return _v
}

// Color: color at the given offset.
func (c *ColorStop) Color() *gdk.RGBA {
	valptr := &c.native.color
	var _v *gdk.RGBA // out
	_v = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Offset: offset of the color stop.
func (c *ColorStop) SetOffset(offset float32) {
	valptr := &c.native.offset
	*valptr = C.float(offset)
}

// GLShaderClass: instance of this type is always passed by reference.
type GLShaderClass struct {
	*glShaderClass
}

// glShaderClass is the struct that's finalized.
type glShaderClass struct {
	native *C.GskGLShaderClass
}

// ParseLocation: location in a parse buffer.
//
// An instance of this type is always passed by reference.
type ParseLocation struct {
	*parseLocation
}

// parseLocation is the struct that's finalized.
type parseLocation struct {
	native *C.GskParseLocation
}

// NewParseLocation creates a new ParseLocation instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewParseLocation(bytes, chars, lines, lineBytes, lineChars uint) ParseLocation {
	var f0 C.gsize // out
	f0 = C.gsize(bytes)
	var f1 C.gsize // out
	f1 = C.gsize(chars)
	var f2 C.gsize // out
	f2 = C.gsize(lines)
	var f3 C.gsize // out
	f3 = C.gsize(lineBytes)
	var f4 C.gsize // out
	f4 = C.gsize(lineChars)

	v := C.GskParseLocation{
		bytes:      f0,
		chars:      f1,
		lines:      f2,
		line_bytes: f3,
		line_chars: f4,
	}

	return *(*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Bytes: offset of the location in the parse buffer, as bytes.
func (p *ParseLocation) Bytes() uint {
	valptr := &p.native.bytes
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Chars: offset of the location in the parse buffer, as characters.
func (p *ParseLocation) Chars() uint {
	valptr := &p.native.chars
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Lines: line of the location in the parse buffer.
func (p *ParseLocation) Lines() uint {
	valptr := &p.native.lines
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// LineBytes: position in the line, as bytes.
func (p *ParseLocation) LineBytes() uint {
	valptr := &p.native.line_bytes
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// LineChars: position in the line, as characters.
func (p *ParseLocation) LineChars() uint {
	valptr := &p.native.line_chars
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Bytes: offset of the location in the parse buffer, as bytes.
func (p *ParseLocation) SetBytes(bytes uint) {
	valptr := &p.native.bytes
	*valptr = C.gsize(bytes)
}

// Chars: offset of the location in the parse buffer, as characters.
func (p *ParseLocation) SetChars(chars uint) {
	valptr := &p.native.chars
	*valptr = C.gsize(chars)
}

// Lines: line of the location in the parse buffer.
func (p *ParseLocation) SetLines(lines uint) {
	valptr := &p.native.lines
	*valptr = C.gsize(lines)
}

// LineBytes: position in the line, as bytes.
func (p *ParseLocation) SetLineBytes(lineBytes uint) {
	valptr := &p.native.line_bytes
	*valptr = C.gsize(lineBytes)
}

// LineChars: position in the line, as characters.
func (p *ParseLocation) SetLineChars(lineChars uint) {
	valptr := &p.native.line_chars
	*valptr = C.gsize(lineChars)
}

// RoundedRect: rectangular region with rounded corners.
//
// Application code should normalize rectangles using
// gsk.RoundedRect.Normalize(); this function will ensure that the bounds of the
// rectangle are normalized and ensure that the corner values are positive and
// the corners do not overlap.
//
// All functions taking a GskRoundedRect as an argument will internally operate
// on a normalized copy; all functions returning a GskRoundedRect will always
// return a normalized one.
//
// The algorithm used for normalizing corner sizes is described in the CSS
// specification (https://drafts.csswg.org/css-backgrounds-3/#border-radius).
//
// An instance of this type is always passed by reference.
type RoundedRect struct {
	*roundedRect
}

// roundedRect is the struct that's finalized.
type roundedRect struct {
	native *C.GskRoundedRect
}

// Bounds bounds of the rectangle.
func (r *RoundedRect) Bounds() *graphene.Rect {
	valptr := &r.native.bounds
	var _v *graphene.Rect // out
	_v = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Corner: size of the 4 rounded corners.
func (r *RoundedRect) Corner() [4]graphene.Size {
	valptr := &r.native.corner
	var _v [4]graphene.Size // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = *(*graphene.Size)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}
	return _v
}

// ContainsPoint checks if the given point is inside the rounded rectangle.
//
// The function takes the following parameters:
//
//   - point to check.
//
// The function returns the following values:
//
//   - ok: TRUE if the point is inside the rounded rectangle.
//
func (self *RoundedRect) ContainsPoint(point *graphene.Point) bool {
	var _arg0 *C.GskRoundedRect   // out
	var _arg1 *C.graphene_point_t // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(point)))

	_cret = C.gsk_rounded_rect_contains_point(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(point)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainsRect checks if the given rect is contained inside the rounded
// rectangle.
//
// The function takes the following parameters:
//
//   - rect: rectangle to check.
//
// The function returns the following values:
//
//   - ok: TRUE if the rect is fully contained inside the rounded rectangle.
//
func (self *RoundedRect) ContainsRect(rect *graphene.Rect) bool {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(rect)))

	_cret = C.gsk_rounded_rect_contains_rect(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(rect)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Init initializes the given GskRoundedRect with the given values.
//
// This function will implicitly normalize the GskRoundedRect before returning.
//
// The function takes the following parameters:
//
//   - bounds: graphene_rect_t describing the bounds.
//   - topLeft: rounding radius of the top left corner.
//   - topRight: rounding radius of the top right corner.
//   - bottomRight: rounding radius of the bottom right corner.
//   - bottomLeft: rounding radius of the bottom left corner.
//
// The function returns the following values:
//
//   - roundedRect: initialized rectangle.
//
func (self *RoundedRect) Init(bounds *graphene.Rect, topLeft *graphene.Size, topRight *graphene.Size, bottomRight *graphene.Size, bottomLeft *graphene.Size) *RoundedRect {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.graphene_size_t // out
	var _arg3 *C.graphene_size_t // out
	var _arg4 *C.graphene_size_t // out
	var _arg5 *C.graphene_size_t // out
	var _cret *C.GskRoundedRect  // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_size_t)(gextras.StructNative(unsafe.Pointer(topLeft)))
	_arg3 = (*C.graphene_size_t)(gextras.StructNative(unsafe.Pointer(topRight)))
	_arg4 = (*C.graphene_size_t)(gextras.StructNative(unsafe.Pointer(bottomRight)))
	_arg5 = (*C.graphene_size_t)(gextras.StructNative(unsafe.Pointer(bottomLeft)))

	_cret = C.gsk_rounded_rect_init(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(self)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(topLeft)
	runtime.KeepAlive(topRight)
	runtime.KeepAlive(bottomRight)
	runtime.KeepAlive(bottomLeft)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// InitCopy initializes self using the given src rectangle.
//
// This function will not normalize the GskRoundedRect, so make sure the source
// is normalized.
//
// The function takes the following parameters:
//
//   - src: GskRoundedRect.
//
// The function returns the following values:
//
//   - roundedRect: initialized rectangle.
//
func (self *RoundedRect) InitCopy(src *RoundedRect) *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _arg1 *C.GskRoundedRect // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(src)))

	_cret = C.gsk_rounded_rect_init_copy(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(src)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// InitFromRect initializes self to the given bounds and sets the radius of all
// four corners to radius.
//
// The function takes the following parameters:
//
//   - bounds: graphene_rect_t.
//   - radius: border radius.
//
// The function returns the following values:
//
//   - roundedRect: initialized rectangle.
//
func (self *RoundedRect) InitFromRect(bounds *graphene.Rect, radius float32) *RoundedRect {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 C.float            // out
	var _cret *C.GskRoundedRect  // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = C.float(radius)

	_cret = C.gsk_rounded_rect_init_from_rect(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(radius)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// IntersectsRect checks if part of the given rect is contained inside the
// rounded rectangle.
//
// The function takes the following parameters:
//
//   - rect: rectangle to check.
//
// The function returns the following values:
//
//   - ok: TRUE if the rect intersects with the rounded rectangle.
//
func (self *RoundedRect) IntersectsRect(rect *graphene.Rect) bool {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(rect)))

	_cret = C.gsk_rounded_rect_intersects_rect(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(rect)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRectilinear checks if all corners of self are right angles and the
// rectangle covers all of its bounds.
//
// This information can be used to decide if gsk.ClipNode.New or
// gsk.RoundedClipNode.New should be called.
//
// The function returns the following values:
//
//   - ok: TRUE if the rectangle is rectilinear.
//
func (self *RoundedRect) IsRectilinear() bool {
	var _arg0 *C.GskRoundedRect // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gsk_rounded_rect_is_rectilinear(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Normalize normalizes the passed rectangle.
//
// This function will ensure that the bounds of the rectangle are normalized and
// ensure that the corner values are positive and the corners do not overlap.
//
// The function returns the following values:
//
//   - roundedRect: normalized rectangle.
//
func (self *RoundedRect) Normalize() *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gsk_rounded_rect_normalize(_arg0)
	runtime.KeepAlive(self)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Offset offsets the bound's origin by dx and dy.
//
// The size and corners of the rectangle are unchanged.
//
// The function takes the following parameters:
//
//   - dx: horizontal offset.
//   - dy: vertical offset.
//
// The function returns the following values:
//
//   - roundedRect: offset rectangle.
//
func (self *RoundedRect) Offset(dx float32, dy float32) *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _arg1 C.float           // out
	var _arg2 C.float           // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.float(dx)
	_arg2 = C.float(dy)

	_cret = C.gsk_rounded_rect_offset(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Shrink shrinks (or grows) the given rectangle by moving the 4 sides according
// to the offsets given.
//
// The corner radii will be changed in a way that tries to keep the center of
// the corner circle intact. This emulates CSS behavior.
//
// This function also works for growing rectangles if you pass negative values
// for the top, right, bottom or left.
//
// The function takes the following parameters:
//
//   - top: how far to move the top side downwards.
//   - right: how far to move the right side to the left.
//   - bottom: how far to move the bottom side upwards.
//   - left: how far to move the left side to the right.
//
// The function returns the following values:
//
//   - roundedRect: resized GskRoundedRect.
//
func (self *RoundedRect) Shrink(top float32, right float32, bottom float32, left float32) *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _arg1 C.float           // out
	var _arg2 C.float           // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.float(top)
	_arg2 = C.float(right)
	_arg3 = C.float(bottom)
	_arg4 = C.float(left)

	_cret = C.gsk_rounded_rect_shrink(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(top)
	runtime.KeepAlive(right)
	runtime.KeepAlive(bottom)
	runtime.KeepAlive(left)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// ShaderArgsBuilder: object to build the uniforms data for a GLShader.
//
// An instance of this type is always passed by reference.
type ShaderArgsBuilder struct {
	*shaderArgsBuilder
}

// shaderArgsBuilder is the struct that's finalized.
type shaderArgsBuilder struct {
	native *C.GskShaderArgsBuilder
}

func marshalShaderArgsBuilder(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ShaderArgsBuilder{&shaderArgsBuilder{(*C.GskShaderArgsBuilder)(b)}}, nil
}

// NewShaderArgsBuilder constructs a struct ShaderArgsBuilder.
func NewShaderArgsBuilder(shader *GLShader, initialValues *glib.Bytes) *ShaderArgsBuilder {
	var _arg1 *C.GskGLShader          // out
	var _arg2 *C.GBytes               // out
	var _cret *C.GskShaderArgsBuilder // in

	_arg1 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	if initialValues != nil {
		_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(initialValues)))
	}

	_cret = C.gsk_shader_args_builder_new(_arg1, _arg2)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(initialValues)

	var _shaderArgsBuilder *ShaderArgsBuilder // out

	_shaderArgsBuilder = (*ShaderArgsBuilder)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_shaderArgsBuilder)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_shader_args_builder_unref((*C.GskShaderArgsBuilder)(intern.C))
		},
	)

	return _shaderArgsBuilder
}

// SetBool sets the value of the uniform idx.
//
// The uniform must be of bool type.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//   - value to set the uniform to.
//
func (builder *ShaderArgsBuilder) SetBool(idx int, value bool) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.gboolean              // out

	_arg0 = (*C.GskShaderArgsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = C.int(idx)
	if value {
		_arg2 = C.TRUE
	}

	C.gsk_shader_args_builder_set_bool(_arg0, _arg1, _arg2)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(value)
}

// SetFloat sets the value of the uniform idx.
//
// The uniform must be of float type.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//   - value to set the uniform to.
//
func (builder *ShaderArgsBuilder) SetFloat(idx int, value float32) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.float                 // out

	_arg0 = (*C.GskShaderArgsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = C.int(idx)
	_arg2 = C.float(value)

	C.gsk_shader_args_builder_set_float(_arg0, _arg1, _arg2)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(value)
}

// SetInt sets the value of the uniform idx.
//
// The uniform must be of int type.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//   - value to set the uniform to.
//
func (builder *ShaderArgsBuilder) SetInt(idx int, value int32) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.gint32                // out

	_arg0 = (*C.GskShaderArgsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = C.int(idx)
	_arg2 = C.gint32(value)

	C.gsk_shader_args_builder_set_int(_arg0, _arg1, _arg2)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(value)
}

// SetUint sets the value of the uniform idx.
//
// The uniform must be of uint type.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//   - value to set the uniform to.
//
func (builder *ShaderArgsBuilder) SetUint(idx int, value uint32) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.guint32               // out

	_arg0 = (*C.GskShaderArgsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = C.int(idx)
	_arg2 = C.guint32(value)

	C.gsk_shader_args_builder_set_uint(_arg0, _arg1, _arg2)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(value)
}

// SetVec2 sets the value of the uniform idx.
//
// The uniform must be of vec2 type.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//   - value to set the uniform too.
//
func (builder *ShaderArgsBuilder) SetVec2(idx int, value *graphene.Vec2) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 *C.graphene_vec2_t      // out

	_arg0 = (*C.GskShaderArgsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = C.int(idx)
	_arg2 = (*C.graphene_vec2_t)(gextras.StructNative(unsafe.Pointer(value)))

	C.gsk_shader_args_builder_set_vec2(_arg0, _arg1, _arg2)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(value)
}

// SetVec3 sets the value of the uniform idx.
//
// The uniform must be of vec3 type.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//   - value to set the uniform too.
//
func (builder *ShaderArgsBuilder) SetVec3(idx int, value *graphene.Vec3) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 *C.graphene_vec3_t      // out

	_arg0 = (*C.GskShaderArgsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = C.int(idx)
	_arg2 = (*C.graphene_vec3_t)(gextras.StructNative(unsafe.Pointer(value)))

	C.gsk_shader_args_builder_set_vec3(_arg0, _arg1, _arg2)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(value)
}

// SetVec4 sets the value of the uniform idx.
//
// The uniform must be of vec4 type.
//
// The function takes the following parameters:
//
//   - idx: index of the uniform.
//   - value to set the uniform too.
//
func (builder *ShaderArgsBuilder) SetVec4(idx int, value *graphene.Vec4) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 *C.graphene_vec4_t      // out

	_arg0 = (*C.GskShaderArgsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = C.int(idx)
	_arg2 = (*C.graphene_vec4_t)(gextras.StructNative(unsafe.Pointer(value)))

	C.gsk_shader_args_builder_set_vec4(_arg0, _arg1, _arg2)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(value)
}

// ToArgs creates a new GBytes args from the current state of the given builder.
//
// Any uniforms of the shader that have not been explicitly set on the builder
// are zero-initialized.
//
// The given GskShaderArgsBuilder is reset once this function returns;
// you cannot call this function multiple times on the same builder instance.
//
// This function is intended primarily for bindings. C code should use
// gsk.ShaderArgsBuilder.FreeToArgs().
//
// The function returns the following values:
//
//   - bytes: newly allocated buffer with all the args added to builder.
//
func (builder *ShaderArgsBuilder) ToArgs() *glib.Bytes {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _cret *C.GBytes               // in

	_arg0 = (*C.GskShaderArgsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))

	_cret = C.gsk_shader_args_builder_to_args(_arg0)
	runtime.KeepAlive(builder)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Shadow: shadow parameters in a shadow node.
//
// An instance of this type is always passed by reference.
type Shadow struct {
	*shadow
}

// shadow is the struct that's finalized.
type shadow struct {
	native *C.GskShadow
}

// Color: color of the shadow.
func (s *Shadow) Color() *gdk.RGBA {
	valptr := &s.native.color
	var _v *gdk.RGBA // out
	_v = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Dx: horizontal offset of the shadow.
func (s *Shadow) Dx() float32 {
	valptr := &s.native.dx
	var _v float32 // out
	_v = float32(*valptr)
	return _v
}

// Dy: vertical offset of the shadow.
func (s *Shadow) Dy() float32 {
	valptr := &s.native.dy
	var _v float32 // out
	_v = float32(*valptr)
	return _v
}

// Radius radius of the shadow.
func (s *Shadow) Radius() float32 {
	valptr := &s.native.radius
	var _v float32 // out
	_v = float32(*valptr)
	return _v
}

// Dx: horizontal offset of the shadow.
func (s *Shadow) SetDx(dx float32) {
	valptr := &s.native.dx
	*valptr = C.float(dx)
}

// Dy: vertical offset of the shadow.
func (s *Shadow) SetDy(dy float32) {
	valptr := &s.native.dy
	*valptr = C.float(dy)
}

// Radius radius of the shadow.
func (s *Shadow) SetRadius(radius float32) {
	valptr := &s.native.radius
	*valptr = C.float(radius)
}

// Transform: GskTransform is an object to describe transform matrices.
//
// Unlike graphene_matrix_t, GskTransform retains the steps in how a transform
// was constructed, and allows inspecting them. It is modeled after the way CSS
// describes transforms.
//
// GskTransform objects are immutable and cannot be changed after creation.
// This means code can safely expose them as properties of objects without
// having to worry about others changing them.
//
// An instance of this type is always passed by reference.
type Transform struct {
	*transform
}

// transform is the struct that's finalized.
type transform struct {
	native *C.GskTransform
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Transform{&transform{(*C.GskTransform)(b)}}, nil
}

// NewTransform constructs a struct Transform.
func NewTransform() *Transform {
	var _cret *C.GskTransform // in

	_cret = C.gsk_transform_new()

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Equal checks two transforms for equality.
//
// The function takes the following parameters:
//
//   - second (optional) transform.
//
// The function returns the following values:
//
//   - ok: TRUE if the two transforms perform the same operation.
//
func (first *Transform) Equal(second *Transform) bool {
	var _arg0 *C.GskTransform // out
	var _arg1 *C.GskTransform // out
	var _cret C.gboolean      // in

	if first != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(first)))
	}
	if second != nil {
		_arg1 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(second)))
	}

	_cret = C.gsk_transform_equal(_arg0, _arg1)
	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Category returns the category this transform belongs to.
//
// The function returns the following values:
//
//   - transformCategory: category of the transform.
//
func (self *Transform) Category() TransformCategory {
	var _arg0 *C.GskTransform        // out
	var _cret C.GskTransformCategory // in

	if self != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(self)))
	}

	_cret = C.gsk_transform_get_category(_arg0)
	runtime.KeepAlive(self)

	var _transformCategory TransformCategory // out

	_transformCategory = TransformCategory(_cret)

	return _transformCategory
}

// Invert inverts the given transform.
//
// If self is not invertible, NULL is returned. Note that inverting NULL
// also returns NULL, which is the correct inverse of NULL. If you need to
// differentiate between those cases, you should check self is not NULL before
// calling this function.
//
// The function returns the following values:
//
//   - transform (optional): inverted transform or NULL if the transform cannot
//     be inverted.
//
func (self *Transform) Invert() *Transform {
	var _arg0 *C.GskTransform // out
	var _cret *C.GskTransform // in

	if self != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(self)))
	}

	_cret = C.gsk_transform_invert(_arg0)
	runtime.KeepAlive(self)

	var _transform *Transform // out

	if _cret != nil {
		_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_transform)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gsk_transform_unref((*C.GskTransform)(intern.C))
			},
		)
	}

	return _transform
}

// Matrix multiplies next with the given matrix.
//
// The function takes the following parameters:
//
//   - matrix to multiply next with.
//
// The function returns the following values:
//
//   - transform: new transform.
//
func (next *Transform) Matrix(matrix *graphene.Matrix) *Transform {
	var _arg0 *C.GskTransform      // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret *C.GskTransform      // in

	if next != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = (*C.graphene_matrix_t)(gextras.StructNative(unsafe.Pointer(matrix)))

	_cret = C.gsk_transform_matrix(_arg0, _arg1)
	runtime.KeepAlive(next)
	runtime.KeepAlive(matrix)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Perspective applies a perspective projection transform.
//
// This transform scales points in X and Y based on their Z value, scaling
// points with positive Z values away from the origin, and those with negative Z
// values towards the origin. Points on the z=0 plane are unchanged.
//
// The function takes the following parameters:
//
//   - depth: distance of the z=0 plane. Lower values give a more flattened
//     pyramid and therefore a more pronounced perspective effect.
//
// The function returns the following values:
//
//   - transform: new transform.
//
func (next *Transform) Perspective(depth float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _cret *C.GskTransform // in

	if next != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = C.float(depth)

	_cret = C.gsk_transform_perspective(_arg0, _arg1)
	runtime.KeepAlive(next)
	runtime.KeepAlive(depth)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Rotate rotates next angle degrees in 2D - or in 3D-speak, around the z axis.
//
// The function takes the following parameters:
//
//   - angle: rotation angle, in degrees (clockwise).
//
// The function returns the following values:
//
//   - transform: new transform.
//
func (next *Transform) Rotate(angle float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _cret *C.GskTransform // in

	if next != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = C.float(angle)

	_cret = C.gsk_transform_rotate(_arg0, _arg1)
	runtime.KeepAlive(next)
	runtime.KeepAlive(angle)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Rotate3D rotates next angle degrees around axis.
//
// For a rotation in 2D space, use gsk.Transform.Rotate().
//
// The function takes the following parameters:
//
//   - angle: rotation angle, in degrees (clockwise).
//   - axis: rotation axis.
//
// The function returns the following values:
//
//   - transform: new transform.
//
func (next *Transform) Rotate3D(angle float32, axis *graphene.Vec3) *Transform {
	var _arg0 *C.GskTransform    // out
	var _arg1 C.float            // out
	var _arg2 *C.graphene_vec3_t // out
	var _cret *C.GskTransform    // in

	if next != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = C.float(angle)
	_arg2 = (*C.graphene_vec3_t)(gextras.StructNative(unsafe.Pointer(axis)))

	_cret = C.gsk_transform_rotate_3d(_arg0, _arg1, _arg2)
	runtime.KeepAlive(next)
	runtime.KeepAlive(angle)
	runtime.KeepAlive(axis)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Scale scales next in 2-dimensional space by the given factors.
//
// Use gsk.Transform.Scale3D() to scale in all 3 dimensions.
//
// The function takes the following parameters:
//
//   - factorX: scaling factor on the X axis.
//   - factorY: scaling factor on the Y axis.
//
// The function returns the following values:
//
//   - transform: new transform.
//
func (next *Transform) Scale(factorX float32, factorY float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _arg2 C.float         // out
	var _cret *C.GskTransform // in

	if next != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = C.float(factorX)
	_arg2 = C.float(factorY)

	_cret = C.gsk_transform_scale(_arg0, _arg1, _arg2)
	runtime.KeepAlive(next)
	runtime.KeepAlive(factorX)
	runtime.KeepAlive(factorY)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Scale3D scales next by the given factors.
//
// The function takes the following parameters:
//
//   - factorX: scaling factor on the X axis.
//   - factorY: scaling factor on the Y axis.
//   - factorZ: scaling factor on the Z axis.
//
// The function returns the following values:
//
//   - transform: new transform.
//
func (next *Transform) Scale3D(factorX float32, factorY float32, factorZ float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _arg2 C.float         // out
	var _arg3 C.float         // out
	var _cret *C.GskTransform // in

	if next != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = C.float(factorX)
	_arg2 = C.float(factorY)
	_arg3 = C.float(factorZ)

	_cret = C.gsk_transform_scale_3d(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(next)
	runtime.KeepAlive(factorX)
	runtime.KeepAlive(factorY)
	runtime.KeepAlive(factorZ)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// To2D converts a GskTransform to a 2D transformation matrix.
//
// self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D to check.
//
// The returned values have the following layout:
//
//    | xx yx |   |  a  b  0 |
//    | xy yy | = |  c  d  0 |
//    | dx dy |   | tx ty  1 |
//
// This function can be used to convert between a GskTransform and a matrix type
// from other 2D drawing libraries, in particular Cairo.
//
// The function returns the following values:
//
//   - outXx: return location for the xx member.
//   - outYx: return location for the yx member.
//   - outXy: return location for the xy member.
//   - outYy: return location for the yy member.
//   - outDx: return location for the x0 member.
//   - outDy: return location for the y0 member.
//
func (self *Transform) To2D() (outXx float32, outYx float32, outXy float32, outYy float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in
	var _arg3 C.float         // in
	var _arg4 C.float         // in
	var _arg5 C.float         // in
	var _arg6 C.float         // in

	_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(self)))

	C.gsk_transform_to_2d(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(self)

	var _outXx float32 // out
	var _outYx float32 // out
	var _outXy float32 // out
	var _outYy float32 // out
	var _outDx float32 // out
	var _outDy float32 // out

	_outXx = float32(_arg1)
	_outYx = float32(_arg2)
	_outXy = float32(_arg3)
	_outYy = float32(_arg4)
	_outDx = float32(_arg5)
	_outDy = float32(_arg6)

	return _outXx, _outYx, _outXy, _outYy, _outDx, _outDy
}

// ToAffine converts a GskTransform to 2D affine transformation factors.
//
// self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.
//
// The function returns the following values:
//
//   - outScaleX: return location for the scale factor in the x direction.
//   - outScaleY: return location for the scale factor in the y direction.
//   - outDx: return location for the translation in the x direction.
//   - outDy: return location for the translation in the y direction.
//
func (self *Transform) ToAffine() (outScaleX float32, outScaleY float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in
	var _arg3 C.float         // in
	var _arg4 C.float         // in

	_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(self)))

	C.gsk_transform_to_affine(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(self)

	var _outScaleX float32 // out
	var _outScaleY float32 // out
	var _outDx float32     // out
	var _outDy float32     // out

	_outScaleX = float32(_arg1)
	_outScaleY = float32(_arg2)
	_outDx = float32(_arg3)
	_outDy = float32(_arg4)

	return _outScaleX, _outScaleY, _outDx, _outDy
}

// ToMatrix computes the actual value of self and stores it in out_matrix.
//
// The previous value of out_matrix will be ignored.
//
// The function returns the following values:
//
//   - outMatrix: matrix to set.
//
func (self *Transform) ToMatrix() *graphene.Matrix {
	var _arg0 *C.GskTransform     // out
	var _arg1 C.graphene_matrix_t // in

	if self != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(self)))
	}

	C.gsk_transform_to_matrix(_arg0, &_arg1)
	runtime.KeepAlive(self)

	var _outMatrix *graphene.Matrix // out

	_outMatrix = (*graphene.Matrix)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _outMatrix
}

// String converts a matrix into a string that is suitable for printing.
//
// The resulting string can be parsed with gsk.Transform().Parse.
//
// This is a wrapper around gsk.Transform.Print().
//
// The function returns the following values:
//
//   - utf8: new string for self.
//
func (self *Transform) String() string {
	var _arg0 *C.GskTransform // out
	var _cret *C.char         // in

	if self != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(self)))
	}

	_cret = C.gsk_transform_to_string(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToTranslate converts a GskTransform to a translation operation.
//
// self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.
//
// The function returns the following values:
//
//   - outDx: return location for the translation in the x direction.
//   - outDy: return location for the translation in the y direction.
//
func (self *Transform) ToTranslate() (outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in

	_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(self)))

	C.gsk_transform_to_translate(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(self)

	var _outDx float32 // out
	var _outDy float32 // out

	_outDx = float32(_arg1)
	_outDy = float32(_arg2)

	return _outDx, _outDy
}

// Transform applies all the operations from other to next.
//
// The function takes the following parameters:
//
//   - other (optional): transform to apply.
//
// The function returns the following values:
//
//   - transform: new transform.
//
func (next *Transform) Transform(other *Transform) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 *C.GskTransform // out
	var _cret *C.GskTransform // in

	if next != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(next)))
	}
	if other != nil {
		_arg1 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(other)))
	}

	_cret = C.gsk_transform_transform(_arg0, _arg1)
	runtime.KeepAlive(next)
	runtime.KeepAlive(other)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// TransformBounds transforms a graphene_rect_t using the given transform self.
//
// The result is the bounding box containing the coplanar quad.
//
// The function takes the following parameters:
//
//   - rect: graphene_rect_t.
//
// The function returns the following values:
//
//   - outRect: return location for the bounds of the transformed rectangle.
//
func (self *Transform) TransformBounds(rect *graphene.Rect) *graphene.Rect {
	var _arg0 *C.GskTransform    // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 C.graphene_rect_t  // in

	_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(rect)))

	C.gsk_transform_transform_bounds(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(rect)

	var _outRect *graphene.Rect // out

	_outRect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _outRect
}

// TransformPoint transforms a graphene_point_t using the given transform self.
//
// The function takes the following parameters:
//
//   - point: graphene_point_t.
//
// The function returns the following values:
//
//   - outPoint: return location for the transformed point.
//
func (self *Transform) TransformPoint(point *graphene.Point) *graphene.Point {
	var _arg0 *C.GskTransform     // out
	var _arg1 *C.graphene_point_t // out
	var _arg2 C.graphene_point_t  // in

	_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(point)))

	C.gsk_transform_transform_point(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(point)

	var _outPoint *graphene.Point // out

	_outPoint = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _outPoint
}

// Translate translates next in 2-dimensional space by point.
//
// The function takes the following parameters:
//
//   - point to translate the transform by.
//
// The function returns the following values:
//
//   - transform: new transform.
//
func (next *Transform) Translate(point *graphene.Point) *Transform {
	var _arg0 *C.GskTransform     // out
	var _arg1 *C.graphene_point_t // out
	var _cret *C.GskTransform     // in

	if next != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(point)))

	_cret = C.gsk_transform_translate(_arg0, _arg1)
	runtime.KeepAlive(next)
	runtime.KeepAlive(point)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Translate3D translates next by point.
//
// The function takes the following parameters:
//
//   - point to translate the transform by.
//
// The function returns the following values:
//
//   - transform: new transform.
//
func (next *Transform) Translate3D(point *graphene.Point3D) *Transform {
	var _arg0 *C.GskTransform       // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret *C.GskTransform       // in

	if next != nil {
		_arg0 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = (*C.graphene_point3d_t)(gextras.StructNative(unsafe.Pointer(point)))

	_cret = C.gsk_transform_translate_3d(_arg0, _arg1)
	runtime.KeepAlive(next)
	runtime.KeepAlive(point)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// TransformParse parses the given string into a transform and puts it in
// out_transform.
//
// Strings printed via gsk.Transform.ToString() can be read in again
// successfully using this function.
//
// If string does not describe a valid transform, FALSE is returned and NULL is
// put in out_transform.
//
// The function takes the following parameters:
//
//   - str: string to parse.
//
// The function returns the following values:
//
//   - outTransform: location to put the transform in.
//   - ok: TRUE if string described a valid transform.
//
func TransformParse(str string) (*Transform, bool) {
	var _arg1 *C.char         // out
	var _arg2 *C.GskTransform // in
	var _cret C.gboolean      // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gsk_transform_parse(_arg1, &_arg2)
	runtime.KeepAlive(str)

	var _outTransform *Transform // out
	var _ok bool                 // out

	_outTransform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_outTransform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _outTransform, _ok
}
