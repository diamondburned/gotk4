// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

//export _gotk4_gtk3_AboutDialogClass_activate_link
func _gotk4_gtk3_AboutDialogClass_activate_link(arg0 *C.GtkAboutDialog, arg1 *C.gchar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AboutDialogOverrides](instance0)
	if overrides.ActivateLink == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AboutDialogOverrides.ActivateLink, got none")
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := overrides.ActivateLink(_uri)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_AccessibleClass_connect_widget_destroyed
func _gotk4_gtk3_AccessibleClass_connect_widget_destroyed(arg0 *C.GtkAccessible) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AccessibleOverrides](instance0)
	if overrides.ConnectWidgetDestroyed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AccessibleOverrides.ConnectWidgetDestroyed, got none")
	}

	overrides.ConnectWidgetDestroyed()
}

//export _gotk4_gtk3_AccessibleClass_widget_set
func _gotk4_gtk3_AccessibleClass_widget_set(arg0 *C.GtkAccessible) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AccessibleOverrides](instance0)
	if overrides.WidgetSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AccessibleOverrides.WidgetSet, got none")
	}

	overrides.WidgetSet()
}

//export _gotk4_gtk3_AccessibleClass_widget_unset
func _gotk4_gtk3_AccessibleClass_widget_unset(arg0 *C.GtkAccessible) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AccessibleOverrides](instance0)
	if overrides.WidgetUnset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AccessibleOverrides.WidgetUnset, got none")
	}

	overrides.WidgetUnset()
}

//export _gotk4_gtk3_ActionClass_activate
func _gotk4_gtk3_ActionClass_activate(arg0 *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_ActionClass_connect_proxy
func _gotk4_gtk3_ActionClass_connect_proxy(arg0 *C.GtkAction, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.ConnectProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.ConnectProxy, got none")
	}

	var _proxy Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	overrides.ConnectProxy(_proxy)
}

//export _gotk4_gtk3_ActionClass_create_menu
func _gotk4_gtk3_ActionClass_create_menu(arg0 *C.GtkAction) (cret *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.CreateMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.CreateMenu, got none")
	}

	widget := overrides.CreateMenu()

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ActionClass_create_menu_item
func _gotk4_gtk3_ActionClass_create_menu_item(arg0 *C.GtkAction) (cret *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.CreateMenuItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.CreateMenuItem, got none")
	}

	widget := overrides.CreateMenuItem()

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ActionClass_create_tool_item
func _gotk4_gtk3_ActionClass_create_tool_item(arg0 *C.GtkAction) (cret *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.CreateToolItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.CreateToolItem, got none")
	}

	widget := overrides.CreateToolItem()

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ActionClass_disconnect_proxy
func _gotk4_gtk3_ActionClass_disconnect_proxy(arg0 *C.GtkAction, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.DisconnectProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.DisconnectProxy, got none")
	}

	var _proxy Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	overrides.DisconnectProxy(_proxy)
}

//export _gotk4_gtk3_ActionGroupClass_get_action
func _gotk4_gtk3_ActionGroupClass_get_action(arg0 *C.GtkActionGroup, arg1 *C.gchar) (cret *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionGroupOverrides](instance0)
	if overrides.Action == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionGroupOverrides.Action, got none")
	}

	var _actionName string // out

	_actionName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	action := overrides.Action(_actionName)

	var _ *Action

	cret = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	return cret
}

//export _gotk4_gtk3_AdjustmentClass_changed
func _gotk4_gtk3_AdjustmentClass_changed(arg0 *C.GtkAdjustment) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AdjustmentOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AdjustmentOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_AdjustmentClass_value_changed
func _gotk4_gtk3_AdjustmentClass_value_changed(arg0 *C.GtkAdjustment) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AdjustmentOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AdjustmentOverrides.ValueChanged, got none")
	}

	overrides.ValueChanged()
}

//export _gotk4_gtk3_AppChooserButtonClass_custom_item_activated
func _gotk4_gtk3_AppChooserButtonClass_custom_item_activated(arg0 *C.GtkAppChooserButton, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AppChooserButtonOverrides](instance0)
	if overrides.CustomItemActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AppChooserButtonOverrides.CustomItemActivated, got none")
	}

	var _itemName string // out

	_itemName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.CustomItemActivated(_itemName)
}

//export _gotk4_gtk3_AppChooserWidgetClass_application_activated
func _gotk4_gtk3_AppChooserWidgetClass_application_activated(arg0 *C.GtkAppChooserWidget, arg1 *C.GAppInfo) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AppChooserWidgetOverrides](instance0)
	if overrides.ApplicationActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AppChooserWidgetOverrides.ApplicationActivated, got none")
	}

	var _appInfo gio.AppInfor // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AppInfor)
			return ok
		})
		rv, ok := casted.(gio.AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_appInfo = rv
	}

	overrides.ApplicationActivated(_appInfo)
}

//export _gotk4_gtk3_AppChooserWidgetClass_application_selected
func _gotk4_gtk3_AppChooserWidgetClass_application_selected(arg0 *C.GtkAppChooserWidget, arg1 *C.GAppInfo) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AppChooserWidgetOverrides](instance0)
	if overrides.ApplicationSelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AppChooserWidgetOverrides.ApplicationSelected, got none")
	}

	var _appInfo gio.AppInfor // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AppInfor)
			return ok
		})
		rv, ok := casted.(gio.AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_appInfo = rv
	}

	overrides.ApplicationSelected(_appInfo)
}

//export _gotk4_gtk3_AppChooserWidgetClass_populate_popup
func _gotk4_gtk3_AppChooserWidgetClass_populate_popup(arg0 *C.GtkAppChooserWidget, arg1 *C.GtkMenu, arg2 *C.GAppInfo) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AppChooserWidgetOverrides](instance0)
	if overrides.PopulatePopup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AppChooserWidgetOverrides.PopulatePopup, got none")
	}

	var _menu *Menu           // out
	var _appInfo gio.AppInfor // out

	_menu = wrapMenu(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AppInfor)
			return ok
		})
		rv, ok := casted.(gio.AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_appInfo = rv
	}

	overrides.PopulatePopup(_menu, _appInfo)
}

//export _gotk4_gtk3_ApplicationClass_window_added
func _gotk4_gtk3_ApplicationClass_window_added(arg0 *C.GtkApplication, arg1 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ApplicationOverrides](instance0)
	if overrides.WindowAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ApplicationOverrides.WindowAdded, got none")
	}

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.WindowAdded(_window)
}

//export _gotk4_gtk3_ApplicationClass_window_removed
func _gotk4_gtk3_ApplicationClass_window_removed(arg0 *C.GtkApplication, arg1 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ApplicationOverrides](instance0)
	if overrides.WindowRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ApplicationOverrides.WindowRemoved, got none")
	}

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.WindowRemoved(_window)
}

//export _gotk4_gtk3_AssistantClass_apply
func _gotk4_gtk3_AssistantClass_apply(arg0 *C.GtkAssistant) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AssistantOverrides](instance0)
	if overrides.Apply == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AssistantOverrides.Apply, got none")
	}

	overrides.Apply()
}

//export _gotk4_gtk3_AssistantClass_cancel
func _gotk4_gtk3_AssistantClass_cancel(arg0 *C.GtkAssistant) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AssistantOverrides](instance0)
	if overrides.Cancel == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AssistantOverrides.Cancel, got none")
	}

	overrides.Cancel()
}

//export _gotk4_gtk3_AssistantClass_close
func _gotk4_gtk3_AssistantClass_close(arg0 *C.GtkAssistant) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AssistantOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AssistantOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk3_AssistantClass_prepare
func _gotk4_gtk3_AssistantClass_prepare(arg0 *C.GtkAssistant, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AssistantOverrides](instance0)
	if overrides.Prepare == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AssistantOverrides.Prepare, got none")
	}

	var _page Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}

	overrides.Prepare(_page)
}

//export _gotk4_gtk3_Assistant_ConnectEscape
func _gotk4_gtk3_Assistant_ConnectEscape(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_BuilderClass_get_type_from_name
func _gotk4_gtk3_BuilderClass_get_type_from_name(arg0 *C.GtkBuilder, arg1 *C.char) (cret C.GType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BuilderOverrides](instance0)
	if overrides.TypeFromName == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BuilderOverrides.TypeFromName, got none")
	}

	var _typeName string // out

	_typeName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	gType := overrides.TypeFromName(_typeName)

	var _ coreglib.Type

	cret = C.GType(gType)

	return cret
}

//export _gotk4_gtk3_ButtonClass_activate
func _gotk4_gtk3_ButtonClass_activate(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_ButtonClass_clicked
func _gotk4_gtk3_ButtonClass_clicked(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Clicked == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Clicked, got none")
	}

	overrides.Clicked()
}

//export _gotk4_gtk3_ButtonClass_enter
func _gotk4_gtk3_ButtonClass_enter(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Enter == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Enter, got none")
	}

	overrides.Enter()
}

//export _gotk4_gtk3_ButtonClass_leave
func _gotk4_gtk3_ButtonClass_leave(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Leave == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Leave, got none")
	}

	overrides.Leave()
}

//export _gotk4_gtk3_ButtonClass_pressed
func _gotk4_gtk3_ButtonClass_pressed(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Pressed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Pressed, got none")
	}

	overrides.Pressed()
}

//export _gotk4_gtk3_ButtonClass_released
func _gotk4_gtk3_ButtonClass_released(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Released == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Released, got none")
	}

	overrides.Released()
}

//export _gotk4_gtk3_CalendarClass_day_selected
func _gotk4_gtk3_CalendarClass_day_selected(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.DaySelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.DaySelected, got none")
	}

	overrides.DaySelected()
}

//export _gotk4_gtk3_CalendarClass_day_selected_double_click
func _gotk4_gtk3_CalendarClass_day_selected_double_click(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.DaySelectedDoubleClick == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.DaySelectedDoubleClick, got none")
	}

	overrides.DaySelectedDoubleClick()
}

//export _gotk4_gtk3_CalendarClass_month_changed
func _gotk4_gtk3_CalendarClass_month_changed(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.MonthChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.MonthChanged, got none")
	}

	overrides.MonthChanged()
}

//export _gotk4_gtk3_CalendarClass_next_month
func _gotk4_gtk3_CalendarClass_next_month(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.NextMonth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.NextMonth, got none")
	}

	overrides.NextMonth()
}

//export _gotk4_gtk3_CalendarClass_next_year
func _gotk4_gtk3_CalendarClass_next_year(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.NextYear == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.NextYear, got none")
	}

	overrides.NextYear()
}

//export _gotk4_gtk3_CalendarClass_prev_month
func _gotk4_gtk3_CalendarClass_prev_month(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.PrevMonth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.PrevMonth, got none")
	}

	overrides.PrevMonth()
}

//export _gotk4_gtk3_CalendarClass_prev_year
func _gotk4_gtk3_CalendarClass_prev_year(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.PrevYear == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.PrevYear, got none")
	}

	overrides.PrevYear()
}

//export _gotk4_gtk3_CellAccessibleClass_update_cache
func _gotk4_gtk3_CellAccessibleClass_update_cache(arg0 *C.GtkCellAccessible, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAccessibleOverrides](instance0)
	if overrides.UpdateCache == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAccessibleOverrides.UpdateCache, got none")
	}

	var _emitSignal bool // out

	if arg1 != 0 {
		_emitSignal = true
	}

	overrides.UpdateCache(_emitSignal)
}

//export _gotk4_gtk3_CellAreaClass_activate
func _gotk4_gtk3_CellAreaClass_activate(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GdkRectangle, arg4 C.GtkCellRendererState, arg5 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Activate, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _cellArea *gdk.Rectangle  // out
	var _flags CellRendererState  // out
	var _editOnly bool            // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_flags = CellRendererState(arg4)
	if arg5 != 0 {
		_editOnly = true
	}

	ok := overrides.Activate(_context, _widget, _cellArea, _flags, _editOnly)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellAreaClass_add
func _gotk4_gtk3_CellAreaClass_add(arg0 *C.GtkCellArea, arg1 *C.GtkCellRenderer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Add == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Add, got none")
	}

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	overrides.Add(_renderer)
}

//export _gotk4_gtk3_CellAreaClass_apply_attributes
func _gotk4_gtk3_CellAreaClass_apply_attributes(arg0 *C.GtkCellArea, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.gboolean, arg4 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.ApplyAttributes == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.ApplyAttributes, got none")
	}

	var _treeModel TreeModeller // out
	var _iter *TreeIter         // out
	var _isExpander bool        // out
	var _isExpanded bool        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_treeModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	if arg3 != 0 {
		_isExpander = true
	}
	if arg4 != 0 {
		_isExpanded = true
	}

	overrides.ApplyAttributes(_treeModel, _iter, _isExpander, _isExpanded)
}

//export _gotk4_gtk3_CellAreaClass_copy_context
func _gotk4_gtk3_CellAreaClass_copy_context(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext) (cret *C.GtkCellAreaContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.CopyContext == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.CopyContext, got none")
	}

	var _context *CellAreaContext // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))

	cellAreaContext := overrides.CopyContext(_context)

	var _ *CellAreaContext

	cret = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(cellAreaContext).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(cellAreaContext).Native()))

	return cret
}

//export _gotk4_gtk3_CellAreaClass_create_context
func _gotk4_gtk3_CellAreaClass_create_context(arg0 *C.GtkCellArea) (cret *C.GtkCellAreaContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.CreateContext == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.CreateContext, got none")
	}

	cellAreaContext := overrides.CreateContext()

	var _ *CellAreaContext

	cret = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(cellAreaContext).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(cellAreaContext).Native()))

	return cret
}

//export _gotk4_gtk3_CellAreaClass_event
func _gotk4_gtk3_CellAreaClass_event(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GdkEvent, arg4 *C.GdkRectangle, arg5 C.GtkCellRendererState) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Event == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Event, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _event *gdk.Event         // out
	var _cellArea *gdk.Rectangle  // out
	var _flags CellRendererState  // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg3)))
		v = gdk.CopyEventer(v)
		_event = v
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_flags = CellRendererState(arg5)

	gint := overrides.Event(_context, _widget, _event, _cellArea, _flags)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_CellAreaClass_focus
func _gotk4_gtk3_CellAreaClass_focus(arg0 *C.GtkCellArea, arg1 C.GtkDirectionType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Focus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Focus, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := overrides.Focus(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellAreaClass_get_preferred_height
func _gotk4_gtk3_CellAreaClass_get_preferred_height(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredHeight, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumHeight, naturalHeight := overrides.PreferredHeight(_context, _widget)

	var _ int
	var _ int

	*arg3 = C.gint(minimumHeight)
	*arg4 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_CellAreaClass_get_preferred_height_for_width
func _gotk4_gtk3_CellAreaClass_get_preferred_height_for_width(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 C.gint, arg4 *C.gint, arg5 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredHeightForWidth, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _width int                // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int(arg3)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_context, _widget, _width)

	var _ int
	var _ int

	*arg4 = C.gint(minimumHeight)
	*arg5 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_CellAreaClass_get_preferred_width
func _gotk4_gtk3_CellAreaClass_get_preferred_width(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredWidth, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumWidth, naturalWidth := overrides.PreferredWidth(_context, _widget)

	var _ int
	var _ int

	*arg3 = C.gint(minimumWidth)
	*arg4 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_CellAreaClass_get_preferred_width_for_height
func _gotk4_gtk3_CellAreaClass_get_preferred_width_for_height(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 C.gint, arg4 *C.gint, arg5 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredWidthForHeight, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _height int               // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_height = int(arg3)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_context, _widget, _height)

	var _ int
	var _ int

	*arg4 = C.gint(minimumWidth)
	*arg5 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_CellAreaClass_get_request_mode
func _gotk4_gtk3_CellAreaClass_get_request_mode(arg0 *C.GtkCellArea) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.RequestMode, got none")
	}

	sizeRequestMode := overrides.RequestMode()

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk3_CellAreaClass_is_activatable
func _gotk4_gtk3_CellAreaClass_is_activatable(arg0 *C.GtkCellArea) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.IsActivatable == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.IsActivatable, got none")
	}

	ok := overrides.IsActivatable()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellAreaClass_remove
func _gotk4_gtk3_CellAreaClass_remove(arg0 *C.GtkCellArea, arg1 *C.GtkCellRenderer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Remove == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Remove, got none")
	}

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	overrides.Remove(_renderer)
}

//export _gotk4_gtk3_CellAreaClass_render
func _gotk4_gtk3_CellAreaClass_render(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.cairo_t, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState, arg7 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Render == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Render, got none")
	}

	var _context *CellAreaContext      // out
	var _widget Widgetter              // out
	var _cr *cairo.Context             // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out
	var _paintFocus bool               // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg3)))
	C.cairo_reference(arg3)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)
	if arg7 != 0 {
		_paintFocus = true
	}

	overrides.Render(_context, _widget, _cr, _backgroundArea, _cellArea, _flags, _paintFocus)
}

//export _gotk4_gtk3_CellAreaContextClass_allocate
func _gotk4_gtk3_CellAreaContextClass_allocate(arg0 *C.GtkCellAreaContext, arg1 C.gint, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.Allocate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.Allocate, got none")
	}

	var _width int  // out
	var _height int // out

	_width = int(arg1)
	_height = int(arg2)

	overrides.Allocate(_width, _height)
}

//export _gotk4_gtk3_CellAreaContextClass_get_preferred_height_for_width
func _gotk4_gtk3_CellAreaContextClass_get_preferred_height_for_width(arg0 *C.GtkCellAreaContext, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.PreferredHeightForWidth, got none")
	}

	var _width int // out

	_width = int(arg1)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_width)

	var _ int
	var _ int

	*arg2 = C.gint(minimumHeight)
	*arg3 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_CellAreaContextClass_get_preferred_width_for_height
func _gotk4_gtk3_CellAreaContextClass_get_preferred_width_for_height(arg0 *C.GtkCellAreaContext, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.PreferredWidthForHeight, got none")
	}

	var _height int // out

	_height = int(arg1)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_height)

	var _ int
	var _ int

	*arg2 = C.gint(minimumWidth)
	*arg3 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_CellAreaContextClass_reset
func _gotk4_gtk3_CellAreaContextClass_reset(arg0 *C.GtkCellAreaContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.Reset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.Reset, got none")
	}

	overrides.Reset()
}

//export _gotk4_gtk3_CellRendererClass_activate
func _gotk4_gtk3_CellRendererClass_activate(arg0 *C.GtkCellRenderer, arg1 *C.GdkEvent, arg2 *C.GtkWidget, arg3 *C.gchar, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.Activate, got none")
	}

	var _event *gdk.Event              // out
	var _widget Widgetter              // out
	var _path string                   // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		v = gdk.CopyEventer(v)
		_event = v
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)

	ok := overrides.Activate(_event, _widget, _path, _backgroundArea, _cellArea, _flags)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellRendererClass_editing_canceled
func _gotk4_gtk3_CellRendererClass_editing_canceled(arg0 *C.GtkCellRenderer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.EditingCanceled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.EditingCanceled, got none")
	}

	overrides.EditingCanceled()
}

//export _gotk4_gtk3_CellRendererClass_editing_started
func _gotk4_gtk3_CellRendererClass_editing_started(arg0 *C.GtkCellRenderer, arg1 *C.GtkCellEditable, arg2 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.EditingStarted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.EditingStarted, got none")
	}

	var _editable CellEditabler // out
	var _path string            // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.EditingStarted(_editable, _path)
}

//export _gotk4_gtk3_CellRendererClass_get_aligned_area
func _gotk4_gtk3_CellRendererClass_get_aligned_area(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 C.GtkCellRendererState, arg3 *C.GdkRectangle, arg4 *C.GdkRectangle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.AlignedArea == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.AlignedArea, got none")
	}

	var _widget Widgetter        // out
	var _flags CellRendererState // out
	var _cellArea *gdk.Rectangle // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_flags = CellRendererState(arg2)
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	alignedArea := overrides.AlignedArea(_widget, _flags, _cellArea)

	var _ *gdk.Rectangle

	*arg4 = *(*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(alignedArea)))
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_height
func _gotk4_gtk3_CellRendererClass_get_preferred_height(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredHeight, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := overrides.PreferredHeight(_widget)

	var _ int
	var _ int

	*arg2 = C.gint(minimumSize)
	*arg3 = C.gint(naturalSize)
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_height_for_width
func _gotk4_gtk3_CellRendererClass_get_preferred_height_for_width(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 C.gint, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredHeightForWidth, got none")
	}

	var _widget Widgetter // out
	var _width int        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int(arg2)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_widget, _width)

	var _ int
	var _ int

	*arg3 = C.gint(minimumHeight)
	*arg4 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_width
func _gotk4_gtk3_CellRendererClass_get_preferred_width(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredWidth, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := overrides.PreferredWidth(_widget)

	var _ int
	var _ int

	*arg2 = C.gint(minimumSize)
	*arg3 = C.gint(naturalSize)
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_width_for_height
func _gotk4_gtk3_CellRendererClass_get_preferred_width_for_height(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 C.gint, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredWidthForHeight, got none")
	}

	var _widget Widgetter // out
	var _height int       // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_height = int(arg2)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_widget, _height)

	var _ int
	var _ int

	*arg3 = C.gint(minimumWidth)
	*arg4 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_CellRendererClass_get_request_mode
func _gotk4_gtk3_CellRendererClass_get_request_mode(arg0 *C.GtkCellRenderer) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.RequestMode, got none")
	}

	sizeRequestMode := overrides.RequestMode()

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk3_CellRendererClass_get_size
func _gotk4_gtk3_CellRendererClass_get_size(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 *C.GdkRectangle, arg3 *C.gint, arg4 *C.gint, arg5 *C.gint, arg6 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.Size == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.Size, got none")
	}

	var _widget Widgetter        // out
	var _cellArea *gdk.Rectangle // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	if arg2 != nil {
		_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	}

	xOffset, yOffset, width, height := overrides.Size(_widget, _cellArea)

	var _ int
	var _ int
	var _ int
	var _ int

	*arg3 = C.gint(xOffset)
	*arg4 = C.gint(yOffset)
	*arg5 = C.gint(width)
	*arg6 = C.gint(height)
}

//export _gotk4_gtk3_CellRendererClass_render
func _gotk4_gtk3_CellRendererClass_render(arg0 *C.GtkCellRenderer, arg1 *C.cairo_t, arg2 *C.GtkWidget, arg3 *C.GdkRectangle, arg4 *C.GdkRectangle, arg5 C.GtkCellRendererState) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.Render == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.Render, got none")
	}

	var _cr *cairo.Context             // out
	var _widget Widgetter              // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_flags = CellRendererState(arg5)

	overrides.Render(_cr, _widget, _backgroundArea, _cellArea, _flags)
}

//export _gotk4_gtk3_CellRendererClass_start_editing
func _gotk4_gtk3_CellRendererClass_start_editing(arg0 *C.GtkCellRenderer, arg1 *C.GdkEvent, arg2 *C.GtkWidget, arg3 *C.gchar, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState) (cret *C.GtkCellEditable) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.StartEditing == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.StartEditing, got none")
	}

	var _event *gdk.Event              // out
	var _widget Widgetter              // out
	var _path string                   // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out

	if arg1 != nil {
		{
			v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
			v = gdk.CopyEventer(v)
			_event = v
		}
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)

	cellEditable := overrides.StartEditing(_event, _widget, _path, _backgroundArea, _cellArea, _flags)

	var _ *CellEditable

	if cellEditable != nil {
		cret = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(cellEditable).Native()))
	}

	return cret
}

//export _gotk4_gtk3_CellRendererAccelClass_accel_cleared
func _gotk4_gtk3_CellRendererAccelClass_accel_cleared(arg0 *C.GtkCellRendererAccel, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererAccelOverrides](instance0)
	if overrides.AccelCleared == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererAccelOverrides.AccelCleared, got none")
	}

	var _pathString string // out

	_pathString = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.AccelCleared(_pathString)
}

//export _gotk4_gtk3_CellRendererAccelClass_accel_edited
func _gotk4_gtk3_CellRendererAccelClass_accel_edited(arg0 *C.GtkCellRendererAccel, arg1 *C.gchar, arg2 C.guint, arg3 C.GdkModifierType, arg4 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererAccelOverrides](instance0)
	if overrides.AccelEdited == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererAccelOverrides.AccelEdited, got none")
	}

	var _pathString string          // out
	var _accelKey uint              // out
	var _accelMods gdk.ModifierType // out
	var _hardwareKeycode uint       // out

	_pathString = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_accelKey = uint(arg2)
	_accelMods = gdk.ModifierType(arg3)
	_hardwareKeycode = uint(arg4)

	overrides.AccelEdited(_pathString, _accelKey, _accelMods, _hardwareKeycode)
}

//export _gotk4_gtk3_CellRendererTextClass_edited
func _gotk4_gtk3_CellRendererTextClass_edited(arg0 *C.GtkCellRendererText, arg1 *C.gchar, arg2 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererTextOverrides](instance0)
	if overrides.Edited == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererTextOverrides.Edited, got none")
	}

	var _path string    // out
	var _newText string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_newText = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.Edited(_path, _newText)
}

//export _gotk4_gtk3_CellRendererToggleClass_toggled
func _gotk4_gtk3_CellRendererToggleClass_toggled(arg0 *C.GtkCellRendererToggle, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererToggleOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererToggleOverrides.Toggled, got none")
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.Toggled(_path)
}

//export _gotk4_gtk3_CheckButtonClass_draw_indicator
func _gotk4_gtk3_CheckButtonClass_draw_indicator(arg0 *C.GtkCheckButton, arg1 *C.cairo_t) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CheckButtonOverrides](instance0)
	if overrides.DrawIndicator == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CheckButtonOverrides.DrawIndicator, got none")
	}

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	overrides.DrawIndicator(_cr)
}

//export _gotk4_gtk3_CheckMenuItemClass_draw_indicator
func _gotk4_gtk3_CheckMenuItemClass_draw_indicator(arg0 *C.GtkCheckMenuItem, arg1 *C.cairo_t) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CheckMenuItemOverrides](instance0)
	if overrides.DrawIndicator == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CheckMenuItemOverrides.DrawIndicator, got none")
	}

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	overrides.DrawIndicator(_cr)
}

//export _gotk4_gtk3_CheckMenuItemClass_toggled
func _gotk4_gtk3_CheckMenuItemClass_toggled(arg0 *C.GtkCheckMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CheckMenuItemOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CheckMenuItemOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk3_ColorButtonClass_color_set
func _gotk4_gtk3_ColorButtonClass_color_set(arg0 *C.GtkColorButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ColorButtonOverrides](instance0)
	if overrides.ColorSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ColorButtonOverrides.ColorSet, got none")
	}

	overrides.ColorSet()
}

//export _gotk4_gtk3_ColorSelectionClass_color_changed
func _gotk4_gtk3_ColorSelectionClass_color_changed(arg0 *C.GtkColorSelection) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ColorSelectionOverrides](instance0)
	if overrides.ColorChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ColorSelectionOverrides.ColorChanged, got none")
	}

	overrides.ColorChanged()
}

//export _gotk4_gtk3_ComboBoxClass_changed
func _gotk4_gtk3_ComboBoxClass_changed(arg0 *C.GtkComboBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ComboBoxOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ComboBoxOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_ComboBoxClass_format_entry_text
func _gotk4_gtk3_ComboBoxClass_format_entry_text(arg0 *C.GtkComboBox, arg1 *C.gchar) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ComboBoxOverrides](instance0)
	if overrides.FormatEntryText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ComboBoxOverrides.FormatEntryText, got none")
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	utf8 := overrides.FormatEntryText(_path)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_ContainerClass_add
func _gotk4_gtk3_ContainerClass_add(arg0 *C.GtkContainer, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.Add == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.Add, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	overrides.Add(_widget)
}

//export _gotk4_gtk3_ContainerClass_check_resize
func _gotk4_gtk3_ContainerClass_check_resize(arg0 *C.GtkContainer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.CheckResize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.CheckResize, got none")
	}

	overrides.CheckResize()
}

//export _gotk4_gtk3_ContainerClass_child_type
func _gotk4_gtk3_ContainerClass_child_type(arg0 *C.GtkContainer) (cret C.GType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.ChildType == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.ChildType, got none")
	}

	gType := overrides.ChildType()

	var _ coreglib.Type

	cret = C.GType(gType)

	return cret
}

//export _gotk4_gtk3_ContainerClass_composite_name
func _gotk4_gtk3_ContainerClass_composite_name(arg0 *C.GtkContainer, arg1 *C.GtkWidget) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.CompositeName == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.CompositeName, got none")
	}

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	utf8 := overrides.CompositeName(_child)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_ContainerClass_get_path_for_child
func _gotk4_gtk3_ContainerClass_get_path_for_child(arg0 *C.GtkContainer, arg1 *C.GtkWidget) (cret *C.GtkWidgetPath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.PathForChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.PathForChild, got none")
	}

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	widgetPath := overrides.PathForChild(_child)

	var _ *WidgetPath

	cret = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(widgetPath)))

	return cret
}

//export _gotk4_gtk3_ContainerClass_remove
func _gotk4_gtk3_ContainerClass_remove(arg0 *C.GtkContainer, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.Remove == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.Remove, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	overrides.Remove(_widget)
}

//export _gotk4_gtk3_ContainerClass_set_focus_child
func _gotk4_gtk3_ContainerClass_set_focus_child(arg0 *C.GtkContainer, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.SetFocusChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.SetFocusChild, got none")
	}

	var _child Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_child = rv
		}
	}

	overrides.SetFocusChild(_child)
}

//export _gotk4_gtk3_Container_ConnectAdd
func _gotk4_gtk3_Container_ConnectAdd(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(object Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object Widgetter))
	}

	var _object Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_object = rv
	}

	f(_object)
}

//export _gotk4_gtk3_Container_ConnectCheckResize
func _gotk4_gtk3_Container_ConnectCheckResize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Container_ConnectRemove
func _gotk4_gtk3_Container_ConnectRemove(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(object Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object Widgetter))
	}

	var _object Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_object = rv
	}

	f(_object)
}

//export _gotk4_gtk3_Container_ConnectSetFocusChild
func _gotk4_gtk3_Container_ConnectSetFocusChild(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(object Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object Widgetter))
	}

	var _object Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_object = rv
	}

	f(_object)
}

//export _gotk4_gtk3_CssProviderClass_parsing_error
func _gotk4_gtk3_CssProviderClass_parsing_error(arg0 *C.GtkCssProvider, arg1 *C.GtkCssSection, arg2 *C.GError) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CSSProviderOverrides](instance0)
	if overrides.ParsingError == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CSSProviderOverrides.ParsingError, got none")
	}

	var _section *CSSSection // out
	var _err error           // out

	_section = (*CSSSection)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gtk_css_section_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_section)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_css_section_unref((*C.GtkCssSection)(intern.C))
		},
	)
	_err = gerror.Take(unsafe.Pointer(arg2))

	overrides.ParsingError(_section, _err)
}

//export _gotk4_gtk3_DialogClass_close
func _gotk4_gtk3_DialogClass_close(arg0 *C.GtkDialog) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DialogOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DialogOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk3_DialogClass_response
func _gotk4_gtk3_DialogClass_response(arg0 *C.GtkDialog, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DialogOverrides](instance0)
	if overrides.Response == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DialogOverrides.Response, got none")
	}

	var _responseId int // out

	_responseId = int(arg1)

	overrides.Response(_responseId)
}

//export _gotk4_gtk3_EntryClass_activate
func _gotk4_gtk3_EntryClass_activate(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_EntryClass_backspace
func _gotk4_gtk3_EntryClass_backspace(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.Backspace == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.Backspace, got none")
	}

	overrides.Backspace()
}

//export _gotk4_gtk3_EntryClass_copy_clipboard
func _gotk4_gtk3_EntryClass_copy_clipboard(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.CopyClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.CopyClipboard, got none")
	}

	overrides.CopyClipboard()
}

//export _gotk4_gtk3_EntryClass_cut_clipboard
func _gotk4_gtk3_EntryClass_cut_clipboard(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.CutClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.CutClipboard, got none")
	}

	overrides.CutClipboard()
}

//export _gotk4_gtk3_EntryClass_delete_from_cursor
func _gotk4_gtk3_EntryClass_delete_from_cursor(arg0 *C.GtkEntry, arg1 C.GtkDeleteType, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.DeleteFromCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.DeleteFromCursor, got none")
	}

	var _typ DeleteType // out
	var _count int      // out

	_typ = DeleteType(arg1)
	_count = int(arg2)

	overrides.DeleteFromCursor(_typ, _count)
}

//export _gotk4_gtk3_EntryClass_get_frame_size
func _gotk4_gtk3_EntryClass_get_frame_size(arg0 *C.GtkEntry, arg1 *C.gint, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.FrameSize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.FrameSize, got none")
	}

	var _x *int      // out
	var _y *int      // out
	var _width *int  // out
	var _height *int // out

	_x = (*int)(unsafe.Pointer(arg1))
	_y = (*int)(unsafe.Pointer(arg2))
	_width = (*int)(unsafe.Pointer(arg3))
	_height = (*int)(unsafe.Pointer(arg4))

	overrides.FrameSize(_x, _y, _width, _height)
}

//export _gotk4_gtk3_EntryClass_get_text_area_size
func _gotk4_gtk3_EntryClass_get_text_area_size(arg0 *C.GtkEntry, arg1 *C.gint, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.TextAreaSize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.TextAreaSize, got none")
	}

	var _x *int      // out
	var _y *int      // out
	var _width *int  // out
	var _height *int // out

	_x = (*int)(unsafe.Pointer(arg1))
	_y = (*int)(unsafe.Pointer(arg2))
	_width = (*int)(unsafe.Pointer(arg3))
	_height = (*int)(unsafe.Pointer(arg4))

	overrides.TextAreaSize(_x, _y, _width, _height)
}

//export _gotk4_gtk3_EntryClass_insert_at_cursor
func _gotk4_gtk3_EntryClass_insert_at_cursor(arg0 *C.GtkEntry, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.InsertAtCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.InsertAtCursor, got none")
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.InsertAtCursor(_str)
}

//export _gotk4_gtk3_EntryClass_insert_emoji
func _gotk4_gtk3_EntryClass_insert_emoji(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.InsertEmoji == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.InsertEmoji, got none")
	}

	overrides.InsertEmoji()
}

//export _gotk4_gtk3_EntryClass_move_cursor
func _gotk4_gtk3_EntryClass_move_cursor(arg0 *C.GtkEntry, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.MoveCursor, got none")
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	overrides.MoveCursor(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_EntryClass_paste_clipboard
func _gotk4_gtk3_EntryClass_paste_clipboard(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.PasteClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.PasteClipboard, got none")
	}

	overrides.PasteClipboard()
}

//export _gotk4_gtk3_EntryClass_populate_popup
func _gotk4_gtk3_EntryClass_populate_popup(arg0 *C.GtkEntry, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.PopulatePopup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.PopulatePopup, got none")
	}

	var _popup Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_popup = rv
	}

	overrides.PopulatePopup(_popup)
}

//export _gotk4_gtk3_EntryClass_toggle_overwrite
func _gotk4_gtk3_EntryClass_toggle_overwrite(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.ToggleOverwrite == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.ToggleOverwrite, got none")
	}

	overrides.ToggleOverwrite()
}

//export _gotk4_gtk3_EntryBufferClass_delete_text
func _gotk4_gtk3_EntryBufferClass_delete_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 C.guint) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.DeleteText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.DeleteText, got none")
	}

	var _position uint // out
	var _nChars uint   // out

	_position = uint(arg1)
	_nChars = uint(arg2)

	guint := overrides.DeleteText(_position, _nChars)

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk3_EntryBufferClass_deleted_text
func _gotk4_gtk3_EntryBufferClass_deleted_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.DeletedText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.DeletedText, got none")
	}

	var _position uint // out
	var _nChars uint   // out

	_position = uint(arg1)
	_nChars = uint(arg2)

	overrides.DeletedText(_position, _nChars)
}

//export _gotk4_gtk3_EntryBufferClass_get_length
func _gotk4_gtk3_EntryBufferClass_get_length(arg0 *C.GtkEntryBuffer) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.Length == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.Length, got none")
	}

	guint := overrides.Length()

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk3_EntryBufferClass_get_text
func _gotk4_gtk3_EntryBufferClass_get_text(arg0 *C.GtkEntryBuffer, arg1 *C.gsize) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.Text == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.Text, got none")
	}

	var _nBytes *uint // out

	_nBytes = (*uint)(unsafe.Pointer(arg1))

	utf8 := overrides.Text(_nBytes)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_gtk3_EntryBufferClass_insert_text
func _gotk4_gtk3_EntryBufferClass_insert_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 *C.gchar, arg3 C.guint) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.InsertText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.InsertText, got none")
	}

	var _position uint // out
	var _chars string  // out
	var _nChars uint   // out

	_position = uint(arg1)
	_chars = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_nChars = uint(arg3)

	guint := overrides.InsertText(_position, _chars, _nChars)

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk3_EntryBufferClass_inserted_text
func _gotk4_gtk3_EntryBufferClass_inserted_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 *C.gchar, arg3 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.InsertedText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.InsertedText, got none")
	}

	var _position uint // out
	var _chars string  // out
	var _nChars uint   // out

	_position = uint(arg1)
	_chars = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_nChars = uint(arg3)

	overrides.InsertedText(_position, _chars, _nChars)
}

//export _gotk4_gtk3_EntryCompletionClass_action_activated
func _gotk4_gtk3_EntryCompletionClass_action_activated(arg0 *C.GtkEntryCompletion, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.ActionActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.ActionActivated, got none")
	}

	var _index_ int // out

	_index_ = int(arg1)

	overrides.ActionActivated(_index_)
}

//export _gotk4_gtk3_EntryCompletionClass_cursor_on_match
func _gotk4_gtk3_EntryCompletionClass_cursor_on_match(arg0 *C.GtkEntryCompletion, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.CursorOnMatch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.CursorOnMatch, got none")
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.CursorOnMatch(_model, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EntryCompletionClass_insert_prefix
func _gotk4_gtk3_EntryCompletionClass_insert_prefix(arg0 *C.GtkEntryCompletion, arg1 *C.gchar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.InsertPrefix == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.InsertPrefix, got none")
	}

	var _prefix string // out

	_prefix = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := overrides.InsertPrefix(_prefix)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EntryCompletionClass_match_selected
func _gotk4_gtk3_EntryCompletionClass_match_selected(arg0 *C.GtkEntryCompletion, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.MatchSelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.MatchSelected, got none")
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.MatchSelected(_model, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EntryCompletionClass_no_matches
func _gotk4_gtk3_EntryCompletionClass_no_matches(arg0 *C.GtkEntryCompletion) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.NoMatches == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.NoMatches, got none")
	}

	overrides.NoMatches()
}

//export _gotk4_gtk3_EventControllerKey_ConnectFocusIn
func _gotk4_gtk3_EventControllerKey_ConnectFocusIn(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EventControllerKey_ConnectFocusOut
func _gotk4_gtk3_EventControllerKey_ConnectFocusOut(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EventControllerKey_ConnectIMUpdate
func _gotk4_gtk3_EventControllerKey_ConnectIMUpdate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EventControllerKey_ConnectModifiers
func _gotk4_gtk3_EventControllerKey_ConnectModifiers(arg0 C.gpointer, arg1 C.GdkModifierType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object gdk.ModifierType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object gdk.ModifierType) (ok bool))
	}

	var _object gdk.ModifierType // out

	_object = gdk.ModifierType(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ExpanderClass_activate
func _gotk4_gtk3_ExpanderClass_activate(arg0 *C.GtkExpander) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ExpanderOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ExpanderOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_Expander_ConnectActivate
func _gotk4_gtk3_Expander_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserButtonClass_file_set
func _gotk4_gtk3_FileChooserButtonClass_file_set(arg0 *C.GtkFileChooserButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FileChooserButtonOverrides](instance0)
	if overrides.FileSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FileChooserButtonOverrides.FileSet, got none")
	}

	overrides.FileSet()
}

//export _gotk4_gtk3_FlowBoxClass_activate_cursor_child
func _gotk4_gtk3_FlowBoxClass_activate_cursor_child(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.ActivateCursorChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.ActivateCursorChild, got none")
	}

	overrides.ActivateCursorChild()
}

//export _gotk4_gtk3_FlowBoxClass_child_activated
func _gotk4_gtk3_FlowBoxClass_child_activated(arg0 *C.GtkFlowBox, arg1 *C.GtkFlowBoxChild) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.ChildActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.ChildActivated, got none")
	}

	var _child *FlowBoxChild // out

	_child = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.ChildActivated(_child)
}

//export _gotk4_gtk3_FlowBoxClass_move_cursor
func _gotk4_gtk3_FlowBoxClass_move_cursor(arg0 *C.GtkFlowBox, arg1 C.GtkMovementStep, arg2 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.MoveCursor, got none")
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	ok := overrides.MoveCursor(_step, _count)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_FlowBoxClass_select_all
func _gotk4_gtk3_FlowBoxClass_select_all(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.SelectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.SelectAll, got none")
	}

	overrides.SelectAll()
}

//export _gotk4_gtk3_FlowBoxClass_selected_children_changed
func _gotk4_gtk3_FlowBoxClass_selected_children_changed(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.SelectedChildrenChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.SelectedChildrenChanged, got none")
	}

	overrides.SelectedChildrenChanged()
}

//export _gotk4_gtk3_FlowBoxClass_toggle_cursor_child
func _gotk4_gtk3_FlowBoxClass_toggle_cursor_child(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.ToggleCursorChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.ToggleCursorChild, got none")
	}

	overrides.ToggleCursorChild()
}

//export _gotk4_gtk3_FlowBoxClass_unselect_all
func _gotk4_gtk3_FlowBoxClass_unselect_all(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.UnselectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.UnselectAll, got none")
	}

	overrides.UnselectAll()
}

//export _gotk4_gtk3_FlowBoxChildClass_activate
func _gotk4_gtk3_FlowBoxChildClass_activate(arg0 *C.GtkFlowBoxChild) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxChildOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxChildOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_FontButtonClass_font_set
func _gotk4_gtk3_FontButtonClass_font_set(arg0 *C.GtkFontButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FontButtonOverrides](instance0)
	if overrides.FontSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FontButtonOverrides.FontSet, got none")
	}

	overrides.FontSet()
}

//export _gotk4_gtk3_FrameClass_compute_child_allocation
func _gotk4_gtk3_FrameClass_compute_child_allocation(arg0 *C.GtkFrame, arg1 *C.GtkAllocation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FrameOverrides](instance0)
	if overrides.ComputeChildAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FrameOverrides.ComputeChildAllocation, got none")
	}

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	overrides.ComputeChildAllocation(_allocation)
}

//export _gotk4_gtk3_GLAreaClass_render
func _gotk4_gtk3_GLAreaClass_render(arg0 *C.GtkGLArea, arg1 *C.GdkGLContext) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[GLAreaOverrides](instance0)
	if overrides.Render == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected GLAreaOverrides.Render, got none")
	}

	var _context gdk.GLContexter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.GLContexter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.GLContexter)
			return ok
		})
		rv, ok := casted.(gdk.GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
		}
		_context = rv
	}

	ok := overrides.Render(_context)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_GLAreaClass_resize
func _gotk4_gtk3_GLAreaClass_resize(arg0 *C.GtkGLArea, arg1 C.int, arg2 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[GLAreaOverrides](instance0)
	if overrides.Resize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected GLAreaOverrides.Resize, got none")
	}

	var _width int  // out
	var _height int // out

	_width = int(arg1)
	_height = int(arg2)

	overrides.Resize(_width, _height)
}

//export _gotk4_gtk3_GestureStylus_ConnectDown
func _gotk4_gtk3_GestureStylus_ConnectDown(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(object, p0 float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0 float64))
	}

	var _object float64 // out
	var _p0 float64     // out

	_object = float64(arg1)
	_p0 = float64(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_GestureStylus_ConnectMotion
func _gotk4_gtk3_GestureStylus_ConnectMotion(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(object, p0 float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0 float64))
	}

	var _object float64 // out
	var _p0 float64     // out

	_object = float64(arg1)
	_p0 = float64(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_GestureStylus_ConnectProximity
func _gotk4_gtk3_GestureStylus_ConnectProximity(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(object, p0 float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0 float64))
	}

	var _object float64 // out
	var _p0 float64     // out

	_object = float64(arg1)
	_p0 = float64(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_GestureStylus_ConnectUp
func _gotk4_gtk3_GestureStylus_ConnectUp(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(object, p0 float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0 float64))
	}

	var _object float64 // out
	var _p0 float64     // out

	_object = float64(arg1)
	_p0 = float64(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_HSVClass_changed
func _gotk4_gtk3_HSVClass_changed(arg0 *C.GtkHSV) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSVOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSVOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_HSVClass_move
func _gotk4_gtk3_HSVClass_move(arg0 *C.GtkHSV, arg1 C.GtkDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSVOverrides](instance0)
	if overrides.Move == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSVOverrides.Move, got none")
	}

	var _typ DirectionType // out

	_typ = DirectionType(arg1)

	overrides.Move(_typ)
}

//export _gotk4_gtk3_HSV_ConnectChanged
func _gotk4_gtk3_HSV_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_HSV_ConnectMove
func _gotk4_gtk3_HSV_ConnectMove(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(object DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType))
	}

	var _object DirectionType // out

	_object = DirectionType(arg1)

	f(_object)
}

//export _gotk4_gtk3_HandleBoxClass_child_attached
func _gotk4_gtk3_HandleBoxClass_child_attached(arg0 *C.GtkHandleBox, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HandleBoxOverrides](instance0)
	if overrides.ChildAttached == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HandleBoxOverrides.ChildAttached, got none")
	}

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	overrides.ChildAttached(_child)
}

//export _gotk4_gtk3_HandleBoxClass_child_detached
func _gotk4_gtk3_HandleBoxClass_child_detached(arg0 *C.GtkHandleBox, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HandleBoxOverrides](instance0)
	if overrides.ChildDetached == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HandleBoxOverrides.ChildDetached, got none")
	}

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	overrides.ChildDetached(_child)
}

//export _gotk4_gtk3_IMContextClass_commit
func _gotk4_gtk3_IMContextClass_commit(arg0 *C.GtkIMContext, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.Commit == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.Commit, got none")
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.Commit(_str)
}

//export _gotk4_gtk3_IMContextClass_delete_surrounding
func _gotk4_gtk3_IMContextClass_delete_surrounding(arg0 *C.GtkIMContext, arg1 C.gint, arg2 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.DeleteSurrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.DeleteSurrounding, got none")
	}

	var _offset int // out
	var _nChars int // out

	_offset = int(arg1)
	_nChars = int(arg2)

	ok := overrides.DeleteSurrounding(_offset, _nChars)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IMContextClass_filter_keypress
func _gotk4_gtk3_IMContextClass_filter_keypress(arg0 *C.GtkIMContext, arg1 *C.GdkEventKey) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.FilterKeypress == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.FilterKeypress, got none")
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.FilterKeypress(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IMContextClass_focus_in
func _gotk4_gtk3_IMContextClass_focus_in(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.FocusIn == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.FocusIn, got none")
	}

	overrides.FocusIn()
}

//export _gotk4_gtk3_IMContextClass_focus_out
func _gotk4_gtk3_IMContextClass_focus_out(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.FocusOut == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.FocusOut, got none")
	}

	overrides.FocusOut()
}

//export _gotk4_gtk3_IMContextClass_get_preedit_string
func _gotk4_gtk3_IMContextClass_get_preedit_string(arg0 *C.GtkIMContext, arg1 **C.gchar, arg2 **C.PangoAttrList, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditString == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditString, got none")
	}

	str, attrs, cursorPos := overrides.PreeditString()

	var _ string
	var _ *pango.AttrList
	var _ int

	*arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	*arg2 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))
	*arg3 = C.gint(cursorPos)
}

//export _gotk4_gtk3_IMContextClass_get_surrounding
func _gotk4_gtk3_IMContextClass_get_surrounding(arg0 *C.GtkIMContext, arg1 **C.gchar, arg2 *C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.Surrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.Surrounding, got none")
	}

	text, cursorIndex, ok := overrides.Surrounding()

	var _ string
	var _ int
	var _ bool

	*arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	*arg2 = C.gint(cursorIndex)
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IMContextClass_preedit_changed
func _gotk4_gtk3_IMContextClass_preedit_changed(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditChanged, got none")
	}

	overrides.PreeditChanged()
}

//export _gotk4_gtk3_IMContextClass_preedit_end
func _gotk4_gtk3_IMContextClass_preedit_end(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditEnd == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditEnd, got none")
	}

	overrides.PreeditEnd()
}

//export _gotk4_gtk3_IMContextClass_preedit_start
func _gotk4_gtk3_IMContextClass_preedit_start(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditStart == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditStart, got none")
	}

	overrides.PreeditStart()
}

//export _gotk4_gtk3_IMContextClass_reset
func _gotk4_gtk3_IMContextClass_reset(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.Reset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.Reset, got none")
	}

	overrides.Reset()
}

//export _gotk4_gtk3_IMContextClass_retrieve_surrounding
func _gotk4_gtk3_IMContextClass_retrieve_surrounding(arg0 *C.GtkIMContext) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.RetrieveSurrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.RetrieveSurrounding, got none")
	}

	ok := overrides.RetrieveSurrounding()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IMContextClass_set_client_window
func _gotk4_gtk3_IMContextClass_set_client_window(arg0 *C.GtkIMContext, arg1 *C.GdkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetClientWindow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetClientWindow, got none")
	}

	var _window gdk.Windower // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Windower)
				return ok
			})
			rv, ok := casted.(gdk.Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	overrides.SetClientWindow(_window)
}

//export _gotk4_gtk3_IMContextClass_set_cursor_location
func _gotk4_gtk3_IMContextClass_set_cursor_location(arg0 *C.GtkIMContext, arg1 *C.GdkRectangle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetCursorLocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetCursorLocation, got none")
	}

	var _area *gdk.Rectangle // out

	_area = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.SetCursorLocation(_area)
}

//export _gotk4_gtk3_IMContextClass_set_surrounding
func _gotk4_gtk3_IMContextClass_set_surrounding(arg0 *C.GtkIMContext, arg1 *C.gchar, arg2 C.gint, arg3 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetSurrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetSurrounding, got none")
	}

	var _text string     // out
	var _len int         // out
	var _cursorIndex int // out

	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_len = int(arg2)
	_cursorIndex = int(arg3)

	overrides.SetSurrounding(_text, _len, _cursorIndex)
}

//export _gotk4_gtk3_IMContextClass_set_use_preedit
func _gotk4_gtk3_IMContextClass_set_use_preedit(arg0 *C.GtkIMContext, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetUsePreedit == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetUsePreedit, got none")
	}

	var _usePreedit bool // out

	if arg1 != 0 {
		_usePreedit = true
	}

	overrides.SetUsePreedit(_usePreedit)
}

//export _gotk4_gtk3_IconThemeClass_changed
func _gotk4_gtk3_IconThemeClass_changed(arg0 *C.GtkIconTheme) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconThemeOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconThemeOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_IconViewClass_activate_cursor_item
func _gotk4_gtk3_IconViewClass_activate_cursor_item(arg0 *C.GtkIconView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.ActivateCursorItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.ActivateCursorItem, got none")
	}

	ok := overrides.ActivateCursorItem()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IconViewClass_item_activated
func _gotk4_gtk3_IconViewClass_item_activated(arg0 *C.GtkIconView, arg1 *C.GtkTreePath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.ItemActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.ItemActivated, got none")
	}

	var _path *TreePath // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.ItemActivated(_path)
}

//export _gotk4_gtk3_IconViewClass_move_cursor
func _gotk4_gtk3_IconViewClass_move_cursor(arg0 *C.GtkIconView, arg1 C.GtkMovementStep, arg2 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.MoveCursor, got none")
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	ok := overrides.MoveCursor(_step, _count)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IconViewClass_select_all
func _gotk4_gtk3_IconViewClass_select_all(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.SelectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.SelectAll, got none")
	}

	overrides.SelectAll()
}

//export _gotk4_gtk3_IconViewClass_select_cursor_item
func _gotk4_gtk3_IconViewClass_select_cursor_item(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.SelectCursorItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.SelectCursorItem, got none")
	}

	overrides.SelectCursorItem()
}

//export _gotk4_gtk3_IconViewClass_selection_changed
func _gotk4_gtk3_IconViewClass_selection_changed(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.SelectionChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.SelectionChanged, got none")
	}

	overrides.SelectionChanged()
}

//export _gotk4_gtk3_IconViewClass_toggle_cursor_item
func _gotk4_gtk3_IconViewClass_toggle_cursor_item(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.ToggleCursorItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.ToggleCursorItem, got none")
	}

	overrides.ToggleCursorItem()
}

//export _gotk4_gtk3_IconViewClass_unselect_all
func _gotk4_gtk3_IconViewClass_unselect_all(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.UnselectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.UnselectAll, got none")
	}

	overrides.UnselectAll()
}

//export _gotk4_gtk3_InfoBarClass_close
func _gotk4_gtk3_InfoBarClass_close(arg0 *C.GtkInfoBar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[InfoBarOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected InfoBarOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk3_InfoBarClass_response
func _gotk4_gtk3_InfoBarClass_response(arg0 *C.GtkInfoBar, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[InfoBarOverrides](instance0)
	if overrides.Response == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected InfoBarOverrides.Response, got none")
	}

	var _responseId int // out

	_responseId = int(arg1)

	overrides.Response(_responseId)
}

//export _gotk4_gtk3_LabelClass_activate_link
func _gotk4_gtk3_LabelClass_activate_link(arg0 *C.GtkLabel, arg1 *C.gchar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LabelOverrides](instance0)
	if overrides.ActivateLink == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LabelOverrides.ActivateLink, got none")
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := overrides.ActivateLink(_uri)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_LabelClass_copy_clipboard
func _gotk4_gtk3_LabelClass_copy_clipboard(arg0 *C.GtkLabel) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LabelOverrides](instance0)
	if overrides.CopyClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LabelOverrides.CopyClipboard, got none")
	}

	overrides.CopyClipboard()
}

//export _gotk4_gtk3_LabelClass_move_cursor
func _gotk4_gtk3_LabelClass_move_cursor(arg0 *C.GtkLabel, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LabelOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LabelOverrides.MoveCursor, got none")
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	overrides.MoveCursor(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_LabelClass_populate_popup
func _gotk4_gtk3_LabelClass_populate_popup(arg0 *C.GtkLabel, arg1 *C.GtkMenu) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LabelOverrides](instance0)
	if overrides.PopulatePopup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LabelOverrides.PopulatePopup, got none")
	}

	var _menu *Menu // out

	_menu = wrapMenu(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PopulatePopup(_menu)
}

//export _gotk4_gtk3_LevelBarClass_offset_changed
func _gotk4_gtk3_LevelBarClass_offset_changed(arg0 *C.GtkLevelBar, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LevelBarOverrides](instance0)
	if overrides.OffsetChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LevelBarOverrides.OffsetChanged, got none")
	}

	var _name string // out

	_name = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.OffsetChanged(_name)
}

//export _gotk4_gtk3_LinkButtonClass_activate_link
func _gotk4_gtk3_LinkButtonClass_activate_link(arg0 *C.GtkLinkButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LinkButtonOverrides](instance0)
	if overrides.ActivateLink == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LinkButtonOverrides.ActivateLink, got none")
	}

	ok := overrides.ActivateLink()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ListBoxClass_activate_cursor_row
func _gotk4_gtk3_ListBoxClass_activate_cursor_row(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.ActivateCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.ActivateCursorRow, got none")
	}

	overrides.ActivateCursorRow()
}

//export _gotk4_gtk3_ListBoxClass_move_cursor
func _gotk4_gtk3_ListBoxClass_move_cursor(arg0 *C.GtkListBox, arg1 C.GtkMovementStep, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.MoveCursor, got none")
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	overrides.MoveCursor(_step, _count)
}

//export _gotk4_gtk3_ListBoxClass_row_activated
func _gotk4_gtk3_ListBoxClass_row_activated(arg0 *C.GtkListBox, arg1 *C.GtkListBoxRow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.RowActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.RowActivated, got none")
	}

	var _row *ListBoxRow // out

	_row = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RowActivated(_row)
}

//export _gotk4_gtk3_ListBoxClass_row_selected
func _gotk4_gtk3_ListBoxClass_row_selected(arg0 *C.GtkListBox, arg1 *C.GtkListBoxRow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.RowSelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.RowSelected, got none")
	}

	var _row *ListBoxRow // out

	_row = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RowSelected(_row)
}

//export _gotk4_gtk3_ListBoxClass_select_all
func _gotk4_gtk3_ListBoxClass_select_all(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.SelectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.SelectAll, got none")
	}

	overrides.SelectAll()
}

//export _gotk4_gtk3_ListBoxClass_selected_rows_changed
func _gotk4_gtk3_ListBoxClass_selected_rows_changed(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.SelectedRowsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.SelectedRowsChanged, got none")
	}

	overrides.SelectedRowsChanged()
}

//export _gotk4_gtk3_ListBoxClass_toggle_cursor_row
func _gotk4_gtk3_ListBoxClass_toggle_cursor_row(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.ToggleCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.ToggleCursorRow, got none")
	}

	overrides.ToggleCursorRow()
}

//export _gotk4_gtk3_ListBoxClass_unselect_all
func _gotk4_gtk3_ListBoxClass_unselect_all(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.UnselectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.UnselectAll, got none")
	}

	overrides.UnselectAll()
}

//export _gotk4_gtk3_ListBox_ConnectActivateCursorRow
func _gotk4_gtk3_ListBox_ConnectActivateCursorRow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ListBox_ConnectMoveCursor
func _gotk4_gtk3_ListBox_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.guintptr) {
	var f func(object MovementStep, p0 int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object MovementStep, p0 int))
	}

	var _object MovementStep // out
	var _p0 int              // out

	_object = MovementStep(arg1)
	_p0 = int(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_ListBox_ConnectToggleCursorRow
func _gotk4_gtk3_ListBox_ConnectToggleCursorRow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ListBoxRowClass_activate
func _gotk4_gtk3_ListBoxRowClass_activate(arg0 *C.GtkListBoxRow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxRowOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxRowOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_Menu_ConnectMoveScroll
func _gotk4_gtk3_Menu_ConnectMoveScroll(arg0 C.gpointer, arg1 C.GtkScrollType, arg2 C.guintptr) {
	var f func(scrollType ScrollType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(scrollType ScrollType))
	}

	var _scrollType ScrollType // out

	_scrollType = ScrollType(arg1)

	f(_scrollType)
}

//export _gotk4_gtk3_MenuItemClass_activate
func _gotk4_gtk3_MenuItemClass_activate(arg0 *C.GtkMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_MenuItemClass_activate_item
func _gotk4_gtk3_MenuItemClass_activate_item(arg0 *C.GtkMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.ActivateItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.ActivateItem, got none")
	}

	overrides.ActivateItem()
}

//export _gotk4_gtk3_MenuItemClass_deselect
func _gotk4_gtk3_MenuItemClass_deselect(arg0 *C.GtkMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.Deselect == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.Deselect, got none")
	}

	overrides.Deselect()
}

//export _gotk4_gtk3_MenuItemClass_get_label
func _gotk4_gtk3_MenuItemClass_get_label(arg0 *C.GtkMenuItem) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.Label == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.Label, got none")
	}

	utf8 := overrides.Label()

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_gtk3_MenuItemClass_select
func _gotk4_gtk3_MenuItemClass_select(arg0 *C.GtkMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.Select == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.Select, got none")
	}

	overrides.Select()
}

//export _gotk4_gtk3_MenuItemClass_set_label
func _gotk4_gtk3_MenuItemClass_set_label(arg0 *C.GtkMenuItem, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.SetLabel == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.SetLabel, got none")
	}

	var _label string // out

	_label = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.SetLabel(_label)
}

//export _gotk4_gtk3_MenuItemClass_toggle_size_allocate
func _gotk4_gtk3_MenuItemClass_toggle_size_allocate(arg0 *C.GtkMenuItem, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.ToggleSizeAllocate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.ToggleSizeAllocate, got none")
	}

	var _allocation int // out

	_allocation = int(arg1)

	overrides.ToggleSizeAllocate(_allocation)
}

//export _gotk4_gtk3_MenuItem_ConnectDeselect
func _gotk4_gtk3_MenuItem_ConnectDeselect(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_MenuItem_ConnectSelect
func _gotk4_gtk3_MenuItem_ConnectSelect(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_MenuItem_ConnectToggleSizeAllocate
func _gotk4_gtk3_MenuItem_ConnectToggleSizeAllocate(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) {
	var f func(object int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object int))
	}

	var _object int // out

	_object = int(arg1)

	f(_object)
}

//export _gotk4_gtk3_MenuItem_ConnectToggleSizeRequest
func _gotk4_gtk3_MenuItem_ConnectToggleSizeRequest(arg0 C.gpointer, arg1 C.gpointer, arg2 C.guintptr) {
	var f func(object unsafe.Pointer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object unsafe.Pointer))
	}

	var _object unsafe.Pointer // out

	_object = (unsafe.Pointer)(unsafe.Pointer(arg1))

	f(_object)
}

//export _gotk4_gtk3_MenuShellClass_activate_current
func _gotk4_gtk3_MenuShellClass_activate_current(arg0 *C.GtkMenuShell, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.ActivateCurrent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.ActivateCurrent, got none")
	}

	var _forceHide bool // out

	if arg1 != 0 {
		_forceHide = true
	}

	overrides.ActivateCurrent(_forceHide)
}

//export _gotk4_gtk3_MenuShellClass_cancel
func _gotk4_gtk3_MenuShellClass_cancel(arg0 *C.GtkMenuShell) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.Cancel == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.Cancel, got none")
	}

	overrides.Cancel()
}

//export _gotk4_gtk3_MenuShellClass_deactivate
func _gotk4_gtk3_MenuShellClass_deactivate(arg0 *C.GtkMenuShell) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.Deactivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.Deactivate, got none")
	}

	overrides.Deactivate()
}

//export _gotk4_gtk3_MenuShellClass_get_popup_delay
func _gotk4_gtk3_MenuShellClass_get_popup_delay(arg0 *C.GtkMenuShell) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.PopupDelay == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.PopupDelay, got none")
	}

	gint := overrides.PopupDelay()

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_MenuShellClass_insert
func _gotk4_gtk3_MenuShellClass_insert(arg0 *C.GtkMenuShell, arg1 *C.GtkWidget, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.Insert == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.Insert, got none")
	}

	var _child Widgetter // out
	var _position int    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_position = int(arg2)

	overrides.Insert(_child, _position)
}

//export _gotk4_gtk3_MenuShellClass_move_current
func _gotk4_gtk3_MenuShellClass_move_current(arg0 *C.GtkMenuShell, arg1 C.GtkMenuDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.MoveCurrent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.MoveCurrent, got none")
	}

	var _direction MenuDirectionType // out

	_direction = MenuDirectionType(arg1)

	overrides.MoveCurrent(_direction)
}

//export _gotk4_gtk3_MenuShellClass_move_selected
func _gotk4_gtk3_MenuShellClass_move_selected(arg0 *C.GtkMenuShell, arg1 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.MoveSelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.MoveSelected, got none")
	}

	var _distance int // out

	_distance = int(arg1)

	ok := overrides.MoveSelected(_distance)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_MenuShellClass_select_item
func _gotk4_gtk3_MenuShellClass_select_item(arg0 *C.GtkMenuShell, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.SelectItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.SelectItem, got none")
	}

	var _menuItem Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_menuItem = rv
	}

	overrides.SelectItem(_menuItem)
}

//export _gotk4_gtk3_MenuShellClass_selection_done
func _gotk4_gtk3_MenuShellClass_selection_done(arg0 *C.GtkMenuShell) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.SelectionDone == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.SelectionDone, got none")
	}

	overrides.SelectionDone()
}

//export _gotk4_gtk3_MenuToolButtonClass_show_menu
func _gotk4_gtk3_MenuToolButtonClass_show_menu(arg0 *C.GtkMenuToolButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuToolButtonOverrides](instance0)
	if overrides.ShowMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuToolButtonOverrides.ShowMenu, got none")
	}

	overrides.ShowMenu()
}

//export _gotk4_gtk3_NativeDialogClass_hide
func _gotk4_gtk3_NativeDialogClass_hide(arg0 *C.GtkNativeDialog) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NativeDialogOverrides](instance0)
	if overrides.Hide == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NativeDialogOverrides.Hide, got none")
	}

	overrides.Hide()
}

//export _gotk4_gtk3_NativeDialogClass_response
func _gotk4_gtk3_NativeDialogClass_response(arg0 *C.GtkNativeDialog, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NativeDialogOverrides](instance0)
	if overrides.Response == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NativeDialogOverrides.Response, got none")
	}

	var _responseId int // out

	_responseId = int(arg1)

	overrides.Response(_responseId)
}

//export _gotk4_gtk3_NativeDialogClass_show
func _gotk4_gtk3_NativeDialogClass_show(arg0 *C.GtkNativeDialog) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NativeDialogOverrides](instance0)
	if overrides.Show == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NativeDialogOverrides.Show, got none")
	}

	overrides.Show()
}

//export _gotk4_gtk3_NotebookClass_change_current_page
func _gotk4_gtk3_NotebookClass_change_current_page(arg0 *C.GtkNotebook, arg1 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.ChangeCurrentPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.ChangeCurrentPage, got none")
	}

	var _offset int // out

	_offset = int(arg1)

	ok := overrides.ChangeCurrentPage(_offset)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_focus_tab
func _gotk4_gtk3_NotebookClass_focus_tab(arg0 *C.GtkNotebook, arg1 C.GtkNotebookTab) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.FocusTab == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.FocusTab, got none")
	}

	var _typ NotebookTab // out

	_typ = NotebookTab(arg1)

	ok := overrides.FocusTab(_typ)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_insert_page
func _gotk4_gtk3_NotebookClass_insert_page(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 *C.GtkWidget, arg3 *C.GtkWidget, arg4 C.gint) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.InsertPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.InsertPage, got none")
	}

	var _child Widgetter     // out
	var _tabLabel Widgetter  // out
	var _menuLabel Widgetter // out
	var _position int        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_tabLabel = rv
	}
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_menuLabel = rv
	}
	_position = int(arg4)

	gint := overrides.InsertPage(_child, _tabLabel, _menuLabel, _position)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_NotebookClass_move_focus_out
func _gotk4_gtk3_NotebookClass_move_focus_out(arg0 *C.GtkNotebook, arg1 C.GtkDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.MoveFocusOut == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.MoveFocusOut, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	overrides.MoveFocusOut(_direction)
}

//export _gotk4_gtk3_NotebookClass_page_added
func _gotk4_gtk3_NotebookClass_page_added(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.PageAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.PageAdded, got none")
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	overrides.PageAdded(_child, _pageNum)
}

//export _gotk4_gtk3_NotebookClass_page_removed
func _gotk4_gtk3_NotebookClass_page_removed(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.PageRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.PageRemoved, got none")
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	overrides.PageRemoved(_child, _pageNum)
}

//export _gotk4_gtk3_NotebookClass_page_reordered
func _gotk4_gtk3_NotebookClass_page_reordered(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.PageReordered == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.PageReordered, got none")
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	overrides.PageReordered(_child, _pageNum)
}

//export _gotk4_gtk3_NotebookClass_reorder_tab
func _gotk4_gtk3_NotebookClass_reorder_tab(arg0 *C.GtkNotebook, arg1 C.GtkDirectionType, arg2 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.ReorderTab == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.ReorderTab, got none")
	}

	var _direction DirectionType // out
	var _moveToLast bool         // out

	_direction = DirectionType(arg1)
	if arg2 != 0 {
		_moveToLast = true
	}

	ok := overrides.ReorderTab(_direction, _moveToLast)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_select_page
func _gotk4_gtk3_NotebookClass_select_page(arg0 *C.GtkNotebook, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.SelectPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.SelectPage, got none")
	}

	var _moveFocus bool // out

	if arg1 != 0 {
		_moveFocus = true
	}

	ok := overrides.SelectPage(_moveFocus)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_switch_page
func _gotk4_gtk3_NotebookClass_switch_page(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.SwitchPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.SwitchPage, got none")
	}

	var _page Widgetter // out
	var _pageNum uint   // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}
	_pageNum = uint(arg2)

	overrides.SwitchPage(_page, _pageNum)
}

//export _gotk4_gtk3_Notebook_ConnectChangeCurrentPage
func _gotk4_gtk3_Notebook_ConnectChangeCurrentPage(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object int) (ok bool))
	}

	var _object int // out

	_object = int(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Notebook_ConnectFocusTab
func _gotk4_gtk3_Notebook_ConnectFocusTab(arg0 C.gpointer, arg1 C.GtkNotebookTab, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object NotebookTab) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object NotebookTab) (ok bool))
	}

	var _object NotebookTab // out

	_object = NotebookTab(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Notebook_ConnectMoveFocusOut
func _gotk4_gtk3_Notebook_ConnectMoveFocusOut(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(object DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType))
	}

	var _object DirectionType // out

	_object = DirectionType(arg1)

	f(_object)
}

//export _gotk4_gtk3_Notebook_ConnectReorderTab
func _gotk4_gtk3_Notebook_ConnectReorderTab(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.gboolean, arg3 C.guintptr) (cret C.gboolean) {
	var f func(object DirectionType, p0 bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType, p0 bool) (ok bool))
	}

	var _object DirectionType // out
	var _p0 bool              // out

	_object = DirectionType(arg1)
	if arg2 != 0 {
		_p0 = true
	}

	ok := f(_object, _p0)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Notebook_ConnectSelectPage
func _gotk4_gtk3_Notebook_ConnectSelectPage(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object bool) (ok bool))
	}

	var _object bool // out

	if arg1 != 0 {
		_object = true
	}

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_OverlayClass_get_child_position
func _gotk4_gtk3_OverlayClass_get_child_position(arg0 *C.GtkOverlay, arg1 *C.GtkWidget, arg2 *C.GtkAllocation) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[OverlayOverrides](instance0)
	if overrides.ChildPosition == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected OverlayOverrides.ChildPosition, got none")
	}

	var _widget Widgetter       // out
	var _allocation *Allocation // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	ok := overrides.ChildPosition(_widget, _allocation)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_accept_position
func _gotk4_gtk3_PanedClass_accept_position(arg0 *C.GtkPaned) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.AcceptPosition == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.AcceptPosition, got none")
	}

	ok := overrides.AcceptPosition()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_cancel_position
func _gotk4_gtk3_PanedClass_cancel_position(arg0 *C.GtkPaned) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.CancelPosition == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.CancelPosition, got none")
	}

	ok := overrides.CancelPosition()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_cycle_child_focus
func _gotk4_gtk3_PanedClass_cycle_child_focus(arg0 *C.GtkPaned, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.CycleChildFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.CycleChildFocus, got none")
	}

	var _reverse bool // out

	if arg1 != 0 {
		_reverse = true
	}

	ok := overrides.CycleChildFocus(_reverse)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_cycle_handle_focus
func _gotk4_gtk3_PanedClass_cycle_handle_focus(arg0 *C.GtkPaned, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.CycleHandleFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.CycleHandleFocus, got none")
	}

	var _reverse bool // out

	if arg1 != 0 {
		_reverse = true
	}

	ok := overrides.CycleHandleFocus(_reverse)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_move_handle
func _gotk4_gtk3_PanedClass_move_handle(arg0 *C.GtkPaned, arg1 C.GtkScrollType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.MoveHandle == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.MoveHandle, got none")
	}

	var _scroll ScrollType // out

	_scroll = ScrollType(arg1)

	ok := overrides.MoveHandle(_scroll)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_toggle_handle_focus
func _gotk4_gtk3_PanedClass_toggle_handle_focus(arg0 *C.GtkPaned) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.ToggleHandleFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.ToggleHandleFocus, got none")
	}

	ok := overrides.ToggleHandleFocus()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PlugClass_embedded
func _gotk4_gtk3_PlugClass_embedded(arg0 *C.GtkPlug) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PlugOverrides](instance0)
	if overrides.Embedded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PlugOverrides.Embedded, got none")
	}

	overrides.Embedded()
}

//export _gotk4_gtk3_PopoverClass_closed
func _gotk4_gtk3_PopoverClass_closed(arg0 *C.GtkPopover) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PopoverOverrides](instance0)
	if overrides.Closed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PopoverOverrides.Closed, got none")
	}

	overrides.Closed()
}

//export _gotk4_gtk3_PrintOperationClass_begin_print
func _gotk4_gtk3_PrintOperationClass_begin_print(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.BeginPrint == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.BeginPrint, got none")
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.BeginPrint(_context)
}

//export _gotk4_gtk3_PrintOperationClass_custom_widget_apply
func _gotk4_gtk3_PrintOperationClass_custom_widget_apply(arg0 *C.GtkPrintOperation, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.CustomWidgetApply == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.CustomWidgetApply, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	overrides.CustomWidgetApply(_widget)
}

//export _gotk4_gtk3_PrintOperationClass_done
func _gotk4_gtk3_PrintOperationClass_done(arg0 *C.GtkPrintOperation, arg1 C.GtkPrintOperationResult) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.Done == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.Done, got none")
	}

	var _result PrintOperationResult // out

	_result = PrintOperationResult(arg1)

	overrides.Done(_result)
}

//export _gotk4_gtk3_PrintOperationClass_draw_page
func _gotk4_gtk3_PrintOperationClass_draw_page(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.DrawPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.DrawPage, got none")
	}

	var _context *PrintContext // out
	var _pageNr int            // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int(arg2)

	overrides.DrawPage(_context, _pageNr)
}

//export _gotk4_gtk3_PrintOperationClass_end_print
func _gotk4_gtk3_PrintOperationClass_end_print(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.EndPrint == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.EndPrint, got none")
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.EndPrint(_context)
}

//export _gotk4_gtk3_PrintOperationClass_paginate
func _gotk4_gtk3_PrintOperationClass_paginate(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.Paginate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.Paginate, got none")
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	ok := overrides.Paginate(_context)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PrintOperationClass_preview
func _gotk4_gtk3_PrintOperationClass_preview(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintOperationPreview, arg2 *C.GtkPrintContext, arg3 *C.GtkWindow) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.Preview == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.Preview, got none")
	}

	var _preview PrintOperationPreviewer // out
	var _context *PrintContext           // out
	var _parent *Window                  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.PrintOperationPreviewer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PrintOperationPreviewer)
			return ok
		})
		rv, ok := casted.(PrintOperationPreviewer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.PrintOperationPreviewer")
		}
		_preview = rv
	}
	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg2)))
	_parent = wrapWindow(coreglib.Take(unsafe.Pointer(arg3)))

	ok := overrides.Preview(_preview, _context, _parent)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PrintOperationClass_request_page_setup
func _gotk4_gtk3_PrintOperationClass_request_page_setup(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext, arg2 C.gint, arg3 *C.GtkPageSetup) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.RequestPageSetup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.RequestPageSetup, got none")
	}

	var _context *PrintContext // out
	var _pageNr int            // out
	var _setup *PageSetup      // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int(arg2)
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg3)))

	overrides.RequestPageSetup(_context, _pageNr, _setup)
}

//export _gotk4_gtk3_PrintOperationClass_status_changed
func _gotk4_gtk3_PrintOperationClass_status_changed(arg0 *C.GtkPrintOperation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.StatusChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.StatusChanged, got none")
	}

	overrides.StatusChanged()
}

//export _gotk4_gtk3_PrintOperationClass_update_custom_widget
func _gotk4_gtk3_PrintOperationClass_update_custom_widget(arg0 *C.GtkPrintOperation, arg1 *C.GtkWidget, arg2 *C.GtkPageSetup, arg3 *C.GtkPrintSettings) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.UpdateCustomWidget == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.UpdateCustomWidget, got none")
	}

	var _widget Widgetter        // out
	var _setup *PageSetup        // out
	var _settings *PrintSettings // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg2)))
	_settings = wrapPrintSettings(coreglib.Take(unsafe.Pointer(arg3)))

	overrides.UpdateCustomWidget(_widget, _setup, _settings)
}

//export _gotk4_gtk3_RadioActionClass_changed
func _gotk4_gtk3_RadioActionClass_changed(arg0 *C.GtkRadioAction, arg1 *C.GtkRadioAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RadioActionOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RadioActionOverrides.Changed, got none")
	}

	var _current *RadioAction // out

	_current = wrapRadioAction(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.Changed(_current)
}

//export _gotk4_gtk3_RadioButtonClass_group_changed
func _gotk4_gtk3_RadioButtonClass_group_changed(arg0 *C.GtkRadioButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RadioButtonOverrides](instance0)
	if overrides.GroupChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RadioButtonOverrides.GroupChanged, got none")
	}

	overrides.GroupChanged()
}

//export _gotk4_gtk3_RadioMenuItemClass_group_changed
func _gotk4_gtk3_RadioMenuItemClass_group_changed(arg0 *C.GtkRadioMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RadioMenuItemOverrides](instance0)
	if overrides.GroupChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RadioMenuItemOverrides.GroupChanged, got none")
	}

	overrides.GroupChanged()
}

//export _gotk4_gtk3_RadioMenuItem_ConnectGroupChanged
func _gotk4_gtk3_RadioMenuItem_ConnectGroupChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_RangeClass_adjust_bounds
func _gotk4_gtk3_RangeClass_adjust_bounds(arg0 *C.GtkRange, arg1 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.AdjustBounds == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.AdjustBounds, got none")
	}

	var _newValue float64 // out

	_newValue = float64(arg1)

	overrides.AdjustBounds(_newValue)
}

//export _gotk4_gtk3_RangeClass_change_value
func _gotk4_gtk3_RangeClass_change_value(arg0 *C.GtkRange, arg1 C.GtkScrollType, arg2 C.gdouble) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.ChangeValue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.ChangeValue, got none")
	}

	var _scroll ScrollType // out
	var _newValue float64  // out

	_scroll = ScrollType(arg1)
	_newValue = float64(arg2)

	ok := overrides.ChangeValue(_scroll, _newValue)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_RangeClass_get_range_border
func _gotk4_gtk3_RangeClass_get_range_border(arg0 *C.GtkRange, arg1 *C.GtkBorder) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.RangeBorder == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.RangeBorder, got none")
	}

	var _border_ *Border // out

	_border_ = (*Border)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.RangeBorder(_border_)
}

//export _gotk4_gtk3_RangeClass_get_range_size_request
func _gotk4_gtk3_RangeClass_get_range_size_request(arg0 *C.GtkRange, arg1 C.GtkOrientation, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.RangeSizeRequest == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.RangeSizeRequest, got none")
	}

	var _orientation Orientation // out
	var _minimum *int            // out
	var _natural *int            // out

	_orientation = Orientation(arg1)
	_minimum = (*int)(unsafe.Pointer(arg2))
	_natural = (*int)(unsafe.Pointer(arg3))

	overrides.RangeSizeRequest(_orientation, _minimum, _natural)
}

//export _gotk4_gtk3_RangeClass_move_slider
func _gotk4_gtk3_RangeClass_move_slider(arg0 *C.GtkRange, arg1 C.GtkScrollType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.MoveSlider == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.MoveSlider, got none")
	}

	var _scroll ScrollType // out

	_scroll = ScrollType(arg1)

	overrides.MoveSlider(_scroll)
}

//export _gotk4_gtk3_RangeClass_value_changed
func _gotk4_gtk3_RangeClass_value_changed(arg0 *C.GtkRange) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.ValueChanged, got none")
	}

	overrides.ValueChanged()
}

//export _gotk4_gtk3_RcStyleClass_merge
func _gotk4_gtk3_RcStyleClass_merge(arg0 *C.GtkRcStyle, arg1 *C.GtkRcStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RCStyleOverrides](instance0)
	if overrides.Merge == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RCStyleOverrides.Merge, got none")
	}

	var _src *RCStyle // out

	_src = wrapRCStyle(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.Merge(_src)
}

//export _gotk4_gtk3_RcStyleClass_parse
func _gotk4_gtk3_RcStyleClass_parse(arg0 *C.GtkRcStyle, arg1 *C.GtkSettings, arg2 *C.GScanner) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RCStyleOverrides](instance0)
	if overrides.Parse == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RCStyleOverrides.Parse, got none")
	}

	var _settings *Settings    // out
	var _scanner *glib.Scanner // out

	_settings = wrapSettings(coreglib.Take(unsafe.Pointer(arg1)))
	_scanner = (*glib.Scanner)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	guint := overrides.Parse(_settings, _scanner)

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk3_RecentManagerClass_changed
func _gotk4_gtk3_RecentManagerClass_changed(arg0 *C.GtkRecentManager) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RecentManagerOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RecentManagerOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_ScaleClass_draw_value
func _gotk4_gtk3_ScaleClass_draw_value(arg0 *C.GtkScale) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleOverrides](instance0)
	if overrides.DrawValue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleOverrides.DrawValue, got none")
	}

	overrides.DrawValue()
}

//export _gotk4_gtk3_ScaleClass_format_value
func _gotk4_gtk3_ScaleClass_format_value(arg0 *C.GtkScale, arg1 C.gdouble) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleOverrides](instance0)
	if overrides.FormatValue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleOverrides.FormatValue, got none")
	}

	var _value float64 // out

	_value = float64(arg1)

	utf8 := overrides.FormatValue(_value)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_ScaleClass_get_layout_offsets
func _gotk4_gtk3_ScaleClass_get_layout_offsets(arg0 *C.GtkScale, arg1 *C.gint, arg2 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleOverrides](instance0)
	if overrides.LayoutOffsets == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleOverrides.LayoutOffsets, got none")
	}

	x, y := overrides.LayoutOffsets()

	var _ int
	var _ int

	*arg1 = C.gint(x)
	*arg2 = C.gint(y)
}

//export _gotk4_gtk3_ScaleButtonClass_value_changed
func _gotk4_gtk3_ScaleButtonClass_value_changed(arg0 *C.GtkScaleButton, arg1 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleButtonOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleButtonOverrides.ValueChanged, got none")
	}

	var _value float64 // out

	_value = float64(arg1)

	overrides.ValueChanged(_value)
}

//export _gotk4_gtk3_ScrolledWindowClass_move_focus_out
func _gotk4_gtk3_ScrolledWindowClass_move_focus_out(arg0 *C.GtkScrolledWindow, arg1 C.GtkDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScrolledWindowOverrides](instance0)
	if overrides.MoveFocusOut == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScrolledWindowOverrides.MoveFocusOut, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	overrides.MoveFocusOut(_direction)
}

//export _gotk4_gtk3_ScrolledWindowClass_scroll_child
func _gotk4_gtk3_ScrolledWindowClass_scroll_child(arg0 *C.GtkScrolledWindow, arg1 C.GtkScrollType, arg2 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScrolledWindowOverrides](instance0)
	if overrides.ScrollChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScrolledWindowOverrides.ScrollChild, got none")
	}

	var _scroll ScrollType // out
	var _horizontal bool   // out

	_scroll = ScrollType(arg1)
	if arg2 != 0 {
		_horizontal = true
	}

	ok := overrides.ScrollChild(_scroll, _horizontal)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_SearchEntryClass_next_match
func _gotk4_gtk3_SearchEntryClass_next_match(arg0 *C.GtkSearchEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SearchEntryOverrides](instance0)
	if overrides.NextMatch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SearchEntryOverrides.NextMatch, got none")
	}

	overrides.NextMatch()
}

//export _gotk4_gtk3_SearchEntryClass_previous_match
func _gotk4_gtk3_SearchEntryClass_previous_match(arg0 *C.GtkSearchEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SearchEntryOverrides](instance0)
	if overrides.PreviousMatch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SearchEntryOverrides.PreviousMatch, got none")
	}

	overrides.PreviousMatch()
}

//export _gotk4_gtk3_SearchEntryClass_search_changed
func _gotk4_gtk3_SearchEntryClass_search_changed(arg0 *C.GtkSearchEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SearchEntryOverrides](instance0)
	if overrides.SearchChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SearchEntryOverrides.SearchChanged, got none")
	}

	overrides.SearchChanged()
}

//export _gotk4_gtk3_SearchEntryClass_stop_search
func _gotk4_gtk3_SearchEntryClass_stop_search(arg0 *C.GtkSearchEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SearchEntryOverrides](instance0)
	if overrides.StopSearch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SearchEntryOverrides.StopSearch, got none")
	}

	overrides.StopSearch()
}

//export _gotk4_gtk3_ShortcutsSection_ConnectChangeCurrentPage
func _gotk4_gtk3_ShortcutsSection_ConnectChangeCurrentPage(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object int) (ok bool))
	}

	var _object int // out

	_object = int(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ShortcutsWindowClass_close
func _gotk4_gtk3_ShortcutsWindowClass_close(arg0 *C.GtkShortcutsWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ShortcutsWindowOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ShortcutsWindowOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk3_ShortcutsWindowClass_search
func _gotk4_gtk3_ShortcutsWindowClass_search(arg0 *C.GtkShortcutsWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ShortcutsWindowOverrides](instance0)
	if overrides.Search == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ShortcutsWindowOverrides.Search, got none")
	}

	overrides.Search()
}

//export _gotk4_gtk3_SocketClass_plug_added
func _gotk4_gtk3_SocketClass_plug_added(arg0 *C.GtkSocket) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SocketOverrides](instance0)
	if overrides.PlugAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SocketOverrides.PlugAdded, got none")
	}

	overrides.PlugAdded()
}

//export _gotk4_gtk3_SocketClass_plug_removed
func _gotk4_gtk3_SocketClass_plug_removed(arg0 *C.GtkSocket) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SocketOverrides](instance0)
	if overrides.PlugRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SocketOverrides.PlugRemoved, got none")
	}

	ok := overrides.PlugRemoved()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_SpinButtonClass_change_value
func _gotk4_gtk3_SpinButtonClass_change_value(arg0 *C.GtkSpinButton, arg1 C.GtkScrollType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.ChangeValue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.ChangeValue, got none")
	}

	var _scroll ScrollType // out

	_scroll = ScrollType(arg1)

	overrides.ChangeValue(_scroll)
}

//export _gotk4_gtk3_SpinButtonClass_input
func _gotk4_gtk3_SpinButtonClass_input(arg0 *C.GtkSpinButton, arg1 *C.gdouble) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.Input == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.Input, got none")
	}

	var _newValue *float64 // out

	_newValue = (*float64)(unsafe.Pointer(arg1))

	gint := overrides.Input(_newValue)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_SpinButtonClass_output
func _gotk4_gtk3_SpinButtonClass_output(arg0 *C.GtkSpinButton) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.Output == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.Output, got none")
	}

	gint := overrides.Output()

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_SpinButtonClass_value_changed
func _gotk4_gtk3_SpinButtonClass_value_changed(arg0 *C.GtkSpinButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.ValueChanged, got none")
	}

	overrides.ValueChanged()
}

//export _gotk4_gtk3_SpinButtonClass_wrapped
func _gotk4_gtk3_SpinButtonClass_wrapped(arg0 *C.GtkSpinButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.Wrapped == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.Wrapped, got none")
	}

	overrides.Wrapped()
}

//export _gotk4_gtk3_StatusIconClass_activate
func _gotk4_gtk3_StatusIconClass_activate(arg0 *C.GtkStatusIcon) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_StatusIconClass_button_press_event
func _gotk4_gtk3_StatusIconClass_button_press_event(arg0 *C.GtkStatusIcon, arg1 *C.GdkEventButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.ButtonPressEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.ButtonPressEvent, got none")
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ButtonPressEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_button_release_event
func _gotk4_gtk3_StatusIconClass_button_release_event(arg0 *C.GtkStatusIcon, arg1 *C.GdkEventButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.ButtonReleaseEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.ButtonReleaseEvent, got none")
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ButtonReleaseEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_popup_menu
func _gotk4_gtk3_StatusIconClass_popup_menu(arg0 *C.GtkStatusIcon, arg1 C.guint, arg2 C.guint32) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.PopupMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.PopupMenu, got none")
	}

	var _button uint         // out
	var _activateTime uint32 // out

	_button = uint(arg1)
	_activateTime = uint32(arg2)

	overrides.PopupMenu(_button, _activateTime)
}

//export _gotk4_gtk3_StatusIconClass_query_tooltip
func _gotk4_gtk3_StatusIconClass_query_tooltip(arg0 *C.GtkStatusIcon, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.GtkTooltip) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.QueryTooltip == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.QueryTooltip, got none")
	}

	var _x int             // out
	var _y int             // out
	var _keyboardMode bool // out
	var _tooltip *Tooltip  // out

	_x = int(arg1)
	_y = int(arg2)
	if arg3 != 0 {
		_keyboardMode = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := overrides.QueryTooltip(_x, _y, _keyboardMode, _tooltip)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_scroll_event
func _gotk4_gtk3_StatusIconClass_scroll_event(arg0 *C.GtkStatusIcon, arg1 *C.GdkEventScroll) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.ScrollEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.ScrollEvent, got none")
	}

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ScrollEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_size_changed
func _gotk4_gtk3_StatusIconClass_size_changed(arg0 *C.GtkStatusIcon, arg1 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.SizeChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.SizeChanged, got none")
	}

	var _size int // out

	_size = int(arg1)

	ok := overrides.SizeChanged(_size)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusbarClass_text_popped
func _gotk4_gtk3_StatusbarClass_text_popped(arg0 *C.GtkStatusbar, arg1 C.guint, arg2 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusbarOverrides](instance0)
	if overrides.TextPopped == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusbarOverrides.TextPopped, got none")
	}

	var _contextId uint // out
	var _text string    // out

	_contextId = uint(arg1)
	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.TextPopped(_contextId, _text)
}

//export _gotk4_gtk3_StatusbarClass_text_pushed
func _gotk4_gtk3_StatusbarClass_text_pushed(arg0 *C.GtkStatusbar, arg1 C.guint, arg2 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusbarOverrides](instance0)
	if overrides.TextPushed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusbarOverrides.TextPushed, got none")
	}

	var _contextId uint // out
	var _text string    // out

	_contextId = uint(arg1)
	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.TextPushed(_contextId, _text)
}

//export _gotk4_gtk3_StyleClass_copy
func _gotk4_gtk3_StyleClass_copy(arg0 *C.GtkStyle, arg1 *C.GtkStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.Copy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.Copy, got none")
	}

	var _src *Style // out

	_src = wrapStyle(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.Copy(_src)
}

//export _gotk4_gtk3_StyleClass_draw_arrow
func _gotk4_gtk3_StyleClass_draw_arrow(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.GtkArrowType, arg7 C.gboolean, arg8 C.gint, arg9 C.gint, arg10 C.gint, arg11 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawArrow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawArrow, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _arrowType ArrowType   // out
	var _fill bool             // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_arrowType = ArrowType(arg6)
	if arg7 != 0 {
		_fill = true
	}
	_x = int(arg8)
	_y = int(arg9)
	_width = int(arg10)
	_height = int(arg11)

	overrides.DrawArrow(_cr, _stateType, _shadowType, _widget, _detail, _arrowType, _fill, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_box
func _gotk4_gtk3_StyleClass_draw_box(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawBox == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawBox, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawBox(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_box_gap
func _gotk4_gtk3_StyleClass_draw_box_gap(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkPositionType, arg11 C.gint, arg12 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawBoxGap == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawBoxGap, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out
	var _gapSide PositionType  // out
	var _gapX int              // out
	var _gapWidth int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_gapSide = PositionType(arg10)
	_gapX = int(arg11)
	_gapWidth = int(arg12)

	overrides.DrawBoxGap(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _gapSide, _gapX, _gapWidth)
}

//export _gotk4_gtk3_StyleClass_draw_check
func _gotk4_gtk3_StyleClass_draw_check(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawCheck == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawCheck, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawCheck(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_diamond
func _gotk4_gtk3_StyleClass_draw_diamond(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawDiamond == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawDiamond, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawDiamond(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_expander
func _gotk4_gtk3_StyleClass_draw_expander(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.gint, arg6 C.gint, arg7 C.GtkExpanderStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawExpander == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawExpander, got none")
	}

	var _cr *cairo.Context           // out
	var _stateType StateType         // out
	var _widget Widgetter            // out
	var _detail string               // out
	var _x int                       // out
	var _y int                       // out
	var _expanderStyle ExpanderStyle // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_x = int(arg5)
	_y = int(arg6)
	_expanderStyle = ExpanderStyle(arg7)

	overrides.DrawExpander(_cr, _stateType, _widget, _detail, _x, _y, _expanderStyle)
}

//export _gotk4_gtk3_StyleClass_draw_extension
func _gotk4_gtk3_StyleClass_draw_extension(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkPositionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawExtension == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawExtension, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out
	var _gapSide PositionType  // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_gapSide = PositionType(arg10)

	overrides.DrawExtension(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _gapSide)
}

//export _gotk4_gtk3_StyleClass_draw_flat_box
func _gotk4_gtk3_StyleClass_draw_flat_box(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawFlatBox == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawFlatBox, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawFlatBox(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_focus
func _gotk4_gtk3_StyleClass_draw_focus(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.gint, arg6 C.gint, arg7 C.gint, arg8 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawFocus, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _x int               // out
	var _y int               // out
	var _width int           // out
	var _height int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_x = int(arg5)
	_y = int(arg6)
	_width = int(arg7)
	_height = int(arg8)

	overrides.DrawFocus(_cr, _stateType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_handle
func _gotk4_gtk3_StyleClass_draw_handle(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkOrientation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawHandle == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawHandle, got none")
	}

	var _cr *cairo.Context       // out
	var _stateType StateType     // out
	var _shadowType ShadowType   // out
	var _widget Widgetter        // out
	var _detail string           // out
	var _x int                   // out
	var _y int                   // out
	var _width int               // out
	var _height int              // out
	var _orientation Orientation // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_orientation = Orientation(arg10)

	overrides.DrawHandle(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _orientation)
}

//export _gotk4_gtk3_StyleClass_draw_hline
func _gotk4_gtk3_StyleClass_draw_hline(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.gint, arg6 C.gint, arg7 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawHline == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawHline, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _x1 int              // out
	var _x2 int              // out
	var _y int               // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_x1 = int(arg5)
	_x2 = int(arg6)
	_y = int(arg7)

	overrides.DrawHline(_cr, _stateType, _widget, _detail, _x1, _x2, _y)
}

//export _gotk4_gtk3_StyleClass_draw_layout
func _gotk4_gtk3_StyleClass_draw_layout(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.gboolean, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 *C.PangoLayout) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawLayout == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawLayout, got none")
	}

	var _cr *cairo.Context    // out
	var _stateType StateType  // out
	var _useText bool         // out
	var _widget Widgetter     // out
	var _detail string        // out
	var _x int                // out
	var _y int                // out
	var _layout *pango.Layout // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	if arg3 != 0 {
		_useText = true
	}
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	{
		obj := coreglib.Take(unsafe.Pointer(arg8))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	overrides.DrawLayout(_cr, _stateType, _useText, _widget, _detail, _x, _y, _layout)
}

//export _gotk4_gtk3_StyleClass_draw_option
func _gotk4_gtk3_StyleClass_draw_option(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawOption == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawOption, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawOption(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_resize_grip
func _gotk4_gtk3_StyleClass_draw_resize_grip(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.GdkWindowEdge, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawResizeGrip == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawResizeGrip, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _edge gdk.WindowEdge // out
	var _x int               // out
	var _y int               // out
	var _width int           // out
	var _height int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_edge = gdk.WindowEdge(arg5)
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawResizeGrip(_cr, _stateType, _widget, _detail, _edge, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_shadow
func _gotk4_gtk3_StyleClass_draw_shadow(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawShadow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawShadow, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawShadow(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_shadow_gap
func _gotk4_gtk3_StyleClass_draw_shadow_gap(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkPositionType, arg11 C.gint, arg12 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawShadowGap == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawShadowGap, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out
	var _gapSide PositionType  // out
	var _gapX int              // out
	var _gapWidth int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_gapSide = PositionType(arg10)
	_gapX = int(arg11)
	_gapWidth = int(arg12)

	overrides.DrawShadowGap(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _gapSide, _gapX, _gapWidth)
}

//export _gotk4_gtk3_StyleClass_draw_slider
func _gotk4_gtk3_StyleClass_draw_slider(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkOrientation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawSlider == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawSlider, got none")
	}

	var _cr *cairo.Context       // out
	var _stateType StateType     // out
	var _shadowType ShadowType   // out
	var _widget Widgetter        // out
	var _detail string           // out
	var _x int                   // out
	var _y int                   // out
	var _width int               // out
	var _height int              // out
	var _orientation Orientation // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_orientation = Orientation(arg10)

	overrides.DrawSlider(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _orientation)
}

//export _gotk4_gtk3_StyleClass_draw_spinner
func _gotk4_gtk3_StyleClass_draw_spinner(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.guint, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawSpinner == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawSpinner, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _step uint           // out
	var _x int               // out
	var _y int               // out
	var _width int           // out
	var _height int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_step = uint(arg5)
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawSpinner(_cr, _stateType, _widget, _detail, _step, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_tab
func _gotk4_gtk3_StyleClass_draw_tab(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawTab == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawTab, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawTab(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_vline
func _gotk4_gtk3_StyleClass_draw_vline(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.gint, arg6 C.gint, arg7 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawVline == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawVline, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _y1 int              // out
	var _y2 int              // out
	var _x int               // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_y1 = int(arg5)
	_y2 = int(arg6)
	_x = int(arg7)

	overrides.DrawVline(_cr, _stateType, _widget, _detail, _y1, _y2, _x)
}

//export _gotk4_gtk3_StyleClass_init_from_rc
func _gotk4_gtk3_StyleClass_init_from_rc(arg0 *C.GtkStyle, arg1 *C.GtkRcStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.InitFromRC == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.InitFromRC, got none")
	}

	var _rcStyle *RCStyle // out

	_rcStyle = wrapRCStyle(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.InitFromRC(_rcStyle)
}

//export _gotk4_gtk3_StyleClass_realize
func _gotk4_gtk3_StyleClass_realize(arg0 *C.GtkStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.Realize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.Realize, got none")
	}

	overrides.Realize()
}

//export _gotk4_gtk3_StyleClass_render_icon
func _gotk4_gtk3_StyleClass_render_icon(arg0 *C.GtkStyle, arg1 *C.GtkIconSource, arg2 C.GtkTextDirection, arg3 C.GtkStateType, arg4 C.GtkIconSize, arg5 *C.GtkWidget, arg6 *C.gchar) (cret *C.GdkPixbuf) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.RenderIcon == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.RenderIcon, got none")
	}

	var _source *IconSource      // out
	var _direction TextDirection // out
	var _state StateType         // out
	var _size int                // out
	var _widget Widgetter        // out
	var _detail string           // out

	_source = (*IconSource)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_direction = TextDirection(arg2)
	_state = StateType(arg3)
	_size = int(arg4)
	if arg5 != nil {
		{
			objptr := unsafe.Pointer(arg5)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}
	if arg6 != nil {
		_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg6)))
	}

	pixbuf := overrides.RenderIcon(_source, _direction, _state, _size, _widget, _detail)

	var _ *gdkpixbuf.Pixbuf

	cret = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(pixbuf).Native()))

	return cret
}

//export _gotk4_gtk3_StyleClass_set_background
func _gotk4_gtk3_StyleClass_set_background(arg0 *C.GtkStyle, arg1 *C.GdkWindow, arg2 C.GtkStateType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.SetBackground == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.SetBackground, got none")
	}

	var _window gdk.Windower // out
	var _stateType StateType // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Windower)
			return ok
		})
		rv, ok := casted.(gdk.Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_window = rv
	}
	_stateType = StateType(arg2)

	overrides.SetBackground(_window, _stateType)
}

//export _gotk4_gtk3_StyleClass_unrealize
func _gotk4_gtk3_StyleClass_unrealize(arg0 *C.GtkStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.Unrealize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.Unrealize, got none")
	}

	overrides.Unrealize()
}

//export _gotk4_gtk3_StyleContextClass_changed
func _gotk4_gtk3_StyleContextClass_changed(arg0 *C.GtkStyleContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleContextOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleContextOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_SwitchClass_activate
func _gotk4_gtk3_SwitchClass_activate(arg0 *C.GtkSwitch) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SwitchOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SwitchOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_SwitchClass_state_set
func _gotk4_gtk3_SwitchClass_state_set(arg0 *C.GtkSwitch, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SwitchOverrides](instance0)
	if overrides.StateSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SwitchOverrides.StateSet, got none")
	}

	var _state bool // out

	if arg1 != 0 {
		_state = true
	}

	ok := overrides.StateSet(_state)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextBufferClass_apply_tag
func _gotk4_gtk3_TextBufferClass_apply_tag(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.ApplyTag == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.ApplyTag, got none")
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	overrides.ApplyTag(_tag, _start, _end)
}

//export _gotk4_gtk3_TextBufferClass_begin_user_action
func _gotk4_gtk3_TextBufferClass_begin_user_action(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.BeginUserAction == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.BeginUserAction, got none")
	}

	overrides.BeginUserAction()
}

//export _gotk4_gtk3_TextBufferClass_changed
func _gotk4_gtk3_TextBufferClass_changed(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_TextBufferClass_delete_range
func _gotk4_gtk3_TextBufferClass_delete_range(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextIter) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.DeleteRange == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.DeleteRange, got none")
	}

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.DeleteRange(_start, _end)
}

//export _gotk4_gtk3_TextBufferClass_end_user_action
func _gotk4_gtk3_TextBufferClass_end_user_action(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.EndUserAction == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.EndUserAction, got none")
	}

	overrides.EndUserAction()
}

//export _gotk4_gtk3_TextBufferClass_insert_child_anchor
func _gotk4_gtk3_TextBufferClass_insert_child_anchor(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextChildAnchor) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.InsertChildAnchor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.InsertChildAnchor, got none")
	}

	var _iter *TextIter          // out
	var _anchor *TextChildAnchor // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_anchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.InsertChildAnchor(_iter, _anchor)
}

//export _gotk4_gtk3_TextBufferClass_insert_pixbuf
func _gotk4_gtk3_TextBufferClass_insert_pixbuf(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GdkPixbuf) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.InsertPixbuf == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.InsertPixbuf, got none")
	}

	var _iter *TextIter           // out
	var _pixbuf *gdkpixbuf.Pixbuf // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	{
		obj := coreglib.Take(unsafe.Pointer(arg2))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	overrides.InsertPixbuf(_iter, _pixbuf)
}

//export _gotk4_gtk3_TextBufferClass_insert_text
func _gotk4_gtk3_TextBufferClass_insert_text(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.gchar, arg3 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.InsertText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.InsertText, got none")
	}

	var _pos *TextIter     // out
	var _newText string    // out
	var _newTextLength int // out

	_pos = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_newText = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_newTextLength = int(arg3)

	overrides.InsertText(_pos, _newText, _newTextLength)
}

//export _gotk4_gtk3_TextBufferClass_mark_deleted
func _gotk4_gtk3_TextBufferClass_mark_deleted(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextMark) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.MarkDeleted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.MarkDeleted, got none")
	}

	var _mark *TextMark // out

	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.MarkDeleted(_mark)
}

//export _gotk4_gtk3_TextBufferClass_mark_set
func _gotk4_gtk3_TextBufferClass_mark_set(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextMark) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.MarkSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.MarkSet, got none")
	}

	var _location *TextIter // out
	var _mark *TextMark     // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.MarkSet(_location, _mark)
}

//export _gotk4_gtk3_TextBufferClass_modified_changed
func _gotk4_gtk3_TextBufferClass_modified_changed(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.ModifiedChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.ModifiedChanged, got none")
	}

	overrides.ModifiedChanged()
}

//export _gotk4_gtk3_TextBufferClass_paste_done
func _gotk4_gtk3_TextBufferClass_paste_done(arg0 *C.GtkTextBuffer, arg1 *C.GtkClipboard) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.PasteDone == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.PasteDone, got none")
	}

	var _clipboard *Clipboard // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PasteDone(_clipboard)
}

//export _gotk4_gtk3_TextBufferClass_remove_tag
func _gotk4_gtk3_TextBufferClass_remove_tag(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.RemoveTag == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.RemoveTag, got none")
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	overrides.RemoveTag(_tag, _start, _end)
}

//export _gotk4_gtk3_TextTagClass_event
func _gotk4_gtk3_TextTagClass_event(arg0 *C.GtkTextTag, arg1 *C.GObject, arg2 *C.GdkEvent, arg3 *C.GtkTextIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextTagOverrides](instance0)
	if overrides.Event == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextTagOverrides.Event, got none")
	}

	var _eventObject *coreglib.Object // out
	var _event *gdk.Event             // out
	var _iter *TextIter               // out

	_eventObject = coreglib.Take(unsafe.Pointer(arg1))
	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg2)))
		v = gdk.CopyEventer(v)
		_event = v
	}
	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := overrides.Event(_eventObject, _event, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextTagTableClass_tag_added
func _gotk4_gtk3_TextTagTableClass_tag_added(arg0 *C.GtkTextTagTable, arg1 *C.GtkTextTag) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextTagTableOverrides](instance0)
	if overrides.TagAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextTagTableOverrides.TagAdded, got none")
	}

	var _tag *TextTag // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.TagAdded(_tag)
}

//export _gotk4_gtk3_TextTagTableClass_tag_changed
func _gotk4_gtk3_TextTagTableClass_tag_changed(arg0 *C.GtkTextTagTable, arg1 *C.GtkTextTag, arg2 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextTagTableOverrides](instance0)
	if overrides.TagChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextTagTableOverrides.TagChanged, got none")
	}

	var _tag *TextTag     // out
	var _sizeChanged bool // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	if arg2 != 0 {
		_sizeChanged = true
	}

	overrides.TagChanged(_tag, _sizeChanged)
}

//export _gotk4_gtk3_TextTagTableClass_tag_removed
func _gotk4_gtk3_TextTagTableClass_tag_removed(arg0 *C.GtkTextTagTable, arg1 *C.GtkTextTag) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextTagTableOverrides](instance0)
	if overrides.TagRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextTagTableOverrides.TagRemoved, got none")
	}

	var _tag *TextTag // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.TagRemoved(_tag)
}

//export _gotk4_gtk3_TextTagTable_ConnectTagAdded
func _gotk4_gtk3_TextTagTable_ConnectTagAdded(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 C.guintptr) {
	var f func(tag *TextTag)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag))
	}

	var _tag *TextTag // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))

	f(_tag)
}

//export _gotk4_gtk3_TextTagTable_ConnectTagChanged
func _gotk4_gtk3_TextTagTable_ConnectTagChanged(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 C.gboolean, arg3 C.guintptr) {
	var f func(tag *TextTag, sizeChanged bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag, sizeChanged bool))
	}

	var _tag *TextTag     // out
	var _sizeChanged bool // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	if arg2 != 0 {
		_sizeChanged = true
	}

	f(_tag, _sizeChanged)
}

//export _gotk4_gtk3_TextTagTable_ConnectTagRemoved
func _gotk4_gtk3_TextTagTable_ConnectTagRemoved(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 C.guintptr) {
	var f func(tag *TextTag)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag))
	}

	var _tag *TextTag // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))

	f(_tag)
}

//export _gotk4_gtk3_TextViewClass_backspace
func _gotk4_gtk3_TextViewClass_backspace(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.Backspace == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.Backspace, got none")
	}

	overrides.Backspace()
}

//export _gotk4_gtk3_TextViewClass_copy_clipboard
func _gotk4_gtk3_TextViewClass_copy_clipboard(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.CopyClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.CopyClipboard, got none")
	}

	overrides.CopyClipboard()
}

//export _gotk4_gtk3_TextViewClass_cut_clipboard
func _gotk4_gtk3_TextViewClass_cut_clipboard(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.CutClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.CutClipboard, got none")
	}

	overrides.CutClipboard()
}

//export _gotk4_gtk3_TextViewClass_delete_from_cursor
func _gotk4_gtk3_TextViewClass_delete_from_cursor(arg0 *C.GtkTextView, arg1 C.GtkDeleteType, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.DeleteFromCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.DeleteFromCursor, got none")
	}

	var _typ DeleteType // out
	var _count int      // out

	_typ = DeleteType(arg1)
	_count = int(arg2)

	overrides.DeleteFromCursor(_typ, _count)
}

//export _gotk4_gtk3_TextViewClass_draw_layer
func _gotk4_gtk3_TextViewClass_draw_layer(arg0 *C.GtkTextView, arg1 C.GtkTextViewLayer, arg2 *C.cairo_t) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.DrawLayer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.DrawLayer, got none")
	}

	var _layer TextViewLayer // out
	var _cr *cairo.Context   // out

	_layer = TextViewLayer(arg1)
	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg2)))
	C.cairo_reference(arg2)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	overrides.DrawLayer(_layer, _cr)
}

//export _gotk4_gtk3_TextViewClass_extend_selection
func _gotk4_gtk3_TextViewClass_extend_selection(arg0 *C.GtkTextView, arg1 C.GtkTextExtendSelection, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 *C.GtkTextIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.ExtendSelection == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.ExtendSelection, got none")
	}

	var _granularity TextExtendSelection // out
	var _location *TextIter              // out
	var _start *TextIter                 // out
	var _end *TextIter                   // out

	_granularity = TextExtendSelection(arg1)
	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	ok := overrides.ExtendSelection(_granularity, _location, _start, _end)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextViewClass_insert_at_cursor
func _gotk4_gtk3_TextViewClass_insert_at_cursor(arg0 *C.GtkTextView, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.InsertAtCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.InsertAtCursor, got none")
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.InsertAtCursor(_str)
}

//export _gotk4_gtk3_TextViewClass_insert_emoji
func _gotk4_gtk3_TextViewClass_insert_emoji(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.InsertEmoji == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.InsertEmoji, got none")
	}

	overrides.InsertEmoji()
}

//export _gotk4_gtk3_TextViewClass_move_cursor
func _gotk4_gtk3_TextViewClass_move_cursor(arg0 *C.GtkTextView, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.MoveCursor, got none")
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	overrides.MoveCursor(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_TextViewClass_paste_clipboard
func _gotk4_gtk3_TextViewClass_paste_clipboard(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.PasteClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.PasteClipboard, got none")
	}

	overrides.PasteClipboard()
}

//export _gotk4_gtk3_TextViewClass_populate_popup
func _gotk4_gtk3_TextViewClass_populate_popup(arg0 *C.GtkTextView, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.PopulatePopup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.PopulatePopup, got none")
	}

	var _popup Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_popup = rv
	}

	overrides.PopulatePopup(_popup)
}

//export _gotk4_gtk3_TextViewClass_set_anchor
func _gotk4_gtk3_TextViewClass_set_anchor(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.SetAnchor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.SetAnchor, got none")
	}

	overrides.SetAnchor()
}

//export _gotk4_gtk3_TextViewClass_toggle_overwrite
func _gotk4_gtk3_TextViewClass_toggle_overwrite(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.ToggleOverwrite == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.ToggleOverwrite, got none")
	}

	overrides.ToggleOverwrite()
}

//export _gotk4_gtk3_ThemingEngineClass_render_activity
func _gotk4_gtk3_ThemingEngineClass_render_activity(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderActivity == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderActivity, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderActivity(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_arrow
func _gotk4_gtk3_ThemingEngineClass_render_arrow(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderArrow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderArrow, got none")
	}

	var _cr *cairo.Context // out
	var _angle float64     // out
	var _x float64         // out
	var _y float64         // out
	var _size float64      // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_angle = float64(arg2)
	_x = float64(arg3)
	_y = float64(arg4)
	_size = float64(arg5)

	overrides.RenderArrow(_cr, _angle, _x, _y, _size)
}

//export _gotk4_gtk3_ThemingEngineClass_render_background
func _gotk4_gtk3_ThemingEngineClass_render_background(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderBackground == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderBackground, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderBackground(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_check
func _gotk4_gtk3_ThemingEngineClass_render_check(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderCheck == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderCheck, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderCheck(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_expander
func _gotk4_gtk3_ThemingEngineClass_render_expander(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderExpander == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderExpander, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderExpander(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_extension
func _gotk4_gtk3_ThemingEngineClass_render_extension(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble, arg6 C.GtkPositionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderExtension == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderExtension, got none")
	}

	var _cr *cairo.Context    // out
	var _x float64            // out
	var _y float64            // out
	var _width float64        // out
	var _height float64       // out
	var _gapSide PositionType // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)
	_gapSide = PositionType(arg6)

	overrides.RenderExtension(_cr, _x, _y, _width, _height, _gapSide)
}

//export _gotk4_gtk3_ThemingEngineClass_render_focus
func _gotk4_gtk3_ThemingEngineClass_render_focus(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderFocus, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderFocus(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_frame
func _gotk4_gtk3_ThemingEngineClass_render_frame(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderFrame, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderFrame(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_frame_gap
func _gotk4_gtk3_ThemingEngineClass_render_frame_gap(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble, arg6 C.GtkPositionType, arg7 C.gdouble, arg8 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderFrameGap == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderFrameGap, got none")
	}

	var _cr *cairo.Context    // out
	var _x float64            // out
	var _y float64            // out
	var _width float64        // out
	var _height float64       // out
	var _gapSide PositionType // out
	var _xy0Gap float64       // out
	var _xy1Gap float64       // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)
	_gapSide = PositionType(arg6)
	_xy0Gap = float64(arg7)
	_xy1Gap = float64(arg8)

	overrides.RenderFrameGap(_cr, _x, _y, _width, _height, _gapSide, _xy0Gap, _xy1Gap)
}

//export _gotk4_gtk3_ThemingEngineClass_render_handle
func _gotk4_gtk3_ThemingEngineClass_render_handle(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderHandle == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderHandle, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderHandle(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_icon
func _gotk4_gtk3_ThemingEngineClass_render_icon(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 *C.GdkPixbuf, arg3 C.gdouble, arg4 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderIcon == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderIcon, got none")
	}

	var _cr *cairo.Context        // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _x float64                // out
	var _y float64                // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	{
		obj := coreglib.Take(unsafe.Pointer(arg2))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}
	_x = float64(arg3)
	_y = float64(arg4)

	overrides.RenderIcon(_cr, _pixbuf, _x, _y)
}

//export _gotk4_gtk3_ThemingEngineClass_render_icon_surface
func _gotk4_gtk3_ThemingEngineClass_render_icon_surface(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 *C.cairo_surface_t, arg3 C.gdouble, arg4 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderIconSurface == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderIconSurface, got none")
	}

	var _cr *cairo.Context      // out
	var _surface *cairo.Surface // out
	var _x float64              // out
	var _y float64              // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(arg2)))
	C.cairo_surface_reference(arg2)
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg3)
	_y = float64(arg4)

	overrides.RenderIconSurface(_cr, _surface, _x, _y)
}

//export _gotk4_gtk3_ThemingEngineClass_render_layout
func _gotk4_gtk3_ThemingEngineClass_render_layout(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 *C.PangoLayout) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderLayout == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderLayout, got none")
	}

	var _cr *cairo.Context    // out
	var _x float64            // out
	var _y float64            // out
	var _layout *pango.Layout // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	{
		obj := coreglib.Take(unsafe.Pointer(arg4))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	overrides.RenderLayout(_cr, _x, _y, _layout)
}

//export _gotk4_gtk3_ThemingEngineClass_render_line
func _gotk4_gtk3_ThemingEngineClass_render_line(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderLine == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderLine, got none")
	}

	var _cr *cairo.Context // out
	var _x0 float64        // out
	var _y0 float64        // out
	var _x1 float64        // out
	var _y1 float64        // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x0 = float64(arg2)
	_y0 = float64(arg3)
	_x1 = float64(arg4)
	_y1 = float64(arg5)

	overrides.RenderLine(_cr, _x0, _y0, _x1, _y1)
}

//export _gotk4_gtk3_ThemingEngineClass_render_option
func _gotk4_gtk3_ThemingEngineClass_render_option(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderOption == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderOption, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderOption(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_slider
func _gotk4_gtk3_ThemingEngineClass_render_slider(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble, arg6 C.GtkOrientation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderSlider == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderSlider, got none")
	}

	var _cr *cairo.Context       // out
	var _x float64               // out
	var _y float64               // out
	var _width float64           // out
	var _height float64          // out
	var _orientation Orientation // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)
	_orientation = Orientation(arg6)

	overrides.RenderSlider(_cr, _x, _y, _width, _height, _orientation)
}

//export _gotk4_gtk3_ToggleActionClass_toggled
func _gotk4_gtk3_ToggleActionClass_toggled(arg0 *C.GtkToggleAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToggleActionOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToggleActionOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk3_ToggleButtonClass_toggled
func _gotk4_gtk3_ToggleButtonClass_toggled(arg0 *C.GtkToggleButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToggleButtonOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToggleButtonOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk3_ToggleToolButtonClass_toggled
func _gotk4_gtk3_ToggleToolButtonClass_toggled(arg0 *C.GtkToggleToolButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToggleToolButtonOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToggleToolButtonOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk3_ToolButtonClass_clicked
func _gotk4_gtk3_ToolButtonClass_clicked(arg0 *C.GtkToolButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolButtonOverrides](instance0)
	if overrides.Clicked == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolButtonOverrides.Clicked, got none")
	}

	overrides.Clicked()
}

//export _gotk4_gtk3_ToolItemClass_create_menu_proxy
func _gotk4_gtk3_ToolItemClass_create_menu_proxy(arg0 *C.GtkToolItem) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolItemOverrides](instance0)
	if overrides.CreateMenuProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolItemOverrides.CreateMenuProxy, got none")
	}

	ok := overrides.CreateMenuProxy()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ToolItemClass_toolbar_reconfigured
func _gotk4_gtk3_ToolItemClass_toolbar_reconfigured(arg0 *C.GtkToolItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolItemOverrides](instance0)
	if overrides.ToolbarReconfigured == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolItemOverrides.ToolbarReconfigured, got none")
	}

	overrides.ToolbarReconfigured()
}

//export _gotk4_gtk3_ToolbarClass_orientation_changed
func _gotk4_gtk3_ToolbarClass_orientation_changed(arg0 *C.GtkToolbar, arg1 C.GtkOrientation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolbarOverrides](instance0)
	if overrides.OrientationChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolbarOverrides.OrientationChanged, got none")
	}

	var _orientation Orientation // out

	_orientation = Orientation(arg1)

	overrides.OrientationChanged(_orientation)
}

//export _gotk4_gtk3_ToolbarClass_popup_context_menu
func _gotk4_gtk3_ToolbarClass_popup_context_menu(arg0 *C.GtkToolbar, arg1 C.gint, arg2 C.gint, arg3 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolbarOverrides](instance0)
	if overrides.PopupContextMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolbarOverrides.PopupContextMenu, got none")
	}

	var _x int            // out
	var _y int            // out
	var _buttonNumber int // out

	_x = int(arg1)
	_y = int(arg2)
	_buttonNumber = int(arg3)

	ok := overrides.PopupContextMenu(_x, _y, _buttonNumber)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ToolbarClass_style_changed
func _gotk4_gtk3_ToolbarClass_style_changed(arg0 *C.GtkToolbar, arg1 C.GtkToolbarStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolbarOverrides](instance0)
	if overrides.StyleChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolbarOverrides.StyleChanged, got none")
	}

	var _style ToolbarStyle // out

	_style = ToolbarStyle(arg1)

	overrides.StyleChanged(_style)
}

//export _gotk4_gtk3_TreeModelFilterClass_modify
func _gotk4_gtk3_TreeModelFilterClass_modify(arg0 *C.GtkTreeModelFilter, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 *C.GValue, arg4 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeModelFilterOverrides](instance0)
	if overrides.Modify == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeModelFilterOverrides.Modify, got none")
	}

	var _childModel TreeModeller // out
	var _iter *TreeIter          // out
	var _value *coreglib.Value   // out
	var _column int              // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_childModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_value = coreglib.ValueFromNative(unsafe.Pointer(arg3))
	_column = int(arg4)

	overrides.Modify(_childModel, _iter, _value, _column)
}

//export _gotk4_gtk3_TreeModelFilterClass_visible
func _gotk4_gtk3_TreeModelFilterClass_visible(arg0 *C.GtkTreeModelFilter, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeModelFilterOverrides](instance0)
	if overrides.Visible == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeModelFilterOverrides.Visible, got none")
	}

	var _childModel TreeModeller // out
	var _iter *TreeIter          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_childModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.Visible(_childModel, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeSelectionClass_changed
func _gotk4_gtk3_TreeSelectionClass_changed(arg0 *C.GtkTreeSelection) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeSelectionOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeSelectionOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_TreeViewClass_columns_changed
func _gotk4_gtk3_TreeViewClass_columns_changed(arg0 *C.GtkTreeView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.ColumnsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.ColumnsChanged, got none")
	}

	overrides.ColumnsChanged()
}

//export _gotk4_gtk3_TreeViewClass_cursor_changed
func _gotk4_gtk3_TreeViewClass_cursor_changed(arg0 *C.GtkTreeView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.CursorChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.CursorChanged, got none")
	}

	overrides.CursorChanged()
}

//export _gotk4_gtk3_TreeViewClass_expand_collapse_cursor_row
func _gotk4_gtk3_TreeViewClass_expand_collapse_cursor_row(arg0 *C.GtkTreeView, arg1 C.gboolean, arg2 C.gboolean, arg3 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.ExpandCollapseCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.ExpandCollapseCursorRow, got none")
	}

	var _logical bool // out
	var _expand bool  // out
	var _openAll bool // out

	if arg1 != 0 {
		_logical = true
	}
	if arg2 != 0 {
		_expand = true
	}
	if arg3 != 0 {
		_openAll = true
	}

	ok := overrides.ExpandCollapseCursorRow(_logical, _expand, _openAll)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_move_cursor
func _gotk4_gtk3_TreeViewClass_move_cursor(arg0 *C.GtkTreeView, arg1 C.GtkMovementStep, arg2 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.MoveCursor, got none")
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	ok := overrides.MoveCursor(_step, _count)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_row_activated
func _gotk4_gtk3_TreeViewClass_row_activated(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 *C.GtkTreeViewColumn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.RowActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.RowActivated, got none")
	}

	var _path *TreePath         // out
	var _column *TreeViewColumn // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.RowActivated(_path, _column)
}

//export _gotk4_gtk3_TreeViewClass_row_collapsed
func _gotk4_gtk3_TreeViewClass_row_collapsed(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.RowCollapsed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.RowCollapsed, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RowCollapsed(_iter, _path)
}

//export _gotk4_gtk3_TreeViewClass_row_expanded
func _gotk4_gtk3_TreeViewClass_row_expanded(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.RowExpanded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.RowExpanded, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RowExpanded(_iter, _path)
}

//export _gotk4_gtk3_TreeViewClass_select_all
func _gotk4_gtk3_TreeViewClass_select_all(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.SelectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.SelectAll, got none")
	}

	ok := overrides.SelectAll()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_select_cursor_parent
func _gotk4_gtk3_TreeViewClass_select_cursor_parent(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.SelectCursorParent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.SelectCursorParent, got none")
	}

	ok := overrides.SelectCursorParent()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_select_cursor_row
func _gotk4_gtk3_TreeViewClass_select_cursor_row(arg0 *C.GtkTreeView, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.SelectCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.SelectCursorRow, got none")
	}

	var _startEditing bool // out

	if arg1 != 0 {
		_startEditing = true
	}

	ok := overrides.SelectCursorRow(_startEditing)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_start_interactive_search
func _gotk4_gtk3_TreeViewClass_start_interactive_search(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.StartInteractiveSearch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.StartInteractiveSearch, got none")
	}

	ok := overrides.StartInteractiveSearch()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_test_collapse_row
func _gotk4_gtk3_TreeViewClass_test_collapse_row(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.TestCollapseRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.TestCollapseRow, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.TestCollapseRow(_iter, _path)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_test_expand_row
func _gotk4_gtk3_TreeViewClass_test_expand_row(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.TestExpandRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.TestExpandRow, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.TestExpandRow(_iter, _path)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_toggle_cursor_row
func _gotk4_gtk3_TreeViewClass_toggle_cursor_row(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.ToggleCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.ToggleCursorRow, got none")
	}

	ok := overrides.ToggleCursorRow()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_unselect_all
func _gotk4_gtk3_TreeViewClass_unselect_all(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.UnselectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.UnselectAll, got none")
	}

	ok := overrides.UnselectAll()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectExpandCollapseCursorRow
func _gotk4_gtk3_TreeView_ConnectExpandCollapseCursorRow(arg0 C.gpointer, arg1 C.gboolean, arg2 C.gboolean, arg3 C.gboolean, arg4 C.guintptr) (cret C.gboolean) {
	var f func(object, p0, p1 bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0, p1 bool) (ok bool))
	}

	var _object bool // out
	var _p0 bool     // out
	var _p1 bool     // out

	if arg1 != 0 {
		_object = true
	}
	if arg2 != 0 {
		_p0 = true
	}
	if arg3 != 0 {
		_p1 = true
	}

	ok := f(_object, _p0, _p1)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectSelectAll
func _gotk4_gtk3_TreeView_ConnectSelectAll(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectSelectCursorParent
func _gotk4_gtk3_TreeView_ConnectSelectCursorParent(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectSelectCursorRow
func _gotk4_gtk3_TreeView_ConnectSelectCursorRow(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object bool) (ok bool))
	}

	var _object bool // out

	if arg1 != 0 {
		_object = true
	}

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectStartInteractiveSearch
func _gotk4_gtk3_TreeView_ConnectStartInteractiveSearch(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectToggleCursorRow
func _gotk4_gtk3_TreeView_ConnectToggleCursorRow(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectUnselectAll
func _gotk4_gtk3_TreeView_ConnectUnselectAll(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewColumnClass_clicked
func _gotk4_gtk3_TreeViewColumnClass_clicked(arg0 *C.GtkTreeViewColumn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewColumnOverrides](instance0)
	if overrides.Clicked == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewColumnOverrides.Clicked, got none")
	}

	overrides.Clicked()
}

//export _gotk4_gtk3_TreeViewColumn_ConnectClicked
func _gotk4_gtk3_TreeViewColumn_ConnectClicked(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_UIManagerClass_actions_changed
func _gotk4_gtk3_UIManagerClass_actions_changed(arg0 *C.GtkUIManager) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.ActionsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.ActionsChanged, got none")
	}

	overrides.ActionsChanged()
}

//export _gotk4_gtk3_UIManagerClass_add_widget
func _gotk4_gtk3_UIManagerClass_add_widget(arg0 *C.GtkUIManager, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.AddWidget == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.AddWidget, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	overrides.AddWidget(_widget)
}

//export _gotk4_gtk3_UIManagerClass_connect_proxy
func _gotk4_gtk3_UIManagerClass_connect_proxy(arg0 *C.GtkUIManager, arg1 *C.GtkAction, arg2 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.ConnectProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.ConnectProxy, got none")
	}

	var _action *Action  // out
	var _proxy Widgetter // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	overrides.ConnectProxy(_action, _proxy)
}

//export _gotk4_gtk3_UIManagerClass_disconnect_proxy
func _gotk4_gtk3_UIManagerClass_disconnect_proxy(arg0 *C.GtkUIManager, arg1 *C.GtkAction, arg2 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.DisconnectProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.DisconnectProxy, got none")
	}

	var _action *Action  // out
	var _proxy Widgetter // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	overrides.DisconnectProxy(_action, _proxy)
}

//export _gotk4_gtk3_UIManagerClass_get_action
func _gotk4_gtk3_UIManagerClass_get_action(arg0 *C.GtkUIManager, arg1 *C.gchar) (cret *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.Action == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.Action, got none")
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	action := overrides.Action(_path)

	var _ *Action

	cret = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	return cret
}

//export _gotk4_gtk3_UIManagerClass_get_widget
func _gotk4_gtk3_UIManagerClass_get_widget(arg0 *C.GtkUIManager, arg1 *C.gchar) (cret *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.Widget == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.Widget, got none")
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	widget := overrides.Widget(_path)

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_UIManagerClass_post_activate
func _gotk4_gtk3_UIManagerClass_post_activate(arg0 *C.GtkUIManager, arg1 *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.PostActivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.PostActivate, got none")
	}

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PostActivate(_action)
}

//export _gotk4_gtk3_UIManagerClass_pre_activate
func _gotk4_gtk3_UIManagerClass_pre_activate(arg0 *C.GtkUIManager, arg1 *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.PreActivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.PreActivate, got none")
	}

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PreActivate(_action)
}

//export _gotk4_gtk3_WidgetClass_adjust_baseline_allocation
func _gotk4_gtk3_WidgetClass_adjust_baseline_allocation(arg0 *C.GtkWidget, arg1 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.AdjustBaselineAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.AdjustBaselineAllocation, got none")
	}

	var _baseline *int // out

	_baseline = (*int)(unsafe.Pointer(arg1))

	overrides.AdjustBaselineAllocation(_baseline)
}

//export _gotk4_gtk3_WidgetClass_adjust_baseline_request
func _gotk4_gtk3_WidgetClass_adjust_baseline_request(arg0 *C.GtkWidget, arg1 *C.gint, arg2 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.AdjustBaselineRequest == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.AdjustBaselineRequest, got none")
	}

	var _minimumBaseline *int // out
	var _naturalBaseline *int // out

	_minimumBaseline = (*int)(unsafe.Pointer(arg1))
	_naturalBaseline = (*int)(unsafe.Pointer(arg2))

	overrides.AdjustBaselineRequest(_minimumBaseline, _naturalBaseline)
}

//export _gotk4_gtk3_WidgetClass_adjust_size_allocation
func _gotk4_gtk3_WidgetClass_adjust_size_allocation(arg0 *C.GtkWidget, arg1 C.GtkOrientation, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint, arg5 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.AdjustSizeAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.AdjustSizeAllocation, got none")
	}

	var _orientation Orientation // out
	var _minimumSize *int        // out
	var _naturalSize *int        // out
	var _allocatedPos *int       // out
	var _allocatedSize *int      // out

	_orientation = Orientation(arg1)
	_minimumSize = (*int)(unsafe.Pointer(arg2))
	_naturalSize = (*int)(unsafe.Pointer(arg3))
	_allocatedPos = (*int)(unsafe.Pointer(arg4))
	_allocatedSize = (*int)(unsafe.Pointer(arg5))

	overrides.AdjustSizeAllocation(_orientation, _minimumSize, _naturalSize, _allocatedPos, _allocatedSize)
}

//export _gotk4_gtk3_WidgetClass_adjust_size_request
func _gotk4_gtk3_WidgetClass_adjust_size_request(arg0 *C.GtkWidget, arg1 C.GtkOrientation, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.AdjustSizeRequest == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.AdjustSizeRequest, got none")
	}

	var _orientation Orientation // out
	var _minimumSize *int        // out
	var _naturalSize *int        // out

	_orientation = Orientation(arg1)
	_minimumSize = (*int)(unsafe.Pointer(arg2))
	_naturalSize = (*int)(unsafe.Pointer(arg3))

	overrides.AdjustSizeRequest(_orientation, _minimumSize, _naturalSize)
}

//export _gotk4_gtk3_WidgetClass_button_press_event
func _gotk4_gtk3_WidgetClass_button_press_event(arg0 *C.GtkWidget, arg1 *C.GdkEventButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ButtonPressEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ButtonPressEvent, got none")
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ButtonPressEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_button_release_event
func _gotk4_gtk3_WidgetClass_button_release_event(arg0 *C.GtkWidget, arg1 *C.GdkEventButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ButtonReleaseEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ButtonReleaseEvent, got none")
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ButtonReleaseEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_can_activate_accel
func _gotk4_gtk3_WidgetClass_can_activate_accel(arg0 *C.GtkWidget, arg1 C.guint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.CanActivateAccel == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.CanActivateAccel, got none")
	}

	var _signalId uint // out

	_signalId = uint(arg1)

	ok := overrides.CanActivateAccel(_signalId)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_composited_changed
func _gotk4_gtk3_WidgetClass_composited_changed(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.CompositedChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.CompositedChanged, got none")
	}

	overrides.CompositedChanged()
}

//export _gotk4_gtk3_WidgetClass_configure_event
func _gotk4_gtk3_WidgetClass_configure_event(arg0 *C.GtkWidget, arg1 *C.GdkEventConfigure) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ConfigureEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ConfigureEvent, got none")
	}

	var _event *gdk.EventConfigure // out

	_event = (*gdk.EventConfigure)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ConfigureEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_damage_event
func _gotk4_gtk3_WidgetClass_damage_event(arg0 *C.GtkWidget, arg1 *C.GdkEventExpose) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DamageEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DamageEvent, got none")
	}

	var _event *gdk.EventExpose // out

	_event = (*gdk.EventExpose)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DamageEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_delete_event
func _gotk4_gtk3_WidgetClass_delete_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DeleteEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DeleteEvent, got none")
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DeleteEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_destroy
func _gotk4_gtk3_WidgetClass_destroy(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Destroy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Destroy, got none")
	}

	overrides.Destroy()
}

//export _gotk4_gtk3_WidgetClass_destroy_event
func _gotk4_gtk3_WidgetClass_destroy_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DestroyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DestroyEvent, got none")
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DestroyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_direction_changed
func _gotk4_gtk3_WidgetClass_direction_changed(arg0 *C.GtkWidget, arg1 C.GtkTextDirection) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DirectionChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DirectionChanged, got none")
	}

	var _previousDirection TextDirection // out

	_previousDirection = TextDirection(arg1)

	overrides.DirectionChanged(_previousDirection)
}

//export _gotk4_gtk3_WidgetClass_drag_begin
func _gotk4_gtk3_WidgetClass_drag_begin(arg0 *C.GtkWidget, arg1 *C.GdkDragContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragBegin == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragBegin, got none")
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	overrides.DragBegin(_context)
}

//export _gotk4_gtk3_WidgetClass_drag_data_delete
func _gotk4_gtk3_WidgetClass_drag_data_delete(arg0 *C.GtkWidget, arg1 *C.GdkDragContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragDataDelete == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragDataDelete, got none")
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	overrides.DragDataDelete(_context)
}

//export _gotk4_gtk3_WidgetClass_drag_data_get
func _gotk4_gtk3_WidgetClass_drag_data_get(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 *C.GtkSelectionData, arg3 C.guint, arg4 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragDataGet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragDataGet, got none")
	}

	var _context *gdk.DragContext     // out
	var _selectionData *SelectionData // out
	var _info uint                    // out
	var _time_ uint                   // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_info = uint(arg3)
	_time_ = uint(arg4)

	overrides.DragDataGet(_context, _selectionData, _info, _time_)
}

//export _gotk4_gtk3_WidgetClass_drag_data_received
func _gotk4_gtk3_WidgetClass_drag_data_received(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 *C.GtkSelectionData, arg5 C.guint, arg6 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragDataReceived == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragDataReceived, got none")
	}

	var _context *gdk.DragContext     // out
	var _x int                        // out
	var _y int                        // out
	var _selectionData *SelectionData // out
	var _info uint                    // out
	var _time_ uint                   // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_info = uint(arg5)
	_time_ = uint(arg6)

	overrides.DragDataReceived(_context, _x, _y, _selectionData, _info, _time_)
}

//export _gotk4_gtk3_WidgetClass_drag_drop
func _gotk4_gtk3_WidgetClass_drag_drop(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragDrop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragDrop, got none")
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _time_ uint               // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_time_ = uint(arg4)

	ok := overrides.DragDrop(_context, _x, _y, _time_)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_drag_end
func _gotk4_gtk3_WidgetClass_drag_end(arg0 *C.GtkWidget, arg1 *C.GdkDragContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragEnd == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragEnd, got none")
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	overrides.DragEnd(_context)
}

//export _gotk4_gtk3_WidgetClass_drag_failed
func _gotk4_gtk3_WidgetClass_drag_failed(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.GtkDragResult) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragFailed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragFailed, got none")
	}

	var _context *gdk.DragContext // out
	var _result DragResult        // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_result = DragResult(arg2)

	ok := overrides.DragFailed(_context, _result)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_drag_leave
func _gotk4_gtk3_WidgetClass_drag_leave(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragLeave == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragLeave, got none")
	}

	var _context *gdk.DragContext // out
	var _time_ uint               // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_time_ = uint(arg2)

	overrides.DragLeave(_context, _time_)
}

//export _gotk4_gtk3_WidgetClass_drag_motion
func _gotk4_gtk3_WidgetClass_drag_motion(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragMotion == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragMotion, got none")
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _time_ uint               // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_time_ = uint(arg4)

	ok := overrides.DragMotion(_context, _x, _y, _time_)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_draw
func _gotk4_gtk3_WidgetClass_draw(arg0 *C.GtkWidget, arg1 *C.cairo_t) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Draw == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Draw, got none")
	}

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	ok := overrides.Draw(_cr)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_enter_notify_event
func _gotk4_gtk3_WidgetClass_enter_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventCrossing) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.EnterNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.EnterNotifyEvent, got none")
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.EnterNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_event
func _gotk4_gtk3_WidgetClass_event(arg0 *C.GtkWidget, arg1 *C.GdkEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Event == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Event, got none")
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := overrides.Event(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_focus
func _gotk4_gtk3_WidgetClass_focus(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Focus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Focus, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := overrides.Focus(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_focus_in_event
func _gotk4_gtk3_WidgetClass_focus_in_event(arg0 *C.GtkWidget, arg1 *C.GdkEventFocus) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.FocusInEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.FocusInEvent, got none")
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.FocusInEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_focus_out_event
func _gotk4_gtk3_WidgetClass_focus_out_event(arg0 *C.GtkWidget, arg1 *C.GdkEventFocus) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.FocusOutEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.FocusOutEvent, got none")
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.FocusOutEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_get_accessible
func _gotk4_gtk3_WidgetClass_get_accessible(arg0 *C.GtkWidget) (cret *C.AtkObject) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Accessible == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Accessible, got none")
	}

	object := overrides.Accessible()

	var _ *atk.AtkObject

	cret = (*C.AtkObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	return cret
}

//export _gotk4_gtk3_WidgetClass_get_preferred_height
func _gotk4_gtk3_WidgetClass_get_preferred_height(arg0 *C.GtkWidget, arg1 *C.gint, arg2 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredHeight, got none")
	}

	minimumHeight, naturalHeight := overrides.PreferredHeight()

	var _ int
	var _ int

	*arg1 = C.gint(minimumHeight)
	*arg2 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width
func _gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width(arg0 *C.GtkWidget, arg1 C.gint, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint, arg5 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredHeightAndBaselineForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredHeightAndBaselineForWidth, got none")
	}

	var _width int // out

	_width = int(arg1)

	minimumHeight, naturalHeight, minimumBaseline, naturalBaseline := overrides.PreferredHeightAndBaselineForWidth(_width)

	var _ int
	var _ int
	var _ int
	var _ int

	*arg2 = C.gint(minimumHeight)
	*arg3 = C.gint(naturalHeight)
	*arg4 = C.gint(minimumBaseline)
	*arg5 = C.gint(naturalBaseline)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_height_for_width
func _gotk4_gtk3_WidgetClass_get_preferred_height_for_width(arg0 *C.GtkWidget, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredHeightForWidth, got none")
	}

	var _width int // out

	_width = int(arg1)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_width)

	var _ int
	var _ int

	*arg2 = C.gint(minimumHeight)
	*arg3 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_width
func _gotk4_gtk3_WidgetClass_get_preferred_width(arg0 *C.GtkWidget, arg1 *C.gint, arg2 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredWidth, got none")
	}

	minimumWidth, naturalWidth := overrides.PreferredWidth()

	var _ int
	var _ int

	*arg1 = C.gint(minimumWidth)
	*arg2 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_width_for_height
func _gotk4_gtk3_WidgetClass_get_preferred_width_for_height(arg0 *C.GtkWidget, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredWidthForHeight, got none")
	}

	var _height int // out

	_height = int(arg1)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_height)

	var _ int
	var _ int

	*arg2 = C.gint(minimumWidth)
	*arg3 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_WidgetClass_get_request_mode
func _gotk4_gtk3_WidgetClass_get_request_mode(arg0 *C.GtkWidget) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.RequestMode, got none")
	}

	sizeRequestMode := overrides.RequestMode()

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk3_WidgetClass_grab_broken_event
func _gotk4_gtk3_WidgetClass_grab_broken_event(arg0 *C.GtkWidget, arg1 *C.GdkEventGrabBroken) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.GrabBrokenEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.GrabBrokenEvent, got none")
	}

	var _event *gdk.EventGrabBroken // out

	_event = (*gdk.EventGrabBroken)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.GrabBrokenEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_grab_focus
func _gotk4_gtk3_WidgetClass_grab_focus(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.GrabFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.GrabFocus, got none")
	}

	overrides.GrabFocus()
}

//export _gotk4_gtk3_WidgetClass_grab_notify
func _gotk4_gtk3_WidgetClass_grab_notify(arg0 *C.GtkWidget, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.GrabNotify == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.GrabNotify, got none")
	}

	var _wasGrabbed bool // out

	if arg1 != 0 {
		_wasGrabbed = true
	}

	overrides.GrabNotify(_wasGrabbed)
}

//export _gotk4_gtk3_WidgetClass_hide
func _gotk4_gtk3_WidgetClass_hide(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Hide == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Hide, got none")
	}

	overrides.Hide()
}

//export _gotk4_gtk3_WidgetClass_hierarchy_changed
func _gotk4_gtk3_WidgetClass_hierarchy_changed(arg0 *C.GtkWidget, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.HierarchyChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.HierarchyChanged, got none")
	}

	var _previousToplevel Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_previousToplevel = rv
	}

	overrides.HierarchyChanged(_previousToplevel)
}

//export _gotk4_gtk3_WidgetClass_key_press_event
func _gotk4_gtk3_WidgetClass_key_press_event(arg0 *C.GtkWidget, arg1 *C.GdkEventKey) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.KeyPressEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.KeyPressEvent, got none")
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.KeyPressEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_key_release_event
func _gotk4_gtk3_WidgetClass_key_release_event(arg0 *C.GtkWidget, arg1 *C.GdkEventKey) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.KeyReleaseEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.KeyReleaseEvent, got none")
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.KeyReleaseEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_keynav_failed
func _gotk4_gtk3_WidgetClass_keynav_failed(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.KeynavFailed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.KeynavFailed, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := overrides.KeynavFailed(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_leave_notify_event
func _gotk4_gtk3_WidgetClass_leave_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventCrossing) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.LeaveNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.LeaveNotifyEvent, got none")
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.LeaveNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_map
func _gotk4_gtk3_WidgetClass_map(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Map == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Map, got none")
	}

	overrides.Map()
}

//export _gotk4_gtk3_WidgetClass_map_event
func _gotk4_gtk3_WidgetClass_map_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MapEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MapEvent, got none")
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.MapEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_mnemonic_activate
func _gotk4_gtk3_WidgetClass_mnemonic_activate(arg0 *C.GtkWidget, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MnemonicActivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MnemonicActivate, got none")
	}

	var _groupCycling bool // out

	if arg1 != 0 {
		_groupCycling = true
	}

	ok := overrides.MnemonicActivate(_groupCycling)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_motion_notify_event
func _gotk4_gtk3_WidgetClass_motion_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventMotion) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MotionNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MotionNotifyEvent, got none")
	}

	var _event *gdk.EventMotion // out

	_event = (*gdk.EventMotion)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.MotionNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_move_focus
func _gotk4_gtk3_WidgetClass_move_focus(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MoveFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MoveFocus, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	overrides.MoveFocus(_direction)
}

//export _gotk4_gtk3_WidgetClass_parent_set
func _gotk4_gtk3_WidgetClass_parent_set(arg0 *C.GtkWidget, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ParentSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ParentSet, got none")
	}

	var _previousParent Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_previousParent = rv
	}

	overrides.ParentSet(_previousParent)
}

//export _gotk4_gtk3_WidgetClass_popup_menu
func _gotk4_gtk3_WidgetClass_popup_menu(arg0 *C.GtkWidget) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PopupMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PopupMenu, got none")
	}

	ok := overrides.PopupMenu()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_property_notify_event
func _gotk4_gtk3_WidgetClass_property_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventProperty) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PropertyNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PropertyNotifyEvent, got none")
	}

	var _event *gdk.EventProperty // out

	_event = (*gdk.EventProperty)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.PropertyNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_proximity_in_event
func _gotk4_gtk3_WidgetClass_proximity_in_event(arg0 *C.GtkWidget, arg1 *C.GdkEventProximity) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ProximityInEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ProximityInEvent, got none")
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ProximityInEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_proximity_out_event
func _gotk4_gtk3_WidgetClass_proximity_out_event(arg0 *C.GtkWidget, arg1 *C.GdkEventProximity) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ProximityOutEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ProximityOutEvent, got none")
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ProximityOutEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_query_tooltip
func _gotk4_gtk3_WidgetClass_query_tooltip(arg0 *C.GtkWidget, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.GtkTooltip) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.QueryTooltip == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.QueryTooltip, got none")
	}

	var _x int                // out
	var _y int                // out
	var _keyboardTooltip bool // out
	var _tooltip *Tooltip     // out

	_x = int(arg1)
	_y = int(arg2)
	if arg3 != 0 {
		_keyboardTooltip = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := overrides.QueryTooltip(_x, _y, _keyboardTooltip, _tooltip)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_queue_draw_region
func _gotk4_gtk3_WidgetClass_queue_draw_region(arg0 *C.GtkWidget, arg1 *C.cairo_region_t) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.QueueDrawRegion == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.QueueDrawRegion, got none")
	}

	var _region *cairo.Region // out

	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(arg1)}
		_region = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	C.cairo_region_reference(arg1)
	runtime.SetFinalizer(_region, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
	})

	overrides.QueueDrawRegion(_region)
}

//export _gotk4_gtk3_WidgetClass_realize
func _gotk4_gtk3_WidgetClass_realize(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Realize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Realize, got none")
	}

	overrides.Realize()
}

//export _gotk4_gtk3_WidgetClass_screen_changed
func _gotk4_gtk3_WidgetClass_screen_changed(arg0 *C.GtkWidget, arg1 *C.GdkScreen) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ScreenChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ScreenChanged, got none")
	}

	var _previousScreen *gdk.Screen // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_previousScreen = &gdk.Screen{
			Object: obj,
		}
	}

	overrides.ScreenChanged(_previousScreen)
}

//export _gotk4_gtk3_WidgetClass_scroll_event
func _gotk4_gtk3_WidgetClass_scroll_event(arg0 *C.GtkWidget, arg1 *C.GdkEventScroll) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ScrollEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ScrollEvent, got none")
	}

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ScrollEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_selection_clear_event
func _gotk4_gtk3_WidgetClass_selection_clear_event(arg0 *C.GtkWidget, arg1 *C.GdkEventSelection) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionClearEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionClearEvent, got none")
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SelectionClearEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_selection_get
func _gotk4_gtk3_WidgetClass_selection_get(arg0 *C.GtkWidget, arg1 *C.GtkSelectionData, arg2 C.guint, arg3 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionGet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionGet, got none")
	}

	var _selectionData *SelectionData // out
	var _info uint                    // out
	var _time_ uint                   // out

	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_info = uint(arg2)
	_time_ = uint(arg3)

	overrides.SelectionGet(_selectionData, _info, _time_)
}

//export _gotk4_gtk3_WidgetClass_selection_notify_event
func _gotk4_gtk3_WidgetClass_selection_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventSelection) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionNotifyEvent, got none")
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SelectionNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_selection_received
func _gotk4_gtk3_WidgetClass_selection_received(arg0 *C.GtkWidget, arg1 *C.GtkSelectionData, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionReceived == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionReceived, got none")
	}

	var _selectionData *SelectionData // out
	var _time_ uint                   // out

	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_time_ = uint(arg2)

	overrides.SelectionReceived(_selectionData, _time_)
}

//export _gotk4_gtk3_WidgetClass_selection_request_event
func _gotk4_gtk3_WidgetClass_selection_request_event(arg0 *C.GtkWidget, arg1 *C.GdkEventSelection) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionRequestEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionRequestEvent, got none")
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SelectionRequestEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_show
func _gotk4_gtk3_WidgetClass_show(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Show == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Show, got none")
	}

	overrides.Show()
}

//export _gotk4_gtk3_WidgetClass_show_all
func _gotk4_gtk3_WidgetClass_show_all(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ShowAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ShowAll, got none")
	}

	overrides.ShowAll()
}

//export _gotk4_gtk3_WidgetClass_show_help
func _gotk4_gtk3_WidgetClass_show_help(arg0 *C.GtkWidget, arg1 C.GtkWidgetHelpType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ShowHelp == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ShowHelp, got none")
	}

	var _helpType WidgetHelpType // out

	_helpType = WidgetHelpType(arg1)

	ok := overrides.ShowHelp(_helpType)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_size_allocate
func _gotk4_gtk3_WidgetClass_size_allocate(arg0 *C.GtkWidget, arg1 *C.GtkAllocation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SizeAllocate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SizeAllocate, got none")
	}

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	overrides.SizeAllocate(_allocation)
}

//export _gotk4_gtk3_WidgetClass_state_changed
func _gotk4_gtk3_WidgetClass_state_changed(arg0 *C.GtkWidget, arg1 C.GtkStateType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.StateChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.StateChanged, got none")
	}

	var _previousState StateType // out

	_previousState = StateType(arg1)

	overrides.StateChanged(_previousState)
}

//export _gotk4_gtk3_WidgetClass_state_flags_changed
func _gotk4_gtk3_WidgetClass_state_flags_changed(arg0 *C.GtkWidget, arg1 C.GtkStateFlags) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.StateFlagsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.StateFlagsChanged, got none")
	}

	var _previousStateFlags StateFlags // out

	_previousStateFlags = StateFlags(arg1)

	overrides.StateFlagsChanged(_previousStateFlags)
}

//export _gotk4_gtk3_WidgetClass_style_set
func _gotk4_gtk3_WidgetClass_style_set(arg0 *C.GtkWidget, arg1 *C.GtkStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.StyleSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.StyleSet, got none")
	}

	var _previousStyle *Style // out

	_previousStyle = wrapStyle(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.StyleSet(_previousStyle)
}

//export _gotk4_gtk3_WidgetClass_style_updated
func _gotk4_gtk3_WidgetClass_style_updated(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.StyleUpdated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.StyleUpdated, got none")
	}

	overrides.StyleUpdated()
}

//export _gotk4_gtk3_WidgetClass_touch_event
func _gotk4_gtk3_WidgetClass_touch_event(arg0 *C.GtkWidget, arg1 *C.GdkEventTouch) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.TouchEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.TouchEvent, got none")
	}

	var _event *gdk.EventTouch // out

	_event = (*gdk.EventTouch)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.TouchEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_unmap
func _gotk4_gtk3_WidgetClass_unmap(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Unmap == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Unmap, got none")
	}

	overrides.Unmap()
}

//export _gotk4_gtk3_WidgetClass_unmap_event
func _gotk4_gtk3_WidgetClass_unmap_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.UnmapEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.UnmapEvent, got none")
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.UnmapEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_unrealize
func _gotk4_gtk3_WidgetClass_unrealize(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Unrealize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Unrealize, got none")
	}

	overrides.Unrealize()
}

//export _gotk4_gtk3_WidgetClass_visibility_notify_event
func _gotk4_gtk3_WidgetClass_visibility_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventVisibility) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.VisibilityNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.VisibilityNotifyEvent, got none")
	}

	var _event *gdk.EventVisibility // out

	_event = (*gdk.EventVisibility)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.VisibilityNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_window_state_event
func _gotk4_gtk3_WidgetClass_window_state_event(arg0 *C.GtkWidget, arg1 *C.GdkEventWindowState) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.WindowStateEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.WindowStateEvent, got none")
	}

	var _event *gdk.EventWindowState // out

	_event = (*gdk.EventWindowState)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.WindowStateEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectAccelClosuresChanged
func _gotk4_gtk3_Widget_ConnectAccelClosuresChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectFocus
func _gotk4_gtk3_Widget_ConnectFocus(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(direction DirectionType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType) (ok bool))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := f(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectGrabFocus
func _gotk4_gtk3_Widget_ConnectGrabFocus(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectMoveFocus
func _gotk4_gtk3_Widget_ConnectMoveFocus(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(direction DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	f(_direction)
}

//export _gotk4_gtk3_Widget_ConnectSelectionGet
func _gotk4_gtk3_Widget_ConnectSelectionGet(arg0 C.gpointer, arg1 *C.GtkSelectionData, arg2 C.guint, arg3 C.guint, arg4 C.guintptr) {
	var f func(data *SelectionData, info, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(data *SelectionData, info, time uint))
	}

	var _data *SelectionData // out
	var _info uint           // out
	var _time uint           // out

	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_info = uint(arg2)
	_time = uint(arg3)

	f(_data, _info, _time)
}

//export _gotk4_gtk3_Widget_ConnectSelectionNotifyEvent
func _gotk4_gtk3_Widget_ConnectSelectionNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventSelection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventSelection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventSelection) (ok bool))
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectSelectionReceived
func _gotk4_gtk3_Widget_ConnectSelectionReceived(arg0 C.gpointer, arg1 *C.GtkSelectionData, arg2 C.guint, arg3 C.guintptr) {
	var f func(data *SelectionData, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(data *SelectionData, time uint))
	}

	var _data *SelectionData // out
	var _time uint           // out

	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_time = uint(arg2)

	f(_data, _time)
}

//export _gotk4_gtk3_Widget_ConnectShowHelp
func _gotk4_gtk3_Widget_ConnectShowHelp(arg0 C.gpointer, arg1 C.GtkWidgetHelpType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(helpType WidgetHelpType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(helpType WidgetHelpType) (ok bool))
	}

	var _helpType WidgetHelpType // out

	_helpType = WidgetHelpType(arg1)

	ok := f(_helpType)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectSizeAllocate
func _gotk4_gtk3_Widget_ConnectSizeAllocate(arg0 C.gpointer, arg1 *C.GtkAllocation, arg2 C.guintptr) {
	var f func(allocation *Allocation)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(allocation *Allocation))
	}

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	f(_allocation)
}

//export _gotk4_gtk3_Widget_ConnectTouchEvent
func _gotk4_gtk3_Widget_ConnectTouchEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object *gdk.Event) (ok bool))
	}

	var _object *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_object = v
	}

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WindowClass_activate_default
func _gotk4_gtk3_WindowClass_activate_default(arg0 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.ActivateDefault == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.ActivateDefault, got none")
	}

	overrides.ActivateDefault()
}

//export _gotk4_gtk3_WindowClass_activate_focus
func _gotk4_gtk3_WindowClass_activate_focus(arg0 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.ActivateFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.ActivateFocus, got none")
	}

	overrides.ActivateFocus()
}

//export _gotk4_gtk3_WindowClass_enable_debugging
func _gotk4_gtk3_WindowClass_enable_debugging(arg0 *C.GtkWindow, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.EnableDebugging == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.EnableDebugging, got none")
	}

	var _toggle bool // out

	if arg1 != 0 {
		_toggle = true
	}

	ok := overrides.EnableDebugging(_toggle)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WindowClass_keys_changed
func _gotk4_gtk3_WindowClass_keys_changed(arg0 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.KeysChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.KeysChanged, got none")
	}

	overrides.KeysChanged()
}

//export _gotk4_gtk3_WindowClass_set_focus
func _gotk4_gtk3_WindowClass_set_focus(arg0 *C.GtkWindow, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.SetFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.SetFocus, got none")
	}

	var _focus Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_focus = rv
		}
	}

	overrides.SetFocus(_focus)
}
