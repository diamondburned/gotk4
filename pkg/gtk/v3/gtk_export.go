// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

//export _gotk4_gtk3_AssistantPageFunc
func _gotk4_gtk3_AssistantPageFunc(arg1 C.gint, arg2 C.gpointer) (cret C.gint) {
	var fn AssistantPageFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(AssistantPageFunc)
	}

	var _currentPage int // out

	_currentPage = int(arg1)

	gint := fn(_currentPage)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_CalendarDetailFunc
func _gotk4_gtk3_CalendarDetailFunc(arg1 *C.GtkCalendar, arg2 C.guint, arg3 C.guint, arg4 C.guint, arg5 C.gpointer) (cret *C.gchar) {
	var fn CalendarDetailFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CalendarDetailFunc)
	}

	var _calendar *Calendar // out
	var _year uint          // out
	var _month uint         // out
	var _day uint           // out

	_calendar = wrapCalendar(coreglib.Take(unsafe.Pointer(arg1)))
	_year = uint(arg2)
	_month = uint(arg3)
	_day = uint(arg4)

	utf8 := fn(_calendar, _year, _month, _day)

	var _ string

	if utf8 != "" {
		cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	}

	return cret
}

//export _gotk4_gtk3_Callback
func _gotk4_gtk3_Callback(arg1 *C.GtkWidget, arg2 C.gpointer) {
	var fn Callback
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(Callback)
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	fn(_widget)
}

//export _gotk4_gtk3_CellAllocCallback
func _gotk4_gtk3_CellAllocCallback(arg1 *C.GtkCellRenderer, arg2 *C.GdkRectangle, arg3 *C.GdkRectangle, arg4 C.gpointer) (cret C.gboolean) {
	var fn CellAllocCallback
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CellAllocCallback)
	}

	var _renderer CellRendererer       // out
	var _cellArea *gdk.Rectangle       // out
	var _cellBackground *gdk.Rectangle // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_cellBackground = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := fn(_renderer, _cellArea, _cellBackground)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellCallback
func _gotk4_gtk3_CellCallback(arg1 *C.GtkCellRenderer, arg2 C.gpointer) (cret C.gboolean) {
	var fn CellCallback
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CellCallback)
	}

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	ok := fn(_renderer)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellLayoutDataFunc
func _gotk4_gtk3_CellLayoutDataFunc(arg1 *C.GtkCellLayout, arg2 *C.GtkCellRenderer, arg3 *C.GtkTreeModel, arg4 *C.GtkTreeIter, arg5 C.gpointer) {
	var fn CellLayoutDataFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CellLayoutDataFunc)
	}

	var _cellLayout CellLayouter // out
	var _cell CellRendererer     // out
	var _treeModel TreeModeller  // out
	var _iter *TreeIter          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellLayouter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellLayouter)
			return ok
		})
		rv, ok := casted.(CellLayouter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellLayouter")
		}
		_cellLayout = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_cell = rv
	}
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_treeModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	fn(_cellLayout, _cell, _treeModel, _iter)
}

//export _gotk4_gtk3_ClipboardImageReceivedFunc
func _gotk4_gtk3_ClipboardImageReceivedFunc(arg1 *C.GtkClipboard, arg2 *C.GdkPixbuf, arg3 C.gpointer) {
	var fn ClipboardImageReceivedFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ClipboardImageReceivedFunc)
	}

	var _clipboard *Clipboard     // out
	var _pixbuf *gdkpixbuf.Pixbuf // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(arg1)))
	{
		obj := coreglib.Take(unsafe.Pointer(arg2))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	fn(_clipboard, _pixbuf)
}

//export _gotk4_gtk3_ClipboardReceivedFunc
func _gotk4_gtk3_ClipboardReceivedFunc(arg1 *C.GtkClipboard, arg2 *C.GtkSelectionData, arg3 C.gpointer) {
	var fn ClipboardReceivedFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ClipboardReceivedFunc)
	}

	var _clipboard *Clipboard         // out
	var _selectionData *SelectionData // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(arg1)))
	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	fn(_clipboard, _selectionData)
}

//export _gotk4_gtk3_ClipboardTextReceivedFunc
func _gotk4_gtk3_ClipboardTextReceivedFunc(arg1 *C.GtkClipboard, arg2 *C.gchar, arg3 C.gpointer) {
	var fn ClipboardTextReceivedFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ClipboardTextReceivedFunc)
	}

	var _clipboard *Clipboard // out
	var _text string          // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(arg1)))
	if arg2 != nil {
		_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	}

	fn(_clipboard, _text)
}

//export _gotk4_gtk3_ClipboardURIReceivedFunc
func _gotk4_gtk3_ClipboardURIReceivedFunc(arg1 *C.GtkClipboard, arg2 **C.gchar, arg3 C.gpointer) {
	var fn ClipboardURIReceivedFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ClipboardURIReceivedFunc)
	}

	var _clipboard *Clipboard // out
	var _uris []string        // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(arg1)))
	{
		var i int
		var z *C.gchar
		for p := arg2; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(arg2, i)
		_uris = make([]string, i)
		for i := range src {
			_uris[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	fn(_clipboard, _uris)
}

//export _gotk4_gtk3_EntryCompletionMatchFunc
func _gotk4_gtk3_EntryCompletionMatchFunc(arg1 *C.GtkEntryCompletion, arg2 *C.gchar, arg3 *C.GtkTreeIter, arg4 C.gpointer) (cret C.gboolean) {
	var fn EntryCompletionMatchFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(EntryCompletionMatchFunc)
	}

	var _completion *EntryCompletion // out
	var _key string                  // out
	var _iter *TreeIter              // out

	_completion = wrapEntryCompletion(coreglib.Take(unsafe.Pointer(arg1)))
	_key = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := fn(_completion, _key, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_FileFilterFunc
func _gotk4_gtk3_FileFilterFunc(arg1 *C.GtkFileFilterInfo, arg2 C.gpointer) (cret C.gboolean) {
	var fn FileFilterFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(FileFilterFunc)
	}

	var _filterInfo *FileFilterInfo // out

	_filterInfo = (*FileFilterInfo)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := fn(_filterInfo)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_FlowBoxCreateWidgetFunc
func _gotk4_gtk3_FlowBoxCreateWidgetFunc(arg1 C.gpointer, arg2 C.gpointer) (cret *C.GtkWidget) {
	var fn FlowBoxCreateWidgetFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(FlowBoxCreateWidgetFunc)
	}

	var _item *coreglib.Object // out

	_item = coreglib.Take(unsafe.Pointer(arg1))

	widget := fn(_item)

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_FlowBoxFilterFunc
func _gotk4_gtk3_FlowBoxFilterFunc(arg1 *C.GtkFlowBoxChild, arg2 C.gpointer) (cret C.gboolean) {
	var fn FlowBoxFilterFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(FlowBoxFilterFunc)
	}

	var _child *FlowBoxChild // out

	_child = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(arg1)))

	ok := fn(_child)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_FlowBoxForEachFunc
func _gotk4_gtk3_FlowBoxForEachFunc(arg1 *C.GtkFlowBox, arg2 *C.GtkFlowBoxChild, arg3 C.gpointer) {
	var fn FlowBoxForEachFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(FlowBoxForEachFunc)
	}

	var _box *FlowBox        // out
	var _child *FlowBoxChild // out

	_box = wrapFlowBox(coreglib.Take(unsafe.Pointer(arg1)))
	_child = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(arg2)))

	fn(_box, _child)
}

//export _gotk4_gtk3_FlowBoxSortFunc
func _gotk4_gtk3_FlowBoxSortFunc(arg1 *C.GtkFlowBoxChild, arg2 *C.GtkFlowBoxChild, arg3 C.gpointer) (cret C.gint) {
	var fn FlowBoxSortFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(FlowBoxSortFunc)
	}

	var _child1 *FlowBoxChild // out
	var _child2 *FlowBoxChild // out

	_child1 = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(arg1)))
	_child2 = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(arg2)))

	gint := fn(_child1, _child2)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_FontFilterFunc
func _gotk4_gtk3_FontFilterFunc(arg1 *C.PangoFontFamily, arg2 *C.PangoFontFace, arg3 C.gpointer) (cret C.gboolean) {
	var fn FontFilterFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(FontFilterFunc)
	}

	var _family pango.FontFamilier // out
	var _face pango.FontFacer      // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type pango.FontFamilier is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(pango.FontFamilier)
			return ok
		})
		rv, ok := casted.(pango.FontFamilier)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
		}
		_family = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type pango.FontFacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(pango.FontFacer)
			return ok
		})
		rv, ok := casted.(pango.FontFacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
		}
		_face = rv
	}

	ok := fn(_family, _face)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IconViewForEachFunc
func _gotk4_gtk3_IconViewForEachFunc(arg1 *C.GtkIconView, arg2 *C.GtkTreePath, arg3 C.gpointer) {
	var fn IconViewForEachFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(IconViewForEachFunc)
	}

	var _iconView *IconView // out
	var _path *TreePath     // out

	_iconView = wrapIconView(coreglib.Take(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	fn(_iconView, _path)
}

//export _gotk4_gtk3_KeySnoopFunc
func _gotk4_gtk3_KeySnoopFunc(arg1 *C.GtkWidget, arg2 *C.GdkEventKey, arg3 C.gpointer) (cret C.gint) {
	var fn KeySnoopFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(KeySnoopFunc)
	}

	var _grabWidget Widgetter // out
	var _event *gdk.EventKey  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_grabWidget = rv
	}
	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	gint := fn(_grabWidget, _event)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_ListBoxCreateWidgetFunc
func _gotk4_gtk3_ListBoxCreateWidgetFunc(arg1 C.gpointer, arg2 C.gpointer) (cret *C.GtkWidget) {
	var fn ListBoxCreateWidgetFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ListBoxCreateWidgetFunc)
	}

	var _item *coreglib.Object // out

	_item = coreglib.Take(unsafe.Pointer(arg1))

	widget := fn(_item)

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ListBoxFilterFunc
func _gotk4_gtk3_ListBoxFilterFunc(arg1 *C.GtkListBoxRow, arg2 C.gpointer) (cret C.gboolean) {
	var fn ListBoxFilterFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ListBoxFilterFunc)
	}

	var _row *ListBoxRow // out

	_row = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg1)))

	ok := fn(_row)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ListBoxForEachFunc
func _gotk4_gtk3_ListBoxForEachFunc(arg1 *C.GtkListBox, arg2 *C.GtkListBoxRow, arg3 C.gpointer) {
	var fn ListBoxForEachFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ListBoxForEachFunc)
	}

	var _box *ListBox    // out
	var _row *ListBoxRow // out

	_box = wrapListBox(coreglib.Take(unsafe.Pointer(arg1)))
	_row = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg2)))

	fn(_box, _row)
}

//export _gotk4_gtk3_ListBoxSortFunc
func _gotk4_gtk3_ListBoxSortFunc(arg1 *C.GtkListBoxRow, arg2 *C.GtkListBoxRow, arg3 C.gpointer) (cret C.gint) {
	var fn ListBoxSortFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ListBoxSortFunc)
	}

	var _row1 *ListBoxRow // out
	var _row2 *ListBoxRow // out

	_row1 = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg1)))
	_row2 = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg2)))

	gint := fn(_row1, _row2)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_ListBoxUpdateHeaderFunc
func _gotk4_gtk3_ListBoxUpdateHeaderFunc(arg1 *C.GtkListBoxRow, arg2 *C.GtkListBoxRow, arg3 C.gpointer) {
	var fn ListBoxUpdateHeaderFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ListBoxUpdateHeaderFunc)
	}

	var _row *ListBoxRow    // out
	var _before *ListBoxRow // out

	_row = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg1)))
	if arg2 != nil {
		_before = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg2)))
	}

	fn(_row, _before)
}

//export _gotk4_gtk3_PageSetupDoneFunc
func _gotk4_gtk3_PageSetupDoneFunc(arg1 *C.GtkPageSetup, arg2 C.gpointer) {
	var fn PageSetupDoneFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PageSetupDoneFunc)
	}

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg1)))

	fn(_pageSetup)
}

//export _gotk4_gtk3_PrintSettingsFunc
func _gotk4_gtk3_PrintSettingsFunc(arg1 *C.gchar, arg2 *C.gchar, arg3 C.gpointer) {
	var fn PrintSettingsFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PrintSettingsFunc)
	}

	var _key string   // out
	var _value string // out

	_key = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_value = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	fn(_key, _value)
}

//export _gotk4_gtk3_RecentFilterFunc
func _gotk4_gtk3_RecentFilterFunc(arg1 *C.GtkRecentFilterInfo, arg2 C.gpointer) (cret C.gboolean) {
	var fn RecentFilterFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(RecentFilterFunc)
	}

	var _filterInfo *RecentFilterInfo // out

	_filterInfo = (*RecentFilterInfo)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := fn(_filterInfo)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_RecentSortFunc
func _gotk4_gtk3_RecentSortFunc(arg1 *C.GtkRecentInfo, arg2 *C.GtkRecentInfo, arg3 C.gpointer) (cret C.gint) {
	var fn RecentSortFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(RecentSortFunc)
	}

	var _a *RecentInfo // out
	var _b *RecentInfo // out

	_a = (*RecentInfo)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gtk_recent_info_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_a)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_recent_info_unref((*C.GtkRecentInfo)(intern.C))
		},
	)
	_b = (*RecentInfo)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.gtk_recent_info_ref(arg2)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_b)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_recent_info_unref((*C.GtkRecentInfo)(intern.C))
		},
	)

	gint := fn(_a, _b)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_TextBufferDeserializeFunc
func _gotk4_gtk3_TextBufferDeserializeFunc(arg1 *C.GtkTextBuffer, arg2 *C.GtkTextBuffer, arg3 *C.GtkTextIter, arg4 *C.guint8, arg5 C.gsize, arg6 C.gboolean, arg7 C.gpointer, _cerr **C.GError) (cret C.gboolean) {
	var fn TextBufferDeserializeFunc
	{
		v := gbox.Get(uintptr(arg7))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TextBufferDeserializeFunc)
	}

	var _registerBuffer *TextBuffer // out
	var _contentBuffer *TextBuffer  // out
	var _iter *TextIter             // out
	var _data []byte                // out
	var _createTags bool            // out

	_registerBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(arg1)))
	_contentBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(arg2)))
	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_data = make([]byte, arg5)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(arg4)), arg5))
	if arg6 != 0 {
		_createTags = true
	}

	_goerr := fn(_registerBuffer, _contentBuffer, _iter, _data, _createTags)

	var _ error

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gtk3_TextBufferSerializeFunc
func _gotk4_gtk3_TextBufferSerializeFunc(arg1 *C.GtkTextBuffer, arg2 *C.GtkTextBuffer, arg3 *C.GtkTextIter, arg4 *C.GtkTextIter, arg5 *C.gsize, arg6 C.gpointer) (cret *C.guint8) {
	var fn TextBufferSerializeFunc
	{
		v := gbox.Get(uintptr(arg6))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TextBufferSerializeFunc)
	}

	var _registerBuffer *TextBuffer // out
	var _contentBuffer *TextBuffer  // out
	var _start *TextIter            // out
	var _end *TextIter              // out

	_registerBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(arg1)))
	_contentBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(arg2)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	guint8s := fn(_registerBuffer, _contentBuffer, _start, _end)

	var _ []byte

	*arg5 = (C.gsize)(len(guint8s))
	if len(guint8s) > 0 {
		cret = (*C.guint8)(unsafe.Pointer(&guint8s[0]))
	}

	return cret
}

//export _gotk4_gtk3_TextCharPredicate
func _gotk4_gtk3_TextCharPredicate(arg1 C.gunichar, arg2 C.gpointer) (cret C.gboolean) {
	var fn TextCharPredicate
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TextCharPredicate)
	}

	var _ch uint32 // out

	_ch = uint32(arg1)

	ok := fn(_ch)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextTagTableForEach
func _gotk4_gtk3_TextTagTableForEach(arg1 *C.GtkTextTag, arg2 C.gpointer) {
	var fn TextTagTableForEach
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TextTagTableForEach)
	}

	var _tag *TextTag // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))

	fn(_tag)
}

//export _gotk4_gtk3_TickCallback
func _gotk4_gtk3_TickCallback(arg1 *C.GtkWidget, arg2 *C.GdkFrameClock, arg3 C.gpointer) (cret C.gboolean) {
	var fn TickCallback
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TickCallback)
	}

	var _widget Widgetter            // out
	var _frameClock gdk.FrameClocker // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gdk.FrameClocker is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.FrameClocker)
			return ok
		})
		rv, ok := casted.(gdk.FrameClocker)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.FrameClocker")
		}
		_frameClock = rv
	}

	ok := fn(_widget, _frameClock)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TranslateFunc
func _gotk4_gtk3_TranslateFunc(arg1 *C.gchar, arg2 C.gpointer) (cret *C.gchar) {
	var fn TranslateFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TranslateFunc)
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	utf8 := fn(_path)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_TreeCellDataFunc
func _gotk4_gtk3_TreeCellDataFunc(arg1 *C.GtkTreeViewColumn, arg2 *C.GtkCellRenderer, arg3 *C.GtkTreeModel, arg4 *C.GtkTreeIter, arg5 C.gpointer) {
	var fn TreeCellDataFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeCellDataFunc)
	}

	var _treeColumn *TreeViewColumn // out
	var _cell CellRendererer        // out
	var _treeModel TreeModeller     // out
	var _iter *TreeIter             // out

	_treeColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_cell = rv
	}
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_treeModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	fn(_treeColumn, _cell, _treeModel, _iter)
}

//export _gotk4_gtk3_TreeDestroyCountFunc
func _gotk4_gtk3_TreeDestroyCountFunc(arg1 *C.GtkTreeView, arg2 *C.GtkTreePath, arg3 C.gint, arg4 C.gpointer) {
	var fn TreeDestroyCountFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeDestroyCountFunc)
	}

	var _treeView *TreeView // out
	var _path *TreePath     // out
	var _children int       // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_children = int(arg3)

	fn(_treeView, _path, _children)
}

//export _gotk4_gtk3_TreeIterCompareFunc
func _gotk4_gtk3_TreeIterCompareFunc(arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 *C.GtkTreeIter, arg4 C.gpointer) (cret C.gint) {
	var fn TreeIterCompareFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeIterCompareFunc)
	}

	var _model TreeModeller // out
	var _a *TreeIter        // out
	var _b *TreeIter        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_a = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_b = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	gint := fn(_model, _a, _b)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_TreeModelFilterModifyFunc
func _gotk4_gtk3_TreeModelFilterModifyFunc(arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 *C.GValue, arg4 C.gint, arg5 C.gpointer) {
	var fn TreeModelFilterModifyFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeModelFilterModifyFunc)
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out
	var _column int         // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_column = int(arg4)

	value := fn(_model, _iter, _column)

	var _ coreglib.Value

	*arg3 = *(*C.GValue)(unsafe.Pointer((&value).Native()))
}

//export _gotk4_gtk3_TreeModelFilterVisibleFunc
func _gotk4_gtk3_TreeModelFilterVisibleFunc(arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.gpointer) (cret C.gboolean) {
	var fn TreeModelFilterVisibleFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeModelFilterVisibleFunc)
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := fn(_model, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeModelForEachFunc
func _gotk4_gtk3_TreeModelForEachFunc(arg1 *C.GtkTreeModel, arg2 *C.GtkTreePath, arg3 *C.GtkTreeIter, arg4 C.gpointer) (cret C.gboolean) {
	var fn TreeModelForEachFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeModelForEachFunc)
	}

	var _model TreeModeller // out
	var _path *TreePath     // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := fn(_model, _path, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeSelectionForEachFunc
func _gotk4_gtk3_TreeSelectionForEachFunc(arg1 *C.GtkTreeModel, arg2 *C.GtkTreePath, arg3 *C.GtkTreeIter, arg4 C.gpointer) {
	var fn TreeSelectionForEachFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeSelectionForEachFunc)
	}

	var _model TreeModeller // out
	var _path *TreePath     // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	fn(_model, _path, _iter)
}

//export _gotk4_gtk3_TreeSelectionFunc
func _gotk4_gtk3_TreeSelectionFunc(arg1 *C.GtkTreeSelection, arg2 *C.GtkTreeModel, arg3 *C.GtkTreePath, arg4 C.gboolean, arg5 C.gpointer) (cret C.gboolean) {
	var fn TreeSelectionFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeSelectionFunc)
	}

	var _selection *TreeSelection   // out
	var _model TreeModeller         // out
	var _path *TreePath             // out
	var _pathCurrentlySelected bool // out

	_selection = wrapTreeSelection(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	if arg4 != 0 {
		_pathCurrentlySelected = true
	}

	ok := fn(_selection, _model, _path, _pathCurrentlySelected)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewColumnDropFunc
func _gotk4_gtk3_TreeViewColumnDropFunc(arg1 *C.GtkTreeView, arg2 *C.GtkTreeViewColumn, arg3 *C.GtkTreeViewColumn, arg4 *C.GtkTreeViewColumn, arg5 C.gpointer) (cret C.gboolean) {
	var fn TreeViewColumnDropFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewColumnDropFunc)
	}

	var _treeView *TreeView         // out
	var _column *TreeViewColumn     // out
	var _prevColumn *TreeViewColumn // out
	var _nextColumn *TreeViewColumn // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(arg1)))
	_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg2)))
	_prevColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg3)))
	_nextColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg4)))

	ok := fn(_treeView, _column, _prevColumn, _nextColumn)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewMappingFunc
func _gotk4_gtk3_TreeViewMappingFunc(arg1 *C.GtkTreeView, arg2 *C.GtkTreePath, arg3 C.gpointer) {
	var fn TreeViewMappingFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewMappingFunc)
	}

	var _treeView *TreeView // out
	var _path *TreePath     // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	fn(_treeView, _path)
}

//export _gotk4_gtk3_TreeViewRowSeparatorFunc
func _gotk4_gtk3_TreeViewRowSeparatorFunc(arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.gpointer) (cret C.gboolean) {
	var fn TreeViewRowSeparatorFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewRowSeparatorFunc)
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := fn(_model, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewSearchEqualFunc
func _gotk4_gtk3_TreeViewSearchEqualFunc(arg1 *C.GtkTreeModel, arg2 C.gint, arg3 *C.gchar, arg4 *C.GtkTreeIter, arg5 C.gpointer) (cret C.gboolean) {
	var fn TreeViewSearchEqualFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewSearchEqualFunc)
	}

	var _model TreeModeller // out
	var _column int         // out
	var _key string         // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_column = int(arg2)
	_key = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	ok := fn(_model, _column, _key, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewSearchPositionFunc
func _gotk4_gtk3_TreeViewSearchPositionFunc(arg1 *C.GtkTreeView, arg2 *C.GtkWidget, arg3 C.gpointer) {
	var fn TreeViewSearchPositionFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewSearchPositionFunc)
	}

	var _treeView *TreeView     // out
	var _searchDialog Widgetter // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_searchDialog = rv
	}

	fn(_treeView, _searchDialog)
}

//export _gotk4_gtk3_CellEditable_ConnectEditingDone
func _gotk4_gtk3_CellEditable_ConnectEditingDone(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_CellEditable_ConnectRemoveWidget
func _gotk4_gtk3_CellEditable_ConnectRemoveWidget(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ColorChooser_ConnectColorActivated
func _gotk4_gtk3_ColorChooser_ConnectColorActivated(arg0 C.gpointer, arg1 *C.GdkRGBA, arg2 C.guintptr) {
	var f func(color *gdk.RGBA)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(color *gdk.RGBA))
	}

	var _color *gdk.RGBA // out

	_color = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	f(_color)
}

//export _gotk4_gtk3_Editable_ConnectChanged
func _gotk4_gtk3_Editable_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Editable_ConnectDeleteText
func _gotk4_gtk3_Editable_ConnectDeleteText(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.guintptr) {
	var f func(startPos, endPos int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(startPos, endPos int))
	}

	var _startPos int // out
	var _endPos int   // out

	_startPos = int(arg1)
	_endPos = int(arg2)

	f(_startPos, _endPos)
}

//export _gotk4_gtk3_FileChooser_ConnectConfirmOverwrite
func _gotk4_gtk3_FileChooser_ConnectConfirmOverwrite(arg0 C.gpointer, arg1 C.guintptr) (cret C.GtkFileChooserConfirmation) {
	var f func() (fileChooserConfirmation FileChooserConfirmation)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (fileChooserConfirmation FileChooserConfirmation))
	}

	fileChooserConfirmation := f()

	var _ FileChooserConfirmation

	cret = C.GtkFileChooserConfirmation(fileChooserConfirmation)

	return cret
}

//export _gotk4_gtk3_FileChooser_ConnectCurrentFolderChanged
func _gotk4_gtk3_FileChooser_ConnectCurrentFolderChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooser_ConnectFileActivated
func _gotk4_gtk3_FileChooser_ConnectFileActivated(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooser_ConnectSelectionChanged
func _gotk4_gtk3_FileChooser_ConnectSelectionChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooser_ConnectUpdatePreview
func _gotk4_gtk3_FileChooser_ConnectUpdatePreview(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FontChooser_ConnectFontActivated
func _gotk4_gtk3_FontChooser_ConnectFontActivated(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(fontname string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(fontname string))
	}

	var _fontname string // out

	_fontname = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_fontname)
}

//export _gotk4_gtk3_PrintOperationPreview_ConnectGotPageSize
func _gotk4_gtk3_PrintOperationPreview_ConnectGotPageSize(arg0 C.gpointer, arg1 *C.GtkPrintContext, arg2 *C.GtkPageSetup, arg3 C.guintptr) {
	var f func(context *PrintContext, pageSetup *PageSetup)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext, pageSetup *PageSetup))
	}

	var _context *PrintContext // out
	var _pageSetup *PageSetup  // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageSetup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg2)))

	f(_context, _pageSetup)
}

//export _gotk4_gtk3_PrintOperationPreview_ConnectReady
func _gotk4_gtk3_PrintOperationPreview_ConnectReady(arg0 C.gpointer, arg1 *C.GtkPrintContext, arg2 C.guintptr) {
	var f func(context *PrintContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext))
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	f(_context)
}

//export _gotk4_gtk3_RecentChooser_ConnectItemActivated
func _gotk4_gtk3_RecentChooser_ConnectItemActivated(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_RecentChooser_ConnectSelectionChanged
func _gotk4_gtk3_RecentChooser_ConnectSelectionChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TreeModel_ConnectRowChanged
func _gotk4_gtk3_TreeModel_ConnectRowChanged(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.guintptr) {
	var f func(path *TreePath, iter *TreeIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, iter *TreeIter))
	}

	var _path *TreePath // out
	var _iter *TreeIter // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_path, _iter)
}

//export _gotk4_gtk3_TreeModel_ConnectRowDeleted
func _gotk4_gtk3_TreeModel_ConnectRowDeleted(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 C.guintptr) {
	var f func(path *TreePath)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath))
	}

	var _path *TreePath // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	f(_path)
}

//export _gotk4_gtk3_TreeModel_ConnectRowHasChildToggled
func _gotk4_gtk3_TreeModel_ConnectRowHasChildToggled(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.guintptr) {
	var f func(path *TreePath, iter *TreeIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, iter *TreeIter))
	}

	var _path *TreePath // out
	var _iter *TreeIter // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_path, _iter)
}

//export _gotk4_gtk3_TreeModel_ConnectRowInserted
func _gotk4_gtk3_TreeModel_ConnectRowInserted(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.guintptr) {
	var f func(path *TreePath, iter *TreeIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, iter *TreeIter))
	}

	var _path *TreePath // out
	var _iter *TreeIter // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_path, _iter)
}

//export _gotk4_gtk3_TreeModel_ConnectRowsReordered
func _gotk4_gtk3_TreeModel_ConnectRowsReordered(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.gpointer, arg4 C.guintptr) {
	var f func(path *TreePath, iter *TreeIter, newOrder unsafe.Pointer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, iter *TreeIter, newOrder unsafe.Pointer))
	}

	var _path *TreePath          // out
	var _iter *TreeIter          // out
	var _newOrder unsafe.Pointer // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_newOrder = (unsafe.Pointer)(unsafe.Pointer(arg3))

	f(_path, _iter, _newOrder)
}

//export _gotk4_gtk3_TreeSortable_ConnectSortColumnChanged
func _gotk4_gtk3_TreeSortable_ConnectSortColumnChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_AboutDialogClass_activate_link
func _gotk4_gtk3_AboutDialogClass_activate_link(arg0 *C.GtkAboutDialog, arg1 *C.gchar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AboutDialogOverrides](instance0)
	if overrides.ActivateLink == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AboutDialogOverrides.ActivateLink, got none")
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := overrides.ActivateLink(_uri)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_AboutDialog_ConnectActivateLink
func _gotk4_gtk3_AboutDialog_ConnectActivateLink(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) (cret C.gboolean) {
	var f func(uri string) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(uri string) (ok bool))
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := f(_uri)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_AccelGroup_ConnectAccelActivate
func _gotk4_gtk3_AccelGroup_ConnectAccelActivate(arg0 C.gpointer, arg1 *C.GObject, arg2 C.guint, arg3 C.GdkModifierType, arg4 C.guintptr) (cret C.gboolean) {
	var f func(acceleratable *coreglib.Object, keyval uint, modifier gdk.ModifierType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(acceleratable *coreglib.Object, keyval uint, modifier gdk.ModifierType) (ok bool))
	}

	var _acceleratable *coreglib.Object // out
	var _keyval uint                    // out
	var _modifier gdk.ModifierType      // out

	_acceleratable = coreglib.Take(unsafe.Pointer(arg1))
	_keyval = uint(arg2)
	_modifier = gdk.ModifierType(arg3)

	ok := f(_acceleratable, _keyval, _modifier)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_AccelMap_ConnectChanged
func _gotk4_gtk3_AccelMap_ConnectChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guint, arg3 C.GdkModifierType, arg4 C.guintptr) {
	var f func(accelPath string, accelKey uint, accelMods gdk.ModifierType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(accelPath string, accelKey uint, accelMods gdk.ModifierType))
	}

	var _accelPath string           // out
	var _accelKey uint              // out
	var _accelMods gdk.ModifierType // out

	_accelPath = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_accelKey = uint(arg2)
	_accelMods = gdk.ModifierType(arg3)

	f(_accelPath, _accelKey, _accelMods)
}

//export _gotk4_gtk3_AccessibleClass_connect_widget_destroyed
func _gotk4_gtk3_AccessibleClass_connect_widget_destroyed(arg0 *C.GtkAccessible) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AccessibleOverrides](instance0)
	if overrides.ConnectWidgetDestroyed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AccessibleOverrides.ConnectWidgetDestroyed, got none")
	}

	overrides.ConnectWidgetDestroyed()
}

//export _gotk4_gtk3_AccessibleClass_widget_set
func _gotk4_gtk3_AccessibleClass_widget_set(arg0 *C.GtkAccessible) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AccessibleOverrides](instance0)
	if overrides.WidgetSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AccessibleOverrides.WidgetSet, got none")
	}

	overrides.WidgetSet()
}

//export _gotk4_gtk3_AccessibleClass_widget_unset
func _gotk4_gtk3_AccessibleClass_widget_unset(arg0 *C.GtkAccessible) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AccessibleOverrides](instance0)
	if overrides.WidgetUnset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AccessibleOverrides.WidgetUnset, got none")
	}

	overrides.WidgetUnset()
}

//export _gotk4_gtk3_ActionClass_activate
func _gotk4_gtk3_ActionClass_activate(arg0 *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_ActionClass_connect_proxy
func _gotk4_gtk3_ActionClass_connect_proxy(arg0 *C.GtkAction, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.ConnectProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.ConnectProxy, got none")
	}

	var _proxy Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	overrides.ConnectProxy(_proxy)
}

//export _gotk4_gtk3_ActionClass_create_menu
func _gotk4_gtk3_ActionClass_create_menu(arg0 *C.GtkAction) (cret *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.CreateMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.CreateMenu, got none")
	}

	widget := overrides.CreateMenu()

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ActionClass_create_menu_item
func _gotk4_gtk3_ActionClass_create_menu_item(arg0 *C.GtkAction) (cret *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.CreateMenuItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.CreateMenuItem, got none")
	}

	widget := overrides.CreateMenuItem()

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ActionClass_create_tool_item
func _gotk4_gtk3_ActionClass_create_tool_item(arg0 *C.GtkAction) (cret *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.CreateToolItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.CreateToolItem, got none")
	}

	widget := overrides.CreateToolItem()

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ActionClass_disconnect_proxy
func _gotk4_gtk3_ActionClass_disconnect_proxy(arg0 *C.GtkAction, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionOverrides](instance0)
	if overrides.DisconnectProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionOverrides.DisconnectProxy, got none")
	}

	var _proxy Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	overrides.DisconnectProxy(_proxy)
}

//export _gotk4_gtk3_Action_ConnectActivate
func _gotk4_gtk3_Action_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ActionGroupClass_get_action
func _gotk4_gtk3_ActionGroupClass_get_action(arg0 *C.GtkActionGroup, arg1 *C.gchar) (cret *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ActionGroupOverrides](instance0)
	if overrides.Action == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ActionGroupOverrides.Action, got none")
	}

	var _actionName string // out

	_actionName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	action := overrides.Action(_actionName)

	var _ *Action

	cret = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	return cret
}

//export _gotk4_gtk3_ActionGroup_ConnectConnectProxy
func _gotk4_gtk3_ActionGroup_ConnectConnectProxy(arg0 C.gpointer, arg1 *C.GtkAction, arg2 *C.GtkWidget, arg3 C.guintptr) {
	var f func(action *Action, proxy Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(action *Action, proxy Widgetter))
	}

	var _action *Action  // out
	var _proxy Widgetter // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	f(_action, _proxy)
}

//export _gotk4_gtk3_ActionGroup_ConnectDisconnectProxy
func _gotk4_gtk3_ActionGroup_ConnectDisconnectProxy(arg0 C.gpointer, arg1 *C.GtkAction, arg2 *C.GtkWidget, arg3 C.guintptr) {
	var f func(action *Action, proxy Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(action *Action, proxy Widgetter))
	}

	var _action *Action  // out
	var _proxy Widgetter // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	f(_action, _proxy)
}

//export _gotk4_gtk3_ActionGroup_ConnectPostActivate
func _gotk4_gtk3_ActionGroup_ConnectPostActivate(arg0 C.gpointer, arg1 *C.GtkAction, arg2 C.guintptr) {
	var f func(action *Action)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(action *Action))
	}

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))

	f(_action)
}

//export _gotk4_gtk3_ActionGroup_ConnectPreActivate
func _gotk4_gtk3_ActionGroup_ConnectPreActivate(arg0 C.gpointer, arg1 *C.GtkAction, arg2 C.guintptr) {
	var f func(action *Action)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(action *Action))
	}

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))

	f(_action)
}

//export _gotk4_gtk3_AdjustmentClass_changed
func _gotk4_gtk3_AdjustmentClass_changed(arg0 *C.GtkAdjustment) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AdjustmentOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AdjustmentOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_AdjustmentClass_value_changed
func _gotk4_gtk3_AdjustmentClass_value_changed(arg0 *C.GtkAdjustment) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AdjustmentOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AdjustmentOverrides.ValueChanged, got none")
	}

	overrides.ValueChanged()
}

//export _gotk4_gtk3_Adjustment_ConnectChanged
func _gotk4_gtk3_Adjustment_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Adjustment_ConnectValueChanged
func _gotk4_gtk3_Adjustment_ConnectValueChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_AppChooserButtonClass_custom_item_activated
func _gotk4_gtk3_AppChooserButtonClass_custom_item_activated(arg0 *C.GtkAppChooserButton, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AppChooserButtonOverrides](instance0)
	if overrides.CustomItemActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AppChooserButtonOverrides.CustomItemActivated, got none")
	}

	var _itemName string // out

	_itemName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.CustomItemActivated(_itemName)
}

//export _gotk4_gtk3_AppChooserButton_ConnectCustomItemActivated
func _gotk4_gtk3_AppChooserButton_ConnectCustomItemActivated(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(itemName string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(itemName string))
	}

	var _itemName string // out

	_itemName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_itemName)
}

//export _gotk4_gtk3_AppChooserWidgetClass_application_activated
func _gotk4_gtk3_AppChooserWidgetClass_application_activated(arg0 *C.GtkAppChooserWidget, arg1 *C.GAppInfo) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AppChooserWidgetOverrides](instance0)
	if overrides.ApplicationActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AppChooserWidgetOverrides.ApplicationActivated, got none")
	}

	var _appInfo gio.AppInfor // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AppInfor)
			return ok
		})
		rv, ok := casted.(gio.AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_appInfo = rv
	}

	overrides.ApplicationActivated(_appInfo)
}

//export _gotk4_gtk3_AppChooserWidgetClass_application_selected
func _gotk4_gtk3_AppChooserWidgetClass_application_selected(arg0 *C.GtkAppChooserWidget, arg1 *C.GAppInfo) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AppChooserWidgetOverrides](instance0)
	if overrides.ApplicationSelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AppChooserWidgetOverrides.ApplicationSelected, got none")
	}

	var _appInfo gio.AppInfor // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AppInfor)
			return ok
		})
		rv, ok := casted.(gio.AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_appInfo = rv
	}

	overrides.ApplicationSelected(_appInfo)
}

//export _gotk4_gtk3_AppChooserWidgetClass_populate_popup
func _gotk4_gtk3_AppChooserWidgetClass_populate_popup(arg0 *C.GtkAppChooserWidget, arg1 *C.GtkMenu, arg2 *C.GAppInfo) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AppChooserWidgetOverrides](instance0)
	if overrides.PopulatePopup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AppChooserWidgetOverrides.PopulatePopup, got none")
	}

	var _menu *Menu           // out
	var _appInfo gio.AppInfor // out

	_menu = wrapMenu(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AppInfor)
			return ok
		})
		rv, ok := casted.(gio.AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_appInfo = rv
	}

	overrides.PopulatePopup(_menu, _appInfo)
}

//export _gotk4_gtk3_AppChooserWidget_ConnectApplicationActivated
func _gotk4_gtk3_AppChooserWidget_ConnectApplicationActivated(arg0 C.gpointer, arg1 *C.GAppInfo, arg2 C.guintptr) {
	var f func(application gio.AppInfor)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(application gio.AppInfor))
	}

	var _application gio.AppInfor // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AppInfor)
			return ok
		})
		rv, ok := casted.(gio.AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_application = rv
	}

	f(_application)
}

//export _gotk4_gtk3_AppChooserWidget_ConnectApplicationSelected
func _gotk4_gtk3_AppChooserWidget_ConnectApplicationSelected(arg0 C.gpointer, arg1 *C.GAppInfo, arg2 C.guintptr) {
	var f func(application gio.AppInfor)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(application gio.AppInfor))
	}

	var _application gio.AppInfor // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AppInfor)
			return ok
		})
		rv, ok := casted.(gio.AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_application = rv
	}

	f(_application)
}

//export _gotk4_gtk3_AppChooserWidget_ConnectPopulatePopup
func _gotk4_gtk3_AppChooserWidget_ConnectPopulatePopup(arg0 C.gpointer, arg1 *C.GtkMenu, arg2 *C.GAppInfo, arg3 C.guintptr) {
	var f func(menu *Menu, application gio.AppInfor)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(menu *Menu, application gio.AppInfor))
	}

	var _menu *Menu               // out
	var _application gio.AppInfor // out

	_menu = wrapMenu(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gio.AppInfor is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AppInfor)
			return ok
		})
		rv, ok := casted.(gio.AppInfor)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AppInfor")
		}
		_application = rv
	}

	f(_menu, _application)
}

//export _gotk4_gtk3_ApplicationClass_window_added
func _gotk4_gtk3_ApplicationClass_window_added(arg0 *C.GtkApplication, arg1 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ApplicationOverrides](instance0)
	if overrides.WindowAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ApplicationOverrides.WindowAdded, got none")
	}

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.WindowAdded(_window)
}

//export _gotk4_gtk3_ApplicationClass_window_removed
func _gotk4_gtk3_ApplicationClass_window_removed(arg0 *C.GtkApplication, arg1 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ApplicationOverrides](instance0)
	if overrides.WindowRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ApplicationOverrides.WindowRemoved, got none")
	}

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.WindowRemoved(_window)
}

//export _gotk4_gtk3_Application_ConnectQueryEnd
func _gotk4_gtk3_Application_ConnectQueryEnd(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Application_ConnectWindowAdded
func _gotk4_gtk3_Application_ConnectWindowAdded(arg0 C.gpointer, arg1 *C.GtkWindow, arg2 C.guintptr) {
	var f func(window *Window)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(window *Window))
	}

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(arg1)))

	f(_window)
}

//export _gotk4_gtk3_Application_ConnectWindowRemoved
func _gotk4_gtk3_Application_ConnectWindowRemoved(arg0 C.gpointer, arg1 *C.GtkWindow, arg2 C.guintptr) {
	var f func(window *Window)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(window *Window))
	}

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(arg1)))

	f(_window)
}

//export _gotk4_gtk3_AssistantClass_apply
func _gotk4_gtk3_AssistantClass_apply(arg0 *C.GtkAssistant) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AssistantOverrides](instance0)
	if overrides.Apply == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AssistantOverrides.Apply, got none")
	}

	overrides.Apply()
}

//export _gotk4_gtk3_AssistantClass_cancel
func _gotk4_gtk3_AssistantClass_cancel(arg0 *C.GtkAssistant) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AssistantOverrides](instance0)
	if overrides.Cancel == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AssistantOverrides.Cancel, got none")
	}

	overrides.Cancel()
}

//export _gotk4_gtk3_AssistantClass_close
func _gotk4_gtk3_AssistantClass_close(arg0 *C.GtkAssistant) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AssistantOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AssistantOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk3_AssistantClass_prepare
func _gotk4_gtk3_AssistantClass_prepare(arg0 *C.GtkAssistant, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AssistantOverrides](instance0)
	if overrides.Prepare == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AssistantOverrides.Prepare, got none")
	}

	var _page Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}

	overrides.Prepare(_page)
}

//export _gotk4_gtk3_Assistant_ConnectApply
func _gotk4_gtk3_Assistant_ConnectApply(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Assistant_ConnectCancel
func _gotk4_gtk3_Assistant_ConnectCancel(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Assistant_ConnectClose
func _gotk4_gtk3_Assistant_ConnectClose(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Assistant_ConnectEscape
func _gotk4_gtk3_Assistant_ConnectEscape(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Assistant_ConnectPrepare
func _gotk4_gtk3_Assistant_ConnectPrepare(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(page Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(page Widgetter))
	}

	var _page Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}

	f(_page)
}

//export _gotk4_gtk3_BuilderClass_get_type_from_name
func _gotk4_gtk3_BuilderClass_get_type_from_name(arg0 *C.GtkBuilder, arg1 *C.char) (cret C.GType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BuilderOverrides](instance0)
	if overrides.TypeFromName == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BuilderOverrides.TypeFromName, got none")
	}

	var _typeName string // out

	_typeName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	gType := overrides.TypeFromName(_typeName)

	var _ coreglib.Type

	cret = C.GType(gType)

	return cret
}

//export _gotk4_gtk3_ButtonClass_activate
func _gotk4_gtk3_ButtonClass_activate(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_ButtonClass_clicked
func _gotk4_gtk3_ButtonClass_clicked(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Clicked == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Clicked, got none")
	}

	overrides.Clicked()
}

//export _gotk4_gtk3_ButtonClass_enter
func _gotk4_gtk3_ButtonClass_enter(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Enter == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Enter, got none")
	}

	overrides.Enter()
}

//export _gotk4_gtk3_ButtonClass_leave
func _gotk4_gtk3_ButtonClass_leave(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Leave == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Leave, got none")
	}

	overrides.Leave()
}

//export _gotk4_gtk3_ButtonClass_pressed
func _gotk4_gtk3_ButtonClass_pressed(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Pressed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Pressed, got none")
	}

	overrides.Pressed()
}

//export _gotk4_gtk3_ButtonClass_released
func _gotk4_gtk3_ButtonClass_released(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Released == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Released, got none")
	}

	overrides.Released()
}

//export _gotk4_gtk3_Button_ConnectActivate
func _gotk4_gtk3_Button_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Button_ConnectClicked
func _gotk4_gtk3_Button_ConnectClicked(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Button_ConnectEnter
func _gotk4_gtk3_Button_ConnectEnter(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Button_ConnectLeave
func _gotk4_gtk3_Button_ConnectLeave(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Button_ConnectPressed
func _gotk4_gtk3_Button_ConnectPressed(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Button_ConnectReleased
func _gotk4_gtk3_Button_ConnectReleased(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_CalendarClass_day_selected
func _gotk4_gtk3_CalendarClass_day_selected(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.DaySelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.DaySelected, got none")
	}

	overrides.DaySelected()
}

//export _gotk4_gtk3_CalendarClass_day_selected_double_click
func _gotk4_gtk3_CalendarClass_day_selected_double_click(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.DaySelectedDoubleClick == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.DaySelectedDoubleClick, got none")
	}

	overrides.DaySelectedDoubleClick()
}

//export _gotk4_gtk3_CalendarClass_month_changed
func _gotk4_gtk3_CalendarClass_month_changed(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.MonthChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.MonthChanged, got none")
	}

	overrides.MonthChanged()
}

//export _gotk4_gtk3_CalendarClass_next_month
func _gotk4_gtk3_CalendarClass_next_month(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.NextMonth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.NextMonth, got none")
	}

	overrides.NextMonth()
}

//export _gotk4_gtk3_CalendarClass_next_year
func _gotk4_gtk3_CalendarClass_next_year(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.NextYear == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.NextYear, got none")
	}

	overrides.NextYear()
}

//export _gotk4_gtk3_CalendarClass_prev_month
func _gotk4_gtk3_CalendarClass_prev_month(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.PrevMonth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.PrevMonth, got none")
	}

	overrides.PrevMonth()
}

//export _gotk4_gtk3_CalendarClass_prev_year
func _gotk4_gtk3_CalendarClass_prev_year(arg0 *C.GtkCalendar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CalendarOverrides](instance0)
	if overrides.PrevYear == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CalendarOverrides.PrevYear, got none")
	}

	overrides.PrevYear()
}

//export _gotk4_gtk3_Calendar_ConnectDaySelected
func _gotk4_gtk3_Calendar_ConnectDaySelected(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Calendar_ConnectDaySelectedDoubleClick
func _gotk4_gtk3_Calendar_ConnectDaySelectedDoubleClick(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Calendar_ConnectMonthChanged
func _gotk4_gtk3_Calendar_ConnectMonthChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Calendar_ConnectNextMonth
func _gotk4_gtk3_Calendar_ConnectNextMonth(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Calendar_ConnectNextYear
func _gotk4_gtk3_Calendar_ConnectNextYear(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Calendar_ConnectPrevMonth
func _gotk4_gtk3_Calendar_ConnectPrevMonth(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Calendar_ConnectPrevYear
func _gotk4_gtk3_Calendar_ConnectPrevYear(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_CellAccessibleClass_update_cache
func _gotk4_gtk3_CellAccessibleClass_update_cache(arg0 *C.GtkCellAccessible, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAccessibleOverrides](instance0)
	if overrides.UpdateCache == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAccessibleOverrides.UpdateCache, got none")
	}

	var _emitSignal bool // out

	if arg1 != 0 {
		_emitSignal = true
	}

	overrides.UpdateCache(_emitSignal)
}

//export _gotk4_gtk3_CellAreaClass_activate
func _gotk4_gtk3_CellAreaClass_activate(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GdkRectangle, arg4 C.GtkCellRendererState, arg5 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Activate, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _cellArea *gdk.Rectangle  // out
	var _flags CellRendererState  // out
	var _editOnly bool            // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_flags = CellRendererState(arg4)
	if arg5 != 0 {
		_editOnly = true
	}

	ok := overrides.Activate(_context, _widget, _cellArea, _flags, _editOnly)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellAreaClass_add
func _gotk4_gtk3_CellAreaClass_add(arg0 *C.GtkCellArea, arg1 *C.GtkCellRenderer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Add == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Add, got none")
	}

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	overrides.Add(_renderer)
}

//export _gotk4_gtk3_CellAreaClass_apply_attributes
func _gotk4_gtk3_CellAreaClass_apply_attributes(arg0 *C.GtkCellArea, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.gboolean, arg4 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.ApplyAttributes == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.ApplyAttributes, got none")
	}

	var _treeModel TreeModeller // out
	var _iter *TreeIter         // out
	var _isExpander bool        // out
	var _isExpanded bool        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_treeModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	if arg3 != 0 {
		_isExpander = true
	}
	if arg4 != 0 {
		_isExpanded = true
	}

	overrides.ApplyAttributes(_treeModel, _iter, _isExpander, _isExpanded)
}

//export _gotk4_gtk3_CellAreaClass_copy_context
func _gotk4_gtk3_CellAreaClass_copy_context(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext) (cret *C.GtkCellAreaContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.CopyContext == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.CopyContext, got none")
	}

	var _context *CellAreaContext // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))

	cellAreaContext := overrides.CopyContext(_context)

	var _ *CellAreaContext

	cret = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(cellAreaContext).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(cellAreaContext).Native()))

	return cret
}

//export _gotk4_gtk3_CellAreaClass_create_context
func _gotk4_gtk3_CellAreaClass_create_context(arg0 *C.GtkCellArea) (cret *C.GtkCellAreaContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.CreateContext == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.CreateContext, got none")
	}

	cellAreaContext := overrides.CreateContext()

	var _ *CellAreaContext

	cret = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(cellAreaContext).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(cellAreaContext).Native()))

	return cret
}

//export _gotk4_gtk3_CellAreaClass_event
func _gotk4_gtk3_CellAreaClass_event(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GdkEvent, arg4 *C.GdkRectangle, arg5 C.GtkCellRendererState) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Event == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Event, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _event *gdk.Event         // out
	var _cellArea *gdk.Rectangle  // out
	var _flags CellRendererState  // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg3)))
		v = gdk.CopyEventer(v)
		_event = v
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_flags = CellRendererState(arg5)

	gint := overrides.Event(_context, _widget, _event, _cellArea, _flags)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_CellAreaClass_focus
func _gotk4_gtk3_CellAreaClass_focus(arg0 *C.GtkCellArea, arg1 C.GtkDirectionType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Focus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Focus, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := overrides.Focus(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellAreaClass_get_preferred_height
func _gotk4_gtk3_CellAreaClass_get_preferred_height(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredHeight, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumHeight, naturalHeight := overrides.PreferredHeight(_context, _widget)

	var _ int
	var _ int

	*arg3 = C.gint(minimumHeight)
	*arg4 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_CellAreaClass_get_preferred_height_for_width
func _gotk4_gtk3_CellAreaClass_get_preferred_height_for_width(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 C.gint, arg4 *C.gint, arg5 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredHeightForWidth, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _width int                // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int(arg3)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_context, _widget, _width)

	var _ int
	var _ int

	*arg4 = C.gint(minimumHeight)
	*arg5 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_CellAreaClass_get_preferred_width
func _gotk4_gtk3_CellAreaClass_get_preferred_width(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredWidth, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumWidth, naturalWidth := overrides.PreferredWidth(_context, _widget)

	var _ int
	var _ int

	*arg3 = C.gint(minimumWidth)
	*arg4 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_CellAreaClass_get_preferred_width_for_height
func _gotk4_gtk3_CellAreaClass_get_preferred_width_for_height(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 C.gint, arg4 *C.gint, arg5 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredWidthForHeight, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _height int               // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_height = int(arg3)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_context, _widget, _height)

	var _ int
	var _ int

	*arg4 = C.gint(minimumWidth)
	*arg5 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_CellAreaClass_get_request_mode
func _gotk4_gtk3_CellAreaClass_get_request_mode(arg0 *C.GtkCellArea) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.RequestMode, got none")
	}

	sizeRequestMode := overrides.RequestMode()

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk3_CellAreaClass_is_activatable
func _gotk4_gtk3_CellAreaClass_is_activatable(arg0 *C.GtkCellArea) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.IsActivatable == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.IsActivatable, got none")
	}

	ok := overrides.IsActivatable()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellAreaClass_remove
func _gotk4_gtk3_CellAreaClass_remove(arg0 *C.GtkCellArea, arg1 *C.GtkCellRenderer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Remove == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Remove, got none")
	}

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	overrides.Remove(_renderer)
}

//export _gotk4_gtk3_CellAreaClass_render
func _gotk4_gtk3_CellAreaClass_render(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.cairo_t, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState, arg7 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Render == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Render, got none")
	}

	var _context *CellAreaContext      // out
	var _widget Widgetter              // out
	var _cr *cairo.Context             // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out
	var _paintFocus bool               // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg3)))
	C.cairo_reference(arg3)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)
	if arg7 != 0 {
		_paintFocus = true
	}

	overrides.Render(_context, _widget, _cr, _backgroundArea, _cellArea, _flags, _paintFocus)
}

//export _gotk4_gtk3_CellArea_ConnectAddEditable
func _gotk4_gtk3_CellArea_ConnectAddEditable(arg0 C.gpointer, arg1 *C.GtkCellRenderer, arg2 *C.GtkCellEditable, arg3 *C.GdkRectangle, arg4 *C.gchar, arg5 C.guintptr) {
	var f func(renderer CellRendererer, editable CellEditabler, cellArea *gdk.Rectangle, path string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(renderer CellRendererer, editable CellEditabler, cellArea *gdk.Rectangle, path string))
	}

	var _renderer CellRendererer // out
	var _editable CellEditabler  // out
	var _cellArea *gdk.Rectangle // out
	var _path string             // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))

	f(_renderer, _editable, _cellArea, _path)
}

//export _gotk4_gtk3_CellArea_ConnectApplyAttributes
func _gotk4_gtk3_CellArea_ConnectApplyAttributes(arg0 C.gpointer, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.gboolean, arg4 C.gboolean, arg5 C.guintptr) {
	var f func(model TreeModeller, iter *TreeIter, isExpander, isExpanded bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(model TreeModeller, iter *TreeIter, isExpander, isExpanded bool))
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out
	var _isExpander bool    // out
	var _isExpanded bool    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	if arg3 != 0 {
		_isExpander = true
	}
	if arg4 != 0 {
		_isExpanded = true
	}

	f(_model, _iter, _isExpander, _isExpanded)
}

//export _gotk4_gtk3_CellArea_ConnectFocusChanged
func _gotk4_gtk3_CellArea_ConnectFocusChanged(arg0 C.gpointer, arg1 *C.GtkCellRenderer, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(renderer CellRendererer, path string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(renderer CellRendererer, path string))
	}

	var _renderer CellRendererer // out
	var _path string             // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_renderer, _path)
}

//export _gotk4_gtk3_CellArea_ConnectRemoveEditable
func _gotk4_gtk3_CellArea_ConnectRemoveEditable(arg0 C.gpointer, arg1 *C.GtkCellRenderer, arg2 *C.GtkCellEditable, arg3 C.guintptr) {
	var f func(renderer CellRendererer, editable CellEditabler)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(renderer CellRendererer, editable CellEditabler))
	}

	var _renderer CellRendererer // out
	var _editable CellEditabler  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}

	f(_renderer, _editable)
}

//export _gotk4_gtk3_CellAreaContextClass_allocate
func _gotk4_gtk3_CellAreaContextClass_allocate(arg0 *C.GtkCellAreaContext, arg1 C.gint, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.Allocate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.Allocate, got none")
	}

	var _width int  // out
	var _height int // out

	_width = int(arg1)
	_height = int(arg2)

	overrides.Allocate(_width, _height)
}

//export _gotk4_gtk3_CellAreaContextClass_get_preferred_height_for_width
func _gotk4_gtk3_CellAreaContextClass_get_preferred_height_for_width(arg0 *C.GtkCellAreaContext, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.PreferredHeightForWidth, got none")
	}

	var _width int // out

	_width = int(arg1)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_width)

	var _ int
	var _ int

	*arg2 = C.gint(minimumHeight)
	*arg3 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_CellAreaContextClass_get_preferred_width_for_height
func _gotk4_gtk3_CellAreaContextClass_get_preferred_width_for_height(arg0 *C.GtkCellAreaContext, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.PreferredWidthForHeight, got none")
	}

	var _height int // out

	_height = int(arg1)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_height)

	var _ int
	var _ int

	*arg2 = C.gint(minimumWidth)
	*arg3 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_CellAreaContextClass_reset
func _gotk4_gtk3_CellAreaContextClass_reset(arg0 *C.GtkCellAreaContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.Reset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.Reset, got none")
	}

	overrides.Reset()
}

//export _gotk4_gtk3_CellRendererClass_activate
func _gotk4_gtk3_CellRendererClass_activate(arg0 *C.GtkCellRenderer, arg1 *C.GdkEvent, arg2 *C.GtkWidget, arg3 *C.gchar, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.Activate, got none")
	}

	var _event *gdk.Event              // out
	var _widget Widgetter              // out
	var _path string                   // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		v = gdk.CopyEventer(v)
		_event = v
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)

	ok := overrides.Activate(_event, _widget, _path, _backgroundArea, _cellArea, _flags)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_CellRendererClass_editing_canceled
func _gotk4_gtk3_CellRendererClass_editing_canceled(arg0 *C.GtkCellRenderer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.EditingCanceled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.EditingCanceled, got none")
	}

	overrides.EditingCanceled()
}

//export _gotk4_gtk3_CellRendererClass_editing_started
func _gotk4_gtk3_CellRendererClass_editing_started(arg0 *C.GtkCellRenderer, arg1 *C.GtkCellEditable, arg2 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.EditingStarted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.EditingStarted, got none")
	}

	var _editable CellEditabler // out
	var _path string            // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.EditingStarted(_editable, _path)
}

//export _gotk4_gtk3_CellRendererClass_get_aligned_area
func _gotk4_gtk3_CellRendererClass_get_aligned_area(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 C.GtkCellRendererState, arg3 *C.GdkRectangle, arg4 *C.GdkRectangle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.AlignedArea == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.AlignedArea, got none")
	}

	var _widget Widgetter        // out
	var _flags CellRendererState // out
	var _cellArea *gdk.Rectangle // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_flags = CellRendererState(arg2)
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	alignedArea := overrides.AlignedArea(_widget, _flags, _cellArea)

	var _ *gdk.Rectangle

	*arg4 = *(*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(alignedArea)))
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_height
func _gotk4_gtk3_CellRendererClass_get_preferred_height(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredHeight, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := overrides.PreferredHeight(_widget)

	var _ int
	var _ int

	*arg2 = C.gint(minimumSize)
	*arg3 = C.gint(naturalSize)
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_height_for_width
func _gotk4_gtk3_CellRendererClass_get_preferred_height_for_width(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 C.gint, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredHeightForWidth, got none")
	}

	var _widget Widgetter // out
	var _width int        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int(arg2)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_widget, _width)

	var _ int
	var _ int

	*arg3 = C.gint(minimumHeight)
	*arg4 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_width
func _gotk4_gtk3_CellRendererClass_get_preferred_width(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredWidth, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := overrides.PreferredWidth(_widget)

	var _ int
	var _ int

	*arg2 = C.gint(minimumSize)
	*arg3 = C.gint(naturalSize)
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_width_for_height
func _gotk4_gtk3_CellRendererClass_get_preferred_width_for_height(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 C.gint, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredWidthForHeight, got none")
	}

	var _widget Widgetter // out
	var _height int       // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_height = int(arg2)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_widget, _height)

	var _ int
	var _ int

	*arg3 = C.gint(minimumWidth)
	*arg4 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_CellRendererClass_get_request_mode
func _gotk4_gtk3_CellRendererClass_get_request_mode(arg0 *C.GtkCellRenderer) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.RequestMode, got none")
	}

	sizeRequestMode := overrides.RequestMode()

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk3_CellRendererClass_get_size
func _gotk4_gtk3_CellRendererClass_get_size(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 *C.GdkRectangle, arg3 *C.gint, arg4 *C.gint, arg5 *C.gint, arg6 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.Size == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.Size, got none")
	}

	var _widget Widgetter        // out
	var _cellArea *gdk.Rectangle // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	if arg2 != nil {
		_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	}

	xOffset, yOffset, width, height := overrides.Size(_widget, _cellArea)

	var _ int
	var _ int
	var _ int
	var _ int

	*arg3 = C.gint(xOffset)
	*arg4 = C.gint(yOffset)
	*arg5 = C.gint(width)
	*arg6 = C.gint(height)
}

//export _gotk4_gtk3_CellRendererClass_render
func _gotk4_gtk3_CellRendererClass_render(arg0 *C.GtkCellRenderer, arg1 *C.cairo_t, arg2 *C.GtkWidget, arg3 *C.GdkRectangle, arg4 *C.GdkRectangle, arg5 C.GtkCellRendererState) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.Render == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.Render, got none")
	}

	var _cr *cairo.Context             // out
	var _widget Widgetter              // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_flags = CellRendererState(arg5)

	overrides.Render(_cr, _widget, _backgroundArea, _cellArea, _flags)
}

//export _gotk4_gtk3_CellRendererClass_start_editing
func _gotk4_gtk3_CellRendererClass_start_editing(arg0 *C.GtkCellRenderer, arg1 *C.GdkEvent, arg2 *C.GtkWidget, arg3 *C.gchar, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState) (cret *C.GtkCellEditable) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.StartEditing == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.StartEditing, got none")
	}

	var _event *gdk.Event              // out
	var _widget Widgetter              // out
	var _path string                   // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out

	if arg1 != nil {
		{
			v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
			v = gdk.CopyEventer(v)
			_event = v
		}
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)

	cellEditable := overrides.StartEditing(_event, _widget, _path, _backgroundArea, _cellArea, _flags)

	var _ *CellEditable

	if cellEditable != nil {
		cret = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(cellEditable).Native()))
	}

	return cret
}

//export _gotk4_gtk3_CellRenderer_ConnectEditingCanceled
func _gotk4_gtk3_CellRenderer_ConnectEditingCanceled(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_CellRenderer_ConnectEditingStarted
func _gotk4_gtk3_CellRenderer_ConnectEditingStarted(arg0 C.gpointer, arg1 *C.GtkCellEditable, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(editable CellEditabler, path string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(editable CellEditabler, path string))
	}

	var _editable CellEditabler // out
	var _path string            // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_editable, _path)
}

//export _gotk4_gtk3_CellRendererAccelClass_accel_cleared
func _gotk4_gtk3_CellRendererAccelClass_accel_cleared(arg0 *C.GtkCellRendererAccel, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererAccelOverrides](instance0)
	if overrides.AccelCleared == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererAccelOverrides.AccelCleared, got none")
	}

	var _pathString string // out

	_pathString = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.AccelCleared(_pathString)
}

//export _gotk4_gtk3_CellRendererAccelClass_accel_edited
func _gotk4_gtk3_CellRendererAccelClass_accel_edited(arg0 *C.GtkCellRendererAccel, arg1 *C.gchar, arg2 C.guint, arg3 C.GdkModifierType, arg4 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererAccelOverrides](instance0)
	if overrides.AccelEdited == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererAccelOverrides.AccelEdited, got none")
	}

	var _pathString string          // out
	var _accelKey uint              // out
	var _accelMods gdk.ModifierType // out
	var _hardwareKeycode uint       // out

	_pathString = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_accelKey = uint(arg2)
	_accelMods = gdk.ModifierType(arg3)
	_hardwareKeycode = uint(arg4)

	overrides.AccelEdited(_pathString, _accelKey, _accelMods, _hardwareKeycode)
}

//export _gotk4_gtk3_CellRendererAccel_ConnectAccelCleared
func _gotk4_gtk3_CellRendererAccel_ConnectAccelCleared(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(pathString string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(pathString string))
	}

	var _pathString string // out

	_pathString = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_pathString)
}

//export _gotk4_gtk3_CellRendererAccel_ConnectAccelEdited
func _gotk4_gtk3_CellRendererAccel_ConnectAccelEdited(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guint, arg3 C.GdkModifierType, arg4 C.guint, arg5 C.guintptr) {
	var f func(pathString string, accelKey uint, accelMods gdk.ModifierType, hardwareKeycode uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(pathString string, accelKey uint, accelMods gdk.ModifierType, hardwareKeycode uint))
	}

	var _pathString string          // out
	var _accelKey uint              // out
	var _accelMods gdk.ModifierType // out
	var _hardwareKeycode uint       // out

	_pathString = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_accelKey = uint(arg2)
	_accelMods = gdk.ModifierType(arg3)
	_hardwareKeycode = uint(arg4)

	f(_pathString, _accelKey, _accelMods, _hardwareKeycode)
}

//export _gotk4_gtk3_CellRendererCombo_ConnectChanged
func _gotk4_gtk3_CellRendererCombo_ConnectChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.GtkTreeIter, arg3 C.guintptr) {
	var f func(pathString string, newIter *TreeIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(pathString string, newIter *TreeIter))
	}

	var _pathString string // out
	var _newIter *TreeIter // out

	_pathString = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_newIter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_pathString, _newIter)
}

//export _gotk4_gtk3_CellRendererTextClass_edited
func _gotk4_gtk3_CellRendererTextClass_edited(arg0 *C.GtkCellRendererText, arg1 *C.gchar, arg2 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererTextOverrides](instance0)
	if overrides.Edited == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererTextOverrides.Edited, got none")
	}

	var _path string    // out
	var _newText string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_newText = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.Edited(_path, _newText)
}

//export _gotk4_gtk3_CellRendererText_ConnectEdited
func _gotk4_gtk3_CellRendererText_ConnectEdited(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(path, newText string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path, newText string))
	}

	var _path string    // out
	var _newText string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_newText = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_path, _newText)
}

//export _gotk4_gtk3_CellRendererToggleClass_toggled
func _gotk4_gtk3_CellRendererToggleClass_toggled(arg0 *C.GtkCellRendererToggle, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererToggleOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererToggleOverrides.Toggled, got none")
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.Toggled(_path)
}

//export _gotk4_gtk3_CellRendererToggle_ConnectToggled
func _gotk4_gtk3_CellRendererToggle_ConnectToggled(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(path string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path string))
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_path)
}

//export _gotk4_gtk3_CheckButtonClass_draw_indicator
func _gotk4_gtk3_CheckButtonClass_draw_indicator(arg0 *C.GtkCheckButton, arg1 *C.cairo_t) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CheckButtonOverrides](instance0)
	if overrides.DrawIndicator == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CheckButtonOverrides.DrawIndicator, got none")
	}

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	overrides.DrawIndicator(_cr)
}

//export _gotk4_gtk3_CheckMenuItemClass_draw_indicator
func _gotk4_gtk3_CheckMenuItemClass_draw_indicator(arg0 *C.GtkCheckMenuItem, arg1 *C.cairo_t) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CheckMenuItemOverrides](instance0)
	if overrides.DrawIndicator == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CheckMenuItemOverrides.DrawIndicator, got none")
	}

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	overrides.DrawIndicator(_cr)
}

//export _gotk4_gtk3_CheckMenuItemClass_toggled
func _gotk4_gtk3_CheckMenuItemClass_toggled(arg0 *C.GtkCheckMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CheckMenuItemOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CheckMenuItemOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk3_CheckMenuItem_ConnectToggled
func _gotk4_gtk3_CheckMenuItem_ConnectToggled(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Clipboard_ConnectOwnerChange
func _gotk4_gtk3_Clipboard_ConnectOwnerChange(arg0 C.gpointer, arg1 *C.GdkEventOwnerChange, arg2 C.guintptr) {
	var f func(event *gdk.EventOwnerChange)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventOwnerChange))
	}

	var _event *gdk.EventOwnerChange // out

	_event = (*gdk.EventOwnerChange)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	f(_event)
}

//export _gotk4_gtk3_ColorButtonClass_color_set
func _gotk4_gtk3_ColorButtonClass_color_set(arg0 *C.GtkColorButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ColorButtonOverrides](instance0)
	if overrides.ColorSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ColorButtonOverrides.ColorSet, got none")
	}

	overrides.ColorSet()
}

//export _gotk4_gtk3_ColorButton_ConnectColorSet
func _gotk4_gtk3_ColorButton_ConnectColorSet(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ColorSelectionClass_color_changed
func _gotk4_gtk3_ColorSelectionClass_color_changed(arg0 *C.GtkColorSelection) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ColorSelectionOverrides](instance0)
	if overrides.ColorChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ColorSelectionOverrides.ColorChanged, got none")
	}

	overrides.ColorChanged()
}

//export _gotk4_gtk3_ColorSelection_ConnectColorChanged
func _gotk4_gtk3_ColorSelection_ConnectColorChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ComboBoxClass_changed
func _gotk4_gtk3_ComboBoxClass_changed(arg0 *C.GtkComboBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ComboBoxOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ComboBoxOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_ComboBoxClass_format_entry_text
func _gotk4_gtk3_ComboBoxClass_format_entry_text(arg0 *C.GtkComboBox, arg1 *C.gchar) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ComboBoxOverrides](instance0)
	if overrides.FormatEntryText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ComboBoxOverrides.FormatEntryText, got none")
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	utf8 := overrides.FormatEntryText(_path)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_ComboBox_ConnectChanged
func _gotk4_gtk3_ComboBox_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ComboBox_ConnectFormatEntryText
func _gotk4_gtk3_ComboBox_ConnectFormatEntryText(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) (cret *C.gchar) {
	var f func(path string) (utf8 string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path string) (utf8 string))
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	utf8 := f(_path)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_ComboBox_ConnectMoveActive
func _gotk4_gtk3_ComboBox_ConnectMoveActive(arg0 C.gpointer, arg1 C.GtkScrollType, arg2 C.guintptr) {
	var f func(scrollType ScrollType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(scrollType ScrollType))
	}

	var _scrollType ScrollType // out

	_scrollType = ScrollType(arg1)

	f(_scrollType)
}

//export _gotk4_gtk3_ComboBox_ConnectPopdown
func _gotk4_gtk3_ComboBox_ConnectPopdown(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ComboBox_ConnectPopup
func _gotk4_gtk3_ComboBox_ConnectPopup(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ContainerClass_add
func _gotk4_gtk3_ContainerClass_add(arg0 *C.GtkContainer, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.Add == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.Add, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	overrides.Add(_widget)
}

//export _gotk4_gtk3_ContainerClass_check_resize
func _gotk4_gtk3_ContainerClass_check_resize(arg0 *C.GtkContainer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.CheckResize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.CheckResize, got none")
	}

	overrides.CheckResize()
}

//export _gotk4_gtk3_ContainerClass_child_type
func _gotk4_gtk3_ContainerClass_child_type(arg0 *C.GtkContainer) (cret C.GType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.ChildType == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.ChildType, got none")
	}

	gType := overrides.ChildType()

	var _ coreglib.Type

	cret = C.GType(gType)

	return cret
}

//export _gotk4_gtk3_ContainerClass_composite_name
func _gotk4_gtk3_ContainerClass_composite_name(arg0 *C.GtkContainer, arg1 *C.GtkWidget) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.CompositeName == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.CompositeName, got none")
	}

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	utf8 := overrides.CompositeName(_child)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_ContainerClass_get_path_for_child
func _gotk4_gtk3_ContainerClass_get_path_for_child(arg0 *C.GtkContainer, arg1 *C.GtkWidget) (cret *C.GtkWidgetPath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.PathForChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.PathForChild, got none")
	}

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	widgetPath := overrides.PathForChild(_child)

	var _ *WidgetPath

	cret = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(widgetPath)))

	return cret
}

//export _gotk4_gtk3_ContainerClass_remove
func _gotk4_gtk3_ContainerClass_remove(arg0 *C.GtkContainer, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.Remove == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.Remove, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	overrides.Remove(_widget)
}

//export _gotk4_gtk3_ContainerClass_set_focus_child
func _gotk4_gtk3_ContainerClass_set_focus_child(arg0 *C.GtkContainer, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContainerOverrides](instance0)
	if overrides.SetFocusChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContainerOverrides.SetFocusChild, got none")
	}

	var _child Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_child = rv
		}
	}

	overrides.SetFocusChild(_child)
}

//export _gotk4_gtk3_Container_ConnectAdd
func _gotk4_gtk3_Container_ConnectAdd(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(object Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object Widgetter))
	}

	var _object Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_object = rv
	}

	f(_object)
}

//export _gotk4_gtk3_Container_ConnectCheckResize
func _gotk4_gtk3_Container_ConnectCheckResize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Container_ConnectRemove
func _gotk4_gtk3_Container_ConnectRemove(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(object Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object Widgetter))
	}

	var _object Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_object = rv
	}

	f(_object)
}

//export _gotk4_gtk3_Container_ConnectSetFocusChild
func _gotk4_gtk3_Container_ConnectSetFocusChild(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(object Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object Widgetter))
	}

	var _object Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_object = rv
	}

	f(_object)
}

//export _gotk4_gtk3_CssProviderClass_parsing_error
func _gotk4_gtk3_CssProviderClass_parsing_error(arg0 *C.GtkCssProvider, arg1 *C.GtkCssSection, arg2 *C.GError) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CSSProviderOverrides](instance0)
	if overrides.ParsingError == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CSSProviderOverrides.ParsingError, got none")
	}

	var _section *CSSSection // out
	var _err error           // out

	_section = (*CSSSection)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gtk_css_section_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_section)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_css_section_unref((*C.GtkCssSection)(intern.C))
		},
	)
	_err = gerror.Take(unsafe.Pointer(arg2))

	overrides.ParsingError(_section, _err)
}

//export _gotk4_gtk3_CssProvider_ConnectParsingError
func _gotk4_gtk3_CssProvider_ConnectParsingError(arg0 C.gpointer, arg1 *C.GtkCssSection, arg2 *C.GError, arg3 C.guintptr) {
	var f func(section *CSSSection, err error)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(section *CSSSection, err error))
	}

	var _section *CSSSection // out
	var _err error           // out

	_section = (*CSSSection)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gtk_css_section_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_section)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_css_section_unref((*C.GtkCssSection)(intern.C))
		},
	)
	_err = gerror.Take(unsafe.Pointer(arg2))

	f(_section, _err)
}

//export _gotk4_gtk3_DialogClass_close
func _gotk4_gtk3_DialogClass_close(arg0 *C.GtkDialog) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DialogOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DialogOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk3_DialogClass_response
func _gotk4_gtk3_DialogClass_response(arg0 *C.GtkDialog, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DialogOverrides](instance0)
	if overrides.Response == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DialogOverrides.Response, got none")
	}

	var _responseId int // out

	_responseId = int(arg1)

	overrides.Response(_responseId)
}

//export _gotk4_gtk3_Dialog_ConnectClose
func _gotk4_gtk3_Dialog_ConnectClose(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Dialog_ConnectResponse
func _gotk4_gtk3_Dialog_ConnectResponse(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) {
	var f func(responseId int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(responseId int))
	}

	var _responseId int // out

	_responseId = int(arg1)

	f(_responseId)
}

//export _gotk4_gtk3_EntryClass_activate
func _gotk4_gtk3_EntryClass_activate(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_EntryClass_backspace
func _gotk4_gtk3_EntryClass_backspace(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.Backspace == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.Backspace, got none")
	}

	overrides.Backspace()
}

//export _gotk4_gtk3_EntryClass_copy_clipboard
func _gotk4_gtk3_EntryClass_copy_clipboard(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.CopyClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.CopyClipboard, got none")
	}

	overrides.CopyClipboard()
}

//export _gotk4_gtk3_EntryClass_cut_clipboard
func _gotk4_gtk3_EntryClass_cut_clipboard(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.CutClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.CutClipboard, got none")
	}

	overrides.CutClipboard()
}

//export _gotk4_gtk3_EntryClass_delete_from_cursor
func _gotk4_gtk3_EntryClass_delete_from_cursor(arg0 *C.GtkEntry, arg1 C.GtkDeleteType, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.DeleteFromCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.DeleteFromCursor, got none")
	}

	var _typ DeleteType // out
	var _count int      // out

	_typ = DeleteType(arg1)
	_count = int(arg2)

	overrides.DeleteFromCursor(_typ, _count)
}

//export _gotk4_gtk3_EntryClass_get_frame_size
func _gotk4_gtk3_EntryClass_get_frame_size(arg0 *C.GtkEntry, arg1 *C.gint, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.FrameSize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.FrameSize, got none")
	}

	var _x *int      // out
	var _y *int      // out
	var _width *int  // out
	var _height *int // out

	_x = (*int)(unsafe.Pointer(arg1))
	_y = (*int)(unsafe.Pointer(arg2))
	_width = (*int)(unsafe.Pointer(arg3))
	_height = (*int)(unsafe.Pointer(arg4))

	overrides.FrameSize(_x, _y, _width, _height)
}

//export _gotk4_gtk3_EntryClass_get_text_area_size
func _gotk4_gtk3_EntryClass_get_text_area_size(arg0 *C.GtkEntry, arg1 *C.gint, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.TextAreaSize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.TextAreaSize, got none")
	}

	var _x *int      // out
	var _y *int      // out
	var _width *int  // out
	var _height *int // out

	_x = (*int)(unsafe.Pointer(arg1))
	_y = (*int)(unsafe.Pointer(arg2))
	_width = (*int)(unsafe.Pointer(arg3))
	_height = (*int)(unsafe.Pointer(arg4))

	overrides.TextAreaSize(_x, _y, _width, _height)
}

//export _gotk4_gtk3_EntryClass_insert_at_cursor
func _gotk4_gtk3_EntryClass_insert_at_cursor(arg0 *C.GtkEntry, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.InsertAtCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.InsertAtCursor, got none")
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.InsertAtCursor(_str)
}

//export _gotk4_gtk3_EntryClass_insert_emoji
func _gotk4_gtk3_EntryClass_insert_emoji(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.InsertEmoji == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.InsertEmoji, got none")
	}

	overrides.InsertEmoji()
}

//export _gotk4_gtk3_EntryClass_move_cursor
func _gotk4_gtk3_EntryClass_move_cursor(arg0 *C.GtkEntry, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.MoveCursor, got none")
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	overrides.MoveCursor(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_EntryClass_paste_clipboard
func _gotk4_gtk3_EntryClass_paste_clipboard(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.PasteClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.PasteClipboard, got none")
	}

	overrides.PasteClipboard()
}

//export _gotk4_gtk3_EntryClass_populate_popup
func _gotk4_gtk3_EntryClass_populate_popup(arg0 *C.GtkEntry, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.PopulatePopup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.PopulatePopup, got none")
	}

	var _popup Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_popup = rv
	}

	overrides.PopulatePopup(_popup)
}

//export _gotk4_gtk3_EntryClass_toggle_overwrite
func _gotk4_gtk3_EntryClass_toggle_overwrite(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.ToggleOverwrite == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.ToggleOverwrite, got none")
	}

	overrides.ToggleOverwrite()
}

//export _gotk4_gtk3_Entry_ConnectActivate
func _gotk4_gtk3_Entry_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Entry_ConnectBackspace
func _gotk4_gtk3_Entry_ConnectBackspace(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Entry_ConnectCopyClipboard
func _gotk4_gtk3_Entry_ConnectCopyClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Entry_ConnectCutClipboard
func _gotk4_gtk3_Entry_ConnectCutClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Entry_ConnectDeleteFromCursor
func _gotk4_gtk3_Entry_ConnectDeleteFromCursor(arg0 C.gpointer, arg1 C.GtkDeleteType, arg2 C.gint, arg3 C.guintptr) {
	var f func(typ DeleteType, count int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(typ DeleteType, count int))
	}

	var _typ DeleteType // out
	var _count int      // out

	_typ = DeleteType(arg1)
	_count = int(arg2)

	f(_typ, _count)
}

//export _gotk4_gtk3_Entry_ConnectIconPress
func _gotk4_gtk3_Entry_ConnectIconPress(arg0 C.gpointer, arg1 C.GtkEntryIconPosition, arg2 C.GdkEvent, arg3 C.guintptr) {
	var f func(iconPos EntryIconPosition, event *gdk.Event)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iconPos EntryIconPosition, event *gdk.Event))
	}

	var _iconPos EntryIconPosition // out
	var _event *gdk.Event          // out

	_iconPos = EntryIconPosition(arg1)
	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg2))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	f(_iconPos, _event)
}

//export _gotk4_gtk3_Entry_ConnectIconRelease
func _gotk4_gtk3_Entry_ConnectIconRelease(arg0 C.gpointer, arg1 C.GtkEntryIconPosition, arg2 C.GdkEvent, arg3 C.guintptr) {
	var f func(iconPos EntryIconPosition, event *gdk.Event)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iconPos EntryIconPosition, event *gdk.Event))
	}

	var _iconPos EntryIconPosition // out
	var _event *gdk.Event          // out

	_iconPos = EntryIconPosition(arg1)
	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg2))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	f(_iconPos, _event)
}

//export _gotk4_gtk3_Entry_ConnectInsertAtCursor
func _gotk4_gtk3_Entry_ConnectInsertAtCursor(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(str string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(str string))
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_str)
}

//export _gotk4_gtk3_Entry_ConnectInsertEmoji
func _gotk4_gtk3_Entry_ConnectInsertEmoji(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Entry_ConnectMoveCursor
func _gotk4_gtk3_Entry_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean, arg4 C.guintptr) {
	var f func(step MovementStep, count int, extendSelection bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step MovementStep, count int, extendSelection bool))
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	f(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_Entry_ConnectPasteClipboard
func _gotk4_gtk3_Entry_ConnectPasteClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Entry_ConnectPopulatePopup
func _gotk4_gtk3_Entry_ConnectPopulatePopup(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(widget Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter))
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	f(_widget)
}

//export _gotk4_gtk3_Entry_ConnectPreeditChanged
func _gotk4_gtk3_Entry_ConnectPreeditChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(preedit string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(preedit string))
	}

	var _preedit string // out

	_preedit = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_preedit)
}

//export _gotk4_gtk3_Entry_ConnectToggleOverwrite
func _gotk4_gtk3_Entry_ConnectToggleOverwrite(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EntryBufferClass_delete_text
func _gotk4_gtk3_EntryBufferClass_delete_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 C.guint) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.DeleteText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.DeleteText, got none")
	}

	var _position uint // out
	var _nChars uint   // out

	_position = uint(arg1)
	_nChars = uint(arg2)

	guint := overrides.DeleteText(_position, _nChars)

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk3_EntryBufferClass_deleted_text
func _gotk4_gtk3_EntryBufferClass_deleted_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.DeletedText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.DeletedText, got none")
	}

	var _position uint // out
	var _nChars uint   // out

	_position = uint(arg1)
	_nChars = uint(arg2)

	overrides.DeletedText(_position, _nChars)
}

//export _gotk4_gtk3_EntryBufferClass_get_length
func _gotk4_gtk3_EntryBufferClass_get_length(arg0 *C.GtkEntryBuffer) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.Length == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.Length, got none")
	}

	guint := overrides.Length()

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk3_EntryBufferClass_get_text
func _gotk4_gtk3_EntryBufferClass_get_text(arg0 *C.GtkEntryBuffer, arg1 *C.gsize) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.Text == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.Text, got none")
	}

	var _nBytes *uint // out

	_nBytes = (*uint)(unsafe.Pointer(arg1))

	utf8 := overrides.Text(_nBytes)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_gtk3_EntryBufferClass_insert_text
func _gotk4_gtk3_EntryBufferClass_insert_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 *C.gchar, arg3 C.guint) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.InsertText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.InsertText, got none")
	}

	var _position uint // out
	var _chars string  // out
	var _nChars uint   // out

	_position = uint(arg1)
	_chars = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_nChars = uint(arg3)

	guint := overrides.InsertText(_position, _chars, _nChars)

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk3_EntryBufferClass_inserted_text
func _gotk4_gtk3_EntryBufferClass_inserted_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 *C.gchar, arg3 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.InsertedText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.InsertedText, got none")
	}

	var _position uint // out
	var _chars string  // out
	var _nChars uint   // out

	_position = uint(arg1)
	_chars = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_nChars = uint(arg3)

	overrides.InsertedText(_position, _chars, _nChars)
}

//export _gotk4_gtk3_EntryBuffer_ConnectDeletedText
func _gotk4_gtk3_EntryBuffer_ConnectDeletedText(arg0 C.gpointer, arg1 C.guint, arg2 C.guint, arg3 C.guintptr) {
	var f func(position, nChars uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(position, nChars uint))
	}

	var _position uint // out
	var _nChars uint   // out

	_position = uint(arg1)
	_nChars = uint(arg2)

	f(_position, _nChars)
}

//export _gotk4_gtk3_EntryBuffer_ConnectInsertedText
func _gotk4_gtk3_EntryBuffer_ConnectInsertedText(arg0 C.gpointer, arg1 C.guint, arg2 *C.gchar, arg3 C.guint, arg4 C.guintptr) {
	var f func(position uint, chars string, nChars uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(position uint, chars string, nChars uint))
	}

	var _position uint // out
	var _chars string  // out
	var _nChars uint   // out

	_position = uint(arg1)
	_chars = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_nChars = uint(arg3)

	f(_position, _chars, _nChars)
}

//export _gotk4_gtk3_EntryCompletionClass_action_activated
func _gotk4_gtk3_EntryCompletionClass_action_activated(arg0 *C.GtkEntryCompletion, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.ActionActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.ActionActivated, got none")
	}

	var _index_ int // out

	_index_ = int(arg1)

	overrides.ActionActivated(_index_)
}

//export _gotk4_gtk3_EntryCompletionClass_cursor_on_match
func _gotk4_gtk3_EntryCompletionClass_cursor_on_match(arg0 *C.GtkEntryCompletion, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.CursorOnMatch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.CursorOnMatch, got none")
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.CursorOnMatch(_model, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EntryCompletionClass_insert_prefix
func _gotk4_gtk3_EntryCompletionClass_insert_prefix(arg0 *C.GtkEntryCompletion, arg1 *C.gchar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.InsertPrefix == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.InsertPrefix, got none")
	}

	var _prefix string // out

	_prefix = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := overrides.InsertPrefix(_prefix)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EntryCompletionClass_match_selected
func _gotk4_gtk3_EntryCompletionClass_match_selected(arg0 *C.GtkEntryCompletion, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.MatchSelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.MatchSelected, got none")
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.MatchSelected(_model, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EntryCompletionClass_no_matches
func _gotk4_gtk3_EntryCompletionClass_no_matches(arg0 *C.GtkEntryCompletion) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryCompletionOverrides](instance0)
	if overrides.NoMatches == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryCompletionOverrides.NoMatches, got none")
	}

	overrides.NoMatches()
}

//export _gotk4_gtk3_EntryCompletion_ConnectActionActivated
func _gotk4_gtk3_EntryCompletion_ConnectActionActivated(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) {
	var f func(index int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(index int))
	}

	var _index int // out

	_index = int(arg1)

	f(_index)
}

//export _gotk4_gtk3_EntryCompletion_ConnectCursorOnMatch
func _gotk4_gtk3_EntryCompletion_ConnectCursorOnMatch(arg0 C.gpointer, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.guintptr) (cret C.gboolean) {
	var f func(model TreeModeller, iter *TreeIter) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(model TreeModeller, iter *TreeIter) (ok bool))
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := f(_model, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EntryCompletion_ConnectInsertPrefix
func _gotk4_gtk3_EntryCompletion_ConnectInsertPrefix(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) (cret C.gboolean) {
	var f func(prefix string) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(prefix string) (ok bool))
	}

	var _prefix string // out

	_prefix = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := f(_prefix)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EntryCompletion_ConnectMatchSelected
func _gotk4_gtk3_EntryCompletion_ConnectMatchSelected(arg0 C.gpointer, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.guintptr) (cret C.gboolean) {
	var f func(model TreeModeller, iter *TreeIter) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(model TreeModeller, iter *TreeIter) (ok bool))
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := f(_model, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EntryCompletion_ConnectNoMatches
func _gotk4_gtk3_EntryCompletion_ConnectNoMatches(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EventControllerKey_ConnectFocusIn
func _gotk4_gtk3_EventControllerKey_ConnectFocusIn(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EventControllerKey_ConnectFocusOut
func _gotk4_gtk3_EventControllerKey_ConnectFocusOut(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EventControllerKey_ConnectIMUpdate
func _gotk4_gtk3_EventControllerKey_ConnectIMUpdate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EventControllerKey_ConnectKeyPressed
func _gotk4_gtk3_EventControllerKey_ConnectKeyPressed(arg0 C.gpointer, arg1 C.guint, arg2 C.guint, arg3 C.GdkModifierType, arg4 C.guintptr) (cret C.gboolean) {
	var f func(keyval, keycode uint, state gdk.ModifierType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(keyval, keycode uint, state gdk.ModifierType) (ok bool))
	}

	var _keyval uint            // out
	var _keycode uint           // out
	var _state gdk.ModifierType // out

	_keyval = uint(arg1)
	_keycode = uint(arg2)
	_state = gdk.ModifierType(arg3)

	ok := f(_keyval, _keycode, _state)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EventControllerKey_ConnectKeyReleased
func _gotk4_gtk3_EventControllerKey_ConnectKeyReleased(arg0 C.gpointer, arg1 C.guint, arg2 C.guint, arg3 C.GdkModifierType, arg4 C.guintptr) {
	var f func(keyval, keycode uint, state gdk.ModifierType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(keyval, keycode uint, state gdk.ModifierType))
	}

	var _keyval uint            // out
	var _keycode uint           // out
	var _state gdk.ModifierType // out

	_keyval = uint(arg1)
	_keycode = uint(arg2)
	_state = gdk.ModifierType(arg3)

	f(_keyval, _keycode, _state)
}

//export _gotk4_gtk3_EventControllerKey_ConnectModifiers
func _gotk4_gtk3_EventControllerKey_ConnectModifiers(arg0 C.gpointer, arg1 C.GdkModifierType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object gdk.ModifierType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object gdk.ModifierType) (ok bool))
	}

	var _object gdk.ModifierType // out

	_object = gdk.ModifierType(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_EventControllerMotion_ConnectEnter
func _gotk4_gtk3_EventControllerMotion_ConnectEnter(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(x, y float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y float64))
	}

	var _x float64 // out
	var _y float64 // out

	_x = float64(arg1)
	_y = float64(arg2)

	f(_x, _y)
}

//export _gotk4_gtk3_EventControllerMotion_ConnectLeave
func _gotk4_gtk3_EventControllerMotion_ConnectLeave(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EventControllerMotion_ConnectMotion
func _gotk4_gtk3_EventControllerMotion_ConnectMotion(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(x, y float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y float64))
	}

	var _x float64 // out
	var _y float64 // out

	_x = float64(arg1)
	_y = float64(arg2)

	f(_x, _y)
}

//export _gotk4_gtk3_EventControllerScroll_ConnectDecelerate
func _gotk4_gtk3_EventControllerScroll_ConnectDecelerate(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(velX, velY float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(velX, velY float64))
	}

	var _velX float64 // out
	var _velY float64 // out

	_velX = float64(arg1)
	_velY = float64(arg2)

	f(_velX, _velY)
}

//export _gotk4_gtk3_EventControllerScroll_ConnectScroll
func _gotk4_gtk3_EventControllerScroll_ConnectScroll(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(dx, dy float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(dx, dy float64))
	}

	var _dx float64 // out
	var _dy float64 // out

	_dx = float64(arg1)
	_dy = float64(arg2)

	f(_dx, _dy)
}

//export _gotk4_gtk3_EventControllerScroll_ConnectScrollBegin
func _gotk4_gtk3_EventControllerScroll_ConnectScrollBegin(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_EventControllerScroll_ConnectScrollEnd
func _gotk4_gtk3_EventControllerScroll_ConnectScrollEnd(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ExpanderClass_activate
func _gotk4_gtk3_ExpanderClass_activate(arg0 *C.GtkExpander) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ExpanderOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ExpanderOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_Expander_ConnectActivate
func _gotk4_gtk3_Expander_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserButtonClass_file_set
func _gotk4_gtk3_FileChooserButtonClass_file_set(arg0 *C.GtkFileChooserButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FileChooserButtonOverrides](instance0)
	if overrides.FileSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FileChooserButtonOverrides.FileSet, got none")
	}

	overrides.FileSet()
}

//export _gotk4_gtk3_FileChooserButton_ConnectFileSet
func _gotk4_gtk3_FileChooserButton_ConnectFileSet(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectDesktopFolder
func _gotk4_gtk3_FileChooserWidget_ConnectDesktopFolder(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectDownFolder
func _gotk4_gtk3_FileChooserWidget_ConnectDownFolder(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectHomeFolder
func _gotk4_gtk3_FileChooserWidget_ConnectHomeFolder(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectLocationPopup
func _gotk4_gtk3_FileChooserWidget_ConnectLocationPopup(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(path string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path string))
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_path)
}

//export _gotk4_gtk3_FileChooserWidget_ConnectLocationPopupOnPaste
func _gotk4_gtk3_FileChooserWidget_ConnectLocationPopupOnPaste(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectLocationTogglePopup
func _gotk4_gtk3_FileChooserWidget_ConnectLocationTogglePopup(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectPlacesShortcut
func _gotk4_gtk3_FileChooserWidget_ConnectPlacesShortcut(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectQuickBookmark
func _gotk4_gtk3_FileChooserWidget_ConnectQuickBookmark(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) {
	var f func(bookmarkIndex int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(bookmarkIndex int))
	}

	var _bookmarkIndex int // out

	_bookmarkIndex = int(arg1)

	f(_bookmarkIndex)
}

//export _gotk4_gtk3_FileChooserWidget_ConnectRecentShortcut
func _gotk4_gtk3_FileChooserWidget_ConnectRecentShortcut(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectSearchShortcut
func _gotk4_gtk3_FileChooserWidget_ConnectSearchShortcut(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectShowHidden
func _gotk4_gtk3_FileChooserWidget_ConnectShowHidden(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FileChooserWidget_ConnectUpFolder
func _gotk4_gtk3_FileChooserWidget_ConnectUpFolder(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FlowBoxClass_activate_cursor_child
func _gotk4_gtk3_FlowBoxClass_activate_cursor_child(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.ActivateCursorChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.ActivateCursorChild, got none")
	}

	overrides.ActivateCursorChild()
}

//export _gotk4_gtk3_FlowBoxClass_child_activated
func _gotk4_gtk3_FlowBoxClass_child_activated(arg0 *C.GtkFlowBox, arg1 *C.GtkFlowBoxChild) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.ChildActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.ChildActivated, got none")
	}

	var _child *FlowBoxChild // out

	_child = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.ChildActivated(_child)
}

//export _gotk4_gtk3_FlowBoxClass_move_cursor
func _gotk4_gtk3_FlowBoxClass_move_cursor(arg0 *C.GtkFlowBox, arg1 C.GtkMovementStep, arg2 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.MoveCursor, got none")
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	ok := overrides.MoveCursor(_step, _count)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_FlowBoxClass_select_all
func _gotk4_gtk3_FlowBoxClass_select_all(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.SelectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.SelectAll, got none")
	}

	overrides.SelectAll()
}

//export _gotk4_gtk3_FlowBoxClass_selected_children_changed
func _gotk4_gtk3_FlowBoxClass_selected_children_changed(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.SelectedChildrenChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.SelectedChildrenChanged, got none")
	}

	overrides.SelectedChildrenChanged()
}

//export _gotk4_gtk3_FlowBoxClass_toggle_cursor_child
func _gotk4_gtk3_FlowBoxClass_toggle_cursor_child(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.ToggleCursorChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.ToggleCursorChild, got none")
	}

	overrides.ToggleCursorChild()
}

//export _gotk4_gtk3_FlowBoxClass_unselect_all
func _gotk4_gtk3_FlowBoxClass_unselect_all(arg0 *C.GtkFlowBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxOverrides](instance0)
	if overrides.UnselectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxOverrides.UnselectAll, got none")
	}

	overrides.UnselectAll()
}

//export _gotk4_gtk3_FlowBox_ConnectActivateCursorChild
func _gotk4_gtk3_FlowBox_ConnectActivateCursorChild(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FlowBox_ConnectChildActivated
func _gotk4_gtk3_FlowBox_ConnectChildActivated(arg0 C.gpointer, arg1 *C.GtkFlowBoxChild, arg2 C.guintptr) {
	var f func(child *FlowBoxChild)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(child *FlowBoxChild))
	}

	var _child *FlowBoxChild // out

	_child = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(arg1)))

	f(_child)
}

//export _gotk4_gtk3_FlowBox_ConnectMoveCursor
func _gotk4_gtk3_FlowBox_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.guintptr) (cret C.gboolean) {
	var f func(step MovementStep, count int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step MovementStep, count int) (ok bool))
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	ok := f(_step, _count)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_FlowBox_ConnectSelectAll
func _gotk4_gtk3_FlowBox_ConnectSelectAll(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FlowBox_ConnectSelectedChildrenChanged
func _gotk4_gtk3_FlowBox_ConnectSelectedChildrenChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FlowBox_ConnectToggleCursorChild
func _gotk4_gtk3_FlowBox_ConnectToggleCursorChild(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FlowBox_ConnectUnselectAll
func _gotk4_gtk3_FlowBox_ConnectUnselectAll(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FlowBoxChildClass_activate
func _gotk4_gtk3_FlowBoxChildClass_activate(arg0 *C.GtkFlowBoxChild) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxChildOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxChildOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_FlowBoxChild_ConnectActivate
func _gotk4_gtk3_FlowBoxChild_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FontButtonClass_font_set
func _gotk4_gtk3_FontButtonClass_font_set(arg0 *C.GtkFontButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FontButtonOverrides](instance0)
	if overrides.FontSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FontButtonOverrides.FontSet, got none")
	}

	overrides.FontSet()
}

//export _gotk4_gtk3_FontButton_ConnectFontSet
func _gotk4_gtk3_FontButton_ConnectFontSet(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_FrameClass_compute_child_allocation
func _gotk4_gtk3_FrameClass_compute_child_allocation(arg0 *C.GtkFrame, arg1 *C.GtkAllocation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FrameOverrides](instance0)
	if overrides.ComputeChildAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FrameOverrides.ComputeChildAllocation, got none")
	}

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	overrides.ComputeChildAllocation(_allocation)
}

//export _gotk4_gtk3_GLAreaClass_render
func _gotk4_gtk3_GLAreaClass_render(arg0 *C.GtkGLArea, arg1 *C.GdkGLContext) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[GLAreaOverrides](instance0)
	if overrides.Render == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected GLAreaOverrides.Render, got none")
	}

	var _context gdk.GLContexter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.GLContexter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.GLContexter)
			return ok
		})
		rv, ok := casted.(gdk.GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
		}
		_context = rv
	}

	ok := overrides.Render(_context)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_GLAreaClass_resize
func _gotk4_gtk3_GLAreaClass_resize(arg0 *C.GtkGLArea, arg1 C.int, arg2 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[GLAreaOverrides](instance0)
	if overrides.Resize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected GLAreaOverrides.Resize, got none")
	}

	var _width int  // out
	var _height int // out

	_width = int(arg1)
	_height = int(arg2)

	overrides.Resize(_width, _height)
}

//export _gotk4_gtk3_GLArea_ConnectCreateContext
func _gotk4_gtk3_GLArea_ConnectCreateContext(arg0 C.gpointer, arg1 C.guintptr) (cret *C.GdkGLContext) {
	var f func() (glContext gdk.GLContexter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (glContext gdk.GLContexter))
	}

	glContext := f()

	var _ gdk.GLContexter

	cret = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(glContext).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(glContext).Native()))

	return cret
}

//export _gotk4_gtk3_GLArea_ConnectRender
func _gotk4_gtk3_GLArea_ConnectRender(arg0 C.gpointer, arg1 *C.GdkGLContext, arg2 C.guintptr) (cret C.gboolean) {
	var f func(context gdk.GLContexter) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context gdk.GLContexter) (ok bool))
	}

	var _context gdk.GLContexter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.GLContexter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.GLContexter)
			return ok
		})
		rv, ok := casted.(gdk.GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
		}
		_context = rv
	}

	ok := f(_context)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_GLArea_ConnectResize
func _gotk4_gtk3_GLArea_ConnectResize(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.guintptr) {
	var f func(width, height int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(width, height int))
	}

	var _width int  // out
	var _height int // out

	_width = int(arg1)
	_height = int(arg2)

	f(_width, _height)
}

//export _gotk4_gtk3_Gesture_ConnectBegin
func _gotk4_gtk3_Gesture_ConnectBegin(arg0 C.gpointer, arg1 *C.GdkEventSequence, arg2 C.guintptr) {
	var f func(sequence *gdk.EventSequence)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(sequence *gdk.EventSequence))
	}

	var _sequence *gdk.EventSequence // out

	if arg1 != nil {
		_sequence = (*gdk.EventSequence)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	}

	f(_sequence)
}

//export _gotk4_gtk3_Gesture_ConnectCancel
func _gotk4_gtk3_Gesture_ConnectCancel(arg0 C.gpointer, arg1 *C.GdkEventSequence, arg2 C.guintptr) {
	var f func(sequence *gdk.EventSequence)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(sequence *gdk.EventSequence))
	}

	var _sequence *gdk.EventSequence // out

	if arg1 != nil {
		_sequence = (*gdk.EventSequence)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	}

	f(_sequence)
}

//export _gotk4_gtk3_Gesture_ConnectEnd
func _gotk4_gtk3_Gesture_ConnectEnd(arg0 C.gpointer, arg1 *C.GdkEventSequence, arg2 C.guintptr) {
	var f func(sequence *gdk.EventSequence)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(sequence *gdk.EventSequence))
	}

	var _sequence *gdk.EventSequence // out

	if arg1 != nil {
		_sequence = (*gdk.EventSequence)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	}

	f(_sequence)
}

//export _gotk4_gtk3_Gesture_ConnectSequenceStateChanged
func _gotk4_gtk3_Gesture_ConnectSequenceStateChanged(arg0 C.gpointer, arg1 *C.GdkEventSequence, arg2 C.GtkEventSequenceState, arg3 C.guintptr) {
	var f func(sequence *gdk.EventSequence, state EventSequenceState)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(sequence *gdk.EventSequence, state EventSequenceState))
	}

	var _sequence *gdk.EventSequence // out
	var _state EventSequenceState    // out

	if arg1 != nil {
		_sequence = (*gdk.EventSequence)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	}
	_state = EventSequenceState(arg2)

	f(_sequence, _state)
}

//export _gotk4_gtk3_Gesture_ConnectUpdate
func _gotk4_gtk3_Gesture_ConnectUpdate(arg0 C.gpointer, arg1 *C.GdkEventSequence, arg2 C.guintptr) {
	var f func(sequence *gdk.EventSequence)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(sequence *gdk.EventSequence))
	}

	var _sequence *gdk.EventSequence // out

	if arg1 != nil {
		_sequence = (*gdk.EventSequence)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	}

	f(_sequence)
}

//export _gotk4_gtk3_GestureDrag_ConnectDragBegin
func _gotk4_gtk3_GestureDrag_ConnectDragBegin(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(startX, startY float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(startX, startY float64))
	}

	var _startX float64 // out
	var _startY float64 // out

	_startX = float64(arg1)
	_startY = float64(arg2)

	f(_startX, _startY)
}

//export _gotk4_gtk3_GestureDrag_ConnectDragEnd
func _gotk4_gtk3_GestureDrag_ConnectDragEnd(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(offsetX, offsetY float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(offsetX, offsetY float64))
	}

	var _offsetX float64 // out
	var _offsetY float64 // out

	_offsetX = float64(arg1)
	_offsetY = float64(arg2)

	f(_offsetX, _offsetY)
}

//export _gotk4_gtk3_GestureDrag_ConnectDragUpdate
func _gotk4_gtk3_GestureDrag_ConnectDragUpdate(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(offsetX, offsetY float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(offsetX, offsetY float64))
	}

	var _offsetX float64 // out
	var _offsetY float64 // out

	_offsetX = float64(arg1)
	_offsetY = float64(arg2)

	f(_offsetX, _offsetY)
}

//export _gotk4_gtk3_GestureLongPress_ConnectCancelled
func _gotk4_gtk3_GestureLongPress_ConnectCancelled(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_GestureLongPress_ConnectPressed
func _gotk4_gtk3_GestureLongPress_ConnectPressed(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(x, y float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y float64))
	}

	var _x float64 // out
	var _y float64 // out

	_x = float64(arg1)
	_y = float64(arg2)

	f(_x, _y)
}

//export _gotk4_gtk3_GestureMultiPress_ConnectPressed
func _gotk4_gtk3_GestureMultiPress_ConnectPressed(arg0 C.gpointer, arg1 C.gint, arg2 C.gdouble, arg3 C.gdouble, arg4 C.guintptr) {
	var f func(nPress int, x, y float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(nPress int, x, y float64))
	}

	var _nPress int // out
	var _x float64  // out
	var _y float64  // out

	_nPress = int(arg1)
	_x = float64(arg2)
	_y = float64(arg3)

	f(_nPress, _x, _y)
}

//export _gotk4_gtk3_GestureMultiPress_ConnectReleased
func _gotk4_gtk3_GestureMultiPress_ConnectReleased(arg0 C.gpointer, arg1 C.gint, arg2 C.gdouble, arg3 C.gdouble, arg4 C.guintptr) {
	var f func(nPress int, x, y float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(nPress int, x, y float64))
	}

	var _nPress int // out
	var _x float64  // out
	var _y float64  // out

	_nPress = int(arg1)
	_x = float64(arg2)
	_y = float64(arg3)

	f(_nPress, _x, _y)
}

//export _gotk4_gtk3_GestureMultiPress_ConnectStopped
func _gotk4_gtk3_GestureMultiPress_ConnectStopped(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_GesturePan_ConnectPan
func _gotk4_gtk3_GesturePan_ConnectPan(arg0 C.gpointer, arg1 C.GtkPanDirection, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(direction PanDirection, offset float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction PanDirection, offset float64))
	}

	var _direction PanDirection // out
	var _offset float64         // out

	_direction = PanDirection(arg1)
	_offset = float64(arg2)

	f(_direction, _offset)
}

//export _gotk4_gtk3_GestureRotate_ConnectAngleChanged
func _gotk4_gtk3_GestureRotate_ConnectAngleChanged(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(angle, angleDelta float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(angle, angleDelta float64))
	}

	var _angle float64      // out
	var _angleDelta float64 // out

	_angle = float64(arg1)
	_angleDelta = float64(arg2)

	f(_angle, _angleDelta)
}

//export _gotk4_gtk3_GestureStylus_ConnectDown
func _gotk4_gtk3_GestureStylus_ConnectDown(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(object, p0 float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0 float64))
	}

	var _object float64 // out
	var _p0 float64     // out

	_object = float64(arg1)
	_p0 = float64(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_GestureStylus_ConnectMotion
func _gotk4_gtk3_GestureStylus_ConnectMotion(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(object, p0 float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0 float64))
	}

	var _object float64 // out
	var _p0 float64     // out

	_object = float64(arg1)
	_p0 = float64(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_GestureStylus_ConnectProximity
func _gotk4_gtk3_GestureStylus_ConnectProximity(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(object, p0 float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0 float64))
	}

	var _object float64 // out
	var _p0 float64     // out

	_object = float64(arg1)
	_p0 = float64(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_GestureStylus_ConnectUp
func _gotk4_gtk3_GestureStylus_ConnectUp(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(object, p0 float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0 float64))
	}

	var _object float64 // out
	var _p0 float64     // out

	_object = float64(arg1)
	_p0 = float64(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_GestureSwipe_ConnectSwipe
func _gotk4_gtk3_GestureSwipe_ConnectSwipe(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(velocityX, velocityY float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(velocityX, velocityY float64))
	}

	var _velocityX float64 // out
	var _velocityY float64 // out

	_velocityX = float64(arg1)
	_velocityY = float64(arg2)

	f(_velocityX, _velocityY)
}

//export _gotk4_gtk3_GestureZoom_ConnectScaleChanged
func _gotk4_gtk3_GestureZoom_ConnectScaleChanged(arg0 C.gpointer, arg1 C.gdouble, arg2 C.guintptr) {
	var f func(scale float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(scale float64))
	}

	var _scale float64 // out

	_scale = float64(arg1)

	f(_scale)
}

//export _gotk4_gtk3_HSVClass_changed
func _gotk4_gtk3_HSVClass_changed(arg0 *C.GtkHSV) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSVOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSVOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_HSVClass_move
func _gotk4_gtk3_HSVClass_move(arg0 *C.GtkHSV, arg1 C.GtkDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSVOverrides](instance0)
	if overrides.Move == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSVOverrides.Move, got none")
	}

	var _typ DirectionType // out

	_typ = DirectionType(arg1)

	overrides.Move(_typ)
}

//export _gotk4_gtk3_HSV_ConnectChanged
func _gotk4_gtk3_HSV_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_HSV_ConnectMove
func _gotk4_gtk3_HSV_ConnectMove(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(object DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType))
	}

	var _object DirectionType // out

	_object = DirectionType(arg1)

	f(_object)
}

//export _gotk4_gtk3_HandleBoxClass_child_attached
func _gotk4_gtk3_HandleBoxClass_child_attached(arg0 *C.GtkHandleBox, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HandleBoxOverrides](instance0)
	if overrides.ChildAttached == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HandleBoxOverrides.ChildAttached, got none")
	}

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	overrides.ChildAttached(_child)
}

//export _gotk4_gtk3_HandleBoxClass_child_detached
func _gotk4_gtk3_HandleBoxClass_child_detached(arg0 *C.GtkHandleBox, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HandleBoxOverrides](instance0)
	if overrides.ChildDetached == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HandleBoxOverrides.ChildDetached, got none")
	}

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	overrides.ChildDetached(_child)
}

//export _gotk4_gtk3_HandleBox_ConnectChildAttached
func _gotk4_gtk3_HandleBox_ConnectChildAttached(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(widget Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter))
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	f(_widget)
}

//export _gotk4_gtk3_HandleBox_ConnectChildDetached
func _gotk4_gtk3_HandleBox_ConnectChildDetached(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(widget Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter))
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	f(_widget)
}

//export _gotk4_gtk3_IMContextClass_commit
func _gotk4_gtk3_IMContextClass_commit(arg0 *C.GtkIMContext, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.Commit == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.Commit, got none")
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.Commit(_str)
}

//export _gotk4_gtk3_IMContextClass_delete_surrounding
func _gotk4_gtk3_IMContextClass_delete_surrounding(arg0 *C.GtkIMContext, arg1 C.gint, arg2 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.DeleteSurrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.DeleteSurrounding, got none")
	}

	var _offset int // out
	var _nChars int // out

	_offset = int(arg1)
	_nChars = int(arg2)

	ok := overrides.DeleteSurrounding(_offset, _nChars)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IMContextClass_filter_keypress
func _gotk4_gtk3_IMContextClass_filter_keypress(arg0 *C.GtkIMContext, arg1 *C.GdkEventKey) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.FilterKeypress == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.FilterKeypress, got none")
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.FilterKeypress(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IMContextClass_focus_in
func _gotk4_gtk3_IMContextClass_focus_in(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.FocusIn == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.FocusIn, got none")
	}

	overrides.FocusIn()
}

//export _gotk4_gtk3_IMContextClass_focus_out
func _gotk4_gtk3_IMContextClass_focus_out(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.FocusOut == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.FocusOut, got none")
	}

	overrides.FocusOut()
}

//export _gotk4_gtk3_IMContextClass_get_preedit_string
func _gotk4_gtk3_IMContextClass_get_preedit_string(arg0 *C.GtkIMContext, arg1 **C.gchar, arg2 **C.PangoAttrList, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditString == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditString, got none")
	}

	str, attrs, cursorPos := overrides.PreeditString()

	var _ string
	var _ *pango.AttrList
	var _ int

	*arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	*arg2 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))
	*arg3 = C.gint(cursorPos)
}

//export _gotk4_gtk3_IMContextClass_get_surrounding
func _gotk4_gtk3_IMContextClass_get_surrounding(arg0 *C.GtkIMContext, arg1 **C.gchar, arg2 *C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.Surrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.Surrounding, got none")
	}

	text, cursorIndex, ok := overrides.Surrounding()

	var _ string
	var _ int
	var _ bool

	*arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	*arg2 = C.gint(cursorIndex)
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IMContextClass_preedit_changed
func _gotk4_gtk3_IMContextClass_preedit_changed(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditChanged, got none")
	}

	overrides.PreeditChanged()
}

//export _gotk4_gtk3_IMContextClass_preedit_end
func _gotk4_gtk3_IMContextClass_preedit_end(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditEnd == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditEnd, got none")
	}

	overrides.PreeditEnd()
}

//export _gotk4_gtk3_IMContextClass_preedit_start
func _gotk4_gtk3_IMContextClass_preedit_start(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditStart == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditStart, got none")
	}

	overrides.PreeditStart()
}

//export _gotk4_gtk3_IMContextClass_reset
func _gotk4_gtk3_IMContextClass_reset(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.Reset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.Reset, got none")
	}

	overrides.Reset()
}

//export _gotk4_gtk3_IMContextClass_retrieve_surrounding
func _gotk4_gtk3_IMContextClass_retrieve_surrounding(arg0 *C.GtkIMContext) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.RetrieveSurrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.RetrieveSurrounding, got none")
	}

	ok := overrides.RetrieveSurrounding()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IMContextClass_set_client_window
func _gotk4_gtk3_IMContextClass_set_client_window(arg0 *C.GtkIMContext, arg1 *C.GdkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetClientWindow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetClientWindow, got none")
	}

	var _window gdk.Windower // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Windower)
				return ok
			})
			rv, ok := casted.(gdk.Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	overrides.SetClientWindow(_window)
}

//export _gotk4_gtk3_IMContextClass_set_cursor_location
func _gotk4_gtk3_IMContextClass_set_cursor_location(arg0 *C.GtkIMContext, arg1 *C.GdkRectangle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetCursorLocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetCursorLocation, got none")
	}

	var _area *gdk.Rectangle // out

	_area = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.SetCursorLocation(_area)
}

//export _gotk4_gtk3_IMContextClass_set_surrounding
func _gotk4_gtk3_IMContextClass_set_surrounding(arg0 *C.GtkIMContext, arg1 *C.gchar, arg2 C.gint, arg3 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetSurrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetSurrounding, got none")
	}

	var _text string
	var _cursorIndex int // out

	_text = C.GoStringN(arg1, C.int(arg2))
	_cursorIndex = int(arg3)

	overrides.SetSurrounding(_text, _cursorIndex)
}

//export _gotk4_gtk3_IMContextClass_set_use_preedit
func _gotk4_gtk3_IMContextClass_set_use_preedit(arg0 *C.GtkIMContext, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetUsePreedit == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetUsePreedit, got none")
	}

	var _usePreedit bool // out

	if arg1 != 0 {
		_usePreedit = true
	}

	overrides.SetUsePreedit(_usePreedit)
}

//export _gotk4_gtk3_IMContext_ConnectCommit
func _gotk4_gtk3_IMContext_ConnectCommit(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(str string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(str string))
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_str)
}

//export _gotk4_gtk3_IMContext_ConnectDeleteSurrounding
func _gotk4_gtk3_IMContext_ConnectDeleteSurrounding(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.guintptr) (cret C.gboolean) {
	var f func(offset, nChars int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(offset, nChars int) (ok bool))
	}

	var _offset int // out
	var _nChars int // out

	_offset = int(arg1)
	_nChars = int(arg2)

	ok := f(_offset, _nChars)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IMContext_ConnectPreeditChanged
func _gotk4_gtk3_IMContext_ConnectPreeditChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_IMContext_ConnectPreeditEnd
func _gotk4_gtk3_IMContext_ConnectPreeditEnd(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_IMContext_ConnectPreeditStart
func _gotk4_gtk3_IMContext_ConnectPreeditStart(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_IMContext_ConnectRetrieveSurrounding
func _gotk4_gtk3_IMContext_ConnectRetrieveSurrounding(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IconThemeClass_changed
func _gotk4_gtk3_IconThemeClass_changed(arg0 *C.GtkIconTheme) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconThemeOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconThemeOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_IconTheme_ConnectChanged
func _gotk4_gtk3_IconTheme_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_IconViewClass_activate_cursor_item
func _gotk4_gtk3_IconViewClass_activate_cursor_item(arg0 *C.GtkIconView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.ActivateCursorItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.ActivateCursorItem, got none")
	}

	ok := overrides.ActivateCursorItem()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IconViewClass_item_activated
func _gotk4_gtk3_IconViewClass_item_activated(arg0 *C.GtkIconView, arg1 *C.GtkTreePath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.ItemActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.ItemActivated, got none")
	}

	var _path *TreePath // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.ItemActivated(_path)
}

//export _gotk4_gtk3_IconViewClass_move_cursor
func _gotk4_gtk3_IconViewClass_move_cursor(arg0 *C.GtkIconView, arg1 C.GtkMovementStep, arg2 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.MoveCursor, got none")
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	ok := overrides.MoveCursor(_step, _count)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IconViewClass_select_all
func _gotk4_gtk3_IconViewClass_select_all(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.SelectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.SelectAll, got none")
	}

	overrides.SelectAll()
}

//export _gotk4_gtk3_IconViewClass_select_cursor_item
func _gotk4_gtk3_IconViewClass_select_cursor_item(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.SelectCursorItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.SelectCursorItem, got none")
	}

	overrides.SelectCursorItem()
}

//export _gotk4_gtk3_IconViewClass_selection_changed
func _gotk4_gtk3_IconViewClass_selection_changed(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.SelectionChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.SelectionChanged, got none")
	}

	overrides.SelectionChanged()
}

//export _gotk4_gtk3_IconViewClass_toggle_cursor_item
func _gotk4_gtk3_IconViewClass_toggle_cursor_item(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.ToggleCursorItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.ToggleCursorItem, got none")
	}

	overrides.ToggleCursorItem()
}

//export _gotk4_gtk3_IconViewClass_unselect_all
func _gotk4_gtk3_IconViewClass_unselect_all(arg0 *C.GtkIconView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IconViewOverrides](instance0)
	if overrides.UnselectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IconViewOverrides.UnselectAll, got none")
	}

	overrides.UnselectAll()
}

//export _gotk4_gtk3_IconView_ConnectActivateCursorItem
func _gotk4_gtk3_IconView_ConnectActivateCursorItem(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IconView_ConnectItemActivated
func _gotk4_gtk3_IconView_ConnectItemActivated(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 C.guintptr) {
	var f func(path *TreePath)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath))
	}

	var _path *TreePath // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	f(_path)
}

//export _gotk4_gtk3_IconView_ConnectMoveCursor
func _gotk4_gtk3_IconView_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.guintptr) (cret C.gboolean) {
	var f func(step MovementStep, count int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step MovementStep, count int) (ok bool))
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	ok := f(_step, _count)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_IconView_ConnectSelectAll
func _gotk4_gtk3_IconView_ConnectSelectAll(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_IconView_ConnectSelectCursorItem
func _gotk4_gtk3_IconView_ConnectSelectCursorItem(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_IconView_ConnectSelectionChanged
func _gotk4_gtk3_IconView_ConnectSelectionChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_IconView_ConnectToggleCursorItem
func _gotk4_gtk3_IconView_ConnectToggleCursorItem(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_IconView_ConnectUnselectAll
func _gotk4_gtk3_IconView_ConnectUnselectAll(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_InfoBarClass_close
func _gotk4_gtk3_InfoBarClass_close(arg0 *C.GtkInfoBar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[InfoBarOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected InfoBarOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk3_InfoBarClass_response
func _gotk4_gtk3_InfoBarClass_response(arg0 *C.GtkInfoBar, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[InfoBarOverrides](instance0)
	if overrides.Response == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected InfoBarOverrides.Response, got none")
	}

	var _responseId int // out

	_responseId = int(arg1)

	overrides.Response(_responseId)
}

//export _gotk4_gtk3_InfoBar_ConnectClose
func _gotk4_gtk3_InfoBar_ConnectClose(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_InfoBar_ConnectResponse
func _gotk4_gtk3_InfoBar_ConnectResponse(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) {
	var f func(responseId int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(responseId int))
	}

	var _responseId int // out

	_responseId = int(arg1)

	f(_responseId)
}

//export _gotk4_gtk3_LabelClass_activate_link
func _gotk4_gtk3_LabelClass_activate_link(arg0 *C.GtkLabel, arg1 *C.gchar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LabelOverrides](instance0)
	if overrides.ActivateLink == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LabelOverrides.ActivateLink, got none")
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := overrides.ActivateLink(_uri)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_LabelClass_copy_clipboard
func _gotk4_gtk3_LabelClass_copy_clipboard(arg0 *C.GtkLabel) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LabelOverrides](instance0)
	if overrides.CopyClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LabelOverrides.CopyClipboard, got none")
	}

	overrides.CopyClipboard()
}

//export _gotk4_gtk3_LabelClass_move_cursor
func _gotk4_gtk3_LabelClass_move_cursor(arg0 *C.GtkLabel, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LabelOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LabelOverrides.MoveCursor, got none")
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	overrides.MoveCursor(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_LabelClass_populate_popup
func _gotk4_gtk3_LabelClass_populate_popup(arg0 *C.GtkLabel, arg1 *C.GtkMenu) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LabelOverrides](instance0)
	if overrides.PopulatePopup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LabelOverrides.PopulatePopup, got none")
	}

	var _menu *Menu // out

	_menu = wrapMenu(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PopulatePopup(_menu)
}

//export _gotk4_gtk3_Label_ConnectActivateCurrentLink
func _gotk4_gtk3_Label_ConnectActivateCurrentLink(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Label_ConnectActivateLink
func _gotk4_gtk3_Label_ConnectActivateLink(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) (cret C.gboolean) {
	var f func(uri string) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(uri string) (ok bool))
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := f(_uri)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Label_ConnectCopyClipboard
func _gotk4_gtk3_Label_ConnectCopyClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Label_ConnectMoveCursor
func _gotk4_gtk3_Label_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean, arg4 C.guintptr) {
	var f func(step MovementStep, count int, extendSelection bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step MovementStep, count int, extendSelection bool))
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	f(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_Label_ConnectPopulatePopup
func _gotk4_gtk3_Label_ConnectPopulatePopup(arg0 C.gpointer, arg1 *C.GtkMenu, arg2 C.guintptr) {
	var f func(menu *Menu)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(menu *Menu))
	}

	var _menu *Menu // out

	_menu = wrapMenu(coreglib.Take(unsafe.Pointer(arg1)))

	f(_menu)
}

//export _gotk4_gtk3_LevelBarClass_offset_changed
func _gotk4_gtk3_LevelBarClass_offset_changed(arg0 *C.GtkLevelBar, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LevelBarOverrides](instance0)
	if overrides.OffsetChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LevelBarOverrides.OffsetChanged, got none")
	}

	var _name string // out

	_name = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.OffsetChanged(_name)
}

//export _gotk4_gtk3_LevelBar_ConnectOffsetChanged
func _gotk4_gtk3_LevelBar_ConnectOffsetChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(name string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(name string))
	}

	var _name string // out

	_name = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_name)
}

//export _gotk4_gtk3_LinkButtonClass_activate_link
func _gotk4_gtk3_LinkButtonClass_activate_link(arg0 *C.GtkLinkButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LinkButtonOverrides](instance0)
	if overrides.ActivateLink == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LinkButtonOverrides.ActivateLink, got none")
	}

	ok := overrides.ActivateLink()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_LinkButton_ConnectActivateLink
func _gotk4_gtk3_LinkButton_ConnectActivateLink(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ListBoxClass_activate_cursor_row
func _gotk4_gtk3_ListBoxClass_activate_cursor_row(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.ActivateCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.ActivateCursorRow, got none")
	}

	overrides.ActivateCursorRow()
}

//export _gotk4_gtk3_ListBoxClass_move_cursor
func _gotk4_gtk3_ListBoxClass_move_cursor(arg0 *C.GtkListBox, arg1 C.GtkMovementStep, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.MoveCursor, got none")
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	overrides.MoveCursor(_step, _count)
}

//export _gotk4_gtk3_ListBoxClass_row_activated
func _gotk4_gtk3_ListBoxClass_row_activated(arg0 *C.GtkListBox, arg1 *C.GtkListBoxRow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.RowActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.RowActivated, got none")
	}

	var _row *ListBoxRow // out

	_row = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RowActivated(_row)
}

//export _gotk4_gtk3_ListBoxClass_row_selected
func _gotk4_gtk3_ListBoxClass_row_selected(arg0 *C.GtkListBox, arg1 *C.GtkListBoxRow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.RowSelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.RowSelected, got none")
	}

	var _row *ListBoxRow // out

	_row = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RowSelected(_row)
}

//export _gotk4_gtk3_ListBoxClass_select_all
func _gotk4_gtk3_ListBoxClass_select_all(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.SelectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.SelectAll, got none")
	}

	overrides.SelectAll()
}

//export _gotk4_gtk3_ListBoxClass_selected_rows_changed
func _gotk4_gtk3_ListBoxClass_selected_rows_changed(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.SelectedRowsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.SelectedRowsChanged, got none")
	}

	overrides.SelectedRowsChanged()
}

//export _gotk4_gtk3_ListBoxClass_toggle_cursor_row
func _gotk4_gtk3_ListBoxClass_toggle_cursor_row(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.ToggleCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.ToggleCursorRow, got none")
	}

	overrides.ToggleCursorRow()
}

//export _gotk4_gtk3_ListBoxClass_unselect_all
func _gotk4_gtk3_ListBoxClass_unselect_all(arg0 *C.GtkListBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxOverrides](instance0)
	if overrides.UnselectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxOverrides.UnselectAll, got none")
	}

	overrides.UnselectAll()
}

//export _gotk4_gtk3_ListBox_ConnectActivateCursorRow
func _gotk4_gtk3_ListBox_ConnectActivateCursorRow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ListBox_ConnectMoveCursor
func _gotk4_gtk3_ListBox_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.guintptr) {
	var f func(object MovementStep, p0 int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object MovementStep, p0 int))
	}

	var _object MovementStep // out
	var _p0 int              // out

	_object = MovementStep(arg1)
	_p0 = int(arg2)

	f(_object, _p0)
}

//export _gotk4_gtk3_ListBox_ConnectRowActivated
func _gotk4_gtk3_ListBox_ConnectRowActivated(arg0 C.gpointer, arg1 *C.GtkListBoxRow, arg2 C.guintptr) {
	var f func(row *ListBoxRow)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(row *ListBoxRow))
	}

	var _row *ListBoxRow // out

	_row = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg1)))

	f(_row)
}

//export _gotk4_gtk3_ListBox_ConnectRowSelected
func _gotk4_gtk3_ListBox_ConnectRowSelected(arg0 C.gpointer, arg1 *C.GtkListBoxRow, arg2 C.guintptr) {
	var f func(row *ListBoxRow)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(row *ListBoxRow))
	}

	var _row *ListBoxRow // out

	if arg1 != nil {
		_row = wrapListBoxRow(coreglib.Take(unsafe.Pointer(arg1)))
	}

	f(_row)
}

//export _gotk4_gtk3_ListBox_ConnectSelectAll
func _gotk4_gtk3_ListBox_ConnectSelectAll(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ListBox_ConnectSelectedRowsChanged
func _gotk4_gtk3_ListBox_ConnectSelectedRowsChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ListBox_ConnectToggleCursorRow
func _gotk4_gtk3_ListBox_ConnectToggleCursorRow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ListBox_ConnectUnselectAll
func _gotk4_gtk3_ListBox_ConnectUnselectAll(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ListBoxRowClass_activate
func _gotk4_gtk3_ListBoxRowClass_activate(arg0 *C.GtkListBoxRow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxRowOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxRowOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_ListBoxRow_ConnectActivate
func _gotk4_gtk3_ListBoxRow_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Menu_ConnectMoveScroll
func _gotk4_gtk3_Menu_ConnectMoveScroll(arg0 C.gpointer, arg1 C.GtkScrollType, arg2 C.guintptr) {
	var f func(scrollType ScrollType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(scrollType ScrollType))
	}

	var _scrollType ScrollType // out

	_scrollType = ScrollType(arg1)

	f(_scrollType)
}

//export _gotk4_gtk3_Menu_ConnectPoppedUp
func _gotk4_gtk3_Menu_ConnectPoppedUp(arg0 C.gpointer, arg1 C.gpointer, arg2 C.gpointer, arg3 C.gboolean, arg4 C.gboolean, arg5 C.guintptr) {
	var f func(flippedRect, finalRect unsafe.Pointer, flippedX, flippedY bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(flippedRect, finalRect unsafe.Pointer, flippedX, flippedY bool))
	}

	var _flippedRect unsafe.Pointer // out
	var _finalRect unsafe.Pointer   // out
	var _flippedX bool              // out
	var _flippedY bool              // out

	_flippedRect = (unsafe.Pointer)(unsafe.Pointer(arg1))
	_finalRect = (unsafe.Pointer)(unsafe.Pointer(arg2))
	if arg3 != 0 {
		_flippedX = true
	}
	if arg4 != 0 {
		_flippedY = true
	}

	f(_flippedRect, _finalRect, _flippedX, _flippedY)
}

//export _gotk4_gtk3_MenuItemClass_activate
func _gotk4_gtk3_MenuItemClass_activate(arg0 *C.GtkMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_MenuItemClass_activate_item
func _gotk4_gtk3_MenuItemClass_activate_item(arg0 *C.GtkMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.ActivateItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.ActivateItem, got none")
	}

	overrides.ActivateItem()
}

//export _gotk4_gtk3_MenuItemClass_deselect
func _gotk4_gtk3_MenuItemClass_deselect(arg0 *C.GtkMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.Deselect == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.Deselect, got none")
	}

	overrides.Deselect()
}

//export _gotk4_gtk3_MenuItemClass_get_label
func _gotk4_gtk3_MenuItemClass_get_label(arg0 *C.GtkMenuItem) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.Label == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.Label, got none")
	}

	utf8 := overrides.Label()

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_gtk3_MenuItemClass_select
func _gotk4_gtk3_MenuItemClass_select(arg0 *C.GtkMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.Select == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.Select, got none")
	}

	overrides.Select()
}

//export _gotk4_gtk3_MenuItemClass_set_label
func _gotk4_gtk3_MenuItemClass_set_label(arg0 *C.GtkMenuItem, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.SetLabel == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.SetLabel, got none")
	}

	var _label string // out

	_label = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.SetLabel(_label)
}

//export _gotk4_gtk3_MenuItemClass_toggle_size_allocate
func _gotk4_gtk3_MenuItemClass_toggle_size_allocate(arg0 *C.GtkMenuItem, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuItemOverrides](instance0)
	if overrides.ToggleSizeAllocate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuItemOverrides.ToggleSizeAllocate, got none")
	}

	var _allocation int // out

	_allocation = int(arg1)

	overrides.ToggleSizeAllocate(_allocation)
}

//export _gotk4_gtk3_MenuItem_ConnectActivate
func _gotk4_gtk3_MenuItem_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_MenuItem_ConnectActivateItem
func _gotk4_gtk3_MenuItem_ConnectActivateItem(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_MenuItem_ConnectDeselect
func _gotk4_gtk3_MenuItem_ConnectDeselect(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_MenuItem_ConnectSelect
func _gotk4_gtk3_MenuItem_ConnectSelect(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_MenuItem_ConnectToggleSizeAllocate
func _gotk4_gtk3_MenuItem_ConnectToggleSizeAllocate(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) {
	var f func(object int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object int))
	}

	var _object int // out

	_object = int(arg1)

	f(_object)
}

//export _gotk4_gtk3_MenuItem_ConnectToggleSizeRequest
func _gotk4_gtk3_MenuItem_ConnectToggleSizeRequest(arg0 C.gpointer, arg1 C.gpointer, arg2 C.guintptr) {
	var f func(object unsafe.Pointer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object unsafe.Pointer))
	}

	var _object unsafe.Pointer // out

	_object = (unsafe.Pointer)(unsafe.Pointer(arg1))

	f(_object)
}

//export _gotk4_gtk3_MenuShellClass_activate_current
func _gotk4_gtk3_MenuShellClass_activate_current(arg0 *C.GtkMenuShell, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.ActivateCurrent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.ActivateCurrent, got none")
	}

	var _forceHide bool // out

	if arg1 != 0 {
		_forceHide = true
	}

	overrides.ActivateCurrent(_forceHide)
}

//export _gotk4_gtk3_MenuShellClass_cancel
func _gotk4_gtk3_MenuShellClass_cancel(arg0 *C.GtkMenuShell) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.Cancel == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.Cancel, got none")
	}

	overrides.Cancel()
}

//export _gotk4_gtk3_MenuShellClass_deactivate
func _gotk4_gtk3_MenuShellClass_deactivate(arg0 *C.GtkMenuShell) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.Deactivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.Deactivate, got none")
	}

	overrides.Deactivate()
}

//export _gotk4_gtk3_MenuShellClass_get_popup_delay
func _gotk4_gtk3_MenuShellClass_get_popup_delay(arg0 *C.GtkMenuShell) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.PopupDelay == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.PopupDelay, got none")
	}

	gint := overrides.PopupDelay()

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_MenuShellClass_insert
func _gotk4_gtk3_MenuShellClass_insert(arg0 *C.GtkMenuShell, arg1 *C.GtkWidget, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.Insert == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.Insert, got none")
	}

	var _child Widgetter // out
	var _position int    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_position = int(arg2)

	overrides.Insert(_child, _position)
}

//export _gotk4_gtk3_MenuShellClass_move_current
func _gotk4_gtk3_MenuShellClass_move_current(arg0 *C.GtkMenuShell, arg1 C.GtkMenuDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.MoveCurrent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.MoveCurrent, got none")
	}

	var _direction MenuDirectionType // out

	_direction = MenuDirectionType(arg1)

	overrides.MoveCurrent(_direction)
}

//export _gotk4_gtk3_MenuShellClass_move_selected
func _gotk4_gtk3_MenuShellClass_move_selected(arg0 *C.GtkMenuShell, arg1 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.MoveSelected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.MoveSelected, got none")
	}

	var _distance int // out

	_distance = int(arg1)

	ok := overrides.MoveSelected(_distance)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_MenuShellClass_select_item
func _gotk4_gtk3_MenuShellClass_select_item(arg0 *C.GtkMenuShell, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.SelectItem == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.SelectItem, got none")
	}

	var _menuItem Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_menuItem = rv
	}

	overrides.SelectItem(_menuItem)
}

//export _gotk4_gtk3_MenuShellClass_selection_done
func _gotk4_gtk3_MenuShellClass_selection_done(arg0 *C.GtkMenuShell) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuShellOverrides](instance0)
	if overrides.SelectionDone == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuShellOverrides.SelectionDone, got none")
	}

	overrides.SelectionDone()
}

//export _gotk4_gtk3_MenuShell_ConnectActivateCurrent
func _gotk4_gtk3_MenuShell_ConnectActivateCurrent(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(forceHide bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(forceHide bool))
	}

	var _forceHide bool // out

	if arg1 != 0 {
		_forceHide = true
	}

	f(_forceHide)
}

//export _gotk4_gtk3_MenuShell_ConnectCancel
func _gotk4_gtk3_MenuShell_ConnectCancel(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_MenuShell_ConnectCycleFocus
func _gotk4_gtk3_MenuShell_ConnectCycleFocus(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(direction DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	f(_direction)
}

//export _gotk4_gtk3_MenuShell_ConnectDeactivate
func _gotk4_gtk3_MenuShell_ConnectDeactivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_MenuShell_ConnectInsert
func _gotk4_gtk3_MenuShell_ConnectInsert(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.gint, arg3 C.guintptr) {
	var f func(child Widgetter, position int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(child Widgetter, position int))
	}

	var _child Widgetter // out
	var _position int    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_position = int(arg2)

	f(_child, _position)
}

//export _gotk4_gtk3_MenuShell_ConnectMoveCurrent
func _gotk4_gtk3_MenuShell_ConnectMoveCurrent(arg0 C.gpointer, arg1 C.GtkMenuDirectionType, arg2 C.guintptr) {
	var f func(direction MenuDirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction MenuDirectionType))
	}

	var _direction MenuDirectionType // out

	_direction = MenuDirectionType(arg1)

	f(_direction)
}

//export _gotk4_gtk3_MenuShell_ConnectMoveSelected
func _gotk4_gtk3_MenuShell_ConnectMoveSelected(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(distance int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(distance int) (ok bool))
	}

	var _distance int // out

	_distance = int(arg1)

	ok := f(_distance)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_MenuShell_ConnectSelectionDone
func _gotk4_gtk3_MenuShell_ConnectSelectionDone(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_MenuToolButtonClass_show_menu
func _gotk4_gtk3_MenuToolButtonClass_show_menu(arg0 *C.GtkMenuToolButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MenuToolButtonOverrides](instance0)
	if overrides.ShowMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MenuToolButtonOverrides.ShowMenu, got none")
	}

	overrides.ShowMenu()
}

//export _gotk4_gtk3_MenuToolButton_ConnectShowMenu
func _gotk4_gtk3_MenuToolButton_ConnectShowMenu(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_NativeDialogClass_hide
func _gotk4_gtk3_NativeDialogClass_hide(arg0 *C.GtkNativeDialog) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NativeDialogOverrides](instance0)
	if overrides.Hide == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NativeDialogOverrides.Hide, got none")
	}

	overrides.Hide()
}

//export _gotk4_gtk3_NativeDialogClass_response
func _gotk4_gtk3_NativeDialogClass_response(arg0 *C.GtkNativeDialog, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NativeDialogOverrides](instance0)
	if overrides.Response == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NativeDialogOverrides.Response, got none")
	}

	var _responseId int // out

	_responseId = int(arg1)

	overrides.Response(_responseId)
}

//export _gotk4_gtk3_NativeDialogClass_show
func _gotk4_gtk3_NativeDialogClass_show(arg0 *C.GtkNativeDialog) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NativeDialogOverrides](instance0)
	if overrides.Show == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NativeDialogOverrides.Show, got none")
	}

	overrides.Show()
}

//export _gotk4_gtk3_NativeDialog_ConnectResponse
func _gotk4_gtk3_NativeDialog_ConnectResponse(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) {
	var f func(responseId int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(responseId int))
	}

	var _responseId int // out

	_responseId = int(arg1)

	f(_responseId)
}

//export _gotk4_gtk3_NotebookClass_change_current_page
func _gotk4_gtk3_NotebookClass_change_current_page(arg0 *C.GtkNotebook, arg1 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.ChangeCurrentPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.ChangeCurrentPage, got none")
	}

	var _offset int // out

	_offset = int(arg1)

	ok := overrides.ChangeCurrentPage(_offset)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_focus_tab
func _gotk4_gtk3_NotebookClass_focus_tab(arg0 *C.GtkNotebook, arg1 C.GtkNotebookTab) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.FocusTab == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.FocusTab, got none")
	}

	var _typ NotebookTab // out

	_typ = NotebookTab(arg1)

	ok := overrides.FocusTab(_typ)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_insert_page
func _gotk4_gtk3_NotebookClass_insert_page(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 *C.GtkWidget, arg3 *C.GtkWidget, arg4 C.gint) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.InsertPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.InsertPage, got none")
	}

	var _child Widgetter     // out
	var _tabLabel Widgetter  // out
	var _menuLabel Widgetter // out
	var _position int        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_tabLabel = rv
	}
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_menuLabel = rv
	}
	_position = int(arg4)

	gint := overrides.InsertPage(_child, _tabLabel, _menuLabel, _position)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_NotebookClass_move_focus_out
func _gotk4_gtk3_NotebookClass_move_focus_out(arg0 *C.GtkNotebook, arg1 C.GtkDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.MoveFocusOut == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.MoveFocusOut, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	overrides.MoveFocusOut(_direction)
}

//export _gotk4_gtk3_NotebookClass_page_added
func _gotk4_gtk3_NotebookClass_page_added(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.PageAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.PageAdded, got none")
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	overrides.PageAdded(_child, _pageNum)
}

//export _gotk4_gtk3_NotebookClass_page_removed
func _gotk4_gtk3_NotebookClass_page_removed(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.PageRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.PageRemoved, got none")
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	overrides.PageRemoved(_child, _pageNum)
}

//export _gotk4_gtk3_NotebookClass_page_reordered
func _gotk4_gtk3_NotebookClass_page_reordered(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.PageReordered == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.PageReordered, got none")
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	overrides.PageReordered(_child, _pageNum)
}

//export _gotk4_gtk3_NotebookClass_reorder_tab
func _gotk4_gtk3_NotebookClass_reorder_tab(arg0 *C.GtkNotebook, arg1 C.GtkDirectionType, arg2 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.ReorderTab == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.ReorderTab, got none")
	}

	var _direction DirectionType // out
	var _moveToLast bool         // out

	_direction = DirectionType(arg1)
	if arg2 != 0 {
		_moveToLast = true
	}

	ok := overrides.ReorderTab(_direction, _moveToLast)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_select_page
func _gotk4_gtk3_NotebookClass_select_page(arg0 *C.GtkNotebook, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.SelectPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.SelectPage, got none")
	}

	var _moveFocus bool // out

	if arg1 != 0 {
		_moveFocus = true
	}

	ok := overrides.SelectPage(_moveFocus)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_switch_page
func _gotk4_gtk3_NotebookClass_switch_page(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NotebookOverrides](instance0)
	if overrides.SwitchPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NotebookOverrides.SwitchPage, got none")
	}

	var _page Widgetter // out
	var _pageNum uint   // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}
	_pageNum = uint(arg2)

	overrides.SwitchPage(_page, _pageNum)
}

//export _gotk4_gtk3_Notebook_ConnectChangeCurrentPage
func _gotk4_gtk3_Notebook_ConnectChangeCurrentPage(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object int) (ok bool))
	}

	var _object int // out

	_object = int(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Notebook_ConnectCreateWindow
func _gotk4_gtk3_Notebook_ConnectCreateWindow(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.gint, arg3 C.gint, arg4 C.guintptr) (cret *C.GtkNotebook) {
	var f func(page Widgetter, x, y int) (notebook *Notebook)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(page Widgetter, x, y int) (notebook *Notebook))
	}

	var _page Widgetter // out
	var _x int          // out
	var _y int          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}
	_x = int(arg2)
	_y = int(arg3)

	notebook := f(_page, _x, _y)

	var _ *Notebook

	cret = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	return cret
}

//export _gotk4_gtk3_Notebook_ConnectFocusTab
func _gotk4_gtk3_Notebook_ConnectFocusTab(arg0 C.gpointer, arg1 C.GtkNotebookTab, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object NotebookTab) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object NotebookTab) (ok bool))
	}

	var _object NotebookTab // out

	_object = NotebookTab(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Notebook_ConnectMoveFocusOut
func _gotk4_gtk3_Notebook_ConnectMoveFocusOut(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(object DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType))
	}

	var _object DirectionType // out

	_object = DirectionType(arg1)

	f(_object)
}

//export _gotk4_gtk3_Notebook_ConnectPageAdded
func _gotk4_gtk3_Notebook_ConnectPageAdded(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guint, arg3 C.guintptr) {
	var f func(child Widgetter, pageNum uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(child Widgetter, pageNum uint))
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	f(_child, _pageNum)
}

//export _gotk4_gtk3_Notebook_ConnectPageRemoved
func _gotk4_gtk3_Notebook_ConnectPageRemoved(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guint, arg3 C.guintptr) {
	var f func(child Widgetter, pageNum uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(child Widgetter, pageNum uint))
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	f(_child, _pageNum)
}

//export _gotk4_gtk3_Notebook_ConnectPageReordered
func _gotk4_gtk3_Notebook_ConnectPageReordered(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guint, arg3 C.guintptr) {
	var f func(child Widgetter, pageNum uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(child Widgetter, pageNum uint))
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	f(_child, _pageNum)
}

//export _gotk4_gtk3_Notebook_ConnectReorderTab
func _gotk4_gtk3_Notebook_ConnectReorderTab(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.gboolean, arg3 C.guintptr) (cret C.gboolean) {
	var f func(object DirectionType, p0 bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType, p0 bool) (ok bool))
	}

	var _object DirectionType // out
	var _p0 bool              // out

	_object = DirectionType(arg1)
	if arg2 != 0 {
		_p0 = true
	}

	ok := f(_object, _p0)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Notebook_ConnectSelectPage
func _gotk4_gtk3_Notebook_ConnectSelectPage(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object bool) (ok bool))
	}

	var _object bool // out

	if arg1 != 0 {
		_object = true
	}

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Notebook_ConnectSwitchPage
func _gotk4_gtk3_Notebook_ConnectSwitchPage(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guint, arg3 C.guintptr) {
	var f func(page Widgetter, pageNum uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(page Widgetter, pageNum uint))
	}

	var _page Widgetter // out
	var _pageNum uint   // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}
	_pageNum = uint(arg2)

	f(_page, _pageNum)
}

//export _gotk4_gtk3_OverlayClass_get_child_position
func _gotk4_gtk3_OverlayClass_get_child_position(arg0 *C.GtkOverlay, arg1 *C.GtkWidget, arg2 *C.GtkAllocation) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[OverlayOverrides](instance0)
	if overrides.ChildPosition == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected OverlayOverrides.ChildPosition, got none")
	}

	var _widget Widgetter       // out
	var _allocation *Allocation // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	ok := overrides.ChildPosition(_widget, _allocation)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Overlay_ConnectGetChildPosition
func _gotk4_gtk3_Overlay_ConnectGetChildPosition(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 *C.GdkRectangle, arg3 C.guintptr) (cret C.gboolean) {
	var f func(widget Widgetter) (allocation *gdk.Rectangle, ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter) (allocation *gdk.Rectangle, ok bool))
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	allocation, ok := f(_widget)

	var _ *gdk.Rectangle
	var _ bool

	*arg2 = *(*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_accept_position
func _gotk4_gtk3_PanedClass_accept_position(arg0 *C.GtkPaned) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.AcceptPosition == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.AcceptPosition, got none")
	}

	ok := overrides.AcceptPosition()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_cancel_position
func _gotk4_gtk3_PanedClass_cancel_position(arg0 *C.GtkPaned) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.CancelPosition == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.CancelPosition, got none")
	}

	ok := overrides.CancelPosition()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_cycle_child_focus
func _gotk4_gtk3_PanedClass_cycle_child_focus(arg0 *C.GtkPaned, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.CycleChildFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.CycleChildFocus, got none")
	}

	var _reverse bool // out

	if arg1 != 0 {
		_reverse = true
	}

	ok := overrides.CycleChildFocus(_reverse)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_cycle_handle_focus
func _gotk4_gtk3_PanedClass_cycle_handle_focus(arg0 *C.GtkPaned, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.CycleHandleFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.CycleHandleFocus, got none")
	}

	var _reverse bool // out

	if arg1 != 0 {
		_reverse = true
	}

	ok := overrides.CycleHandleFocus(_reverse)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_move_handle
func _gotk4_gtk3_PanedClass_move_handle(arg0 *C.GtkPaned, arg1 C.GtkScrollType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.MoveHandle == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.MoveHandle, got none")
	}

	var _scroll ScrollType // out

	_scroll = ScrollType(arg1)

	ok := overrides.MoveHandle(_scroll)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PanedClass_toggle_handle_focus
func _gotk4_gtk3_PanedClass_toggle_handle_focus(arg0 *C.GtkPaned) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PanedOverrides](instance0)
	if overrides.ToggleHandleFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PanedOverrides.ToggleHandleFocus, got none")
	}

	ok := overrides.ToggleHandleFocus()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Paned_ConnectAcceptPosition
func _gotk4_gtk3_Paned_ConnectAcceptPosition(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Paned_ConnectCancelPosition
func _gotk4_gtk3_Paned_ConnectCancelPosition(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Paned_ConnectCycleChildFocus
func _gotk4_gtk3_Paned_ConnectCycleChildFocus(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(reversed bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(reversed bool) (ok bool))
	}

	var _reversed bool // out

	if arg1 != 0 {
		_reversed = true
	}

	ok := f(_reversed)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Paned_ConnectCycleHandleFocus
func _gotk4_gtk3_Paned_ConnectCycleHandleFocus(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(reversed bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(reversed bool) (ok bool))
	}

	var _reversed bool // out

	if arg1 != 0 {
		_reversed = true
	}

	ok := f(_reversed)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Paned_ConnectMoveHandle
func _gotk4_gtk3_Paned_ConnectMoveHandle(arg0 C.gpointer, arg1 C.GtkScrollType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(scrollType ScrollType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(scrollType ScrollType) (ok bool))
	}

	var _scrollType ScrollType // out

	_scrollType = ScrollType(arg1)

	ok := f(_scrollType)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Paned_ConnectToggleHandleFocus
func _gotk4_gtk3_Paned_ConnectToggleHandleFocus(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PlacesSidebar_ConnectDragActionAsk
func _gotk4_gtk3_PlacesSidebar_ConnectDragActionAsk(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gint) {
	var f func(actions int) (gint int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(actions int) (gint int))
	}

	var _actions int // out

	_actions = int(arg1)

	gint := f(_actions)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_PlacesSidebar_ConnectMount
func _gotk4_gtk3_PlacesSidebar_ConnectMount(arg0 C.gpointer, arg1 *C.GMountOperation, arg2 C.guintptr) {
	var f func(mountOperation *gio.MountOperation)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mountOperation *gio.MountOperation))
	}

	var _mountOperation *gio.MountOperation // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_mountOperation = &gio.MountOperation{
			Object: obj,
		}
	}

	f(_mountOperation)
}

//export _gotk4_gtk3_PlacesSidebar_ConnectOpenLocation
func _gotk4_gtk3_PlacesSidebar_ConnectOpenLocation(arg0 C.gpointer, arg1 *C.GFile, arg2 C.GtkPlacesOpenFlags, arg3 C.guintptr) {
	var f func(location gio.Filer, openFlags PlacesOpenFlags)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location gio.Filer, openFlags PlacesOpenFlags))
	}

	var _location gio.Filer        // out
	var _openFlags PlacesOpenFlags // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Filer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.Filer)
			return ok
		})
		rv, ok := casted.(gio.Filer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
		}
		_location = rv
	}
	_openFlags = PlacesOpenFlags(arg2)

	f(_location, _openFlags)
}

//export _gotk4_gtk3_PlacesSidebar_ConnectPopulatePopup
func _gotk4_gtk3_PlacesSidebar_ConnectPopulatePopup(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 *C.GFile, arg3 *C.GVolume, arg4 C.guintptr) {
	var f func(container Widgetter, selectedItem gio.Filer, selectedVolume gio.Volumer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(container Widgetter, selectedItem gio.Filer, selectedVolume gio.Volumer))
	}

	var _container Widgetter        // out
	var _selectedItem gio.Filer     // out
	var _selectedVolume gio.Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_container = rv
	}
	if arg2 != nil {
		{
			objptr := unsafe.Pointer(arg2)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.Filer)
				return ok
			})
			rv, ok := casted.(gio.Filer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
			}
			_selectedItem = rv
		}
	}
	if arg3 != nil {
		{
			objptr := unsafe.Pointer(arg3)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.Volumer)
				return ok
			})
			rv, ok := casted.(gio.Volumer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
			}
			_selectedVolume = rv
		}
	}

	f(_container, _selectedItem, _selectedVolume)
}

//export _gotk4_gtk3_PlacesSidebar_ConnectShowConnectToServer
func _gotk4_gtk3_PlacesSidebar_ConnectShowConnectToServer(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_PlacesSidebar_ConnectShowEnterLocation
func _gotk4_gtk3_PlacesSidebar_ConnectShowEnterLocation(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_PlacesSidebar_ConnectShowErrorMessage
func _gotk4_gtk3_PlacesSidebar_ConnectShowErrorMessage(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(primary, secondary string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(primary, secondary string))
	}

	var _primary string   // out
	var _secondary string // out

	_primary = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_secondary = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_primary, _secondary)
}

//export _gotk4_gtk3_PlacesSidebar_ConnectShowOtherLocations
func _gotk4_gtk3_PlacesSidebar_ConnectShowOtherLocations(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_PlacesSidebar_ConnectShowOtherLocationsWithFlags
func _gotk4_gtk3_PlacesSidebar_ConnectShowOtherLocationsWithFlags(arg0 C.gpointer, arg1 C.GtkPlacesOpenFlags, arg2 C.guintptr) {
	var f func(openFlags PlacesOpenFlags)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(openFlags PlacesOpenFlags))
	}

	var _openFlags PlacesOpenFlags // out

	_openFlags = PlacesOpenFlags(arg1)

	f(_openFlags)
}

//export _gotk4_gtk3_PlacesSidebar_ConnectShowStarredLocation
func _gotk4_gtk3_PlacesSidebar_ConnectShowStarredLocation(arg0 C.gpointer, arg1 C.GtkPlacesOpenFlags, arg2 C.guintptr) {
	var f func(openFlags PlacesOpenFlags)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(openFlags PlacesOpenFlags))
	}

	var _openFlags PlacesOpenFlags // out

	_openFlags = PlacesOpenFlags(arg1)

	f(_openFlags)
}

//export _gotk4_gtk3_PlacesSidebar_ConnectUnmount
func _gotk4_gtk3_PlacesSidebar_ConnectUnmount(arg0 C.gpointer, arg1 *C.GMountOperation, arg2 C.guintptr) {
	var f func(mountOperation *gio.MountOperation)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mountOperation *gio.MountOperation))
	}

	var _mountOperation *gio.MountOperation // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_mountOperation = &gio.MountOperation{
			Object: obj,
		}
	}

	f(_mountOperation)
}

//export _gotk4_gtk3_PlugClass_embedded
func _gotk4_gtk3_PlugClass_embedded(arg0 *C.GtkPlug) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PlugOverrides](instance0)
	if overrides.Embedded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PlugOverrides.Embedded, got none")
	}

	overrides.Embedded()
}

//export _gotk4_gtk3_Plug_ConnectEmbedded
func _gotk4_gtk3_Plug_ConnectEmbedded(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_PopoverClass_closed
func _gotk4_gtk3_PopoverClass_closed(arg0 *C.GtkPopover) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PopoverOverrides](instance0)
	if overrides.Closed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PopoverOverrides.Closed, got none")
	}

	overrides.Closed()
}

//export _gotk4_gtk3_Popover_ConnectClosed
func _gotk4_gtk3_Popover_ConnectClosed(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_PrintOperationClass_begin_print
func _gotk4_gtk3_PrintOperationClass_begin_print(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.BeginPrint == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.BeginPrint, got none")
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.BeginPrint(_context)
}

//export _gotk4_gtk3_PrintOperationClass_custom_widget_apply
func _gotk4_gtk3_PrintOperationClass_custom_widget_apply(arg0 *C.GtkPrintOperation, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.CustomWidgetApply == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.CustomWidgetApply, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	overrides.CustomWidgetApply(_widget)
}

//export _gotk4_gtk3_PrintOperationClass_done
func _gotk4_gtk3_PrintOperationClass_done(arg0 *C.GtkPrintOperation, arg1 C.GtkPrintOperationResult) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.Done == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.Done, got none")
	}

	var _result PrintOperationResult // out

	_result = PrintOperationResult(arg1)

	overrides.Done(_result)
}

//export _gotk4_gtk3_PrintOperationClass_draw_page
func _gotk4_gtk3_PrintOperationClass_draw_page(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.DrawPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.DrawPage, got none")
	}

	var _context *PrintContext // out
	var _pageNr int            // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int(arg2)

	overrides.DrawPage(_context, _pageNr)
}

//export _gotk4_gtk3_PrintOperationClass_end_print
func _gotk4_gtk3_PrintOperationClass_end_print(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.EndPrint == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.EndPrint, got none")
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.EndPrint(_context)
}

//export _gotk4_gtk3_PrintOperationClass_paginate
func _gotk4_gtk3_PrintOperationClass_paginate(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.Paginate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.Paginate, got none")
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	ok := overrides.Paginate(_context)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PrintOperationClass_preview
func _gotk4_gtk3_PrintOperationClass_preview(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintOperationPreview, arg2 *C.GtkPrintContext, arg3 *C.GtkWindow) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.Preview == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.Preview, got none")
	}

	var _preview PrintOperationPreviewer // out
	var _context *PrintContext           // out
	var _parent *Window                  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.PrintOperationPreviewer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PrintOperationPreviewer)
			return ok
		})
		rv, ok := casted.(PrintOperationPreviewer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.PrintOperationPreviewer")
		}
		_preview = rv
	}
	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg2)))
	_parent = wrapWindow(coreglib.Take(unsafe.Pointer(arg3)))

	ok := overrides.Preview(_preview, _context, _parent)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PrintOperationClass_request_page_setup
func _gotk4_gtk3_PrintOperationClass_request_page_setup(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext, arg2 C.gint, arg3 *C.GtkPageSetup) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.RequestPageSetup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.RequestPageSetup, got none")
	}

	var _context *PrintContext // out
	var _pageNr int            // out
	var _setup *PageSetup      // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int(arg2)
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg3)))

	overrides.RequestPageSetup(_context, _pageNr, _setup)
}

//export _gotk4_gtk3_PrintOperationClass_status_changed
func _gotk4_gtk3_PrintOperationClass_status_changed(arg0 *C.GtkPrintOperation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.StatusChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.StatusChanged, got none")
	}

	overrides.StatusChanged()
}

//export _gotk4_gtk3_PrintOperationClass_update_custom_widget
func _gotk4_gtk3_PrintOperationClass_update_custom_widget(arg0 *C.GtkPrintOperation, arg1 *C.GtkWidget, arg2 *C.GtkPageSetup, arg3 *C.GtkPrintSettings) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.UpdateCustomWidget == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.UpdateCustomWidget, got none")
	}

	var _widget Widgetter        // out
	var _setup *PageSetup        // out
	var _settings *PrintSettings // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg2)))
	_settings = wrapPrintSettings(coreglib.Take(unsafe.Pointer(arg3)))

	overrides.UpdateCustomWidget(_widget, _setup, _settings)
}

//export _gotk4_gtk3_PrintOperation_ConnectBeginPrint
func _gotk4_gtk3_PrintOperation_ConnectBeginPrint(arg0 C.gpointer, arg1 *C.GtkPrintContext, arg2 C.guintptr) {
	var f func(context *PrintContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext))
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	f(_context)
}

//export _gotk4_gtk3_PrintOperation_ConnectCreateCustomWidget
func _gotk4_gtk3_PrintOperation_ConnectCreateCustomWidget(arg0 C.gpointer, arg1 C.guintptr) (cret *C.GObject) {
	var f func() (object *coreglib.Object)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (object *coreglib.Object))
	}

	object := f()

	var _ *coreglib.Object

	cret = (*C.GObject)(unsafe.Pointer(object.Native()))

	return cret
}

//export _gotk4_gtk3_PrintOperation_ConnectCustomWidgetApply
func _gotk4_gtk3_PrintOperation_ConnectCustomWidgetApply(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(widget Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter))
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	f(_widget)
}

//export _gotk4_gtk3_PrintOperation_ConnectDone
func _gotk4_gtk3_PrintOperation_ConnectDone(arg0 C.gpointer, arg1 C.GtkPrintOperationResult, arg2 C.guintptr) {
	var f func(result PrintOperationResult)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(result PrintOperationResult))
	}

	var _result PrintOperationResult // out

	_result = PrintOperationResult(arg1)

	f(_result)
}

//export _gotk4_gtk3_PrintOperation_ConnectDrawPage
func _gotk4_gtk3_PrintOperation_ConnectDrawPage(arg0 C.gpointer, arg1 *C.GtkPrintContext, arg2 C.gint, arg3 C.guintptr) {
	var f func(context *PrintContext, pageNr int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext, pageNr int))
	}

	var _context *PrintContext // out
	var _pageNr int            // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int(arg2)

	f(_context, _pageNr)
}

//export _gotk4_gtk3_PrintOperation_ConnectEndPrint
func _gotk4_gtk3_PrintOperation_ConnectEndPrint(arg0 C.gpointer, arg1 *C.GtkPrintContext, arg2 C.guintptr) {
	var f func(context *PrintContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext))
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	f(_context)
}

//export _gotk4_gtk3_PrintOperation_ConnectPaginate
func _gotk4_gtk3_PrintOperation_ConnectPaginate(arg0 C.gpointer, arg1 *C.GtkPrintContext, arg2 C.guintptr) (cret C.gboolean) {
	var f func(context *PrintContext) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext) (ok bool))
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_context)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PrintOperation_ConnectPreview
func _gotk4_gtk3_PrintOperation_ConnectPreview(arg0 C.gpointer, arg1 *C.GtkPrintOperationPreview, arg2 *C.GtkPrintContext, arg3 *C.GtkWindow, arg4 C.guintptr) (cret C.gboolean) {
	var f func(preview PrintOperationPreviewer, context *PrintContext, parent *Window) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(preview PrintOperationPreviewer, context *PrintContext, parent *Window) (ok bool))
	}

	var _preview PrintOperationPreviewer // out
	var _context *PrintContext           // out
	var _parent *Window                  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.PrintOperationPreviewer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PrintOperationPreviewer)
			return ok
		})
		rv, ok := casted.(PrintOperationPreviewer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.PrintOperationPreviewer")
		}
		_preview = rv
	}
	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg2)))
	if arg3 != nil {
		_parent = wrapWindow(coreglib.Take(unsafe.Pointer(arg3)))
	}

	ok := f(_preview, _context, _parent)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PrintOperation_ConnectRequestPageSetup
func _gotk4_gtk3_PrintOperation_ConnectRequestPageSetup(arg0 C.gpointer, arg1 *C.GtkPrintContext, arg2 C.gint, arg3 *C.GtkPageSetup, arg4 C.guintptr) {
	var f func(context *PrintContext, pageNr int, setup *PageSetup)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext, pageNr int, setup *PageSetup))
	}

	var _context *PrintContext // out
	var _pageNr int            // out
	var _setup *PageSetup      // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int(arg2)
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg3)))

	f(_context, _pageNr, _setup)
}

//export _gotk4_gtk3_PrintOperation_ConnectStatusChanged
func _gotk4_gtk3_PrintOperation_ConnectStatusChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_PrintOperation_ConnectUpdateCustomWidget
func _gotk4_gtk3_PrintOperation_ConnectUpdateCustomWidget(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 *C.GtkPageSetup, arg3 *C.GtkPrintSettings, arg4 C.guintptr) {
	var f func(widget Widgetter, setup *PageSetup, settings *PrintSettings)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter, setup *PageSetup, settings *PrintSettings))
	}

	var _widget Widgetter        // out
	var _setup *PageSetup        // out
	var _settings *PrintSettings // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg2)))
	_settings = wrapPrintSettings(coreglib.Take(unsafe.Pointer(arg3)))

	f(_widget, _setup, _settings)
}

//export _gotk4_gtk3_RadioActionClass_changed
func _gotk4_gtk3_RadioActionClass_changed(arg0 *C.GtkRadioAction, arg1 *C.GtkRadioAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RadioActionOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RadioActionOverrides.Changed, got none")
	}

	var _current *RadioAction // out

	_current = wrapRadioAction(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.Changed(_current)
}

//export _gotk4_gtk3_RadioAction_ConnectChanged
func _gotk4_gtk3_RadioAction_ConnectChanged(arg0 C.gpointer, arg1 *C.GtkRadioAction, arg2 C.guintptr) {
	var f func(current *RadioAction)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(current *RadioAction))
	}

	var _current *RadioAction // out

	_current = wrapRadioAction(coreglib.Take(unsafe.Pointer(arg1)))

	f(_current)
}

//export _gotk4_gtk3_RadioButtonClass_group_changed
func _gotk4_gtk3_RadioButtonClass_group_changed(arg0 *C.GtkRadioButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RadioButtonOverrides](instance0)
	if overrides.GroupChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RadioButtonOverrides.GroupChanged, got none")
	}

	overrides.GroupChanged()
}

//export _gotk4_gtk3_RadioButton_ConnectGroupChanged
func _gotk4_gtk3_RadioButton_ConnectGroupChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_RadioMenuItemClass_group_changed
func _gotk4_gtk3_RadioMenuItemClass_group_changed(arg0 *C.GtkRadioMenuItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RadioMenuItemOverrides](instance0)
	if overrides.GroupChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RadioMenuItemOverrides.GroupChanged, got none")
	}

	overrides.GroupChanged()
}

//export _gotk4_gtk3_RadioMenuItem_ConnectGroupChanged
func _gotk4_gtk3_RadioMenuItem_ConnectGroupChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_RangeClass_adjust_bounds
func _gotk4_gtk3_RangeClass_adjust_bounds(arg0 *C.GtkRange, arg1 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.AdjustBounds == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.AdjustBounds, got none")
	}

	var _newValue float64 // out

	_newValue = float64(arg1)

	overrides.AdjustBounds(_newValue)
}

//export _gotk4_gtk3_RangeClass_change_value
func _gotk4_gtk3_RangeClass_change_value(arg0 *C.GtkRange, arg1 C.GtkScrollType, arg2 C.gdouble) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.ChangeValue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.ChangeValue, got none")
	}

	var _scroll ScrollType // out
	var _newValue float64  // out

	_scroll = ScrollType(arg1)
	_newValue = float64(arg2)

	ok := overrides.ChangeValue(_scroll, _newValue)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_RangeClass_get_range_border
func _gotk4_gtk3_RangeClass_get_range_border(arg0 *C.GtkRange, arg1 *C.GtkBorder) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.RangeBorder == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.RangeBorder, got none")
	}

	var _border_ *Border // out

	_border_ = (*Border)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.RangeBorder(_border_)
}

//export _gotk4_gtk3_RangeClass_get_range_size_request
func _gotk4_gtk3_RangeClass_get_range_size_request(arg0 *C.GtkRange, arg1 C.GtkOrientation, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.RangeSizeRequest == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.RangeSizeRequest, got none")
	}

	var _orientation Orientation // out
	var _minimum *int            // out
	var _natural *int            // out

	_orientation = Orientation(arg1)
	_minimum = (*int)(unsafe.Pointer(arg2))
	_natural = (*int)(unsafe.Pointer(arg3))

	overrides.RangeSizeRequest(_orientation, _minimum, _natural)
}

//export _gotk4_gtk3_RangeClass_move_slider
func _gotk4_gtk3_RangeClass_move_slider(arg0 *C.GtkRange, arg1 C.GtkScrollType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.MoveSlider == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.MoveSlider, got none")
	}

	var _scroll ScrollType // out

	_scroll = ScrollType(arg1)

	overrides.MoveSlider(_scroll)
}

//export _gotk4_gtk3_RangeClass_value_changed
func _gotk4_gtk3_RangeClass_value_changed(arg0 *C.GtkRange) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.ValueChanged, got none")
	}

	overrides.ValueChanged()
}

//export _gotk4_gtk3_Range_ConnectAdjustBounds
func _gotk4_gtk3_Range_ConnectAdjustBounds(arg0 C.gpointer, arg1 C.gdouble, arg2 C.guintptr) {
	var f func(value float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(value float64))
	}

	var _value float64 // out

	_value = float64(arg1)

	f(_value)
}

//export _gotk4_gtk3_Range_ConnectChangeValue
func _gotk4_gtk3_Range_ConnectChangeValue(arg0 C.gpointer, arg1 C.GtkScrollType, arg2 C.gdouble, arg3 C.guintptr) (cret C.gboolean) {
	var f func(scroll ScrollType, value float64) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(scroll ScrollType, value float64) (ok bool))
	}

	var _scroll ScrollType // out
	var _value float64     // out

	_scroll = ScrollType(arg1)
	_value = float64(arg2)

	ok := f(_scroll, _value)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Range_ConnectMoveSlider
func _gotk4_gtk3_Range_ConnectMoveSlider(arg0 C.gpointer, arg1 C.GtkScrollType, arg2 C.guintptr) {
	var f func(step ScrollType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step ScrollType))
	}

	var _step ScrollType // out

	_step = ScrollType(arg1)

	f(_step)
}

//export _gotk4_gtk3_Range_ConnectValueChanged
func _gotk4_gtk3_Range_ConnectValueChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_RcStyleClass_merge
func _gotk4_gtk3_RcStyleClass_merge(arg0 *C.GtkRcStyle, arg1 *C.GtkRcStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RCStyleOverrides](instance0)
	if overrides.Merge == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RCStyleOverrides.Merge, got none")
	}

	var _src *RCStyle // out

	_src = wrapRCStyle(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.Merge(_src)
}

//export _gotk4_gtk3_RcStyleClass_parse
func _gotk4_gtk3_RcStyleClass_parse(arg0 *C.GtkRcStyle, arg1 *C.GtkSettings, arg2 *C.GScanner) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RCStyleOverrides](instance0)
	if overrides.Parse == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RCStyleOverrides.Parse, got none")
	}

	var _settings *Settings    // out
	var _scanner *glib.Scanner // out

	_settings = wrapSettings(coreglib.Take(unsafe.Pointer(arg1)))
	_scanner = (*glib.Scanner)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	guint := overrides.Parse(_settings, _scanner)

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk3_RecentManagerClass_changed
func _gotk4_gtk3_RecentManagerClass_changed(arg0 *C.GtkRecentManager) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RecentManagerOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RecentManagerOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_RecentManager_ConnectChanged
func _gotk4_gtk3_RecentManager_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ScaleClass_draw_value
func _gotk4_gtk3_ScaleClass_draw_value(arg0 *C.GtkScale) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleOverrides](instance0)
	if overrides.DrawValue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleOverrides.DrawValue, got none")
	}

	overrides.DrawValue()
}

//export _gotk4_gtk3_ScaleClass_format_value
func _gotk4_gtk3_ScaleClass_format_value(arg0 *C.GtkScale, arg1 C.gdouble) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleOverrides](instance0)
	if overrides.FormatValue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleOverrides.FormatValue, got none")
	}

	var _value float64 // out

	_value = float64(arg1)

	utf8 := overrides.FormatValue(_value)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_ScaleClass_get_layout_offsets
func _gotk4_gtk3_ScaleClass_get_layout_offsets(arg0 *C.GtkScale, arg1 *C.gint, arg2 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleOverrides](instance0)
	if overrides.LayoutOffsets == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleOverrides.LayoutOffsets, got none")
	}

	x, y := overrides.LayoutOffsets()

	var _ int
	var _ int

	*arg1 = C.gint(x)
	*arg2 = C.gint(y)
}

//export _gotk4_gtk3_Scale_ConnectFormatValue
func _gotk4_gtk3_Scale_ConnectFormatValue(arg0 C.gpointer, arg1 C.gdouble, arg2 C.guintptr) (cret *C.gchar) {
	var f func(value float64) (utf8 string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(value float64) (utf8 string))
	}

	var _value float64 // out

	_value = float64(arg1)

	utf8 := f(_value)

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_ScaleButtonClass_value_changed
func _gotk4_gtk3_ScaleButtonClass_value_changed(arg0 *C.GtkScaleButton, arg1 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleButtonOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleButtonOverrides.ValueChanged, got none")
	}

	var _value float64 // out

	_value = float64(arg1)

	overrides.ValueChanged(_value)
}

//export _gotk4_gtk3_ScaleButton_ConnectPopdown
func _gotk4_gtk3_ScaleButton_ConnectPopdown(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ScaleButton_ConnectPopup
func _gotk4_gtk3_ScaleButton_ConnectPopup(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ScaleButton_ConnectValueChanged
func _gotk4_gtk3_ScaleButton_ConnectValueChanged(arg0 C.gpointer, arg1 C.gdouble, arg2 C.guintptr) {
	var f func(value float64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(value float64))
	}

	var _value float64 // out

	_value = float64(arg1)

	f(_value)
}

//export _gotk4_gtk3_ScrolledWindowClass_move_focus_out
func _gotk4_gtk3_ScrolledWindowClass_move_focus_out(arg0 *C.GtkScrolledWindow, arg1 C.GtkDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScrolledWindowOverrides](instance0)
	if overrides.MoveFocusOut == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScrolledWindowOverrides.MoveFocusOut, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	overrides.MoveFocusOut(_direction)
}

//export _gotk4_gtk3_ScrolledWindowClass_scroll_child
func _gotk4_gtk3_ScrolledWindowClass_scroll_child(arg0 *C.GtkScrolledWindow, arg1 C.GtkScrollType, arg2 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScrolledWindowOverrides](instance0)
	if overrides.ScrollChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScrolledWindowOverrides.ScrollChild, got none")
	}

	var _scroll ScrollType // out
	var _horizontal bool   // out

	_scroll = ScrollType(arg1)
	if arg2 != 0 {
		_horizontal = true
	}

	ok := overrides.ScrollChild(_scroll, _horizontal)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ScrolledWindow_ConnectEdgeOvershot
func _gotk4_gtk3_ScrolledWindow_ConnectEdgeOvershot(arg0 C.gpointer, arg1 C.GtkPositionType, arg2 C.guintptr) {
	var f func(pos PositionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(pos PositionType))
	}

	var _pos PositionType // out

	_pos = PositionType(arg1)

	f(_pos)
}

//export _gotk4_gtk3_ScrolledWindow_ConnectEdgeReached
func _gotk4_gtk3_ScrolledWindow_ConnectEdgeReached(arg0 C.gpointer, arg1 C.GtkPositionType, arg2 C.guintptr) {
	var f func(pos PositionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(pos PositionType))
	}

	var _pos PositionType // out

	_pos = PositionType(arg1)

	f(_pos)
}

//export _gotk4_gtk3_ScrolledWindow_ConnectMoveFocusOut
func _gotk4_gtk3_ScrolledWindow_ConnectMoveFocusOut(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(directionType DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(directionType DirectionType))
	}

	var _directionType DirectionType // out

	_directionType = DirectionType(arg1)

	f(_directionType)
}

//export _gotk4_gtk3_ScrolledWindow_ConnectScrollChild
func _gotk4_gtk3_ScrolledWindow_ConnectScrollChild(arg0 C.gpointer, arg1 C.GtkScrollType, arg2 C.gboolean, arg3 C.guintptr) (cret C.gboolean) {
	var f func(scroll ScrollType, horizontal bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(scroll ScrollType, horizontal bool) (ok bool))
	}

	var _scroll ScrollType // out
	var _horizontal bool   // out

	_scroll = ScrollType(arg1)
	if arg2 != 0 {
		_horizontal = true
	}

	ok := f(_scroll, _horizontal)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_SearchEntryClass_next_match
func _gotk4_gtk3_SearchEntryClass_next_match(arg0 *C.GtkSearchEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SearchEntryOverrides](instance0)
	if overrides.NextMatch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SearchEntryOverrides.NextMatch, got none")
	}

	overrides.NextMatch()
}

//export _gotk4_gtk3_SearchEntryClass_previous_match
func _gotk4_gtk3_SearchEntryClass_previous_match(arg0 *C.GtkSearchEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SearchEntryOverrides](instance0)
	if overrides.PreviousMatch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SearchEntryOverrides.PreviousMatch, got none")
	}

	overrides.PreviousMatch()
}

//export _gotk4_gtk3_SearchEntryClass_search_changed
func _gotk4_gtk3_SearchEntryClass_search_changed(arg0 *C.GtkSearchEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SearchEntryOverrides](instance0)
	if overrides.SearchChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SearchEntryOverrides.SearchChanged, got none")
	}

	overrides.SearchChanged()
}

//export _gotk4_gtk3_SearchEntryClass_stop_search
func _gotk4_gtk3_SearchEntryClass_stop_search(arg0 *C.GtkSearchEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SearchEntryOverrides](instance0)
	if overrides.StopSearch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SearchEntryOverrides.StopSearch, got none")
	}

	overrides.StopSearch()
}

//export _gotk4_gtk3_SearchEntry_ConnectNextMatch
func _gotk4_gtk3_SearchEntry_ConnectNextMatch(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_SearchEntry_ConnectPreviousMatch
func _gotk4_gtk3_SearchEntry_ConnectPreviousMatch(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_SearchEntry_ConnectSearchChanged
func _gotk4_gtk3_SearchEntry_ConnectSearchChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_SearchEntry_ConnectStopSearch
func _gotk4_gtk3_SearchEntry_ConnectStopSearch(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ShortcutsSection_ConnectChangeCurrentPage
func _gotk4_gtk3_ShortcutsSection_ConnectChangeCurrentPage(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object int) (ok bool))
	}

	var _object int // out

	_object = int(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ShortcutsWindowClass_close
func _gotk4_gtk3_ShortcutsWindowClass_close(arg0 *C.GtkShortcutsWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ShortcutsWindowOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ShortcutsWindowOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk3_ShortcutsWindowClass_search
func _gotk4_gtk3_ShortcutsWindowClass_search(arg0 *C.GtkShortcutsWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ShortcutsWindowOverrides](instance0)
	if overrides.Search == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ShortcutsWindowOverrides.Search, got none")
	}

	overrides.Search()
}

//export _gotk4_gtk3_ShortcutsWindow_ConnectClose
func _gotk4_gtk3_ShortcutsWindow_ConnectClose(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ShortcutsWindow_ConnectSearch
func _gotk4_gtk3_ShortcutsWindow_ConnectSearch(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_SocketClass_plug_added
func _gotk4_gtk3_SocketClass_plug_added(arg0 *C.GtkSocket) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SocketOverrides](instance0)
	if overrides.PlugAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SocketOverrides.PlugAdded, got none")
	}

	overrides.PlugAdded()
}

//export _gotk4_gtk3_SocketClass_plug_removed
func _gotk4_gtk3_SocketClass_plug_removed(arg0 *C.GtkSocket) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SocketOverrides](instance0)
	if overrides.PlugRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SocketOverrides.PlugRemoved, got none")
	}

	ok := overrides.PlugRemoved()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Socket_ConnectPlugAdded
func _gotk4_gtk3_Socket_ConnectPlugAdded(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Socket_ConnectPlugRemoved
func _gotk4_gtk3_Socket_ConnectPlugRemoved(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_SpinButtonClass_change_value
func _gotk4_gtk3_SpinButtonClass_change_value(arg0 *C.GtkSpinButton, arg1 C.GtkScrollType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.ChangeValue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.ChangeValue, got none")
	}

	var _scroll ScrollType // out

	_scroll = ScrollType(arg1)

	overrides.ChangeValue(_scroll)
}

//export _gotk4_gtk3_SpinButtonClass_input
func _gotk4_gtk3_SpinButtonClass_input(arg0 *C.GtkSpinButton, arg1 *C.gdouble) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.Input == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.Input, got none")
	}

	var _newValue *float64 // out

	_newValue = (*float64)(unsafe.Pointer(arg1))

	gint := overrides.Input(_newValue)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_SpinButtonClass_output
func _gotk4_gtk3_SpinButtonClass_output(arg0 *C.GtkSpinButton) (cret C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.Output == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.Output, got none")
	}

	gint := overrides.Output()

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_SpinButtonClass_value_changed
func _gotk4_gtk3_SpinButtonClass_value_changed(arg0 *C.GtkSpinButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.ValueChanged, got none")
	}

	overrides.ValueChanged()
}

//export _gotk4_gtk3_SpinButtonClass_wrapped
func _gotk4_gtk3_SpinButtonClass_wrapped(arg0 *C.GtkSpinButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SpinButtonOverrides](instance0)
	if overrides.Wrapped == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SpinButtonOverrides.Wrapped, got none")
	}

	overrides.Wrapped()
}

//export _gotk4_gtk3_SpinButton_ConnectChangeValue
func _gotk4_gtk3_SpinButton_ConnectChangeValue(arg0 C.gpointer, arg1 C.GtkScrollType, arg2 C.guintptr) {
	var f func(scroll ScrollType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(scroll ScrollType))
	}

	var _scroll ScrollType // out

	_scroll = ScrollType(arg1)

	f(_scroll)
}

//export _gotk4_gtk3_SpinButton_ConnectOutput
func _gotk4_gtk3_SpinButton_ConnectOutput(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_SpinButton_ConnectValueChanged
func _gotk4_gtk3_SpinButton_ConnectValueChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_SpinButton_ConnectWrapped
func _gotk4_gtk3_SpinButton_ConnectWrapped(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_StatusIconClass_activate
func _gotk4_gtk3_StatusIconClass_activate(arg0 *C.GtkStatusIcon) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_StatusIconClass_button_press_event
func _gotk4_gtk3_StatusIconClass_button_press_event(arg0 *C.GtkStatusIcon, arg1 *C.GdkEventButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.ButtonPressEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.ButtonPressEvent, got none")
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ButtonPressEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_button_release_event
func _gotk4_gtk3_StatusIconClass_button_release_event(arg0 *C.GtkStatusIcon, arg1 *C.GdkEventButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.ButtonReleaseEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.ButtonReleaseEvent, got none")
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ButtonReleaseEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_popup_menu
func _gotk4_gtk3_StatusIconClass_popup_menu(arg0 *C.GtkStatusIcon, arg1 C.guint, arg2 C.guint32) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.PopupMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.PopupMenu, got none")
	}

	var _button uint         // out
	var _activateTime uint32 // out

	_button = uint(arg1)
	_activateTime = uint32(arg2)

	overrides.PopupMenu(_button, _activateTime)
}

//export _gotk4_gtk3_StatusIconClass_query_tooltip
func _gotk4_gtk3_StatusIconClass_query_tooltip(arg0 *C.GtkStatusIcon, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.GtkTooltip) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.QueryTooltip == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.QueryTooltip, got none")
	}

	var _x int             // out
	var _y int             // out
	var _keyboardMode bool // out
	var _tooltip *Tooltip  // out

	_x = int(arg1)
	_y = int(arg2)
	if arg3 != 0 {
		_keyboardMode = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := overrides.QueryTooltip(_x, _y, _keyboardMode, _tooltip)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_scroll_event
func _gotk4_gtk3_StatusIconClass_scroll_event(arg0 *C.GtkStatusIcon, arg1 *C.GdkEventScroll) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.ScrollEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.ScrollEvent, got none")
	}

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ScrollEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_size_changed
func _gotk4_gtk3_StatusIconClass_size_changed(arg0 *C.GtkStatusIcon, arg1 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusIconOverrides](instance0)
	if overrides.SizeChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusIconOverrides.SizeChanged, got none")
	}

	var _size int // out

	_size = int(arg1)

	ok := overrides.SizeChanged(_size)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIcon_ConnectActivate
func _gotk4_gtk3_StatusIcon_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_StatusIcon_ConnectButtonPressEvent
func _gotk4_gtk3_StatusIcon_ConnectButtonPressEvent(arg0 C.gpointer, arg1 *C.GdkEventButton, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent
func _gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent(arg0 C.gpointer, arg1 *C.GdkEventButton, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIcon_ConnectPopupMenu
func _gotk4_gtk3_StatusIcon_ConnectPopupMenu(arg0 C.gpointer, arg1 C.guint, arg2 C.guint, arg3 C.guintptr) {
	var f func(button, activateTime uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(button, activateTime uint))
	}

	var _button uint       // out
	var _activateTime uint // out

	_button = uint(arg1)
	_activateTime = uint(arg2)

	f(_button, _activateTime)
}

//export _gotk4_gtk3_StatusIcon_ConnectQueryTooltip
func _gotk4_gtk3_StatusIcon_ConnectQueryTooltip(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.GtkTooltip, arg5 C.guintptr) (cret C.gboolean) {
	var f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool))
	}

	var _x int             // out
	var _y int             // out
	var _keyboardMode bool // out
	var _tooltip *Tooltip  // out

	_x = int(arg1)
	_y = int(arg2)
	if arg3 != 0 {
		_keyboardMode = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := f(_x, _y, _keyboardMode, _tooltip)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIcon_ConnectScrollEvent
func _gotk4_gtk3_StatusIcon_ConnectScrollEvent(arg0 C.gpointer, arg1 *C.GdkEventScroll, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventScroll) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventScroll) (ok bool))
	}

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIcon_ConnectSizeChanged
func _gotk4_gtk3_StatusIcon_ConnectSizeChanged(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(size int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(size int) (ok bool))
	}

	var _size int // out

	_size = int(arg1)

	ok := f(_size)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusbarClass_text_popped
func _gotk4_gtk3_StatusbarClass_text_popped(arg0 *C.GtkStatusbar, arg1 C.guint, arg2 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusbarOverrides](instance0)
	if overrides.TextPopped == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusbarOverrides.TextPopped, got none")
	}

	var _contextId uint // out
	var _text string    // out

	_contextId = uint(arg1)
	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.TextPopped(_contextId, _text)
}

//export _gotk4_gtk3_StatusbarClass_text_pushed
func _gotk4_gtk3_StatusbarClass_text_pushed(arg0 *C.GtkStatusbar, arg1 C.guint, arg2 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StatusbarOverrides](instance0)
	if overrides.TextPushed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StatusbarOverrides.TextPushed, got none")
	}

	var _contextId uint // out
	var _text string    // out

	_contextId = uint(arg1)
	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.TextPushed(_contextId, _text)
}

//export _gotk4_gtk3_Statusbar_ConnectTextPopped
func _gotk4_gtk3_Statusbar_ConnectTextPopped(arg0 C.gpointer, arg1 C.guint, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(contextId uint, text string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(contextId uint, text string))
	}

	var _contextId uint // out
	var _text string    // out

	_contextId = uint(arg1)
	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_contextId, _text)
}

//export _gotk4_gtk3_Statusbar_ConnectTextPushed
func _gotk4_gtk3_Statusbar_ConnectTextPushed(arg0 C.gpointer, arg1 C.guint, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(contextId uint, text string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(contextId uint, text string))
	}

	var _contextId uint // out
	var _text string    // out

	_contextId = uint(arg1)
	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_contextId, _text)
}

//export _gotk4_gtk3_StyleClass_copy
func _gotk4_gtk3_StyleClass_copy(arg0 *C.GtkStyle, arg1 *C.GtkStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.Copy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.Copy, got none")
	}

	var _src *Style // out

	_src = wrapStyle(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.Copy(_src)
}

//export _gotk4_gtk3_StyleClass_draw_arrow
func _gotk4_gtk3_StyleClass_draw_arrow(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.GtkArrowType, arg7 C.gboolean, arg8 C.gint, arg9 C.gint, arg10 C.gint, arg11 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawArrow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawArrow, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _arrowType ArrowType   // out
	var _fill bool             // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_arrowType = ArrowType(arg6)
	if arg7 != 0 {
		_fill = true
	}
	_x = int(arg8)
	_y = int(arg9)
	_width = int(arg10)
	_height = int(arg11)

	overrides.DrawArrow(_cr, _stateType, _shadowType, _widget, _detail, _arrowType, _fill, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_box
func _gotk4_gtk3_StyleClass_draw_box(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawBox == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawBox, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawBox(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_box_gap
func _gotk4_gtk3_StyleClass_draw_box_gap(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkPositionType, arg11 C.gint, arg12 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawBoxGap == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawBoxGap, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out
	var _gapSide PositionType  // out
	var _gapX int              // out
	var _gapWidth int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_gapSide = PositionType(arg10)
	_gapX = int(arg11)
	_gapWidth = int(arg12)

	overrides.DrawBoxGap(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _gapSide, _gapX, _gapWidth)
}

//export _gotk4_gtk3_StyleClass_draw_check
func _gotk4_gtk3_StyleClass_draw_check(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawCheck == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawCheck, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawCheck(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_diamond
func _gotk4_gtk3_StyleClass_draw_diamond(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawDiamond == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawDiamond, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawDiamond(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_expander
func _gotk4_gtk3_StyleClass_draw_expander(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.gint, arg6 C.gint, arg7 C.GtkExpanderStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawExpander == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawExpander, got none")
	}

	var _cr *cairo.Context           // out
	var _stateType StateType         // out
	var _widget Widgetter            // out
	var _detail string               // out
	var _x int                       // out
	var _y int                       // out
	var _expanderStyle ExpanderStyle // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_x = int(arg5)
	_y = int(arg6)
	_expanderStyle = ExpanderStyle(arg7)

	overrides.DrawExpander(_cr, _stateType, _widget, _detail, _x, _y, _expanderStyle)
}

//export _gotk4_gtk3_StyleClass_draw_extension
func _gotk4_gtk3_StyleClass_draw_extension(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkPositionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawExtension == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawExtension, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out
	var _gapSide PositionType  // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_gapSide = PositionType(arg10)

	overrides.DrawExtension(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _gapSide)
}

//export _gotk4_gtk3_StyleClass_draw_flat_box
func _gotk4_gtk3_StyleClass_draw_flat_box(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawFlatBox == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawFlatBox, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawFlatBox(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_focus
func _gotk4_gtk3_StyleClass_draw_focus(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.gint, arg6 C.gint, arg7 C.gint, arg8 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawFocus, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _x int               // out
	var _y int               // out
	var _width int           // out
	var _height int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_x = int(arg5)
	_y = int(arg6)
	_width = int(arg7)
	_height = int(arg8)

	overrides.DrawFocus(_cr, _stateType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_handle
func _gotk4_gtk3_StyleClass_draw_handle(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkOrientation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawHandle == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawHandle, got none")
	}

	var _cr *cairo.Context       // out
	var _stateType StateType     // out
	var _shadowType ShadowType   // out
	var _widget Widgetter        // out
	var _detail string           // out
	var _x int                   // out
	var _y int                   // out
	var _width int               // out
	var _height int              // out
	var _orientation Orientation // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_orientation = Orientation(arg10)

	overrides.DrawHandle(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _orientation)
}

//export _gotk4_gtk3_StyleClass_draw_hline
func _gotk4_gtk3_StyleClass_draw_hline(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.gint, arg6 C.gint, arg7 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawHline == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawHline, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _x1 int              // out
	var _x2 int              // out
	var _y int               // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_x1 = int(arg5)
	_x2 = int(arg6)
	_y = int(arg7)

	overrides.DrawHline(_cr, _stateType, _widget, _detail, _x1, _x2, _y)
}

//export _gotk4_gtk3_StyleClass_draw_layout
func _gotk4_gtk3_StyleClass_draw_layout(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.gboolean, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 *C.PangoLayout) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawLayout == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawLayout, got none")
	}

	var _cr *cairo.Context    // out
	var _stateType StateType  // out
	var _useText bool         // out
	var _widget Widgetter     // out
	var _detail string        // out
	var _x int                // out
	var _y int                // out
	var _layout *pango.Layout // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	if arg3 != 0 {
		_useText = true
	}
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	{
		obj := coreglib.Take(unsafe.Pointer(arg8))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	overrides.DrawLayout(_cr, _stateType, _useText, _widget, _detail, _x, _y, _layout)
}

//export _gotk4_gtk3_StyleClass_draw_option
func _gotk4_gtk3_StyleClass_draw_option(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawOption == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawOption, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawOption(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_resize_grip
func _gotk4_gtk3_StyleClass_draw_resize_grip(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.GdkWindowEdge, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawResizeGrip == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawResizeGrip, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _edge gdk.WindowEdge // out
	var _x int               // out
	var _y int               // out
	var _width int           // out
	var _height int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_edge = gdk.WindowEdge(arg5)
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawResizeGrip(_cr, _stateType, _widget, _detail, _edge, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_shadow
func _gotk4_gtk3_StyleClass_draw_shadow(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawShadow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawShadow, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawShadow(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_shadow_gap
func _gotk4_gtk3_StyleClass_draw_shadow_gap(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkPositionType, arg11 C.gint, arg12 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawShadowGap == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawShadowGap, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out
	var _gapSide PositionType  // out
	var _gapX int              // out
	var _gapWidth int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_gapSide = PositionType(arg10)
	_gapX = int(arg11)
	_gapWidth = int(arg12)

	overrides.DrawShadowGap(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _gapSide, _gapX, _gapWidth)
}

//export _gotk4_gtk3_StyleClass_draw_slider
func _gotk4_gtk3_StyleClass_draw_slider(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint, arg10 C.GtkOrientation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawSlider == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawSlider, got none")
	}

	var _cr *cairo.Context       // out
	var _stateType StateType     // out
	var _shadowType ShadowType   // out
	var _widget Widgetter        // out
	var _detail string           // out
	var _x int                   // out
	var _y int                   // out
	var _width int               // out
	var _height int              // out
	var _orientation Orientation // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)
	_orientation = Orientation(arg10)

	overrides.DrawSlider(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height, _orientation)
}

//export _gotk4_gtk3_StyleClass_draw_spinner
func _gotk4_gtk3_StyleClass_draw_spinner(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.guint, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawSpinner == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawSpinner, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _step uint           // out
	var _x int               // out
	var _y int               // out
	var _width int           // out
	var _height int          // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_step = uint(arg5)
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawSpinner(_cr, _stateType, _widget, _detail, _step, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_tab
func _gotk4_gtk3_StyleClass_draw_tab(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 C.GtkShadowType, arg4 *C.GtkWidget, arg5 *C.gchar, arg6 C.gint, arg7 C.gint, arg8 C.gint, arg9 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawTab == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawTab, got none")
	}

	var _cr *cairo.Context     // out
	var _stateType StateType   // out
	var _shadowType ShadowType // out
	var _widget Widgetter      // out
	var _detail string         // out
	var _x int                 // out
	var _y int                 // out
	var _width int             // out
	var _height int            // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	_shadowType = ShadowType(arg3)
	{
		objptr := unsafe.Pointer(arg4)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg5)))
	_x = int(arg6)
	_y = int(arg7)
	_width = int(arg8)
	_height = int(arg9)

	overrides.DrawTab(_cr, _stateType, _shadowType, _widget, _detail, _x, _y, _width, _height)
}

//export _gotk4_gtk3_StyleClass_draw_vline
func _gotk4_gtk3_StyleClass_draw_vline(arg0 *C.GtkStyle, arg1 *C.cairo_t, arg2 C.GtkStateType, arg3 *C.GtkWidget, arg4 *C.gchar, arg5 C.gint, arg6 C.gint, arg7 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.DrawVline == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.DrawVline, got none")
	}

	var _cr *cairo.Context   // out
	var _stateType StateType // out
	var _widget Widgetter    // out
	var _detail string       // out
	var _y1 int              // out
	var _y2 int              // out
	var _x int               // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_stateType = StateType(arg2)
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))
	_y1 = int(arg5)
	_y2 = int(arg6)
	_x = int(arg7)

	overrides.DrawVline(_cr, _stateType, _widget, _detail, _y1, _y2, _x)
}

//export _gotk4_gtk3_StyleClass_init_from_rc
func _gotk4_gtk3_StyleClass_init_from_rc(arg0 *C.GtkStyle, arg1 *C.GtkRcStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.InitFromRC == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.InitFromRC, got none")
	}

	var _rcStyle *RCStyle // out

	_rcStyle = wrapRCStyle(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.InitFromRC(_rcStyle)
}

//export _gotk4_gtk3_StyleClass_realize
func _gotk4_gtk3_StyleClass_realize(arg0 *C.GtkStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.Realize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.Realize, got none")
	}

	overrides.Realize()
}

//export _gotk4_gtk3_StyleClass_render_icon
func _gotk4_gtk3_StyleClass_render_icon(arg0 *C.GtkStyle, arg1 *C.GtkIconSource, arg2 C.GtkTextDirection, arg3 C.GtkStateType, arg4 C.GtkIconSize, arg5 *C.GtkWidget, arg6 *C.gchar) (cret *C.GdkPixbuf) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.RenderIcon == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.RenderIcon, got none")
	}

	var _source *IconSource      // out
	var _direction TextDirection // out
	var _state StateType         // out
	var _size int                // out
	var _widget Widgetter        // out
	var _detail string           // out

	_source = (*IconSource)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_direction = TextDirection(arg2)
	_state = StateType(arg3)
	_size = int(arg4)
	if arg5 != nil {
		{
			objptr := unsafe.Pointer(arg5)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}
	if arg6 != nil {
		_detail = C.GoString((*C.gchar)(unsafe.Pointer(arg6)))
	}

	pixbuf := overrides.RenderIcon(_source, _direction, _state, _size, _widget, _detail)

	var _ *gdkpixbuf.Pixbuf

	cret = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(pixbuf).Native()))

	return cret
}

//export _gotk4_gtk3_StyleClass_set_background
func _gotk4_gtk3_StyleClass_set_background(arg0 *C.GtkStyle, arg1 *C.GdkWindow, arg2 C.GtkStateType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.SetBackground == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.SetBackground, got none")
	}

	var _window gdk.Windower // out
	var _stateType StateType // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Windower)
			return ok
		})
		rv, ok := casted.(gdk.Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_window = rv
	}
	_stateType = StateType(arg2)

	overrides.SetBackground(_window, _stateType)
}

//export _gotk4_gtk3_StyleClass_unrealize
func _gotk4_gtk3_StyleClass_unrealize(arg0 *C.GtkStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleOverrides](instance0)
	if overrides.Unrealize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleOverrides.Unrealize, got none")
	}

	overrides.Unrealize()
}

//export _gotk4_gtk3_Style_ConnectRealize
func _gotk4_gtk3_Style_ConnectRealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Style_ConnectUnrealize
func _gotk4_gtk3_Style_ConnectUnrealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_StyleContextClass_changed
func _gotk4_gtk3_StyleContextClass_changed(arg0 *C.GtkStyleContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleContextOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleContextOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_StyleContext_ConnectChanged
func _gotk4_gtk3_StyleContext_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_SwitchClass_activate
func _gotk4_gtk3_SwitchClass_activate(arg0 *C.GtkSwitch) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SwitchOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SwitchOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk3_SwitchClass_state_set
func _gotk4_gtk3_SwitchClass_state_set(arg0 *C.GtkSwitch, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SwitchOverrides](instance0)
	if overrides.StateSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SwitchOverrides.StateSet, got none")
	}

	var _state bool // out

	if arg1 != 0 {
		_state = true
	}

	ok := overrides.StateSet(_state)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Switch_ConnectActivate
func _gotk4_gtk3_Switch_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Switch_ConnectStateSet
func _gotk4_gtk3_Switch_ConnectStateSet(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(state bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(state bool) (ok bool))
	}

	var _state bool // out

	if arg1 != 0 {
		_state = true
	}

	ok := f(_state)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextBufferClass_apply_tag
func _gotk4_gtk3_TextBufferClass_apply_tag(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.ApplyTag == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.ApplyTag, got none")
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	overrides.ApplyTag(_tag, _start, _end)
}

//export _gotk4_gtk3_TextBufferClass_begin_user_action
func _gotk4_gtk3_TextBufferClass_begin_user_action(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.BeginUserAction == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.BeginUserAction, got none")
	}

	overrides.BeginUserAction()
}

//export _gotk4_gtk3_TextBufferClass_changed
func _gotk4_gtk3_TextBufferClass_changed(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_TextBufferClass_delete_range
func _gotk4_gtk3_TextBufferClass_delete_range(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextIter) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.DeleteRange == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.DeleteRange, got none")
	}

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.DeleteRange(_start, _end)
}

//export _gotk4_gtk3_TextBufferClass_end_user_action
func _gotk4_gtk3_TextBufferClass_end_user_action(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.EndUserAction == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.EndUserAction, got none")
	}

	overrides.EndUserAction()
}

//export _gotk4_gtk3_TextBufferClass_insert_child_anchor
func _gotk4_gtk3_TextBufferClass_insert_child_anchor(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextChildAnchor) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.InsertChildAnchor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.InsertChildAnchor, got none")
	}

	var _iter *TextIter          // out
	var _anchor *TextChildAnchor // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_anchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.InsertChildAnchor(_iter, _anchor)
}

//export _gotk4_gtk3_TextBufferClass_insert_pixbuf
func _gotk4_gtk3_TextBufferClass_insert_pixbuf(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GdkPixbuf) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.InsertPixbuf == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.InsertPixbuf, got none")
	}

	var _iter *TextIter           // out
	var _pixbuf *gdkpixbuf.Pixbuf // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	{
		obj := coreglib.Take(unsafe.Pointer(arg2))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	overrides.InsertPixbuf(_iter, _pixbuf)
}

//export _gotk4_gtk3_TextBufferClass_insert_text
func _gotk4_gtk3_TextBufferClass_insert_text(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.gchar, arg3 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.InsertText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.InsertText, got none")
	}

	var _pos *TextIter     // out
	var _newText string    // out
	var _newTextLength int // out

	_pos = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_newText = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_newTextLength = int(arg3)

	overrides.InsertText(_pos, _newText, _newTextLength)
}

//export _gotk4_gtk3_TextBufferClass_mark_deleted
func _gotk4_gtk3_TextBufferClass_mark_deleted(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextMark) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.MarkDeleted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.MarkDeleted, got none")
	}

	var _mark *TextMark // out

	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.MarkDeleted(_mark)
}

//export _gotk4_gtk3_TextBufferClass_mark_set
func _gotk4_gtk3_TextBufferClass_mark_set(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextMark) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.MarkSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.MarkSet, got none")
	}

	var _location *TextIter // out
	var _mark *TextMark     // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.MarkSet(_location, _mark)
}

//export _gotk4_gtk3_TextBufferClass_modified_changed
func _gotk4_gtk3_TextBufferClass_modified_changed(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.ModifiedChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.ModifiedChanged, got none")
	}

	overrides.ModifiedChanged()
}

//export _gotk4_gtk3_TextBufferClass_paste_done
func _gotk4_gtk3_TextBufferClass_paste_done(arg0 *C.GtkTextBuffer, arg1 *C.GtkClipboard) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.PasteDone == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.PasteDone, got none")
	}

	var _clipboard *Clipboard // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PasteDone(_clipboard)
}

//export _gotk4_gtk3_TextBufferClass_remove_tag
func _gotk4_gtk3_TextBufferClass_remove_tag(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.RemoveTag == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.RemoveTag, got none")
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	overrides.RemoveTag(_tag, _start, _end)
}

//export _gotk4_gtk3_TextBuffer_ConnectApplyTag
func _gotk4_gtk3_TextBuffer_ConnectApplyTag(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 C.guintptr) {
	var f func(tag *TextTag, start, end *TextIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag, start, end *TextIter))
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	f(_tag, _start, _end)
}

//export _gotk4_gtk3_TextBuffer_ConnectBeginUserAction
func _gotk4_gtk3_TextBuffer_ConnectBeginUserAction(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextBuffer_ConnectChanged
func _gotk4_gtk3_TextBuffer_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextBuffer_ConnectDeleteRange
func _gotk4_gtk3_TextBuffer_ConnectDeleteRange(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.GtkTextIter, arg3 C.guintptr) {
	var f func(start, end *TextIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(start, end *TextIter))
	}

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_start, _end)
}

//export _gotk4_gtk3_TextBuffer_ConnectEndUserAction
func _gotk4_gtk3_TextBuffer_ConnectEndUserAction(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextBuffer_ConnectInsertChildAnchor
func _gotk4_gtk3_TextBuffer_ConnectInsertChildAnchor(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.GtkTextChildAnchor, arg3 C.guintptr) {
	var f func(location *TextIter, anchor *TextChildAnchor)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, anchor *TextChildAnchor))
	}

	var _location *TextIter      // out
	var _anchor *TextChildAnchor // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_anchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(arg2)))

	f(_location, _anchor)
}

//export _gotk4_gtk3_TextBuffer_ConnectInsertPixbuf
func _gotk4_gtk3_TextBuffer_ConnectInsertPixbuf(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.GdkPixbuf, arg3 C.guintptr) {
	var f func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf))
	}

	var _location *TextIter       // out
	var _pixbuf *gdkpixbuf.Pixbuf // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	{
		obj := coreglib.Take(unsafe.Pointer(arg2))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	f(_location, _pixbuf)
}

//export _gotk4_gtk3_TextBuffer_ConnectInsertText
func _gotk4_gtk3_TextBuffer_ConnectInsertText(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.gchar, arg3 C.gint, arg4 C.guintptr) {
	var f func(location *TextIter, text string, len int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, text string, len int))
	}

	var _location *TextIter // out
	var _text string        // out
	var _len int            // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_len = int(arg3)

	f(_location, _text, _len)
}

//export _gotk4_gtk3_TextBuffer_ConnectMarkDeleted
func _gotk4_gtk3_TextBuffer_ConnectMarkDeleted(arg0 C.gpointer, arg1 *C.GtkTextMark, arg2 C.guintptr) {
	var f func(mark *TextMark)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mark *TextMark))
	}

	var _mark *TextMark // out

	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg1)))

	f(_mark)
}

//export _gotk4_gtk3_TextBuffer_ConnectMarkSet
func _gotk4_gtk3_TextBuffer_ConnectMarkSet(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.GtkTextMark, arg3 C.guintptr) {
	var f func(location *TextIter, mark *TextMark)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, mark *TextMark))
	}

	var _location *TextIter // out
	var _mark *TextMark     // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg2)))

	f(_location, _mark)
}

//export _gotk4_gtk3_TextBuffer_ConnectModifiedChanged
func _gotk4_gtk3_TextBuffer_ConnectModifiedChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextBuffer_ConnectPasteDone
func _gotk4_gtk3_TextBuffer_ConnectPasteDone(arg0 C.gpointer, arg1 *C.GtkClipboard, arg2 C.guintptr) {
	var f func(clipboard *Clipboard)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(clipboard *Clipboard))
	}

	var _clipboard *Clipboard // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(arg1)))

	f(_clipboard)
}

//export _gotk4_gtk3_TextBuffer_ConnectRemoveTag
func _gotk4_gtk3_TextBuffer_ConnectRemoveTag(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 C.guintptr) {
	var f func(tag *TextTag, start, end *TextIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag, start, end *TextIter))
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	f(_tag, _start, _end)
}

//export _gotk4_gtk3_TextTagClass_event
func _gotk4_gtk3_TextTagClass_event(arg0 *C.GtkTextTag, arg1 *C.GObject, arg2 *C.GdkEvent, arg3 *C.GtkTextIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextTagOverrides](instance0)
	if overrides.Event == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextTagOverrides.Event, got none")
	}

	var _eventObject *coreglib.Object // out
	var _event *gdk.Event             // out
	var _iter *TextIter               // out

	_eventObject = coreglib.Take(unsafe.Pointer(arg1))
	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg2)))
		v = gdk.CopyEventer(v)
		_event = v
	}
	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := overrides.Event(_eventObject, _event, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextTag_ConnectEvent
func _gotk4_gtk3_TextTag_ConnectEvent(arg0 C.gpointer, arg1 *C.GObject, arg2 C.GdkEvent, arg3 *C.GtkTextIter, arg4 C.guintptr) (cret C.gboolean) {
	var f func(object *coreglib.Object, event *gdk.Event, iter *TextIter) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object *coreglib.Object, event *gdk.Event, iter *TextIter) (ok bool))
	}

	var _object *coreglib.Object // out
	var _event *gdk.Event        // out
	var _iter *TextIter          // out

	_object = coreglib.Take(unsafe.Pointer(arg1))
	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg2))))
		v = gdk.CopyEventer(v)
		_event = v
	}
	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := f(_object, _event, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextTagTableClass_tag_added
func _gotk4_gtk3_TextTagTableClass_tag_added(arg0 *C.GtkTextTagTable, arg1 *C.GtkTextTag) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextTagTableOverrides](instance0)
	if overrides.TagAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextTagTableOverrides.TagAdded, got none")
	}

	var _tag *TextTag // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.TagAdded(_tag)
}

//export _gotk4_gtk3_TextTagTableClass_tag_changed
func _gotk4_gtk3_TextTagTableClass_tag_changed(arg0 *C.GtkTextTagTable, arg1 *C.GtkTextTag, arg2 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextTagTableOverrides](instance0)
	if overrides.TagChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextTagTableOverrides.TagChanged, got none")
	}

	var _tag *TextTag     // out
	var _sizeChanged bool // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	if arg2 != 0 {
		_sizeChanged = true
	}

	overrides.TagChanged(_tag, _sizeChanged)
}

//export _gotk4_gtk3_TextTagTableClass_tag_removed
func _gotk4_gtk3_TextTagTableClass_tag_removed(arg0 *C.GtkTextTagTable, arg1 *C.GtkTextTag) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextTagTableOverrides](instance0)
	if overrides.TagRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextTagTableOverrides.TagRemoved, got none")
	}

	var _tag *TextTag // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.TagRemoved(_tag)
}

//export _gotk4_gtk3_TextTagTable_ConnectTagAdded
func _gotk4_gtk3_TextTagTable_ConnectTagAdded(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 C.guintptr) {
	var f func(tag *TextTag)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag))
	}

	var _tag *TextTag // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))

	f(_tag)
}

//export _gotk4_gtk3_TextTagTable_ConnectTagChanged
func _gotk4_gtk3_TextTagTable_ConnectTagChanged(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 C.gboolean, arg3 C.guintptr) {
	var f func(tag *TextTag, sizeChanged bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag, sizeChanged bool))
	}

	var _tag *TextTag     // out
	var _sizeChanged bool // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	if arg2 != 0 {
		_sizeChanged = true
	}

	f(_tag, _sizeChanged)
}

//export _gotk4_gtk3_TextTagTable_ConnectTagRemoved
func _gotk4_gtk3_TextTagTable_ConnectTagRemoved(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 C.guintptr) {
	var f func(tag *TextTag)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag))
	}

	var _tag *TextTag // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))

	f(_tag)
}

//export _gotk4_gtk3_TextViewClass_backspace
func _gotk4_gtk3_TextViewClass_backspace(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.Backspace == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.Backspace, got none")
	}

	overrides.Backspace()
}

//export _gotk4_gtk3_TextViewClass_copy_clipboard
func _gotk4_gtk3_TextViewClass_copy_clipboard(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.CopyClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.CopyClipboard, got none")
	}

	overrides.CopyClipboard()
}

//export _gotk4_gtk3_TextViewClass_cut_clipboard
func _gotk4_gtk3_TextViewClass_cut_clipboard(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.CutClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.CutClipboard, got none")
	}

	overrides.CutClipboard()
}

//export _gotk4_gtk3_TextViewClass_delete_from_cursor
func _gotk4_gtk3_TextViewClass_delete_from_cursor(arg0 *C.GtkTextView, arg1 C.GtkDeleteType, arg2 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.DeleteFromCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.DeleteFromCursor, got none")
	}

	var _typ DeleteType // out
	var _count int      // out

	_typ = DeleteType(arg1)
	_count = int(arg2)

	overrides.DeleteFromCursor(_typ, _count)
}

//export _gotk4_gtk3_TextViewClass_draw_layer
func _gotk4_gtk3_TextViewClass_draw_layer(arg0 *C.GtkTextView, arg1 C.GtkTextViewLayer, arg2 *C.cairo_t) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.DrawLayer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.DrawLayer, got none")
	}

	var _layer TextViewLayer // out
	var _cr *cairo.Context   // out

	_layer = TextViewLayer(arg1)
	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg2)))
	C.cairo_reference(arg2)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	overrides.DrawLayer(_layer, _cr)
}

//export _gotk4_gtk3_TextViewClass_extend_selection
func _gotk4_gtk3_TextViewClass_extend_selection(arg0 *C.GtkTextView, arg1 C.GtkTextExtendSelection, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 *C.GtkTextIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.ExtendSelection == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.ExtendSelection, got none")
	}

	var _granularity TextExtendSelection // out
	var _location *TextIter              // out
	var _start *TextIter                 // out
	var _end *TextIter                   // out

	_granularity = TextExtendSelection(arg1)
	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	ok := overrides.ExtendSelection(_granularity, _location, _start, _end)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextViewClass_insert_at_cursor
func _gotk4_gtk3_TextViewClass_insert_at_cursor(arg0 *C.GtkTextView, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.InsertAtCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.InsertAtCursor, got none")
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.InsertAtCursor(_str)
}

//export _gotk4_gtk3_TextViewClass_insert_emoji
func _gotk4_gtk3_TextViewClass_insert_emoji(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.InsertEmoji == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.InsertEmoji, got none")
	}

	overrides.InsertEmoji()
}

//export _gotk4_gtk3_TextViewClass_move_cursor
func _gotk4_gtk3_TextViewClass_move_cursor(arg0 *C.GtkTextView, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.MoveCursor, got none")
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	overrides.MoveCursor(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_TextViewClass_paste_clipboard
func _gotk4_gtk3_TextViewClass_paste_clipboard(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.PasteClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.PasteClipboard, got none")
	}

	overrides.PasteClipboard()
}

//export _gotk4_gtk3_TextViewClass_populate_popup
func _gotk4_gtk3_TextViewClass_populate_popup(arg0 *C.GtkTextView, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.PopulatePopup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.PopulatePopup, got none")
	}

	var _popup Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_popup = rv
	}

	overrides.PopulatePopup(_popup)
}

//export _gotk4_gtk3_TextViewClass_set_anchor
func _gotk4_gtk3_TextViewClass_set_anchor(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.SetAnchor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.SetAnchor, got none")
	}

	overrides.SetAnchor()
}

//export _gotk4_gtk3_TextViewClass_toggle_overwrite
func _gotk4_gtk3_TextViewClass_toggle_overwrite(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.ToggleOverwrite == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.ToggleOverwrite, got none")
	}

	overrides.ToggleOverwrite()
}

//export _gotk4_gtk3_TextView_ConnectBackspace
func _gotk4_gtk3_TextView_ConnectBackspace(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextView_ConnectCopyClipboard
func _gotk4_gtk3_TextView_ConnectCopyClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextView_ConnectCutClipboard
func _gotk4_gtk3_TextView_ConnectCutClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextView_ConnectDeleteFromCursor
func _gotk4_gtk3_TextView_ConnectDeleteFromCursor(arg0 C.gpointer, arg1 C.GtkDeleteType, arg2 C.gint, arg3 C.guintptr) {
	var f func(typ DeleteType, count int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(typ DeleteType, count int))
	}

	var _typ DeleteType // out
	var _count int      // out

	_typ = DeleteType(arg1)
	_count = int(arg2)

	f(_typ, _count)
}

//export _gotk4_gtk3_TextView_ConnectExtendSelection
func _gotk4_gtk3_TextView_ConnectExtendSelection(arg0 C.gpointer, arg1 C.GtkTextExtendSelection, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 *C.GtkTextIter, arg5 C.guintptr) (cret C.gboolean) {
	var f func(granularity TextExtendSelection, location, start, end *TextIter) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(granularity TextExtendSelection, location, start, end *TextIter) (ok bool))
	}

	var _granularity TextExtendSelection // out
	var _location *TextIter              // out
	var _start *TextIter                 // out
	var _end *TextIter                   // out

	_granularity = TextExtendSelection(arg1)
	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	ok := f(_granularity, _location, _start, _end)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextView_ConnectInsertAtCursor
func _gotk4_gtk3_TextView_ConnectInsertAtCursor(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(str string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(str string))
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_str)
}

//export _gotk4_gtk3_TextView_ConnectInsertEmoji
func _gotk4_gtk3_TextView_ConnectInsertEmoji(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextView_ConnectMoveCursor
func _gotk4_gtk3_TextView_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean, arg4 C.guintptr) {
	var f func(step MovementStep, count int, extendSelection bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step MovementStep, count int, extendSelection bool))
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	f(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_TextView_ConnectMoveViewport
func _gotk4_gtk3_TextView_ConnectMoveViewport(arg0 C.gpointer, arg1 C.GtkScrollStep, arg2 C.gint, arg3 C.guintptr) {
	var f func(step ScrollStep, count int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step ScrollStep, count int))
	}

	var _step ScrollStep // out
	var _count int       // out

	_step = ScrollStep(arg1)
	_count = int(arg2)

	f(_step, _count)
}

//export _gotk4_gtk3_TextView_ConnectPasteClipboard
func _gotk4_gtk3_TextView_ConnectPasteClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextView_ConnectPopulatePopup
func _gotk4_gtk3_TextView_ConnectPopulatePopup(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(popup Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(popup Widgetter))
	}

	var _popup Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_popup = rv
	}

	f(_popup)
}

//export _gotk4_gtk3_TextView_ConnectPreeditChanged
func _gotk4_gtk3_TextView_ConnectPreeditChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(preedit string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(preedit string))
	}

	var _preedit string // out

	_preedit = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_preedit)
}

//export _gotk4_gtk3_TextView_ConnectSelectAll
func _gotk4_gtk3_TextView_ConnectSelectAll(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(sel bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(sel bool))
	}

	var _sel bool // out

	if arg1 != 0 {
		_sel = true
	}

	f(_sel)
}

//export _gotk4_gtk3_TextView_ConnectSetAnchor
func _gotk4_gtk3_TextView_ConnectSetAnchor(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextView_ConnectToggleCursorVisible
func _gotk4_gtk3_TextView_ConnectToggleCursorVisible(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TextView_ConnectToggleOverwrite
func _gotk4_gtk3_TextView_ConnectToggleOverwrite(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ThemingEngineClass_render_activity
func _gotk4_gtk3_ThemingEngineClass_render_activity(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderActivity == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderActivity, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderActivity(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_arrow
func _gotk4_gtk3_ThemingEngineClass_render_arrow(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderArrow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderArrow, got none")
	}

	var _cr *cairo.Context // out
	var _angle float64     // out
	var _x float64         // out
	var _y float64         // out
	var _size float64      // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_angle = float64(arg2)
	_x = float64(arg3)
	_y = float64(arg4)
	_size = float64(arg5)

	overrides.RenderArrow(_cr, _angle, _x, _y, _size)
}

//export _gotk4_gtk3_ThemingEngineClass_render_background
func _gotk4_gtk3_ThemingEngineClass_render_background(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderBackground == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderBackground, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderBackground(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_check
func _gotk4_gtk3_ThemingEngineClass_render_check(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderCheck == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderCheck, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderCheck(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_expander
func _gotk4_gtk3_ThemingEngineClass_render_expander(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderExpander == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderExpander, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderExpander(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_extension
func _gotk4_gtk3_ThemingEngineClass_render_extension(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble, arg6 C.GtkPositionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderExtension == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderExtension, got none")
	}

	var _cr *cairo.Context    // out
	var _x float64            // out
	var _y float64            // out
	var _width float64        // out
	var _height float64       // out
	var _gapSide PositionType // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)
	_gapSide = PositionType(arg6)

	overrides.RenderExtension(_cr, _x, _y, _width, _height, _gapSide)
}

//export _gotk4_gtk3_ThemingEngineClass_render_focus
func _gotk4_gtk3_ThemingEngineClass_render_focus(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderFocus, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderFocus(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_frame
func _gotk4_gtk3_ThemingEngineClass_render_frame(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderFrame, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderFrame(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_frame_gap
func _gotk4_gtk3_ThemingEngineClass_render_frame_gap(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble, arg6 C.GtkPositionType, arg7 C.gdouble, arg8 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderFrameGap == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderFrameGap, got none")
	}

	var _cr *cairo.Context    // out
	var _x float64            // out
	var _y float64            // out
	var _width float64        // out
	var _height float64       // out
	var _gapSide PositionType // out
	var _xy0Gap float64       // out
	var _xy1Gap float64       // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)
	_gapSide = PositionType(arg6)
	_xy0Gap = float64(arg7)
	_xy1Gap = float64(arg8)

	overrides.RenderFrameGap(_cr, _x, _y, _width, _height, _gapSide, _xy0Gap, _xy1Gap)
}

//export _gotk4_gtk3_ThemingEngineClass_render_handle
func _gotk4_gtk3_ThemingEngineClass_render_handle(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderHandle == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderHandle, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderHandle(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_icon
func _gotk4_gtk3_ThemingEngineClass_render_icon(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 *C.GdkPixbuf, arg3 C.gdouble, arg4 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderIcon == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderIcon, got none")
	}

	var _cr *cairo.Context        // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _x float64                // out
	var _y float64                // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	{
		obj := coreglib.Take(unsafe.Pointer(arg2))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}
	_x = float64(arg3)
	_y = float64(arg4)

	overrides.RenderIcon(_cr, _pixbuf, _x, _y)
}

//export _gotk4_gtk3_ThemingEngineClass_render_icon_surface
func _gotk4_gtk3_ThemingEngineClass_render_icon_surface(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 *C.cairo_surface_t, arg3 C.gdouble, arg4 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderIconSurface == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderIconSurface, got none")
	}

	var _cr *cairo.Context      // out
	var _surface *cairo.Surface // out
	var _x float64              // out
	var _y float64              // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(arg2)))
	C.cairo_surface_reference(arg2)
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg3)
	_y = float64(arg4)

	overrides.RenderIconSurface(_cr, _surface, _x, _y)
}

//export _gotk4_gtk3_ThemingEngineClass_render_layout
func _gotk4_gtk3_ThemingEngineClass_render_layout(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 *C.PangoLayout) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderLayout == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderLayout, got none")
	}

	var _cr *cairo.Context    // out
	var _x float64            // out
	var _y float64            // out
	var _layout *pango.Layout // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	{
		obj := coreglib.Take(unsafe.Pointer(arg4))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	overrides.RenderLayout(_cr, _x, _y, _layout)
}

//export _gotk4_gtk3_ThemingEngineClass_render_line
func _gotk4_gtk3_ThemingEngineClass_render_line(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderLine == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderLine, got none")
	}

	var _cr *cairo.Context // out
	var _x0 float64        // out
	var _y0 float64        // out
	var _x1 float64        // out
	var _y1 float64        // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x0 = float64(arg2)
	_y0 = float64(arg3)
	_x1 = float64(arg4)
	_y1 = float64(arg5)

	overrides.RenderLine(_cr, _x0, _y0, _x1, _y1)
}

//export _gotk4_gtk3_ThemingEngineClass_render_option
func _gotk4_gtk3_ThemingEngineClass_render_option(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderOption == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderOption, got none")
	}

	var _cr *cairo.Context // out
	var _x float64         // out
	var _y float64         // out
	var _width float64     // out
	var _height float64    // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)

	overrides.RenderOption(_cr, _x, _y, _width, _height)
}

//export _gotk4_gtk3_ThemingEngineClass_render_slider
func _gotk4_gtk3_ThemingEngineClass_render_slider(arg0 *C.GtkThemingEngine, arg1 *C.cairo_t, arg2 C.gdouble, arg3 C.gdouble, arg4 C.gdouble, arg5 C.gdouble, arg6 C.GtkOrientation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ThemingEngineOverrides](instance0)
	if overrides.RenderSlider == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ThemingEngineOverrides.RenderSlider, got none")
	}

	var _cr *cairo.Context       // out
	var _x float64               // out
	var _y float64               // out
	var _width float64           // out
	var _height float64          // out
	var _orientation Orientation // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})
	_x = float64(arg2)
	_y = float64(arg3)
	_width = float64(arg4)
	_height = float64(arg5)
	_orientation = Orientation(arg6)

	overrides.RenderSlider(_cr, _x, _y, _width, _height, _orientation)
}

//export _gotk4_gtk3_ToggleActionClass_toggled
func _gotk4_gtk3_ToggleActionClass_toggled(arg0 *C.GtkToggleAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToggleActionOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToggleActionOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk3_ToggleAction_ConnectToggled
func _gotk4_gtk3_ToggleAction_ConnectToggled(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ToggleButtonClass_toggled
func _gotk4_gtk3_ToggleButtonClass_toggled(arg0 *C.GtkToggleButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToggleButtonOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToggleButtonOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk3_ToggleButton_ConnectToggled
func _gotk4_gtk3_ToggleButton_ConnectToggled(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ToggleToolButtonClass_toggled
func _gotk4_gtk3_ToggleToolButtonClass_toggled(arg0 *C.GtkToggleToolButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToggleToolButtonOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToggleToolButtonOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk3_ToggleToolButton_ConnectToggled
func _gotk4_gtk3_ToggleToolButton_ConnectToggled(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ToolButtonClass_clicked
func _gotk4_gtk3_ToolButtonClass_clicked(arg0 *C.GtkToolButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolButtonOverrides](instance0)
	if overrides.Clicked == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolButtonOverrides.Clicked, got none")
	}

	overrides.Clicked()
}

//export _gotk4_gtk3_ToolButton_ConnectClicked
func _gotk4_gtk3_ToolButton_ConnectClicked(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ToolItemClass_create_menu_proxy
func _gotk4_gtk3_ToolItemClass_create_menu_proxy(arg0 *C.GtkToolItem) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolItemOverrides](instance0)
	if overrides.CreateMenuProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolItemOverrides.CreateMenuProxy, got none")
	}

	ok := overrides.CreateMenuProxy()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ToolItemClass_toolbar_reconfigured
func _gotk4_gtk3_ToolItemClass_toolbar_reconfigured(arg0 *C.GtkToolItem) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolItemOverrides](instance0)
	if overrides.ToolbarReconfigured == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolItemOverrides.ToolbarReconfigured, got none")
	}

	overrides.ToolbarReconfigured()
}

//export _gotk4_gtk3_ToolItem_ConnectCreateMenuProxy
func _gotk4_gtk3_ToolItem_ConnectCreateMenuProxy(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ToolItem_ConnectToolbarReconfigured
func _gotk4_gtk3_ToolItem_ConnectToolbarReconfigured(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_ToolbarClass_orientation_changed
func _gotk4_gtk3_ToolbarClass_orientation_changed(arg0 *C.GtkToolbar, arg1 C.GtkOrientation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolbarOverrides](instance0)
	if overrides.OrientationChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolbarOverrides.OrientationChanged, got none")
	}

	var _orientation Orientation // out

	_orientation = Orientation(arg1)

	overrides.OrientationChanged(_orientation)
}

//export _gotk4_gtk3_ToolbarClass_popup_context_menu
func _gotk4_gtk3_ToolbarClass_popup_context_menu(arg0 *C.GtkToolbar, arg1 C.gint, arg2 C.gint, arg3 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolbarOverrides](instance0)
	if overrides.PopupContextMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolbarOverrides.PopupContextMenu, got none")
	}

	var _x int            // out
	var _y int            // out
	var _buttonNumber int // out

	_x = int(arg1)
	_y = int(arg2)
	_buttonNumber = int(arg3)

	ok := overrides.PopupContextMenu(_x, _y, _buttonNumber)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_ToolbarClass_style_changed
func _gotk4_gtk3_ToolbarClass_style_changed(arg0 *C.GtkToolbar, arg1 C.GtkToolbarStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToolbarOverrides](instance0)
	if overrides.StyleChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToolbarOverrides.StyleChanged, got none")
	}

	var _style ToolbarStyle // out

	_style = ToolbarStyle(arg1)

	overrides.StyleChanged(_style)
}

//export _gotk4_gtk3_Toolbar_ConnectFocusHomeOrEnd
func _gotk4_gtk3_Toolbar_ConnectFocusHomeOrEnd(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(focusHome bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(focusHome bool) (ok bool))
	}

	var _focusHome bool // out

	if arg1 != 0 {
		_focusHome = true
	}

	ok := f(_focusHome)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Toolbar_ConnectOrientationChanged
func _gotk4_gtk3_Toolbar_ConnectOrientationChanged(arg0 C.gpointer, arg1 C.GtkOrientation, arg2 C.guintptr) {
	var f func(orientation Orientation)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(orientation Orientation))
	}

	var _orientation Orientation // out

	_orientation = Orientation(arg1)

	f(_orientation)
}

//export _gotk4_gtk3_Toolbar_ConnectPopupContextMenu
func _gotk4_gtk3_Toolbar_ConnectPopupContextMenu(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.gint, arg4 C.guintptr) (cret C.gboolean) {
	var f func(x, y, button int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y, button int) (ok bool))
	}

	var _x int      // out
	var _y int      // out
	var _button int // out

	_x = int(arg1)
	_y = int(arg2)
	_button = int(arg3)

	ok := f(_x, _y, _button)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Toolbar_ConnectStyleChanged
func _gotk4_gtk3_Toolbar_ConnectStyleChanged(arg0 C.gpointer, arg1 C.GtkToolbarStyle, arg2 C.guintptr) {
	var f func(style ToolbarStyle)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(style ToolbarStyle))
	}

	var _style ToolbarStyle // out

	_style = ToolbarStyle(arg1)

	f(_style)
}

//export _gotk4_gtk3_TreeModelFilterClass_modify
func _gotk4_gtk3_TreeModelFilterClass_modify(arg0 *C.GtkTreeModelFilter, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 *C.GValue, arg4 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeModelFilterOverrides](instance0)
	if overrides.Modify == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeModelFilterOverrides.Modify, got none")
	}

	var _childModel TreeModeller // out
	var _iter *TreeIter          // out
	var _value *coreglib.Value   // out
	var _column int              // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_childModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_value = coreglib.ValueFromNative(unsafe.Pointer(arg3))
	_column = int(arg4)

	overrides.Modify(_childModel, _iter, _value, _column)
}

//export _gotk4_gtk3_TreeModelFilterClass_visible
func _gotk4_gtk3_TreeModelFilterClass_visible(arg0 *C.GtkTreeModelFilter, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeModelFilterOverrides](instance0)
	if overrides.Visible == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeModelFilterOverrides.Visible, got none")
	}

	var _childModel TreeModeller // out
	var _iter *TreeIter          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_childModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.Visible(_childModel, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeSelectionClass_changed
func _gotk4_gtk3_TreeSelectionClass_changed(arg0 *C.GtkTreeSelection) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeSelectionOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeSelectionOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk3_TreeSelection_ConnectChanged
func _gotk4_gtk3_TreeSelection_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TreeViewClass_columns_changed
func _gotk4_gtk3_TreeViewClass_columns_changed(arg0 *C.GtkTreeView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.ColumnsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.ColumnsChanged, got none")
	}

	overrides.ColumnsChanged()
}

//export _gotk4_gtk3_TreeViewClass_cursor_changed
func _gotk4_gtk3_TreeViewClass_cursor_changed(arg0 *C.GtkTreeView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.CursorChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.CursorChanged, got none")
	}

	overrides.CursorChanged()
}

//export _gotk4_gtk3_TreeViewClass_expand_collapse_cursor_row
func _gotk4_gtk3_TreeViewClass_expand_collapse_cursor_row(arg0 *C.GtkTreeView, arg1 C.gboolean, arg2 C.gboolean, arg3 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.ExpandCollapseCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.ExpandCollapseCursorRow, got none")
	}

	var _logical bool // out
	var _expand bool  // out
	var _openAll bool // out

	if arg1 != 0 {
		_logical = true
	}
	if arg2 != 0 {
		_expand = true
	}
	if arg3 != 0 {
		_openAll = true
	}

	ok := overrides.ExpandCollapseCursorRow(_logical, _expand, _openAll)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_move_cursor
func _gotk4_gtk3_TreeViewClass_move_cursor(arg0 *C.GtkTreeView, arg1 C.GtkMovementStep, arg2 C.gint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.MoveCursor, got none")
	}

	var _step MovementStep // out
	var _count int         // out

	_step = MovementStep(arg1)
	_count = int(arg2)

	ok := overrides.MoveCursor(_step, _count)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_row_activated
func _gotk4_gtk3_TreeViewClass_row_activated(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 *C.GtkTreeViewColumn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.RowActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.RowActivated, got none")
	}

	var _path *TreePath         // out
	var _column *TreeViewColumn // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.RowActivated(_path, _column)
}

//export _gotk4_gtk3_TreeViewClass_row_collapsed
func _gotk4_gtk3_TreeViewClass_row_collapsed(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.RowCollapsed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.RowCollapsed, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RowCollapsed(_iter, _path)
}

//export _gotk4_gtk3_TreeViewClass_row_expanded
func _gotk4_gtk3_TreeViewClass_row_expanded(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.RowExpanded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.RowExpanded, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RowExpanded(_iter, _path)
}

//export _gotk4_gtk3_TreeViewClass_select_all
func _gotk4_gtk3_TreeViewClass_select_all(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.SelectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.SelectAll, got none")
	}

	ok := overrides.SelectAll()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_select_cursor_parent
func _gotk4_gtk3_TreeViewClass_select_cursor_parent(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.SelectCursorParent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.SelectCursorParent, got none")
	}

	ok := overrides.SelectCursorParent()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_select_cursor_row
func _gotk4_gtk3_TreeViewClass_select_cursor_row(arg0 *C.GtkTreeView, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.SelectCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.SelectCursorRow, got none")
	}

	var _startEditing bool // out

	if arg1 != 0 {
		_startEditing = true
	}

	ok := overrides.SelectCursorRow(_startEditing)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_start_interactive_search
func _gotk4_gtk3_TreeViewClass_start_interactive_search(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.StartInteractiveSearch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.StartInteractiveSearch, got none")
	}

	ok := overrides.StartInteractiveSearch()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_test_collapse_row
func _gotk4_gtk3_TreeViewClass_test_collapse_row(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.TestCollapseRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.TestCollapseRow, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.TestCollapseRow(_iter, _path)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_test_expand_row
func _gotk4_gtk3_TreeViewClass_test_expand_row(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.TestExpandRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.TestExpandRow, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.TestExpandRow(_iter, _path)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_toggle_cursor_row
func _gotk4_gtk3_TreeViewClass_toggle_cursor_row(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.ToggleCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.ToggleCursorRow, got none")
	}

	ok := overrides.ToggleCursorRow()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_unselect_all
func _gotk4_gtk3_TreeViewClass_unselect_all(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.UnselectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.UnselectAll, got none")
	}

	ok := overrides.UnselectAll()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectColumnsChanged
func _gotk4_gtk3_TreeView_ConnectColumnsChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TreeView_ConnectCursorChanged
func _gotk4_gtk3_TreeView_ConnectCursorChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_TreeView_ConnectExpandCollapseCursorRow
func _gotk4_gtk3_TreeView_ConnectExpandCollapseCursorRow(arg0 C.gpointer, arg1 C.gboolean, arg2 C.gboolean, arg3 C.gboolean, arg4 C.guintptr) (cret C.gboolean) {
	var f func(object, p0, p1 bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0, p1 bool) (ok bool))
	}

	var _object bool // out
	var _p0 bool     // out
	var _p1 bool     // out

	if arg1 != 0 {
		_object = true
	}
	if arg2 != 0 {
		_p0 = true
	}
	if arg3 != 0 {
		_p1 = true
	}

	ok := f(_object, _p0, _p1)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectMoveCursor
func _gotk4_gtk3_TreeView_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.guintptr) (cret C.gboolean) {
	var f func(step MovementStep, direction int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step MovementStep, direction int) (ok bool))
	}

	var _step MovementStep // out
	var _direction int     // out

	_step = MovementStep(arg1)
	_direction = int(arg2)

	ok := f(_step, _direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectRowActivated
func _gotk4_gtk3_TreeView_ConnectRowActivated(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeViewColumn, arg3 C.guintptr) {
	var f func(path *TreePath, column *TreeViewColumn)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, column *TreeViewColumn))
	}

	var _path *TreePath         // out
	var _column *TreeViewColumn // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg2)))

	f(_path, _column)
}

//export _gotk4_gtk3_TreeView_ConnectRowCollapsed
func _gotk4_gtk3_TreeView_ConnectRowCollapsed(arg0 C.gpointer, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath, arg3 C.guintptr) {
	var f func(iter *TreeIter, path *TreePath)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iter *TreeIter, path *TreePath))
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_iter, _path)
}

//export _gotk4_gtk3_TreeView_ConnectRowExpanded
func _gotk4_gtk3_TreeView_ConnectRowExpanded(arg0 C.gpointer, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath, arg3 C.guintptr) {
	var f func(iter *TreeIter, path *TreePath)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iter *TreeIter, path *TreePath))
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_iter, _path)
}

//export _gotk4_gtk3_TreeView_ConnectSelectAll
func _gotk4_gtk3_TreeView_ConnectSelectAll(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectSelectCursorParent
func _gotk4_gtk3_TreeView_ConnectSelectCursorParent(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectSelectCursorRow
func _gotk4_gtk3_TreeView_ConnectSelectCursorRow(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object bool) (ok bool))
	}

	var _object bool // out

	if arg1 != 0 {
		_object = true
	}

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectStartInteractiveSearch
func _gotk4_gtk3_TreeView_ConnectStartInteractiveSearch(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectTestCollapseRow
func _gotk4_gtk3_TreeView_ConnectTestCollapseRow(arg0 C.gpointer, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath, arg3 C.guintptr) (cret C.gboolean) {
	var f func(iter *TreeIter, path *TreePath) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iter *TreeIter, path *TreePath) (ok bool))
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := f(_iter, _path)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectTestExpandRow
func _gotk4_gtk3_TreeView_ConnectTestExpandRow(arg0 C.gpointer, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath, arg3 C.guintptr) (cret C.gboolean) {
	var f func(iter *TreeIter, path *TreePath) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iter *TreeIter, path *TreePath) (ok bool))
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := f(_iter, _path)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectToggleCursorRow
func _gotk4_gtk3_TreeView_ConnectToggleCursorRow(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeView_ConnectUnselectAll
func _gotk4_gtk3_TreeView_ConnectUnselectAll(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewColumnClass_clicked
func _gotk4_gtk3_TreeViewColumnClass_clicked(arg0 *C.GtkTreeViewColumn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewColumnOverrides](instance0)
	if overrides.Clicked == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewColumnOverrides.Clicked, got none")
	}

	overrides.Clicked()
}

//export _gotk4_gtk3_TreeViewColumn_ConnectClicked
func _gotk4_gtk3_TreeViewColumn_ConnectClicked(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_UIManagerClass_actions_changed
func _gotk4_gtk3_UIManagerClass_actions_changed(arg0 *C.GtkUIManager) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.ActionsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.ActionsChanged, got none")
	}

	overrides.ActionsChanged()
}

//export _gotk4_gtk3_UIManagerClass_add_widget
func _gotk4_gtk3_UIManagerClass_add_widget(arg0 *C.GtkUIManager, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.AddWidget == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.AddWidget, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	overrides.AddWidget(_widget)
}

//export _gotk4_gtk3_UIManagerClass_connect_proxy
func _gotk4_gtk3_UIManagerClass_connect_proxy(arg0 *C.GtkUIManager, arg1 *C.GtkAction, arg2 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.ConnectProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.ConnectProxy, got none")
	}

	var _action *Action  // out
	var _proxy Widgetter // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	overrides.ConnectProxy(_action, _proxy)
}

//export _gotk4_gtk3_UIManagerClass_disconnect_proxy
func _gotk4_gtk3_UIManagerClass_disconnect_proxy(arg0 *C.GtkUIManager, arg1 *C.GtkAction, arg2 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.DisconnectProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.DisconnectProxy, got none")
	}

	var _action *Action  // out
	var _proxy Widgetter // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	overrides.DisconnectProxy(_action, _proxy)
}

//export _gotk4_gtk3_UIManagerClass_get_action
func _gotk4_gtk3_UIManagerClass_get_action(arg0 *C.GtkUIManager, arg1 *C.gchar) (cret *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.Action == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.Action, got none")
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	action := overrides.Action(_path)

	var _ *Action

	cret = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	return cret
}

//export _gotk4_gtk3_UIManagerClass_get_widget
func _gotk4_gtk3_UIManagerClass_get_widget(arg0 *C.GtkUIManager, arg1 *C.gchar) (cret *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.Widget == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.Widget, got none")
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	widget := overrides.Widget(_path)

	var _ Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_UIManagerClass_post_activate
func _gotk4_gtk3_UIManagerClass_post_activate(arg0 *C.GtkUIManager, arg1 *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.PostActivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.PostActivate, got none")
	}

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PostActivate(_action)
}

//export _gotk4_gtk3_UIManagerClass_pre_activate
func _gotk4_gtk3_UIManagerClass_pre_activate(arg0 *C.GtkUIManager, arg1 *C.GtkAction) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[UIManagerOverrides](instance0)
	if overrides.PreActivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected UIManagerOverrides.PreActivate, got none")
	}

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PreActivate(_action)
}

//export _gotk4_gtk3_UIManager_ConnectActionsChanged
func _gotk4_gtk3_UIManager_ConnectActionsChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_UIManager_ConnectAddWidget
func _gotk4_gtk3_UIManager_ConnectAddWidget(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(widget Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter))
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	f(_widget)
}

//export _gotk4_gtk3_UIManager_ConnectConnectProxy
func _gotk4_gtk3_UIManager_ConnectConnectProxy(arg0 C.gpointer, arg1 *C.GtkAction, arg2 *C.GtkWidget, arg3 C.guintptr) {
	var f func(action *Action, proxy Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(action *Action, proxy Widgetter))
	}

	var _action *Action  // out
	var _proxy Widgetter // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	f(_action, _proxy)
}

//export _gotk4_gtk3_UIManager_ConnectDisconnectProxy
func _gotk4_gtk3_UIManager_ConnectDisconnectProxy(arg0 C.gpointer, arg1 *C.GtkAction, arg2 *C.GtkWidget, arg3 C.guintptr) {
	var f func(action *Action, proxy Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(action *Action, proxy Widgetter))
	}

	var _action *Action  // out
	var _proxy Widgetter // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	f(_action, _proxy)
}

//export _gotk4_gtk3_UIManager_ConnectPostActivate
func _gotk4_gtk3_UIManager_ConnectPostActivate(arg0 C.gpointer, arg1 *C.GtkAction, arg2 C.guintptr) {
	var f func(action *Action)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(action *Action))
	}

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))

	f(_action)
}

//export _gotk4_gtk3_UIManager_ConnectPreActivate
func _gotk4_gtk3_UIManager_ConnectPreActivate(arg0 C.gpointer, arg1 *C.GtkAction, arg2 C.guintptr) {
	var f func(action *Action)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(action *Action))
	}

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(arg1)))

	f(_action)
}

//export _gotk4_gtk3_WidgetClass_adjust_baseline_allocation
func _gotk4_gtk3_WidgetClass_adjust_baseline_allocation(arg0 *C.GtkWidget, arg1 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.AdjustBaselineAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.AdjustBaselineAllocation, got none")
	}

	var _baseline *int // out

	_baseline = (*int)(unsafe.Pointer(arg1))

	overrides.AdjustBaselineAllocation(_baseline)
}

//export _gotk4_gtk3_WidgetClass_adjust_baseline_request
func _gotk4_gtk3_WidgetClass_adjust_baseline_request(arg0 *C.GtkWidget, arg1 *C.gint, arg2 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.AdjustBaselineRequest == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.AdjustBaselineRequest, got none")
	}

	var _minimumBaseline *int // out
	var _naturalBaseline *int // out

	_minimumBaseline = (*int)(unsafe.Pointer(arg1))
	_naturalBaseline = (*int)(unsafe.Pointer(arg2))

	overrides.AdjustBaselineRequest(_minimumBaseline, _naturalBaseline)
}

//export _gotk4_gtk3_WidgetClass_adjust_size_allocation
func _gotk4_gtk3_WidgetClass_adjust_size_allocation(arg0 *C.GtkWidget, arg1 C.GtkOrientation, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint, arg5 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.AdjustSizeAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.AdjustSizeAllocation, got none")
	}

	var _orientation Orientation // out
	var _minimumSize *int        // out
	var _naturalSize *int        // out
	var _allocatedPos *int       // out
	var _allocatedSize *int      // out

	_orientation = Orientation(arg1)
	_minimumSize = (*int)(unsafe.Pointer(arg2))
	_naturalSize = (*int)(unsafe.Pointer(arg3))
	_allocatedPos = (*int)(unsafe.Pointer(arg4))
	_allocatedSize = (*int)(unsafe.Pointer(arg5))

	overrides.AdjustSizeAllocation(_orientation, _minimumSize, _naturalSize, _allocatedPos, _allocatedSize)
}

//export _gotk4_gtk3_WidgetClass_adjust_size_request
func _gotk4_gtk3_WidgetClass_adjust_size_request(arg0 *C.GtkWidget, arg1 C.GtkOrientation, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.AdjustSizeRequest == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.AdjustSizeRequest, got none")
	}

	var _orientation Orientation // out
	var _minimumSize *int        // out
	var _naturalSize *int        // out

	_orientation = Orientation(arg1)
	_minimumSize = (*int)(unsafe.Pointer(arg2))
	_naturalSize = (*int)(unsafe.Pointer(arg3))

	overrides.AdjustSizeRequest(_orientation, _minimumSize, _naturalSize)
}

//export _gotk4_gtk3_WidgetClass_button_press_event
func _gotk4_gtk3_WidgetClass_button_press_event(arg0 *C.GtkWidget, arg1 *C.GdkEventButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ButtonPressEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ButtonPressEvent, got none")
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ButtonPressEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_button_release_event
func _gotk4_gtk3_WidgetClass_button_release_event(arg0 *C.GtkWidget, arg1 *C.GdkEventButton) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ButtonReleaseEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ButtonReleaseEvent, got none")
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ButtonReleaseEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_can_activate_accel
func _gotk4_gtk3_WidgetClass_can_activate_accel(arg0 *C.GtkWidget, arg1 C.guint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.CanActivateAccel == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.CanActivateAccel, got none")
	}

	var _signalId uint // out

	_signalId = uint(arg1)

	ok := overrides.CanActivateAccel(_signalId)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_composited_changed
func _gotk4_gtk3_WidgetClass_composited_changed(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.CompositedChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.CompositedChanged, got none")
	}

	overrides.CompositedChanged()
}

//export _gotk4_gtk3_WidgetClass_configure_event
func _gotk4_gtk3_WidgetClass_configure_event(arg0 *C.GtkWidget, arg1 *C.GdkEventConfigure) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ConfigureEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ConfigureEvent, got none")
	}

	var _event *gdk.EventConfigure // out

	_event = (*gdk.EventConfigure)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ConfigureEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_damage_event
func _gotk4_gtk3_WidgetClass_damage_event(arg0 *C.GtkWidget, arg1 *C.GdkEventExpose) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DamageEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DamageEvent, got none")
	}

	var _event *gdk.EventExpose // out

	_event = (*gdk.EventExpose)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DamageEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_delete_event
func _gotk4_gtk3_WidgetClass_delete_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DeleteEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DeleteEvent, got none")
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DeleteEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_destroy
func _gotk4_gtk3_WidgetClass_destroy(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Destroy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Destroy, got none")
	}

	overrides.Destroy()
}

//export _gotk4_gtk3_WidgetClass_destroy_event
func _gotk4_gtk3_WidgetClass_destroy_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DestroyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DestroyEvent, got none")
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DestroyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_direction_changed
func _gotk4_gtk3_WidgetClass_direction_changed(arg0 *C.GtkWidget, arg1 C.GtkTextDirection) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DirectionChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DirectionChanged, got none")
	}

	var _previousDirection TextDirection // out

	_previousDirection = TextDirection(arg1)

	overrides.DirectionChanged(_previousDirection)
}

//export _gotk4_gtk3_WidgetClass_drag_begin
func _gotk4_gtk3_WidgetClass_drag_begin(arg0 *C.GtkWidget, arg1 *C.GdkDragContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragBegin == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragBegin, got none")
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	overrides.DragBegin(_context)
}

//export _gotk4_gtk3_WidgetClass_drag_data_delete
func _gotk4_gtk3_WidgetClass_drag_data_delete(arg0 *C.GtkWidget, arg1 *C.GdkDragContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragDataDelete == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragDataDelete, got none")
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	overrides.DragDataDelete(_context)
}

//export _gotk4_gtk3_WidgetClass_drag_data_get
func _gotk4_gtk3_WidgetClass_drag_data_get(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 *C.GtkSelectionData, arg3 C.guint, arg4 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragDataGet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragDataGet, got none")
	}

	var _context *gdk.DragContext     // out
	var _selectionData *SelectionData // out
	var _info uint                    // out
	var _time_ uint                   // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_info = uint(arg3)
	_time_ = uint(arg4)

	overrides.DragDataGet(_context, _selectionData, _info, _time_)
}

//export _gotk4_gtk3_WidgetClass_drag_data_received
func _gotk4_gtk3_WidgetClass_drag_data_received(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 *C.GtkSelectionData, arg5 C.guint, arg6 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragDataReceived == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragDataReceived, got none")
	}

	var _context *gdk.DragContext     // out
	var _x int                        // out
	var _y int                        // out
	var _selectionData *SelectionData // out
	var _info uint                    // out
	var _time_ uint                   // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_info = uint(arg5)
	_time_ = uint(arg6)

	overrides.DragDataReceived(_context, _x, _y, _selectionData, _info, _time_)
}

//export _gotk4_gtk3_WidgetClass_drag_drop
func _gotk4_gtk3_WidgetClass_drag_drop(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragDrop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragDrop, got none")
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _time_ uint               // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_time_ = uint(arg4)

	ok := overrides.DragDrop(_context, _x, _y, _time_)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_drag_end
func _gotk4_gtk3_WidgetClass_drag_end(arg0 *C.GtkWidget, arg1 *C.GdkDragContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragEnd == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragEnd, got none")
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	overrides.DragEnd(_context)
}

//export _gotk4_gtk3_WidgetClass_drag_failed
func _gotk4_gtk3_WidgetClass_drag_failed(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.GtkDragResult) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragFailed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragFailed, got none")
	}

	var _context *gdk.DragContext // out
	var _result DragResult        // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_result = DragResult(arg2)

	ok := overrides.DragFailed(_context, _result)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_drag_leave
func _gotk4_gtk3_WidgetClass_drag_leave(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragLeave == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragLeave, got none")
	}

	var _context *gdk.DragContext // out
	var _time_ uint               // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_time_ = uint(arg2)

	overrides.DragLeave(_context, _time_)
}

//export _gotk4_gtk3_WidgetClass_drag_motion
func _gotk4_gtk3_WidgetClass_drag_motion(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DragMotion == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DragMotion, got none")
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _time_ uint               // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_time_ = uint(arg4)

	ok := overrides.DragMotion(_context, _x, _y, _time_)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_draw
func _gotk4_gtk3_WidgetClass_draw(arg0 *C.GtkWidget, arg1 *C.cairo_t) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Draw == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Draw, got none")
	}

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	ok := overrides.Draw(_cr)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_enter_notify_event
func _gotk4_gtk3_WidgetClass_enter_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventCrossing) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.EnterNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.EnterNotifyEvent, got none")
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.EnterNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_event
func _gotk4_gtk3_WidgetClass_event(arg0 *C.GtkWidget, arg1 *C.GdkEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Event == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Event, got none")
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := overrides.Event(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_focus
func _gotk4_gtk3_WidgetClass_focus(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Focus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Focus, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := overrides.Focus(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_focus_in_event
func _gotk4_gtk3_WidgetClass_focus_in_event(arg0 *C.GtkWidget, arg1 *C.GdkEventFocus) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.FocusInEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.FocusInEvent, got none")
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.FocusInEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_focus_out_event
func _gotk4_gtk3_WidgetClass_focus_out_event(arg0 *C.GtkWidget, arg1 *C.GdkEventFocus) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.FocusOutEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.FocusOutEvent, got none")
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.FocusOutEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_get_accessible
func _gotk4_gtk3_WidgetClass_get_accessible(arg0 *C.GtkWidget) (cret *C.AtkObject) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Accessible == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Accessible, got none")
	}

	object := overrides.Accessible()

	var _ *atk.AtkObject

	cret = (*C.AtkObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	return cret
}

//export _gotk4_gtk3_WidgetClass_get_preferred_height
func _gotk4_gtk3_WidgetClass_get_preferred_height(arg0 *C.GtkWidget, arg1 *C.gint, arg2 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredHeight, got none")
	}

	minimumHeight, naturalHeight := overrides.PreferredHeight()

	var _ int
	var _ int

	*arg1 = C.gint(minimumHeight)
	*arg2 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width
func _gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width(arg0 *C.GtkWidget, arg1 C.gint, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint, arg5 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredHeightAndBaselineForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredHeightAndBaselineForWidth, got none")
	}

	var _width int // out

	_width = int(arg1)

	minimumHeight, naturalHeight, minimumBaseline, naturalBaseline := overrides.PreferredHeightAndBaselineForWidth(_width)

	var _ int
	var _ int
	var _ int
	var _ int

	*arg2 = C.gint(minimumHeight)
	*arg3 = C.gint(naturalHeight)
	*arg4 = C.gint(minimumBaseline)
	*arg5 = C.gint(naturalBaseline)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_height_for_width
func _gotk4_gtk3_WidgetClass_get_preferred_height_for_width(arg0 *C.GtkWidget, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredHeightForWidth, got none")
	}

	var _width int // out

	_width = int(arg1)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_width)

	var _ int
	var _ int

	*arg2 = C.gint(minimumHeight)
	*arg3 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_width
func _gotk4_gtk3_WidgetClass_get_preferred_width(arg0 *C.GtkWidget, arg1 *C.gint, arg2 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredWidth, got none")
	}

	minimumWidth, naturalWidth := overrides.PreferredWidth()

	var _ int
	var _ int

	*arg1 = C.gint(minimumWidth)
	*arg2 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_width_for_height
func _gotk4_gtk3_WidgetClass_get_preferred_width_for_height(arg0 *C.GtkWidget, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PreferredWidthForHeight, got none")
	}

	var _height int // out

	_height = int(arg1)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_height)

	var _ int
	var _ int

	*arg2 = C.gint(minimumWidth)
	*arg3 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_WidgetClass_get_request_mode
func _gotk4_gtk3_WidgetClass_get_request_mode(arg0 *C.GtkWidget) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.RequestMode, got none")
	}

	sizeRequestMode := overrides.RequestMode()

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk3_WidgetClass_grab_broken_event
func _gotk4_gtk3_WidgetClass_grab_broken_event(arg0 *C.GtkWidget, arg1 *C.GdkEventGrabBroken) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.GrabBrokenEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.GrabBrokenEvent, got none")
	}

	var _event *gdk.EventGrabBroken // out

	_event = (*gdk.EventGrabBroken)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.GrabBrokenEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_grab_focus
func _gotk4_gtk3_WidgetClass_grab_focus(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.GrabFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.GrabFocus, got none")
	}

	overrides.GrabFocus()
}

//export _gotk4_gtk3_WidgetClass_grab_notify
func _gotk4_gtk3_WidgetClass_grab_notify(arg0 *C.GtkWidget, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.GrabNotify == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.GrabNotify, got none")
	}

	var _wasGrabbed bool // out

	if arg1 != 0 {
		_wasGrabbed = true
	}

	overrides.GrabNotify(_wasGrabbed)
}

//export _gotk4_gtk3_WidgetClass_hide
func _gotk4_gtk3_WidgetClass_hide(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Hide == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Hide, got none")
	}

	overrides.Hide()
}

//export _gotk4_gtk3_WidgetClass_hierarchy_changed
func _gotk4_gtk3_WidgetClass_hierarchy_changed(arg0 *C.GtkWidget, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.HierarchyChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.HierarchyChanged, got none")
	}

	var _previousToplevel Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_previousToplevel = rv
	}

	overrides.HierarchyChanged(_previousToplevel)
}

//export _gotk4_gtk3_WidgetClass_key_press_event
func _gotk4_gtk3_WidgetClass_key_press_event(arg0 *C.GtkWidget, arg1 *C.GdkEventKey) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.KeyPressEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.KeyPressEvent, got none")
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.KeyPressEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_key_release_event
func _gotk4_gtk3_WidgetClass_key_release_event(arg0 *C.GtkWidget, arg1 *C.GdkEventKey) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.KeyReleaseEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.KeyReleaseEvent, got none")
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.KeyReleaseEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_keynav_failed
func _gotk4_gtk3_WidgetClass_keynav_failed(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.KeynavFailed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.KeynavFailed, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := overrides.KeynavFailed(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_leave_notify_event
func _gotk4_gtk3_WidgetClass_leave_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventCrossing) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.LeaveNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.LeaveNotifyEvent, got none")
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.LeaveNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_map
func _gotk4_gtk3_WidgetClass_map(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Map == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Map, got none")
	}

	overrides.Map()
}

//export _gotk4_gtk3_WidgetClass_map_event
func _gotk4_gtk3_WidgetClass_map_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MapEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MapEvent, got none")
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.MapEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_mnemonic_activate
func _gotk4_gtk3_WidgetClass_mnemonic_activate(arg0 *C.GtkWidget, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MnemonicActivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MnemonicActivate, got none")
	}

	var _groupCycling bool // out

	if arg1 != 0 {
		_groupCycling = true
	}

	ok := overrides.MnemonicActivate(_groupCycling)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_motion_notify_event
func _gotk4_gtk3_WidgetClass_motion_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventMotion) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MotionNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MotionNotifyEvent, got none")
	}

	var _event *gdk.EventMotion // out

	_event = (*gdk.EventMotion)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.MotionNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_move_focus
func _gotk4_gtk3_WidgetClass_move_focus(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MoveFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MoveFocus, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	overrides.MoveFocus(_direction)
}

//export _gotk4_gtk3_WidgetClass_parent_set
func _gotk4_gtk3_WidgetClass_parent_set(arg0 *C.GtkWidget, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ParentSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ParentSet, got none")
	}

	var _previousParent Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_previousParent = rv
	}

	overrides.ParentSet(_previousParent)
}

//export _gotk4_gtk3_WidgetClass_popup_menu
func _gotk4_gtk3_WidgetClass_popup_menu(arg0 *C.GtkWidget) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PopupMenu == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PopupMenu, got none")
	}

	ok := overrides.PopupMenu()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_property_notify_event
func _gotk4_gtk3_WidgetClass_property_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventProperty) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.PropertyNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.PropertyNotifyEvent, got none")
	}

	var _event *gdk.EventProperty // out

	_event = (*gdk.EventProperty)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.PropertyNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_proximity_in_event
func _gotk4_gtk3_WidgetClass_proximity_in_event(arg0 *C.GtkWidget, arg1 *C.GdkEventProximity) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ProximityInEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ProximityInEvent, got none")
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ProximityInEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_proximity_out_event
func _gotk4_gtk3_WidgetClass_proximity_out_event(arg0 *C.GtkWidget, arg1 *C.GdkEventProximity) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ProximityOutEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ProximityOutEvent, got none")
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ProximityOutEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_query_tooltip
func _gotk4_gtk3_WidgetClass_query_tooltip(arg0 *C.GtkWidget, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.GtkTooltip) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.QueryTooltip == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.QueryTooltip, got none")
	}

	var _x int                // out
	var _y int                // out
	var _keyboardTooltip bool // out
	var _tooltip *Tooltip     // out

	_x = int(arg1)
	_y = int(arg2)
	if arg3 != 0 {
		_keyboardTooltip = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := overrides.QueryTooltip(_x, _y, _keyboardTooltip, _tooltip)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_queue_draw_region
func _gotk4_gtk3_WidgetClass_queue_draw_region(arg0 *C.GtkWidget, arg1 *C.cairo_region_t) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.QueueDrawRegion == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.QueueDrawRegion, got none")
	}

	var _region *cairo.Region // out

	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(arg1)}
		_region = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	C.cairo_region_reference(arg1)
	runtime.SetFinalizer(_region, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
	})

	overrides.QueueDrawRegion(_region)
}

//export _gotk4_gtk3_WidgetClass_realize
func _gotk4_gtk3_WidgetClass_realize(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Realize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Realize, got none")
	}

	overrides.Realize()
}

//export _gotk4_gtk3_WidgetClass_screen_changed
func _gotk4_gtk3_WidgetClass_screen_changed(arg0 *C.GtkWidget, arg1 *C.GdkScreen) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ScreenChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ScreenChanged, got none")
	}

	var _previousScreen *gdk.Screen // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_previousScreen = &gdk.Screen{
			Object: obj,
		}
	}

	overrides.ScreenChanged(_previousScreen)
}

//export _gotk4_gtk3_WidgetClass_scroll_event
func _gotk4_gtk3_WidgetClass_scroll_event(arg0 *C.GtkWidget, arg1 *C.GdkEventScroll) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ScrollEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ScrollEvent, got none")
	}

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ScrollEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_selection_clear_event
func _gotk4_gtk3_WidgetClass_selection_clear_event(arg0 *C.GtkWidget, arg1 *C.GdkEventSelection) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionClearEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionClearEvent, got none")
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SelectionClearEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_selection_get
func _gotk4_gtk3_WidgetClass_selection_get(arg0 *C.GtkWidget, arg1 *C.GtkSelectionData, arg2 C.guint, arg3 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionGet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionGet, got none")
	}

	var _selectionData *SelectionData // out
	var _info uint                    // out
	var _time_ uint                   // out

	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_info = uint(arg2)
	_time_ = uint(arg3)

	overrides.SelectionGet(_selectionData, _info, _time_)
}

//export _gotk4_gtk3_WidgetClass_selection_notify_event
func _gotk4_gtk3_WidgetClass_selection_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventSelection) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionNotifyEvent, got none")
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SelectionNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_selection_received
func _gotk4_gtk3_WidgetClass_selection_received(arg0 *C.GtkWidget, arg1 *C.GtkSelectionData, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionReceived == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionReceived, got none")
	}

	var _selectionData *SelectionData // out
	var _time_ uint                   // out

	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_time_ = uint(arg2)

	overrides.SelectionReceived(_selectionData, _time_)
}

//export _gotk4_gtk3_WidgetClass_selection_request_event
func _gotk4_gtk3_WidgetClass_selection_request_event(arg0 *C.GtkWidget, arg1 *C.GdkEventSelection) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SelectionRequestEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SelectionRequestEvent, got none")
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SelectionRequestEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_show
func _gotk4_gtk3_WidgetClass_show(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Show == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Show, got none")
	}

	overrides.Show()
}

//export _gotk4_gtk3_WidgetClass_show_all
func _gotk4_gtk3_WidgetClass_show_all(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ShowAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ShowAll, got none")
	}

	overrides.ShowAll()
}

//export _gotk4_gtk3_WidgetClass_show_help
func _gotk4_gtk3_WidgetClass_show_help(arg0 *C.GtkWidget, arg1 C.GtkWidgetHelpType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.ShowHelp == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.ShowHelp, got none")
	}

	var _helpType WidgetHelpType // out

	_helpType = WidgetHelpType(arg1)

	ok := overrides.ShowHelp(_helpType)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_size_allocate
func _gotk4_gtk3_WidgetClass_size_allocate(arg0 *C.GtkWidget, arg1 *C.GtkAllocation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SizeAllocate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SizeAllocate, got none")
	}

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	overrides.SizeAllocate(_allocation)
}

//export _gotk4_gtk3_WidgetClass_state_changed
func _gotk4_gtk3_WidgetClass_state_changed(arg0 *C.GtkWidget, arg1 C.GtkStateType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.StateChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.StateChanged, got none")
	}

	var _previousState StateType // out

	_previousState = StateType(arg1)

	overrides.StateChanged(_previousState)
}

//export _gotk4_gtk3_WidgetClass_state_flags_changed
func _gotk4_gtk3_WidgetClass_state_flags_changed(arg0 *C.GtkWidget, arg1 C.GtkStateFlags) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.StateFlagsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.StateFlagsChanged, got none")
	}

	var _previousStateFlags StateFlags // out

	_previousStateFlags = StateFlags(arg1)

	overrides.StateFlagsChanged(_previousStateFlags)
}

//export _gotk4_gtk3_WidgetClass_style_set
func _gotk4_gtk3_WidgetClass_style_set(arg0 *C.GtkWidget, arg1 *C.GtkStyle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.StyleSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.StyleSet, got none")
	}

	var _previousStyle *Style // out

	_previousStyle = wrapStyle(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.StyleSet(_previousStyle)
}

//export _gotk4_gtk3_WidgetClass_style_updated
func _gotk4_gtk3_WidgetClass_style_updated(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.StyleUpdated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.StyleUpdated, got none")
	}

	overrides.StyleUpdated()
}

//export _gotk4_gtk3_WidgetClass_touch_event
func _gotk4_gtk3_WidgetClass_touch_event(arg0 *C.GtkWidget, arg1 *C.GdkEventTouch) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.TouchEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.TouchEvent, got none")
	}

	var _event *gdk.EventTouch // out

	_event = (*gdk.EventTouch)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.TouchEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_unmap
func _gotk4_gtk3_WidgetClass_unmap(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Unmap == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Unmap, got none")
	}

	overrides.Unmap()
}

//export _gotk4_gtk3_WidgetClass_unmap_event
func _gotk4_gtk3_WidgetClass_unmap_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.UnmapEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.UnmapEvent, got none")
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.UnmapEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_unrealize
func _gotk4_gtk3_WidgetClass_unrealize(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Unrealize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Unrealize, got none")
	}

	overrides.Unrealize()
}

//export _gotk4_gtk3_WidgetClass_visibility_notify_event
func _gotk4_gtk3_WidgetClass_visibility_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventVisibility) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.VisibilityNotifyEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.VisibilityNotifyEvent, got none")
	}

	var _event *gdk.EventVisibility // out

	_event = (*gdk.EventVisibility)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.VisibilityNotifyEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_window_state_event
func _gotk4_gtk3_WidgetClass_window_state_event(arg0 *C.GtkWidget, arg1 *C.GdkEventWindowState) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.WindowStateEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.WindowStateEvent, got none")
	}

	var _event *gdk.EventWindowState // out

	_event = (*gdk.EventWindowState)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.WindowStateEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectAccelClosuresChanged
func _gotk4_gtk3_Widget_ConnectAccelClosuresChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectButtonPressEvent
func _gotk4_gtk3_Widget_ConnectButtonPressEvent(arg0 C.gpointer, arg1 *C.GdkEventButton, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectButtonReleaseEvent
func _gotk4_gtk3_Widget_ConnectButtonReleaseEvent(arg0 C.gpointer, arg1 *C.GdkEventButton, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectCanActivateAccel
func _gotk4_gtk3_Widget_ConnectCanActivateAccel(arg0 C.gpointer, arg1 C.guint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(signalId uint) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(signalId uint) (ok bool))
	}

	var _signalId uint // out

	_signalId = uint(arg1)

	ok := f(_signalId)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectCompositedChanged
func _gotk4_gtk3_Widget_ConnectCompositedChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectConfigureEvent
func _gotk4_gtk3_Widget_ConnectConfigureEvent(arg0 C.gpointer, arg1 *C.GdkEventConfigure, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventConfigure) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventConfigure) (ok bool))
	}

	var _event *gdk.EventConfigure // out

	_event = (*gdk.EventConfigure)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDamageEvent
func _gotk4_gtk3_Widget_ConnectDamageEvent(arg0 C.gpointer, arg1 *C.GdkEventExpose, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventExpose) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventExpose) (ok bool))
	}

	var _event *gdk.EventExpose // out

	_event = (*gdk.EventExpose)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDeleteEvent
func _gotk4_gtk3_Widget_ConnectDeleteEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event) (ok bool))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDestroy
func _gotk4_gtk3_Widget_ConnectDestroy(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectDestroyEvent
func _gotk4_gtk3_Widget_ConnectDestroyEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event) (ok bool))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDirectionChanged
func _gotk4_gtk3_Widget_ConnectDirectionChanged(arg0 C.gpointer, arg1 C.GtkTextDirection, arg2 C.guintptr) {
	var f func(previousDirection TextDirection)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousDirection TextDirection))
	}

	var _previousDirection TextDirection // out

	_previousDirection = TextDirection(arg1)

	f(_previousDirection)
}

//export _gotk4_gtk3_Widget_ConnectDragBegin
func _gotk4_gtk3_Widget_ConnectDragBegin(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guintptr) {
	var f func(context *gdk.DragContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext))
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	f(_context)
}

//export _gotk4_gtk3_Widget_ConnectDragDataDelete
func _gotk4_gtk3_Widget_ConnectDragDataDelete(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guintptr) {
	var f func(context *gdk.DragContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext))
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	f(_context)
}

//export _gotk4_gtk3_Widget_ConnectDragDataGet
func _gotk4_gtk3_Widget_ConnectDragDataGet(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 *C.GtkSelectionData, arg3 C.guint, arg4 C.guint, arg5 C.guintptr) {
	var f func(context *gdk.DragContext, data *SelectionData, info, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, data *SelectionData, info, time uint))
	}

	var _context *gdk.DragContext // out
	var _data *SelectionData      // out
	var _info uint                // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_info = uint(arg3)
	_time = uint(arg4)

	f(_context, _data, _info, _time)
}

//export _gotk4_gtk3_Widget_ConnectDragDataReceived
func _gotk4_gtk3_Widget_ConnectDragDataReceived(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 *C.GtkSelectionData, arg5 C.guint, arg6 C.guint, arg7 C.guintptr) {
	var f func(context *gdk.DragContext, x, y int, data *SelectionData, info, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg7))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, x, y int, data *SelectionData, info, time uint))
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _data *SelectionData      // out
	var _info uint                // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_info = uint(arg5)
	_time = uint(arg6)

	f(_context, _x, _y, _data, _info, _time)
}

//export _gotk4_gtk3_Widget_ConnectDragDrop
func _gotk4_gtk3_Widget_ConnectDragDrop(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint, arg5 C.guintptr) (cret C.gboolean) {
	var f func(context *gdk.DragContext, x, y int, time uint) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, x, y int, time uint) (ok bool))
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_time = uint(arg4)

	ok := f(_context, _x, _y, _time)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDragEnd
func _gotk4_gtk3_Widget_ConnectDragEnd(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guintptr) {
	var f func(context *gdk.DragContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext))
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	f(_context)
}

//export _gotk4_gtk3_Widget_ConnectDragFailed
func _gotk4_gtk3_Widget_ConnectDragFailed(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.GtkDragResult, arg3 C.guintptr) (cret C.gboolean) {
	var f func(context *gdk.DragContext, result DragResult) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, result DragResult) (ok bool))
	}

	var _context *gdk.DragContext // out
	var _result DragResult        // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_result = DragResult(arg2)

	ok := f(_context, _result)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDragLeave
func _gotk4_gtk3_Widget_ConnectDragLeave(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guint, arg3 C.guintptr) {
	var f func(context *gdk.DragContext, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, time uint))
	}

	var _context *gdk.DragContext // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_time = uint(arg2)

	f(_context, _time)
}

//export _gotk4_gtk3_Widget_ConnectDragMotion
func _gotk4_gtk3_Widget_ConnectDragMotion(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint, arg5 C.guintptr) (cret C.gboolean) {
	var f func(context *gdk.DragContext, x, y int, time uint) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, x, y int, time uint) (ok bool))
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_time = uint(arg4)

	ok := f(_context, _x, _y, _time)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDraw
func _gotk4_gtk3_Widget_ConnectDraw(arg0 C.gpointer, arg1 *C.cairo_t, arg2 C.guintptr) (cret C.gboolean) {
	var f func(cr *cairo.Context) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(cr *cairo.Context) (ok bool))
	}

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	ok := f(_cr)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectEnterNotifyEvent
func _gotk4_gtk3_Widget_ConnectEnterNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventCrossing, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventCrossing) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventCrossing) (ok bool))
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectEvent
func _gotk4_gtk3_Widget_ConnectEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event) (ok bool))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectEventAfter
func _gotk4_gtk3_Widget_ConnectEventAfter(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) {
	var f func(event *gdk.Event)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	f(_event)
}

//export _gotk4_gtk3_Widget_ConnectFocus
func _gotk4_gtk3_Widget_ConnectFocus(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(direction DirectionType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType) (ok bool))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := f(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectFocusInEvent
func _gotk4_gtk3_Widget_ConnectFocusInEvent(arg0 C.gpointer, arg1 *C.GdkEventFocus, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventFocus) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventFocus) (ok bool))
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectFocusOutEvent
func _gotk4_gtk3_Widget_ConnectFocusOutEvent(arg0 C.gpointer, arg1 *C.GdkEventFocus, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventFocus) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventFocus) (ok bool))
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectGrabBrokenEvent
func _gotk4_gtk3_Widget_ConnectGrabBrokenEvent(arg0 C.gpointer, arg1 *C.GdkEventGrabBroken, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventGrabBroken) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventGrabBroken) (ok bool))
	}

	var _event *gdk.EventGrabBroken // out

	_event = (*gdk.EventGrabBroken)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectGrabFocus
func _gotk4_gtk3_Widget_ConnectGrabFocus(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectGrabNotify
func _gotk4_gtk3_Widget_ConnectGrabNotify(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(wasGrabbed bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(wasGrabbed bool))
	}

	var _wasGrabbed bool // out

	if arg1 != 0 {
		_wasGrabbed = true
	}

	f(_wasGrabbed)
}

//export _gotk4_gtk3_Widget_ConnectHide
func _gotk4_gtk3_Widget_ConnectHide(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectHierarchyChanged
func _gotk4_gtk3_Widget_ConnectHierarchyChanged(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(previousToplevel Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousToplevel Widgetter))
	}

	var _previousToplevel Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_previousToplevel = rv
		}
	}

	f(_previousToplevel)
}

//export _gotk4_gtk3_Widget_ConnectKeyPressEvent
func _gotk4_gtk3_Widget_ConnectKeyPressEvent(arg0 C.gpointer, arg1 *C.GdkEventKey, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventKey) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventKey) (ok bool))
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectKeyReleaseEvent
func _gotk4_gtk3_Widget_ConnectKeyReleaseEvent(arg0 C.gpointer, arg1 *C.GdkEventKey, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventKey) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventKey) (ok bool))
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectKeynavFailed
func _gotk4_gtk3_Widget_ConnectKeynavFailed(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(direction DirectionType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType) (ok bool))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := f(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectLeaveNotifyEvent
func _gotk4_gtk3_Widget_ConnectLeaveNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventCrossing, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventCrossing) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventCrossing) (ok bool))
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectMap
func _gotk4_gtk3_Widget_ConnectMap(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectMapEvent
func _gotk4_gtk3_Widget_ConnectMapEvent(arg0 C.gpointer, arg1 *C.GdkEventAny, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventAny) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventAny) (ok bool))
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectMnemonicActivate
func _gotk4_gtk3_Widget_ConnectMnemonicActivate(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(groupCycling bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(groupCycling bool) (ok bool))
	}

	var _groupCycling bool // out

	if arg1 != 0 {
		_groupCycling = true
	}

	ok := f(_groupCycling)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectMotionNotifyEvent
func _gotk4_gtk3_Widget_ConnectMotionNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventMotion, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventMotion) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventMotion) (ok bool))
	}

	var _event *gdk.EventMotion // out

	_event = (*gdk.EventMotion)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectMoveFocus
func _gotk4_gtk3_Widget_ConnectMoveFocus(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(direction DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	f(_direction)
}

//export _gotk4_gtk3_Widget_ConnectParentSet
func _gotk4_gtk3_Widget_ConnectParentSet(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(oldParent Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(oldParent Widgetter))
	}

	var _oldParent Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_oldParent = rv
		}
	}

	f(_oldParent)
}

//export _gotk4_gtk3_Widget_ConnectPopupMenu
func _gotk4_gtk3_Widget_ConnectPopupMenu(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectPropertyNotifyEvent
func _gotk4_gtk3_Widget_ConnectPropertyNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventProperty, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventProperty) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventProperty) (ok bool))
	}

	var _event *gdk.EventProperty // out

	_event = (*gdk.EventProperty)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectProximityInEvent
func _gotk4_gtk3_Widget_ConnectProximityInEvent(arg0 C.gpointer, arg1 *C.GdkEventProximity, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventProximity) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventProximity) (ok bool))
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectProximityOutEvent
func _gotk4_gtk3_Widget_ConnectProximityOutEvent(arg0 C.gpointer, arg1 *C.GdkEventProximity, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventProximity) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventProximity) (ok bool))
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectQueryTooltip
func _gotk4_gtk3_Widget_ConnectQueryTooltip(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.GtkTooltip, arg5 C.guintptr) (cret C.gboolean) {
	var f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool))
	}

	var _x int             // out
	var _y int             // out
	var _keyboardMode bool // out
	var _tooltip *Tooltip  // out

	_x = int(arg1)
	_y = int(arg2)
	if arg3 != 0 {
		_keyboardMode = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := f(_x, _y, _keyboardMode, _tooltip)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectRealize
func _gotk4_gtk3_Widget_ConnectRealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectScreenChanged
func _gotk4_gtk3_Widget_ConnectScreenChanged(arg0 C.gpointer, arg1 *C.GdkScreen, arg2 C.guintptr) {
	var f func(previousScreen *gdk.Screen)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousScreen *gdk.Screen))
	}

	var _previousScreen *gdk.Screen // out

	if arg1 != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(arg1))
			_previousScreen = &gdk.Screen{
				Object: obj,
			}
		}
	}

	f(_previousScreen)
}

//export _gotk4_gtk3_Widget_ConnectScrollEvent
func _gotk4_gtk3_Widget_ConnectScrollEvent(arg0 C.gpointer, arg1 *C.GdkEventScroll, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventScroll) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventScroll) (ok bool))
	}

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectSelectionClearEvent
func _gotk4_gtk3_Widget_ConnectSelectionClearEvent(arg0 C.gpointer, arg1 *C.GdkEventSelection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventSelection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventSelection) (ok bool))
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectSelectionGet
func _gotk4_gtk3_Widget_ConnectSelectionGet(arg0 C.gpointer, arg1 *C.GtkSelectionData, arg2 C.guint, arg3 C.guint, arg4 C.guintptr) {
	var f func(data *SelectionData, info, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(data *SelectionData, info, time uint))
	}

	var _data *SelectionData // out
	var _info uint           // out
	var _time uint           // out

	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_info = uint(arg2)
	_time = uint(arg3)

	f(_data, _info, _time)
}

//export _gotk4_gtk3_Widget_ConnectSelectionNotifyEvent
func _gotk4_gtk3_Widget_ConnectSelectionNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventSelection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventSelection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventSelection) (ok bool))
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectSelectionReceived
func _gotk4_gtk3_Widget_ConnectSelectionReceived(arg0 C.gpointer, arg1 *C.GtkSelectionData, arg2 C.guint, arg3 C.guintptr) {
	var f func(data *SelectionData, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(data *SelectionData, time uint))
	}

	var _data *SelectionData // out
	var _time uint           // out

	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_time = uint(arg2)

	f(_data, _time)
}

//export _gotk4_gtk3_Widget_ConnectSelectionRequestEvent
func _gotk4_gtk3_Widget_ConnectSelectionRequestEvent(arg0 C.gpointer, arg1 *C.GdkEventSelection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventSelection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventSelection) (ok bool))
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectShow
func _gotk4_gtk3_Widget_ConnectShow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectShowHelp
func _gotk4_gtk3_Widget_ConnectShowHelp(arg0 C.gpointer, arg1 C.GtkWidgetHelpType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(helpType WidgetHelpType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(helpType WidgetHelpType) (ok bool))
	}

	var _helpType WidgetHelpType // out

	_helpType = WidgetHelpType(arg1)

	ok := f(_helpType)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectSizeAllocate
func _gotk4_gtk3_Widget_ConnectSizeAllocate(arg0 C.gpointer, arg1 *C.GtkAllocation, arg2 C.guintptr) {
	var f func(allocation *Allocation)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(allocation *Allocation))
	}

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	f(_allocation)
}

//export _gotk4_gtk3_Widget_ConnectStateChanged
func _gotk4_gtk3_Widget_ConnectStateChanged(arg0 C.gpointer, arg1 C.GtkStateType, arg2 C.guintptr) {
	var f func(state StateType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(state StateType))
	}

	var _state StateType // out

	_state = StateType(arg1)

	f(_state)
}

//export _gotk4_gtk3_Widget_ConnectStateFlagsChanged
func _gotk4_gtk3_Widget_ConnectStateFlagsChanged(arg0 C.gpointer, arg1 C.GtkStateFlags, arg2 C.guintptr) {
	var f func(flags StateFlags)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(flags StateFlags))
	}

	var _flags StateFlags // out

	_flags = StateFlags(arg1)

	f(_flags)
}

//export _gotk4_gtk3_Widget_ConnectStyleSet
func _gotk4_gtk3_Widget_ConnectStyleSet(arg0 C.gpointer, arg1 *C.GtkStyle, arg2 C.guintptr) {
	var f func(previousStyle *Style)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousStyle *Style))
	}

	var _previousStyle *Style // out

	if arg1 != nil {
		_previousStyle = wrapStyle(coreglib.Take(unsafe.Pointer(arg1)))
	}

	f(_previousStyle)
}

//export _gotk4_gtk3_Widget_ConnectStyleUpdated
func _gotk4_gtk3_Widget_ConnectStyleUpdated(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectTouchEvent
func _gotk4_gtk3_Widget_ConnectTouchEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object *gdk.Event) (ok bool))
	}

	var _object *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_object = v
	}

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectUnmap
func _gotk4_gtk3_Widget_ConnectUnmap(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectUnmapEvent
func _gotk4_gtk3_Widget_ConnectUnmapEvent(arg0 C.gpointer, arg1 *C.GdkEventAny, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventAny) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventAny) (ok bool))
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectUnrealize
func _gotk4_gtk3_Widget_ConnectUnrealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent
func _gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventVisibility, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventVisibility) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventVisibility) (ok bool))
	}

	var _event *gdk.EventVisibility // out

	_event = (*gdk.EventVisibility)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectWindowStateEvent
func _gotk4_gtk3_Widget_ConnectWindowStateEvent(arg0 C.gpointer, arg1 *C.GdkEventWindowState, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventWindowState) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventWindowState) (ok bool))
	}

	var _event *gdk.EventWindowState // out

	_event = (*gdk.EventWindowState)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WindowClass_activate_default
func _gotk4_gtk3_WindowClass_activate_default(arg0 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.ActivateDefault == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.ActivateDefault, got none")
	}

	overrides.ActivateDefault()
}

//export _gotk4_gtk3_WindowClass_activate_focus
func _gotk4_gtk3_WindowClass_activate_focus(arg0 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.ActivateFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.ActivateFocus, got none")
	}

	overrides.ActivateFocus()
}

//export _gotk4_gtk3_WindowClass_enable_debugging
func _gotk4_gtk3_WindowClass_enable_debugging(arg0 *C.GtkWindow, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.EnableDebugging == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.EnableDebugging, got none")
	}

	var _toggle bool // out

	if arg1 != 0 {
		_toggle = true
	}

	ok := overrides.EnableDebugging(_toggle)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WindowClass_keys_changed
func _gotk4_gtk3_WindowClass_keys_changed(arg0 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.KeysChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.KeysChanged, got none")
	}

	overrides.KeysChanged()
}

//export _gotk4_gtk3_WindowClass_set_focus
func _gotk4_gtk3_WindowClass_set_focus(arg0 *C.GtkWindow, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.SetFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.SetFocus, got none")
	}

	var _focus Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_focus = rv
		}
	}

	overrides.SetFocus(_focus)
}

//export _gotk4_gtk3_Window_ConnectActivateDefault
func _gotk4_gtk3_Window_ConnectActivateDefault(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Window_ConnectActivateFocus
func _gotk4_gtk3_Window_ConnectActivateFocus(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Window_ConnectEnableDebugging
func _gotk4_gtk3_Window_ConnectEnableDebugging(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(toggle bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(toggle bool) (ok bool))
	}

	var _toggle bool // out

	if arg1 != 0 {
		_toggle = true
	}

	ok := f(_toggle)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Window_ConnectKeysChanged
func _gotk4_gtk3_Window_ConnectKeysChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Window_ConnectSetFocus
func _gotk4_gtk3_Window_ConnectSetFocus(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(widget Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter))
	}

	var _widget Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	f(_widget)
}
