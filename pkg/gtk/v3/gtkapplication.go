// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_application_get_type()), F: marshalApplication},
	})
}

// Application is a class that handles many important aspects of a GTK+
// application in a convenient fashion, without enforcing a one-size-fits-all
// application model.
//
// Currently, GtkApplication handles GTK+ initialization, application
// uniqueness, session management, provides some basic scriptability and desktop
// shell integration by exporting actions and menus and manages a list of
// toplevel windows whose life-cycle is automatically tied to the life-cycle of
// your application.
//
// While GtkApplication works fine with plain Windows, it is recommended to use
// it together with ApplicationWindow.
//
// When GDK threads are enabled, GtkApplication will acquire the GDK lock when
// invoking actions that arrive from other processes. The GDK lock is not
// touched for local action invocations. In order to have actions invoked in a
// predictable context it is therefore recommended that the GDK lock be held
// while invoking actions locally with g_action_group_activate_action(). The
// same applies to actions associated with ApplicationWindow and to the
// “activate” and “open” #GApplication methods.
//
//
// Automatic resources
//
// Application will automatically load menus from the Builder resource located
// at "gtk/menus.ui", relative to the application's resource base path (see
// g_application_set_resource_base_path()). The menu with the ID "app-menu" is
// taken as the application's app menu and the menu with the ID "menubar" is
// taken as the application's menubar. Additional menus (most interesting
// submenus) can be named and accessed via gtk_application_get_menu_by_id()
// which allows for dynamic population of a part of the menu structure.
//
// If the resources "gtk/menus-appmenu.ui" or "gtk/menus-traditional.ui" are
// present then these files will be used in preference, depending on the value
// of gtk_application_prefers_app_menu(). If the resource "gtk/menus-common.ui"
// is present it will be loaded as well. This is useful for storing items that
// are referenced from both "gtk/menus-appmenu.ui" and
// "gtk/menus-traditional.ui".
//
// It is also possible to provide the menus manually using
// gtk_application_set_app_menu() and gtk_application_set_menubar().
//
// Application will also automatically setup an icon search path for the default
// icon theme by appending "icons" to the resource base path. This allows your
// application to easily store its icons as resources. See
// gtk_icon_theme_add_resource_path() for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// ShortcutsWindow with ID "help_overlay" then GtkApplication associates an
// instance of this shortcuts window with each ApplicationWindow and sets up
// keyboard accelerators (Control-F1 and Control-?) to open it. To create a menu
// item that displays the shortcuts window, associate the item with the action
// win.show-help-overlay.
//
//
// A simple application
//
// A simple example
// (https://git.gnome.org/browse/gtk+/tree/examples/bp/bloatpad.c)
//
// GtkApplication optionally registers with a session manager of the users
// session (if you set the Application:register-session property) and offers
// various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// gtk_application_inhibit() function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
//
// See Also
//
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK+: Basics
// (https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.3)
type Application interface {
	gio.Application
	gio.ActionGroup
	gio.ActionMap

	// AddAccelerator installs an accelerator that will cause the named action
	// to be activated when the key combination specificed by @accelerator is
	// pressed.
	//
	// @accelerator must be a string that can be parsed by
	// gtk_accelerator_parse(), e.g. "<Primary>q" or “<Control><Alt>p”.
	//
	// @action_name must be the name of an action as it would be used in the app
	// menu, i.e. actions that have been added to the application are referred
	// to with an “app.” prefix, and window-specific actions with a “win.”
	// prefix.
	//
	// GtkApplication also extracts accelerators out of “accel” attributes in
	// the Models passed to gtk_application_set_app_menu() and
	// gtk_application_set_menubar(), which is usually more convenient than
	// calling this function for each accelerator.
	AddAccelerator(a Application, accelerator string, actionName string, parameter *glib.Variant)
	// AddWindow adds a window to @application.
	//
	// This call can only happen after the @application has started; typically,
	// you should add new application windows in response to the emission of the
	// #GApplication::activate signal.
	//
	// This call is equivalent to setting the Window:application property of
	// @window to @application.
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it
	// with gtk_application_remove_window().
	//
	// GTK+ will keep the @application running as long as it has any windows.
	AddWindow(a Application, window Window)
	// AccelsForAction gets the accelerators that are currently associated with
	// the given action.
	AccelsForAction(a Application, detailedActionName string)
	// ActionsForAccel returns the list of actions (possibly empty) that @accel
	// maps to. Each item in the list is a detailed action name in the usual
	// form.
	//
	// This might be useful to discover if an accel already exists in order to
	// prevent installation of a conflicting accelerator (from an accelerator
	// editor or a plugin system, for example). Note that having more than one
	// action per accelerator may not be a bad thing and might make sense in
	// cases where the actions never appear in the same context.
	//
	// In case there are no actions for a given accelerator, an empty array is
	// returned. nil is never returned.
	//
	// It is a programmer error to pass an invalid accelerator string. If you
	// are unsure, check it with gtk_accelerator_parse() first.
	ActionsForAccel(a Application, accel string)
	// ActiveWindow gets the “active” window for the application.
	//
	// The active window is the one that was most recently focused (within the
	// application). This window may not have the focus at the moment if another
	// application has it — this is just the most recently-focused window within
	// this application.
	ActiveWindow(a Application)
	// AppMenu returns the menu model that has been set with
	// gtk_application_set_app_menu().
	AppMenu(a Application)
	// MenuByID gets a menu from automatically loaded resources. See [Automatic
	// resources][automatic-resources] for more information.
	MenuByID(a Application, id string)
	// Menubar returns the menu model that has been set with
	// gtk_application_set_menubar().
	Menubar(a Application)
	// WindowByID returns the ApplicationWindow with the given ID.
	//
	// The ID of a ApplicationWindow can be retrieved with
	// gtk_application_window_get_id().
	WindowByID(a Application, id uint)
	// Windows gets a list of the Windows associated with @application.
	//
	// The list is sorted by most recently focused window, such that the first
	// element is the currently focused window. (Useful for choosing a parent
	// for a transient window.)
	//
	// The list that is returned should not be modified in any way. It will only
	// remain valid until the next focus change or window creation or deletion.
	Windows(a Application)
	// Inhibit: inform the session manager that certain types of actions should
	// be inhibited. This is not guaranteed to work on all platforms and for all
	// types of actions.
	//
	// Applications should invoke this method when they begin an operation that
	// should not be interrupted, such as creating a CD or DVD. The types of
	// actions that may be blocked are specified by the @flags parameter. When
	// the application completes the operation it should call
	// gtk_application_uninhibit() to remove the inhibitor. Note that an
	// application can have multiple inhibitors, and all of them must be
	// individually removed. Inhibitors are also cleared when the application
	// exits.
	//
	// Applications should not expect that they will always be able to block the
	// action. In most cases, users will be given the option to force the action
	// to take place.
	//
	// Reasons should be short and to the point.
	//
	// If @window is given, the session manager may point the user to this
	// window to find out more about why the action is inhibited.
	Inhibit(a Application, window Window, flags ApplicationInhibitFlags, reason string)
	// IsInhibited determines if any of the actions specified in @flags are
	// currently inhibited (possibly by another application).
	//
	// Note that this information may not be available (for example when the
	// application is running in a sandbox).
	IsInhibited(a Application, flags ApplicationInhibitFlags) bool
	// ListActionDescriptions lists the detailed action names which have
	// associated accelerators. See gtk_application_set_accels_for_action().
	ListActionDescriptions(a Application)
	// PrefersAppMenu determines if the desktop environment in which the
	// application is running would prefer an application menu be shown.
	//
	// If this function returns true then the application should call
	// gtk_application_set_app_menu() with the contents of an application menu,
	// which will be shown by the desktop environment. If it returns false then
	// you should consider using an alternate approach, such as a menubar.
	//
	// The value returned by this function is purely advisory and you are free
	// to ignore it. If you call gtk_application_set_app_menu() even if the
	// desktop environment doesn't support app menus, then a fallback will be
	// provided.
	//
	// Applications are similarly free not to set an app menu even if the
	// desktop environment wants to show one. In that case, a fallback will also
	// be created by the desktop environment (GNOME, for example, uses a menu
	// with only a "Quit" item in it).
	//
	// The value returned by this function never changes. Once it returns a
	// particular value, it is guaranteed to always return the same value.
	//
	// You may only call this function after the application has been registered
	// and after the base startup handler has run. You're most likely to want to
	// use this from your own startup handler. It may also make sense to consult
	// this function while constructing UI (in activate, open or an action
	// activation handler) in order to determine if you should show a gear menu
	// or not.
	//
	// This function will return false on Mac OS and a default app menu will be
	// created automatically with the "usual" contents of that menu typical to
	// most Mac OS applications. If you call gtk_application_set_app_menu()
	// anyway, then this menu will be replaced with your own.
	PrefersAppMenu(a Application) bool
	// RemoveAccelerator removes an accelerator that has been previously added
	// with gtk_application_add_accelerator().
	RemoveAccelerator(a Application, actionName string, parameter *glib.Variant)
	// RemoveWindow: remove a window from @application.
	//
	// If @window belongs to @application then this call is equivalent to
	// setting the Window:application property of @window to nil.
	//
	// The application may stop running as a result of a call to this function.
	RemoveWindow(a Application, window Window)
	// SetAccelsForAction sets zero or more keyboard accelerators that will
	// trigger the given action. The first item in @accels will be the primary
	// accelerator, which may be displayed in the UI.
	//
	// To remove all accelerators for an action, use an empty, zero-terminated
	// array for @accels.
	//
	// For the @detailed_action_name, see g_action_parse_detailed_name() and
	// g_action_print_detailed_name().
	SetAccelsForAction(a Application, detailedActionName string, accels []string)
	// SetAppMenu sets or unsets the application menu for @application.
	//
	// This can only be done in the primary instance of the application, after
	// it has been registered. #GApplication::startup is a good place to call
	// this.
	//
	// The application menu is a single menu containing items that typically
	// impact the application as a whole, rather than acting on a specific
	// window or document. For example, you would expect to see “Preferences” or
	// “Quit” in an application menu, but not “Save” or “Print”.
	//
	// If supported, the application menu will be rendered by the desktop
	// environment.
	//
	// Use the base Map interface to add actions, to respond to the user
	// selecting these menu items.
	SetAppMenu(a Application, appMenu gio.MenuModel)
	// SetMenubar sets or unsets the menubar for windows of @application.
	//
	// This is a menubar in the traditional sense.
	//
	// This can only be done in the primary instance of the application, after
	// it has been registered. #GApplication::startup is a good place to call
	// this.
	//
	// Depending on the desktop environment, this may appear at the top of each
	// window, or at the top of the screen. In some environments, if both the
	// application menu and the menubar are set, the application menu will be
	// presented as if it were the first item of the menubar. Other environments
	// treat the two as completely separate — for example, the application menu
	// may be rendered by the desktop shell while the menubar (if set) remains
	// in each individual window.
	//
	// Use the base Map interface to add actions, to respond to the user
	// selecting these menu items.
	SetMenubar(a Application, menubar gio.MenuModel)
	// Uninhibit removes an inhibitor that has been established with
	// gtk_application_inhibit(). Inhibitors are also cleared when the
	// application exits.
	Uninhibit(a Application, cookie uint)
}

// application implements the Application interface.
type application struct {
	gio.Application
	gio.ActionGroup
	gio.ActionMap
}

var _ Application = (*application)(nil)

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return Application{
		gio.Application: gio.WrapApplication(obj),
		gio.ActionGroup: gio.WrapActionGroup(obj),
		gio.ActionMap:   gio.WrapActionMap(obj),
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

// NewApplication constructs a class Application.
func NewApplication(applicationID string, flags gio.ApplicationFlags) {
	var arg1 *C.gchar
	var arg2 C.GApplicationFlags

	arg1 = (*C.gchar)(C.CString(applicationID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GApplicationFlags)(flags)

	C.gtk_application_new(arg1, arg2)
}

// AddAccelerator installs an accelerator that will cause the named action
// to be activated when the key combination specificed by @accelerator is
// pressed.
//
// @accelerator must be a string that can be parsed by
// gtk_accelerator_parse(), e.g. "<Primary>q" or “<Control><Alt>p”.
//
// @action_name must be the name of an action as it would be used in the app
// menu, i.e. actions that have been added to the application are referred
// to with an “app.” prefix, and window-specific actions with a “win.”
// prefix.
//
// GtkApplication also extracts accelerators out of “accel” attributes in
// the Models passed to gtk_application_set_app_menu() and
// gtk_application_set_menubar(), which is usually more convenient than
// calling this function for each accelerator.
func (a application) AddAccelerator(a Application, accelerator string, actionName string, parameter *glib.Variant) {
	var arg0 *C.GtkApplication
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.GVariant

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

	C.gtk_application_add_accelerator(arg0, arg1, arg2, arg3)
}

// AddWindow adds a window to @application.
//
// This call can only happen after the @application has started; typically,
// you should add new application windows in response to the emission of the
// #GApplication::activate signal.
//
// This call is equivalent to setting the Window:application property of
// @window to @application.
//
// Normally, the connection between the application and the window will
// remain until the window is destroyed, but you can explicitly remove it
// with gtk_application_remove_window().
//
// GTK+ will keep the @application running as long as it has any windows.
func (a application) AddWindow(a Application, window Window) {
	var arg0 *C.GtkApplication
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_add_window(arg0, arg1)
}

// AccelsForAction gets the accelerators that are currently associated with
// the given action.
func (a application) AccelsForAction(a Application, detailedActionName string) {
	var arg0 *C.GtkApplication
	var arg1 *C.gchar

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.gchar)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_application_get_accels_for_action(arg0, arg1)
}

// ActionsForAccel returns the list of actions (possibly empty) that @accel
// maps to. Each item in the list is a detailed action name in the usual
// form.
//
// This might be useful to discover if an accel already exists in order to
// prevent installation of a conflicting accelerator (from an accelerator
// editor or a plugin system, for example). Note that having more than one
// action per accelerator may not be a bad thing and might make sense in
// cases where the actions never appear in the same context.
//
// In case there are no actions for a given accelerator, an empty array is
// returned. nil is never returned.
//
// It is a programmer error to pass an invalid accelerator string. If you
// are unsure, check it with gtk_accelerator_parse() first.
func (a application) ActionsForAccel(a Application, accel string) {
	var arg0 *C.GtkApplication
	var arg1 *C.gchar

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.gchar)(C.CString(accel))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_application_get_actions_for_accel(arg0, arg1)
}

// ActiveWindow gets the “active” window for the application.
//
// The active window is the one that was most recently focused (within the
// application). This window may not have the focus at the moment if another
// application has it — this is just the most recently-focused window within
// this application.
func (a application) ActiveWindow(a Application) {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	C.gtk_application_get_active_window(arg0)
}

// AppMenu returns the menu model that has been set with
// gtk_application_set_app_menu().
func (a application) AppMenu(a Application) {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	C.gtk_application_get_app_menu(arg0)
}

// MenuByID gets a menu from automatically loaded resources. See [Automatic
// resources][automatic-resources] for more information.
func (a application) MenuByID(a Application, id string) {
	var arg0 *C.GtkApplication
	var arg1 *C.gchar

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_application_get_menu_by_id(arg0, arg1)
}

// Menubar returns the menu model that has been set with
// gtk_application_set_menubar().
func (a application) Menubar(a Application) {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	C.gtk_application_get_menubar(arg0)
}

// WindowByID returns the ApplicationWindow with the given ID.
//
// The ID of a ApplicationWindow can be retrieved with
// gtk_application_window_get_id().
func (a application) WindowByID(a Application, id uint) {
	var arg0 *C.GtkApplication
	var arg1 C.guint

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = C.guint(id)

	C.gtk_application_get_window_by_id(arg0, arg1)
}

// Windows gets a list of the Windows associated with @application.
//
// The list is sorted by most recently focused window, such that the first
// element is the currently focused window. (Useful for choosing a parent
// for a transient window.)
//
// The list that is returned should not be modified in any way. It will only
// remain valid until the next focus change or window creation or deletion.
func (a application) Windows(a Application) {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	C.gtk_application_get_windows(arg0)
}

// Inhibit: inform the session manager that certain types of actions should
// be inhibited. This is not guaranteed to work on all platforms and for all
// types of actions.
//
// Applications should invoke this method when they begin an operation that
// should not be interrupted, such as creating a CD or DVD. The types of
// actions that may be blocked are specified by the @flags parameter. When
// the application completes the operation it should call
// gtk_application_uninhibit() to remove the inhibitor. Note that an
// application can have multiple inhibitors, and all of them must be
// individually removed. Inhibitors are also cleared when the application
// exits.
//
// Applications should not expect that they will always be able to block the
// action. In most cases, users will be given the option to force the action
// to take place.
//
// Reasons should be short and to the point.
//
// If @window is given, the session manager may point the user to this
// window to find out more about why the action is inhibited.
func (a application) Inhibit(a Application, window Window, flags ApplicationInhibitFlags, reason string) {
	var arg0 *C.GtkApplication
	var arg1 *C.GtkWindow
	var arg2 C.GtkApplicationInhibitFlags
	var arg3 *C.gchar

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	arg2 = (C.GtkApplicationInhibitFlags)(flags)
	arg3 = (*C.gchar)(C.CString(reason))
	defer C.free(unsafe.Pointer(arg3))

	C.gtk_application_inhibit(arg0, arg1, arg2, arg3)
}

// IsInhibited determines if any of the actions specified in @flags are
// currently inhibited (possibly by another application).
//
// Note that this information may not be available (for example when the
// application is running in a sandbox).
func (a application) IsInhibited(a Application, flags ApplicationInhibitFlags) bool {
	var arg0 *C.GtkApplication
	var arg1 C.GtkApplicationInhibitFlags

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (C.GtkApplicationInhibitFlags)(flags)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_application_is_inhibited(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ListActionDescriptions lists the detailed action names which have
// associated accelerators. See gtk_application_set_accels_for_action().
func (a application) ListActionDescriptions(a Application) {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	C.gtk_application_list_action_descriptions(arg0)
}

// PrefersAppMenu determines if the desktop environment in which the
// application is running would prefer an application menu be shown.
//
// If this function returns true then the application should call
// gtk_application_set_app_menu() with the contents of an application menu,
// which will be shown by the desktop environment. If it returns false then
// you should consider using an alternate approach, such as a menubar.
//
// The value returned by this function is purely advisory and you are free
// to ignore it. If you call gtk_application_set_app_menu() even if the
// desktop environment doesn't support app menus, then a fallback will be
// provided.
//
// Applications are similarly free not to set an app menu even if the
// desktop environment wants to show one. In that case, a fallback will also
// be created by the desktop environment (GNOME, for example, uses a menu
// with only a "Quit" item in it).
//
// The value returned by this function never changes. Once it returns a
// particular value, it is guaranteed to always return the same value.
//
// You may only call this function after the application has been registered
// and after the base startup handler has run. You're most likely to want to
// use this from your own startup handler. It may also make sense to consult
// this function while constructing UI (in activate, open or an action
// activation handler) in order to determine if you should show a gear menu
// or not.
//
// This function will return false on Mac OS and a default app menu will be
// created automatically with the "usual" contents of that menu typical to
// most Mac OS applications. If you call gtk_application_set_app_menu()
// anyway, then this menu will be replaced with your own.
func (a application) PrefersAppMenu(a Application) bool {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_application_prefers_app_menu(arg0)

	if cret {
		ok = true
	}

	return ok
}

// RemoveAccelerator removes an accelerator that has been previously added
// with gtk_application_add_accelerator().
func (a application) RemoveAccelerator(a Application, actionName string, parameter *glib.Variant) {
	var arg0 *C.GtkApplication
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

	C.gtk_application_remove_accelerator(arg0, arg1, arg2)
}

// RemoveWindow: remove a window from @application.
//
// If @window belongs to @application then this call is equivalent to
// setting the Window:application property of @window to nil.
//
// The application may stop running as a result of a call to this function.
func (a application) RemoveWindow(a Application, window Window) {
	var arg0 *C.GtkApplication
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_remove_window(arg0, arg1)
}

// SetAccelsForAction sets zero or more keyboard accelerators that will
// trigger the given action. The first item in @accels will be the primary
// accelerator, which may be displayed in the UI.
//
// To remove all accelerators for an action, use an empty, zero-terminated
// array for @accels.
//
// For the @detailed_action_name, see g_action_parse_detailed_name() and
// g_action_print_detailed_name().
func (a application) SetAccelsForAction(a Application, detailedActionName string, accels []string) {
	var arg0 *C.GtkApplication
	var arg1 *C.gchar
	var arg2 **C.gchar

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.gchar)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.malloc(len(accels) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg2))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg2), int(len(accels)))

		for i := range accels {
			out[i] = (*C.gchar)(C.CString(accels[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_application_set_accels_for_action(arg0, arg1, arg2)
}

// SetAppMenu sets or unsets the application menu for @application.
//
// This can only be done in the primary instance of the application, after
// it has been registered. #GApplication::startup is a good place to call
// this.
//
// The application menu is a single menu containing items that typically
// impact the application as a whole, rather than acting on a specific
// window or document. For example, you would expect to see “Preferences” or
// “Quit” in an application menu, but not “Save” or “Print”.
//
// If supported, the application menu will be rendered by the desktop
// environment.
//
// Use the base Map interface to add actions, to respond to the user
// selecting these menu items.
func (a application) SetAppMenu(a Application, appMenu gio.MenuModel) {
	var arg0 *C.GtkApplication
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(appMenu.Native()))

	C.gtk_application_set_app_menu(arg0, arg1)
}

// SetMenubar sets or unsets the menubar for windows of @application.
//
// This is a menubar in the traditional sense.
//
// This can only be done in the primary instance of the application, after
// it has been registered. #GApplication::startup is a good place to call
// this.
//
// Depending on the desktop environment, this may appear at the top of each
// window, or at the top of the screen. In some environments, if both the
// application menu and the menubar are set, the application menu will be
// presented as if it were the first item of the menubar. Other environments
// treat the two as completely separate — for example, the application menu
// may be rendered by the desktop shell while the menubar (if set) remains
// in each individual window.
//
// Use the base Map interface to add actions, to respond to the user
// selecting these menu items.
func (a application) SetMenubar(a Application, menubar gio.MenuModel) {
	var arg0 *C.GtkApplication
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(menubar.Native()))

	C.gtk_application_set_menubar(arg0, arg1)
}

// Uninhibit removes an inhibitor that has been established with
// gtk_application_inhibit(). Inhibitors are also cleared when the
// application exits.
func (a application) Uninhibit(a Application, cookie uint) {
	var arg0 *C.GtkApplication
	var arg1 C.guint

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = C.guint(cookie)

	C.gtk_application_uninhibit(arg0, arg1)
}
