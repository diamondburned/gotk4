// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_drag_result_get_type()), F: marshalDragResult},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_im_preedit_style_get_type()), F: marshalIMPreeditStyle},
		{T: externglib.Type(C.gtk_im_status_style_get_type()), F: marshalIMStatusStyle},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_menu_direction_type_get_type()), F: marshalMenuDirectionType},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_pack_direction_get_type()), F: marshalPackDirection},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_popover_constraint_get_type()), F: marshalPopoverConstraint},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_relief_style_get_type()), F: marshalReliefStyle},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shadow_type_get_type()), F: marshalShadowType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_state_type_get_type()), F: marshalStateType},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_toolbar_style_get_type()), F: marshalToolbarStyle},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
		{T: externglib.Type(C.gtk_junction_sides_get_type()), F: marshalJunctionSides},
		{T: externglib.Type(C.gtk_region_flags_get_type()), F: marshalRegionFlags},
		{T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
	})
}

// Align controls how a widget deals with extra space in a single (x or y)
// dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:expand flag inside a Box,
// then the widget might get extra space. If you have for example a 16x16 icon
// inside a 32x32 space, the icon could be scaled and stretched, it could be
// centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support for it is optional for containers and widgets, and
// it is only supported for vertical alignment. When its not supported by a
// child or a container it is treated as GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = iota
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd
	// AlignCenter natural width of widget inside the allocation
	AlignCenter
	// AlignBaseline: align the widget according to the baseline. Since 3.10.
	AlignBaseline
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for Align.
func (a Align) String() string {
	switch a {
	case AlignFill:
		return "Fill"
	case AlignStart:
		return "Start"
	case AlignEnd:
		return "End"
	case AlignCenter:
		return "Center"
	case AlignBaseline:
		return "Baseline"
	default:
		return fmt.Sprintf("Align(%d)", a)
	}
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowUp represents an upward pointing arrow.
	ArrowUp ArrowType = iota
	// ArrowDown represents a downward pointing arrow.
	ArrowDown
	// ArrowLeft represents a left pointing arrow.
	ArrowLeft
	// ArrowRight represents a right pointing arrow.
	ArrowRight
	// ArrowNone: no arrow. Since 2.10.
	ArrowNone
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for ArrowType.
func (a ArrowType) String() string {
	switch a {
	case ArrowUp:
		return "Up"
	case ArrowDown:
		return "Down"
	case ArrowLeft:
		return "Left"
	case ArrowRight:
		return "Right"
	case ArrowNone:
		return "None"
	default:
		return fmt.Sprintf("ArrowType(%d)", a)
	}
}

// BaselinePosition: whenever a container has some form of natural row it may
// align children in that row along a common typographical baseline. If the
// amount of verical space in the row is taller than the total requested height
// of the baseline-aligned children then it can use a BaselinePosition to select
// where to put the baseline inside the extra availible space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = iota
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for BaselinePosition.
func (b BaselinePosition) String() string {
	switch b {
	case BaselinePositionTop:
		return "Top"
	case BaselinePositionCenter:
		return "Center"
	case BaselinePositionBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("BaselinePosition(%d)", b)
	}
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = iota
	// BorderStyleSolid: single line segment
	BorderStyleSolid
	// BorderStyleInset looks as if the content is sunken into the canvas
	BorderStyleInset
	// BorderStyleOutset looks as if the content is coming out of the canvas
	BorderStyleOutset
	// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE
	BorderStyleHidden
	// BorderStyleDotted series of round dots
	BorderStyleDotted
	// BorderStyleDashed series of square-ended dashes
	BorderStyleDashed
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble
	// BorderStyleGroove looks as if it were carved in the canvas
	BorderStyleGroove
	// BorderStyleRidge looks as if it were coming out of the canvas
	BorderStyleRidge
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for BorderStyle.
func (b BorderStyle) String() string {
	switch b {
	case BorderStyleNone:
		return "None"
	case BorderStyleSolid:
		return "Solid"
	case BorderStyleInset:
		return "Inset"
	case BorderStyleOutset:
		return "Outset"
	case BorderStyleHidden:
		return "Hidden"
	case BorderStyleDotted:
		return "Dotted"
	case BorderStyleDashed:
		return "Dashed"
	case BorderStyleDouble:
		return "Double"
	case BorderStyleGroove:
		return "Groove"
	case BorderStyleRidge:
		return "Ridge"
	default:
		return fmt.Sprintf("BorderStyle(%d)", b)
	}
}

// DeleteType: see also: Entry::delete-from-cursor.
type DeleteType int

const (
	// DeleteChars: delete characters.
	DeleteChars DeleteType = iota
	// DeleteWordEnds: delete only the portion of the word to the left/right of
	// cursor if we’re in the middle of a word.
	DeleteWordEnds
	// DeleteWords: delete words.
	DeleteWords
	// DeleteDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteDisplayLines
	// DeleteDisplayLineEnds: delete only the portion of the display-line to the
	// left/right of cursor.
	DeleteDisplayLineEnds
	// DeleteParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteParagraphEnds
	// DeleteParagraphs: delete entire line. Like C-k in pico.
	DeleteParagraphs
	// DeleteWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteWhitespace
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for DeleteType.
func (d DeleteType) String() string {
	switch d {
	case DeleteChars:
		return "Chars"
	case DeleteWordEnds:
		return "WordEnds"
	case DeleteWords:
		return "Words"
	case DeleteDisplayLines:
		return "DisplayLines"
	case DeleteDisplayLineEnds:
		return "DisplayLineEnds"
	case DeleteParagraphEnds:
		return "ParagraphEnds"
	case DeleteParagraphs:
		return "Paragraphs"
	case DeleteWhitespace:
		return "Whitespace"
	default:
		return fmt.Sprintf("DeleteType(%d)", d)
	}
}

// DirectionType focus movement types.
type DirectionType int

const (
	// DirTabForward: move forward.
	DirTabForward DirectionType = iota
	// DirTabBackward: move backward.
	DirTabBackward
	// DirUp: move up.
	DirUp
	// DirDown: move down.
	DirDown
	// DirLeft: move left.
	DirLeft
	// DirRight: move right.
	DirRight
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for DirectionType.
func (d DirectionType) String() string {
	switch d {
	case DirTabForward:
		return "TabForward"
	case DirTabBackward:
		return "TabBackward"
	case DirUp:
		return "Up"
	case DirDown:
		return "Down"
	case DirLeft:
		return "Left"
	case DirRight:
		return "Right"
	default:
		return fmt.Sprintf("DirectionType(%d)", d)
	}
}

// DragResult gives an indication why a drag operation failed. The value can by
// obtained by connecting to the Widget::drag-failed signal.
type DragResult int

const (
	// DragResultSuccess: drag operation was successful.
	DragResultSuccess DragResult = iota
	// DragResultNoTarget: no suitable drag target.
	DragResultNoTarget
	// DragResultUserCancelled: user cancelled the drag operation.
	DragResultUserCancelled
	// DragResultTimeoutExpired: drag operation timed out.
	DragResultTimeoutExpired
	// DragResultGrabBroken: pointer or keyboard grab used for the drag
	// operation was broken.
	DragResultGrabBroken
	// DragResultError: drag operation failed due to some unspecified error.
	DragResultError
)

func marshalDragResult(p uintptr) (interface{}, error) {
	return DragResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for DragResult.
func (d DragResult) String() string {
	switch d {
	case DragResultSuccess:
		return "Success"
	case DragResultNoTarget:
		return "NoTarget"
	case DragResultUserCancelled:
		return "UserCancelled"
	case DragResultTimeoutExpired:
		return "TimeoutExpired"
	case DragResultGrabBroken:
		return "GrabBroken"
	case DragResultError:
		return "Error"
	default:
		return fmt.Sprintf("DragResult(%d)", d)
	}
}

// EventSequenceState describes the state of a EventSequence in a Gesture.
type EventSequenceState int

const (
	// EventSequenceNone: sequence is handled, but not grabbed.
	EventSequenceNone EventSequenceState = iota
	// EventSequenceClaimed: sequence is handled and grabbed.
	EventSequenceClaimed
	// EventSequenceDenied: sequence is denied.
	EventSequenceDenied
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for EventSequenceState.
func (e EventSequenceState) String() string {
	switch e {
	case EventSequenceNone:
		return "None"
	case EventSequenceClaimed:
		return "Claimed"
	case EventSequenceDenied:
		return "Denied"
	default:
		return fmt.Sprintf("EventSequenceState(%d)", e)
	}
}

// IMPreeditStyle: style for input method preedit. See also
// Settings:gtk-im-preedit-style
//
// Deprecated: since version 3.10.
type IMPreeditStyle int

const (
	// ImPreeditNothing: deprecated
	ImPreeditNothing IMPreeditStyle = iota
	// ImPreeditCallback: deprecated
	ImPreeditCallback
	// ImPreeditNone: deprecated
	ImPreeditNone
)

func marshalIMPreeditStyle(p uintptr) (interface{}, error) {
	return IMPreeditStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for IMPreeditStyle.
func (i IMPreeditStyle) String() string {
	switch i {
	case ImPreeditNothing:
		return "Nothing"
	case ImPreeditCallback:
		return "Callback"
	case ImPreeditNone:
		return "None"
	default:
		return fmt.Sprintf("IMPreeditStyle(%d)", i)
	}
}

// IMStatusStyle: style for input method status. See also
// Settings:gtk-im-status-style
//
// Deprecated: since version 3.10.
type IMStatusStyle int

const (
	// ImStatusNothing: deprecated
	ImStatusNothing IMStatusStyle = iota
	// ImStatusCallback: deprecated
	ImStatusCallback
	// ImStatusNone: deprecated
	ImStatusNone
)

func marshalIMStatusStyle(p uintptr) (interface{}, error) {
	return IMStatusStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for IMStatusStyle.
func (i IMStatusStyle) String() string {
	switch i {
	case ImStatusNothing:
		return "Nothing"
	case ImStatusCallback:
		return "Callback"
	case ImStatusNone:
		return "None"
	default:
		return fmt.Sprintf("IMStatusStyle(%d)", i)
	}
}

// IconSize: built-in stock icon sizes.
type IconSize int

const (
	// IconSizeInvalid: invalid size.
	IconSizeInvalid IconSize = iota
	// IconSizeMenu: size appropriate for menus (16px).
	IconSizeMenu
	// IconSizeSmallToolbar: size appropriate for small toolbars (16px).
	IconSizeSmallToolbar
	// IconSizeLargeToolbar: size appropriate for large toolbars (24px)
	IconSizeLargeToolbar
	// IconSizeButton: size appropriate for buttons (16px)
	IconSizeButton
	// IconSizeDnd: size appropriate for drag and drop (32px)
	IconSizeDnd
	// IconSizeDialog: size appropriate for dialogs (48px)
	IconSizeDialog
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for IconSize.
func (i IconSize) String() string {
	switch i {
	case IconSizeInvalid:
		return "Invalid"
	case IconSizeMenu:
		return "Menu"
	case IconSizeSmallToolbar:
		return "SmallToolbar"
	case IconSizeLargeToolbar:
		return "LargeToolbar"
	case IconSizeButton:
		return "Button"
	case IconSizeDnd:
		return "Dnd"
	case IconSizeDialog:
		return "Dialog"
	default:
		return fmt.Sprintf("IconSize(%d)", i)
	}
}

// InputPurpose describes primary purpose of the input widget. This information
// is useful for on-screen keyboards and similar input methods to decide which
// keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between GTK_INPUT_PURPOSE_DIGITS and GTK_INPUT_PURPOSE_NUMBER
// is that the former accepts only digits while the latter also some punctuation
// (like commas or points, plus, minus) and “e” or “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = iota
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha
	// InputPurposeDigits: allow only digits
	InputPurposeDigits
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone
	// InputPurposeURL: edited field expects URL
	InputPurposeURL
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName
	// InputPurposePassword: like GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword
	// InputPurposePin: like GTK_INPUT_PURPOSE_DIGITS, but characters are hidden
	InputPurposePin
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for InputPurpose.
func (i InputPurpose) String() string {
	switch i {
	case InputPurposeFreeForm:
		return "FreeForm"
	case InputPurposeAlpha:
		return "Alpha"
	case InputPurposeDigits:
		return "Digits"
	case InputPurposeNumber:
		return "Number"
	case InputPurposePhone:
		return "Phone"
	case InputPurposeURL:
		return "URL"
	case InputPurposeEmail:
		return "Email"
	case InputPurposeName:
		return "Name"
	case InputPurposePassword:
		return "Password"
	case InputPurposePin:
		return "Pin"
	case InputPurposeTerminal:
		return "Terminal"
	default:
		return fmt.Sprintf("InputPurpose(%d)", i)
	}
}

// Justification: used for justifying the text inside a Label widget. (See also
// Alignment).
type Justification int

const (
	// JustifyLeft: text is placed at the left edge of the label.
	JustifyLeft Justification = iota
	// JustifyRight: text is placed at the right edge of the label.
	JustifyRight
	// JustifyCenter: text is placed in the center of the label.
	JustifyCenter
	// JustifyFill: text is placed is distributed across the label.
	JustifyFill
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for Justification.
func (j Justification) String() string {
	switch j {
	case JustifyLeft:
		return "Left"
	case JustifyRight:
		return "Right"
	case JustifyCenter:
		return "Center"
	case JustifyFill:
		return "Fill"
	default:
		return fmt.Sprintf("Justification(%d)", j)
	}
}

// LevelBarMode describes how LevelBar contents should be rendered. Note that
// this enumeration could be extended with additional modes in the future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = iota
	// LevelBarModeDiscrete: bar has a discrete mode
	LevelBarModeDiscrete
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for LevelBarMode.
func (l LevelBarMode) String() string {
	switch l {
	case LevelBarModeContinuous:
		return "Continuous"
	case LevelBarModeDiscrete:
		return "Discrete"
	default:
		return fmt.Sprintf("LevelBarMode(%d)", l)
	}
}

// MenuDirectionType: enumeration representing directional movements within a
// menu.
type MenuDirectionType int

const (
	// MenuDirParent: to the parent menu shell
	MenuDirParent MenuDirectionType = iota
	// MenuDirChild: to the submenu, if any, associated with the item
	MenuDirChild
	// MenuDirNext: to the next menu item
	MenuDirNext
	// MenuDirPrev: to the previous menu item
	MenuDirPrev
)

func marshalMenuDirectionType(p uintptr) (interface{}, error) {
	return MenuDirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for MenuDirectionType.
func (m MenuDirectionType) String() string {
	switch m {
	case MenuDirParent:
		return "Parent"
	case MenuDirChild:
		return "Child"
	case MenuDirNext:
		return "Next"
	case MenuDirPrev:
		return "Prev"
	default:
		return fmt.Sprintf("MenuDirectionType(%d)", m)
	}
}

// MessageType: type of message being displayed in the dialog.
type MessageType int

const (
	// MessageInfo: informational message
	MessageInfo MessageType = iota
	// MessageWarning: non-fatal warning message
	MessageWarning
	// MessageQuestion: question requiring a choice
	MessageQuestion
	// MessageError: fatal error message
	MessageError
	// MessageOther: none of the above
	MessageOther
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for MessageType.
func (m MessageType) String() string {
	switch m {
	case MessageInfo:
		return "Info"
	case MessageWarning:
		return "Warning"
	case MessageQuestion:
		return "Question"
	case MessageError:
		return "Error"
	case MessageOther:
		return "Other"
	default:
		return fmt.Sprintf("MessageType(%d)", m)
	}
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLeftToRightTopToBottom: ! (layout-lrtb.png)
	NumberUpLayoutLeftToRightTopToBottom NumberUpLayout = iota
	// NumberUpLayoutLeftToRightBottomToTop: ! (layout-lrbt.png)
	NumberUpLayoutLeftToRightBottomToTop
	// NumberUpLayoutRightToLeftTopToBottom: ! (layout-rltb.png)
	NumberUpLayoutRightToLeftTopToBottom
	// NumberUpLayoutRightToLeftBottomToTop: ! (layout-rlbt.png)
	NumberUpLayoutRightToLeftBottomToTop
	// NumberUpLayoutTopToBottomLeftToRight: ! (layout-tblr.png)
	NumberUpLayoutTopToBottomLeftToRight
	// NumberUpLayoutTopToBottomRightToLeft: ! (layout-tbrl.png)
	NumberUpLayoutTopToBottomRightToLeft
	// NumberUpLayoutBottomToTopLeftToRight: ! (layout-btlr.png)
	NumberUpLayoutBottomToTopLeftToRight
	// NumberUpLayoutBottomToTopRightToLeft: ! (layout-btrl.png)
	NumberUpLayoutBottomToTopRightToLeft
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for NumberUpLayout.
func (n NumberUpLayout) String() string {
	switch n {
	case NumberUpLayoutLeftToRightTopToBottom:
		return "Lrtb"
	case NumberUpLayoutLeftToRightBottomToTop:
		return "Lrbt"
	case NumberUpLayoutRightToLeftTopToBottom:
		return "Rltb"
	case NumberUpLayoutRightToLeftBottomToTop:
		return "Rlbt"
	case NumberUpLayoutTopToBottomLeftToRight:
		return "Tblr"
	case NumberUpLayoutTopToBottomRightToLeft:
		return "Tbrl"
	case NumberUpLayoutBottomToTopLeftToRight:
		return "Btlr"
	case NumberUpLayoutBottomToTopRightToLeft:
		return "Btrl"
	default:
		return fmt.Sprintf("NumberUpLayout(%d)", n)
	}
}

// Orientation represents the orientation of widgets and other objects which can
// be switched between horizontal and vertical orientation on the fly, like
// Toolbar or GesturePan.
type Orientation int

const (
	// OrientationHorizontal: element is in horizontal orientation.
	OrientationHorizontal Orientation = iota
	// OrientationVertical: element is in vertical orientation.
	OrientationVertical
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for Orientation.
func (o Orientation) String() string {
	switch o {
	case OrientationHorizontal:
		return "Horizontal"
	case OrientationVertical:
		return "Vertical"
	default:
		return fmt.Sprintf("Orientation(%d)", o)
	}
}

// PackDirection determines how widgets should be packed inside menubars and
// menuitems contained in menubars.
type PackDirection int

const (
	// PackDirectionLTR widgets are packed left-to-right
	PackDirectionLTR PackDirection = iota
	// PackDirectionRTL widgets are packed right-to-left
	PackDirectionRTL
	// PackDirectionTtb widgets are packed top-to-bottom
	PackDirectionTtb
	// PackDirectionBtt widgets are packed bottom-to-top
	PackDirectionBtt
)

func marshalPackDirection(p uintptr) (interface{}, error) {
	return PackDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PackDirection.
func (p PackDirection) String() string {
	switch p {
	case PackDirectionLTR:
		return "LTR"
	case PackDirectionRTL:
		return "RTL"
	case PackDirectionTtb:
		return "Ttb"
	case PackDirectionBtt:
		return "Btt"
	default:
		return fmt.Sprintf("PackDirection(%d)", p)
	}
}

// PackType represents the packing location Box children. (See: VBox, HBox, and
// ButtonBox).
type PackType int

const (
	// PackStart: child is packed into the start of the box
	PackStart PackType = iota
	// PackEnd: child is packed into the end of the box
	PackEnd
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PackType.
func (p PackType) String() string {
	switch p {
	case PackStart:
		return "Start"
	case PackEnd:
		return "End"
	default:
		return fmt.Sprintf("PackType(%d)", p)
	}
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = iota
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PageOrientation.
func (p PageOrientation) String() string {
	switch p {
	case PageOrientationPortrait:
		return "Portrait"
	case PageOrientationLandscape:
		return "Landscape"
	case PageOrientationReversePortrait:
		return "ReversePortrait"
	case PageOrientationReverseLandscape:
		return "ReverseLandscape"
	default:
		return fmt.Sprintf("PageOrientation(%d)", p)
	}
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = iota
	// PageSetEven: even pages.
	PageSetEven
	// PageSetOdd: odd pages.
	PageSetOdd
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PageSet.
func (p PageSet) String() string {
	switch p {
	case PageSetAll:
		return "All"
	case PageSetEven:
		return "Even"
	case PageSetOdd:
		return "Odd"
	default:
		return fmt.Sprintf("PageSet(%d)", p)
	}
}

// PanDirection describes the panning direction of a GesturePan
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = iota
	// PanDirectionRight: panned towards the right
	PanDirectionRight
	// PanDirectionUp: panned upwards
	PanDirectionUp
	// PanDirectionDown: panned downwards
	PanDirectionDown
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PanDirection.
func (p PanDirection) String() string {
	switch p {
	case PanDirectionLeft:
		return "Left"
	case PanDirectionRight:
		return "Right"
	case PanDirectionUp:
		return "Up"
	case PanDirectionDown:
		return "Down"
	default:
		return fmt.Sprintf("PanDirection(%d)", p)
	}
}

// PopoverConstraint describes constraints to positioning of popovers. More
// values may be added to this enumeration in the future.
type PopoverConstraint int

const (
	// PopoverConstraintNone: don't constrain the popover position beyond what
	// is imposed by the implementation
	PopoverConstraintNone PopoverConstraint = iota
	// PopoverConstraintWindow: constrain the popover to the boundaries of the
	// window that it is attached to
	PopoverConstraintWindow
)

func marshalPopoverConstraint(p uintptr) (interface{}, error) {
	return PopoverConstraint(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PopoverConstraint.
func (p PopoverConstraint) String() string {
	switch p {
	case PopoverConstraintNone:
		return "None"
	case PopoverConstraintWindow:
		return "Window"
	default:
		return fmt.Sprintf("PopoverConstraint(%d)", p)
	}
}

// PositionType describes which edge of a widget a certain feature is positioned
// at, e.g. the tabs of a Notebook, the handle of a HandleBox or the label of a
// Scale.
type PositionType int

const (
	// PosLeft: feature is at the left edge.
	PosLeft PositionType = iota
	// PosRight: feature is at the right edge.
	PosRight
	// PosTop: feature is at the top edge.
	PosTop
	// PosBottom: feature is at the bottom edge.
	PosBottom
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PositionType.
func (p PositionType) String() string {
	switch p {
	case PosLeft:
		return "Left"
	case PosRight:
		return "Right"
	case PosTop:
		return "Top"
	case PosBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("PositionType(%d)", p)
	}
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = iota
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PrintDuplex.
func (p PrintDuplex) String() string {
	switch p {
	case PrintDuplexSimplex:
		return "Simplex"
	case PrintDuplexHorizontal:
		return "Horizontal"
	case PrintDuplexVertical:
		return "Vertical"
	default:
		return fmt.Sprintf("PrintDuplex(%d)", p)
	}
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = iota
	// PrintPagesCurrent: current page.
	PrintPagesCurrent
	// PrintPagesRanges: range of pages.
	PrintPagesRanges
	// PrintPagesSelection: selected pages.
	PrintPagesSelection
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PrintPages.
func (p PrintPages) String() string {
	switch p {
	case PrintPagesAll:
		return "All"
	case PrintPagesCurrent:
		return "Current"
	case PrintPagesRanges:
		return "Ranges"
	case PrintPagesSelection:
		return "Selection"
	default:
		return fmt.Sprintf("PrintPages(%d)", p)
	}
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = iota
	// PrintQualityNormal: normal quality.
	PrintQualityNormal
	// PrintQualityHigh: high quality.
	PrintQualityHigh
	// PrintQualityDraft: draft quality.
	PrintQualityDraft
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PrintQuality.
func (p PrintQuality) String() string {
	switch p {
	case PrintQualityLow:
		return "Low"
	case PrintQualityNormal:
		return "Normal"
	case PrintQualityHigh:
		return "High"
	case PrintQualityDraft:
		return "Draft"
	default:
		return fmt.Sprintf("PrintQuality(%d)", p)
	}
}

// PropagationPhase describes the stage at which events are fed into a
// EventController.
type PropagationPhase int

const (
	// PhaseNone events are not delivered automatically. Those can be manually
	// fed through gtk_event_controller_handle_event(). This should only be used
	// when full control about when, or whether the controller handles the event
	// is needed.
	PhaseNone PropagationPhase = iota
	// PhaseCapture events are delivered in the capture phase. The capture phase
	// happens before the bubble phase, runs from the toplevel down to the event
	// widget. This option should only be used on containers that might possibly
	// handle events before their children do.
	PhaseCapture
	// PhaseBubble events are delivered in the bubble phase. The bubble phase
	// happens after the capture phase, and before the default handlers are run.
	// This phase runs from the event widget, up to the toplevel.
	PhaseBubble
	// PhaseTarget events are delivered in the default widget event handlers,
	// note that widget implementations must chain up on button, motion, touch
	// and grab broken handlers for controllers in this phase to be run.
	PhaseTarget
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PropagationPhase.
func (p PropagationPhase) String() string {
	switch p {
	case PhaseNone:
		return "None"
	case PhaseCapture:
		return "Capture"
	case PhaseBubble:
		return "Bubble"
	case PhaseTarget:
		return "Target"
	default:
		return fmt.Sprintf("PropagationPhase(%d)", p)
	}
}

// ReliefStyle: indicated the relief to be drawn around a Button.
type ReliefStyle int

const (
	// ReliefNormal: draw a normal relief.
	ReliefNormal ReliefStyle = iota
	// ReliefHalf relief. Deprecated in 3.14, does the same as GTK_RELIEF_NORMAL
	ReliefHalf
	// ReliefNone: no relief.
	ReliefNone
)

func marshalReliefStyle(p uintptr) (interface{}, error) {
	return ReliefStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for ReliefStyle.
func (r ReliefStyle) String() string {
	switch r {
	case ReliefNormal:
		return "Normal"
	case ReliefHalf:
		return "Half"
	case ReliefNone:
		return "None"
	default:
		return fmt.Sprintf("ReliefStyle(%d)", r)
	}
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollNone: no scrolling.
	ScrollNone ScrollType = iota
	// ScrollJump: jump to new location.
	ScrollJump
	// ScrollStepBackward: step backward.
	ScrollStepBackward
	// ScrollStepForward: step forward.
	ScrollStepForward
	// ScrollPageBackward: page backward.
	ScrollPageBackward
	// ScrollPageForward: page forward.
	ScrollPageForward
	// ScrollStepUp: step up.
	ScrollStepUp
	// ScrollStepDown: step down.
	ScrollStepDown
	// ScrollPageUp: page up.
	ScrollPageUp
	// ScrollPageDown: page down.
	ScrollPageDown
	// ScrollStepLeft: step to the left.
	ScrollStepLeft
	// ScrollStepRight: step to the right.
	ScrollStepRight
	// ScrollPageLeft: page to the left.
	ScrollPageLeft
	// ScrollPageRight: page to the right.
	ScrollPageRight
	// ScrollStart: scroll to start.
	ScrollStart
	// ScrollEnd: scroll to end.
	ScrollEnd
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for ScrollType.
func (s ScrollType) String() string {
	switch s {
	case ScrollNone:
		return "None"
	case ScrollJump:
		return "Jump"
	case ScrollStepBackward:
		return "StepBackward"
	case ScrollStepForward:
		return "StepForward"
	case ScrollPageBackward:
		return "PageBackward"
	case ScrollPageForward:
		return "PageForward"
	case ScrollStepUp:
		return "StepUp"
	case ScrollStepDown:
		return "StepDown"
	case ScrollPageUp:
		return "PageUp"
	case ScrollPageDown:
		return "PageDown"
	case ScrollStepLeft:
		return "StepLeft"
	case ScrollStepRight:
		return "StepRight"
	case ScrollPageLeft:
		return "PageLeft"
	case ScrollPageRight:
		return "PageRight"
	case ScrollStart:
		return "Start"
	case ScrollEnd:
		return "End"
	default:
		return fmt.Sprintf("ScrollType(%d)", s)
	}
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollMinimum: scrollable adjustments are based on the minimum size
	ScrollMinimum ScrollablePolicy = iota
	// ScrollNatural: scrollable adjustments are based on the natural size
	ScrollNatural
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for ScrollablePolicy.
func (s ScrollablePolicy) String() string {
	switch s {
	case ScrollMinimum:
		return "Minimum"
	case ScrollNatural:
		return "Natural"
	default:
		return fmt.Sprintf("ScrollablePolicy(%d)", s)
	}
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionNone: no selection is possible.
	SelectionNone SelectionMode = iota
	// SelectionSingle: zero or one element may be selected.
	SelectionSingle
	// SelectionBrowse: exactly one element is selected. In some circumstances,
	// such as initially or during a search operation, it’s possible for no
	// element to be selected with GTK_SELECTION_BROWSE. What is really enforced
	// is that the user can’t deselect a currently selected element except by
	// selecting another element.
	SelectionBrowse
	// SelectionMultiple: any number of elements may be selected. The Ctrl key
	// may be used to enlarge the selection, and Shift key to select between the
	// focus and the child pointed to. Some widgets may also allow Click-drag to
	// select a range of elements.
	SelectionMultiple
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for SelectionMode.
func (s SelectionMode) String() string {
	switch s {
	case SelectionNone:
		return "None"
	case SelectionSingle:
		return "Single"
	case SelectionBrowse:
		return "Browse"
	case SelectionMultiple:
		return "Multiple"
	default:
		return fmt.Sprintf("SelectionMode(%d)", s)
	}
}

// SensitivityType determines how GTK+ handles the sensitivity of stepper arrows
// at the end of range widgets.
type SensitivityType int

const (
	// SensitivityAuto: arrow is made insensitive if the thumb is at the end
	SensitivityAuto SensitivityType = iota
	// SensitivityOn: arrow is always sensitive
	SensitivityOn
	// SensitivityOff: arrow is always insensitive
	SensitivityOff
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for SensitivityType.
func (s SensitivityType) String() string {
	switch s {
	case SensitivityAuto:
		return "Auto"
	case SensitivityOn:
		return "On"
	case SensitivityOff:
		return "Off"
	default:
		return fmt.Sprintf("SensitivityType(%d)", s)
	}
}

// ShadowType: used to change the appearance of an outline typically provided by
// a Frame.
//
// Note that many themes do not differentiate the appearance of the various
// shadow types: Either their is no visible shadow (GTK_SHADOW_NONE), or there
// is (any other value).
type ShadowType int

const (
	// ShadowNone: no outline.
	ShadowNone ShadowType = iota
	// ShadowIn: outline is bevelled inwards.
	ShadowIn
	// ShadowOut: outline is bevelled outwards like a button.
	ShadowOut
	// ShadowEtchedIn: outline has a sunken 3d appearance.
	ShadowEtchedIn
	// ShadowEtchedOut: outline has a raised 3d appearance.
	ShadowEtchedOut
)

func marshalShadowType(p uintptr) (interface{}, error) {
	return ShadowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for ShadowType.
func (s ShadowType) String() string {
	switch s {
	case ShadowNone:
		return "None"
	case ShadowIn:
		return "In"
	case ShadowOut:
		return "Out"
	case ShadowEtchedIn:
		return "EtchedIn"
	case ShadowEtchedOut:
		return "EtchedOut"
	default:
		return fmt.Sprintf("ShadowType(%d)", s)
	}
}

// SizeGroupMode: mode of the size group determines the directions in which the
// size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupNone: group has no effect
	SizeGroupNone SizeGroupMode = iota
	// SizeGroupHorizontal: group affects horizontal requisition
	SizeGroupHorizontal
	// SizeGroupVertical: group affects vertical requisition
	SizeGroupVertical
	// SizeGroupBoth: group affects both horizontal and vertical requisition
	SizeGroupBoth
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for SizeGroupMode.
func (s SizeGroupMode) String() string {
	switch s {
	case SizeGroupNone:
		return "None"
	case SizeGroupHorizontal:
		return "Horizontal"
	case SizeGroupVertical:
		return "Vertical"
	case SizeGroupBoth:
		return "Both"
	default:
		return fmt.Sprintf("SizeGroupMode(%d)", s)
	}
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestHeightForWidth: prefer height-for-width geometry management
	SizeRequestHeightForWidth SizeRequestMode = iota
	// SizeRequestWidthForHeight: prefer width-for-height geometry management
	SizeRequestWidthForHeight
	// SizeRequestConstantSize: don’t trade height-for-width or width-for-height
	SizeRequestConstantSize
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for SizeRequestMode.
func (s SizeRequestMode) String() string {
	switch s {
	case SizeRequestHeightForWidth:
		return "HeightForWidth"
	case SizeRequestWidthForHeight:
		return "WidthForHeight"
	case SizeRequestConstantSize:
		return "ConstantSize"
	default:
		return fmt.Sprintf("SizeRequestMode(%d)", s)
	}
}

// SortType determines the direction of a sort.
type SortType int

const (
	// SortAscending: sorting is in ascending order.
	SortAscending SortType = iota
	// SortDescending: sorting is in descending order.
	SortDescending
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for SortType.
func (s SortType) String() string {
	switch s {
	case SortAscending:
		return "Ascending"
	case SortDescending:
		return "Descending"
	default:
		return fmt.Sprintf("SortType(%d)", s)
	}
}

// StateType: this type indicates the current state of a widget; the state
// determines how the widget is drawn. The StateType enumeration is also used to
// identify different colors in a Style for drawing, so states can be used for
// subparts of a widget as well as entire widgets.
//
// Deprecated: All APIs that are using this enumeration have been deprecated in
// favor of alternatives using StateFlags.
type StateType int

const (
	// StateNormal: state during normal operation.
	StateNormal StateType = iota
	// StateActive: state of a currently active widget, such as a depressed
	// button.
	StateActive
	// StatePrelight: state indicating that the mouse pointer is over the widget
	// and the widget will respond to mouse clicks.
	StatePrelight
	// StateSelected: state of a selected item, such the selected row in a list.
	StateSelected
	// StateInsensitive: state indicating that the widget is unresponsive to
	// user actions.
	StateInsensitive
	// StateInconsistent: widget is inconsistent, such as checkbuttons or
	// radiobuttons that aren’t either set to TRUE nor FALSE, or buttons
	// requiring the user attention.
	StateInconsistent
	// StateFocused: widget has the keyboard focus.
	StateFocused
)

func marshalStateType(p uintptr) (interface{}, error) {
	return StateType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for StateType.
func (s StateType) String() string {
	switch s {
	case StateNormal:
		return "Normal"
	case StateActive:
		return "Active"
	case StatePrelight:
		return "Prelight"
	case StateSelected:
		return "Selected"
	case StateInsensitive:
		return "Insensitive"
	case StateInconsistent:
		return "Inconsistent"
	case StateFocused:
		return "Focused"
	default:
		return fmt.Sprintf("StateType(%d)", s)
	}
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirNone: no direction.
	TextDirNone TextDirection = iota
	// TextDirLTR: left to right text direction.
	TextDirLTR
	// TextDirRTL: right to left text direction.
	TextDirRTL
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TextDirection.
func (t TextDirection) String() string {
	switch t {
	case TextDirNone:
		return "None"
	case TextDirLTR:
		return "LTR"
	case TextDirRTL:
		return "RTL"
	default:
		return fmt.Sprintf("TextDirection(%d)", t)
	}
}

// ToolbarStyle: used to customize the appearance of a Toolbar. Note that
// setting the toolbar style overrides the user’s preferences for the default
// toolbar style. Note that if the button has only a label set and
// GTK_TOOLBAR_ICONS is used, the label will be visible, and vice versa.
type ToolbarStyle int

const (
	// ToolbarIcons buttons display only icons in the toolbar.
	ToolbarIcons ToolbarStyle = iota
	// ToolbarText buttons display only text labels in the toolbar.
	ToolbarText
	// ToolbarBoth buttons display text and icons in the toolbar.
	ToolbarBoth
	// ToolbarBothHoriz buttons display icons and text alongside each other,
	// rather than vertically stacked
	ToolbarBothHoriz
)

func marshalToolbarStyle(p uintptr) (interface{}, error) {
	return ToolbarStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for ToolbarStyle.
func (t ToolbarStyle) String() string {
	switch t {
	case ToolbarIcons:
		return "Icons"
	case ToolbarText:
		return "Text"
	case ToolbarBoth:
		return "Both"
	case ToolbarBothHoriz:
		return "BothHoriz"
	default:
		return fmt.Sprintf("ToolbarStyle(%d)", t)
	}
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = iota
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TreeViewGridLines.
func (t TreeViewGridLines) String() string {
	switch t {
	case TreeViewGridLinesNone:
		return "None"
	case TreeViewGridLinesHorizontal:
		return "Horizontal"
	case TreeViewGridLinesVertical:
		return "Vertical"
	case TreeViewGridLinesBoth:
		return "Both"
	default:
		return fmt.Sprintf("TreeViewGridLines(%d)", t)
	}
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = iota
	// UnitPoints dimensions in points.
	UnitPoints
	// UnitInch dimensions in inches.
	UnitInch
	// UnitMm dimensions in millimeters
	UnitMm
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for Unit.
func (u Unit) String() string {
	switch u {
	case UnitNone:
		return "None"
	case UnitPoints:
		return "Points"
	case UnitInch:
		return "Inch"
	case UnitMm:
		return "Mm"
	default:
		return fmt.Sprintf("Unit(%d)", u)
	}
}

// WrapMode describes a type of line wrapping.
type WrapMode int

const (
	// WrapNone: do not wrap lines; just make the text area wider
	WrapNone WrapMode = iota
	// WrapChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapChar
	// WrapWord: wrap text, breaking lines in between words
	WrapWord
	// WrapWordChar: wrap text, breaking lines in between words, or if that is
	// not enough, also between graphemes
	WrapWordChar
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for WrapMode.
func (w WrapMode) String() string {
	switch w {
	case WrapNone:
		return "None"
	case WrapChar:
		return "Char"
	case WrapWord:
		return "Word"
	case WrapWordChar:
		return "WordChar"
	default:
		return fmt.Sprintf("WrapMode(%d)", w)
	}
}

// InputHints describes hints that might be taken into account by input methods
// or applications. Note that input methods may already tailor their behaviour
// according to the InputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintNone: no special behaviour suggested
	InputHintNone InputHints = 0b0
	// InputHintSpellcheck: suggest checking for typos
	InputHintSpellcheck InputHints = 0b1
	// InputHintNoSpellcheck: suggest not checking for typos
	InputHintNoSpellcheck InputHints = 0b10
	// InputHintWordCompletion: suggest word completion
	InputHintWordCompletion InputHints = 0b100
	// InputHintLowercase: suggest to convert all text to lowercase
	InputHintLowercase InputHints = 0b1000
	// InputHintUppercaseChars: suggest to capitalize all text
	InputHintUppercaseChars InputHints = 0b10000
	// InputHintUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintUppercaseWords InputHints = 0b100000
	// InputHintUppercaseSentences: suggest to capitalize the first word of each
	// sentence
	InputHintUppercaseSentences InputHints = 0b1000000
	// InputHintInhibitOSK: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintInhibitOSK InputHints = 0b10000000
	// InputHintVerticalWriting: text is vertical. Since 3.18
	InputHintVerticalWriting InputHints = 0b100000000
	// InputHintEmoji: suggest offering Emoji support. Since 3.22.20
	InputHintEmoji InputHints = 0b1000000000
	// InputHintNoEmoji: suggest not offering Emoji support. Since 3.22.20
	InputHintNoEmoji InputHints = 0b10000000000
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_flags((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for InputHints.
func (i InputHints) String() string {
	if i == 0 {
		return "InputHints(0)"
	}

	var builder strings.Builder
	builder.Grow(251)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case InputHintNone:
			builder.WriteString("None|")
		case InputHintSpellcheck:
			builder.WriteString("Spellcheck|")
		case InputHintNoSpellcheck:
			builder.WriteString("NoSpellcheck|")
		case InputHintWordCompletion:
			builder.WriteString("WordCompletion|")
		case InputHintLowercase:
			builder.WriteString("Lowercase|")
		case InputHintUppercaseChars:
			builder.WriteString("UppercaseChars|")
		case InputHintUppercaseWords:
			builder.WriteString("UppercaseWords|")
		case InputHintUppercaseSentences:
			builder.WriteString("UppercaseSentences|")
		case InputHintInhibitOSK:
			builder.WriteString("InhibitOSK|")
		case InputHintVerticalWriting:
			builder.WriteString("VerticalWriting|")
		case InputHintEmoji:
			builder.WriteString("Emoji|")
		case InputHintNoEmoji:
			builder.WriteString("NoEmoji|")
		default:
			builder.WriteString(fmt.Sprintf("InputHints(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i InputHints) Has(other InputHints) bool {
	return (i & other) == other
}

// JunctionSides describes how a rendered element connects to adjacent elements.
type JunctionSides int

const (
	// JunctionNone: no junctions.
	JunctionNone JunctionSides = 0b0
	// JunctionCornerTopleft: element connects on the top-left corner.
	JunctionCornerTopleft JunctionSides = 0b1
	// JunctionCornerTopright: element connects on the top-right corner.
	JunctionCornerTopright JunctionSides = 0b10
	// JunctionCornerBottomleft: element connects on the bottom-left corner.
	JunctionCornerBottomleft JunctionSides = 0b100
	// JunctionCornerBottomright: element connects on the bottom-right corner.
	JunctionCornerBottomright JunctionSides = 0b1000
	// JunctionTop: element connects on the top side.
	JunctionTop JunctionSides = 0b11
	// JunctionBottom: element connects on the bottom side.
	JunctionBottom JunctionSides = 0b1100
	// JunctionLeft: element connects on the left side.
	JunctionLeft JunctionSides = 0b101
	// JunctionRight: element connects on the right side.
	JunctionRight JunctionSides = 0b1010
)

func marshalJunctionSides(p uintptr) (interface{}, error) {
	return JunctionSides(C.g_value_get_flags((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for JunctionSides.
func (j JunctionSides) String() string {
	if j == 0 {
		return "JunctionSides(0)"
	}

	var builder strings.Builder
	builder.Grow(162)

	for j != 0 {
		next := j & (j - 1)
		bit := j - next

		switch bit {
		case JunctionNone:
			builder.WriteString("None|")
		case JunctionCornerTopleft:
			builder.WriteString("CornerTopleft|")
		case JunctionCornerTopright:
			builder.WriteString("CornerTopright|")
		case JunctionCornerBottomleft:
			builder.WriteString("CornerBottomleft|")
		case JunctionCornerBottomright:
			builder.WriteString("CornerBottomright|")
		case JunctionTop:
			builder.WriteString("Top|")
		case JunctionBottom:
			builder.WriteString("Bottom|")
		case JunctionLeft:
			builder.WriteString("Left|")
		case JunctionRight:
			builder.WriteString("Right|")
		default:
			builder.WriteString(fmt.Sprintf("JunctionSides(0b%b)|", bit))
		}

		j = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if j contains other.
func (j JunctionSides) Has(other JunctionSides) bool {
	return (j & other) == other
}

// RegionFlags describes a region within a widget.
type RegionFlags int

const (
	// RegionEven: region has an even number within a set.
	RegionEven RegionFlags = 0b1
	// RegionOdd: region has an odd number within a set.
	RegionOdd RegionFlags = 0b10
	// RegionFirst: region is the first one within a set.
	RegionFirst RegionFlags = 0b100
	// RegionLast: region is the last one within a set.
	RegionLast RegionFlags = 0b1000
	// RegionOnly: region is the only one within a set.
	RegionOnly RegionFlags = 0b10000
	// RegionSorted: region is part of a sorted area.
	RegionSorted RegionFlags = 0b100000
)

func marshalRegionFlags(p uintptr) (interface{}, error) {
	return RegionFlags(C.g_value_get_flags((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for RegionFlags.
func (r RegionFlags) String() string {
	if r == 0 {
		return "RegionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(67)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RegionEven:
			builder.WriteString("Even|")
		case RegionOdd:
			builder.WriteString("Odd|")
		case RegionFirst:
			builder.WriteString("First|")
		case RegionLast:
			builder.WriteString("Last|")
		case RegionOnly:
			builder.WriteString("Only|")
		case RegionSorted:
			builder.WriteString("Sorted|")
		default:
			builder.WriteString(fmt.Sprintf("RegionFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RegionFlags) Has(other RegionFlags) bool {
	return (r & other) == other
}

// StateFlags describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagNormal: state during normal operation.
	StateFlagNormal StateFlags = 0b0
	// StateFlagActive: widget is active.
	StateFlagActive StateFlags = 0b1
	// StateFlagPrelight: widget has a mouse pointer over it.
	StateFlagPrelight StateFlags = 0b10
	// StateFlagSelected: widget is selected.
	StateFlagSelected StateFlags = 0b100
	// StateFlagInsensitive: widget is insensitive.
	StateFlagInsensitive StateFlags = 0b1000
	// StateFlagInconsistent: widget is inconsistent.
	StateFlagInconsistent StateFlags = 0b10000
	// StateFlagFocused: widget has the keyboard focus.
	StateFlagFocused StateFlags = 0b100000
	// StateFlagBackdrop: widget is in a background toplevel window.
	StateFlagBackdrop StateFlags = 0b1000000
	// StateFlagDirLTR: widget is in left-to-right text direction. Since 3.8
	StateFlagDirLTR StateFlags = 0b10000000
	// StateFlagDirRTL: widget is in right-to-left text direction. Since 3.8
	StateFlagDirRTL StateFlags = 0b100000000
	// StateFlagLink: widget is a link. Since 3.12
	StateFlagLink StateFlags = 0b1000000000
	// StateFlagVisited: location the widget points to has already been visited.
	// Since 3.12
	StateFlagVisited StateFlags = 0b10000000000
	// StateFlagChecked: widget is checked. Since 3.14
	StateFlagChecked StateFlags = 0b100000000000
	// StateFlagDropActive: widget is highlighted as a drop target for DND.
	// Since 3.20
	StateFlagDropActive StateFlags = 0b1000000000000
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_flags((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for StateFlags.
func (s StateFlags) String() string {
	if s == 0 {
		return "StateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(245)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StateFlagNormal:
			builder.WriteString("Normal|")
		case StateFlagActive:
			builder.WriteString("Active|")
		case StateFlagPrelight:
			builder.WriteString("Prelight|")
		case StateFlagSelected:
			builder.WriteString("Selected|")
		case StateFlagInsensitive:
			builder.WriteString("Insensitive|")
		case StateFlagInconsistent:
			builder.WriteString("Inconsistent|")
		case StateFlagFocused:
			builder.WriteString("Focused|")
		case StateFlagBackdrop:
			builder.WriteString("Backdrop|")
		case StateFlagDirLTR:
			builder.WriteString("DirLTR|")
		case StateFlagDirRTL:
			builder.WriteString("DirRTL|")
		case StateFlagLink:
			builder.WriteString("Link|")
		case StateFlagVisited:
			builder.WriteString("Visited|")
		case StateFlagChecked:
			builder.WriteString("Checked|")
		case StateFlagDropActive:
			builder.WriteString("DropActive|")
		default:
			builder.WriteString(fmt.Sprintf("StateFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StateFlags) Has(other StateFlags) bool {
	return (s & other) == other
}
