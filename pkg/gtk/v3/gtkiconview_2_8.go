// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// CreateDragIcon creates a #cairo_surface_t representation of the item at path.
// This image is used for a drag icon.
//
// The function takes the following parameters:
//
//    - path in icon_view.
//
// The function returns the following values:
//
//    - surface: newly-allocated surface of the drag icon.
//
func (iconView *IconView) CreateDragIcon(path *TreePath) *cairo.Surface {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_icon_view_create_drag_icon(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// EnableModelDragDest turns icon_view into a drop destination for automatic
// DND. Calling this method sets IconView:reorderable to FALSE.
//
// The function takes the following parameters:
//
//    - targets: table of targets that the drag will support.
//    - actions: bitmask of possible actions for a drag to this widget.
//
func (iconView *IconView) EnableModelDragDest(targets []TargetEntry, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView    // out
	var _arg1 *C.GtkTargetEntry // out
	var _arg2 C.gint
	var _arg3 C.GdkDragAction // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg2 = (C.gint)(len(targets))
	_arg1 = (*C.GtkTargetEntry)(C.calloc(C.size_t(len(targets)), C.size_t(C.sizeof_GtkTargetEntry)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GtkTargetEntry)(_arg1), len(targets))
		for i := range targets {
			out[i] = *(*C.GtkTargetEntry)(gextras.StructNative(unsafe.Pointer((&targets[i]))))
		}
	}
	_arg3 = C.GdkDragAction(actions)

	C.gtk_icon_view_enable_model_drag_dest(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(targets)
	runtime.KeepAlive(actions)
}

// EnableModelDragSource turns icon_view into a drag source for automatic DND.
// Calling this method sets IconView:reorderable to FALSE.
//
// The function takes the following parameters:
//
//    - startButtonMask: mask of allowed buttons to start drag.
//    - targets: table of targets that the drag will support.
//    - actions: bitmask of possible actions for a drag from this widget.
//
func (iconView *IconView) EnableModelDragSource(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView    // out
	var _arg1 C.GdkModifierType // out
	var _arg2 *C.GtkTargetEntry // out
	var _arg3 C.gint
	var _arg4 C.GdkDragAction // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.GdkModifierType(startButtonMask)
	_arg3 = (C.gint)(len(targets))
	_arg2 = (*C.GtkTargetEntry)(C.calloc(C.size_t(len(targets)), C.size_t(C.sizeof_GtkTargetEntry)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GtkTargetEntry)(_arg2), len(targets))
		for i := range targets {
			out[i] = *(*C.GtkTargetEntry)(gextras.StructNative(unsafe.Pointer((&targets[i]))))
		}
	}
	_arg4 = C.GdkDragAction(actions)

	C.gtk_icon_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(startButtonMask)
	runtime.KeepAlive(targets)
	runtime.KeepAlive(actions)
}

// Cursor fills in path and cell with the current cursor path and cell. If the
// cursor isn’t currently set, then *path will be NULL. If no cell currently has
// focus, then *cell will be NULL.
//
// The returned TreePath must be freed with gtk_tree_path_free().
//
// The function returns the following values:
//
//    - path (optional): return location for the current cursor path, or NULL.
//    - cell (optional): return location the current focus cell, or NULL.
//    - ok: TRUE if the cursor is set.
//
func (iconView *IconView) Cursor() (*TreePath, CellRendererer, bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // in
	var _arg2 *C.GtkCellRenderer // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_cursor(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iconView)

	var _path *TreePath      // out
	var _cell CellRendererer // out
	var _ok bool             // out

	if _arg1 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			_cell = rv
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _path, _cell, _ok
}

// DestItemAtPos determines the destination item for a given position.
//
// The function takes the following parameters:
//
//    - dragX: position to determine the destination item for.
//    - dragY: position to determine the destination item for.
//
// The function returns the following values:
//
//    - path (optional): return location for the path of the item, or NULL.
//    - pos (optional): return location for the drop position, or NULL.
//    - ok: whether there is an item at the given position.
//
func (iconView *IconView) DestItemAtPos(dragX, dragY int) (*TreePath, IconViewDropPosition, bool) {
	var _arg0 *C.GtkIconView            // out
	var _arg1 C.gint                    // out
	var _arg2 C.gint                    // out
	var _arg3 *C.GtkTreePath            // in
	var _arg4 C.GtkIconViewDropPosition // in
	var _cret C.gboolean                // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.gint(dragX)
	_arg2 = C.gint(dragY)

	_cret = C.gtk_icon_view_get_dest_item_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(dragX)
	runtime.KeepAlive(dragY)

	var _path *TreePath           // out
	var _pos IconViewDropPosition // out
	var _ok bool                  // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_pos = IconViewDropPosition(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _path, _pos, _ok
}

// DragDestItem gets information about the item that is highlighted for
// feedback.
//
// The function returns the following values:
//
//    - path (optional): return location for the path of the highlighted item, or
//      NULL.
//    - pos (optional): return location for the drop position, or NULL.
//
func (iconView *IconView) DragDestItem() (*TreePath, IconViewDropPosition) {
	var _arg0 *C.GtkIconView            // out
	var _arg1 *C.GtkTreePath            // in
	var _arg2 C.GtkIconViewDropPosition // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C.gtk_icon_view_get_drag_dest_item(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iconView)

	var _path *TreePath           // out
	var _pos IconViewDropPosition // out

	if _arg1 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_pos = IconViewDropPosition(_arg2)

	return _path, _pos
}

// ItemAtPos finds the path at the point (x, y), relative to bin_window
// coordinates. In contrast to gtk_icon_view_get_path_at_pos(), this function
// also obtains the cell at the specified position. The returned path should be
// freed with gtk_tree_path_free(). See
// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
// coordinates to bin_window coordinates.
//
// The function takes the following parameters:
//
//    - x position to be identified.
//    - y position to be identified.
//
// The function returns the following values:
//
//    - path (optional): return location for the path, or NULL.
//    - cell (optional): return location for the renderer responsible for the
//      cell at (x, y), or NULL.
//    - ok: TRUE if an item exists at the specified position.
//
func (iconView *IconView) ItemAtPos(x, y int) (*TreePath, CellRendererer, bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 C.gint             // out
	var _arg2 C.gint             // out
	var _arg3 *C.GtkTreePath     // in
	var _arg4 *C.GtkCellRenderer // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)

	_cret = C.gtk_icon_view_get_item_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _path *TreePath      // out
	var _cell CellRendererer // out
	var _ok bool             // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg4 != nil {
		{
			objptr := unsafe.Pointer(_arg4)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			_cell = rv
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _path, _cell, _ok
}

// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
//
// The function returns the following values:
//
//    - ok: TRUE if the list can be reordered.
//
func (iconView *IconView) Reorderable() bool {
	var _arg0 *C.GtkIconView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_reorderable(_arg0)
	runtime.KeepAlive(iconView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleRange sets start_path and end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
//
// Both paths should be freed with gtk_tree_path_free() after use.
//
// The function returns the following values:
//
//    - startPath (optional): return location for start of region, or NULL.
//    - endPath (optional): return location for end of region, or NULL.
//    - ok: TRUE, if valid paths were placed in start_path and end_path.
//
func (iconView *IconView) VisibleRange() (startPath, endPath *TreePath, ok bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // in
	var _arg2 *C.GtkTreePath // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_visible_range(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iconView)

	var _startPath *TreePath // out
	var _endPath *TreePath   // out
	var _ok bool             // out

	if _arg1 != nil {
		_startPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_startPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg2 != nil {
		_endPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_endPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

// ScrollToPath moves the alignments of icon_view to the position specified by
// path. row_align determines where the row is placed, and col_align determines
// where column is placed. Both are expected to be between 0.0 and 1.0. 0.0
// means left/top alignment, 1.0 means right/bottom alignment, 0.5 means center.
//
// If use_align is FALSE, then the alignment arguments are ignored, and the tree
// does the minimum amount of work to scroll the item onto the screen. This
// means that the item will be scrolled to the edge closest to its current
// position. If the item is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and path is a valid row on the
// model. If the model changes before the icon_view is realized, the centered
// path will be modified to reflect this change.
//
// The function takes the following parameters:
//
//    - path of the item to move to.
//    - useAlign: whether to use alignment arguments, or FALSE.
//    - rowAlign: vertical alignment of the item specified by path.
//    - colAlign: horizontal alignment of the item specified by path.
//
func (iconView *IconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign, colAlign float32) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _arg2 C.gboolean     // out
	var _arg3 C.gfloat       // out
	var _arg4 C.gfloat       // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if useAlign {
		_arg2 = C.TRUE
	}
	_arg3 = C.gfloat(rowAlign)
	_arg4 = C.gfloat(colAlign)

	C.gtk_icon_view_scroll_to_path(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(rowAlign)
	runtime.KeepAlive(colAlign)
}

// SetCursor sets the current keyboard focus to be at path, and selects it. This
// is useful when you want to focus the user’s attention on a particular item.
// If cell is not NULL, then focus is given to the cell specified by it.
// Additionally, if start_editing is TRUE, then editing should be started in the
// specified cell.
//
// This function is often followed by gtk_widget_grab_focus (icon_view) in order
// to give keyboard focus to the widget. Please note that editing can only
// happen when the widget is realized.
//
// The function takes the following parameters:
//
//    - path: TreePath.
//    - cell (optional): one of the cell renderers of icon_view, or NULL.
//    - startEditing: TRUE if the specified cell should start being edited.
//
func (iconView *IconView) SetCursor(path *TreePath, cell CellRendererer, startEditing bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GtkCellRenderer // out
	var _arg3 C.gboolean         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if cell != nil {
		_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	}
	if startEditing {
		_arg3 = C.TRUE
	}

	C.gtk_icon_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(startEditing)
}

// SetDragDestItem sets the item that is highlighted for feedback.
//
// The function takes the following parameters:
//
//    - path (optional) of the item to highlight, or NULL.
//    - pos specifies where to drop, relative to the item.
//
func (iconView *IconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition) {
	var _arg0 *C.GtkIconView            // out
	var _arg1 *C.GtkTreePath            // out
	var _arg2 C.GtkIconViewDropPosition // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	_arg2 = C.GtkIconViewDropPosition(pos)

	C.gtk_icon_view_set_drag_dest_item(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If reorderable
// is TRUE, then the user can reorder the model by dragging and dropping rows.
// The developer can listen to these changes by connecting to the model's
// row_inserted and row_deleted signals. The reordering is implemented by
// setting up the icon view as a drag source and destination. Therefore, drag
// and drop can not be used in a reorderable view for any other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
//
// The function takes the following parameters:
//
//    - reorderable: TRUE, if the list of items can be reordered.
//
func (iconView *IconView) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_icon_view_set_reorderable(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(reorderable)
}

// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to FALSE.
func (iconView *IconView) UnsetModelDragDest() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C.gtk_icon_view_unset_model_drag_dest(_arg0)
	runtime.KeepAlive(iconView)
}

// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to FALSE.
func (iconView *IconView) UnsetModelDragSource() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C.gtk_icon_view_unset_model_drag_source(_arg0)
	runtime.KeepAlive(iconView)
}
