// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/gsk/v4"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_accessible_autocomplete_get_type()), F: marshalAccessibleAutocomplete},
		{T: externglib.Type(C.gtk_accessible_invalid_state_get_type()), F: marshalAccessibleInvalidState},
		{T: externglib.Type(C.gtk_accessible_property_get_type()), F: marshalAccessibleProperty},
		{T: externglib.Type(C.gtk_accessible_relation_get_type()), F: marshalAccessibleRelation},
		{T: externglib.Type(C.gtk_accessible_role_get_type()), F: marshalAccessibleRole},
		{T: externglib.Type(C.gtk_accessible_sort_get_type()), F: marshalAccessibleSort},
		{T: externglib.Type(C.gtk_accessible_state_get_type()), F: marshalAccessibleState},
		{T: externglib.Type(C.gtk_accessible_tristate_get_type()), F: marshalAccessibleTristate},
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
		{T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
		{T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
		{T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
		{T: externglib.Type(C.gtk_constraint_attribute_get_type()), F: marshalConstraintAttribute},
		{T: externglib.Type(C.gtk_constraint_relation_get_type()), F: marshalConstraintRelation},
		{T: externglib.Type(C.gtk_constraint_strength_get_type()), F: marshalConstraintStrength},
		{T: externglib.Type(C.gtk_constraint_vfl_parser_error_get_type()), F: marshalConstraintVflParserError},
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_editable_properties_get_type()), F: marshalEditableProperties},
		{T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
		{T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
		{T: externglib.Type(C.gtk_filter_change_get_type()), F: marshalFilterChange},
		{T: externglib.Type(C.gtk_filter_match_get_type()), F: marshalFilterMatch},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
		{T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
		{T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_ordering_get_type()), F: marshalOrdering},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_overflow_get_type()), F: marshalOverflow},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_propagation_limit_get_type()), F: marshalPropagationLimit},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
		{T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shortcut_scope_get_type()), F: marshalShortcutScope},
		{T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_sorter_change_get_type()), F: marshalSorterChange},
		{T: externglib.Type(C.gtk_sorter_order_get_type()), F: marshalSorterOrder},
		{T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
		{T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
		{T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
		{T: externglib.Type(C.gtk_string_filter_match_mode_get_type()), F: marshalStringFilterMatchMode},
		{T: externglib.Type(C.gtk_system_setting_get_type()), F: marshalSystemSetting},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
		{T: externglib.Type(C.gtk_builder_closure_flags_get_type()), F: marshalBuilderClosureFlags},
		{T: externglib.Type(C.gtk_cell_renderer_state_get_type()), F: marshalCellRendererState},
		{T: externglib.Type(C.gtk_debug_flags_get_type()), F: marshalDebugFlags},
		{T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
		{T: externglib.Type(C.gtk_event_controller_scroll_flags_get_type()), F: marshalEventControllerScrollFlags},
		{T: externglib.Type(C.gtk_font_chooser_level_get_type()), F: marshalFontChooserLevel},
		{T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
		{T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
		{T: externglib.Type(C.gtk_pick_flags_get_type()), F: marshalPickFlags},
		{T: externglib.Type(C.gtk_popover_menu_flags_get_type()), F: marshalPopoverMenuFlags},
		{T: externglib.Type(C.gtk_print_capabilities_get_type()), F: marshalPrintCapabilities},
		{T: externglib.Type(C.gtk_shortcut_action_flags_get_type()), F: marshalShortcutActionFlags},
		{T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
		{T: externglib.Type(C.gtk_style_context_print_flags_get_type()), F: marshalStyleContextPrintFlags},
		{T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
		{T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
		{T: externglib.Type(C.gtk_accessible_get_type()), F: marshalAccessible},
		{T: externglib.Type(C.gtk_actionable_get_type()), F: marshalActionable},
		{T: externglib.Type(C.gtk_app_chooser_get_type()), F: marshalAppChooser},
		{T: externglib.Type(C.gtk_buildable_get_type()), F: marshalBuildable},
		{T: externglib.Type(C.gtk_builder_scope_get_type()), F: marshalBuilderScope},
		{T: externglib.Type(C.gtk_cell_editable_get_type()), F: marshalCellEditable},
		{T: externglib.Type(C.gtk_cell_layout_get_type()), F: marshalCellLayout},
		{T: externglib.Type(C.gtk_color_chooser_get_type()), F: marshalColorChooser},
		{T: externglib.Type(C.gtk_constraint_target_get_type()), F: marshalConstraintTarget},
		{T: externglib.Type(C.gtk_editable_get_type()), F: marshalEditable},
		{T: externglib.Type(C.gtk_file_chooser_get_type()), F: marshalFileChooser},
		{T: externglib.Type(C.gtk_font_chooser_get_type()), F: marshalFontChooser},
		{T: externglib.Type(C.gtk_native_get_type()), F: marshalNative},
		{T: externglib.Type(C.gtk_orientable_get_type()), F: marshalOrientable},
		{T: externglib.Type(C.gtk_print_operation_preview_get_type()), F: marshalPrintOperationPreview},
		{T: externglib.Type(C.gtk_root_get_type()), F: marshalRoot},
		{T: externglib.Type(C.gtk_scrollable_get_type()), F: marshalScrollable},
		{T: externglib.Type(C.gtk_selection_model_get_type()), F: marshalSelectionModel},
		{T: externglib.Type(C.gtk_shortcut_manager_get_type()), F: marshalShortcutManager},
		{T: externglib.Type(C.gtk_style_provider_get_type()), F: marshalStyleProvider},
		{T: externglib.Type(C.gtk_tree_drag_dest_get_type()), F: marshalTreeDragDest},
		{T: externglib.Type(C.gtk_tree_drag_source_get_type()), F: marshalTreeDragSource},
		{T: externglib.Type(C.gtk_tree_model_get_type()), F: marshalTreeModel},
		{T: externglib.Type(C.gtk_tree_sortable_get_type()), F: marshalTreeSortable},
		{T: externglib.Type(C.gtk_at_context_get_type()), F: marshalATContext},
		{T: externglib.Type(C.gtk_about_dialog_get_type()), F: marshalAboutDialog},
		{T: externglib.Type(C.gtk_action_bar_get_type()), F: marshalActionBar},
		{T: externglib.Type(C.gtk_activate_action_get_type()), F: marshalActivateAction},
		{T: externglib.Type(C.gtk_adjustment_get_type()), F: marshalAdjustment},
		{T: externglib.Type(C.gtk_alternative_trigger_get_type()), F: marshalAlternativeTrigger},
		{T: externglib.Type(C.gtk_any_filter_get_type()), F: marshalAnyFilter},
		{T: externglib.Type(C.gtk_app_chooser_button_get_type()), F: marshalAppChooserButton},
		{T: externglib.Type(C.gtk_app_chooser_dialog_get_type()), F: marshalAppChooserDialog},
		{T: externglib.Type(C.gtk_app_chooser_widget_get_type()), F: marshalAppChooserWidget},
		{T: externglib.Type(C.gtk_application_get_type()), F: marshalApplication},
		{T: externglib.Type(C.gtk_application_window_get_type()), F: marshalApplicationWindow},
		{T: externglib.Type(C.gtk_aspect_frame_get_type()), F: marshalAspectFrame},
		{T: externglib.Type(C.gtk_assistant_get_type()), F: marshalAssistant},
		{T: externglib.Type(C.gtk_assistant_page_get_type()), F: marshalAssistantPage},
		{T: externglib.Type(C.gtk_bin_layout_get_type()), F: marshalBinLayout},
		{T: externglib.Type(C.gtk_bookmark_list_get_type()), F: marshalBookmarkList},
		{T: externglib.Type(C.gtk_bool_filter_get_type()), F: marshalBoolFilter},
		{T: externglib.Type(C.gtk_box_get_type()), F: marshalBox},
		{T: externglib.Type(C.gtk_box_layout_get_type()), F: marshalBoxLayout},
		{T: externglib.Type(C.gtk_builder_get_type()), F: marshalBuilder},
		{T: externglib.Type(C.gtk_builder_cscope_get_type()), F: marshalBuilderCScope},
		{T: externglib.Type(C.gtk_builder_list_item_factory_get_type()), F: marshalBuilderListItemFactory},
		{T: externglib.Type(C.gtk_button_get_type()), F: marshalButton},
		{T: externglib.Type(C.gtk_cclosure_expression_get_type()), F: marshalCClosureExpression},
		{T: externglib.Type(C.gtk_calendar_get_type()), F: marshalCalendar},
		{T: externglib.Type(C.gtk_callback_action_get_type()), F: marshalCallbackAction},
		{T: externglib.Type(C.gtk_cell_area_get_type()), F: marshalCellArea},
		{T: externglib.Type(C.gtk_cell_area_box_get_type()), F: marshalCellAreaBox},
		{T: externglib.Type(C.gtk_cell_area_context_get_type()), F: marshalCellAreaContext},
		{T: externglib.Type(C.gtk_cell_renderer_get_type()), F: marshalCellRenderer},
		{T: externglib.Type(C.gtk_cell_renderer_accel_get_type()), F: marshalCellRendererAccel},
		{T: externglib.Type(C.gtk_cell_renderer_combo_get_type()), F: marshalCellRendererCombo},
		{T: externglib.Type(C.gtk_cell_renderer_pixbuf_get_type()), F: marshalCellRendererPixbuf},
		{T: externglib.Type(C.gtk_cell_renderer_progress_get_type()), F: marshalCellRendererProgress},
		{T: externglib.Type(C.gtk_cell_renderer_spin_get_type()), F: marshalCellRendererSpin},
		{T: externglib.Type(C.gtk_cell_renderer_spinner_get_type()), F: marshalCellRendererSpinner},
		{T: externglib.Type(C.gtk_cell_renderer_text_get_type()), F: marshalCellRendererText},
		{T: externglib.Type(C.gtk_cell_renderer_toggle_get_type()), F: marshalCellRendererToggle},
		{T: externglib.Type(C.gtk_cell_view_get_type()), F: marshalCellView},
		{T: externglib.Type(C.gtk_center_box_get_type()), F: marshalCenterBox},
		{T: externglib.Type(C.gtk_center_layout_get_type()), F: marshalCenterLayout},
		{T: externglib.Type(C.gtk_check_button_get_type()), F: marshalCheckButton},
		{T: externglib.Type(C.gtk_closure_expression_get_type()), F: marshalClosureExpression},
		{T: externglib.Type(C.gtk_color_button_get_type()), F: marshalColorButton},
		{T: externglib.Type(C.gtk_color_chooser_dialog_get_type()), F: marshalColorChooserDialog},
		{T: externglib.Type(C.gtk_color_chooser_widget_get_type()), F: marshalColorChooserWidget},
		{T: externglib.Type(C.gtk_column_view_get_type()), F: marshalColumnView},
		{T: externglib.Type(C.gtk_column_view_column_get_type()), F: marshalColumnViewColumn},
		{T: externglib.Type(C.gtk_combo_box_get_type()), F: marshalComboBox},
		{T: externglib.Type(C.gtk_combo_box_text_get_type()), F: marshalComboBoxText},
		{T: externglib.Type(C.gtk_constant_expression_get_type()), F: marshalConstantExpression},
		{T: externglib.Type(C.gtk_constraint_get_type()), F: marshalConstraint},
		{T: externglib.Type(C.gtk_constraint_guide_get_type()), F: marshalConstraintGuide},
		{T: externglib.Type(C.gtk_constraint_layout_get_type()), F: marshalConstraintLayout},
		{T: externglib.Type(C.gtk_constraint_layout_child_get_type()), F: marshalConstraintLayoutChild},
		{T: externglib.Type(C.gtk_css_provider_get_type()), F: marshalCSSProvider},
		{T: externglib.Type(C.gtk_custom_filter_get_type()), F: marshalCustomFilter},
		{T: externglib.Type(C.gtk_custom_layout_get_type()), F: marshalCustomLayout},
		{T: externglib.Type(C.gtk_custom_sorter_get_type()), F: marshalCustomSorter},
		{T: externglib.Type(C.gtk_dialog_get_type()), F: marshalDialog},
		{T: externglib.Type(C.gtk_directory_list_get_type()), F: marshalDirectoryList},
		{T: externglib.Type(C.gtk_drag_icon_get_type()), F: marshalDragIcon},
		{T: externglib.Type(C.gtk_drag_source_get_type()), F: marshalDragSource},
		{T: externglib.Type(C.gtk_drawing_area_get_type()), F: marshalDrawingArea},
		{T: externglib.Type(C.gtk_drop_controller_motion_get_type()), F: marshalDropControllerMotion},
		{T: externglib.Type(C.gtk_drop_down_get_type()), F: marshalDropDown},
		{T: externglib.Type(C.gtk_drop_target_get_type()), F: marshalDropTarget},
		{T: externglib.Type(C.gtk_drop_target_async_get_type()), F: marshalDropTargetAsync},
		{T: externglib.Type(C.gtk_editable_label_get_type()), F: marshalEditableLabel},
		{T: externglib.Type(C.gtk_emoji_chooser_get_type()), F: marshalEmojiChooser},
		{T: externglib.Type(C.gtk_entry_get_type()), F: marshalEntry},
		{T: externglib.Type(C.gtk_entry_buffer_get_type()), F: marshalEntryBuffer},
		{T: externglib.Type(C.gtk_entry_completion_get_type()), F: marshalEntryCompletion},
		{T: externglib.Type(C.gtk_event_controller_get_type()), F: marshalEventController},
		{T: externglib.Type(C.gtk_event_controller_focus_get_type()), F: marshalEventControllerFocus},
		{T: externglib.Type(C.gtk_event_controller_key_get_type()), F: marshalEventControllerKey},
		{T: externglib.Type(C.gtk_event_controller_legacy_get_type()), F: marshalEventControllerLegacy},
		{T: externglib.Type(C.gtk_event_controller_motion_get_type()), F: marshalEventControllerMotion},
		{T: externglib.Type(C.gtk_event_controller_scroll_get_type()), F: marshalEventControllerScroll},
		{T: externglib.Type(C.gtk_every_filter_get_type()), F: marshalEveryFilter},
		{T: externglib.Type(C.gtk_expander_get_type()), F: marshalExpander},
		{T: externglib.Type(C.gtk_file_chooser_dialog_get_type()), F: marshalFileChooserDialog},
		{T: externglib.Type(C.gtk_file_chooser_native_get_type()), F: marshalFileChooserNative},
		{T: externglib.Type(C.gtk_file_chooser_widget_get_type()), F: marshalFileChooserWidget},
		{T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
		{T: externglib.Type(C.gtk_filter_get_type()), F: marshalFilter},
		{T: externglib.Type(C.gtk_filter_list_model_get_type()), F: marshalFilterListModel},
		{T: externglib.Type(C.gtk_fixed_get_type()), F: marshalFixed},
		{T: externglib.Type(C.gtk_fixed_layout_get_type()), F: marshalFixedLayout},
		{T: externglib.Type(C.gtk_fixed_layout_child_get_type()), F: marshalFixedLayoutChild},
		{T: externglib.Type(C.gtk_flatten_list_model_get_type()), F: marshalFlattenListModel},
		{T: externglib.Type(C.gtk_flow_box_get_type()), F: marshalFlowBox},
		{T: externglib.Type(C.gtk_flow_box_child_get_type()), F: marshalFlowBoxChild},
		{T: externglib.Type(C.gtk_font_button_get_type()), F: marshalFontButton},
		{T: externglib.Type(C.gtk_font_chooser_dialog_get_type()), F: marshalFontChooserDialog},
		{T: externglib.Type(C.gtk_font_chooser_widget_get_type()), F: marshalFontChooserWidget},
		{T: externglib.Type(C.gtk_frame_get_type()), F: marshalFrame},
		{T: externglib.Type(C.gtk_gl_area_get_type()), F: marshalGLArea},
		{T: externglib.Type(C.gtk_gesture_get_type()), F: marshalGesture},
		{T: externglib.Type(C.gtk_gesture_click_get_type()), F: marshalGestureClick},
		{T: externglib.Type(C.gtk_gesture_drag_get_type()), F: marshalGestureDrag},
		{T: externglib.Type(C.gtk_gesture_long_press_get_type()), F: marshalGestureLongPress},
		{T: externglib.Type(C.gtk_gesture_pan_get_type()), F: marshalGesturePan},
		{T: externglib.Type(C.gtk_gesture_rotate_get_type()), F: marshalGestureRotate},
		{T: externglib.Type(C.gtk_gesture_single_get_type()), F: marshalGestureSingle},
		{T: externglib.Type(C.gtk_gesture_stylus_get_type()), F: marshalGestureStylus},
		{T: externglib.Type(C.gtk_gesture_swipe_get_type()), F: marshalGestureSwipe},
		{T: externglib.Type(C.gtk_gesture_zoom_get_type()), F: marshalGestureZoom},
		{T: externglib.Type(C.gtk_grid_get_type()), F: marshalGrid},
		{T: externglib.Type(C.gtk_grid_layout_get_type()), F: marshalGridLayout},
		{T: externglib.Type(C.gtk_grid_layout_child_get_type()), F: marshalGridLayoutChild},
		{T: externglib.Type(C.gtk_grid_view_get_type()), F: marshalGridView},
		{T: externglib.Type(C.gtk_header_bar_get_type()), F: marshalHeaderBar},
		{T: externglib.Type(C.gtk_im_context_get_type()), F: marshalIMContext},
		{T: externglib.Type(C.gtk_im_context_simple_get_type()), F: marshalIMContextSimple},
		{T: externglib.Type(C.gtk_im_multicontext_get_type()), F: marshalIMMulticontext},
		{T: externglib.Type(C.gtk_icon_paintable_get_type()), F: marshalIconPaintable},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
		{T: externglib.Type(C.gtk_icon_view_get_type()), F: marshalIconView},
		{T: externglib.Type(C.gtk_image_get_type()), F: marshalImage},
		{T: externglib.Type(C.gtk_info_bar_get_type()), F: marshalInfoBar},
		{T: externglib.Type(C.gtk_keyval_trigger_get_type()), F: marshalKeyvalTrigger},
		{T: externglib.Type(C.gtk_label_get_type()), F: marshalLabel},
		{T: externglib.Type(C.gtk_layout_child_get_type()), F: marshalLayoutChild},
		{T: externglib.Type(C.gtk_layout_manager_get_type()), F: marshalLayoutManager},
		{T: externglib.Type(C.gtk_level_bar_get_type()), F: marshalLevelBar},
		{T: externglib.Type(C.gtk_link_button_get_type()), F: marshalLinkButton},
		{T: externglib.Type(C.gtk_list_base_get_type()), F: marshalListBase},
		{T: externglib.Type(C.gtk_list_box_get_type()), F: marshalListBox},
		{T: externglib.Type(C.gtk_list_box_row_get_type()), F: marshalListBoxRow},
		{T: externglib.Type(C.gtk_list_item_get_type()), F: marshalListItem},
		{T: externglib.Type(C.gtk_list_item_factory_get_type()), F: marshalListItemFactory},
		{T: externglib.Type(C.gtk_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.gtk_list_view_get_type()), F: marshalListView},
		{T: externglib.Type(C.gtk_lock_button_get_type()), F: marshalLockButton},
		{T: externglib.Type(C.gtk_map_list_model_get_type()), F: marshalMapListModel},
		{T: externglib.Type(C.gtk_media_controls_get_type()), F: marshalMediaControls},
		{T: externglib.Type(C.gtk_media_file_get_type()), F: marshalMediaFile},
		{T: externglib.Type(C.gtk_media_stream_get_type()), F: marshalMediaStream},
		{T: externglib.Type(C.gtk_menu_button_get_type()), F: marshalMenuButton},
		{T: externglib.Type(C.gtk_message_dialog_get_type()), F: marshalMessageDialog},
		{T: externglib.Type(C.gtk_mnemonic_action_get_type()), F: marshalMnemonicAction},
		{T: externglib.Type(C.gtk_mnemonic_trigger_get_type()), F: marshalMnemonicTrigger},
		{T: externglib.Type(C.gtk_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.gtk_multi_filter_get_type()), F: marshalMultiFilter},
		{T: externglib.Type(C.gtk_multi_selection_get_type()), F: marshalMultiSelection},
		{T: externglib.Type(C.gtk_multi_sorter_get_type()), F: marshalMultiSorter},
		{T: externglib.Type(C.gtk_named_action_get_type()), F: marshalNamedAction},
		{T: externglib.Type(C.gtk_native_dialog_get_type()), F: marshalNativeDialog},
		{T: externglib.Type(C.gtk_never_trigger_get_type()), F: marshalNeverTrigger},
		{T: externglib.Type(C.gtk_no_selection_get_type()), F: marshalNoSelection},
		{T: externglib.Type(C.gtk_notebook_get_type()), F: marshalNotebook},
		{T: externglib.Type(C.gtk_notebook_page_get_type()), F: marshalNotebookPage},
		{T: externglib.Type(C.gtk_nothing_action_get_type()), F: marshalNothingAction},
		{T: externglib.Type(C.gtk_numeric_sorter_get_type()), F: marshalNumericSorter},
		{T: externglib.Type(C.gtk_object_expression_get_type()), F: marshalObjectExpression},
		{T: externglib.Type(C.gtk_overlay_get_type()), F: marshalOverlay},
		{T: externglib.Type(C.gtk_overlay_layout_get_type()), F: marshalOverlayLayout},
		{T: externglib.Type(C.gtk_overlay_layout_child_get_type()), F: marshalOverlayLayoutChild},
		{T: externglib.Type(C.gtk_pad_controller_get_type()), F: marshalPadController},
		{T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
		{T: externglib.Type(C.gtk_page_setup_unix_dialog_get_type()), F: marshalPageSetupUnixDialog},
		{T: externglib.Type(C.gtk_paned_get_type()), F: marshalPaned},
		{T: externglib.Type(C.gtk_password_entry_get_type()), F: marshalPasswordEntry},
		{T: externglib.Type(C.gtk_picture_get_type()), F: marshalPicture},
		{T: externglib.Type(C.gtk_popover_get_type()), F: marshalPopover},
		{T: externglib.Type(C.gtk_popover_menu_get_type()), F: marshalPopoverMenu},
		{T: externglib.Type(C.gtk_popover_menu_bar_get_type()), F: marshalPopoverMenuBar},
		{T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
		{T: externglib.Type(C.gtk_print_job_get_type()), F: marshalPrintJob},
		{T: externglib.Type(C.gtk_print_operation_get_type()), F: marshalPrintOperation},
		{T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
		{T: externglib.Type(C.gtk_print_unix_dialog_get_type()), F: marshalPrintUnixDialog},
		{T: externglib.Type(C.gtk_printer_get_type()), F: marshalPrinter},
		{T: externglib.Type(C.gtk_progress_bar_get_type()), F: marshalProgressBar},
		{T: externglib.Type(C.gtk_property_expression_get_type()), F: marshalPropertyExpression},
		{T: externglib.Type(C.gtk_range_get_type()), F: marshalRange},
		{T: externglib.Type(C.gtk_recent_manager_get_type()), F: marshalRecentManager},
		{T: externglib.Type(C.gtk_revealer_get_type()), F: marshalRevealer},
		{T: externglib.Type(C.gtk_scale_get_type()), F: marshalScale},
		{T: externglib.Type(C.gtk_scale_button_get_type()), F: marshalScaleButton},
		{T: externglib.Type(C.gtk_scrollbar_get_type()), F: marshalScrollbar},
		{T: externglib.Type(C.gtk_scrolled_window_get_type()), F: marshalScrolledWindow},
		{T: externglib.Type(C.gtk_search_bar_get_type()), F: marshalSearchBar},
		{T: externglib.Type(C.gtk_search_entry_get_type()), F: marshalSearchEntry},
		{T: externglib.Type(C.gtk_selection_filter_model_get_type()), F: marshalSelectionFilterModel},
		{T: externglib.Type(C.gtk_separator_get_type()), F: marshalSeparator},
		{T: externglib.Type(C.gtk_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.gtk_shortcut_get_type()), F: marshalShortcut},
		{T: externglib.Type(C.gtk_shortcut_action_get_type()), F: marshalShortcutAction},
		{T: externglib.Type(C.gtk_shortcut_controller_get_type()), F: marshalShortcutController},
		{T: externglib.Type(C.gtk_shortcut_label_get_type()), F: marshalShortcutLabel},
		{T: externglib.Type(C.gtk_shortcut_trigger_get_type()), F: marshalShortcutTrigger},
		{T: externglib.Type(C.gtk_shortcuts_group_get_type()), F: marshalShortcutsGroup},
		{T: externglib.Type(C.gtk_shortcuts_section_get_type()), F: marshalShortcutsSection},
		{T: externglib.Type(C.gtk_shortcuts_shortcut_get_type()), F: marshalShortcutsShortcut},
		{T: externglib.Type(C.gtk_shortcuts_window_get_type()), F: marshalShortcutsWindow},
		{T: externglib.Type(C.gtk_signal_action_get_type()), F: marshalSignalAction},
		{T: externglib.Type(C.gtk_signal_list_item_factory_get_type()), F: marshalSignalListItemFactory},
		{T: externglib.Type(C.gtk_single_selection_get_type()), F: marshalSingleSelection},
		{T: externglib.Type(C.gtk_size_group_get_type()), F: marshalSizeGroup},
		{T: externglib.Type(C.gtk_slice_list_model_get_type()), F: marshalSliceListModel},
		{T: externglib.Type(C.gtk_snapshot_get_type()), F: marshalSnapshot},
		{T: externglib.Type(C.gtk_sort_list_model_get_type()), F: marshalSortListModel},
		{T: externglib.Type(C.gtk_sorter_get_type()), F: marshalSorter},
		{T: externglib.Type(C.gtk_spin_button_get_type()), F: marshalSpinButton},
		{T: externglib.Type(C.gtk_spinner_get_type()), F: marshalSpinner},
		{T: externglib.Type(C.gtk_stack_get_type()), F: marshalStack},
		{T: externglib.Type(C.gtk_stack_page_get_type()), F: marshalStackPage},
		{T: externglib.Type(C.gtk_stack_sidebar_get_type()), F: marshalStackSidebar},
		{T: externglib.Type(C.gtk_stack_switcher_get_type()), F: marshalStackSwitcher},
		{T: externglib.Type(C.gtk_statusbar_get_type()), F: marshalStatusbar},
		{T: externglib.Type(C.gtk_string_filter_get_type()), F: marshalStringFilter},
		{T: externglib.Type(C.gtk_string_sorter_get_type()), F: marshalStringSorter},
		{T: externglib.Type(C.gtk_style_context_get_type()), F: marshalStyleContext},
		{T: externglib.Type(C.gtk_switch_get_type()), F: marshalSwitch},
		{T: externglib.Type(C.gtk_text_get_type()), F: marshalText},
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
		{T: externglib.Type(C.gtk_text_child_anchor_get_type()), F: marshalTextChildAnchor},
		{T: externglib.Type(C.gtk_text_mark_get_type()), F: marshalTextMark},
		{T: externglib.Type(C.gtk_text_tag_get_type()), F: marshalTextTag},
		{T: externglib.Type(C.gtk_text_tag_table_get_type()), F: marshalTextTagTable},
		{T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextView},
		{T: externglib.Type(C.gtk_toggle_button_get_type()), F: marshalToggleButton},
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
		{T: externglib.Type(C.gtk_tree_expander_get_type()), F: marshalTreeExpander},
		{T: externglib.Type(C.gtk_tree_list_model_get_type()), F: marshalTreeListModel},
		{T: externglib.Type(C.gtk_tree_list_row_get_type()), F: marshalTreeListRow},
		{T: externglib.Type(C.gtk_tree_list_row_sorter_get_type()), F: marshalTreeListRowSorter},
		{T: externglib.Type(C.gtk_tree_model_filter_get_type()), F: marshalTreeModelFilter},
		{T: externglib.Type(C.gtk_tree_model_sort_get_type()), F: marshalTreeModelSort},
		{T: externglib.Type(C.gtk_tree_selection_get_type()), F: marshalTreeSelection},
		{T: externglib.Type(C.gtk_tree_store_get_type()), F: marshalTreeStore},
		{T: externglib.Type(C.gtk_tree_view_get_type()), F: marshalTreeView},
		{T: externglib.Type(C.gtk_tree_view_column_get_type()), F: marshalTreeViewColumn},
		{T: externglib.Type(C.gtk_video_get_type()), F: marshalVideo},
		{T: externglib.Type(C.gtk_viewport_get_type()), F: marshalViewport},
		{T: externglib.Type(C.gtk_volume_button_get_type()), F: marshalVolumeButton},
		{T: externglib.Type(C.gtk_widget_get_type()), F: marshalWidget},
		{T: externglib.Type(C.gtk_widget_paintable_get_type()), F: marshalWidgetPaintable},
		{T: externglib.Type(C.gtk_window_get_type()), F: marshalWindow},
		{T: externglib.Type(C.gtk_window_controls_get_type()), F: marshalWindowControls},
		{T: externglib.Type(C.gtk_window_group_get_type()), F: marshalWindowGroup},
		{T: externglib.Type(C.gtk_window_handle_get_type()), F: marshalWindowHandle},
		{T: externglib.Type(C.gtk_bitset_get_type()), F: marshalBitset},
		{T: externglib.Type(C.gtk_border_get_type()), F: marshalBorder},
		{T: externglib.Type(C.gtk_css_section_get_type()), F: marshalCSSSection},
		{T: externglib.Type(C.gtk_expression_watch_get_type()), F: marshalExpressionWatch},
		{T: externglib.Type(C.gtk_paper_size_get_type()), F: marshalPaperSize},
		{T: externglib.Type(C.gtk_recent_info_get_type()), F: marshalRecentInfo},
		{T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
		{T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
		{T: externglib.Type(C.gtk_tree_iter_get_type()), F: marshalTreeIter},
		{T: externglib.Type(C.gtk_tree_path_get_type()), F: marshalTreePath},
		{T: externglib.Type(C.gtk_tree_row_reference_get_type()), F: marshalTreeRowReference},
	})
}

// Allocation: the rectangle representing the area allocated for a widget by its
// parent.
type Allocation = gdk.Rectangle

// AccessibleAutocomplete: the possible values for the
// GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE accessible property.
type AccessibleAutocomplete int

const (
	// AccessibleAutocompleteNone: automatic suggestions are not displayed.
	AccessibleAutocompleteNone AccessibleAutocomplete = 0
	// AccessibleAutocompleteInline: when a user is providing input, text
	// suggesting one way to complete the provided input may be dynamically
	// inserted after the caret.
	AccessibleAutocompleteInline AccessibleAutocomplete = 1
	// AccessibleAutocompleteList: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed.
	AccessibleAutocompleteList AccessibleAutocomplete = 2
	// AccessibleAutocompleteBoth: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed. If displayed, one value in the collection is
	// automatically selected, and the text needed to complete the automatically
	// selected value appears after the caret in the input.
	AccessibleAutocompleteBoth AccessibleAutocomplete = 3
)

func marshalAccessibleAutocomplete(p uintptr) (interface{}, error) {
	return AccessibleAutocomplete(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleInvalidState: the possible values for the
// GTK_ACCESSIBLE_STATE_INVALID accessible state.
//
// Note that the GTK_ACCESSIBLE_INVALID_FALSE and GTK_ACCESSIBLE_INVALID_TRUE
// have the same values as false and true.
type AccessibleInvalidState int

const (
	// AccessibleInvalidStateFalse: there are no detected errors in the value
	AccessibleInvalidStateFalse AccessibleInvalidState = 0
	// AccessibleInvalidStateTrue: the value entered by the user has failed
	// validation
	AccessibleInvalidStateTrue AccessibleInvalidState = 1
	// AccessibleInvalidStateGrammar: a grammatical error was detected
	AccessibleInvalidStateGrammar AccessibleInvalidState = 2
	// AccessibleInvalidStateSpelling: a spelling error was detected
	AccessibleInvalidStateSpelling AccessibleInvalidState = 3
)

func marshalAccessibleInvalidState(p uintptr) (interface{}, error) {
	return AccessibleInvalidState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleProperty: the possible accessible properties of a `GtkAccessible`.
type AccessibleProperty int

const (
	// AccessiblePropertyAutocomplete indicates whether inputting text could
	// trigger display of one or more predictions of the user's intended value
	// for a combobox, searchbox, or textbox and specifies how predictions would
	// be presented if they were made. Value type: AccessibleAutocomplete
	AccessiblePropertyAutocomplete AccessibleProperty = 0
	// AccessiblePropertyDescription defines a string value that describes or
	// annotates the current element. Value type: string
	AccessiblePropertyDescription AccessibleProperty = 1
	// AccessiblePropertyHasPopup indicates the availability and type of
	// interactive popup element, such as menu or dialog, that can be triggered
	// by an element.
	AccessiblePropertyHasPopup AccessibleProperty = 2
	// AccessiblePropertyKeyShortcuts indicates keyboard shortcuts that an
	// author has implemented to activate or give focus to an element. Value
	// type: string
	AccessiblePropertyKeyShortcuts AccessibleProperty = 3
	// AccessiblePropertyLabel defines a string value that labels the current
	// element. Value type: string
	AccessiblePropertyLabel AccessibleProperty = 4
	// AccessiblePropertyLevel defines the hierarchical level of an element
	// within a structure. Value type: integer
	AccessiblePropertyLevel AccessibleProperty = 5
	// AccessiblePropertyModal indicates whether an element is modal when
	// displayed. Value type: boolean
	AccessiblePropertyModal AccessibleProperty = 6
	// AccessiblePropertyMultiLine indicates whether a text box accepts multiple
	// lines of input or only a single line. Value type: boolean
	AccessiblePropertyMultiLine AccessibleProperty = 7
	// AccessiblePropertyMultiSelectable indicates that the user may select more
	// than one item from the current selectable descendants. Value type:
	// boolean
	AccessiblePropertyMultiSelectable AccessibleProperty = 8
	// AccessiblePropertyOrientation indicates whether the element's orientation
	// is horizontal, vertical, or unknown/ambiguous. Value type: Orientation
	AccessiblePropertyOrientation AccessibleProperty = 9
	// AccessiblePropertyPlaceholder defines a short hint (a word or short
	// phrase) intended to aid the user with data entry when the control has no
	// value. A hint could be a sample value or a brief description of the
	// expected format. Value type: string
	AccessiblePropertyPlaceholder AccessibleProperty = 10
	// AccessiblePropertyReadOnly indicates that the element is not editable,
	// but is otherwise operable. Value type: boolean
	AccessiblePropertyReadOnly AccessibleProperty = 11
	// AccessiblePropertyRequired indicates that user input is required on the
	// element before a form may be submitted. Value type: boolean
	AccessiblePropertyRequired AccessibleProperty = 12
	// AccessiblePropertyRoleDescription defines a human-readable,
	// author-localized description for the role of an element. Value type:
	// string
	AccessiblePropertyRoleDescription AccessibleProperty = 13
	// AccessiblePropertySort indicates if items in a table or grid are sorted
	// in ascending or descending order. Possible property values are in the
	// AccessibleSort enumeration. Value type: AccessibleSort
	AccessiblePropertySort AccessibleProperty = 14
	// AccessiblePropertyValueMax defines the maximum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMax AccessibleProperty = 15
	// AccessiblePropertyValueMin defines the minimum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMin AccessibleProperty = 16
	// AccessiblePropertyValueNow defines the current value for a range widget.
	// Value type: double
	AccessiblePropertyValueNow AccessibleProperty = 17
	// AccessiblePropertyValueText defines the human readable text alternative
	// of aria-valuenow for a range widget. Value type: string
	AccessiblePropertyValueText AccessibleProperty = 18
)

func marshalAccessibleProperty(p uintptr) (interface{}, error) {
	return AccessibleProperty(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRelation: the possible accessible relations of a `GtkAccessible`.
//
// Accessible relations can be references to other widgets, integers or strings.
type AccessibleRelation int

const (
	// AccessibleRelationActiveDescendant identifies the currently active
	// element when focus is on a composite widget, combobox, textbox, group, or
	// application. Value type: reference
	AccessibleRelationActiveDescendant AccessibleRelation = 0
	// AccessibleRelationColCount defines the total number of columns in a
	// table, grid, or treegrid. Value type: integer
	AccessibleRelationColCount AccessibleRelation = 1
	// AccessibleRelationColIndex defines an element's column index or position
	// with respect to the total number of columns within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationColIndex AccessibleRelation = 2
	// AccessibleRelationColIndexText defines a human readable text alternative
	// of GTK_ACCESSIBLE_RELATION_COL_INDEX. Value type: string
	AccessibleRelationColIndexText AccessibleRelation = 3
	// AccessibleRelationColSpan defines the number of columns spanned by a cell
	// or gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationColSpan AccessibleRelation = 4
	// AccessibleRelationControls identifies the element (or elements) whose
	// contents or presence are controlled by the current element. Value type:
	// reference
	AccessibleRelationControls AccessibleRelation = 5
	// AccessibleRelationDescribedBy identifies the element (or elements) that
	// describes the object. Value type: reference
	AccessibleRelationDescribedBy AccessibleRelation = 6
	// AccessibleRelationDetails identifies the element (or elements) that
	// provide additional information related to the object. Value type:
	// reference
	AccessibleRelationDetails AccessibleRelation = 7
	// AccessibleRelationErrorMessage identifies the element that provides an
	// error message for an object. Value type: reference
	AccessibleRelationErrorMessage AccessibleRelation = 8
	// AccessibleRelationFlowTo identifies the next element (or elements) in an
	// alternate reading order of content which, at the user's discretion,
	// allows assistive technology to override the general default of reading in
	// document source order. Value type: reference
	AccessibleRelationFlowTo AccessibleRelation = 9
	// AccessibleRelationLabelledBy identifies the element (or elements) that
	// labels the current element. Value type: reference
	AccessibleRelationLabelledBy AccessibleRelation = 10
	// AccessibleRelationOwns identifies an element (or elements) in order to
	// define a visual, functional, or contextual parent/child relationship
	// between elements where the widget hierarchy cannot be used to represent
	// the relationship. Value type: reference
	AccessibleRelationOwns AccessibleRelation = 11
	// AccessibleRelationPosInSet defines an element's number or position in the
	// current set of listitems or treeitems. Value type: integer
	AccessibleRelationPosInSet AccessibleRelation = 12
	// AccessibleRelationRowCount defines the total number of rows in a table,
	// grid, or treegrid. Value type: integer
	AccessibleRelationRowCount AccessibleRelation = 13
	// AccessibleRelationRowIndex defines an element's row index or position
	// with respect to the total number of rows within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationRowIndex AccessibleRelation = 14
	// AccessibleRelationRowIndexText defines a human readable text alternative
	// of aria-rowindex. Value type: string
	AccessibleRelationRowIndexText AccessibleRelation = 15
	// AccessibleRelationRowSpan defines the number of rows spanned by a cell or
	// gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationRowSpan AccessibleRelation = 16
	// AccessibleRelationSetSize defines the number of items in the current set
	// of listitems or treeitems. Value type: integer
	AccessibleRelationSetSize AccessibleRelation = 17
)

func marshalAccessibleRelation(p uintptr) (interface{}, error) {
	return AccessibleRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRole: the accessible role for a `GtkAccessible` implementation.
//
// Abstract roles are only used as part of the ontology; application developers
// must not use abstract roles in their code.
type AccessibleRole int

const (
	// AccessibleRoleAlert: an element with important, and usually
	// time-sensitive, information
	AccessibleRoleAlert AccessibleRole = 0
	// AccessibleRoleAlertDialog: a type of dialog that contains an alert
	// message
	AccessibleRoleAlertDialog AccessibleRole = 1
	// AccessibleRoleBanner: unused
	AccessibleRoleBanner AccessibleRole = 2
	// AccessibleRoleButton: an input element that allows for user-triggered
	// actions when clicked or pressed
	AccessibleRoleButton AccessibleRole = 3
	// AccessibleRoleCaption: unused
	AccessibleRoleCaption AccessibleRole = 4
	// AccessibleRoleCell: unused
	AccessibleRoleCell AccessibleRole = 5
	// AccessibleRoleCheckbox: a checkable input element that has three possible
	// values: `true`, `false`, or `mixed`
	AccessibleRoleCheckbox AccessibleRole = 6
	// AccessibleRoleColumnHeader: a header in a columned list.
	AccessibleRoleColumnHeader AccessibleRole = 7
	// AccessibleRoleComboBox: an input that controls another element, such as a
	// list or a grid, that can dynamically pop up to help the user set the
	// value of the input
	AccessibleRoleComboBox AccessibleRole = 8
	// AccessibleRoleCommand: abstract role.
	AccessibleRoleCommand AccessibleRole = 9
	// AccessibleRoleComposite: abstract role.
	AccessibleRoleComposite AccessibleRole = 10
	// AccessibleRoleDialog: a dialog is a window that is designed to interrupt
	// the current processing of an application in order to prompt the user to
	// enter information or require a response.
	AccessibleRoleDialog AccessibleRole = 11
	// AccessibleRoleDocument: unused
	AccessibleRoleDocument AccessibleRole = 12
	// AccessibleRoleFeed: unused
	AccessibleRoleFeed AccessibleRole = 13
	// AccessibleRoleForm: unused
	AccessibleRoleForm AccessibleRole = 14
	// AccessibleRoleGeneric: unused
	AccessibleRoleGeneric AccessibleRole = 15
	// AccessibleRoleGrid: a grid of items.
	AccessibleRoleGrid AccessibleRole = 16
	// AccessibleRoleGridCell: an item in a grid or tree grid.
	AccessibleRoleGridCell AccessibleRole = 17
	// AccessibleRoleGroup: an element that groups multiple widgets. GTK uses
	// this role for various containers, like Box, Viewport, and HeaderBar.
	AccessibleRoleGroup AccessibleRole = 18
	// AccessibleRoleHeading: unused
	AccessibleRoleHeading AccessibleRole = 19
	// AccessibleRoleImg: an image.
	AccessibleRoleImg AccessibleRole = 20
	// AccessibleRoleInput: abstract role.
	AccessibleRoleInput AccessibleRole = 21
	// AccessibleRoleLabel: a visible name or caption for a user interface
	// component.
	AccessibleRoleLabel AccessibleRole = 22
	// AccessibleRoleLandmark: abstract role.
	AccessibleRoleLandmark AccessibleRole = 23
	// AccessibleRoleLegend: unused
	AccessibleRoleLegend AccessibleRole = 24
	// AccessibleRoleLink: a clickable link.
	AccessibleRoleLink AccessibleRole = 25
	// AccessibleRoleList: a list of items.
	AccessibleRoleList AccessibleRole = 26
	// AccessibleRoleListBox: unused.
	AccessibleRoleListBox AccessibleRole = 27
	// AccessibleRoleListItem: an item in a list.
	AccessibleRoleListItem AccessibleRole = 28
	// AccessibleRoleLog: unused
	AccessibleRoleLog AccessibleRole = 29
	// AccessibleRoleMain: unused
	AccessibleRoleMain AccessibleRole = 30
	// AccessibleRoleMarquee: unused
	AccessibleRoleMarquee AccessibleRole = 31
	// AccessibleRoleMath: unused
	AccessibleRoleMath AccessibleRole = 32
	// AccessibleRoleMeter: an element that represents a value within a known
	// range.
	AccessibleRoleMeter AccessibleRole = 33
	// AccessibleRoleMenu: a menu.
	AccessibleRoleMenu AccessibleRole = 34
	// AccessibleRoleMenuBar: a menubar.
	AccessibleRoleMenuBar AccessibleRole = 35
	// AccessibleRoleMenuItem: an item in a menu.
	AccessibleRoleMenuItem AccessibleRole = 36
	// AccessibleRoleMenuItemCheckbox: a check item in a menu.
	AccessibleRoleMenuItemCheckbox AccessibleRole = 37
	// AccessibleRoleMenuItemRadio: a radio item in a menu.
	AccessibleRoleMenuItemRadio AccessibleRole = 38
	// AccessibleRoleNavigation: unused
	AccessibleRoleNavigation AccessibleRole = 39
	// AccessibleRoleNone: an element that is not represented to accessibility
	// technologies.
	AccessibleRoleNone AccessibleRole = 40
	// AccessibleRoleNote: unused
	AccessibleRoleNote AccessibleRole = 41
	// AccessibleRoleOption: unused
	AccessibleRoleOption AccessibleRole = 42
	// AccessibleRolePresentation: an element that is not represented to
	// accessibility technologies.
	AccessibleRolePresentation AccessibleRole = 43
	// AccessibleRoleProgressBar: an element that displays the progress status
	// for tasks that take a long time.
	AccessibleRoleProgressBar AccessibleRole = 44
	// AccessibleRoleRadio: a checkable input in a group of radio roles, only
	// one of which can be checked at a time.
	AccessibleRoleRadio AccessibleRole = 45
	// AccessibleRoleRadioGroup: unused
	AccessibleRoleRadioGroup AccessibleRole = 46
	// AccessibleRoleRange: abstract role.
	AccessibleRoleRange AccessibleRole = 47
	// AccessibleRoleRegion: unused
	AccessibleRoleRegion AccessibleRole = 48
	// AccessibleRoleRow: a row in a columned list.
	AccessibleRoleRow AccessibleRole = 49
	// AccessibleRoleRowGroup: unused
	AccessibleRoleRowGroup AccessibleRole = 50
	// AccessibleRoleRowHeader: unused
	AccessibleRoleRowHeader AccessibleRole = 51
	// AccessibleRoleScrollbar: a graphical object that controls the scrolling
	// of content within a viewing area, regardless of whether the content is
	// fully displayed within the viewing area.
	AccessibleRoleScrollbar AccessibleRole = 52
	// AccessibleRoleSearch: unused
	AccessibleRoleSearch AccessibleRole = 53
	// AccessibleRoleSearchBox: a type of textbox intended for specifying search
	// criteria.
	AccessibleRoleSearchBox AccessibleRole = 54
	// AccessibleRoleSection: abstract role.
	AccessibleRoleSection AccessibleRole = 55
	// AccessibleRoleSectionHead: abstract role.
	AccessibleRoleSectionHead AccessibleRole = 56
	// AccessibleRoleSelect: abstract role.
	AccessibleRoleSelect AccessibleRole = 57
	// AccessibleRoleSeparator: a divider that separates and distinguishes
	// sections of content or groups of menuitems.
	AccessibleRoleSeparator AccessibleRole = 58
	// AccessibleRoleSlider: a user input where the user selects a value from
	// within a given range.
	AccessibleRoleSlider AccessibleRole = 59
	// AccessibleRoleSpinButton: a form of range that expects the user to select
	// from among discrete choices.
	AccessibleRoleSpinButton AccessibleRole = 60
	// AccessibleRoleStatus: unused
	AccessibleRoleStatus AccessibleRole = 61
	// AccessibleRoleStructure: abstract role.
	AccessibleRoleStructure AccessibleRole = 62
	// AccessibleRoleSwitch: a type of checkbox that represents on/off values,
	// as opposed to checked/unchecked values.
	AccessibleRoleSwitch AccessibleRole = 63
	// AccessibleRoleTab: an item in a list of tab used for switching pages.
	AccessibleRoleTab AccessibleRole = 64
	// AccessibleRoleTable: unused
	AccessibleRoleTable AccessibleRole = 65
	// AccessibleRoleTabList: a list of tabs for switching pages.
	AccessibleRoleTabList AccessibleRole = 66
	// AccessibleRoleTabPanel: a page in a notebook or stack.
	AccessibleRoleTabPanel AccessibleRole = 67
	// AccessibleRoleTextBox: a type of input that allows free-form text as its
	// value.
	AccessibleRoleTextBox AccessibleRole = 68
	// AccessibleRoleTime: unused
	AccessibleRoleTime AccessibleRole = 69
	// AccessibleRoleTimer: unused
	AccessibleRoleTimer AccessibleRole = 70
	// AccessibleRoleToolbar: unused
	AccessibleRoleToolbar AccessibleRole = 71
	// AccessibleRoleTooltip: unused
	AccessibleRoleTooltip AccessibleRole = 72
	// AccessibleRoleTree: unused
	AccessibleRoleTree AccessibleRole = 73
	// AccessibleRoleTreeGrid: a treeview-like, columned list.
	AccessibleRoleTreeGrid AccessibleRole = 74
	// AccessibleRoleTreeItem: unused
	AccessibleRoleTreeItem AccessibleRole = 75
	// AccessibleRoleWidget: an interactive component of a graphical user
	// interface. This is the role that GTK uses by default for widgets.
	AccessibleRoleWidget AccessibleRole = 76
	// AccessibleRoleWindow: an application window.
	AccessibleRoleWindow AccessibleRole = 77
)

func marshalAccessibleRole(p uintptr) (interface{}, error) {
	return AccessibleRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleSort: the possible values for the GTK_ACCESSIBLE_PROPERTY_SORT
// accessible property.
type AccessibleSort int

const (
	// AccessibleSortNone: there is no defined sort applied to the column.
	AccessibleSortNone AccessibleSort = 0
	// AccessibleSortAscending items are sorted in ascending order by this
	// column.
	AccessibleSortAscending AccessibleSort = 1
	// AccessibleSortDescending items are sorted in descending order by this
	// column.
	AccessibleSortDescending AccessibleSort = 2
	// AccessibleSortOther: a sort algorithm other than ascending or descending
	// has been applied.
	AccessibleSortOther AccessibleSort = 3
)

func marshalAccessibleSort(p uintptr) (interface{}, error) {
	return AccessibleSort(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleState: the possible accessible states of a `GtkAccessible`.
type AccessibleState int

const (
	// AccessibleStateBusy: a busy state. This state has boolean values
	AccessibleStateBusy AccessibleState = 0
	// AccessibleStateChecked: a checked state; indicates the current state of
	// a CheckButton. Value type: AccessibleTristate
	AccessibleStateChecked AccessibleState = 1
	// AccessibleStateDisabled: a disabled state; corresponds to the
	// Widget:sensitive property on Widget. It indicates a UI element that is
	// perceivable, but not editable or operable. Value type: boolean
	AccessibleStateDisabled AccessibleState = 2
	// AccessibleStateExpanded: an expanded state; corresponds to the
	// Expander:expanded property on Expander. Value type: boolean or undefined
	AccessibleStateExpanded AccessibleState = 3
	// AccessibleStateHidden: a hidden state; corresponds to the
	// Widget:visible property on Widget. You can use this state explicitly on
	// UI elements that should not be exposed to an assistive technology. Value
	// type: boolean See also: GTK_ACCESSIBLE_STATE_DISABLED
	AccessibleStateHidden AccessibleState = 4
	// AccessibleStateInvalid: an invalid state; set when a widget is showing
	// an error. Value type: AccessibleInvalidState
	AccessibleStateInvalid AccessibleState = 5
	// AccessibleStatePressed: a pressed state; indicates the current state of
	// a ToggleButton. Value type: AccessibleTristate enumeration
	AccessibleStatePressed AccessibleState = 6
	// AccessibleStateSelected: a selected state; set when a widget is
	// selected. Value type: boolean or undefined
	AccessibleStateSelected AccessibleState = 7
)

func marshalAccessibleState(p uintptr) (interface{}, error) {
	return AccessibleState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleTristate: the possible values for the GTK_ACCESSIBLE_STATE_PRESSED
// accessible state.
//
// Note that the GTK_ACCESSIBLE_TRISTATE_FALSE and GTK_ACCESSIBLE_TRISTATE_TRUE
// have the same values as false and true.
type AccessibleTristate int

const (
	// AccessibleTristateFalse: the state is `false`
	AccessibleTristateFalse AccessibleTristate = 0
	// AccessibleTristateTrue: the state is `true`
	AccessibleTristateTrue AccessibleTristate = 1
	// AccessibleTristateMixed: the state is `mixed`
	AccessibleTristateMixed AccessibleTristate = 2
)

func marshalAccessibleTristate(p uintptr) (interface{}, error) {
	return AccessibleTristate(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Align controls how a widget deals with extra space in a single dimension.
//
// Alignment only matters if the widget receives a too large allocation, for
// example if you packed the widget with the [property@Gtk.Widget:hexpand]
// property inside a `GtkBox`, then the widget might get extra space. If you
// have for example a 16x16 icon inside a 32x32 space, the icon could be scaled
// and stretched, it could be centered, or it could be positioned to one side of
// the space.
//
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support is optional for containers and widgets, and it is
// only supported for vertical alignment. When it's not supported by a child or
// a container it is treated as GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = 0
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart Align = 1
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd Align = 2
	// AlignCenter: center natural width of widget inside the allocation
	AlignCenter Align = 3
	// AlignBaseline: align the widget according to the baseline. See Widget
	AlignBaseline Align = 4
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowTypeUp represents an upward pointing arrow.
	ArrowTypeUp ArrowType = 0
	// ArrowTypeDown represents a downward pointing arrow.
	ArrowTypeDown ArrowType = 1
	// ArrowTypeLeft represents a left pointing arrow.
	ArrowTypeLeft ArrowType = 2
	// ArrowTypeRight represents a right pointing arrow.
	ArrowTypeRight ArrowType = 3
	// ArrowTypeNone: no arrow.
	ArrowTypeNone ArrowType = 4
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageType determines the page role inside a `GtkAssistant`.
//
// The role is used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isnt committed. See
// gtk_assistant_commit() for details.
type AssistantPageType int

const (
	// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
	AssistantPageTypeContent AssistantPageType = 0
	// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
	AssistantPageTypeIntro AssistantPageType = 1
	// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
	AssistantPageTypeConfirm AssistantPageType = 2
	// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
	AssistantPageTypeSummary AssistantPageType = 3
	// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
	AssistantPageTypeProgress AssistantPageType = 4
	// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
	AssistantPageTypeCustom AssistantPageType = 5
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BaselinePosition: baseline position in a row of widgets.
//
// Whenever a container has some form of natural row it may align children in
// that row along a common typographical baseline. If the amount of vertical
// space in the row is taller than the total requested height of the
// baseline-aligned children then it can use a `GtkBaselinePosition` to select
// where to put the baseline inside the extra available space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = 0
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter BaselinePosition = 1
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom BaselinePosition = 2
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = 0
	// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE
	BorderStyleHidden BorderStyle = 1
	// BorderStyleSolid: a single line segment
	BorderStyleSolid BorderStyle = 2
	// BorderStyleInset looks as if the content is sunken into the canvas
	BorderStyleInset BorderStyle = 3
	// BorderStyleOutset looks as if the content is coming out of the canvas
	BorderStyleOutset BorderStyle = 4
	// BorderStyleDotted: a series of round dots
	BorderStyleDotted BorderStyle = 5
	// BorderStyleDashed: a series of square-ended dashes
	BorderStyleDashed BorderStyle = 6
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble BorderStyle = 7
	// BorderStyleGroove looks as if it were carved in the canvas
	BorderStyleGroove BorderStyle = 8
	// BorderStyleRidge looks as if it were coming out of the canvas
	BorderStyleRidge BorderStyle = 9
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError int

const (
	// BuilderErrorInvalidTypeFunction: a type-func attribute didnt name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = 0
	// BuilderErrorUnhandledTag: the input contained a tag that Builder cant
	// handle.
	BuilderErrorUnhandledTag BuilderError = 1
	// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
	BuilderErrorMissingAttribute BuilderError = 2
	// BuilderErrorInvalidAttribute: Builder found an attribute that it doesnt
	// understand.
	BuilderErrorInvalidAttribute BuilderError = 3
	// BuilderErrorInvalidTag: Builder found a tag that it doesnt understand.
	BuilderErrorInvalidTag BuilderError = 4
	// BuilderErrorMissingPropertyValue: a required property value was missing.
	BuilderErrorMissingPropertyValue BuilderError = 5
	// BuilderErrorInvalidValue: Builder couldnt parse some attribute value.
	BuilderErrorInvalidValue BuilderError = 6
	// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK.
	BuilderErrorVersionMismatch BuilderError = 7
	// BuilderErrorDuplicateID: an object id occurred twice.
	BuilderErrorDuplicateID BuilderError = 8
	// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused BuilderError = 9
	// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// classs template XML
	BuilderErrorTemplateMismatch BuilderError = 10
	// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
	BuilderErrorInvalidProperty BuilderError = 11
	// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal BuilderError = 12
	// BuilderErrorInvalidID: an object id is unknown.
	BuilderErrorInvalidID BuilderError = 13
	// BuilderErrorInvalidFunction: a function could not be found. This often
	// happens when symbols are set to be kept private. Compiling code with
	// -rdynamic or using the `gmodule-export-2.0` pkgconfig module can fix this
	// problem.
	BuilderErrorInvalidFunction BuilderError = 14
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonsType: prebuilt sets of buttons for `GtkDialog`.
//
// If none of these choices are appropriate, simply use GTK_BUTTONS_NONE and
// call [method@Gtk.Dialog.add_buttons].
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType int

const (
	// ButtonsTypeNone: no buttons at all
	ButtonsTypeNone ButtonsType = 0
	// ButtonsTypeOk: an OK button
	ButtonsTypeOk ButtonsType = 1
	// ButtonsTypeClose: a Close button
	ButtonsTypeClose ButtonsType = 2
	// ButtonsTypeCancel: a Cancel button
	ButtonsTypeCancel ButtonsType = 3
	// ButtonsTypeYesNo yes and No buttons
	ButtonsTypeYesNo ButtonsType = 4
	// ButtonsTypeOkCancel: OK and Cancel buttons
	ButtonsTypeOkCancel ButtonsType = 5
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererAccelMode determines if the edited accelerators are GTK
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode int

const (
	// CellRendererAccelModeGTK: GTK accelerators mode
	CellRendererAccelModeGTK CellRendererAccelMode = 0
	// CellRendererAccelModeOther: other accelerator mode
	CellRendererAccelModeOther CellRendererAccelMode = 1
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode int

const (
	// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesnt mean that eg. the row being drawn
	// cant be selected -- just that a particular element of it cannot be
	// individually modified.
	CellRendererModeInert CellRendererMode = 0
	// CellRendererModeActivatable: the cell can be clicked.
	CellRendererModeActivatable CellRendererMode = 1
	// CellRendererModeEditable: the cell can be edited or otherwise modified.
	CellRendererModeEditable CellRendererMode = 2
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintAttribute: the widget attributes that can be used when creating a
// `GtkConstraint`.
type ConstraintAttribute int

const (
	// ConstraintAttributeNone: no attribute, used for constant relations
	ConstraintAttributeNone ConstraintAttribute = 0
	// ConstraintAttributeLeft: the left edge of a widget, regardless of text
	// direction
	ConstraintAttributeLeft ConstraintAttribute = 1
	// ConstraintAttributeRight: the right edge of a widget, regardless of text
	// direction
	ConstraintAttributeRight ConstraintAttribute = 2
	// ConstraintAttributeTop: the top edge of a widget
	ConstraintAttributeTop ConstraintAttribute = 3
	// ConstraintAttributeBottom: the bottom edge of a widget
	ConstraintAttributeBottom ConstraintAttribute = 4
	// ConstraintAttributeStart: the leading edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_LEFT for LTR languages,
	// and GTK_CONSTRAINT_ATTRIBUTE_RIGHT for RTL ones
	ConstraintAttributeStart ConstraintAttribute = 5
	// ConstraintAttributeEnd: the trailing edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_RIGHT for LTR
	// languages, and GTK_CONSTRAINT_ATTRIBUTE_LEFT for RTL ones
	ConstraintAttributeEnd ConstraintAttribute = 6
	// ConstraintAttributeWidth: the width of a widget
	ConstraintAttributeWidth ConstraintAttribute = 7
	// ConstraintAttributeHeight: the height of a widget
	ConstraintAttributeHeight ConstraintAttribute = 8
	// ConstraintAttributeCenterX: the center of a widget, on the horizontal
	// axis
	ConstraintAttributeCenterX ConstraintAttribute = 9
	// ConstraintAttributeCenterY: the center of a widget, on the vertical axis
	ConstraintAttributeCenterY ConstraintAttribute = 10
	// ConstraintAttributeBaseline: the baseline of a widget
	ConstraintAttributeBaseline ConstraintAttribute = 11
)

func marshalConstraintAttribute(p uintptr) (interface{}, error) {
	return ConstraintAttribute(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintRelation: the relation between two terms of a constraint.
type ConstraintRelation int

const (
	// ConstraintRelationLe less than, or equal
	ConstraintRelationLe ConstraintRelation = -1
	// ConstraintRelationEq: equal
	ConstraintRelationEq ConstraintRelation = 0
	// ConstraintRelationGe: greater than, or equal
	ConstraintRelationGe ConstraintRelation = 1
)

func marshalConstraintRelation(p uintptr) (interface{}, error) {
	return ConstraintRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintStrength: the strength of a constraint, expressed as a symbolic
// constant.
//
// The strength of a Constraint can be expressed with any positive integer; the
// values of this enumeration can be used for readability.
type ConstraintStrength int

const (
	// ConstraintStrengthRequired: the constraint is required towards solving
	// the layout
	ConstraintStrengthRequired ConstraintStrength = 1001001000
	// ConstraintStrengthStrong: a strong constraint
	ConstraintStrengthStrong ConstraintStrength = 1000000000
	// ConstraintStrengthMedium: a medium constraint
	ConstraintStrengthMedium ConstraintStrength = 1000
	// ConstraintStrengthWeak: a weak constraint
	ConstraintStrengthWeak ConstraintStrength = 1
)

func marshalConstraintStrength(p uintptr) (interface{}, error) {
	return ConstraintStrength(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintVflParserError: domain for VFL parsing errors.
type ConstraintVflParserError int

const (
	// ConstraintVflParserErrorSymbol: invalid or unknown symbol
	ConstraintVflParserErrorSymbol ConstraintVflParserError = 0
	// ConstraintVflParserErrorAttribute: invalid or unknown attribute
	ConstraintVflParserErrorAttribute ConstraintVflParserError = 1
	// ConstraintVflParserErrorView: invalid or unknown view
	ConstraintVflParserErrorView ConstraintVflParserError = 2
	// ConstraintVflParserErrorMetric: invalid or unknown metric
	ConstraintVflParserErrorMetric ConstraintVflParserError = 3
	// ConstraintVflParserErrorPriority: invalid or unknown priority
	ConstraintVflParserErrorPriority ConstraintVflParserError = 4
	// ConstraintVflParserErrorRelation: invalid or unknown relation
	ConstraintVflParserErrorRelation ConstraintVflParserError = 5
)

func marshalConstraintVflParserError(p uintptr) (interface{}, error) {
	return ConstraintVflParserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a `GtkScrolledWindow.`
//
// This is effectively the opposite of where the scroll bars are placed.
type CornerType int

const (
	// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerTypeBottomLeft CornerType = 1
	// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTypeTopRight CornerType = 2
	// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSParserError errors that can occur while parsing CSS.
//
// These errors are unexpected and will cause parts of the given CSS to be
// ignored.
type CSSParserError int

const (
	// CSSParserErrorFailed: unknown failure.
	CSSParserErrorFailed CSSParserError = 0
	// CSSParserErrorSyntax: the given text does not form valid syntax
	CSSParserErrorSyntax CSSParserError = 1
	// CSSParserErrorImport: failed to import a resource
	CSSParserErrorImport CSSParserError = 2
	// CSSParserErrorName: the given name has not been defined
	CSSParserErrorName CSSParserError = 3
	// CSSParserErrorUnknownValue: the given value is not correct
	CSSParserErrorUnknownValue CSSParserError = 4
)

// CSSParserWarning warnings that can occur while parsing CSS.
//
// Unlike CssParserErrors, warnings do not cause the parser to skip any input,
// but they indicate issues that should be fixed.
type CSSParserWarning int

const (
	// CSSParserWarningDeprecated: the given construct is deprecated and will be
	// removed in a future version
	CSSParserWarningDeprecated CSSParserWarning = 0
	// CSSParserWarningSyntax: a syntax construct was used that should be
	// avoided
	CSSParserWarningSyntax CSSParserWarning = 1
	// CSSParserWarningUnimplemented: a feature is not implemented
	CSSParserWarningUnimplemented CSSParserWarning = 2
)

// DeleteType: passed to various keybinding signals for deleting text.
type DeleteType int

const (
	// DeleteTypeChars: delete characters.
	DeleteTypeChars DeleteType = 0
	// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if were in the middle of a word.
	DeleteTypeWordEnds DeleteType = 1
	// DeleteTypeWords: delete words.
	DeleteTypeWords DeleteType = 2
	// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteTypeDisplayLines DeleteType = 3
	// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
	DeleteTypeDisplayLineEnds DeleteType = 4
	// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteTypeParagraphEnds DeleteType = 5
	// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
	DeleteTypeParagraphs DeleteType = 6
	// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteTypeWhitespace DeleteType = 7
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DirectionType focus movement types.
type DirectionType int

const (
	// DirectionTypeTabForward: move forward.
	DirectionTypeTabForward DirectionType = 0
	// DirectionTypeTabBackward: move backward.
	DirectionTypeTabBackward DirectionType = 1
	// DirectionTypeUp: move up.
	DirectionTypeUp DirectionType = 2
	// DirectionTypeDown: move down.
	DirectionTypeDown DirectionType = 3
	// DirectionTypeLeft: move left.
	DirectionTypeLeft DirectionType = 4
	// DirectionTypeRight: move right.
	DirectionTypeRight DirectionType = 5
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type EditableProperties int

const (
	EditablePropertiesPropText           EditableProperties = 0
	EditablePropertiesPropCursorPosition EditableProperties = 1
	EditablePropertiesPropSelectionBound EditableProperties = 2
	EditablePropertiesPropEditable       EditableProperties = 3
	EditablePropertiesPropWidthChars     EditableProperties = 4
	EditablePropertiesPropMaxWidthChars  EditableProperties = 5
	EditablePropertiesPropXalign         EditableProperties = 6
	EditablePropertiesPropEnableUndo     EditableProperties = 7
	EditablePropertiesNumProperties      EditableProperties = 8
)

func marshalEditableProperties(p uintptr) (interface{}, error) {
	return EditableProperties(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

const (
	// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
	EntryIconPositionPrimary EntryIconPosition = 0
	// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
	EntryIconPositionSecondary EntryIconPosition = 1
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventSequenceState describes the state of a `GdkEventSequence` in a
// `GtkGesture`.
type EventSequenceState int

const (
	// EventSequenceStateNone: the sequence is handled, but not grabbed.
	EventSequenceStateNone EventSequenceState = 0
	// EventSequenceStateClaimed: the sequence is handled and grabbed.
	EventSequenceStateClaimed EventSequenceState = 1
	// EventSequenceStateDenied: the sequence is denied.
	EventSequenceStateDenied EventSequenceState = 2
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserAction describes whether a `GtkFileChooser` is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction int

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = 0
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave FileChooserAction = 1
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder FileChooserAction = 2
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserError: these identify the various errors that can occur while
// calling `GtkFileChooser` functions.
type FileChooserError int

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = 0
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename FileChooserError = 1
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists FileChooserError = 2
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname FileChooserError = 3
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterChange describes changes in a filter in more detail and allows objects
// using the filter to optimize refiltering items.
//
// If you are writing an implementation and are not sure which value to pass,
// GTK_FILTER_CHANGE_DIFFERENT is always a correct choice.
type FilterChange int

const (
	// FilterChangeDifferent: the filter change cannot be described with any of
	// the other enumeration values.
	FilterChangeDifferent FilterChange = 0
	// FilterChangeLessStrict: the filter is less strict than it was before: All
	// items that it used to return true for still return true, others now may,
	// too.
	FilterChangeLessStrict FilterChange = 1
	// FilterChangeMoreStrict: the filter is more strict than it was before: All
	// items that it used to return false for still return false, others now
	// may, too.
	FilterChangeMoreStrict FilterChange = 2
)

func marshalFilterChange(p uintptr) (interface{}, error) {
	return FilterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterMatch describes the known strictness of a filter.
//
// Note that for filters where the strictness is not known,
// GTK_FILTER_MATCH_SOME is always an acceptable value, even if a filter does
// match all or no items.
type FilterMatch int

const (
	// FilterMatchSome: the filter matches some items, gtk_filter_match() may
	// return true or false
	FilterMatchSome FilterMatch = 0
	// FilterMatchNone: the filter does not match any item, gtk_filter_match()
	// will always return false.
	FilterMatchNone FilterMatch = 1
	// FilterMatchAll: the filter matches all items, gtk_filter_match() will
	// alays return true.
	FilterMatchAll FilterMatch = 2
)

func marshalFilterMatch(p uintptr) (interface{}, error) {
	return FilterMatch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconSize: built-in icon sizes.
//
// Icon sizes default to being inherited. Where they cannot be inherited, text
// size is the default.
//
// All widgets which use `GtkIconSize` set the normal-icons or large-icons style
// classes correspondingly, and let themes determine the actual size to be used
// with the `-gtk-icon-size` CSS property.
type IconSize int

const (
	// IconSizeInherit: keep the size of the parent element
	IconSizeInherit IconSize = 0
	// IconSizeNormal: size similar to text size
	IconSizeNormal IconSize = 1
	// IconSizeLarge: large size, for example in an icon view
	IconSizeLarge IconSize = 2
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconThemeError: error codes for `GtkIconTheme` operations.
type IconThemeError int

const (
	// IconThemeErrorNotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// IconThemeErrorFailed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconViewDropPosition: an enum for determining where a dropped item goes.
type IconViewDropPosition int

const (
	// IconViewDropPositionNoDrop: no drop possible
	IconViewDropPositionNoDrop IconViewDropPosition = 0
	// IconViewDropPositionDropInto: dropped item replaces the item
	IconViewDropPositionDropInto IconViewDropPosition = 1
	// IconViewDropPositionDropLeft: dropped item is inserted to the left
	IconViewDropPositionDropLeft IconViewDropPosition = 2
	// IconViewDropPositionDropRight: dropped item is inserted to the right
	IconViewDropPositionDropRight IconViewDropPosition = 3
	// IconViewDropPositionDropAbove: dropped item is inserted above
	IconViewDropPositionDropAbove IconViewDropPosition = 4
	// IconViewDropPositionDropBelow: dropped item is inserted below
	IconViewDropPositionDropBelow IconViewDropPosition = 5
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ImageType describes the image data representation used by a
// [class@Gtk.Image].
//
// If you want to get the image from the widget, you can only get the
// currently-stored representation; for instance, if the
// gtk_image_get_storage_type() returns GTK_IMAGE_PAINTABLE, then you can call
// gtk_image_get_paintable().
//
// For empty images, you can request any storage type (call any of the "get"
// functions), but they will all return nil values.
type ImageType int

const (
	// ImageTypeEmpty: there is no image displayed by the widget
	ImageTypeEmpty ImageType = 0
	// ImageTypeIconName: the widget contains a named icon
	ImageTypeIconName ImageType = 1
	// ImageTypeGIcon: the widget contains a #GIcon
	ImageTypeGIcon ImageType = 2
	// ImageTypePaintable: the widget contains a Paintable
	ImageTypePaintable ImageType = 3
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputPurpose describes primary purpose of the input widget.
//
// This information is useful for on-screen keyboards and similar input methods
// to decide which keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between GTK_INPUT_PURPOSE_DIGITS and GTK_INPUT_PURPOSE_NUMBER
// is that the former accepts only digits while the latter also some punctuation
// (like commas or points, plus, minus) and e or E as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as free form.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = 0
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha InputPurpose = 1
	// InputPurposeDigits: allow only digits
	InputPurposeDigits InputPurpose = 2
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber InputPurpose = 3
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone InputPurpose = 4
	// InputPurposeURL: edited field expects URL
	InputPurposeURL InputPurpose = 5
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail InputPurpose = 6
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName InputPurpose = 7
	// InputPurposePassword: like GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword InputPurpose = 8
	// InputPurposePin: like GTK_INPUT_PURPOSE_DIGITS, but characters are hidden
	InputPurposePin InputPurpose = 9
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal InputPurpose = 10
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Justification: used for justifying the text inside a `GtkLabel` widget.
type Justification int

const (
	// JustificationLeft: the text is placed at the left edge of the label.
	JustificationLeft Justification = 0
	// JustificationRight: the text is placed at the right edge of the label.
	JustificationRight Justification = 1
	// JustificationCenter: the text is placed in the center of the label.
	JustificationCenter Justification = 2
	// JustificationFill: the text is placed is distributed across the label.
	JustificationFill Justification = 3
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// LevelBarMode describes how `GtkLevelBar` contents should be rendered.
//
// Note that this enumeration could be extended with additional modes in the
// future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: the bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = 0
	// LevelBarModeDiscrete: the bar has a discrete mode
	LevelBarModeDiscrete LevelBarMode = 1
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// License: the type of license for an application.
//
// This enumeration can be expanded at later date.
type License int

const (
	// LicenseUnknown: no license specified
	LicenseUnknown License = 0
	// LicenseCustom: a license text is going to be specified by the developer
	LicenseCustom License = 1
	// LicenseGPL20: the GNU General Public License, version 2.0 or later
	LicenseGPL20 License = 2
	// LicenseGPL30: the GNU General Public License, version 3.0 or later
	LicenseGPL30 License = 3
	// LicenseLGPL21: the GNU Lesser General Public License, version 2.1 or
	// later
	LicenseLGPL21 License = 4
	// LicenseLGPL30: the GNU Lesser General Public License, version 3.0 or
	// later
	LicenseLGPL30 License = 5
	// LicenseBSD: the BSD standard license
	LicenseBSD License = 6
	// LicenseMITX11: the MIT/X11 standard license
	LicenseMITX11 License = 7
	// LicenseArtistic: the Artistic License, version 2.0
	LicenseArtistic License = 8
	// LicenseGPL20Only: the GNU General Public License, version 2.0 only
	LicenseGPL20Only License = 9
	// LicenseGPL30Only: the GNU General Public License, version 3.0 only
	LicenseGPL30Only License = 10
	// LicenseLGPL21Only: the GNU Lesser General Public License, version 2.1
	// only
	LicenseLGPL21Only License = 11
	// LicenseLGPL30Only: the GNU Lesser General Public License, version 3.0
	// only
	LicenseLGPL30Only License = 12
	// LicenseAGPL30: the GNU Affero General Public License, version 3.0 or
	// later
	LicenseAGPL30 License = 13
	// LicenseAGPL30Only: the GNU Affero General Public License, version 3.0
	// only
	LicenseAGPL30Only License = 14
	// LicenseBSD3: the 3-clause BSD licence
	LicenseBSD3 License = 15
	// LicenseApache20: the Apache License, version 2.0
	LicenseApache20 License = 16
	// LicenseMPL20: the Mozilla Public License, version 2.0
	LicenseMPL20 License = 17
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MessageType: the type of message being displayed in a `GtkMessageDialog`.
type MessageType int

const (
	// MessageTypeInfo: informational message
	MessageTypeInfo MessageType = 0
	// MessageTypeWarning: non-fatal warning message
	MessageTypeWarning MessageType = 1
	// MessageTypeQuestion: question requiring a choice
	MessageTypeQuestion MessageType = 2
	// MessageTypeError: fatal error message
	MessageTypeError MessageType = 3
	// MessageTypeOther: none of the above
	MessageTypeOther MessageType = 4
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MovementStep: passed as argument to various keybinding signals for moving the
// cursor position.
type MovementStep int

const (
	// MovementStepLogicalPositions: move forward or back by graphemes
	MovementStepLogicalPositions MovementStep = 0
	// MovementStepVisualPositions: move left or right by graphemes
	MovementStepVisualPositions MovementStep = 1
	// MovementStepWords: move forward or back by words
	MovementStepWords MovementStep = 2
	// MovementStepDisplayLines: move up or down lines (wrapped lines)
	MovementStepDisplayLines MovementStep = 3
	// MovementStepDisplayLineEnds: move to either end of a line
	MovementStepDisplayLineEnds MovementStep = 4
	// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
	MovementStepParagraphs MovementStep = 5
	// MovementStepParagraphEnds: move to either end of a paragraph
	MovementStepParagraphEnds MovementStep = 6
	// MovementStepPages: move by pages
	MovementStepPages MovementStep = 7
	// MovementStepBufferEnds: move to ends of the buffer
	MovementStepBufferEnds MovementStep = 8
	// MovementStepHorizontalPages: move horizontally by pages
	MovementStepHorizontalPages MovementStep = 9
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotebookTab: the parameter used in the action signals of `GtkNotebook`.
type NotebookTab int

const (
	// NotebookTabFirst: the first tab in the notebook
	NotebookTabFirst NotebookTab = 0
	// NotebookTabLast: the last tab in the notebook
	NotebookTabLast NotebookTab = 1
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLrtb: ! (layout-lrtb.png)
	NumberUpLayoutLrtb NumberUpLayout = 0
	// NumberUpLayoutLrbt: ! (layout-lrbt.png)
	NumberUpLayoutLrbt NumberUpLayout = 1
	// NumberUpLayoutRltb: ! (layout-rltb.png)
	NumberUpLayoutRltb NumberUpLayout = 2
	// NumberUpLayoutRlbt: ! (layout-rlbt.png)
	NumberUpLayoutRlbt NumberUpLayout = 3
	// NumberUpLayoutTblr: ! (layout-tblr.png)
	NumberUpLayoutTblr NumberUpLayout = 4
	// NumberUpLayoutTbrl: ! (layout-tbrl.png)
	NumberUpLayoutTbrl NumberUpLayout = 5
	// NumberUpLayoutBtlr: ! (layout-btlr.png)
	NumberUpLayoutBtlr NumberUpLayout = 6
	// NumberUpLayoutBtrl: ! (layout-btrl.png)
	NumberUpLayoutBtrl NumberUpLayout = 7
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Ordering describes the way two values can be compared.
//
// These values can be used with a `GCompareFunc`. However, a `GCompareFunc` is
// allowed to return any integer values. For converting such a value to a
// `GtkOrdering` value, use [func@Gtk.Ordering.from_cmpfunc].
type Ordering int

const (
	// OrderingSmaller: the first value is smaller than the second
	OrderingSmaller Ordering = -1
	// OrderingEqual: the two values are equal
	OrderingEqual Ordering = 0
	// OrderingLarger: the first value is larger than the second
	OrderingLarger Ordering = 1
)

func marshalOrdering(p uintptr) (interface{}, error) {
	return Ordering(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Orientation represents the orientation of widgets and other objects.
//
// Typical examples are `GtkBox or `GtkGesturePan`.
type Orientation int

const (
	// OrientationHorizontal: the element is in horizontal orientation.
	OrientationHorizontal Orientation = 0
	// OrientationVertical: the element is in vertical orientation.
	OrientationVertical Orientation = 1
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Overflow defines how content overflowing a given area should be handled.
//
// This is used in [method@Gtk.Widget.set_overflow]. The
// [property@Gtk.Widget:overflow] property is modeled after the CSS overflow
// property, but implements it only partially.
type Overflow int

const (
	// OverflowVisible: no change is applied. Content is drawn at the specified
	// position.
	OverflowVisible Overflow = 0
	// OverflowHidden: content is clipped to the bounds of the area. Content
	// outside the area is not drawn and cannot be interacted with.
	OverflowHidden Overflow = 1
)

func marshalOverflow(p uintptr) (interface{}, error) {
	return Overflow(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackType represents the packing location of a children in its parent.
//
// See `GtkWindowControls` for example.
type PackType int

const (
	// PackTypeStart: the child is packed into the start of the widget
	PackTypeStart PackType = 0
	// PackTypeEnd: the child is packed into the end of the widget
	PackTypeEnd PackType = 1
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PadActionType: the type of a pad action.
type PadActionType int

const (
	// PadActionTypeButton: action is triggered by a pad button
	PadActionTypeButton PadActionType = 0
	// PadActionTypeRing: action is triggered by a pad ring
	PadActionTypeRing PadActionType = 1
	// PadActionTypeStrip: action is triggered by a pad strip
	PadActionTypeStrip PadActionType = 2
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = 0
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape PageOrientation = 1
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait PageOrientation = 2
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape PageOrientation = 3
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = 0
	// PageSetEven: even pages.
	PageSetEven PageSet = 1
	// PageSetOdd: odd pages.
	PageSetOdd PageSet = 2
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PanDirection describes the panning direction of a `GtkGesturePan`
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = 0
	// PanDirectionRight: panned towards the right
	PanDirectionRight PanDirection = 1
	// PanDirectionUp: panned upwards
	PanDirectionUp PanDirection = 2
	// PanDirectionDown: panned downwards
	PanDirectionDown PanDirection = 3
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
	PolicyTypeAlways PolicyType = 0
	// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a `GtkTreeView` can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
	PolicyTypeNever PolicyType = 2
	// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar.
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PositionType describes which edge of a widget a certain feature is positioned
// at.
//
// For examples, see the tabs of a `GtkNotebook`, or the label of a `GtkScale`.
type PositionType int

const (
	// PositionTypeLeft: the feature is at the left edge.
	PositionTypeLeft PositionType = 0
	// PositionTypeRight: the feature is at the right edge.
	PositionTypeRight PositionType = 1
	// PositionTypeTop: the feature is at the top edge.
	PositionTypeTop PositionType = 2
	// PositionTypeBottom: the feature is at the bottom edge.
	PositionTypeBottom PositionType = 3
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = 0
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal PrintDuplex = 1
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical PrintDuplex = 2
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNOMEM: a memory allocation failed.
	PrintErrorNOMEM PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction determines what action the print operation should
// perform.
//
// A parameter of this typs is passed to [method@Gtk.PrintOperation.run].
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: the result of a print operation.
//
// A value of this type is returned by [method@Gtk.PrintOperation.run].
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = 0
	// PrintPagesCurrent: current page.
	PrintPagesCurrent PrintPages = 1
	// PrintPagesRanges: range of pages.
	PrintPagesRanges PrintPages = 2
	// PrintPagesSelection: selected pages.
	PrintPagesSelection PrintPages = 3
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = 0
	// PrintQualityNormal: normal quality.
	PrintQualityNormal PrintQuality = 1
	// PrintQualityHigh: high quality.
	PrintQualityHigh PrintQuality = 2
	// PrintQualityDraft: draft quality.
	PrintQualityDraft PrintQuality = 3
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationLimit describes limits of a `GtkEventController` for handling
// events targeting other widgets.
type PropagationLimit int

const (
	// PropagationLimitNone events are handled regardless of what their target
	// is.
	PropagationLimitNone PropagationLimit = 0
	// PropagationLimitSameNative events are only handled if their target is in
	// the same Native as the event controllers widget. Note that some event
	// types have two targets (origin and destination).
	PropagationLimitSameNative PropagationLimit = 1
)

func marshalPropagationLimit(p uintptr) (interface{}, error) {
	return PropagationLimit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationPhase describes the stage at which events are fed into a
// `GtkEventController`.
type PropagationPhase int

const (
	// PropagationPhaseNone events are not delivered.
	PropagationPhaseNone PropagationPhase = 0
	// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
	PropagationPhaseCapture PropagationPhase = 1
	// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
	PropagationPhaseBubble PropagationPhase = 2
	// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
	PropagationPhaseTarget PropagationPhase = 3
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentManagerError: error codes for RecentManager operations
type RecentManagerError int

const (
	// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
	RecentManagerErrorNotFound RecentManagerError = 0
	// RecentManagerErrorInvalidURI: the URI specified is not valid.
	RecentManagerErrorInvalidURI RecentManagerError = 1
	// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
	RecentManagerErrorInvalidEncoding RecentManagerError = 2
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered RecentManagerError = 3
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead RecentManagerError = 4
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite RecentManagerError = 5
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown RecentManagerError = 6
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button().
//
// All predefined values are negative; GTK leaves values of 0 or greater for
// application-defined response ids.
type ResponseType int

const (
	// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// ResponseTypeReject: generic response id, not used by GTK dialogs
	ResponseTypeReject ResponseType = -2
	// ResponseTypeAccept: generic response id, not used by GTK dialogs
	ResponseTypeAccept ResponseType = -3
	// ResponseTypeDeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ResponseTypeOk: returned by OK buttons in GTK dialogs
	ResponseTypeOk ResponseType = -5
	// ResponseTypeCancel: returned by Cancel buttons in GTK dialogs
	ResponseTypeCancel ResponseType = -6
	// ResponseTypeClose: returned by Close buttons in GTK dialogs
	ResponseTypeClose ResponseType = -7
	// ResponseTypeYes: returned by Yes buttons in GTK dialogs
	ResponseTypeYes ResponseType = -8
	// ResponseTypeNo: returned by No buttons in GTK dialogs
	ResponseTypeNo ResponseType = -9
	// ResponseTypeApply: returned by Apply buttons in GTK dialogs
	ResponseTypeApply ResponseType = -10
	// ResponseTypeHelp: returned by Help buttons in GTK dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a `GtkRevealer` widget is shown or hidden.
type RevealerTransitionType int

const (
	// RevealerTransitionTypeNone: no transition
	RevealerTransitionTypeNone RevealerTransitionType = 0
	// RevealerTransitionTypeCrossfade: fade in
	RevealerTransitionTypeCrossfade RevealerTransitionType = 1
	// RevealerTransitionTypeSlideRight: slide in from the left
	RevealerTransitionTypeSlideRight RevealerTransitionType = 2
	// RevealerTransitionTypeSlideLeft: slide in from the right
	RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
	// RevealerTransitionTypeSlideUp: slide in from the bottom
	RevealerTransitionTypeSlideUp RevealerTransitionType = 4
	// RevealerTransitionTypeSlideDown: slide in from the top
	RevealerTransitionTypeSlideDown RevealerTransitionType = 5
	// RevealerTransitionTypeSwingRight: floop in from the left
	RevealerTransitionTypeSwingRight RevealerTransitionType = 6
	// RevealerTransitionTypeSwingLeft: floop in from the right
	RevealerTransitionTypeSwingLeft RevealerTransitionType = 7
	// RevealerTransitionTypeSwingUp: floop in from the bottom
	RevealerTransitionTypeSwingUp RevealerTransitionType = 8
	// RevealerTransitionTypeSwingDown: floop in from the top
	RevealerTransitionTypeSwingDown RevealerTransitionType = 9
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollStep: passed as argument to various keybinding signals.
type ScrollStep int

const (
	// ScrollStepSteps: scroll in steps.
	ScrollStepSteps ScrollStep = 0
	// ScrollStepPages: scroll by pages.
	ScrollStepPages ScrollStep = 1
	// ScrollStepEnds: scroll to ends.
	ScrollStepEnds ScrollStep = 2
	// ScrollStepHorizontalSteps: scroll in horizontal steps.
	ScrollStepHorizontalSteps ScrollStep = 3
	// ScrollStepHorizontalPages: scroll by horizontal pages.
	ScrollStepHorizontalPages ScrollStep = 4
	// ScrollStepHorizontalEnds: scroll to the horizontal ends.
	ScrollStepHorizontalEnds ScrollStep = 5
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollTypeNone: no scrolling.
	ScrollTypeNone ScrollType = 0
	// ScrollTypeJump: jump to new location.
	ScrollTypeJump ScrollType = 1
	// ScrollTypeStepBackward: step backward.
	ScrollTypeStepBackward ScrollType = 2
	// ScrollTypeStepForward: step forward.
	ScrollTypeStepForward ScrollType = 3
	// ScrollTypePageBackward: page backward.
	ScrollTypePageBackward ScrollType = 4
	// ScrollTypePageForward: page forward.
	ScrollTypePageForward ScrollType = 5
	// ScrollTypeStepUp: step up.
	ScrollTypeStepUp ScrollType = 6
	// ScrollTypeStepDown: step down.
	ScrollTypeStepDown ScrollType = 7
	// ScrollTypePageUp: page up.
	ScrollTypePageUp ScrollType = 8
	// ScrollTypePageDown: page down.
	ScrollTypePageDown ScrollType = 9
	// ScrollTypeStepLeft: step to the left.
	ScrollTypeStepLeft ScrollType = 10
	// ScrollTypeStepRight: step to the right.
	ScrollTypeStepRight ScrollType = 11
	// ScrollTypePageLeft: page to the left.
	ScrollTypePageLeft ScrollType = 12
	// ScrollTypePageRight: page to the right.
	ScrollTypePageRight ScrollType = 13
	// ScrollTypeStart: scroll to start.
	ScrollTypeStart ScrollType = 14
	// ScrollTypeEnd: scroll to end.
	ScrollTypeEnd ScrollType = 15
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
	ScrollablePolicyMinimum ScrollablePolicy = 0
	// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
	ScrollablePolicyNatural ScrollablePolicy = 1
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionModeNone: no selection is possible.
	SelectionModeNone SelectionMode = 0
	// SelectionModeSingle: zero or one element may be selected.
	SelectionModeSingle SelectionMode = 1
	// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, its
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user cant deselect a currently selected
	// element except by selecting another element.
	SelectionModeBrowse SelectionMode = 2
	// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
	SelectionModeMultiple SelectionMode = 3
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SensitivityType determines how GTK handles the sensitivity of various
// controls, such as combo box buttons.
type SensitivityType int

const (
	// SensitivityTypeAuto: the control is made insensitive if no action can be
	// triggered
	SensitivityTypeAuto SensitivityType = 0
	// SensitivityTypeOn: the control is always sensitive
	SensitivityTypeOn SensitivityType = 1
	// SensitivityTypeOff: the control is always insensitive
	SensitivityTypeOff SensitivityType = 2
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutScope describes where `GtkShortcut`s added to a
// `GtkShortcutController` get handled.
type ShortcutScope int

const (
	// ShortcutScopeLocal shortcuts are handled inside the widget the controller
	// belongs to.
	ShortcutScopeLocal ShortcutScope = 0
	// ShortcutScopeManaged shortcuts are handled by the first ancestor that is
	// a ShortcutManager
	ShortcutScopeManaged ShortcutScope = 1
	// ShortcutScopeGlobal shortcuts are handled by the root widget.
	ShortcutScopeGlobal ShortcutScope = 2
)

func marshalShortcutScope(p uintptr) (interface{}, error) {
	return ShortcutScope(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described.
//
// More values may be added to this enumeration over time.
type ShortcutType int

const (
	// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// GtkShortcutsShortcut:accelerator property will be used.
	ShortcutTypeAccelerator ShortcutType = 0
	// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK provides
	// an icon and subtitle.
	ShortcutTypeGesturePinch ShortcutType = 1
	// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK
	// provides an icon and subtitle.
	ShortcutTypeGestureStretch ShortcutType = 2
	// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK provides an icon and subtitle.
	ShortcutTypeGestureRotateClockwise ShortcutType = 3
	// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK provides an icon and subtitle.
	ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
	// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
	// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
	// ShortcutTypeGesture: the shortcut is a gesture. The
	// GtkShortcutsShortcut:icon property will be used.
	ShortcutTypeGesture ShortcutType = 7
	// ShortcutTypeGestureSwipeLeft: the shortcut is a swipe gesture. GTK
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeLeft ShortcutType = 8
	// ShortcutTypeGestureSwipeRight: the shortcut is a swipe gesture. GTK
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeRight ShortcutType = 9
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupModeNone: group has no effect
	SizeGroupModeNone SizeGroupMode = 0
	// SizeGroupModeHorizontal: group affects horizontal requisition
	SizeGroupModeHorizontal SizeGroupMode = 1
	// SizeGroupModeVertical: group affects vertical requisition
	SizeGroupModeVertical SizeGroupMode = 2
	// SizeGroupModeBoth: group affects both horizontal and vertical requisition
	SizeGroupModeBoth SizeGroupMode = 3
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
	SizeRequestModeHeightForWidth SizeRequestMode = 0
	// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
	SizeRequestModeWidthForHeight SizeRequestMode = 1
	// SizeRequestModeConstantSize: dont trade height-for-width or
	// width-for-height
	SizeRequestModeConstantSize SizeRequestMode = 2
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SortType determines the direction of a sort.
type SortType int

const (
	// SortTypeAscending: sorting is in ascending order.
	SortTypeAscending SortType = 0
	// SortTypeDescending: sorting is in descending order.
	SortTypeDescending SortType = 1
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterChange describes changes in a sorter in more detail and allows users to
// optimize resorting.
type SorterChange int

const (
	// SorterChangeDifferent: the sorter change cannot be described by any of
	// the other enumeration values
	SorterChangeDifferent SorterChange = 0
	// SorterChangeInverted: the sort order was inverted. Comparisons that
	// returned GTK_ORDERING_SMALLER now return GTK_ORDERING_LARGER and vice
	// versa. Other comparisons return the same values as before.
	SorterChangeInverted SorterChange = 1
	// SorterChangeLessStrict: the sorter is less strict: Comparisons may now
	// return GTK_ORDERING_EQUAL that did not do so before.
	SorterChangeLessStrict SorterChange = 2
	// SorterChangeMoreStrict: the sorter is more strict: Comparisons that did
	// return GTK_ORDERING_EQUAL may not do so anymore.
	SorterChangeMoreStrict SorterChange = 3
)

func marshalSorterChange(p uintptr) (interface{}, error) {
	return SorterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterOrder describes the type of order that a `GtkSorter` may produce.
type SorterOrder int

const (
	// SorterOrderPartial: a partial order. Any Ordering is possible.
	SorterOrderPartial SorterOrder = 0
	// SorterOrderNone: no order, all elements are considered equal.
	// gtk_sorter_compare() will only return GTK_ORDERING_EQUAL.
	SorterOrderNone SorterOrder = 1
	// SorterOrderTotal: a total order. gtk_sorter_compare() will only return
	// GTK_ORDERING_EQUAL if an item is compared with itself. Two different
	// items will never cause this value to be returned.
	SorterOrderTotal SorterOrder = 2
)

func marshalSorterOrder(p uintptr) (interface{}, error) {
	return SorterOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinButtonUpdatePolicy determines whether the spin button displays values
// outside the adjustment bounds.
//
// See [method@Gtk.SpinButton.set_update_policy].
type SpinButtonUpdatePolicy int

const (
	// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
	SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
	// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
	SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
type SpinType int

const (
	// SpinTypeStepForward: increment by the adjustments step increment.
	SpinTypeStepForward SpinType = 0
	// SpinTypeStepBackward: decrement by the adjustments step increment.
	SpinTypeStepBackward SpinType = 1
	// SpinTypePageForward: increment by the adjustments page increment.
	SpinTypePageForward SpinType = 2
	// SpinTypePageBackward: decrement by the adjustments page increment.
	SpinTypePageBackward SpinType = 3
	// SpinTypeHome: go to the adjustments lower bound.
	SpinTypeHome SpinType = 4
	// SpinTypeEnd: go to the adjustments upper bound.
	SpinTypeEnd SpinType = 5
	// SpinTypeUserDefined: change by a specified amount.
	SpinTypeUserDefined SpinType = 6
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StackTransitionType: possible transitions between pages in a `GtkStack`
// widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType int

const (
	// StackTransitionTypeNone: no transition
	StackTransitionTypeNone StackTransitionType = 0
	// StackTransitionTypeCrossfade: a cross-fade
	StackTransitionTypeCrossfade StackTransitionType = 1
	// StackTransitionTypeSlideRight: slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = 2
	// StackTransitionTypeSlideLeft: slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = 3
	// StackTransitionTypeSlideUp: slide from bottom up
	StackTransitionTypeSlideUp StackTransitionType = 4
	// StackTransitionTypeSlideDown: slide from top down
	StackTransitionTypeSlideDown StackTransitionType = 5
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = 6
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
	StackTransitionTypeSlideUpDown StackTransitionType = 7
	// StackTransitionTypeOverUp: cover the old page by sliding up
	StackTransitionTypeOverUp StackTransitionType = 8
	// StackTransitionTypeOverDown: cover the old page by sliding down
	StackTransitionTypeOverDown StackTransitionType = 9
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left
	StackTransitionTypeOverLeft StackTransitionType = 10
	// StackTransitionTypeOverRight: cover the old page by sliding to the right
	StackTransitionTypeOverRight StackTransitionType = 11
	// StackTransitionTypeUnderUp: uncover the new page by sliding up
	StackTransitionTypeUnderUp StackTransitionType = 12
	// StackTransitionTypeUnderDown: uncover the new page by sliding down
	StackTransitionTypeUnderDown StackTransitionType = 13
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the left
	StackTransitionTypeUnderLeft StackTransitionType = 14
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right
	StackTransitionTypeUnderRight StackTransitionType = 15
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order
	StackTransitionTypeOverUpDown StackTransitionType = 16
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order
	StackTransitionTypeOverDownUp StackTransitionType = 17
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order
	StackTransitionTypeOverLeftRight StackTransitionType = 18
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order
	StackTransitionTypeOverRightLeft StackTransitionType = 19
	// StackTransitionTypeRotateLeft: pretend the pages are sides of a cube and
	// rotate that cube to the left
	StackTransitionTypeRotateLeft StackTransitionType = 20
	// StackTransitionTypeRotateRight: pretend the pages are sides of a cube and
	// rotate that cube to the right
	StackTransitionTypeRotateRight StackTransitionType = 21
	// StackTransitionTypeRotateLeftRight: pretend the pages are sides of a cube
	// and rotate that cube to the left or right according to the children order
	StackTransitionTypeRotateLeftRight StackTransitionType = 22
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StringFilterMatchMode specifies how search strings are matched inside text.
type StringFilterMatchMode int

const (
	// StringFilterMatchModeExact: the search string and text must match
	// exactly.
	StringFilterMatchModeExact StringFilterMatchMode = 0
	// StringFilterMatchModeSubstring: the search string must be contained as a
	// substring inside the text.
	StringFilterMatchModeSubstring StringFilterMatchMode = 1
	// StringFilterMatchModePrefix: the text must begin with the search string.
	StringFilterMatchModePrefix StringFilterMatchMode = 2
)

func marshalStringFilterMatchMode(p uintptr) (interface{}, error) {
	return StringFilterMatchMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SystemSetting values that can be passed to the
// GtkWidgetClass.system_setting_changed vfunc.
//
// The values indicate which system setting has changed. Widgets may need to
// drop caches, or react otherwise.
//
// Most of the values correspond to `GtkSettings` properties.
//
// More values may be added over time.
type SystemSetting int

const (
	// SystemSettingDPI: the Settings:gtk-xft-dpi setting has changed
	SystemSettingDPI SystemSetting = 0
	// SystemSettingFontName: the Settings:gtk-font-name setting has changed
	SystemSettingFontName SystemSetting = 1
	// SystemSettingFontConfig: the font configuration has changed in a way that
	// requires text to be redrawn. This can be any of the
	// Settings:gtk-xft-antialias, Settings:gtk-xft-hinting,
	// Settings:gtk-xft-hintstyle, Settings:gtk-xft-rgba or
	// Settings:gtk-fontconfig-timestamp settings
	SystemSettingFontConfig SystemSetting = 2
	// SystemSettingDisplay: the display has changed
	SystemSettingDisplay SystemSetting = 3
	// SystemSettingIconTheme: the icon theme has changed in a way that requires
	// icons to be looked up again
	SystemSettingIconTheme SystemSetting = 4
)

func marshalSystemSetting(p uintptr) (interface{}, error) {
	return SystemSetting(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirectionNone: no direction.
	TextDirectionNone TextDirection = 0
	// TextDirectionLTR: left to right text direction.
	TextDirectionLTR TextDirection = 1
	// TextDirectionRTL: right to left text direction.
	TextDirectionRTL TextDirection = 2
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = 0
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine TextExtendSelection = 1
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background).
	TextViewLayerBelowText TextViewLayer = 0
	// TextViewLayerAboveText: the layer rendered above the text.
	TextViewLayerAboveText TextViewLayer = 1
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowTypeWidget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// TextWindowTypeText: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// TextWindowTypeLeft: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// TextWindowTypeRight: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// TextWindowTypeTop: top border window.
	TextWindowTypeTop TextWindowType = 5
	// TextWindowTypeBottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
type TreeViewColumnSizing int

const (
	// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
	TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
	// TreeViewColumnSizingAutosize columns resize to be the optimal size every
	// time the model changes.
	TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
	// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
	TreeViewColumnSizingFixed TreeViewColumnSizing = 2
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewDropPosition: an enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropPositionBefore: dropped row is inserted before
	TreeViewDropPositionBefore TreeViewDropPosition = 0
	// TreeViewDropPositionAfter: dropped row is inserted after
	TreeViewDropPositionAfter TreeViewDropPosition = 1
	// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
	TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
	// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
	TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = 0
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal TreeViewGridLines = 1
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical TreeViewGridLines = 2
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth TreeViewGridLines = 3
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = 0
	// UnitPoints dimensions in points.
	UnitPoints Unit = 1
	// UnitInch dimensions in inches.
	UnitInch Unit = 2
	// UnitMm dimensions in millimeters
	UnitMm Unit = 3
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode describes a type of line wrapping.
type WrapMode int

const (
	// WrapModeNone: do not wrap lines; just make the text area wider
	WrapModeNone WrapMode = 0
	// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapModeChar WrapMode = 1
	// WrapModeWord: wrap text, breaking lines in between words
	WrapModeWord WrapMode = 2
	// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
	WrapModeWordChar WrapMode = 3
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// `GtkApplication`.
//
// See [method@Gtk.Application.inhibit].
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 2
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 4
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 8
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderClosureFlags: the list of flags that can be passed to
// gtk_builder_create_closure().
//
// New values may be added in the future for new features, so external
// implementations of [interface@Gtk.BuilderScope] should test the flags for
// unknown values and raise a GTK_BUILDER_ERROR_INVALID_ATTRIBUTE error when
// they encounter one.
type BuilderClosureFlags int

const (
	// BuilderClosureFlagsSwapped: the closure should be created swapped. See
	// g_cclosure_new_swap() for details.
	BuilderClosureFlagsSwapped BuilderClosureFlags = 1
)

func marshalBuilderClosureFlags(p uintptr) (interface{}, error) {
	return BuilderClosureFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState int

const (
	// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
	CellRendererStateSelected CellRendererState = 1
	// CellRendererStatePrelit: the mouse is hovering over the cell.
	CellRendererStatePrelit CellRendererState = 2
	// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
	CellRendererStateInsensitive CellRendererState = 4
	// CellRendererStateSorted: the cell is in a sorted row
	CellRendererStateSorted CellRendererState = 8
	// CellRendererStateFocused: the cell is in the focus row.
	CellRendererStateFocused CellRendererState = 16
	// CellRendererStateExpandable: the cell is in a row that can be expanded
	CellRendererStateExpandable CellRendererState = 32
	// CellRendererStateExpanded: the cell is in a row that is expanded
	CellRendererStateExpanded CellRendererState = 64
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DebugFlags int

const (
	DebugFlagsText           DebugFlags = 1
	DebugFlagsTree           DebugFlags = 2
	DebugFlagsKeybindings    DebugFlags = 4
	DebugFlagsModules        DebugFlags = 8
	DebugFlagsGeometry       DebugFlags = 16
	DebugFlagsIcontheme      DebugFlags = 32
	DebugFlagsPrinting       DebugFlags = 64
	DebugFlagsBuilder        DebugFlags = 128
	DebugFlagsSizeRequest    DebugFlags = 256
	DebugFlagsNoCSSCache     DebugFlags = 512
	DebugFlagsInteractive    DebugFlags = 1024
	DebugFlagsTouchscreen    DebugFlags = 2048
	DebugFlagsActions        DebugFlags = 4096
	DebugFlagsLayout         DebugFlags = 8192
	DebugFlagsSnapshot       DebugFlags = 16384
	DebugFlagsConstraints    DebugFlags = 32768
	DebugFlagsBuilderObjects DebugFlags = 65536
	DebugFlagsA11Y           DebugFlags = 131072
	DebugFlagsIconfallback   DebugFlags = 262144
)

func marshalDebugFlags(p uintptr) (interface{}, error) {
	return DebugFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal
	DialogFlagsModal DialogFlags = 1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed
	DialogFlagsDestroyWithParent DialogFlags = 2
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area
	DialogFlagsUseHeaderBar DialogFlags = 4
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventControllerScrollFlags describes the behavior of a
// `GtkEventControllerScroll`.
type EventControllerScrollFlags int

const (
	// EventControllerScrollFlagsNone: don't emit scroll.
	EventControllerScrollFlagsNone EventControllerScrollFlags = 0
	// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
	EventControllerScrollFlagsVertical EventControllerScrollFlags = 1
	// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 2
	// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
	EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 4
	// EventControllerScrollFlagsKinetic: emit ::decelerate after continuous
	// scroll finishes.
	EventControllerScrollFlagsKinetic EventControllerScrollFlags = 8
	// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
	EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 3
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontChooserLevel specifies the granularity of font selection that is desired
// in a `GtkFontChooser`.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel int

const (
	// FontChooserLevelFamily: allow selecting a font family
	FontChooserLevelFamily FontChooserLevel = 0
	// FontChooserLevelStyle: allow selecting a specific font face
	FontChooserLevelStyle FontChooserLevel = 1
	// FontChooserLevelSize: allow selecting a specific font size
	FontChooserLevelSize FontChooserLevel = 2
	// FontChooserLevelVariations: allow changing OpenType font variation axes
	FontChooserLevelVariations FontChooserLevel = 4
	// FontChooserLevelFeatures: allow selecting specific OpenType font features
	FontChooserLevelFeatures FontChooserLevel = 8
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon().
type IconLookupFlags int

const (
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given
	IconLookupFlagsForceRegular IconLookupFlags = 1
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given
	IconLookupFlagsForceSymbolic IconLookupFlags = 2
	// IconLookupFlagsPreload starts loading the texture in the background so it
	// is ready when later needed.
	IconLookupFlagsPreload IconLookupFlags = 4
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputHints describes hints that might be taken into account by input methods
// or applications.
//
// Note that input methods may already tailor their behaviour according to the
// `GtkInputPurpose` of the entry.
//
// Some common sense is expected when using these flags - mixing
// GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintsNone: no special behaviour suggested
	InputHintsNone InputHints = 0
	// InputHintsSpellcheck: suggest checking for typos
	InputHintsSpellcheck InputHints = 1
	// InputHintsNoSpellcheck: suggest not checking for typos
	InputHintsNoSpellcheck InputHints = 2
	// InputHintsWordCompletion: suggest word completion
	InputHintsWordCompletion InputHints = 4
	// InputHintsLowercase: suggest to convert all text to lowercase
	InputHintsLowercase InputHints = 8
	// InputHintsUppercaseChars: suggest to capitalize all text
	InputHintsUppercaseChars InputHints = 16
	// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintsUppercaseWords InputHints = 32
	// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
	InputHintsUppercaseSentences InputHints = 64
	// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintsInhibitOsk InputHints = 128
	// InputHintsVerticalWriting: the text is vertical
	InputHintsVerticalWriting InputHints = 256
	// InputHintsEmoji: suggest offering Emoji support
	InputHintsEmoji InputHints = 512
	// InputHintsNoEmoji: suggest not offering Emoji support
	InputHintsNoEmoji InputHints = 1024
	// InputHintsPrivate: request that the input method should not update
	// personalized data (like typing history)
	InputHintsPrivate InputHints = 2048
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PickFlags flags that influence the behavior of gtk_widget_pick().
type PickFlags int

const (
	// PickFlagsDefault: the default behavior, include widgets that are
	// receiving events
	PickFlagsDefault PickFlags = 0
	// PickFlagsInsensitive: include widgets that are insensitive
	PickFlagsInsensitive PickFlags = 1
	// PickFlagsNonTargetable: include widgets that are marked as
	// non-targetable. See Widget:can-target
	PickFlagsNonTargetable PickFlags = 2
)

func marshalPickFlags(p uintptr) (interface{}, error) {
	return PickFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PopoverMenuFlags flags that affect how popover menus are created from a menu
// model.
type PopoverMenuFlags int

const (
	// PopoverMenuFlagsNested: create submenus as nested popovers. Without this
	// flag, submenus are created as sliding pages that replace the main menu.
	PopoverMenuFlagsNested PopoverMenuFlags = 1
)

func marshalPopoverMenuFlags(p uintptr) (interface{}, error) {
	return PopoverMenuFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintCapabilities specifies which features the print dialog should offer.
//
// If neither GTK_PRINT_CAPABILITY_GENERATE_PDF nor
// GTK_PRINT_CAPABILITY_GENERATE_PS is specified, GTK assumes that all formats
// are supported.
type PrintCapabilities int

const (
	// PrintCapabilitiesPageSet: print dialog will offer printing even/odd
	// pages.
	PrintCapabilitiesPageSet PrintCapabilities = 1
	// PrintCapabilitiesCopies: print dialog will allow to print multiple
	// copies.
	PrintCapabilitiesCopies PrintCapabilities = 2
	// PrintCapabilitiesCollate: print dialog will allow to collate multiple
	// copies.
	PrintCapabilitiesCollate PrintCapabilities = 4
	// PrintCapabilitiesReverse: print dialog will allow to print pages in
	// reverse order.
	PrintCapabilitiesReverse PrintCapabilities = 8
	// PrintCapabilitiesScale: print dialog will allow to scale the output.
	PrintCapabilitiesScale PrintCapabilities = 16
	// PrintCapabilitiesGeneratePDF: the program will send the document to the
	// printer in PDF format
	PrintCapabilitiesGeneratePDF PrintCapabilities = 32
	// PrintCapabilitiesGeneratePS: the program will send the document to the
	// printer in Postscript format
	PrintCapabilitiesGeneratePS PrintCapabilities = 64
	// PrintCapabilitiesPreview: print dialog will offer a preview
	PrintCapabilitiesPreview PrintCapabilities = 128
	// PrintCapabilitiesNumberUp: print dialog will offer printing multiple
	// pages per sheet
	PrintCapabilitiesNumberUp PrintCapabilities = 256
	// PrintCapabilitiesNumberUpLayout: print dialog will allow to rearrange
	// pages when printing multiple pages per sheet
	PrintCapabilitiesNumberUpLayout PrintCapabilities = 512
)

func marshalPrintCapabilities(p uintptr) (interface{}, error) {
	return PrintCapabilities(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutActionFlags: list of flags that can be passed to action activation.
//
// More flags may be added in the future.
type ShortcutActionFlags int

const (
	// ShortcutActionFlagsExclusive: the action is the only action that can be
	// activated. If this flag is not set, a future activation may select a
	// different action.
	ShortcutActionFlagsExclusive ShortcutActionFlags = 1
)

func marshalShortcutActionFlags(p uintptr) (interface{}, error) {
	return ShortcutActionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateFlags describes a widget state.
//
// Widget states are used to match the widget against CSS pseudo-classes. Note
// that GTK extends the regular CSS classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagsNormal: state during normal operation
	StateFlagsNormal StateFlags = 0
	// StateFlagsActive: widget is active
	StateFlagsActive StateFlags = 1
	// StateFlagsPrelight: widget has a mouse pointer over it
	StateFlagsPrelight StateFlags = 2
	// StateFlagsSelected: widget is selected
	StateFlagsSelected StateFlags = 4
	// StateFlagsInsensitive: widget is insensitive
	StateFlagsInsensitive StateFlags = 8
	// StateFlagsInconsistent: widget is inconsistent
	StateFlagsInconsistent StateFlags = 16
	// StateFlagsFocused: widget has the keyboard focus
	StateFlagsFocused StateFlags = 32
	// StateFlagsBackdrop: widget is in a background toplevel window
	StateFlagsBackdrop StateFlags = 64
	// StateFlagsDirLTR: widget is in left-to-right text direction
	StateFlagsDirLTR StateFlags = 128
	// StateFlagsDirRTL: widget is in right-to-left text direction
	StateFlagsDirRTL StateFlags = 256
	// StateFlagsLink: widget is a link
	StateFlagsLink StateFlags = 512
	// StateFlagsVisited: the location the widget points to has already been
	// visited
	StateFlagsVisited StateFlags = 1024
	// StateFlagsChecked: widget is checked
	StateFlagsChecked StateFlags = 2048
	// StateFlagsDropActive: widget is highlighted as a drop target for DND
	StateFlagsDropActive StateFlags = 4096
	// StateFlagsFocusVisible: widget has the visible focus
	StateFlagsFocusVisible StateFlags = 8192
	// StateFlagsFocusWithin: widget contains the keyboard focus
	StateFlagsFocusWithin StateFlags = 16384
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string().
//
// New values may be added to this enumeration.
type StyleContextPrintFlags int

const (
	// StyleContextPrintFlagsNone: default value.
	StyleContextPrintFlagsNone StyleContextPrintFlags = 0
	// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
	StyleContextPrintFlagsRecurse StyleContextPrintFlags = 1
	// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
	StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 2
	// StyleContextPrintFlagsShowChange: show information about what changes
	// affect the styles
	StyleContextPrintFlagsShowChange StyleContextPrintFlags = 4
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither GTK_TEXT_SEARCH_VISIBLE_ONLY nor GTK_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded paintables or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 1
	// TextSearchFlagsTextOnly: search only text. A match may have paintables or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 2
	// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 4
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 2
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AcceleratorGetDefaultModMask gets the modifier mask.
//
// The modifier mask determines which modifiers are considered significant for
// keyboard accelerators. This includes all keyboard modifiers except for
// GDK_LOCK_MASK.
func AcceleratorGetDefaultModMask() gdk.ModifierType {
	var _cret C.GdkModifierType // in

	_cret = C.gtk_accelerator_get_default_mod_mask()

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// AcceleratorGetLabel converts an accelerator keyval and modifier mask into a
// string which can be used to represent the accelerator to the user.
func AcceleratorGetLabel(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret *C.char           // in

	_arg1 = (C.guint)(acceleratorKey)
	_arg2 = (C.GdkModifierType)(acceleratorMods)

	_cret = C.gtk_accelerator_get_label(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorGetLabelWithKeycode converts an accelerator keyval and modifier
// mask into a string that can be displayed to the user.
//
// The string may be translated.
//
// This function is similar to [func@Gtk.accelerator_get_label], but handling
// keycodes.
//
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
func AcceleratorGetLabelWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 *C.GdkDisplay     // out
	var _arg2 C.guint           // out
	var _arg3 C.guint           // out
	var _arg4 C.GdkModifierType // out
	var _cret *C.char           // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
	_arg2 = (C.guint)(acceleratorKey)
	_arg3 = (C.guint)(keycode)
	_arg4 = (C.GdkModifierType)(acceleratorMods)

	_cret = C.gtk_accelerator_get_label_with_keycode(_arg1, _arg2, _arg3, _arg4)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorName converts an accelerator keyval and modifier mask into a
// string parseable by gtk_accelerator_parse().
//
// For example, if you pass in GDK_KEY_q and GDK_CONTROL_MASK, this function
// returns `<Control>q`.
//
// If you need to display accelerators in the user interface, see
// [func@Gtk.accelerator_get_label].
func AcceleratorName(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret *C.char           // in

	_arg1 = (C.guint)(acceleratorKey)
	_arg2 = (C.GdkModifierType)(acceleratorMods)

	_cret = C.gtk_accelerator_name(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorNameWithKeycode converts an accelerator keyval and modifier mask
// into a string parseable by gtk_accelerator_parse_with_keycode().
//
// This is similar to [func@Gtk.accelerator_name] but handling keycodes. This is
// only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
func AcceleratorNameWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 *C.GdkDisplay     // out
	var _arg2 C.guint           // out
	var _arg3 C.guint           // out
	var _arg4 C.GdkModifierType // out
	var _cret *C.char           // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
	_arg2 = (C.guint)(acceleratorKey)
	_arg3 = (C.guint)(keycode)
	_arg4 = (C.GdkModifierType)(acceleratorMods)

	_cret = C.gtk_accelerator_name_with_keycode(_arg1, _arg2, _arg3, _arg4)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorParse parses a string representing an accelerator.
//
// The format looks like <Control>a or <Shift><Alt>F1.
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as <Ctl> and <Ctrl>. Key names are parsed using
// [func@Gdk.keyval_from_name]. For character keys the name is not the symbol,
// but the lowercase name, e.g. one would use <Ctrl>minus instead of
// <Ctrl>-.
//
// If the parse fails, @accelerator_key and @accelerator_mods will be set to 0
// (zero).
func AcceleratorParse(accelerator string) (uint, gdk.ModifierType, bool) {
	var _arg1 *C.char           // out
	var _arg2 C.guint           // in
	var _arg3 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg1 = (*C.char)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_accelerator_parse(_arg1, &_arg2, &_arg3)

	var _acceleratorKey uint              // out
	var _acceleratorMods gdk.ModifierType // out
	var _ok bool                          // out

	_acceleratorKey = (uint)(_arg2)
	_acceleratorMods = gdk.ModifierType(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _acceleratorKey, _acceleratorMods, _ok
}

// AcceleratorParseWithKeycode parses a string representing an accelerator.
//
// This is similar to [func@Gtk.accelerator_parse] but handles keycodes as well.
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If @accelerator_codes is given and the result stored in it is non-nil, the
// result must be freed with g_free().
//
// If a keycode is present in the accelerator and no @accelerator_codes is
// given, the parse will fail.
//
// If the parse fails, @accelerator_key, @accelerator_mods and
// @accelerator_codes will be set to 0 (zero).
func AcceleratorParseWithKeycode(accelerator string, display gdk.Display) (uint, []uint, gdk.ModifierType, bool) {
	var _arg1 *C.char       // out
	var _arg2 *C.GdkDisplay // out
	var _arg3 C.guint       // in
	var _arg4 *C.guint
	var _arg5 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg1 = (*C.char)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	_cret = C.gtk_accelerator_parse_with_keycode(_arg1, _arg2, &_arg3, &_arg4, &_arg5)

	var _acceleratorKey uint // out
	var _acceleratorCodes []uint
	var _acceleratorMods gdk.ModifierType // out
	var _ok bool                          // out

	_acceleratorKey = (uint)(_arg3)
	{
		var i int
		var z C.guint
		for p := _arg4; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg4, i)
		_acceleratorCodes = make([]uint, i)
		for i := range src {
			_acceleratorCodes[i] = (uint)(src[i])
		}
	}
	_acceleratorMods = gdk.ModifierType(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _acceleratorKey, _acceleratorCodes, _acceleratorMods, _ok
}

// AcceleratorValid determines whether a given keyval and modifier mask
// constitute a valid keyboard accelerator.
//
// For example, the GDK_KEY_a keyval plus GDK_CONTROL_MASK mark is valid, and
// matches the Ctrl+a accelerator. But, you can't, for instance, use the
// GDK_KEY_Control_L keyval as an accelerator.
func AcceleratorValid(keyval uint, modifiers gdk.ModifierType) bool {
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg1 = (C.guint)(keyval)
	_arg2 = (C.GdkModifierType)(modifiers)

	_cret = C.gtk_accelerator_valid(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CheckVersion checks that the GTK library in use is compatible with the given
// version.
//
// Generally you would pass in the constants GTK_MAJOR_VERSION,
// GTK_MINOR_VERSION, GTK_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GTK the application or module was compiled against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
//
// This function is primarily for GTK modules; the module can call this function
// to check that it wasnt loaded into an incompatible version of GTK. However,
// such a check isnt completely reliable, since the module may be linked
// against an old version of GTK and calling the old version of
// gtk_check_version(), but still get loaded into an application using a newer
// version of GTK.
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var _arg1 C.guint // out
	var _arg2 C.guint // out
	var _arg3 C.guint // out
	var _cret *C.char // in

	_arg1 = (C.guint)(requiredMajor)
	_arg2 = (C.guint)(requiredMinor)
	_arg3 = (C.guint)(requiredMicro)

	_cret = C.gtk_check_version(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// DisableSetlocale prevents [id@gtk_init] and [id@gtk_init_check] from
// automatically calling `setlocale (LC_ALL, "")`.
//
// You would want to use this function if you wanted to set the locale for your
// program to something other than the users locale, or if you wanted to set
// different values for different locale categories.
//
// Most programs should not need to call this function.
func DisableSetlocale() {
	C.gtk_disable_setlocale()
}

// DistributeNaturalAllocation distributes @extra_space to child @sizes by
// bringing smaller children up to natural size first.
//
// The remaining space will be added to the @minimum_size member of the
// `GtkRequestedSize` struct. If all sizes reach their natural size then the
// remaining space is returned.
func DistributeNaturalAllocation(extraSpace int, sizes []RequestedSize) int {
	var _arg1 C.int // out
	var _arg3 *C.GtkRequestedSize
	var _arg2 C.guint
	var _cret C.int // in

	_arg1 = (C.int)(extraSpace)
	_arg2 = C.guint(len(sizes))
	_arg3 = (*C.GtkRequestedSize)(unsafe.Pointer(&sizes[0]))

	_cret = C.gtk_distribute_natural_allocation(_arg1, _arg2, _arg3)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// GetBinaryAge returns the binary age as passed to `libtool`.
//
// If `libtool` means nothing to you, don't worry about it.
func GetBinaryAge() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_binary_age()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetDebugFlags returns the GTK debug flags that are currently active.
//
// This function is intended for GTK modules that want to adjust their debug
// output based on GTK debug flags.
func GetDebugFlags() DebugFlags {
	var _cret C.GtkDebugFlags // in

	_cret = C.gtk_get_debug_flags()

	var _debugFlags DebugFlags // out

	_debugFlags = DebugFlags(_cret)

	return _debugFlags
}

// GetDefaultLanguage returns the Language for the default language currently in
// effect. (Note that this can change over the life of an application.) The
// default language is derived from the current locale. It determines, for
// example, whether GTK uses the right-to-left or left-to-right text direction.
//
// This function is equivalent to pango_language_get_default(). See that
// function for details.
func GetDefaultLanguage() *pango.Language {
	var _cret *C.PangoLanguage // in

	_cret = C.gtk_get_default_language()

	var _language *pango.Language // out

	_language = pango.WrapLanguage(unsafe.Pointer(_cret))

	return _language
}

// GetInterfaceAge returns the interface age as passed to `libtool`.
//
// If `libtool` means nothing to you, don't worry about it.
func GetInterfaceAge() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_interface_age()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetLocaleDirection: get the direction of the current locale. This is the
// expected reading direction for text and UI.
//
// This function depends on the current locale being set with setlocale() and
// will default to setting the GTK_TEXT_DIR_LTR direction otherwise.
// GTK_TEXT_DIR_NONE will never be returned.
//
// GTK sets the default text direction according to the locale during
// gtk_init(), and you should normally use gtk_widget_get_direction() or
// gtk_widget_get_default_direction() to obtain the current direction.
//
// This function is only needed rare cases when the locale is changed after GTK
// has already been initialized. In this case, you can use it to update the
// default text direction as follows:
//
//    setlocale (LC_ALL, new_locale);
//    direction = gtk_get_locale_direction ();
//    gtk_widget_set_default_direction (direction);
func GetLocaleDirection() TextDirection {
	var _cret C.GtkTextDirection // in

	_cret = C.gtk_get_locale_direction()

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// GetMajorVersion returns the major version number of the GTK library.
//
// For example, in GTK version 3.1.5 this is 3.
//
// This function is in the library, so it represents the GTK library your code
// is running against. Contrast with the GTK_MAJOR_VERSION macro, which
// represents the major version of the GTK headers you have included when
// compiling your code.
func GetMajorVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_major_version()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetMicroVersion returns the micro version number of the GTK library.
//
// For example, in GTK version 3.1.5 this is 5.
//
// This function is in the library, so it represents the GTK library your code
// is are running against. Contrast with the GTK_MICRO_VERSION macro, which
// represents the micro version of the GTK headers you have included when
// compiling your code.
func GetMicroVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_micro_version()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetMinorVersion returns the minor version number of the GTK library.
//
// For example, in GTK version 3.1.5 this is 1.
//
// This function is in the library, so it represents the GTK library your code
// is are running against. Contrast with the GTK_MINOR_VERSION macro, which
// represents the minor version of the GTK headers you have included when
// compiling your code.
func GetMinorVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_minor_version()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// HSVToRGB converts a color from HSV space to RGB.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
func HSVToRGB(h float32, s float32, v float32) (r float32, g float32, b float32) {
	var _arg1 C.float // out
	var _arg2 C.float // out
	var _arg3 C.float // out
	var _arg4 C.float // in
	var _arg5 C.float // in
	var _arg6 C.float // in

	_arg1 = (C.float)(h)
	_arg2 = (C.float)(s)
	_arg3 = (C.float)(v)

	C.gtk_hsv_to_rgb(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)

	var _r float32 // out
	var _g float32 // out
	var _b float32 // out

	_r = (float32)(_arg4)
	_g = (float32)(_arg5)
	_b = (float32)(_arg6)

	return _r, _g, _b
}

// Init: call this function before using any other GTK functions in your GUI
// applications. It will initialize everything needed to operate the toolkit and
// parses some standard command line options.
//
// If you are using Application, you don't have to call gtk_init() or
// gtk_init_check(); the #GApplication::startup handler does it for you.
//
// This function will terminate your program if it was unable to initialize the
// windowing system for some reason. If you want your program to fall back to a
// textual interface you want to call gtk_init_check() instead.
//
// GTK calls `signal (SIGPIPE, SIG_IGN)` during initialization, to ignore
// SIGPIPE signals, since these are almost never wanted in graphical
// applications. If you do need to handle SIGPIPE for some reason, reset the
// handler after gtk_init(), but notice that other libraries (e.g. libdbus or
// gvfs) might do similar things.
func Init() {
	C.gtk_init()
}

// InitCheck: this function does the same work as gtk_init() with only a single
// change: It does not terminate the program if the windowing system cant be
// initialized. Instead it returns false on failure.
//
// This way the application can fall back to some other means of communication
// with the user - for example a curses or command line interface.
func InitCheck() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_init_check()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsInitialized: use this function to check if GTK has been initialized with
// gtk_init() or gtk_init_check().
func IsInitialized() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_is_initialized()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PrintRunPageSetupDialog runs a page setup dialog, letting the user modify the
// values from @page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in @page_setup, otherwise it contains
// the modifications done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
func PrintRunPageSetupDialog(parent Window, pageSetup PageSetup, settings PrintSettings) PageSetup {
	var _arg1 *C.GtkWindow        // out
	var _arg2 *C.GtkPageSetup     // out
	var _arg3 *C.GtkPrintSettings // out
	var _cret *C.GtkPageSetup     // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))
	_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))

	_cret = C.gtk_print_run_page_setup_dialog(_arg1, _arg2, _arg3)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

// RenderActivity renders an activity indicator (such as in Spinner). The state
// GTK_STATE_FLAG_CHECKED determines whether there is activity going on.
func RenderActivity(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x)
	_arg4 = (C.double)(y)
	_arg5 = (C.double)(width)
	_arg6 = (C.double)(height)

	C.gtk_render_activity(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderArrow renders an arrow pointing to @angle.
//
// Typical arrow rendering at 0, 12 ;, ; and 32 :
//
// ! (arrows.png)
func RenderArrow(context StyleContext, cr *cairo.Context, angle float64, x float64, y float64, size float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(angle)
	_arg4 = (C.double)(x)
	_arg5 = (C.double)(y)
	_arg6 = (C.double)(size)

	C.gtk_render_arrow(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderBackground renders the background of an element.
//
// Typical background rendering, showing the effect of `background-image`,
// `border-width` and `border-radius`:
//
// ! (background.png)
func RenderBackground(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x)
	_arg4 = (C.double)(y)
	_arg5 = (C.double)(width)
	_arg6 = (C.double)(height)

	C.gtk_render_background(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderCheck renders a checkmark (as in a CheckButton).
//
// The GTK_STATE_FLAG_CHECKED state determines whether the check is on or off,
// and GTK_STATE_FLAG_INCONSISTENT determines whether it should be marked as
// undefined.
//
// Typical checkmark rendering:
//
// ! (checks.png)
func RenderCheck(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x)
	_arg4 = (C.double)(y)
	_arg5 = (C.double)(width)
	_arg6 = (C.double)(height)

	C.gtk_render_check(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderExpander renders an expander (as used in TreeView and Expander) in the
// area defined by @x, @y, @width, @height. The state GTK_STATE_FLAG_CHECKED
// determines whether the expander is collapsed or expanded.
//
// Typical expander rendering:
//
// ! (expanders.png)
func RenderExpander(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x)
	_arg4 = (C.double)(y)
	_arg5 = (C.double)(width)
	_arg6 = (C.double)(height)

	C.gtk_render_expander(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderFocus renders a focus indicator on the rectangle determined by @x, @y,
// @width, @height.
//
// Typical focus rendering:
//
// ! (focus.png)
func RenderFocus(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x)
	_arg4 = (C.double)(y)
	_arg5 = (C.double)(width)
	_arg6 = (C.double)(height)

	C.gtk_render_focus(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderFrame renders a frame around the rectangle defined by @x, @y, @width,
// @height.
//
// Examples of frame rendering, showing the effect of `border-image`,
// `border-color`, `border-width`, `border-radius` and junctions:
//
// ! (frames.png)
func RenderFrame(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x)
	_arg4 = (C.double)(y)
	_arg5 = (C.double)(width)
	_arg6 = (C.double)(height)

	C.gtk_render_frame(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderHandle renders a handle (as in Paned and Windows resize grip), in the
// rectangle determined by @x, @y, @width, @height.
//
// Handles rendered for the paned and grip classes:
//
// ! (handles.png)
func RenderHandle(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x)
	_arg4 = (C.double)(y)
	_arg5 = (C.double)(width)
	_arg6 = (C.double)(height)

	C.gtk_render_handle(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderIcon renders the icon in @texture at the specified @x and @y
// coordinates.
//
// This function will render the icon in @texture at exactly its size,
// regardless of scaling factors, which may not be appropriate when drawing on
// displays with high pixel densities.
func RenderIcon(context StyleContext, cr *cairo.Context, texture gdk.Texture, x float64, y float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 *C.GdkTexture      // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	_arg4 = (C.double)(x)
	_arg5 = (C.double)(y)

	C.gtk_render_icon(_arg1, _arg2, _arg3, _arg4, _arg5)
}

// RenderLayout renders @layout on the coordinates @x, @y
func RenderLayout(context StyleContext, cr *cairo.Context, x float64, y float64, layout pango.Layout) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 *C.PangoLayout     // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x)
	_arg4 = (C.double)(y)
	_arg5 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.gtk_render_layout(_arg1, _arg2, _arg3, _arg4, _arg5)
}

// RenderLine renders a line from (x0, y0) to (x1, y1).
func RenderLine(context StyleContext, cr *cairo.Context, x0 float64, y0 float64, x1 float64, y1 float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x0)
	_arg4 = (C.double)(y0)
	_arg5 = (C.double)(x1)
	_arg6 = (C.double)(y1)

	C.gtk_render_line(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderOption renders an option mark (as in a radio button), the
// GTK_STATE_FLAG_CHECKED state will determine whether the option is on or off,
// and GTK_STATE_FLAG_INCONSISTENT whether it should be marked as undefined.
//
// Typical option mark rendering:
//
// ! (options.png)
func RenderOption(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.double)(x)
	_arg4 = (C.double)(y)
	_arg5 = (C.double)(width)
	_arg6 = (C.double)(height)

	C.gtk_render_option(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RGBToHSV converts a color from RGB space to HSV.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
func RGBToHSV(r float32, g float32, b float32) (h float32, s float32, v float32) {
	var _arg1 C.float // out
	var _arg2 C.float // out
	var _arg3 C.float // out
	var _arg4 C.float // in
	var _arg5 C.float // in
	var _arg6 C.float // in

	_arg1 = (C.float)(r)
	_arg2 = (C.float)(g)
	_arg3 = (C.float)(b)

	C.gtk_rgb_to_hsv(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)

	var _h float32 // out
	var _s float32 // out
	var _v float32 // out

	_h = (float32)(_arg4)
	_s = (float32)(_arg5)
	_v = (float32)(_arg6)

	return _h, _s, _v
}

// SetDebugFlags sets the GTK debug flags.
func SetDebugFlags(flags DebugFlags) {
	var _arg1 C.GtkDebugFlags // out

	_arg1 = (C.GtkDebugFlags)(flags)

	C.gtk_set_debug_flags(_arg1)
}

// ShowURI: this function launches the default application for showing a given
// uri, or shows an error dialog if that fails.
func ShowURI(parent Window, uri string, timestamp uint32) {
	var _arg1 *C.GtkWindow // out
	var _arg2 *C.char      // out
	var _arg3 C.guint32    // out

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.guint32)(timestamp)

	C.gtk_show_uri(_arg1, _arg2, _arg3)
}

// ShowURIFullFinish finishes the gtk_show_uri() call and returns the result of
// the operation.
func ShowURIFullFinish(parent Window, result gio.AsyncResult) error {
	var _arg1 *C.GtkWindow    // out
	var _arg2 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.gtk_show_uri_full_finish(_arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func TestAccessibleAssertionMessageRole(domain string, file string, line int, fn string, expr string, accessible Accessible, expectedRole AccessibleRole, actualRole AccessibleRole) {
	var _arg1 *C.char             // out
	var _arg2 *C.char             // out
	var _arg3 C.int               // out
	var _arg4 *C.char             // out
	var _arg5 *C.char             // out
	var _arg6 *C.GtkAccessible    // out
	var _arg7 C.GtkAccessibleRole // out
	var _arg8 C.GtkAccessibleRole // out

	_arg1 = (*C.char)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(file))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.int)(line)
	_arg4 = (*C.char)(C.CString(fn))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.char)(C.CString(expr))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
	_arg7 = (C.GtkAccessibleRole)(expectedRole)
	_arg8 = (C.GtkAccessibleRole)(actualRole)

	C.gtk_test_accessible_assertion_message_role(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}

// TestAccessibleHasProperty checks whether the Accessible has @property set.
func TestAccessibleHasProperty(accessible Accessible, property AccessibleProperty) bool {
	var _arg1 *C.GtkAccessible        // out
	var _arg2 C.GtkAccessibleProperty // out
	var _cret C.gboolean              // in

	_arg1 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
	_arg2 = (C.GtkAccessibleProperty)(property)

	_cret = C.gtk_test_accessible_has_property(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestAccessibleHasRelation checks whether the Accessible has @relation set.
func TestAccessibleHasRelation(accessible Accessible, relation AccessibleRelation) bool {
	var _arg1 *C.GtkAccessible        // out
	var _arg2 C.GtkAccessibleRelation // out
	var _cret C.gboolean              // in

	_arg1 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
	_arg2 = (C.GtkAccessibleRelation)(relation)

	_cret = C.gtk_test_accessible_has_relation(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestAccessibleHasRole checks whether the Accessible:accessible-role of the
// accessible is @role.
func TestAccessibleHasRole(accessible Accessible, role AccessibleRole) bool {
	var _arg1 *C.GtkAccessible    // out
	var _arg2 C.GtkAccessibleRole // out
	var _cret C.gboolean          // in

	_arg1 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
	_arg2 = (C.GtkAccessibleRole)(role)

	_cret = C.gtk_test_accessible_has_role(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestAccessibleHasState checks whether the Accessible has @state set.
func TestAccessibleHasState(accessible Accessible, state AccessibleState) bool {
	var _arg1 *C.GtkAccessible     // out
	var _arg2 C.GtkAccessibleState // out
	var _cret C.gboolean           // in

	_arg1 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
	_arg2 = (C.GtkAccessibleState)(state)

	_cret = C.gtk_test_accessible_has_state(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestRegisterAllTypes: force registration of all core GTK object types.
//
// This allowes to refer to any of those object types via g_type_from_name()
// after calling this function.
func TestRegisterAllTypes() {
	C.gtk_test_register_all_types()
}

// TestWidgetWaitForDraw enters the main loop and waits for @widget to be
// drawn.
//
// In this context that means it waits for the frame clock of @widget to have
// run a full styling, layout and drawing cycle.
//
// This function is intended to be used for syncing with actions that depend on
// @widget relayouting or on interaction with the display server.
func TestWidgetWaitForDraw(widget Widget) {
	var _arg1 *C.GtkWidget // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_test_widget_wait_for_draw(_arg1)
}

// TreeCreateRowDragContent creates a content provider for dragging @path from
// @tree_model.
func TreeCreateRowDragContent(treeModel TreeModel, path *TreePath) gdk.ContentProvider {
	var _arg1 *C.GtkTreeModel       // out
	var _arg2 *C.GtkTreePath        // out
	var _cret *C.GdkContentProvider // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_create_row_drag_content(_arg1, _arg2)

	var _contentProvider gdk.ContentProvider // out

	_contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.ContentProvider)

	return _contentProvider
}

// TreeGetRowDragData obtains a @tree_model and @path from value of target type
// GTK_TYPE_TREE_ROW_DATA.
//
// The returned path must be freed with gtk_tree_path_free().
func TreeGetRowDragData(value *externglib.Value) (TreeModel, *TreePath, bool) {
	var _arg1 *C.GValue       // out
	var _arg2 *C.GtkTreeModel // in
	var _path *TreePath
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.gtk_tree_get_row_drag_data(_arg1, &_arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)))

	var _treeModel TreeModel // out

	var _ok bool // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(TreeModel)

	if _cret != 0 {
		_ok = true
	}

	return _treeModel, _path, _ok
}

// ValueDupExpression retrieves the `GtkExpression` stored inside the given
// `value`, and acquires a reference to it.
func ValueDupExpression(value *externglib.Value) Expression {
	var _arg1 *C.GValue        // out
	var _cret *C.GtkExpression // in

	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.gtk_value_dup_expression(_arg1)

	var _expression Expression // out

	_expression = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Expression)

	return _expression
}

// ValueGetExpression retrieves the `GtkExpression` stored inside the given
// `value`.
func ValueGetExpression(value *externglib.Value) Expression {
	var _arg1 *C.GValue        // out
	var _cret *C.GtkExpression // in

	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.gtk_value_get_expression(_arg1)

	var _expression Expression // out

	_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

	return _expression
}

// ValueSetExpression stores the given `GtkExpression` inside `value`.
//
// The `GValue` will acquire a reference to the `expression`.
func ValueSetExpression(value *externglib.Value, expression Expression) {
	var _arg1 *C.GValue        // out
	var _arg2 *C.GtkExpression // out

	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))
	_arg2 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	C.gtk_value_set_expression(_arg1, _arg2)
}

// ValueTakeExpression stores the given `GtkExpression` inside `value`.
//
// This function transfers the ownership of the `expression` to the `GValue`.
func ValueTakeExpression(value *externglib.Value, expression Expression) {
	var _arg1 *C.GValue        // out
	var _arg2 *C.GtkExpression // out

	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))
	_arg2 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	C.gtk_value_take_expression(_arg1, _arg2)
}

// Accessible: `GtkAccessible` is an interface for describing UI elements for
// Assistive Technologies.
//
// Every accessible implementation has:
//
//    - a role, represented by a value of the [enum@Gtk.AccessibleRole]
//      enumeration
//    - an attribute, represented by a set of [enum@Gtk.AccessibleState],
//      [enum@Gtk.AccessibleProperty] and [enum@Gtk.AccessibleRelation] values
//
// The role cannot be changed after instantiating a `GtkAccessible`
// implementation.
//
// The attributes are updated every time a UI element's state changes in a way
// that should be reflected by assistive technologies. For instance, if a
// `GtkWidget` visibility changes, the GTK_ACCESSIBLE_STATE_HIDDEN state will
// also change to reflect the [property@Gtk.Widget:visible] property.
type Accessible interface {

	// AccessibleRole retrieves the `GtkAccessibleRole` for the given
	// `GtkAccessible`.
	AccessibleRole() AccessibleRole
	// ResetProperty resets the accessible @property to its default value.
	ResetProperty(property AccessibleProperty)
	// ResetRelation resets the accessible @relation to its default value.
	ResetRelation(relation AccessibleRelation)
	// ResetState resets the accessible @state to its default value.
	ResetState(state AccessibleState)
	// UpdatePropertyValue updates an array of accessible properties.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible property change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value)
	// UpdateRelationValue updates an array of accessible relations.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible relation change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value)
	// UpdateStateValue updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	UpdateStateValue(states []AccessibleState, values []externglib.Value)
}

// accessible implements the Accessible interface.
type accessible struct {
}

var _ Accessible = (*accessible)(nil)

// WrapAccessible wraps a GObject to a type that implements
// interface Accessible. It is primarily used internally.
func WrapAccessible(obj *externglib.Object) Accessible {
	return accessible{
		Objector: obj,
	}
}

func marshalAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAccessible(obj), nil
}

func (s accessible) AccessibleRole() AccessibleRole {
	var _arg0 *C.GtkAccessible    // out
	var _cret C.GtkAccessibleRole // in

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_accessible_get_accessible_role(_arg0)

	var _accessibleRole AccessibleRole // out

	_accessibleRole = AccessibleRole(_cret)

	return _accessibleRole
}

func (s accessible) ResetProperty(property AccessibleProperty) {
	var _arg0 *C.GtkAccessible        // out
	var _arg1 C.GtkAccessibleProperty // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkAccessibleProperty)(property)

	C.gtk_accessible_reset_property(_arg0, _arg1)
}

func (s accessible) ResetRelation(relation AccessibleRelation) {
	var _arg0 *C.GtkAccessible        // out
	var _arg1 C.GtkAccessibleRelation // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkAccessibleRelation)(relation)

	C.gtk_accessible_reset_relation(_arg0, _arg1)
}

func (s accessible) ResetState(state AccessibleState) {
	var _arg0 *C.GtkAccessible     // out
	var _arg1 C.GtkAccessibleState // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkAccessibleState)(state)

	C.gtk_accessible_reset_state(_arg0, _arg1)
}

func (s accessible) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	var _arg0 *C.GtkAccessible // out
	var _arg2 *C.GtkAccessibleProperty
	var _arg1 C.int
	var _arg3 *C.GValue
	var _arg1 C.int

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(len(properties))
	_arg2 = (*C.GtkAccessibleProperty)(C.malloc(C.ulong(len(properties)) * C.ulong(C.sizeof_GtkAccessibleProperty)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(properties))
		for i := range properties {
			out[i] = (C.GtkAccessibleProperty)(properties[i])
		}
	}
	_arg1 = C.int(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			out[i] = (C.GValue)(unsafe.Pointer(&values[i].GValue))
		}
	}

	C.gtk_accessible_update_property_value(_arg0, _arg1, _arg2, _arg3)
}

func (s accessible) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	var _arg0 *C.GtkAccessible // out
	var _arg2 *C.GtkAccessibleRelation
	var _arg1 C.int
	var _arg3 *C.GValue
	var _arg1 C.int

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(len(relations))
	_arg2 = (*C.GtkAccessibleRelation)(C.malloc(C.ulong(len(relations)) * C.ulong(C.sizeof_GtkAccessibleRelation)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(relations))
		for i := range relations {
			out[i] = (C.GtkAccessibleRelation)(relations[i])
		}
	}
	_arg1 = C.int(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			out[i] = (C.GValue)(unsafe.Pointer(&values[i].GValue))
		}
	}

	C.gtk_accessible_update_relation_value(_arg0, _arg1, _arg2, _arg3)
}

func (s accessible) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	var _arg0 *C.GtkAccessible // out
	var _arg2 *C.GtkAccessibleState
	var _arg1 C.int
	var _arg3 *C.GValue
	var _arg1 C.int

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(len(states))
	_arg2 = (*C.GtkAccessibleState)(C.malloc(C.ulong(len(states)) * C.ulong(C.sizeof_GtkAccessibleState)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(states))
		for i := range states {
			out[i] = (C.GtkAccessibleState)(states[i])
		}
	}
	_arg1 = C.int(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			out[i] = (C.GValue)(unsafe.Pointer(&values[i].GValue))
		}
	}

	C.gtk_accessible_update_state_value(_arg0, _arg1, _arg2, _arg3)
}

// ActionableOverrider contains methods that are overridable. This
// interface is a subset of the interface Actionable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type ActionableOverrider interface {
	// ActionName gets the action name for @actionable.
	ActionName() string
	// ActionTargetValue gets the current target value of @actionable.
	ActionTargetValue() *glib.Variant
	// SetActionName specifies the name of the action with which this widget
	// should be associated.
	//
	// If @action_name is nil then the widget will be unassociated from any
	// previous action.
	//
	// Usually this function is used when the widget is located (or will be
	// located) within the hierarchy of a `GtkApplicationWindow`.
	//
	// Names are of the form win.save or app.quit for actions on the
	// containing `GtkApplicationWindow` or its associated `GtkApplication`,
	// respectively. This is the same form used for actions in the `GMenu`
	// associated with the window.
	SetActionName(actionName string)
	// SetActionTargetValue sets the target value of an actionable widget.
	//
	// If @target_value is nil then the target value is unset.
	//
	// The target value has two purposes. First, it is used as the parameter to
	// activation of the action associated with the `GtkActionable` widget.
	// Second, it is used to determine if the widget should be rendered as
	// active  the widget is active if the state is equal to the given
	// target.
	//
	// Consider the example of associating a set of buttons with a `GAction`
	// with string state in a typical radio button situation. Each button will
	// be associated with the same action, but with a different target value for
	// that action. Clicking on a particular button will activate the action
	// with the target of that button, which will typically cause the actions
	// state to change to that value. Since the actions state is now equal to
	// the target value of the button, the button will now be rendered as active
	// (and the other buttons, with different targets, rendered inactive).
	SetActionTargetValue(targetValue *glib.Variant)
}

// Actionable: the `GtkActionable` interface provides a convenient way of
// asscociating widgets with actions.
//
// It primarily consists of two properties:
// [property@Gtk.Actionable:action-name] and
// [property@Gtk.Actionable:action-target]. There are also some convenience APIs
// for setting these properties.
//
// The action will be looked up in action groups that are found among the
// widgets ancestors. Most commonly, these will be the actions with the win.
// or app. prefix that are associated with the `GtkApplicationWindow` or
// `GtkApplication`, but other action groups that are added with
// [method@Gtk.Widget.insert_action_group] will be consulted as well.
type Actionable interface {

	// ActionName gets the action name for @actionable.
	ActionName() string
	// ActionTargetValue gets the current target value of @actionable.
	ActionTargetValue() *glib.Variant
	// SetActionName specifies the name of the action with which this widget
	// should be associated.
	//
	// If @action_name is nil then the widget will be unassociated from any
	// previous action.
	//
	// Usually this function is used when the widget is located (or will be
	// located) within the hierarchy of a `GtkApplicationWindow`.
	//
	// Names are of the form win.save or app.quit for actions on the
	// containing `GtkApplicationWindow` or its associated `GtkApplication`,
	// respectively. This is the same form used for actions in the `GMenu`
	// associated with the window.
	SetActionName(actionName string)
	// SetActionTargetValue sets the target value of an actionable widget.
	//
	// If @target_value is nil then the target value is unset.
	//
	// The target value has two purposes. First, it is used as the parameter to
	// activation of the action associated with the `GtkActionable` widget.
	// Second, it is used to determine if the widget should be rendered as
	// active  the widget is active if the state is equal to the given
	// target.
	//
	// Consider the example of associating a set of buttons with a `GAction`
	// with string state in a typical radio button situation. Each button will
	// be associated with the same action, but with a different target value for
	// that action. Clicking on a particular button will activate the action
	// with the target of that button, which will typically cause the actions
	// state to change to that value. Since the actions state is now equal to
	// the target value of the button, the button will now be rendered as active
	// (and the other buttons, with different targets, rendered inactive).
	SetActionTargetValue(targetValue *glib.Variant)
	// SetDetailedActionName sets the action-name and associated string target
	// value of an actionable widget.
	//
	// @detailed_action_name is a string in the format accepted by
	// g_action_parse_detailed_name().
	SetDetailedActionName(detailedActionName string)
}

// actionable implements the Actionable interface.
type actionable struct {
}

var _ Actionable = (*actionable)(nil)

// WrapActionable wraps a GObject to a type that implements
// interface Actionable. It is primarily used internally.
func WrapActionable(obj *externglib.Object) Actionable {
	return actionable{
		Widget: WrapWidget(obj),
	}
}

func marshalActionable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionable(obj), nil
}

func (a actionable) ActionName() string {
	var _arg0 *C.GtkActionable // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_actionable_get_action_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a actionable) ActionTargetValue() *glib.Variant {
	var _arg0 *C.GtkActionable // out
	var _cret *C.GVariant      // in

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_actionable_get_action_target_value(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

func (a actionable) SetActionName(actionName string) {
	var _arg0 *C.GtkActionable // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_actionable_set_action_name(_arg0, _arg1)
}

func (a actionable) SetActionTargetValue(targetValue *glib.Variant) {
	var _arg0 *C.GtkActionable // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(targetValue.Native()))

	C.gtk_actionable_set_action_target_value(_arg0, _arg1)
}

func (a actionable) SetDetailedActionName(detailedActionName string) {
	var _arg0 *C.GtkActionable // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_actionable_set_detailed_action_name(_arg0, _arg1)
}

// AppChooser: `GtkAppChooser` is an interface for widgets which allow the user
// to choose an application.
//
// The main objects that implement this interface are
// [class@Gtk.AppChooserWidget], [class@Gtk.AppChooserDialog] and
// [class@Gtk.AppChooserButton].
//
// Applications are represented by GIO `GAppInfo` objects here. GIO has a
// concept of recommended and fallback applications for a given content type.
// Recommended applications are those that claim to handle the content type
// itself, while fallback also includes applications that handle a more generic
// content type. GIO also knows the default and last-used application for a
// given content type. The `GtkAppChooserWidget` provides detailed control over
// whether the shown list of applications should include default, recommended or
// fallback applications.
//
// To obtain the application that has been selected in a `GtkAppChooser`, use
// [method@Gtk.AppChooser.get_app_info].
type AppChooser interface {

	// AppInfo returns the currently selected application.
	AppInfo() gio.AppInfo
	// ContentType returns the content type for which the `GtkAppChooser` shows
	// applications.
	ContentType() string
	// Refresh reloads the list of applications.
	Refresh()
}

// appChooser implements the AppChooser interface.
type appChooser struct {
}

var _ AppChooser = (*appChooser)(nil)

// WrapAppChooser wraps a GObject to a type that implements
// interface AppChooser. It is primarily used internally.
func WrapAppChooser(obj *externglib.Object) AppChooser {
	return appChooser{
		Widget: WrapWidget(obj),
	}
}

func marshalAppChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooser(obj), nil
}

func (s appChooser) AppInfo() gio.AppInfo {
	var _arg0 *C.GtkAppChooser // out
	var _cret *C.GAppInfo      // in

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_get_app_info(_arg0)

	var _appInfo gio.AppInfo // out

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.AppInfo)

	return _appInfo
}

func (s appChooser) ContentType() string {
	var _arg0 *C.GtkAppChooser // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_get_content_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (s appChooser) Refresh() {
	var _arg0 *C.GtkAppChooser // out

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_refresh(_arg0)
}

// BuildableOverrider contains methods that are overridable. This
// interface is a subset of the interface Buildable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type BuildableOverrider interface {
	// AddChild adds a child to @buildable. @type is an optional string
	// describing how the child should be added.
	AddChild(builder Builder, child gextras.Objector, typ string)

	ID() string
	// InternalChild retrieves the internal child called @childname of the
	// @buildable object.
	InternalChild(builder Builder, childname string) gextras.Objector

	ParserFinished(builder Builder)

	SetBuildableProperty(builder Builder, name string, value *externglib.Value)

	SetID(id string)
}

// Buildable: `GtkBuildable` allows objects to extend and customize their
// deserialization from ui files.
//
// The interface includes methods for setting names and properties of objects,
// parsing custom tags and constructing child objects.
//
// The `GtkBuildable` interface is implemented by all widgets and many of the
// non-widget objects that are provided by GTK. The main user of this interface
// is [class@Gtk.Builder]. There should be very little need for applications to
// call any of these functions directly.
//
// An object only needs to implement this interface if it needs to extend the
// `GtkBuilder` XML format or run any extra routines at deserialization time.
type Buildable interface {

	// BuildableID gets the ID of the @buildable object.
	//
	// `GtkBuilder` sets the name based on the ID attribute of the <object> tag
	// used to construct the @buildable.
	BuildableID() string
}

// buildable implements the Buildable interface.
type buildable struct {
}

var _ Buildable = (*buildable)(nil)

// WrapBuildable wraps a GObject to a type that implements
// interface Buildable. It is primarily used internally.
func WrapBuildable(obj *externglib.Object) Buildable {
	return buildable{
		Objector: obj,
	}
}

func marshalBuildable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuildable(obj), nil
}

func (b buildable) BuildableID() string {
	var _arg0 *C.GtkBuildable // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_buildable_get_buildable_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// BuilderScopeOverrider contains methods that are overridable. This
// interface is a subset of the interface BuilderScope.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type BuilderScopeOverrider interface {
	TypeFromFunction(builder Builder, functionName string) externglib.Type

	TypeFromName(builder Builder, typeName string) externglib.Type
}

// BuilderScope: `GtkBuilderScope` is an interface to provide language binding
// support to `GtkBuilder`.
//
// The goal of `GtkBuilderScope` is to look up programming-language-specific
// values for strings that are given in a `GtkBuilder` UI file.
//
// The primary intended audience is bindings that want to provide deeper
// integration of `GtkBuilder` into the language.
//
// A `GtkBuilderScope` instance may be used with multiple `GtkBuilder` objects,
// even at once.
//
// By default, GTK will use its own implementation of `GtkBuilderScope` for the
// C language which can be created via [ctor@Gtk.BuilderCScope.new].
type BuilderScope interface {
}

// builderScope implements the BuilderScope interface.
type builderScope struct {
}

var _ BuilderScope = (*builderScope)(nil)

// WrapBuilderScope wraps a GObject to a type that implements
// interface BuilderScope. It is primarily used internally.
func WrapBuilderScope(obj *externglib.Object) BuilderScope {
	return builderScope{
		Objector: obj,
	}
}

func marshalBuilderScope(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilderScope(obj), nil
}

// CellEditableOverrider contains methods that are overridable. This
// interface is a subset of the interface CellEditable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type CellEditableOverrider interface {
	// EditingDone emits the CellEditable::editing-done signal.
	EditingDone()
	// RemoveWidget emits the CellEditable::remove-widget signal.
	RemoveWidget()
	// StartEditing begins editing on a @cell_editable.
	//
	// The CellRenderer for the cell creates and returns a CellEditable from
	// gtk_cell_renderer_start_editing(), configured for the CellRenderer type.
	//
	// gtk_cell_editable_start_editing() can then set up @cell_editable suitably
	// for editing a cell, e.g. making the Esc key emit
	// CellEditable::editing-done.
	//
	// Note that the @cell_editable is created on-demand for the current edit;
	// its lifetime is temporary and does not persist across other edits and/or
	// cells.
	StartEditing(event gdk.Event)
}

// CellEditable: interface for widgets that can be used for editing cells
//
// The CellEditable interface must be implemented for widgets to be usable to
// edit the contents of a TreeView cell. It provides a way to specify how
// temporary widgets should be configured for editing, get the new value, etc.
type CellEditable interface {

	// EditingDone emits the CellEditable::editing-done signal.
	EditingDone()
	// RemoveWidget emits the CellEditable::remove-widget signal.
	RemoveWidget()
	// StartEditing begins editing on a @cell_editable.
	//
	// The CellRenderer for the cell creates and returns a CellEditable from
	// gtk_cell_renderer_start_editing(), configured for the CellRenderer type.
	//
	// gtk_cell_editable_start_editing() can then set up @cell_editable suitably
	// for editing a cell, e.g. making the Esc key emit
	// CellEditable::editing-done.
	//
	// Note that the @cell_editable is created on-demand for the current edit;
	// its lifetime is temporary and does not persist across other edits and/or
	// cells.
	StartEditing(event gdk.Event)
}

// cellEditable implements the CellEditable interface.
type cellEditable struct {
}

var _ CellEditable = (*cellEditable)(nil)

// WrapCellEditable wraps a GObject to a type that implements
// interface CellEditable. It is primarily used internally.
func WrapCellEditable(obj *externglib.Object) CellEditable {
	return cellEditable{
		Widget: WrapWidget(obj),
	}
}

func marshalCellEditable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellEditable(obj), nil
}

func (c cellEditable) EditingDone() {
	var _arg0 *C.GtkCellEditable // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))

	C.gtk_cell_editable_editing_done(_arg0)
}

func (c cellEditable) RemoveWidget() {
	var _arg0 *C.GtkCellEditable // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))

	C.gtk_cell_editable_remove_widget(_arg0)
}

func (c cellEditable) StartEditing(event gdk.Event) {
	var _arg0 *C.GtkCellEditable // out
	var _arg1 *C.GdkEvent        // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	C.gtk_cell_editable_start_editing(_arg0, _arg1)
}

// CellLayoutOverrider contains methods that are overridable. This
// interface is a subset of the interface CellLayout.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type CellLayoutOverrider interface {
	// AddAttribute adds an attribute mapping to the list in @cell_layout.
	//
	// The @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell to be set from the value. So for
	// example if column 2 of the model contains strings, you could have the
	// text attribute of a CellRendererText get its values from column 2.
	AddAttribute(cell CellRenderer, attribute string, column int)
	// Clear unsets all the mappings on all renderers on @cell_layout and
	// removes all renderers from @cell_layout.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_cell_layout_set_attributes().
	ClearAttributes(cell CellRenderer)
	// Area returns the underlying CellArea which might be @cell_layout if
	// called on a CellArea or might be nil if no CellArea is used by
	// @cell_layout.
	Area() CellArea
	// PackEnd adds the @cell to the end of @cell_layout. If @expand is false,
	// then the @cell is allocated no more space than it needs. Any unused space
	// is divided evenly between cells for which @expand is true.
	//
	// Note that reusing the same cell renderer is not supported.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart packs the @cell into the beginning of @cell_layout. If @expand
	// is false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	//
	// Note that reusing the same cell renderer is not supported.
	PackStart(cell CellRenderer, expand bool)
	// Reorder re-inserts @cell at @position.
	//
	// Note that @cell has already to be packed into @cell_layout for this to
	// function properly.
	Reorder(cell CellRenderer, position int)
}

// CellLayout: an interface for packing cells
//
// CellLayout is an interface to be implemented by all objects which want to
// provide a TreeViewColumn like API for packing cells, setting attributes and
// data funcs.
//
// One of the notable features provided by implementations of GtkCellLayout are
// attributes. Attributes let you set the properties in flexible ways. They can
// just be set to constant values like regular properties. But they can also be
// mapped to a column of the underlying tree model with
// gtk_cell_layout_set_attributes(), which means that the value of the attribute
// can change from cell to cell as they are rendered by the cell renderer.
// Finally, it is possible to specify a function with
// gtk_cell_layout_set_cell_data_func() that is called to determine the value of
// the attribute for each cell that is rendered.
//
//
// GtkCellLayouts as GtkBuildable
//
// Implementations of GtkCellLayout which also implement the GtkBuildable
// interface (CellView, IconView, ComboBox, EntryCompletion, TreeViewColumn)
// accept GtkCellRenderer objects as <child> elements in UI definitions. They
// support a custom <attributes> element for their children, which can contain
// multiple <attribute> elements. Each <attribute> element has a name attribute
// which specifies a property of the cell renderer; the content of the element
// is the attribute value.
//
// This is an example of a UI definition fragment specifying attributes:
//
//    <object class="GtkCellView">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <attributes>
//          <attribute name="text">0</attribute>
//        </attributes>
//      </child>"
//    </object>
//
// Furthermore for implementations of GtkCellLayout that use a CellArea to lay
// out cells (all GtkCellLayouts in GTK use a GtkCellArea) [cell
// properties][cell-properties] can also be defined in the format by specifying
// the custom <cell-packing> attribute which can contain multiple <property>
// elements defined in the normal way.
//
// Here is a UI definition fragment specifying cell properties:
//
//    <object class="GtkTreeViewColumn">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <cell-packing>
//          <property name="align">True</property>
//          <property name="expand">False</property>
//        </cell-packing>
//      </child>"
//    </object>
//
//
// Subclassing GtkCellLayout implementations
//
// When subclassing a widget that implements CellLayout like IconView or
// ComboBox, there are some considerations related to the fact that these
// widgets internally use a CellArea. The cell area is exposed as a
// construct-only property by these widgets. This means that it is possible to
// e.g. do
//
//    static void
//    my_combo_box_init (MyComboBox *b)
//    {
//      GtkCellRenderer *cell;
//
//      cell = gtk_cell_renderer_pixbuf_new ();
//      // The following call causes the default cell area for combo boxes,
//      // a GtkCellAreaBox, to be instantiated
//      gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
//      ...
//    }
//
//    GtkWidget *
//    my_combo_box_new (GtkCellArea *area)
//    {
//      // This call is going to cause a warning about area being ignored
//      return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
//    }
//
// If supporting alternative cell areas with your derived widget is not
// important, then this does not have to concern you. If you want to support
// alternative cell areas, you can do so by moving the problematic calls out of
// init() and into a constructor() for your class.
type CellLayout interface {

	// AddAttribute adds an attribute mapping to the list in @cell_layout.
	//
	// The @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell to be set from the value. So for
	// example if column 2 of the model contains strings, you could have the
	// text attribute of a CellRendererText get its values from column 2.
	AddAttribute(cell CellRenderer, attribute string, column int)
	// Clear unsets all the mappings on all renderers on @cell_layout and
	// removes all renderers from @cell_layout.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_cell_layout_set_attributes().
	ClearAttributes(cell CellRenderer)
	// Area returns the underlying CellArea which might be @cell_layout if
	// called on a CellArea or might be nil if no CellArea is used by
	// @cell_layout.
	Area() CellArea
	// PackEnd adds the @cell to the end of @cell_layout. If @expand is false,
	// then the @cell is allocated no more space than it needs. Any unused space
	// is divided evenly between cells for which @expand is true.
	//
	// Note that reusing the same cell renderer is not supported.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart packs the @cell into the beginning of @cell_layout. If @expand
	// is false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	//
	// Note that reusing the same cell renderer is not supported.
	PackStart(cell CellRenderer, expand bool)
	// Reorder re-inserts @cell at @position.
	//
	// Note that @cell has already to be packed into @cell_layout for this to
	// function properly.
	Reorder(cell CellRenderer, position int)
}

// cellLayout implements the CellLayout interface.
type cellLayout struct {
}

var _ CellLayout = (*cellLayout)(nil)

// WrapCellLayout wraps a GObject to a type that implements
// interface CellLayout. It is primarily used internally.
func WrapCellLayout(obj *externglib.Object) CellLayout {
	return cellLayout{
		Objector: obj,
	}
}

func marshalCellLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellLayout(obj), nil
}

func (c cellLayout) AddAttribute(cell CellRenderer, attribute string, column int) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 C.int              // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	_arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.int)(column)

	C.gtk_cell_layout_add_attribute(_arg0, _arg1, _arg2, _arg3)
}

func (c cellLayout) Clear() {
	var _arg0 *C.GtkCellLayout // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))

	C.gtk_cell_layout_clear(_arg0)
}

func (c cellLayout) ClearAttributes(cell CellRenderer) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_cell_layout_clear_attributes(_arg0, _arg1)
}

func (c cellLayout) Area() CellArea {
	var _arg0 *C.GtkCellLayout // out
	var _cret *C.GtkCellArea   // in

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_layout_get_area(_arg0)

	var _cellArea CellArea // out

	_cellArea = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellArea)

	return _cellArea
}

func (c cellLayout) PackEnd(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_cell_layout_pack_end(_arg0, _arg1, _arg2)
}

func (c cellLayout) PackStart(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_cell_layout_pack_start(_arg0, _arg1, _arg2)
}

func (c cellLayout) Reorder(cell CellRenderer, position int) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.int              // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	_arg2 = (C.int)(position)

	C.gtk_cell_layout_reorder(_arg0, _arg1, _arg2)
}

// ColorChooserOverrider contains methods that are overridable. This
// interface is a subset of the interface ColorChooser.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type ColorChooserOverrider interface {
	// AddPalette adds a palette to the color chooser.
	//
	// If @orientation is horizontal, the colors are grouped in rows, with
	// @colors_per_line colors in each row. If @horizontal is false, the colors
	// are grouped in columns instead.
	//
	// The default color palette of [class@Gtk.ColorChooserWidget] has 45
	// colors, organized in columns of 5 colors (this includes some grays).
	//
	// The layout of the color chooser widget works best when the palettes have
	// 9-10 columns.
	//
	// Calling this function for the first time has the side effect of removing
	// the default color palette from the color chooser.
	//
	// If @colors is nil, removes all previously added palettes.
	AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA)

	ColorActivated(color *gdk.RGBA)
	// RGBA gets the currently-selected color.
	RGBA() gdk.RGBA
	// SetRGBA sets the color.
	SetRGBA(color *gdk.RGBA)
}

// ColorChooser: `GtkColorChooser` is an interface that is implemented by
// widgets for choosing colors.
//
// Depending on the situation, colors may be allowed to have alpha
// (translucency).
//
// In GTK, the main widgets that implement this interface are
// [class@Gtk.ColorChooserWidget], [class@Gtk.ColorChooserDialog] and
// [class@Gtk.ColorButton].
type ColorChooser interface {

	// AddPalette adds a palette to the color chooser.
	//
	// If @orientation is horizontal, the colors are grouped in rows, with
	// @colors_per_line colors in each row. If @horizontal is false, the colors
	// are grouped in columns instead.
	//
	// The default color palette of [class@Gtk.ColorChooserWidget] has 45
	// colors, organized in columns of 5 colors (this includes some grays).
	//
	// The layout of the color chooser widget works best when the palettes have
	// 9-10 columns.
	//
	// Calling this function for the first time has the side effect of removing
	// the default color palette from the color chooser.
	//
	// If @colors is nil, removes all previously added palettes.
	AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA)
	// RGBA gets the currently-selected color.
	RGBA() gdk.RGBA
	// UseAlpha returns whether the color chooser shows the alpha channel.
	UseAlpha() bool
	// SetRGBA sets the color.
	SetRGBA(color *gdk.RGBA)
	// SetUseAlpha sets whether or not the color chooser should use the alpha
	// channel.
	SetUseAlpha(useAlpha bool)
}

// colorChooser implements the ColorChooser interface.
type colorChooser struct {
}

var _ ColorChooser = (*colorChooser)(nil)

// WrapColorChooser wraps a GObject to a type that implements
// interface ColorChooser. It is primarily used internally.
func WrapColorChooser(obj *externglib.Object) ColorChooser {
	return colorChooser{
		Objector: obj,
	}
}

func marshalColorChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooser(obj), nil
}

func (c colorChooser) AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA) {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 C.GtkOrientation   // out
	var _arg2 C.int              // out
	var _arg4 *C.GdkRGBA
	var _arg3 C.int

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (C.int)(colorsPerLine)
	_arg3 = C.int(len(colors))
	_arg4 = (*C.GdkRGBA)(unsafe.Pointer(&colors[0]))

	C.gtk_color_chooser_add_palette(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (c colorChooser) RGBA() gdk.RGBA {
	var _arg0 *C.GtkColorChooser // out
	var _color gdk.RGBA

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))

	C.gtk_color_chooser_get_rgba(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	return _color
}

func (c colorChooser) UseAlpha() bool {
	var _arg0 *C.GtkColorChooser // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_color_chooser_get_use_alpha(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c colorChooser) SetRGBA(color *gdk.RGBA) {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 *C.GdkRGBA         // out

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_color_chooser_set_rgba(_arg0, _arg1)
}

func (c colorChooser) SetUseAlpha(useAlpha bool) {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
	if useAlpha {
		_arg1 = C.TRUE
	}

	C.gtk_color_chooser_set_use_alpha(_arg0, _arg1)
}

// ConstraintTarget: the `GtkConstraintTarget` interface is implemented by
// objects that can be used as source or target in `GtkConstraint`s.
//
// Besides `GtkWidget`, it is also implemented by `GtkConstraintGuide`.
type ConstraintTarget interface {
}

// constraintTarget implements the ConstraintTarget interface.
type constraintTarget struct {
}

var _ ConstraintTarget = (*constraintTarget)(nil)

// WrapConstraintTarget wraps a GObject to a type that implements
// interface ConstraintTarget. It is primarily used internally.
func WrapConstraintTarget(obj *externglib.Object) ConstraintTarget {
	return constraintTarget{
		Objector: obj,
	}
}

func marshalConstraintTarget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintTarget(obj), nil
}

// EditableOverrider contains methods that are overridable. This
// interface is a subset of the interface Editable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type EditableOverrider interface {
	Changed()
	// DeleteText deletes a sequence of characters.
	//
	// The characters that are deleted are those characters at positions from
	// @start_pos up to, but not including @end_pos. If @end_pos is negative,
	// then the characters deleted are those from @start_pos to the end of the
	// text.
	//
	// Note that the positions are specified in characters, not bytes.
	DeleteText(startPos int, endPos int)
	// DoDeleteText deletes a sequence of characters.
	//
	// The characters that are deleted are those characters at positions from
	// @start_pos up to, but not including @end_pos. If @end_pos is negative,
	// then the characters deleted are those from @start_pos to the end of the
	// text.
	//
	// Note that the positions are specified in characters, not bytes.
	DoDeleteText(startPos int, endPos int)
	// Delegate gets the `GtkEditable` that @editable is delegating its
	// implementation to.
	//
	// Typically, the delegate is a [class@Gtk.Text] widget.
	Delegate() Editable
	// SelectionBounds retrieves the selection bound of the editable.
	//
	// @start_pos will be filled with the start of the selection and @end_pos
	// with end. If no text was selected both will be identical and false will
	// be returned.
	//
	// Note that positions are specified in characters, not bytes.
	SelectionBounds() (startPos int, endPos int, ok bool)
	// Text retrieves the contents of @editable.
	//
	// The returned string is owned by GTK and must not be modified or freed.
	Text() string
	// SetSelectionBounds selects a region of text.
	//
	// The characters that are selected are those characters at positions from
	// @start_pos up to, but not including @end_pos. If @end_pos is negative,
	// then the characters selected are those characters from @start_pos to the
	// end of the text.
	//
	// Note that positions are specified in characters, not bytes.
	SetSelectionBounds(startPos int, endPos int)
}

// Editable: `GtkEditable` is an interface for text editing widgets.
//
// Typical examples of editable widgets are [class@Gtk.Entry] and
// [class@Gtk.SpinButton]. It contains functions for generically manipulating an
// editable widget, a large number of action signals used for key bindings, and
// several signals that an application can connect to modify the behavior of a
// widget.
//
// As an example of the latter usage, by connecting the following handler to
// [signal@Gtk.Editable::insert-text], an application can convert all entry into
// a widget into uppercase.
//
// Forcing entry to uppercase.
//
// `c #include <ctype.h>
//
// void insert_text_handler (GtkEditable *editable, const char *text, int
// length, int *position, gpointer data) { char *result = g_utf8_strup (text,
// length);
//
//    g_signal_handlers_block_by_func (editable,
//                                 (gpointer) insert_text_handler, data);
//    gtk_editable_insert_text (editable, result, length, position);
//    g_signal_handlers_unblock_by_func (editable,
//                                       (gpointer) insert_text_handler, data);
//
//    g_signal_stop_emission_by_name (editable, "insert_text");
//
//    g_free (result);
//
// } `
//
//
// Implementing GtkEditable
//
// The most likely scenario for implementing `GtkEditable` on your own widget is
// that you will embed a Text inside a complex widget, and want to delegate the
// editable functionality to that text widget. `GtkEditable` provides some
// utility functions to make this easy.
//
// In your class_init function, call [func@Gtk.Editable.install_properties],
// passing the first available property ID:
//
// `c static void my_class_init (MyClass *class) { ...
// g_object_class_install_properties (object_class, NUM_PROPERTIES, props);
// gtk_editable_install_properties (object_clas, NUM_PROPERTIES); ... } `
//
// In your interface_init function for the `GtkEditable` interface, provide an
// implementation for the get_delegate vfunc that returns your text widget:
//
// `c GtkEditable * get_editable_delegate (GtkEditable *editable) { return
// GTK_EDITABLE (MY_WIDGET (editable)->text_widget); }
//
// static void my_editable_init (GtkEditableInterface *iface) {
// iface->get_delegate = get_editable_delegate; } `
//
// You don't need to provide any other vfuncs. The default implementations work
// by forwarding to the delegate that the GtkEditableInterface.get_delegate()
// vfunc returns.
//
// In your instance_init function, create your text widget, and then call
// [method@Gtk.Editable.init_delegate]:
//
// `c static void my_widget_init (MyWidget *self) { ... self->text_widget =
// gtk_text_new (); gtk_editable_init_delegate (GTK_EDITABLE (self)); ... } `
//
// In your dispose function, call [method@Gtk.Editable.finish_delegate] before
// destroying your text widget:
//
// `c static void my_widget_dispose (GObject *object) { ...
// gtk_editable_finish_delegate (GTK_EDITABLE (self)); g_clear_pointer
// (&self->text_widget, gtk_widget_unparent); ... } `
//
// Finally, use [func@Gtk.Editable.delegate_set_property] in your `set_property`
// function (and similar for `get_property`), to set the editable properties:
//
// `c ... if (gtk_editable_delegate_set_property (object, prop_id, value,
// pspec)) return;
//
//    switch (prop_id)
//    ...
//
// `
//
// It is important to note that if you create a `GtkEditable` that uses a
// delegate, the low level [signal@Gtk.Editable::insert-text] and
// [signal@Gtk.Editable::delete-text] signals will be propagated from the
// "wrapper" editable to the delegate, but they will not be propagated from the
// delegate to the "wrapper" editable, as they would cause an infinite
// recursion. If you wish to connect to the [signal@Gtk.Editable::insert-text]
// and [signal@Gtk.Editable::delete-text] signals, you will need to connect to
// them on the delegate obtained via [method@Gtk.Editable.get_delegate].
type Editable interface {

	// DeleteSelection deletes the currently selected text of the editable.
	//
	// This call doesnt do anything if there is no selected text.
	DeleteSelection()
	// DeleteText deletes a sequence of characters.
	//
	// The characters that are deleted are those characters at positions from
	// @start_pos up to, but not including @end_pos. If @end_pos is negative,
	// then the characters deleted are those from @start_pos to the end of the
	// text.
	//
	// Note that the positions are specified in characters, not bytes.
	DeleteText(startPos int, endPos int)
	// FinishDelegate undoes the setup done by
	// [method@Gtk.Editable.init_delegate].
	//
	// This is a helper function that should be called from dispose, before
	// removing the delegate object.
	FinishDelegate()
	// Alignment gets the alignment of the editable.
	Alignment() float32
	// Chars retrieves a sequence of characters.
	//
	// The characters that are retrieved are those characters at positions from
	// @start_pos up to, but not including @end_pos. If @end_pos is negative,
	// then the characters retrieved are those characters from @start_pos to the
	// end of the text.
	//
	// Note that positions are specified in characters, not bytes.
	Chars(startPos int, endPos int) string
	// Delegate gets the `GtkEditable` that @editable is delegating its
	// implementation to.
	//
	// Typically, the delegate is a [class@Gtk.Text] widget.
	Delegate() Editable
	// Editable retrieves whether @editable is editable.
	Editable() bool
	// EnableUndo gets if undo/redo actions are enabled for @editable
	EnableUndo() bool
	// MaxWidthChars retrieves the desired maximum width of @editable, in
	// characters.
	MaxWidthChars() int
	// Position retrieves the current position of the cursor relative to the
	// start of the content of the editable.
	//
	// Note that this position is in characters, not in bytes.
	Position() int
	// SelectionBounds retrieves the selection bound of the editable.
	//
	// @start_pos will be filled with the start of the selection and @end_pos
	// with end. If no text was selected both will be identical and false will
	// be returned.
	//
	// Note that positions are specified in characters, not bytes.
	SelectionBounds() (startPos int, endPos int, ok bool)
	// Text retrieves the contents of @editable.
	//
	// The returned string is owned by GTK and must not be modified or freed.
	Text() string
	// WidthChars gets the number of characters of space reserved for the
	// contents of the editable.
	WidthChars() int
	// InitDelegate sets up a delegate for `GtkEditable`.
	//
	// This is assuming that the get_delegate vfunc in the `GtkEditable`
	// interface has been set up for the @editable's type.
	//
	// This is a helper function that should be called in instance init, after
	// creating the delegate object.
	InitDelegate()
	// SelectRegion selects a region of text.
	//
	// The characters that are selected are those characters at positions from
	// @start_pos up to, but not including @end_pos. If @end_pos is negative,
	// then the characters selected are those characters from @start_pos to the
	// end of the text.
	//
	// Note that positions are specified in characters, not bytes.
	SelectRegion(startPos int, endPos int)
	// SetAlignment sets the alignment for the contents of the editable.
	//
	// This controls the horizontal positioning of the contents when the
	// displayed text is shorter than the width of the editable.
	SetAlignment(xalign float32)
	// SetEditable determines if the user can edit the text in the editable
	// widget.
	SetEditable(isEditable bool)
	// SetEnableUndo: if enabled, changes to @editable will be saved for
	// undo/redo actions.
	//
	// This results in an additional copy of text changes and are not stored in
	// secure memory. As such, undo is forcefully disabled when
	// [property@Gtk.Text:visibility] is set to false.
	SetEnableUndo(enableUndo bool)
	// SetMaxWidthChars sets the desired maximum width in characters of
	// @editable.
	SetMaxWidthChars(nChars int)
	// SetPosition sets the cursor position in the editable to the given value.
	//
	// The cursor is displayed before the character with the given (base 0)
	// index in the contents of the editable. The value must be less than or
	// equal to the number of characters in the editable. A value of -1
	// indicates that the position should be set after the last character of the
	// editable. Note that @position is in characters, not in bytes.
	SetPosition(position int)
	// SetText sets the text in the editable to the given value.
	//
	// This is replacing the current contents.
	SetText(text string)
	// SetWidthChars changes the size request of the editable to be about the
	// right size for @n_chars characters.
	//
	// Note that it changes the size request, the size can still be affected by
	// how you pack the widget into containers. If @n_chars is -1, the size
	// reverts to the default size.
	SetWidthChars(nChars int)
}

// editable implements the Editable interface.
type editable struct {
}

var _ Editable = (*editable)(nil)

// WrapEditable wraps a GObject to a type that implements
// interface Editable. It is primarily used internally.
func WrapEditable(obj *externglib.Object) Editable {
	return editable{
		Widget: WrapWidget(obj),
	}
}

func marshalEditable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEditable(obj), nil
}

func (e editable) DeleteSelection() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	C.gtk_editable_delete_selection(_arg0)
}

func (e editable) DeleteText(startPos int, endPos int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.int)(startPos)
	_arg2 = (C.int)(endPos)

	C.gtk_editable_delete_text(_arg0, _arg1, _arg2)
}

func (e editable) FinishDelegate() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	C.gtk_editable_finish_delegate(_arg0)
}

func (e editable) Alignment() float32 {
	var _arg0 *C.GtkEditable // out
	var _cret C.float        // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_alignment(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (e editable) Chars(startPos int, endPos int) string {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.int)(startPos)
	_arg2 = (C.int)(endPos)

	_cret = C.gtk_editable_get_chars(_arg0, _arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (e editable) Delegate() Editable {
	var _arg0 *C.GtkEditable // out
	var _cret *C.GtkEditable // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_delegate(_arg0)

	var _ret Editable // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Editable)

	return _ret
}

func (e editable) Editable() bool {
	var _arg0 *C.GtkEditable // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_editable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e editable) EnableUndo() bool {
	var _arg0 *C.GtkEditable // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_enable_undo(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e editable) MaxWidthChars() int {
	var _arg0 *C.GtkEditable // out
	var _cret C.int          // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_max_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (e editable) Position() int {
	var _arg0 *C.GtkEditable // out
	var _cret C.int          // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_position(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (e editable) SelectionBounds() (startPos int, endPos int, ok bool) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_selection_bounds(_arg0, &_arg1, &_arg2)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = (int)(_arg1)
	_endPos = (int)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

func (e editable) Text() string {
	var _arg0 *C.GtkEditable // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (e editable) WidthChars() int {
	var _arg0 *C.GtkEditable // out
	var _cret C.int          // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (e editable) InitDelegate() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	C.gtk_editable_init_delegate(_arg0)
}

func (e editable) SelectRegion(startPos int, endPos int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.int)(startPos)
	_arg2 = (C.int)(endPos)

	C.gtk_editable_select_region(_arg0, _arg1, _arg2)
}

func (e editable) SetAlignment(xalign float32) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.float        // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.float)(xalign)

	C.gtk_editable_set_alignment(_arg0, _arg1)
}

func (e editable) SetEditable(isEditable bool) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	if isEditable {
		_arg1 = C.TRUE
	}

	C.gtk_editable_set_editable(_arg0, _arg1)
}

func (e editable) SetEnableUndo(enableUndo bool) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	if enableUndo {
		_arg1 = C.TRUE
	}

	C.gtk_editable_set_enable_undo(_arg0, _arg1)
}

func (e editable) SetMaxWidthChars(nChars int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.int)(nChars)

	C.gtk_editable_set_max_width_chars(_arg0, _arg1)
}

func (e editable) SetPosition(position int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.int)(position)

	C.gtk_editable_set_position(_arg0, _arg1)
}

func (e editable) SetText(text string) {
	var _arg0 *C.GtkEditable // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_editable_set_text(_arg0, _arg1)
}

func (e editable) SetWidthChars(nChars int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.int)(nChars)

	C.gtk_editable_set_width_chars(_arg0, _arg1)
}

// FileChooser: `GtkFileChooser` is an interface that can be implemented by file
// selection widgets.
//
// In GTK, the main objects that implement this interface are
// [class@Gtk.FileChooserWidget] and [class@Gtk.FileChooserDialog].
//
// You do not need to write an object that implements the `GtkFileChooser`
// interface unless you are trying to adapt an existing file selector to expose
// a standard programming interface.
//
// `GtkFileChooser` allows for shortcuts to various places in the filesystem. In
// the default implementation these are displayed in the left pane. It may be a
// bit confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the Add. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the roots of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a `GtkFileChooser`, your program
// can get the selected filenames as `GFile`s.
//
//
// Adding options
//
// You can add extra widgets to a file chooser to provide options that are not
// present in the default design, by using [method@Gtk.FileChooser.add_choice].
// Each choice has an identifier and a user visible label; additionally, each
// choice can have multiple options. If a choice has no option, it will be
// rendered as a check button with the given label; if a choice has options, it
// will be rendered as a combo box.
type FileChooser interface {

	// AddChoice adds a 'choice' to the file chooser.
	//
	// This is typically implemented as a combobox or, for boolean choices, as a
	// checkbutton. You can select a value using
	// [method@Gtk.FileChooser.set_choice] before the dialog is shown, and you
	// can obtain the user-selected value in the [signal@Gtk.Dialog::response]
	// signal handler using [method@Gtk.FileChooser.get_choice].
	AddChoice(id string, label string, options []string, optionLabels []string)
	// AddFilter adds @filter to the list of filters that the user can select
	// between.
	//
	// When a filter is selected, only files that are passed by that filter are
	// displayed.
	//
	// Note that the @chooser takes ownership of the filter if it is floating,
	// so you have to ref and sink it if you want to keep a reference.
	AddFilter(filter FileFilter)
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders
	// in a file chooser.
	AddShortcutFolder(folder gio.File) error
	// Action gets the type of operation that the file chooser is performing.
	Action() FileChooserAction
	// Choice gets the currently selected option in the 'choice' with the given
	// ID.
	Choice(id string) string
	// CreateFolders gets whether file chooser will offer to create new folders.
	CreateFolders() bool
	// CurrentFolder gets the current folder of @chooser as #GFile.
	CurrentFolder() gio.File
	// CurrentName gets the current name in the file selector, as entered by the
	// user.
	//
	// This is meant to be used in save dialogs, to get the currently typed
	// filename when the file itself does not exist yet.
	CurrentName() string
	// File gets the `GFile` for the currently selected file in the file
	// selector.
	//
	// If multiple files are selected, one of the files will be returned at
	// random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	File() gio.File
	// Files lists all the selected files and subfolders in the current folder
	// of @chooser as #GFile.
	Files() gio.ListModel
	// Filter gets the current filter.
	Filter() FileFilter
	// Filters gets the current set of user-selectable filters, as a list model.
	//
	// See [method@Gtk.FileChooser.add_filter] and
	// [method@Gtk.FileChooser.remove_filter] for changing individual filters.
	//
	// You should not modify the returned list model. Future changes to @chooser
	// may or may not affect the returned model.
	Filters() gio.ListModel
	// SelectMultiple gets whether multiple files can be selected in the file
	// chooser.
	SelectMultiple() bool
	// ShortcutFolders queries the list of shortcut folders in the file chooser.
	//
	// You should not modify the returned list model. Future changes to @chooser
	// may or may not affect the returned model.
	ShortcutFolders() gio.ListModel
	// RemoveChoice removes a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	RemoveChoice(id string)
	// RemoveFilter removes @filter from the list of filters that the user can
	// select between.
	RemoveFilter(filter FileFilter)
	// RemoveShortcutFolder removes a folder from the shortcut folders in a file
	// chooser.
	RemoveShortcutFolder(folder gio.File) error
	// SetAction sets the type of operation that the chooser is performing.
	//
	// The user interface is adapted to suit the selected action.
	//
	// For example, an option to create a new folder might be shown if the
	// action is GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetAction(action FileChooserAction)
	// SetChoice selects an option in a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	//
	// For a boolean choice, the possible options are "true" and "false".
	SetChoice(id string, option string)
	// SetCreateFolders sets whether file chooser will offer to create new
	// folders.
	//
	// This is only relevant if the action is not set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetCreateFolders(createFolders bool)
	// SetCurrentFolder sets the current folder for @chooser from a #GFile.
	SetCurrentFolder(file gio.File) error
	// SetCurrentName sets the current name in the file selector, as if entered
	// by the user.
	//
	// Note that the name passed in here is a UTF-8 string rather than a
	// filename. This function is meant for such uses as a suggested name in a
	// Save As... dialog. You can pass Untitled.doc or a similarly suitable
	// suggestion for the @name.
	//
	// If you want to preselect a particular existing file, you should use
	// [method@Gtk.FileChooser.set_file] instead.
	//
	// Please see the documentation for those functions for an example of using
	// [method@Gtk.FileChooser.set_current_name] as well.
	SetCurrentName(name string)
	// SetFile sets @file as the current filename for the file chooser.
	//
	// This includes changing to the files parent folder and actually selecting
	// the file in list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE
	// mode, the files base name will also appear in the dialogs file name
	// entry.
	//
	// If the file name isnt in the current folder of @chooser, then the
	// current folder of @chooser will be changed to the folder containing
	// @filename.
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// If you are implementing a save dialog, you should use this function if
	// you already have a file name to which the user may save; for example,
	// when the user opens an existing file and then does Save As. If you
	// dont have a file name already  for example, if the user just created a
	// new file and is saving it for the first time, do not call this function.
	//
	// Instead, use something similar to this:
	//
	// `c static void prepare_file_chooser (GtkFileChooser *chooser, GFile
	// *existing_file) { gboolean document_is_new = (existing_file == NULL);
	//
	//    if (document_is_new)
	//      {
	//        GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//        g_object_unref (default_file_for_saving);
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_file (chooser, existing_file, NULL);
	//      }
	//
	// } `
	SetFile(file gio.File) error
	// SetFilter sets the current filter.
	//
	// Only the files that pass the filter will be displayed. If the
	// user-selectable list of filters is non-empty, then the filter should be
	// one of the filters in that list.
	//
	// Setting the current filter when the list of filters is empty is useful if
	// you want to restrict the displayed set of files without letting the user
	// change it.
	SetFilter(filter FileFilter)
	// SetSelectMultiple sets whether multiple files can be selected in the file
	// chooser.
	//
	// This is only relevant if the action is set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
	SetSelectMultiple(selectMultiple bool)
}

// fileChooser implements the FileChooser interface.
type fileChooser struct {
}

var _ FileChooser = (*fileChooser)(nil)

// WrapFileChooser wraps a GObject to a type that implements
// interface FileChooser. It is primarily used internally.
func WrapFileChooser(obj *externglib.Object) FileChooser {
	return fileChooser{
		Objector: obj,
	}
}

func marshalFileChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooser(obj), nil
}

func (c fileChooser) AddChoice(id string, label string, options []string, optionLabels []string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out
	var _arg3 **C.char
	var _arg4 **C.char

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (**C.char)(C.malloc(C.ulong(len(options)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(options))
		for i := range options {
			out[i] = (*C.char)(C.CString(options[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg4 = (**C.char)(C.malloc(C.ulong(len(optionLabels)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(optionLabels))
		for i := range optionLabels {
			out[i] = (*C.char)(C.CString(optionLabels[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_file_chooser_add_choice(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (c fileChooser) AddFilter(filter FileFilter) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkFileFilter  // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_add_filter(_arg0, _arg1)
}

func (c fileChooser) AddShortcutFolder(folder gio.File) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(folder.Native()))

	C.gtk_file_chooser_add_shortcut_folder(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c fileChooser) Action() FileChooserAction {
	var _arg0 *C.GtkFileChooser      // out
	var _cret C.GtkFileChooserAction // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_action(_arg0)

	var _fileChooserAction FileChooserAction // out

	_fileChooserAction = FileChooserAction(_cret)

	return _fileChooserAction
}

func (c fileChooser) Choice(id string) string {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_file_chooser_get_choice(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c fileChooser) CreateFolders() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_create_folders(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c fileChooser) CurrentFolder() gio.File {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GFile          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_current_folder(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

func (c fileChooser) CurrentName() string {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_current_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (c fileChooser) File() gio.File {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GFile          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

func (c fileChooser) Files() gio.ListModel {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_files(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (c fileChooser) Filter() FileFilter {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GtkFileFilter  // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_filter(_arg0)

	var _fileFilter FileFilter // out

	_fileFilter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FileFilter)

	return _fileFilter
}

func (c fileChooser) Filters() gio.ListModel {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_filters(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (c fileChooser) SelectMultiple() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_select_multiple(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c fileChooser) ShortcutFolders() gio.ListModel {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_shortcut_folders(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (c fileChooser) RemoveChoice(id string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_remove_choice(_arg0, _arg1)
}

func (c fileChooser) RemoveFilter(filter FileFilter) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkFileFilter  // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_remove_filter(_arg0, _arg1)
}

func (c fileChooser) RemoveShortcutFolder(folder gio.File) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(folder.Native()))

	C.gtk_file_chooser_remove_shortcut_folder(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c fileChooser) SetAction(action FileChooserAction) {
	var _arg0 *C.GtkFileChooser      // out
	var _arg1 C.GtkFileChooserAction // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkFileChooserAction)(action)

	C.gtk_file_chooser_set_action(_arg0, _arg1)
}

func (c fileChooser) SetChoice(id string, option string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(option))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_file_chooser_set_choice(_arg0, _arg1, _arg2)
}

func (c fileChooser) SetCreateFolders(createFolders bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if createFolders {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_create_folders(_arg0, _arg1)
}

func (c fileChooser) SetCurrentFolder(file gio.File) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_file_chooser_set_current_folder(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c fileChooser) SetCurrentName(name string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_set_current_name(_arg0, _arg1)
}

func (c fileChooser) SetFile(file gio.File) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_file_chooser_set_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c fileChooser) SetFilter(filter FileFilter) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkFileFilter  // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_set_filter(_arg0, _arg1)
}

func (c fileChooser) SetSelectMultiple(selectMultiple bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if selectMultiple {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_select_multiple(_arg0, _arg1)
}

// FontChooserOverrider contains methods that are overridable. This
// interface is a subset of the interface FontChooser.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type FontChooserOverrider interface {
	FontActivated(fontname string)
	// FontFace gets the `PangoFontFace` representing the selected font group
	// details (i.e. family, slant, weight, width, etc).
	//
	// If the selected font is not installed, returns nil.
	FontFace() pango.FontFace
	// FontFamily gets the `PangoFontFamily` representing the selected font
	// family.
	//
	// Font families are a collection of font faces.
	//
	// If the selected font is not installed, returns nil.
	FontFamily() pango.FontFamily
	// FontMap gets the custom font map of this font chooser widget, or nil if
	// it does not have one.
	FontMap() pango.FontMap
	// FontSize: the selected font size.
	FontSize() int
	// SetFontMap sets a custom font map to use for this font chooser widget.
	//
	// A custom font map can be used to present application-specific fonts
	// instead of or in addition to the normal system fonts.
	//
	// `c FcConfig *config; PangoFontMap *fontmap;
	//
	// config = FcInitLoadConfigAndFonts (); FcConfigAppFontAddFile (config,
	// my_app_font_file);
	//
	// fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
	// pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
	//
	// gtk_font_chooser_set_font_map (font_chooser, fontmap); `
	//
	// Note that other GTK widgets will only be able to use the
	// application-specific font if it is present in the font map they use:
	//
	// `c context = gtk_widget_get_pango_context (label);
	// pango_context_set_font_map (context, fontmap); `
	SetFontMap(fontmap pango.FontMap)
}

// FontChooser: `GtkFontChooser` is an interface that can be implemented by
// widgets for choosing fonts.
//
// In GTK, the main objects that implement this interface are
// [class@Gtk.FontChooserWidget], [class@Gtk.FontChooserDialog] and
// [class@Gtk.FontButton].
type FontChooser interface {

	// Font gets the currently-selected font name.
	//
	// Note that this can be a different string than what you set with
	// [method@Gtk.FontChooser.set_font], as the font chooser widget may
	// normalize font names and thus return a string with a different structure.
	// For example, Helvetica Italic Bold 12 could be normalized to Helvetica
	// Bold Italic 12.
	//
	// Use [method@Pango.FontDescription.equal] if you want to compare two font
	// descriptions.
	Font() string
	// FontDesc gets the currently-selected font.
	//
	// Note that this can be a different string than what you set with
	// [method@Gtk.FontChooser.set_font], as the font chooser widget may
	// normalize font names and thus return a string with a different structure.
	// For example, Helvetica Italic Bold 12 could be normalized to Helvetica
	// Bold Italic 12.
	//
	// Use [method@Pango.FontDescription.equal] if you want to compare two font
	// descriptions.
	FontDesc() *pango.FontDescription
	// FontFace gets the `PangoFontFace` representing the selected font group
	// details (i.e. family, slant, weight, width, etc).
	//
	// If the selected font is not installed, returns nil.
	FontFace() pango.FontFace
	// FontFamily gets the `PangoFontFamily` representing the selected font
	// family.
	//
	// Font families are a collection of font faces.
	//
	// If the selected font is not installed, returns nil.
	FontFamily() pango.FontFamily
	// FontFeatures gets the currently-selected font features.
	FontFeatures() string
	// FontMap gets the custom font map of this font chooser widget, or nil if
	// it does not have one.
	FontMap() pango.FontMap
	// FontSize: the selected font size.
	FontSize() int
	// Language gets the language that is used for font features.
	Language() string
	// Level returns the current level of granularity for selecting fonts.
	Level() FontChooserLevel
	// PreviewText gets the text displayed in the preview area.
	PreviewText() string
	// ShowPreviewEntry returns whether the preview entry is shown or not.
	ShowPreviewEntry() bool
	// SetFont sets the currently-selected font.
	SetFont(fontname string)
	// SetFontDesc sets the currently-selected font from @font_desc.
	SetFontDesc(fontDesc *pango.FontDescription)
	// SetFontMap sets a custom font map to use for this font chooser widget.
	//
	// A custom font map can be used to present application-specific fonts
	// instead of or in addition to the normal system fonts.
	//
	// `c FcConfig *config; PangoFontMap *fontmap;
	//
	// config = FcInitLoadConfigAndFonts (); FcConfigAppFontAddFile (config,
	// my_app_font_file);
	//
	// fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
	// pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
	//
	// gtk_font_chooser_set_font_map (font_chooser, fontmap); `
	//
	// Note that other GTK widgets will only be able to use the
	// application-specific font if it is present in the font map they use:
	//
	// `c context = gtk_widget_get_pango_context (label);
	// pango_context_set_font_map (context, fontmap); `
	SetFontMap(fontmap pango.FontMap)
	// SetLanguage sets the language to use for font features.
	SetLanguage(language string)
	// SetLevel sets the desired level of granularity for selecting fonts.
	SetLevel(level FontChooserLevel)
	// SetPreviewText sets the text displayed in the preview area.
	//
	// The @text is used to show how the selected font looks.
	SetPreviewText(text string)
	// SetShowPreviewEntry shows or hides the editable preview entry.
	SetShowPreviewEntry(showPreviewEntry bool)
}

// fontChooser implements the FontChooser interface.
type fontChooser struct {
}

var _ FontChooser = (*fontChooser)(nil)

// WrapFontChooser wraps a GObject to a type that implements
// interface FontChooser. It is primarily used internally.
func WrapFontChooser(obj *externglib.Object) FontChooser {
	return fontChooser{
		Objector: obj,
	}
}

func marshalFontChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooser(obj), nil
}

func (f fontChooser) Font() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (f fontChooser) FontDesc() *pango.FontDescription {
	var _arg0 *C.GtkFontChooser       // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_desc(_arg0)

	var _fontDescription *pango.FontDescription // out

	_fontDescription = pango.WrapFontDescription(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontDescription, func(v *pango.FontDescription) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontDescription
}

func (f fontChooser) FontFace() pango.FontFace {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.PangoFontFace  // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_face(_arg0)

	var _fontFace pango.FontFace // out

	_fontFace = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFace)

	return _fontFace
}

func (f fontChooser) FontFamily() pango.FontFamily {
	var _arg0 *C.GtkFontChooser  // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_family(_arg0)

	var _fontFamily pango.FontFamily // out

	_fontFamily = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFamily)

	return _fontFamily
}

func (f fontChooser) FontFeatures() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_features(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (f fontChooser) FontMap() pango.FontMap {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.PangoFontMap   // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_map(_arg0)

	var _fontMap pango.FontMap // out

	_fontMap = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.FontMap)

	return _fontMap
}

func (f fontChooser) FontSize() int {
	var _arg0 *C.GtkFontChooser // out
	var _cret C.int             // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (f fontChooser) Language() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_language(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (f fontChooser) Level() FontChooserLevel {
	var _arg0 *C.GtkFontChooser     // out
	var _cret C.GtkFontChooserLevel // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_level(_arg0)

	var _fontChooserLevel FontChooserLevel // out

	_fontChooserLevel = FontChooserLevel(_cret)

	return _fontChooserLevel
}

func (f fontChooser) PreviewText() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_preview_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (f fontChooser) ShowPreviewEntry() bool {
	var _arg0 *C.GtkFontChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_show_preview_entry(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f fontChooser) SetFont(fontname string) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(fontname))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_chooser_set_font(_arg0, _arg1)
}

func (f fontChooser) SetFontDesc(fontDesc *pango.FontDescription) {
	var _arg0 *C.GtkFontChooser       // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

	C.gtk_font_chooser_set_font_desc(_arg0, _arg1)
}

func (f fontChooser) SetFontMap(fontmap pango.FontMap) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.PangoFontMap   // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontmap.Native()))

	C.gtk_font_chooser_set_font_map(_arg0, _arg1)
}

func (f fontChooser) SetLanguage(language string) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(language))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_chooser_set_language(_arg0, _arg1)
}

func (f fontChooser) SetLevel(level FontChooserLevel) {
	var _arg0 *C.GtkFontChooser     // out
	var _arg1 C.GtkFontChooserLevel // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GtkFontChooserLevel)(level)

	C.gtk_font_chooser_set_level(_arg0, _arg1)
}

func (f fontChooser) SetPreviewText(text string) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_chooser_set_preview_text(_arg0, _arg1)
}

func (f fontChooser) SetShowPreviewEntry(showPreviewEntry bool) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	if showPreviewEntry {
		_arg1 = C.TRUE
	}

	C.gtk_font_chooser_set_show_preview_entry(_arg0, _arg1)
}

// Native: `GtkNative` is the interface implemented by all widgets that have
// their own `GdkSurface`.
//
// The obvious example of a `GtkNative` is `GtkWindow`.
//
// Every widget that is not itself a `GtkNative` is contained in one, and you
// can get it with [method@Gtk.Widget.get_native].
//
// To get the surface of a `GtkNative`, use [method@Gtk.Native.get_surface]. It
// is also possible to find the `GtkNative` to which a surface belongs, with
// [func@Gtk.Native.get_for_surface].
//
// In addition to a [class@Gdk.Surface], a `GtkNative` also provides a
// [class@Gsk.Renderer] for rendering on that surface. To get the renderer, use
// [method@Gtk.Native.get_renderer].
type Native interface {

	// Renderer returns the renderer that is used for this `GtkNative`.
	Renderer() gsk.Renderer
	// Surface returns the surface of this `GtkNative`.
	Surface() gdk.Surface
	// SurfaceTransform retrieves the surface transform of @self.
	//
	// This is the translation from @self's surface coordinates into @self's
	// widget coordinates.
	SurfaceTransform() (x float64, y float64)
	// Realize realizes a `GtkNative`.
	//
	// This should only be used by subclasses.
	Realize()
	// Unrealize unrealizes a `GtkNative`.
	//
	// This should only be used by subclasses.
	Unrealize()
}

// native implements the Native interface.
type native struct {
}

var _ Native = (*native)(nil)

// WrapNative wraps a GObject to a type that implements
// interface Native. It is primarily used internally.
func WrapNative(obj *externglib.Object) Native {
	return native{
		Widget: WrapWidget(obj),
	}
}

func marshalNative(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNative(obj), nil
}

func (s native) Renderer() gsk.Renderer {
	var _arg0 *C.GtkNative   // out
	var _cret *C.GskRenderer // in

	_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_get_renderer(_arg0)

	var _renderer gsk.Renderer // out

	_renderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gsk.Renderer)

	return _renderer
}

func (s native) Surface() gdk.Surface {
	var _arg0 *C.GtkNative  // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_get_surface(_arg0)

	var _surface gdk.Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Surface)

	return _surface
}

func (s native) SurfaceTransform() (x float64, y float64) {
	var _arg0 *C.GtkNative // out
	var _arg1 C.double     // in
	var _arg2 C.double     // in

	_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

	C.gtk_native_get_surface_transform(_arg0, &_arg1, &_arg2)

	var _x float64 // out
	var _y float64 // out

	_x = (float64)(_arg1)
	_y = (float64)(_arg2)

	return _x, _y
}

func (s native) Realize() {
	var _arg0 *C.GtkNative // out

	_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

	C.gtk_native_realize(_arg0)
}

func (s native) Unrealize() {
	var _arg0 *C.GtkNative // out

	_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

	C.gtk_native_unrealize(_arg0)
}

// Orientable: the `GtkOrientable` interface is implemented by all widgets that
// can be oriented horizontally or vertically.
//
// `GtkOrientable` is more flexible in that it allows the orientation to be
// changed at runtime, allowing the widgets to flip.
type Orientable interface {

	// Orientation retrieves the orientation of the @orientable.
	Orientation() Orientation
	// SetOrientation sets the orientation of the @orientable.
	SetOrientation(orientation Orientation)
}

// orientable implements the Orientable interface.
type orientable struct {
}

var _ Orientable = (*orientable)(nil)

// WrapOrientable wraps a GObject to a type that implements
// interface Orientable. It is primarily used internally.
func WrapOrientable(obj *externglib.Object) Orientable {
	return orientable{
		Objector: obj,
	}
}

func marshalOrientable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOrientable(obj), nil
}

func (o orientable) Orientation() Orientation {
	var _arg0 *C.GtkOrientable // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkOrientable)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_orientable_get_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

func (o orientable) SetOrientation(orientation Orientation) {
	var _arg0 *C.GtkOrientable // out
	var _arg1 C.GtkOrientation // out

	_arg0 = (*C.GtkOrientable)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	C.gtk_orientable_set_orientation(_arg0, _arg1)
}

// PrintOperationPreviewOverrider contains methods that are overridable. This
// interface is a subset of the interface PrintOperationPreview.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type PrintOperationPreviewOverrider interface {
	// EndPreview ends a preview.
	//
	// This function must be called to finish a custom print preview.
	EndPreview()

	GotPageSize(context PrintContext, pageSetup PageSetup)
	// IsSelected returns whether the given page is included in the set of pages
	// that have been selected for printing.
	IsSelected(pageNr int) bool

	Ready(context PrintContext)
	// RenderPage renders a page to the preview.
	//
	// This is using the print context that was passed to the
	// [signal@Gtk.PrintOperation::preview] handler together with @preview.
	//
	// A custom print preview should use this function to render the currently
	// selected page.
	//
	// Note that this function requires a suitable cairo context to be
	// associated with the print context.
	RenderPage(pageNr int)
}

// PrintOperationPreview: `GtkPrintOperationPreview` is the interface that is
// used to implement print preview.
//
// A `GtkPrintOperationPreview` object is passed to the
// [signal@Gtk.PrintOperation::preview] signal by [class@Gtk.PrintOperation].
type PrintOperationPreview interface {

	// EndPreview ends a preview.
	//
	// This function must be called to finish a custom print preview.
	EndPreview()
	// IsSelected returns whether the given page is included in the set of pages
	// that have been selected for printing.
	IsSelected(pageNr int) bool
	// RenderPage renders a page to the preview.
	//
	// This is using the print context that was passed to the
	// [signal@Gtk.PrintOperation::preview] handler together with @preview.
	//
	// A custom print preview should use this function to render the currently
	// selected page.
	//
	// Note that this function requires a suitable cairo context to be
	// associated with the print context.
	RenderPage(pageNr int)
}

// printOperationPreview implements the PrintOperationPreview interface.
type printOperationPreview struct {
}

var _ PrintOperationPreview = (*printOperationPreview)(nil)

// WrapPrintOperationPreview wraps a GObject to a type that implements
// interface PrintOperationPreview. It is primarily used internally.
func WrapPrintOperationPreview(obj *externglib.Object) PrintOperationPreview {
	return printOperationPreview{
		Objector: obj,
	}
}

func marshalPrintOperationPreview(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintOperationPreview(obj), nil
}

func (p printOperationPreview) EndPreview() {
	var _arg0 *C.GtkPrintOperationPreview // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))

	C.gtk_print_operation_preview_end_preview(_arg0)
}

func (p printOperationPreview) IsSelected(pageNr int) bool {
	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 C.int                       // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))
	_arg1 = (C.int)(pageNr)

	_cret = C.gtk_print_operation_preview_is_selected(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p printOperationPreview) RenderPage(pageNr int) {
	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 C.int                       // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))
	_arg1 = (C.int)(pageNr)

	C.gtk_print_operation_preview_render_page(_arg0, _arg1)
}

// Root: `GtkRoot` is the interface implemented by all widgets that can act as a
// toplevel widget.
//
// The root widget takes care of providing the connection to the windowing
// system and manages layout, drawing and event delivery for its widget
// hierarchy.
//
// The obvious example of a `GtkRoot` is `GtkWindow`.
//
// To get the display to which a `GtkRoot` belongs, use
// [method@Gtk.Root.get_display].
//
// `GtkRoot` also maintains the location of keyboard focus inside its widget
// hierarchy, with [method@Gtk.Root.set_focus] and [method@Gtk.Root.get_focus].
type Root interface {
	Native

	// Display returns the display that this `GtkRoot` is on.
	Display() gdk.Display
	// Focus retrieves the current focused widget within the root.
	//
	// Note that this is the widget that would have the focus if the root is
	// active; if the root is not focused then `gtk_widget_has_focus (widget)`
	// will be false for the widget.
	Focus() Widget
	// SetFocus: if @focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the root.
	//
	// If @focus is nil, unsets the focus widget for the root.
	//
	// To set the focus to a particular widget in the root, it is usually more
	// convenient to use [method@Gtk.Widget.grab_focus] instead of this
	// function.
	SetFocus(focus Widget)
}

// root implements the Root interface.
type root struct {
	Native
}

var _ Root = (*root)(nil)

// WrapRoot wraps a GObject to a type that implements
// interface Root. It is primarily used internally.
func WrapRoot(obj *externglib.Object) Root {
	return root{
		Native: WrapNative(obj),
		Widget: WrapWidget(obj),
	}
}

func marshalRoot(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRoot(obj), nil
}

func (s root) Display() gdk.Display {
	var _arg0 *C.GtkRoot    // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GtkRoot)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_root_get_display(_arg0)

	var _display gdk.Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

	return _display
}

func (s root) Focus() Widget {
	var _arg0 *C.GtkRoot   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkRoot)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_root_get_focus(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s root) SetFocus(focus Widget) {
	var _arg0 *C.GtkRoot   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkRoot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(focus.Native()))

	C.gtk_root_set_focus(_arg0, _arg1)
}

// ScrollableOverrider contains methods that are overridable. This
// interface is a subset of the interface Scrollable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type ScrollableOverrider interface {
	// Border returns the size of a non-scrolling border around the outside of
	// the scrollable.
	//
	// An example for this would be treeview headers. GTK can use this
	// information to display overlaid graphics, like the overshoot indication,
	// at the right position.
	Border() (Border, bool)
}

// Scrollable: `GtkScrollable` is an interface for widgets with native scrolling
// ability.
//
// To implement this interface you should override the
// [property@Gtk.Scrollable:hadjustment] and
// [property@Gtk.Scrollable:vadjustment] properties.
//
//
// Creating a scrollable widget
//
// All scrollable widgets should do the following.
//
// - When a parent widget sets the scrollable child widgets adjustments, the
// widget should populate the adjustments [property@Gtk.Adjustment:lower],
// [property@Gtk.Adjustment:upper], [property@Gtk.Adjustment:step-increment],
// [property@Gtk.Adjustment:page-increment] and
// [property@Gtk.Adjustment:page-size] properties and connect to the
// [signal@Gtk.Adjustment::value-changed] signal.
//
// - Because its preferred size is the size for a fully expanded widget, the
// scrollable widget must be able to cope with underallocations. This means that
// it must accept any value passed to its GtkWidgetClass.size_allocate()
// function.
//
// - When the parent allocates space to the scrollable child widget, the widget
// should update the adjustments properties with new values.
//
// - When any of the adjustments emits the
// [signal@Gtk.Adjustment::value-changed] signal, the scrollable widget should
// scroll its contents.
type Scrollable interface {

	// Border returns the size of a non-scrolling border around the outside of
	// the scrollable.
	//
	// An example for this would be treeview headers. GTK can use this
	// information to display overlaid graphics, like the overshoot indication,
	// at the right position.
	Border() (Border, bool)
	// HAdjustment retrieves the `GtkAdjustment` used for horizontal scrolling.
	HAdjustment() Adjustment
	// HScrollPolicy gets the horizontal `GtkScrollablePolicy`.
	HScrollPolicy() ScrollablePolicy
	// VAdjustment retrieves the `GtkAdjustment` used for vertical scrolling.
	VAdjustment() Adjustment
	// VScrollPolicy gets the vertical `GtkScrollablePolicy`.
	VScrollPolicy() ScrollablePolicy
	// SetHAdjustment sets the horizontal adjustment of the `GtkScrollable`.
	SetHAdjustment(hadjustment Adjustment)
	// SetHScrollPolicy sets the `GtkScrollablePolicy`.
	//
	// The policy determines whether horizontal scrolling should start below the
	// minimum width or below the natural width.
	SetHScrollPolicy(policy ScrollablePolicy)
	// SetVAdjustment sets the vertical adjustment of the `GtkScrollable`.
	SetVAdjustment(vadjustment Adjustment)
	// SetVScrollPolicy sets the `GtkScrollablePolicy`.
	//
	// The policy determines whether vertical scrolling should start below the
	// minimum height or below the natural height.
	SetVScrollPolicy(policy ScrollablePolicy)
}

// scrollable implements the Scrollable interface.
type scrollable struct {
}

var _ Scrollable = (*scrollable)(nil)

// WrapScrollable wraps a GObject to a type that implements
// interface Scrollable. It is primarily used internally.
func WrapScrollable(obj *externglib.Object) Scrollable {
	return scrollable{
		Objector: obj,
	}
}

func marshalScrollable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrollable(obj), nil
}

func (s scrollable) Border() (Border, bool) {
	var _arg0 *C.GtkScrollable // out
	var _border Border
	var _cret C.gboolean // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_border(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_border)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _border, _ok
}

func (s scrollable) HAdjustment() Adjustment {
	var _arg0 *C.GtkScrollable // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (s scrollable) HScrollPolicy() ScrollablePolicy {
	var _arg0 *C.GtkScrollable      // out
	var _cret C.GtkScrollablePolicy // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_hscroll_policy(_arg0)

	var _scrollablePolicy ScrollablePolicy // out

	_scrollablePolicy = ScrollablePolicy(_cret)

	return _scrollablePolicy
}

func (s scrollable) VAdjustment() Adjustment {
	var _arg0 *C.GtkScrollable // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (s scrollable) VScrollPolicy() ScrollablePolicy {
	var _arg0 *C.GtkScrollable      // out
	var _cret C.GtkScrollablePolicy // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_vscroll_policy(_arg0)

	var _scrollablePolicy ScrollablePolicy // out

	_scrollablePolicy = ScrollablePolicy(_cret)

	return _scrollablePolicy
}

func (s scrollable) SetHAdjustment(hadjustment Adjustment) {
	var _arg0 *C.GtkScrollable // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

	C.gtk_scrollable_set_hadjustment(_arg0, _arg1)
}

func (s scrollable) SetHScrollPolicy(policy ScrollablePolicy) {
	var _arg0 *C.GtkScrollable      // out
	var _arg1 C.GtkScrollablePolicy // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkScrollablePolicy)(policy)

	C.gtk_scrollable_set_hscroll_policy(_arg0, _arg1)
}

func (s scrollable) SetVAdjustment(vadjustment Adjustment) {
	var _arg0 *C.GtkScrollable // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	C.gtk_scrollable_set_vadjustment(_arg0, _arg1)
}

func (s scrollable) SetVScrollPolicy(policy ScrollablePolicy) {
	var _arg0 *C.GtkScrollable      // out
	var _arg1 C.GtkScrollablePolicy // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkScrollablePolicy)(policy)

	C.gtk_scrollable_set_vscroll_policy(_arg0, _arg1)
}

// SelectionModelOverrider contains methods that are overridable. This
// interface is a subset of the interface SelectionModel.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type SelectionModelOverrider interface {
	// SelectionInRange gets the set of selected items in a range.
	//
	// This function is an optimization for
	// [method@Gtk.SelectionModel.get_selection] when you are only interested in
	// part of the model's selected state. A common use case is in response to
	// the [signal@Gtk.SelectionModel::selection-changed] signal.
	SelectionInRange(position uint, nItems uint) *Bitset
	// IsSelected checks if the given item is selected.
	IsSelected(position uint) bool
	// SelectAll requests to select all items in the model.
	SelectAll() bool
	// SelectItem requests to select an item in the model.
	SelectItem(position uint, unselectRest bool) bool
	// SelectRange requests to select a range of items in the model.
	SelectRange(position uint, nItems uint, unselectRest bool) bool
	// SetSelection: make selection changes.
	//
	// This is the most advanced selection updating method that allows the most
	// fine-grained control over selection changes. If you can, you should try
	// the simpler versions, as implementations are more likely to implement
	// support for those.
	//
	// Requests that the selection state of all positions set in @mask be
	// updated to the respective value in the @selected bitmask.
	//
	// In pseudocode, it would look something like this:
	//
	// `c for (i = 0; i < n_items; i++) { // don't change values not in the
	// mask if (!gtk_bitset_contains (mask, i)) continue;
	//
	//      if (gtk_bitset_contains (selected, i))
	//        select_item (i);
	//      else
	//        unselect_item (i);
	//    }
	//
	// gtk_selection_model_selection_changed (model, first_changed_item,
	// n_changed_items); `
	//
	// @mask and @selected must not be modified. They may refer to the same
	// bitset, which would mean that every item in the set should be selected.
	SetSelection(selected *Bitset, mask *Bitset) bool
	// UnselectAll requests to unselect all items in the model.
	UnselectAll() bool
	// UnselectItem requests to unselect an item in the model.
	UnselectItem(position uint) bool
	// UnselectRange requests to unselect a range of items in the model.
	UnselectRange(position uint, nItems uint) bool
}

// SelectionModel: `GtkSelectionModel` is an interface that add support for
// selection to list models.
//
// This support is then used by widgets using list models to add the ability to
// select and unselect various items.
//
// GTK provides default implementations of the most common selection modes such
// as [class@Gtk.SingleSelection], so you will only need to implement this
// interface if you want detailed control about how selections should be
// handled.
//
// A `GtkSelectionModel` supports a single boolean per item indicating if an
// item is selected or not. This can be queried via
// [method@Gtk.SelectionModel.is_selected]. When the selected state of one or
// more items changes, the model will emit the
// [signal@Gtk.SelectionModel::selection-changed] signal by calling the
// [method@Gtk.SelectionModel.selection_changed] function. The positions given
// in that signal may have their selection state changed, though that is not a
// requirement. If new items added to the model via the ::items-changed signal
// are selected or not is up to the implementation.
//
// Note that items added via ::items-changed may already be selected and no
// [Gtk.SelectionModel::selection-changed] will be emitted for them. So to track
// which items are selected, it is necessary to listen to both signals.
//
// Additionally, the interface can expose functionality to select and unselect
// items. If these functions are implemented, GTK's list widgets will allow
// users to select and unselect items. However, `GtkSelectionModel`s are free to
// only implement them partially or not at all. In that case the widgets will
// not support the unimplemented operations.
//
// When selecting or unselecting is supported by a model, the return values of
// the selection functions do *not* indicate if selection or unselection
// happened. They are only meant to indicate complete failure, like when this
// mode of selecting is not supported by the model.
//
// Selections may happen asynchronously, so the only reliable way to find out
// when an item was selected is to listen to the signals that indicate
// selection.
type SelectionModel interface {

	// Selection gets the set containing all currently selected items in the
	// model.
	//
	// This function may be slow, so if you are only interested in single item,
	// consider using [method@Gtk.SelectionModel.is_selected] or if you are only
	// interested in a few, consider
	// [method@Gtk.SelectionModel.get_selection_in_range].
	Selection() *Bitset
	// SelectionInRange gets the set of selected items in a range.
	//
	// This function is an optimization for
	// [method@Gtk.SelectionModel.get_selection] when you are only interested in
	// part of the model's selected state. A common use case is in response to
	// the [signal@Gtk.SelectionModel::selection-changed] signal.
	SelectionInRange(position uint, nItems uint) *Bitset
	// IsSelected checks if the given item is selected.
	IsSelected(position uint) bool
	// SelectAll requests to select all items in the model.
	SelectAll() bool
	// SelectItem requests to select an item in the model.
	SelectItem(position uint, unselectRest bool) bool
	// SelectRange requests to select a range of items in the model.
	SelectRange(position uint, nItems uint, unselectRest bool) bool
	// SelectionChanged: helper function for implementations of
	// `GtkSelectionModel`.
	//
	// Call this when a the selection changes to emit the
	// [signal@Gtk.SelectionModel::selection-changed] signal.
	SelectionChanged(position uint, nItems uint)
	// SetSelection: make selection changes.
	//
	// This is the most advanced selection updating method that allows the most
	// fine-grained control over selection changes. If you can, you should try
	// the simpler versions, as implementations are more likely to implement
	// support for those.
	//
	// Requests that the selection state of all positions set in @mask be
	// updated to the respective value in the @selected bitmask.
	//
	// In pseudocode, it would look something like this:
	//
	// `c for (i = 0; i < n_items; i++) { // don't change values not in the
	// mask if (!gtk_bitset_contains (mask, i)) continue;
	//
	//      if (gtk_bitset_contains (selected, i))
	//        select_item (i);
	//      else
	//        unselect_item (i);
	//    }
	//
	// gtk_selection_model_selection_changed (model, first_changed_item,
	// n_changed_items); `
	//
	// @mask and @selected must not be modified. They may refer to the same
	// bitset, which would mean that every item in the set should be selected.
	SetSelection(selected *Bitset, mask *Bitset) bool
	// UnselectAll requests to unselect all items in the model.
	UnselectAll() bool
	// UnselectItem requests to unselect an item in the model.
	UnselectItem(position uint) bool
	// UnselectRange requests to unselect a range of items in the model.
	UnselectRange(position uint, nItems uint) bool
}

// selectionModel implements the SelectionModel interface.
type selectionModel struct {
}

var _ SelectionModel = (*selectionModel)(nil)

// WrapSelectionModel wraps a GObject to a type that implements
// interface SelectionModel. It is primarily used internally.
func WrapSelectionModel(obj *externglib.Object) SelectionModel {
	return selectionModel{
		ListModel: gio.WrapListModel(obj),
	}
}

func marshalSelectionModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSelectionModel(obj), nil
}

func (m selectionModel) Selection() *Bitset {
	var _arg0 *C.GtkSelectionModel // out
	var _cret *C.GtkBitset         // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_selection_model_get_selection(_arg0)

	var _bitset *Bitset // out

	_bitset = WrapBitset(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_bitset, func(v *Bitset) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _bitset
}

func (m selectionModel) SelectionInRange(position uint, nItems uint) *Bitset {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out
	var _cret *C.GtkBitset         // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.guint)(nItems)

	_cret = C.gtk_selection_model_get_selection_in_range(_arg0, _arg1, _arg2)

	var _bitset *Bitset // out

	_bitset = WrapBitset(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_bitset, func(v *Bitset) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _bitset
}

func (m selectionModel) IsSelected(position uint) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(position)

	_cret = C.gtk_selection_model_is_selected(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m selectionModel) SelectAll() bool {
	var _arg0 *C.GtkSelectionModel // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_selection_model_select_all(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m selectionModel) SelectItem(position uint, unselectRest bool) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.gboolean           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(position)
	if unselectRest {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_selection_model_select_item(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m selectionModel) SelectRange(position uint, nItems uint, unselectRest bool) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out
	var _arg3 C.gboolean           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.guint)(nItems)
	if unselectRest {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_selection_model_select_range(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m selectionModel) SelectionChanged(position uint, nItems uint) {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.guint)(nItems)

	C.gtk_selection_model_selection_changed(_arg0, _arg1, _arg2)
}

func (m selectionModel) SetSelection(selected *Bitset, mask *Bitset) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 *C.GtkBitset         // out
	var _arg2 *C.GtkBitset         // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkBitset)(unsafe.Pointer(selected.Native()))
	_arg2 = (*C.GtkBitset)(unsafe.Pointer(mask.Native()))

	_cret = C.gtk_selection_model_set_selection(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m selectionModel) UnselectAll() bool {
	var _arg0 *C.GtkSelectionModel // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_selection_model_unselect_all(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m selectionModel) UnselectItem(position uint) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(position)

	_cret = C.gtk_selection_model_unselect_item(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m selectionModel) UnselectRange(position uint, nItems uint) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.guint)(nItems)

	_cret = C.gtk_selection_model_unselect_range(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShortcutManagerOverrider contains methods that are overridable. This
// interface is a subset of the interface ShortcutManager.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type ShortcutManagerOverrider interface {
	AddController(controller ShortcutController)

	RemoveController(controller ShortcutController)
}

// ShortcutManager: the `GtkShortcutManager` interface is used to implement
// shortcut scopes.
//
// This is important for [iface@Gtk.Native] widgets that have their own surface,
// since the event controllers that are used to implement managed and global
// scopes are limited to the same native.
//
// Examples for widgets implementing `GtkShortcutManager` are [class@Gtk.Window]
// and [class@Gtk.Popover].
//
// Every widget that implements `GtkShortcutManager` will be used as a
// GTK_SHORTCUT_SCOPE_MANAGED.
type ShortcutManager interface {
}

// shortcutManager implements the ShortcutManager interface.
type shortcutManager struct {
}

var _ ShortcutManager = (*shortcutManager)(nil)

// WrapShortcutManager wraps a GObject to a type that implements
// interface ShortcutManager. It is primarily used internally.
func WrapShortcutManager(obj *externglib.Object) ShortcutManager {
	return shortcutManager{
		Objector: obj,
	}
}

func marshalShortcutManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutManager(obj), nil
}

// StyleProvider: `GtkStyleProvider` is an interface for style information used
// by `GtkStyleContext`.
//
// See [method@Gtk.StyleContext.add_provider] and
// [func@Gtk.StyleContext.add_provider_for_display] for adding
// `GtkStyleProviders`.
//
// GTK uses the `GtkStyleProvider` implementation for CSS in
// [iface@Gtk.CssProvider].
type StyleProvider interface {
}

// styleProvider implements the StyleProvider interface.
type styleProvider struct {
}

var _ StyleProvider = (*styleProvider)(nil)

// WrapStyleProvider wraps a GObject to a type that implements
// interface StyleProvider. It is primarily used internally.
func WrapStyleProvider(obj *externglib.Object) StyleProvider {
	return styleProvider{
		Objector: obj,
	}
}

func marshalStyleProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleProvider(obj), nil
}

// TreeDragDestOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeDragDest.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TreeDragDestOverrider interface {
	// DragDataReceived asks the TreeDragDest to insert a row before the path
	// @dest, deriving the contents of the row from @value. If @dest is outside
	// the tree so that inserting before it is impossible, false will be
	// returned. Also, false may be returned if the new row is not created for
	// some model-specific reason. Should robustly handle a @dest no longer
	// found in the model!
	DragDataReceived(dest *TreePath, value *externglib.Value) bool
	// RowDropPossible determines whether a drop is possible before the given
	// @dest_path, at the same depth as @dest_path. i.e., can we drop the data
	// in @value at that location. @dest_path does not have to exist; the return
	// value will almost certainly be false if the parent of @dest_path doesnt
	// exist, though.
	RowDropPossible(destPath *TreePath, value *externglib.Value) bool
}

// TreeDragDest: interface for Drag-and-Drop destinations in `GtkTreeView`.
type TreeDragDest interface {

	// DragDataReceived asks the TreeDragDest to insert a row before the path
	// @dest, deriving the contents of the row from @value. If @dest is outside
	// the tree so that inserting before it is impossible, false will be
	// returned. Also, false may be returned if the new row is not created for
	// some model-specific reason. Should robustly handle a @dest no longer
	// found in the model!
	DragDataReceived(dest *TreePath, value *externglib.Value) bool
	// RowDropPossible determines whether a drop is possible before the given
	// @dest_path, at the same depth as @dest_path. i.e., can we drop the data
	// in @value at that location. @dest_path does not have to exist; the return
	// value will almost certainly be false if the parent of @dest_path doesnt
	// exist, though.
	RowDropPossible(destPath *TreePath, value *externglib.Value) bool
}

// treeDragDest implements the TreeDragDest interface.
type treeDragDest struct {
}

var _ TreeDragDest = (*treeDragDest)(nil)

// WrapTreeDragDest wraps a GObject to a type that implements
// interface TreeDragDest. It is primarily used internally.
func WrapTreeDragDest(obj *externglib.Object) TreeDragDest {
	return treeDragDest{
		Objector: obj,
	}
}

func marshalTreeDragDest(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeDragDest(obj), nil
}

func (d treeDragDest) DragDataReceived(dest *TreePath, value *externglib.Value) bool {
	var _arg0 *C.GtkTreeDragDest // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GValue          // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(dest.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.gtk_tree_drag_dest_drag_data_received(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d treeDragDest) RowDropPossible(destPath *TreePath, value *externglib.Value) bool {
	var _arg0 *C.GtkTreeDragDest // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GValue          // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(destPath.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.gtk_tree_drag_dest_row_drop_possible(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeDragSourceOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeDragSource.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TreeDragSourceOverrider interface {
	// DragDataDelete asks the TreeDragSource to delete the row at @path,
	// because it was moved somewhere else via drag-and-drop. Returns false if
	// the deletion fails because @path no longer exists, or for some
	// model-specific reason. Should robustly handle a @path no longer found in
	// the model!
	DragDataDelete(path *TreePath) bool
	// DragDataGet asks the TreeDragSource to return a ContentProvider
	// representing the row at @path. Should robustly handle a @path no longer
	// found in the model!
	DragDataGet(path *TreePath) gdk.ContentProvider
	// RowDraggable asks the TreeDragSource whether a particular row can be used
	// as the source of a DND operation. If the source doesnt implement this
	// interface, the row is assumed draggable.
	RowDraggable(path *TreePath) bool
}

// TreeDragSource: interface for Drag-and-Drop destinations in `GtkTreeView`.
type TreeDragSource interface {

	// DragDataDelete asks the TreeDragSource to delete the row at @path,
	// because it was moved somewhere else via drag-and-drop. Returns false if
	// the deletion fails because @path no longer exists, or for some
	// model-specific reason. Should robustly handle a @path no longer found in
	// the model!
	DragDataDelete(path *TreePath) bool
	// DragDataGet asks the TreeDragSource to return a ContentProvider
	// representing the row at @path. Should robustly handle a @path no longer
	// found in the model!
	DragDataGet(path *TreePath) gdk.ContentProvider
	// RowDraggable asks the TreeDragSource whether a particular row can be used
	// as the source of a DND operation. If the source doesnt implement this
	// interface, the row is assumed draggable.
	RowDraggable(path *TreePath) bool
}

// treeDragSource implements the TreeDragSource interface.
type treeDragSource struct {
}

var _ TreeDragSource = (*treeDragSource)(nil)

// WrapTreeDragSource wraps a GObject to a type that implements
// interface TreeDragSource. It is primarily used internally.
func WrapTreeDragSource(obj *externglib.Object) TreeDragSource {
	return treeDragSource{
		Objector: obj,
	}
}

func marshalTreeDragSource(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeDragSource(obj), nil
}

func (d treeDragSource) DragDataDelete(path *TreePath) bool {
	var _arg0 *C.GtkTreeDragSource // out
	var _arg1 *C.GtkTreePath       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_drag_source_drag_data_delete(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d treeDragSource) DragDataGet(path *TreePath) gdk.ContentProvider {
	var _arg0 *C.GtkTreeDragSource  // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_drag_source_drag_data_get(_arg0, _arg1)

	var _contentProvider gdk.ContentProvider // out

	_contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.ContentProvider)

	return _contentProvider
}

func (d treeDragSource) RowDraggable(path *TreePath) bool {
	var _arg0 *C.GtkTreeDragSource // out
	var _arg1 *C.GtkTreePath       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_drag_source_row_draggable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeModelOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeModel.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TreeModelOverrider interface {
	// ColumnType returns the type of the column.
	ColumnType(index_ int) externglib.Type
	// Flags returns a set of flags supported by this interface.
	//
	// The flags are a bitwise combination of TreeModelFlags. The flags
	// supported should not change during the lifetime of the @tree_model.
	Flags() TreeModelFlags
	// Iter sets @iter to a valid iterator pointing to @path. If @path does not
	// exist, @iter is set to an invalid iterator and false is returned.
	Iter(path *TreePath) (TreeIter, bool)
	// NColumns returns the number of columns supported by @tree_model.
	NColumns() int
	// Path returns a newly-created TreePath-struct referenced by @iter.
	//
	// This path should be freed with gtk_tree_path_free().
	Path(iter *TreeIter) *TreePath
	// Value initializes and sets @value to that at @column.
	//
	// When done with @value, g_value_unset() needs to be called to free any
	// allocated memory.
	Value(iter *TreeIter, column int) externglib.Value
	// IterChildren sets @iter to point to the first child of @parent.
	//
	// If @parent has no children, false is returned and @iter is set to be
	// invalid. @parent will remain a valid node after this function has been
	// called.
	//
	// If @parent is nil returns the first node, equivalent to
	// `gtk_tree_model_get_iter_first (tree_model, iter);`
	IterChildren(parent *TreeIter) (TreeIter, bool)
	// IterHasChild returns true if @iter has children, false otherwise.
	IterHasChild(iter *TreeIter) bool
	// IterNChildren returns the number of children that @iter has.
	//
	// As a special case, if @iter is nil, then the number of toplevel nodes is
	// returned.
	IterNChildren(iter *TreeIter) int
	// IterNext sets @iter to point to the node following it at the current
	// level.
	//
	// If there is no next @iter, false is returned and @iter is set to be
	// invalid.
	IterNext(iter *TreeIter) bool
	// IterNthChild sets @iter to be the child of @parent, using the given
	// index.
	//
	// The first index is 0. If @n is too big, or @parent has no children, @iter
	// is set to an invalid iterator and false is returned. @parent will remain
	// a valid node after this function has been called. As a special case, if
	// @parent is nil, then the @n-th root node is set.
	IterNthChild(parent *TreeIter, n int) (TreeIter, bool)
	// IterParent sets @iter to be the parent of @child.
	//
	// If @child is at the toplevel, and doesnt have a parent, then @iter is
	// set to an invalid iterator and false is returned. @child will remain a
	// valid node after this function has been called.
	//
	// @iter will be initialized before the lookup is performed, so @child and
	// @iter cannot point to the same memory location.
	IterParent(child *TreeIter) (TreeIter, bool)
	// IterPrevious sets @iter to point to the previous node at the current
	// level.
	//
	// If there is no previous @iter, false is returned and @iter is set to be
	// invalid.
	IterPrevious(iter *TreeIter) bool
	// RefNode lets the tree ref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons.
	//
	// This function is primarily meant as a way for views to let caching models
	// know when nodes are being displayed (and hence, whether or not to cache
	// that node). Being displayed means a node is in an expanded branch,
	// regardless of whether the node is currently visible in the viewport. For
	// example, a file-system based model would not want to keep the entire
	// file-hierarchy in memory, just the sections that are currently being
	// displayed by every current view.
	//
	// A model should be expected to be able to get an iter independent of its
	// reffed state.
	RefNode(iter *TreeIter)
	// RowChanged emits the TreeModel::row-changed signal on @tree_model.
	RowChanged(path *TreePath, iter *TreeIter)
	// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
	//
	// This should be called by models after a row has been removed. The
	// location pointed to by @path should be the location that the row
	// previously was at. It may not be a valid location anymore.
	//
	// Nodes that are deleted are not unreffed, this means that any outstanding
	// references on the deleted node should not be released.
	RowDeleted(path *TreePath)
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// @tree_model. This should be called by models after the child state of a
	// node changes.
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
	RowInserted(path *TreePath, iter *TreeIter)
	// UnrefNode lets the tree unref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons. For more information on what this means, see
	// gtk_tree_model_ref_node().
	//
	// Please note that nodes that are deleted are not unreffed.
	UnrefNode(iter *TreeIter)
}

// TreeModel: the tree interface used by GtkTreeView
//
// The TreeModel interface defines a generic tree interface for use by the
// TreeView widget. It is an abstract interface, and is designed to be usable
// with any appropriate data structure. The programmer just has to implement
// this interface on their own data type for it to be viewable by a TreeView
// widget.
//
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
//
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided  the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
//
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the [struct@Gtk.TreePath] and the [struct@Gtk.TreeIter] (iter is short
// for iterator). Most of the interface consists of operations on a
// [struct@Gtk.TreeIter].
//
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. A
// [struct@Gtk.TreePath] can be converted into either an array of unsigned
// integers or a string. The string form is a list of numbers separated by a
// colon. Each number refers to the offset at that level. Thus, the path `0`
// refers to the root node and the path `2:4` refers to the fifth child of the
// third node.
//
// By contrast, a [struct@Gtk.TreeIter] is a reference to a specific node on a
// specific model. It is a generic struct with an integer and three generic
// pointers. These are filled in by the model in a model-specific way. One can
// convert a path to an iterator by calling gtk_tree_model_get_iter(). These
// iterators are the primary way of accessing a model and are similar to the
// iterators used by TextBuffer. They are generally statically allocated on the
// stack and only used for a short time. The model interface defines a set of
// operations using them for navigating the model.
//
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
//
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesnt emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the users point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
//
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location
// `3:2:5`. While the first method shown is easier, the second is much more
// common, as you often get paths from callbacks.
//
// Acquiring a `GtkTreeIter`
//
// `c // Three ways of getting the iter pointing to the location GtkTreePath
// *path; GtkTreeIter iter; GtkTreeIter parent_iter;
//
// // get the iterator from a string gtk_tree_model_get_iter_from_string (model,
// // &iter, "3:2:5");
//
// // get the iterator from a path path = gtk_tree_path_new_from_string
// // ("3:2:5"); gtk_tree_model_get_iter (model, &iter, path); gtk_tree_path_free
// // (path);
//
// // walk the tree to find the iterator gtk_tree_model_iter_nth_child (model,
// // &iter, NULL, 3); parent_iter = iter; gtk_tree_model_iter_nth_child (model,
// // &iter, &parent_iter, 2); parent_iter = iter; gtk_tree_model_iter_nth_child
// // (model, &iter, &parent_iter, 5); `
//
// This second example shows a quick way of iterating through a list and getting
// a string and an integer from each row. The populate_model() function used
// below is not shown, as it is specific to the ListStore. For information on
// how to write such a function, see the ListStore documentation.
//
// Reading data from a `GtkTreeModel`
//
// `c enum { STRING_COLUMN, INT_COLUMN, N_COLUMNS };
//
// ...
//
// GtkTreeModel *list_store; GtkTreeIter iter; gboolean valid; int row_count =
// 0;
//
// // make a new list_store list_store = gtk_list_store_new (N_COLUMNS,
// // G_TYPE_STRING, G_TYPE_INT);
//
// // Fill the list store with data populate_model (list_store);
//
// // Get the first iter in the list, check it is valid and walk // through the
// // list, reading each row.
//
// valid = gtk_tree_model_get_iter_first (list_store, &iter); while (valid) {
// char *str_data; int int_data;
//
//      // Make sure you terminate calls to gtk_tree_model_get() with a -1 value
//      gtk_tree_model_get (list_store, &iter,
//                          STRING_COLUMN, &str_data,
//                          INT_COLUMN, &int_data,
//                          -1);
//
//      // Do something with the data
//      g_print ("Row d: (s,d)\n",
//               row_count, str_data, int_data);
//      g_free (str_data);
//
//      valid = gtk_tree_model_iter_next (list_store,
//                                        &iter);
//      row_count++;
//    }
//
// `
//
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
//
// When working with reference counting, the following rules must be taken into
// account:
//
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
//
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
//
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
type TreeModel interface {

	// NewFilter creates a new TreeModel, with @child_model as the child_model
	// and @root as the virtual root.
	NewFilter(root *TreePath) TreeModel
	// ColumnType returns the type of the column.
	ColumnType(index_ int) externglib.Type
	// Flags returns a set of flags supported by this interface.
	//
	// The flags are a bitwise combination of TreeModelFlags. The flags
	// supported should not change during the lifetime of the @tree_model.
	Flags() TreeModelFlags
	// Iter sets @iter to a valid iterator pointing to @path. If @path does not
	// exist, @iter is set to an invalid iterator and false is returned.
	Iter(path *TreePath) (TreeIter, bool)
	// IterFirst initializes @iter with the first iterator in the tree (the one
	// at the path "0") and returns true. Returns false if the tree is empty.
	IterFirst() (TreeIter, bool)
	// IterFromString sets @iter to a valid iterator pointing to @path_string,
	// if it exists. Otherwise, @iter is left invalid and false is returned.
	IterFromString(pathString string) (TreeIter, bool)
	// NColumns returns the number of columns supported by @tree_model.
	NColumns() int
	// Path returns a newly-created TreePath-struct referenced by @iter.
	//
	// This path should be freed with gtk_tree_path_free().
	Path(iter *TreeIter) *TreePath
	// StringFromIter generates a string representation of the iter.
	//
	// This string is a : separated list of numbers. For example, 4:10:0:3
	// would be an acceptable return value for this string.
	StringFromIter(iter *TreeIter) string
	// Value initializes and sets @value to that at @column.
	//
	// When done with @value, g_value_unset() needs to be called to free any
	// allocated memory.
	Value(iter *TreeIter, column int) externglib.Value
	// IterChildren sets @iter to point to the first child of @parent.
	//
	// If @parent has no children, false is returned and @iter is set to be
	// invalid. @parent will remain a valid node after this function has been
	// called.
	//
	// If @parent is nil returns the first node, equivalent to
	// `gtk_tree_model_get_iter_first (tree_model, iter);`
	IterChildren(parent *TreeIter) (TreeIter, bool)
	// IterHasChild returns true if @iter has children, false otherwise.
	IterHasChild(iter *TreeIter) bool
	// IterNChildren returns the number of children that @iter has.
	//
	// As a special case, if @iter is nil, then the number of toplevel nodes is
	// returned.
	IterNChildren(iter *TreeIter) int
	// IterNext sets @iter to point to the node following it at the current
	// level.
	//
	// If there is no next @iter, false is returned and @iter is set to be
	// invalid.
	IterNext(iter *TreeIter) bool
	// IterNthChild sets @iter to be the child of @parent, using the given
	// index.
	//
	// The first index is 0. If @n is too big, or @parent has no children, @iter
	// is set to an invalid iterator and false is returned. @parent will remain
	// a valid node after this function has been called. As a special case, if
	// @parent is nil, then the @n-th root node is set.
	IterNthChild(parent *TreeIter, n int) (TreeIter, bool)
	// IterParent sets @iter to be the parent of @child.
	//
	// If @child is at the toplevel, and doesnt have a parent, then @iter is
	// set to an invalid iterator and false is returned. @child will remain a
	// valid node after this function has been called.
	//
	// @iter will be initialized before the lookup is performed, so @child and
	// @iter cannot point to the same memory location.
	IterParent(child *TreeIter) (TreeIter, bool)
	// IterPrevious sets @iter to point to the previous node at the current
	// level.
	//
	// If there is no previous @iter, false is returned and @iter is set to be
	// invalid.
	IterPrevious(iter *TreeIter) bool
	// RefNode lets the tree ref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons.
	//
	// This function is primarily meant as a way for views to let caching models
	// know when nodes are being displayed (and hence, whether or not to cache
	// that node). Being displayed means a node is in an expanded branch,
	// regardless of whether the node is currently visible in the viewport. For
	// example, a file-system based model would not want to keep the entire
	// file-hierarchy in memory, just the sections that are currently being
	// displayed by every current view.
	//
	// A model should be expected to be able to get an iter independent of its
	// reffed state.
	RefNode(iter *TreeIter)
	// RowChanged emits the TreeModel::row-changed signal on @tree_model.
	RowChanged(path *TreePath, iter *TreeIter)
	// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
	//
	// This should be called by models after a row has been removed. The
	// location pointed to by @path should be the location that the row
	// previously was at. It may not be a valid location anymore.
	//
	// Nodes that are deleted are not unreffed, this means that any outstanding
	// references on the deleted node should not be released.
	RowDeleted(path *TreePath)
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// @tree_model. This should be called by models after the child state of a
	// node changes.
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
	RowInserted(path *TreePath, iter *TreeIter)
	// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
	// @tree_model.
	//
	// This should be called by models when their rows have been reordered.
	RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int)
	// UnrefNode lets the tree unref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons. For more information on what this means, see
	// gtk_tree_model_ref_node().
	//
	// Please note that nodes that are deleted are not unreffed.
	UnrefNode(iter *TreeIter)
}

// treeModel implements the TreeModel interface.
type treeModel struct {
}

var _ TreeModel = (*treeModel)(nil)

// WrapTreeModel wraps a GObject to a type that implements
// interface TreeModel. It is primarily used internally.
func WrapTreeModel(obj *externglib.Object) TreeModel {
	return treeModel{
		Objector: obj,
	}
}

func marshalTreeModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModel(obj), nil
}

func (c treeModel) NewFilter(root *TreePath) TreeModel {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(root.Native()))

	_cret = C.gtk_tree_model_filter_new(_arg0, _arg1)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

func (t treeModel) ColumnType(index_ int) externglib.Type {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.int           // out
	var _cret C.GType         // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(index_)

	_cret = C.gtk_tree_model_get_column_type(_arg0, _arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (t treeModel) Flags() TreeModelFlags {
	var _arg0 *C.GtkTreeModel     // out
	var _cret C.GtkTreeModelFlags // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_model_get_flags(_arg0)

	var _treeModelFlags TreeModelFlags // out

	_treeModelFlags = TreeModelFlags(_cret)

	return _treeModelFlags
}

func (t treeModel) Iter(path *TreePath) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_model_get_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (t treeModel) IterFirst() (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_model_get_iter_first(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (t treeModel) IterFromString(pathString string) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.char    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.char)(C.CString(pathString))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_tree_model_get_iter_from_string(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (t treeModel) NColumns() int {
	var _arg0 *C.GtkTreeModel // out
	var _cret C.int           // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_model_get_n_columns(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeModel) Path(iter *TreeIter) *TreePath {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret *C.GtkTreePath  // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_get_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

func (t treeModel) StringFromIter(iter *TreeIter) string {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_get_string_from_iter(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (t treeModel) Value(iter *TreeIter, column int) externglib.Value {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.int           // out
	var _arg3 C.GValue        // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.int)(column)

	C.gtk_tree_model_get_value(_arg0, _arg1, _arg2, &_arg3)

	var _value externglib.Value // out

	_value = *externglib.ValueFromNative(unsafe.Pointer(&_arg3))

	return _value
}

func (t treeModel) IterChildren(parent *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_tree_model_iter_children(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (t treeModel) IterHasChild(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_iter_has_child(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeModel) IterNChildren(iter *TreeIter) int {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.int           // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_iter_n_children(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeModel) IterNext(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_iter_next(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeModel) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (C.int)(n)

	_cret = C.gtk_tree_model_iter_nth_child(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (t treeModel) IterParent(child *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_tree_model_iter_parent(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (t treeModel) IterPrevious(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_iter_previous(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeModel) RefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_ref_node(_arg0, _arg1)
}

func (t treeModel) RowChanged(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_row_changed(_arg0, _arg1, _arg2)
}

func (t treeModel) RowDeleted(path *TreePath) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_model_row_deleted(_arg0, _arg1)
}

func (t treeModel) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_row_has_child_toggled(_arg0, _arg1, _arg2)
}

func (t treeModel) RowInserted(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_row_inserted(_arg0, _arg1, _arg2)
}

func (t treeModel) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 *C.int
	var _arg4 C.int

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg4 = C.int(len(newOrder))
	_arg3 = (*C.int)(unsafe.Pointer(&newOrder[0]))

	C.gtk_tree_model_rows_reordered_with_length(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (t treeModel) UnrefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_unref_node(_arg0, _arg1)
}

// TreeSortableOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeSortable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TreeSortableOverrider interface {
	// SortColumnID fills in @sort_column_id and @order with the current sort
	// column and the order. It returns true unless the @sort_column_id is
	// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
	// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
	SortColumnID() (int, SortType, bool)
	// HasDefaultSortFunc returns true if the model has a default sort function.
	// This is used primarily by GtkTreeViewColumns in order to determine if a
	// model can go back to the default state, or not.
	HasDefaultSortFunc() bool
	// SetSortColumnID sets the current sort column to be @sort_column_id. The
	// @sortable will resort itself to reflect this change, after emitting a
	// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
	// regular column id, or one of the following special values:
	//
	// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function
	// will be used, if it is set
	//
	// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
	SetSortColumnID(sortColumnId int, order SortType)
	// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
	// @sortable.
	SortColumnChanged()
}

// TreeSortable: the interface for sortable models used by GtkTreeView
//
// TreeSortable is an interface to be implemented by tree models which support
// sorting. The TreeView uses the methods provided by this interface to sort the
// model.
type TreeSortable interface {

	// SortColumnID fills in @sort_column_id and @order with the current sort
	// column and the order. It returns true unless the @sort_column_id is
	// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
	// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
	SortColumnID() (int, SortType, bool)
	// HasDefaultSortFunc returns true if the model has a default sort function.
	// This is used primarily by GtkTreeViewColumns in order to determine if a
	// model can go back to the default state, or not.
	HasDefaultSortFunc() bool
	// SetSortColumnID sets the current sort column to be @sort_column_id. The
	// @sortable will resort itself to reflect this change, after emitting a
	// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
	// regular column id, or one of the following special values:
	//
	// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function
	// will be used, if it is set
	//
	// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
	SetSortColumnID(sortColumnId int, order SortType)
	// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
	// @sortable.
	SortColumnChanged()
}

// treeSortable implements the TreeSortable interface.
type treeSortable struct {
}

var _ TreeSortable = (*treeSortable)(nil)

// WrapTreeSortable wraps a GObject to a type that implements
// interface TreeSortable. It is primarily used internally.
func WrapTreeSortable(obj *externglib.Object) TreeSortable {
	return treeSortable{
		TreeModel: WrapTreeModel(obj),
	}
}

func marshalTreeSortable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeSortable(obj), nil
}

func (s treeSortable) SortColumnID() (int, SortType, bool) {
	var _arg0 *C.GtkTreeSortable // out
	var _arg1 C.int              // in
	var _arg2 C.GtkSortType      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_sortable_get_sort_column_id(_arg0, &_arg1, &_arg2)

	var _sortColumnId int // out
	var _order SortType   // out
	var _ok bool          // out

	_sortColumnId = (int)(_arg1)
	_order = SortType(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _sortColumnId, _order, _ok
}

func (s treeSortable) HasDefaultSortFunc() bool {
	var _arg0 *C.GtkTreeSortable // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_sortable_has_default_sort_func(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s treeSortable) SetSortColumnID(sortColumnId int, order SortType) {
	var _arg0 *C.GtkTreeSortable // out
	var _arg1 C.int              // out
	var _arg2 C.GtkSortType      // out

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(sortColumnId)
	_arg2 = (C.GtkSortType)(order)

	C.gtk_tree_sortable_set_sort_column_id(_arg0, _arg1, _arg2)
}

func (s treeSortable) SortColumnChanged() {
	var _arg0 *C.GtkTreeSortable // out

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

	C.gtk_tree_sortable_sort_column_changed(_arg0)
}

// ATContext: `GtkATContext` is an abstract class provided by GTK to communicate
// to platform-specific assistive technologies API.
//
// Each platform supported by GTK implements a `GtkATContext` subclass, and is
// responsible for updating the accessible state in response to state changes in
// `GtkAccessible`.
type ATContext interface {

	// Accessible retrieves the `GtkAccessible` using this context.
	Accessible() Accessible
	// AccessibleRole retrieves the accessible role of this context.
	AccessibleRole() AccessibleRole
}

// atContext implements the ATContext class.
type atContext struct {
	gextras.Objector
}

// WrapATContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapATContext(obj *externglib.Object) ATContext {
	return atContext{
		Objector: obj,
	}
}

func marshalATContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapATContext(obj), nil
}

// NewATContextCreate creates a new `GtkATContext` instance for the given
// accessible role, accessible instance, and display connection.
//
// The `GtkATContext` implementation being instantiated will depend on the
// platform.
func NewATContextCreate(accessibleRole AccessibleRole, accessible Accessible, display gdk.Display) ATContext {
	var _arg1 C.GtkAccessibleRole // out
	var _arg2 *C.GtkAccessible    // out
	var _arg3 *C.GdkDisplay       // out
	var _cret *C.GtkATContext     // in

	_arg1 = (C.GtkAccessibleRole)(accessibleRole)
	_arg2 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
	_arg3 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	_cret = C.gtk_at_context_create(_arg1, _arg2, _arg3)

	var _atContext ATContext // out

	_atContext = WrapATContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _atContext
}

func (s atContext) Accessible() Accessible {
	var _arg0 *C.GtkATContext  // out
	var _cret *C.GtkAccessible // in

	_arg0 = (*C.GtkATContext)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_at_context_get_accessible(_arg0)

	var _accessible Accessible // out

	_accessible = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Accessible)

	return _accessible
}

func (s atContext) AccessibleRole() AccessibleRole {
	var _arg0 *C.GtkATContext     // out
	var _cret C.GtkAccessibleRole // in

	_arg0 = (*C.GtkATContext)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_at_context_get_accessible_role(_arg0)

	var _accessibleRole AccessibleRole // out

	_accessibleRole = AccessibleRole(_cret)

	return _accessibleRole
}

// AboutDialog: the `GtkAboutDialog` offers a simple way to display information
// about a program.
//
// The shown information includes the programs' logo, name, copyright, website
// and license. It is also possible to give credits to the authors, documenters,
// translators and artists who have worked on the program.
//
// An about dialog is typically opened when the user selects the `About` option
// from the `Help` menu. All parts of the dialog are optional.
//
// !An example GtkAboutDialog (aboutdialog.png)
//
// About dialogs often contain links and email addresses. `GtkAboutDialog`
// displays these as clickable links. By default, it calls [func@Gtk.show_uri]
// when a user clicks one. The behaviour can be overridden with the
// [signal@Gtk.AboutDialog::activate-link] signal.
//
// To specify a person with an email address, use a string like `Edgar Allan Poe
// <edgar@poe.com>`. To specify a website with a title, use a string like `GTK
// team https://www.gtk.org`.
//
// To make constructing a `GtkAboutDialog` as convenient as possible, you can
// use the function [func@Gtk.show_about_dialog] which constructs and shows a
// dialog and keeps it around so that it can be shown again.
//
// Note that GTK sets a default title of `_("About s")` on the dialog window
// (where `s` is replaced by the name of the application, but in order to ensure
// proper translation of the title, applications should set the title property
// explicitly when constructing a `GtkAboutDialog`, as shown in the following
// example:
//
// `c GFile *logo_file = g_file_new_for_path ("./logo.png"); GdkTexture
// *example_logo = gdk_texture_new_from_file (logo_file, NULL); g_object_unref
// (logo_file);
//
// gtk_show_about_dialog (NULL, "program-name", "ExampleCode", "logo",
// example_logo, "title", _("About ExampleCode"), NULL); `
//
//
// CSS nodes
//
// `GtkAboutDialog` has a single CSS node with the name `window` and style class
// `.aboutdialog`.
type AboutDialog interface {
	Window

	// AddCreditSectionAboutDialog creates a new section in the "Credits" page.
	AddCreditSectionAboutDialog(sectionName string, people []string)
	// Artists returns the string which are displayed in the "Artists" tab of
	// the secondary credits dialog.
	Artists() []string
	// Authors returns the string which are displayed in the authors tab of the
	// secondary credits dialog.
	Authors() []string
	// Comments returns the comments string.
	Comments() string
	// Copyright returns the copyright string.
	Copyright() string
	// Documenters returns the string which are displayed in the "Documenters"
	// tab of the secondary credits dialog.
	Documenters() []string
	// License returns the license information.
	License() string
	// LicenseType retrieves the license type.
	LicenseType() License
	// Logo returns the paintable displayed as logo in the about dialog.
	Logo() gdk.Paintable
	// LogoIconName returns the icon name displayed as logo in the about dialog.
	LogoIconName() string
	// ProgramName returns the program name displayed in the about dialog.
	ProgramName() string
	// SystemInformation returns the system information that is shown in the
	// about dialog.
	SystemInformation() string
	// TranslatorCredits returns the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	TranslatorCredits() string
	// Version returns the version string.
	Version() string
	// Website returns the website URL.
	Website() string
	// WebsiteLabel returns the label used for the website link.
	WebsiteLabel() string
	// WrapLicense returns whether the license text in the about dialog is
	// automatically wrapped.
	WrapLicense() bool
	// SetArtistsAboutDialog sets the strings which are displayed in the
	// "Artists" tab of the secondary credits dialog.
	SetArtistsAboutDialog(artists []string)
	// SetAuthorsAboutDialog sets the strings which are displayed in the
	// "Authors" tab of the secondary credits dialog.
	SetAuthorsAboutDialog(authors []string)
	// SetCommentsAboutDialog sets the comments string to display in the about
	// dialog.
	//
	// This should be a short string of one or two lines.
	SetCommentsAboutDialog(comments string)
	// SetCopyrightAboutDialog sets the copyright string to display in the about
	// dialog.
	//
	// This should be a short string of one or two lines.
	SetCopyrightAboutDialog(copyright string)
	// SetDocumentersAboutDialog sets the strings which are displayed in the
	// "Documenters" tab of the credits dialog.
	SetDocumentersAboutDialog(documenters []string)
	// SetLicenseAboutDialog sets the license information to be displayed in the
	// secondary license dialog.
	//
	// If `license` is `NULL`, the license button is hidden.
	SetLicenseAboutDialog(license string)
	// SetLicenseTypeAboutDialog sets the license of the application showing the
	// about dialog from a list of known licenses.
	//
	// This function overrides the license set using
	// [method@Gtk.AboutDialog.set_license].
	SetLicenseTypeAboutDialog(licenseType License)
	// SetLogoAboutDialog sets the logo in the about dialog.
	SetLogoAboutDialog(logo gdk.Paintable)
	// SetLogoIconNameAboutDialog sets the icon name to be displayed as logo in
	// the about dialog.
	SetLogoIconNameAboutDialog(iconName string)
	// SetProgramNameAboutDialog sets the name to display in the about dialog.
	//
	// If `name` is not set, it defaults to `g_get_application_name()`.
	SetProgramNameAboutDialog(name string)
	// SetSystemInformationAboutDialog sets the system information to be
	// displayed in the about dialog.
	//
	// If `system_information` is `NULL`, the system information tab is hidden.
	//
	// See [property@Gtk.AboutDialog:system-information].
	SetSystemInformationAboutDialog(systemInformation string)
	// SetTranslatorCreditsAboutDialog sets the translator credits string which
	// is displayed in the translators tab of the secondary credits dialog.
	//
	// The intended use for this string is to display the translator of the
	// language which is currently used in the user interface. Using
	// `gettext()`, a simple way to achieve that is to mark the string for
	// translation:
	//
	// `c GtkWidget *about = gtk_about_dialog_new ();
	// gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
	// _("translator-credits")); `
	//
	// It is a good idea to use the customary `msgid` translator-credits for
	// this purpose, since translators will already know the purpose of that
	// `msgid`, and since `GtkAboutDialog` will detect if translator-credits
	// is untranslated and hide the tab.
	SetTranslatorCreditsAboutDialog(translatorCredits string)
	// SetVersionAboutDialog sets the version string to display in the about
	// dialog.
	SetVersionAboutDialog(version string)
	// SetWebsiteAboutDialog sets the URL to use for the website link.
	SetWebsiteAboutDialog(website string)
	// SetWebsiteLabelAboutDialog sets the label to be used for the website
	// link.
	SetWebsiteLabelAboutDialog(websiteLabel string)
	// SetWrapLicenseAboutDialog sets whether the license text in the about
	// dialog should be automatically wrapped.
	SetWrapLicenseAboutDialog(wrapLicense bool)
}

// aboutDialog implements the AboutDialog class.
type aboutDialog struct {
	Window
}

// WrapAboutDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAboutDialog(obj *externglib.Object) AboutDialog {
	return aboutDialog{
		Window: WrapWindow(obj),
	}
}

func marshalAboutDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAboutDialog(obj), nil
}

// NewAboutDialog creates a new `GtkAboutDialog`.
func NewAboutDialog() AboutDialog {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_about_dialog_new()

	var _aboutDialog AboutDialog // out

	_aboutDialog = WrapAboutDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _aboutDialog
}

func (a aboutDialog) AddCreditSectionAboutDialog(sectionName string, people []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out
	var _arg2 **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(sectionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.char)(C.malloc(C.ulong(len(people)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(people))
		for i := range people {
			out[i] = (*C.char)(C.CString(people[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_about_dialog_add_credit_section(_arg0, _arg1, _arg2)
}

func (a aboutDialog) Artists() []string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_artists(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (a aboutDialog) Authors() []string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_authors(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (a aboutDialog) Comments() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_comments(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) Copyright() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_copyright(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) Documenters() []string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_documenters(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (a aboutDialog) License() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_license(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) LicenseType() License {
	var _arg0 *C.GtkAboutDialog // out
	var _cret C.GtkLicense      // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_license_type(_arg0)

	var _license License // out

	_license = License(_cret)

	return _license
}

func (a aboutDialog) Logo() gdk.Paintable {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.GdkPaintable   // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_logo(_arg0)

	var _paintable gdk.Paintable // out

	_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

	return _paintable
}

func (a aboutDialog) LogoIconName() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_logo_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) ProgramName() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_program_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) SystemInformation() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_system_information(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) TranslatorCredits() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_translator_credits(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) Version() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_version(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) Website() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_website(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) WebsiteLabel() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_website_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a aboutDialog) WrapLicense() bool {
	var _arg0 *C.GtkAboutDialog // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_wrap_license(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a aboutDialog) SetArtistsAboutDialog(artists []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (**C.char)(C.malloc(C.ulong(len(artists)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(artists))
		for i := range artists {
			out[i] = (*C.char)(C.CString(artists[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_about_dialog_set_artists(_arg0, _arg1)
}

func (a aboutDialog) SetAuthorsAboutDialog(authors []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (**C.char)(C.malloc(C.ulong(len(authors)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(authors))
		for i := range authors {
			out[i] = (*C.char)(C.CString(authors[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_about_dialog_set_authors(_arg0, _arg1)
}

func (a aboutDialog) SetCommentsAboutDialog(comments string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(comments))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_comments(_arg0, _arg1)
}

func (a aboutDialog) SetCopyrightAboutDialog(copyright string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(copyright))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_copyright(_arg0, _arg1)
}

func (a aboutDialog) SetDocumentersAboutDialog(documenters []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (**C.char)(C.malloc(C.ulong(len(documenters)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(documenters))
		for i := range documenters {
			out[i] = (*C.char)(C.CString(documenters[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_about_dialog_set_documenters(_arg0, _arg1)
}

func (a aboutDialog) SetLicenseAboutDialog(license string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(license))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_license(_arg0, _arg1)
}

func (a aboutDialog) SetLicenseTypeAboutDialog(licenseType License) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 C.GtkLicense      // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (C.GtkLicense)(licenseType)

	C.gtk_about_dialog_set_license_type(_arg0, _arg1)
}

func (a aboutDialog) SetLogoAboutDialog(logo gdk.Paintable) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.GdkPaintable   // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(logo.Native()))

	C.gtk_about_dialog_set_logo(_arg0, _arg1)
}

func (a aboutDialog) SetLogoIconNameAboutDialog(iconName string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_logo_icon_name(_arg0, _arg1)
}

func (a aboutDialog) SetProgramNameAboutDialog(name string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_program_name(_arg0, _arg1)
}

func (a aboutDialog) SetSystemInformationAboutDialog(systemInformation string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(systemInformation))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_system_information(_arg0, _arg1)
}

func (a aboutDialog) SetTranslatorCreditsAboutDialog(translatorCredits string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(translatorCredits))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_translator_credits(_arg0, _arg1)
}

func (a aboutDialog) SetVersionAboutDialog(version string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(version))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_version(_arg0, _arg1)
}

func (a aboutDialog) SetWebsiteAboutDialog(website string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(website))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_website(_arg0, _arg1)
}

func (a aboutDialog) SetWebsiteLabelAboutDialog(websiteLabel string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(websiteLabel))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_website_label(_arg0, _arg1)
}

func (a aboutDialog) SetWrapLicenseAboutDialog(wrapLicense bool) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	if wrapLicense {
		_arg1 = C.TRUE
	}

	C.gtk_about_dialog_set_wrap_license(_arg0, _arg1)
}

func (s aboutDialog) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s aboutDialog) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s aboutDialog) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s aboutDialog) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s aboutDialog) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s aboutDialog) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s aboutDialog) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b aboutDialog) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s aboutDialog) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s aboutDialog) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s aboutDialog) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s aboutDialog) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s aboutDialog) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s aboutDialog) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s aboutDialog) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s aboutDialog) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// ActionBar: `GtkActionBar` is designed to present contextual actions.
//
// !An example GtkActionBar (action-bar.png)
//
// It is expected to be displayed below the content and expand horizontally to
// fill the area.
//
// It allows placing children at the start or the end. In addition, it contains
// an internal centered box which is centered with respect to the full width of
// the box, even if the children at either side take up different amounts of
// space.
//
//
// CSS nodes
//
// `GtkActionBar` has a single CSS node with name actionbar.
type ActionBar interface {
	Widget

	// CenterWidget retrieves the center bar widget of the bar.
	CenterWidget() Widget
	// Revealed gets whether the contents of the action bar are revealed.
	Revealed() bool
	// PackEndActionBar adds @child to @action_bar, packed with reference to the
	// end of the @action_bar.
	PackEndActionBar(child Widget)
	// PackStartActionBar adds @child to @action_bar, packed with reference to
	// the start of the @action_bar.
	PackStartActionBar(child Widget)
	// RemoveActionBar removes a child from @action_bar.
	RemoveActionBar(child Widget)
	// SetCenterWidgetActionBar sets the center widget for the `GtkActionBar`.
	SetCenterWidgetActionBar(centerWidget Widget)
	// SetRevealedActionBar reveals or conceals the content of the action bar.
	//
	// Note: this does not show or hide @action_bar in the
	// [property@Gtk.Widget:visible] sense, so revealing has no effect if the
	// action bar is hidden.
	SetRevealedActionBar(revealed bool)
}

// actionBar implements the ActionBar class.
type actionBar struct {
	Widget
}

// WrapActionBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapActionBar(obj *externglib.Object) ActionBar {
	return actionBar{
		Widget: WrapWidget(obj),
	}
}

func marshalActionBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionBar(obj), nil
}

// NewActionBar creates a new `GtkActionBar` widget.
func NewActionBar() ActionBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_action_bar_new()

	var _actionBar ActionBar // out

	_actionBar = WrapActionBar(externglib.Take(unsafe.Pointer(_cret)))

	return _actionBar
}

func (a actionBar) CenterWidget() Widget {
	var _arg0 *C.GtkActionBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_bar_get_center_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (a actionBar) Revealed() bool {
	var _arg0 *C.GtkActionBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_bar_get_revealed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a actionBar) PackEndActionBar(child Widget) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_pack_end(_arg0, _arg1)
}

func (a actionBar) PackStartActionBar(child Widget) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_pack_start(_arg0, _arg1)
}

func (a actionBar) RemoveActionBar(child Widget) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_remove(_arg0, _arg1)
}

func (a actionBar) SetCenterWidgetActionBar(centerWidget Widget) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(centerWidget.Native()))

	C.gtk_action_bar_set_center_widget(_arg0, _arg1)
}

func (a actionBar) SetRevealedActionBar(revealed bool) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	if revealed {
		_arg1 = C.TRUE
	}

	C.gtk_action_bar_set_revealed(_arg0, _arg1)
}

func (s actionBar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s actionBar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s actionBar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s actionBar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s actionBar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s actionBar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s actionBar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b actionBar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// ActivateAction: a `GtkShortcutAction` that calls gtk_widget_activate().
type ActivateAction interface {
}

// activateAction implements the ActivateAction class.
type activateAction struct {
	ShortcutAction
}

// WrapActivateAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapActivateAction(obj *externglib.Object) ActivateAction {
	return activateAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalActivateAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActivateAction(obj), nil
}

// Adjustment: `GtkAdjustment` is a model for a numeric value.
//
// The `GtkAdjustment has an associated lower and upper bound. It also contains
// step and page increments, and a page size.
//
// Adjustments are used within several GTK widgets, including
// [class@Gtk.SpinButton], [class@Gtk.Viewport], [class@Gtk.Scrollbar] and
// [class@Gtk.Scale].
//
// The `GtkAdjustment` object does not update the value itself. Instead it is
// left up to the owner of the `GtkAdjustment` to control the value.
type Adjustment interface {

	// ClampPageAdjustment updates the value property to ensure that the range
	// between @lower and @upper is in the current page.
	//
	// The current page goes from `value` to `value` + `page-size`. If the range
	// is larger than the page size, then only the start of it will be in the
	// current page.
	//
	// A [signal@Gtk.Adjustment::value-changed] signal will be emitted if the
	// value is changed.
	ClampPageAdjustment(lower float64, upper float64)
	// ConfigureAdjustment sets all properties of the adjustment at once.
	//
	// Use this function to avoid multiple emissions of the
	// [signal@Gtk.Adjustment::changed] signal. See
	// [method@Gtk.Adjustment.set_lower] for an alternative way of compressing
	// multiple emissions of [signal@Gtk.Adjustment::changed] into one.
	ConfigureAdjustment(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64)
	// Lower retrieves the minimum value of the adjustment.
	Lower() float64
	// MinimumIncrement gets the smaller of step increment and page increment.
	MinimumIncrement() float64
	// PageIncrement retrieves the page increment of the adjustment.
	PageIncrement() float64
	// PageSize retrieves the page size of the adjustment.
	PageSize() float64
	// StepIncrement retrieves the step increment of the adjustment.
	StepIncrement() float64
	// Upper retrieves the maximum value of the adjustment.
	Upper() float64
	// Value gets the current value of the adjustment.
	Value() float64
	// SetLowerAdjustment sets the minimum value of the adjustment.
	//
	// When setting multiple adjustment properties via their individual setters,
	// multiple [signal@Gtk.Adjustment::changed] signals will be emitted.
	// However, since the emission of the [signal@Gtk.Adjustment::changed]
	// signal is tied to the emission of the ::notify signals of the changed
	// properties, its possible to compress the
	// [signal@Gtk.Adjustment::changed] signals into one by calling
	// g_object_freeze_notify() and g_object_thaw_notify() around the calls to
	// the individual setters.
	//
	// Alternatively, using a single g_object_set() for all the properties to
	// change, or using [method@Gtk.Adjustment.configure] has the same effect.
	SetLowerAdjustment(lower float64)
	// SetPageIncrementAdjustment sets the page increment of the adjustment.
	//
	// See [method@Gtk.Adjustment.set_lower] about how to compress multiple
	// emissions of the [signal@Gtk.Adjustment::changed] signal when setting
	// multiple adjustment properties.
	SetPageIncrementAdjustment(pageIncrement float64)
	// SetPageSizeAdjustment sets the page size of the adjustment.
	//
	// See [method@Gtk.Adjustment.set_lower] about how to compress multiple
	// emissions of the [signal@Gtk.Adjustment::changed] signal when setting
	// multiple adjustment properties.
	SetPageSizeAdjustment(pageSize float64)
	// SetStepIncrementAdjustment sets the step increment of the adjustment.
	//
	// See [method@Gtk.Adjustment.set_lower] about how to compress multiple
	// emissions of the [signal@Gtk.Adjustment::changed] signal when setting
	// multiple adjustment properties.
	SetStepIncrementAdjustment(stepIncrement float64)
	// SetUpperAdjustment sets the maximum value of the adjustment.
	//
	// Note that values will be restricted by `upper - page-size` if the
	// page-size property is nonzero.
	//
	// See [method@Gtk.Adjustment.set_lower] about how to compress multiple
	// emissions of the [signal@Gtk.Adjustment::changed] signal when setting
	// multiple adjustment properties.
	SetUpperAdjustment(upper float64)
	// SetValueAdjustment sets the `GtkAdjustment` value.
	//
	// The value is clamped to lie between [property@Gtk.Adjustment:lower] and
	// [property@Gtk.Adjustment:upper].
	//
	// Note that for adjustments which are used in a `GtkScrollbar`, the
	// effective range of allowed values goes from
	// [property@Gtk.Adjustment:lower] to [property@Gtk.Adjustment:upper] -
	// [property@Gtk.Adjustment:page-size].
	SetValueAdjustment(value float64)
}

// adjustment implements the Adjustment class.
type adjustment struct {
	gextras.Objector
}

// WrapAdjustment wraps a GObject to the right type. It is
// primarily used internally.
func WrapAdjustment(obj *externglib.Object) Adjustment {
	return adjustment{
		Objector: obj,
	}
}

func marshalAdjustment(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAdjustment(obj), nil
}

// NewAdjustment creates a new `GtkAdjustment`.
func NewAdjustment(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) Adjustment {
	var _arg1 C.double         // out
	var _arg2 C.double         // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out
	var _arg5 C.double         // out
	var _arg6 C.double         // out
	var _cret *C.GtkAdjustment // in

	_arg1 = (C.double)(value)
	_arg2 = (C.double)(lower)
	_arg3 = (C.double)(upper)
	_arg4 = (C.double)(stepIncrement)
	_arg5 = (C.double)(pageIncrement)
	_arg6 = (C.double)(pageSize)

	_cret = C.gtk_adjustment_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _adjustment Adjustment // out

	_adjustment = WrapAdjustment(externglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

func (a adjustment) ClampPageAdjustment(lower float64, upper float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out
	var _arg2 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.double)(lower)
	_arg2 = (C.double)(upper)

	C.gtk_adjustment_clamp_page(_arg0, _arg1, _arg2)
}

func (a adjustment) ConfigureAdjustment(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out
	var _arg2 C.double         // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out
	var _arg5 C.double         // out
	var _arg6 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.double)(value)
	_arg2 = (C.double)(lower)
	_arg3 = (C.double)(upper)
	_arg4 = (C.double)(stepIncrement)
	_arg5 = (C.double)(pageIncrement)
	_arg6 = (C.double)(pageSize)

	C.gtk_adjustment_configure(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (a adjustment) Lower() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_lower(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (a adjustment) MinimumIncrement() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_minimum_increment(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (a adjustment) PageIncrement() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_page_increment(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (a adjustment) PageSize() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_page_size(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (a adjustment) StepIncrement() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_step_increment(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (a adjustment) Upper() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_upper(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (a adjustment) Value() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (a adjustment) SetLowerAdjustment(lower float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.double)(lower)

	C.gtk_adjustment_set_lower(_arg0, _arg1)
}

func (a adjustment) SetPageIncrementAdjustment(pageIncrement float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.double)(pageIncrement)

	C.gtk_adjustment_set_page_increment(_arg0, _arg1)
}

func (a adjustment) SetPageSizeAdjustment(pageSize float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.double)(pageSize)

	C.gtk_adjustment_set_page_size(_arg0, _arg1)
}

func (a adjustment) SetStepIncrementAdjustment(stepIncrement float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.double)(stepIncrement)

	C.gtk_adjustment_set_step_increment(_arg0, _arg1)
}

func (a adjustment) SetUpperAdjustment(upper float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.double)(upper)

	C.gtk_adjustment_set_upper(_arg0, _arg1)
}

func (a adjustment) SetValueAdjustment(value float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.double)(value)

	C.gtk_adjustment_set_value(_arg0, _arg1)
}

// AlternativeTrigger: a `GtkShortcutTrigger` that combines two triggers.
//
// The `GtkAlternativeTrigger` triggers when either of two trigger.
//
// This can be cascaded to combine more than two triggers.
type AlternativeTrigger interface {

	// First gets the first of the two alternative triggers that may trigger
	// @self.
	//
	// [method@Gtk.AlternativeTrigger.get_second] will return the other one.
	First() ShortcutTrigger
	// Second gets the second of the two alternative triggers that may trigger
	// @self.
	//
	// [method@Gtk.AlternativeTrigger.get_first] will return the other one.
	Second() ShortcutTrigger
}

// alternativeTrigger implements the AlternativeTrigger class.
type alternativeTrigger struct {
	ShortcutTrigger
}

// WrapAlternativeTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapAlternativeTrigger(obj *externglib.Object) AlternativeTrigger {
	return alternativeTrigger{
		ShortcutTrigger: WrapShortcutTrigger(obj),
	}
}

func marshalAlternativeTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAlternativeTrigger(obj), nil
}

// NewAlternativeTrigger creates a `GtkShortcutTrigger` that will trigger
// whenever either of the two given triggers gets triggered.
//
// Note that nesting is allowed, so if you want more than two alternative,
// create a new alternative trigger for each option.
func NewAlternativeTrigger(first ShortcutTrigger, second ShortcutTrigger) AlternativeTrigger {
	var _arg1 *C.GtkShortcutTrigger // out
	var _arg2 *C.GtkShortcutTrigger // out
	var _cret *C.GtkShortcutTrigger // in

	_arg1 = (*C.GtkShortcutTrigger)(unsafe.Pointer(first.Native()))
	_arg2 = (*C.GtkShortcutTrigger)(unsafe.Pointer(second.Native()))

	_cret = C.gtk_alternative_trigger_new(_arg1, _arg2)

	var _alternativeTrigger AlternativeTrigger // out

	_alternativeTrigger = WrapAlternativeTrigger(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _alternativeTrigger
}

func (s alternativeTrigger) First() ShortcutTrigger {
	var _arg0 *C.GtkAlternativeTrigger // out
	var _cret *C.GtkShortcutTrigger    // in

	_arg0 = (*C.GtkAlternativeTrigger)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_alternative_trigger_get_first(_arg0)

	var _shortcutTrigger ShortcutTrigger // out

	_shortcutTrigger = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutTrigger)

	return _shortcutTrigger
}

func (s alternativeTrigger) Second() ShortcutTrigger {
	var _arg0 *C.GtkAlternativeTrigger // out
	var _cret *C.GtkShortcutTrigger    // in

	_arg0 = (*C.GtkAlternativeTrigger)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_alternative_trigger_get_second(_arg0)

	var _shortcutTrigger ShortcutTrigger // out

	_shortcutTrigger = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutTrigger)

	return _shortcutTrigger
}

// AnyFilter: `GtkAnyFilter` matches an item when at least one of its filters
// matches.
//
// To add filters to a `GtkAnyFilter`, use [method@Gtk.MultiFilter.append].
type AnyFilter interface {
	MultiFilter
}

// anyFilter implements the AnyFilter class.
type anyFilter struct {
	MultiFilter
}

// WrapAnyFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapAnyFilter(obj *externglib.Object) AnyFilter {
	return anyFilter{
		MultiFilter: WrapMultiFilter(obj),
	}
}

func marshalAnyFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAnyFilter(obj), nil
}

// NewAnyFilter creates a new empty "any" filter.
//
// Use [method@Gtk.MultiFilter.append] to add filters to it.
//
// This filter matches an item if any of the filters added to it matches the
// item. In particular, this means that if no filter has been added to it, the
// filter matches no item.
func NewAnyFilter() AnyFilter {
	var _cret *C.GtkAnyFilter // in

	_cret = C.gtk_any_filter_new()

	var _anyFilter AnyFilter // out

	_anyFilter = WrapAnyFilter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _anyFilter
}

func (b anyFilter) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// AppChooserButton: the `GtkAppChooserButton` lets the user select an
// application.
//
// !An example GtkAppChooserButton (appchooserbutton.png)
//
// Initially, a `GtkAppChooserButton` selects the first application in its list,
// which will either be the most-recently used application or, if
// [property@Gtk.AppChooserButton:show-default-item] is true, the default
// application.
//
// The list of applications shown in a `GtkAppChooserButton` includes the
// recommended applications for the given content type. When
// [property@Gtk.AppChooserButton:show-default-item] is set, the default
// application is also included. To let the user chooser other applications, you
// can set the [property@Gtk.AppChooserButton:show-dialog-item] property, which
// allows to open a full [class@Gtk.AppChooserDialog].
//
// It is possible to add custom items to the list, using
// [method@Gtk.AppChooserButton.append_custom_item]. These items cause the
// [signal@Gtk.AppChooserButton::custom-item-activated] signal to be emitted
// when they are selected.
//
// To track changes in the selected application, use the
// [signal@Gtk.AppChooserButton::changed] signal.
//
//
// CSS nodes
//
// `GtkAppChooserButton` has a single CSS node with the name appchooserbutton.
type AppChooserButton interface {
	AppChooser

	// AppendCustomItemAppChooserButton appends a custom item to the list of
	// applications that is shown in the popup.
	//
	// The item name must be unique per-widget. Clients can use the provided
	// name as a detail for the
	// [signal@Gtk.AppChooserButton::custom-item-activated] signal, to add a
	// callback for the activation of a particular custom item in the list.
	//
	// See also [method@Gtk.AppChooserButton.append_separator].
	AppendCustomItemAppChooserButton(name string, label string, icon gio.Icon)
	// AppendSeparatorAppChooserButton appends a separator to the list of
	// applications that is shown in the popup.
	AppendSeparatorAppChooserButton()
	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// Modal gets whether the dialog is modal.
	Modal() bool
	// ShowDefaultItem returns whether the dropdown menu should show the default
	// application at the top.
	ShowDefaultItem() bool
	// ShowDialogItem returns whether the dropdown menu shows an item for a
	// `GtkAppChooserDialog`.
	ShowDialogItem() bool
	// SetActiveCustomItemAppChooserButton selects a custom item.
	//
	// See [method@Gtk.AppChooserButton.append_custom_item].
	//
	// Use [method@Gtk.AppChooser.refresh] to bring the selection to its initial
	// state.
	SetActiveCustomItemAppChooserButton(name string)
	// SetHeadingAppChooserButton sets the text to display at the top of the
	// dialog.
	//
	// If the heading is not set, the dialog displays a default text.
	SetHeadingAppChooserButton(heading string)
	// SetModalAppChooserButton sets whether the dialog should be modal.
	SetModalAppChooserButton(modal bool)
	// SetShowDefaultItemAppChooserButton sets whether the dropdown menu of this
	// button should show the default application for the given content type at
	// top.
	SetShowDefaultItemAppChooserButton(setting bool)
	// SetShowDialogItemAppChooserButton sets whether the dropdown menu of this
	// button should show an entry to trigger a `GtkAppChooserDialog`.
	SetShowDialogItemAppChooserButton(setting bool)
}

// appChooserButton implements the AppChooserButton class.
type appChooserButton struct {
	Widget
}

// WrapAppChooserButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserButton(obj *externglib.Object) AppChooserButton {
	return appChooserButton{
		Widget: WrapWidget(obj),
	}
}

func marshalAppChooserButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserButton(obj), nil
}

// NewAppChooserButton creates a new `GtkAppChooserButton` for applications that
// can handle content of the given type.
func NewAppChooserButton(contentType string) AppChooserButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_app_chooser_button_new(_arg1)

	var _appChooserButton AppChooserButton // out

	_appChooserButton = WrapAppChooserButton(externglib.Take(unsafe.Pointer(_cret)))

	return _appChooserButton
}

func (s appChooserButton) AppendCustomItemAppChooserButton(name string, label string, icon gio.Icon) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 *C.char                // out
	var _arg2 *C.char                // out
	var _arg3 *C.GIcon               // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_app_chooser_button_append_custom_item(_arg0, _arg1, _arg2, _arg3)
}

func (s appChooserButton) AppendSeparatorAppChooserButton() {
	var _arg0 *C.GtkAppChooserButton // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_button_append_separator(_arg0)
}

func (s appChooserButton) Heading() string {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_button_get_heading(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s appChooserButton) Modal() bool {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_button_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s appChooserButton) ShowDefaultItem() bool {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_button_get_show_default_item(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s appChooserButton) ShowDialogItem() bool {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_button_get_show_dialog_item(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s appChooserButton) SetActiveCustomItemAppChooserButton(name string) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_button_set_active_custom_item(_arg0, _arg1)
}

func (s appChooserButton) SetHeadingAppChooserButton(heading string) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(heading))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_button_set_heading(_arg0, _arg1)
}

func (s appChooserButton) SetModalAppChooserButton(modal bool) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_button_set_modal(_arg0, _arg1)
}

func (s appChooserButton) SetShowDefaultItemAppChooserButton(setting bool) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_button_set_show_default_item(_arg0, _arg1)
}

func (s appChooserButton) SetShowDialogItemAppChooserButton(setting bool) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_button_set_show_dialog_item(_arg0, _arg1)
}

func (s appChooserButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s appChooserButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s appChooserButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s appChooserButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s appChooserButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s appChooserButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s appChooserButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (s appChooserButton) AppInfo() gio.AppInfo {
	return WrapAppChooser(gextras.InternObject(s)).AppInfo()
}

func (s appChooserButton) ContentType() string {
	return WrapAppChooser(gextras.InternObject(s)).ContentType()
}

func (s appChooserButton) Refresh() {
	WrapAppChooser(gextras.InternObject(s)).Refresh()
}

func (b appChooserButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// AppChooserDialog: `GtkAppChooserDialog` shows a `GtkAppChooserWidget` inside
// a `GtkDialog`.
//
// !An example GtkAppChooserDialog (appchooserdialog.png)
//
// Note that `GtkAppChooserDialog` does not have any interesting methods of its
// own. Instead, you should get the embedded `GtkAppChooserWidget` using
// [method@Gtk.AppChooserDialog.get_widget] and call its methods if the generic
// [iface@Gtk.AppChooser] interface is not sufficient for your needs.
//
// To set the heading that is shown above the `GtkAppChooserWidget`, use
// [method@Gtk.AppChooserDialog.set_heading].
type AppChooserDialog interface {
	Dialog
	AppChooser

	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// Widget returns the `GtkAppChooserWidget` of this dialog.
	Widget() Widget
	// SetHeadingAppChooserDialog sets the text to display at the top of the
	// dialog.
	//
	// If the heading is not set, the dialog displays a default text.
	SetHeadingAppChooserDialog(heading string)
}

// appChooserDialog implements the AppChooserDialog class.
type appChooserDialog struct {
	Dialog
}

// WrapAppChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserDialog(obj *externglib.Object) AppChooserDialog {
	return appChooserDialog{
		Dialog: WrapDialog(obj),
	}
}

func marshalAppChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserDialog(obj), nil
}

// NewAppChooserDialog creates a new `GtkAppChooserDialog` for the provided
// `GFile`.
//
// The dialog will show applications that can open the file.
func NewAppChooserDialog(parent Window, flags DialogFlags, file gio.File) AppChooserDialog {
	var _arg1 *C.GtkWindow     // out
	var _arg2 C.GtkDialogFlags // out
	var _arg3 *C.GFile         // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (C.GtkDialogFlags)(flags)
	_arg3 = (*C.GFile)(unsafe.Pointer(file.Native()))

	_cret = C.gtk_app_chooser_dialog_new(_arg1, _arg2, _arg3)

	var _appChooserDialog AppChooserDialog // out

	_appChooserDialog = WrapAppChooserDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _appChooserDialog
}

// NewAppChooserDialogForContentType creates a new `GtkAppChooserDialog` for the
// provided content type.
//
// The dialog will show applications that can open the content type.
func NewAppChooserDialogForContentType(parent Window, flags DialogFlags, contentType string) AppChooserDialog {
	var _arg1 *C.GtkWindow     // out
	var _arg2 C.GtkDialogFlags // out
	var _arg3 *C.char          // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (C.GtkDialogFlags)(flags)
	_arg3 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_app_chooser_dialog_new_for_content_type(_arg1, _arg2, _arg3)

	var _appChooserDialog AppChooserDialog // out

	_appChooserDialog = WrapAppChooserDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _appChooserDialog
}

func (s appChooserDialog) Heading() string {
	var _arg0 *C.GtkAppChooserDialog // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_dialog_get_heading(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s appChooserDialog) Widget() Widget {
	var _arg0 *C.GtkAppChooserDialog // out
	var _cret *C.GtkWidget           // in

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_dialog_get_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s appChooserDialog) SetHeadingAppChooserDialog(heading string) {
	var _arg0 *C.GtkAppChooserDialog // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(heading))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_dialog_set_heading(_arg0, _arg1)
}

func (s appChooserDialog) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s appChooserDialog) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s appChooserDialog) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s appChooserDialog) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s appChooserDialog) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s appChooserDialog) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s appChooserDialog) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (s appChooserDialog) AppInfo() gio.AppInfo {
	return WrapAppChooser(gextras.InternObject(s)).AppInfo()
}

func (s appChooserDialog) ContentType() string {
	return WrapAppChooser(gextras.InternObject(s)).ContentType()
}

func (s appChooserDialog) Refresh() {
	WrapAppChooser(gextras.InternObject(s)).Refresh()
}

func (b appChooserDialog) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s appChooserDialog) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s appChooserDialog) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s appChooserDialog) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s appChooserDialog) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s appChooserDialog) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s appChooserDialog) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s appChooserDialog) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s appChooserDialog) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// AppChooserWidget: `GtkAppChooserWidget` is a widget for selecting
// applications.
//
// It is the main building block for [class@Gtk.AppChooserDialog]. Most
// applications only need to use the latter; but you can use this widget as part
// of a larger widget if you have special needs.
//
// `GtkAppChooserWidget` offers detailed control over what applications are
// shown, using the [property@Gtk.AppChooserWidget:show-default],
// [property@Gtk.AppChooserWidget:show-recommended],
// [property@Gtk.AppChooserWidget:show-fallback],
// [property@Gtk.AppChooserWidget:show-other] and
// [property@Gtk.AppChooserWidget:show-all] properties. See the
// [iface@Gtk.AppChooser] documentation for more information about these groups
// of applications.
//
// To keep track of the selected application, use the
// [signal@Gtk.AppChooserWidget::application-selected] and
// [signal@Gtk.AppChooserWidget::application-activated] signals.
//
//
// CSS nodes
//
// `GtkAppChooserWidget` has a single CSS node with name appchooser.
type AppChooserWidget interface {
	AppChooser

	// DefaultText returns the text that is shown if there are not applications
	// that can handle the content type.
	DefaultText() string
	// ShowAll gets whether the app chooser should show all applications in a
	// flat list.
	ShowAll() bool
	// ShowDefault gets whether the app chooser should show the default handler
	// for the content type in a separate section.
	ShowDefault() bool
	// ShowFallback gets whether the app chooser should show related
	// applications for the content type in a separate section.
	ShowFallback() bool
	// ShowOther gets whether the app chooser should show applications which are
	// unrelated to the content type.
	ShowOther() bool
	// ShowRecommended gets whether the app chooser should show recommended
	// applications for the content type in a separate section.
	ShowRecommended() bool
	// SetDefaultTextAppChooserWidget sets the text that is shown if there are
	// not applications that can handle the content type.
	SetDefaultTextAppChooserWidget(text string)
	// SetShowAllAppChooserWidget sets whether the app chooser should show all
	// applications in a flat list.
	SetShowAllAppChooserWidget(setting bool)
	// SetShowDefaultAppChooserWidget sets whether the app chooser should show
	// the default handler for the content type in a separate section.
	SetShowDefaultAppChooserWidget(setting bool)
	// SetShowFallbackAppChooserWidget sets whether the app chooser should show
	// related applications for the content type in a separate section.
	SetShowFallbackAppChooserWidget(setting bool)
	// SetShowOtherAppChooserWidget sets whether the app chooser should show
	// applications which are unrelated to the content type.
	SetShowOtherAppChooserWidget(setting bool)
	// SetShowRecommendedAppChooserWidget sets whether the app chooser should
	// show recommended applications for the content type in a separate section.
	SetShowRecommendedAppChooserWidget(setting bool)
}

// appChooserWidget implements the AppChooserWidget class.
type appChooserWidget struct {
	Widget
}

// WrapAppChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserWidget(obj *externglib.Object) AppChooserWidget {
	return appChooserWidget{
		Widget: WrapWidget(obj),
	}
}

func marshalAppChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserWidget(obj), nil
}

// NewAppChooserWidget creates a new `GtkAppChooserWidget` for applications that
// can handle content of the given type.
func NewAppChooserWidget(contentType string) AppChooserWidget {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_app_chooser_widget_new(_arg1)

	var _appChooserWidget AppChooserWidget // out

	_appChooserWidget = WrapAppChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _appChooserWidget
}

func (s appChooserWidget) DefaultText() string {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_default_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s appChooserWidget) ShowAll() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_all(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s appChooserWidget) ShowDefault() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s appChooserWidget) ShowFallback() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_fallback(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s appChooserWidget) ShowOther() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_other(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s appChooserWidget) ShowRecommended() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_recommended(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s appChooserWidget) SetDefaultTextAppChooserWidget(text string) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_widget_set_default_text(_arg0, _arg1)
}

func (s appChooserWidget) SetShowAllAppChooserWidget(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_all(_arg0, _arg1)
}

func (s appChooserWidget) SetShowDefaultAppChooserWidget(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_default(_arg0, _arg1)
}

func (s appChooserWidget) SetShowFallbackAppChooserWidget(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_fallback(_arg0, _arg1)
}

func (s appChooserWidget) SetShowOtherAppChooserWidget(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_other(_arg0, _arg1)
}

func (s appChooserWidget) SetShowRecommendedAppChooserWidget(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_recommended(_arg0, _arg1)
}

func (s appChooserWidget) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s appChooserWidget) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s appChooserWidget) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s appChooserWidget) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s appChooserWidget) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s appChooserWidget) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s appChooserWidget) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (s appChooserWidget) AppInfo() gio.AppInfo {
	return WrapAppChooser(gextras.InternObject(s)).AppInfo()
}

func (s appChooserWidget) ContentType() string {
	return WrapAppChooser(gextras.InternObject(s)).ContentType()
}

func (s appChooserWidget) Refresh() {
	WrapAppChooser(gextras.InternObject(s)).Refresh()
}

func (b appChooserWidget) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Application: `GtkApplication` is a high-level API for writing applications.
//
// It supports many aspects of writing a GTK application in a convenient
// fashion, without enforcing a one-size-fits-all model.
//
// Currently, `GtkApplication` handles GTK initialization, application
// uniqueness, session management, provides some basic scriptability and desktop
// shell integration by exporting actions and menus and manages a list of
// toplevel windows whose life-cycle is automatically tied to the life-cycle of
// your application.
//
// While `GtkApplication` works fine with plain [class@Gtk.Window]s, it is
// recommended to use it together with [class@Gtk.ApplicationWindow].
//
//
// Automatic resources
//
// `GtkApplication` will automatically load menus from the `GtkBuilder` resource
// located at "gtk/menus.ui", relative to the application's resource base path
// (see `g_application_set_resource_base_path()`). The menu with the ID
// "menubar" is taken as the application's menubar. Additional menus (most
// interesting submenus) can be named and accessed via
// [method@Gtk.Application.get_menu_by_id] which allows for dynamic population
// of a part of the menu structure.
//
// It is also possible to provide the menubar manually using
// [method@Gtk.Application.set_menubar].
//
// `GtkApplication` will also automatically setup an icon search path for the
// default icon theme by appending "icons" to the resource base path. This
// allows your application to easily store its icons as resources. See
// [method@Gtk.IconTheme.add_resource_path] for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// [class@Gtk.ShortcutsWindow] with ID "help_overlay" then `GtkApplication`
// associates an instance of this shortcuts window with each
// [class@Gtk.ApplicationWindow] and sets up the keyboard accelerator
// <kbd>Control</kbd>+<kbd>?</kbd> to open it. To create a menu item that
// displays the shortcuts window, associate the item with the action
// `win.show-help-overlay`.
//
//
// A simple application
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/bp/bloatpad.c) is
// available in the GTK source code repository
//
// `GtkApplication` optionally registers with a session manager of the users
// session (if you set the [property@Gtk.Application:register-session] property)
// and offers various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// [method@Gtk.Application.inhibit] function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
//
// See Also
//
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK: Basics (getting_started.html#basics)
type Application interface {
	gio.Application
	gio.ActionGroup
	gio.ActionMap

	// AddWindowApplication adds a window to `application`.
	//
	// This call can only happen after the `application` has started; typically,
	// you should add new application windows in response to the emission of the
	// `GApplication::activate` signal.
	//
	// This call is equivalent to setting the [property@Gtk.Window:application]
	// property of `window` to `application`.
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it
	// with [method@Gtk.Application.remove_window].
	//
	// GTK will keep the `application` running as long as it has any windows.
	AddWindowApplication(window Window)
	// AccelsForAction gets the accelerators that are currently associated with
	// the given action.
	AccelsForAction(detailedActionName string) []string
	// ActionsForAccel returns the list of actions (possibly empty) that `accel`
	// maps to.
	//
	// Each item in the list is a detailed action name in the usual form.
	//
	// This might be useful to discover if an accel already exists in order to
	// prevent installation of a conflicting accelerator (from an accelerator
	// editor or a plugin system, for example). Note that having more than one
	// action per accelerator may not be a bad thing and might make sense in
	// cases where the actions never appear in the same context.
	//
	// In case there are no actions for a given accelerator, an empty array is
	// returned. `NULL` is never returned.
	//
	// It is a programmer error to pass an invalid accelerator string.
	//
	// If you are unsure, check it with [func@Gtk.accelerator_parse] first.
	ActionsForAccel(accel string) []string
	// ActiveWindow gets the active window for the application.
	//
	// The active window is the one that was most recently focused (within the
	// application). This window may not have the focus at the moment if another
	// application has it  this is just the most recently-focused window within
	// this application.
	ActiveWindow() Window
	// MenuByID gets a menu from automatically loaded resources.
	//
	// See the section on Automatic resources
	// (class.Application.html#automatic-resources) for more information.
	MenuByID(id string) gio.Menu
	// Menubar returns the menu model that has been set with
	// [method@Gtk.Application.set_menubar].
	Menubar() gio.MenuModel
	// WindowByID returns the [class@Gtk.ApplicationWindow] with the given ID.
	//
	// The ID of a `GtkApplicationWindow` can be retrieved with
	// [method@Gtk.ApplicationWindow.get_id].
	WindowByID(id uint) Window
	// InhibitApplication: inform the session manager that certain types of
	// actions should be inhibited.
	//
	// This is not guaranteed to work on all platforms and for all types of
	// actions.
	//
	// Applications should invoke this method when they begin an operation that
	// should not be interrupted, such as creating a CD or DVD. The types of
	// actions that may be blocked are specified by the `flags` parameter. When
	// the application completes the operation it should call
	// [method@Gtk.Application.uninhibit] to remove the inhibitor. Note that an
	// application can have multiple inhibitors, and all of them must be
	// individually removed. Inhibitors are also cleared when the application
	// exits.
	//
	// Applications should not expect that they will always be able to block the
	// action. In most cases, users will be given the option to force the action
	// to take place.
	//
	// The `reason` message should be short and to the point.
	//
	// If `window` is given, the session manager may point the user to this
	// window to find out more about why the action is inhibited.
	InhibitApplication(window Window, flags ApplicationInhibitFlags, reason string) uint
	// ListActionDescriptionsApplication lists the detailed action names which
	// have associated accelerators.
	//
	// See [method@Gtk.Application.set_accels_for_action].
	ListActionDescriptionsApplication() []string
	// RemoveWindowApplication: remove a window from `application`.
	//
	// If `window` belongs to `application` then this call is equivalent to
	// setting the [property@Gtk.Window:application] property of `window` to
	// `NULL`.
	//
	// The application may stop running as a result of a call to this function,
	// if `window` was the last window of the `application`.
	RemoveWindowApplication(window Window)
	// SetAccelsForActionApplication sets zero or more keyboard accelerators
	// that will trigger the given action.
	//
	// The first item in `accels` will be the primary accelerator, which may be
	// displayed in the UI.
	//
	// To remove all accelerators for an action, use an empty, zero-terminated
	// array for `accels`.
	//
	// For the `detailed_action_name`, see `g_action_parse_detailed_name()` and
	// `g_action_print_detailed_name()`.
	SetAccelsForActionApplication(detailedActionName string, accels []string)
	// SetMenubarApplication sets or unsets the menubar for windows of
	// `application`.
	//
	// This is a menubar in the traditional sense.
	//
	// This can only be done in the primary instance of the application, after
	// it has been registered. `GApplication::startup` is a good place to call
	// this.
	//
	// Depending on the desktop environment, this may appear at the top of each
	// window, or at the top of the screen. In some environments, if both the
	// application menu and the menubar are set, the application menu will be
	// presented as if it were the first item of the menubar. Other environments
	// treat the two as completely separate  for example, the application menu
	// may be rendered by the desktop shell while the menubar (if set) remains
	// in each individual window.
	//
	// Use the base `GActionMap` interface to add actions, to respond to the
	// user selecting these menu items.
	SetMenubarApplication(menubar gio.MenuModel)
	// UninhibitApplication removes an inhibitor that has been previously
	// established.
	//
	// See [method@Gtk.Application.inhibit].
	//
	// Inhibitors are also cleared when the application exits.
	UninhibitApplication(cookie uint)
}

// application implements the Application class.
type application struct {
	gio.Application
}

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return application{
		Application: gio.WrapApplication(obj),
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

// NewApplication creates a new `GtkApplication` instance.
//
// When using `GtkApplication`, it is not necessary to call [func@Gtk.init]
// manually. It is called as soon as the application gets registered as the
// primary instance.
//
// Concretely, [func@Gtk.init] is called in the default handler for the
// `GApplication::startup` signal. Therefore, `GtkApplication` subclasses should
// always chain up in their `GApplication::startup` handler before using any GTK
// API.
//
// Note that commandline arguments are not passed to [func@Gtk.init].
//
// If `application_id` is not nil, then it must be valid. See
// `g_application_id_is_valid()`.
//
// If no application ID is given then some features (most notably application
// uniqueness) will be disabled.
func NewApplication(applicationId string, flags gio.ApplicationFlags) Application {
	var _arg1 *C.char             // out
	var _arg2 C.GApplicationFlags // out
	var _cret *C.GtkApplication   // in

	_arg1 = (*C.char)(C.CString(applicationId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GApplicationFlags)(flags)

	_cret = C.gtk_application_new(_arg1, _arg2)

	var _application Application // out

	_application = WrapApplication(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _application
}

func (a application) AddWindowApplication(window Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_add_window(_arg0, _arg1)
}

func (a application) AccelsForAction(detailedActionName string) []string {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.char           // out
	var _cret **C.char

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_accels_for_action(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (a application) ActionsForAccel(accel string) []string {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.char           // out
	var _cret **C.char

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(accel))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_actions_for_accel(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (a application) ActiveWindow() Window {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GtkWindow      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_get_active_window(_arg0)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

func (a application) MenuByID(id string) gio.Menu {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.char           // out
	var _cret *C.GMenu          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_menu_by_id(_arg0, _arg1)

	var _menu gio.Menu // out

	_menu = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Menu)

	return _menu
}

func (a application) Menubar() gio.MenuModel {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_get_menubar(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (a application) WindowByID(id uint) Window {
	var _arg0 *C.GtkApplication // out
	var _arg1 C.guint           // out
	var _cret *C.GtkWindow      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (C.guint)(id)

	_cret = C.gtk_application_get_window_by_id(_arg0, _arg1)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

func (a application) InhibitApplication(window Window, flags ApplicationInhibitFlags, reason string) uint {
	var _arg0 *C.GtkApplication            // out
	var _arg1 *C.GtkWindow                 // out
	var _arg2 C.GtkApplicationInhibitFlags // out
	var _arg3 *C.char                      // out
	var _cret C.guint                      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg2 = (C.GtkApplicationInhibitFlags)(flags)
	_arg3 = (*C.char)(C.CString(reason))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_application_inhibit(_arg0, _arg1, _arg2, _arg3)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (a application) ListActionDescriptionsApplication() []string {
	var _arg0 *C.GtkApplication // out
	var _cret **C.char

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_list_action_descriptions(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (a application) RemoveWindowApplication(window Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_remove_window(_arg0, _arg1)
}

func (a application) SetAccelsForActionApplication(detailedActionName string, accels []string) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.char           // out
	var _arg2 **C.char

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.char)(C.malloc(C.ulong(len(accels)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(accels))
		for i := range accels {
			out[i] = (*C.char)(C.CString(accels[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_application_set_accels_for_action(_arg0, _arg1, _arg2)
}

func (a application) SetMenubarApplication(menubar gio.MenuModel) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(menubar.Native()))

	C.gtk_application_set_menubar(_arg0, _arg1)
}

func (a application) UninhibitApplication(cookie uint) {
	var _arg0 *C.GtkApplication // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (C.guint)(cookie)

	C.gtk_application_uninhibit(_arg0, _arg1)
}

// ApplicationWindow: `GtkApplicationWindow` is a `GtkWindow` subclass that
// integrates with `GtkApplication`.
//
// Notably, `GtkApplicationWindow` can handle an application menubar.
//
// This class implements the `GActionGroup` and `GActionMap` interfaces, to let
// you add window-specific actions that will be exported by the associated
// [class@Gtk.Application], together with its application-wide actions.
// Window-specific actions are prefixed with the win. prefix and
// application-wide actions are prefixed with the app. prefix. Actions must be
// addressed with the prefixed name when referring to them from a `GMenuModel`.
//
// Note that widgets that are placed inside a `GtkApplicationWindow` can also
// activate these actions, if they implement the [iface@Gtk.Actionable]
// interface.
//
// The settings [property@Gtk.Settings:gtk-shell-shows-app-menu] and
// [property@Gtk.Settings:gtk-shell-shows-menubar] tell GTK whether the desktop
// environment is showing the application menu and menubar models outside the
// application as part of the desktop shell. For instance, on OS X, both menus
// will be displayed remotely; on Windows neither will be.
//
// If the desktop environment does not display the menubar, then
// `GtkApplicationWindow` will automatically show a menubar for it. This
// behaviour can be overridden with the
// [property@Gtk.ApplicationWindow:show-menubar] property. If the desktop
// environment does not display the application menu, then it will automatically
// be included in the menubar or in the windows client-side decorations.
//
// See [class@Gtk.PopoverMenu] for information about the XML language used by
// `GtkBuilder` for menu models.
//
// See also: [method@Gtk.Application.set_menubar].
//
//
// A GtkApplicationWindow with a menubar
//
// The code sample below shows how to set up a `GtkApplicationWindow` with a
// menu bar defined on the [class@Gtk.Application]:
//
// `c GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
//
// GtkBuilder *builder = gtk_builder_new_from_string ( "<interface>" " <menu
// id='menubar'>" " <submenu>" " <attribute name='label'
// translatable='yes'>_Edit</attribute>" " <item>" " <attribute name='label'
// translatable='yes'>_Copy</attribute>" " <attribute
// name='action'>win.copy</attribute>" " </item>" " <item>" " <attribute
// name='label' translatable='yes'>_Paste</attribute>" " <attribute
// name='action'>win.paste</attribute>" " </item>" " </submenu>" " </menu>"
// "</interface>", -1);
//
// GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder,
// "menubar")); gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
// g_object_unref (builder);
//
// // ...
//
// GtkWidget *window = gtk_application_window_new (app); `
type ApplicationWindow interface {
	Window
	gio.ActionGroup
	gio.ActionMap

	// HelpOverlay gets the `GtkShortcutsWindow` that is associated with
	// @window.
	//
	// See [method@Gtk.ApplicationWindow.set_help_overlay].
	HelpOverlay() ShortcutsWindow
	// ID returns the unique ID of the window.
	//
	//    If the window has not yet been added to a `GtkApplication`, returns `0`.
	ID() uint
	// ShowMenubar returns whether the window will display a menubar for the app
	// menu and menubar as needed.
	ShowMenubar() bool
	// SetHelpOverlayApplicationWindow associates a shortcuts window with the
	// application window.
	//
	// Additionally, sets up an action with the name `win.show-help-overlay` to
	// present it.
	//
	// @window takes responsibility for destroying @help_overlay.
	SetHelpOverlayApplicationWindow(helpOverlay ShortcutsWindow)
	// SetShowMenubarApplicationWindow sets whether the window will display a
	// menubar for the app menu and menubar as needed.
	SetShowMenubarApplicationWindow(showMenubar bool)
}

// applicationWindow implements the ApplicationWindow class.
type applicationWindow struct {
	Window
}

// WrapApplicationWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplicationWindow(obj *externglib.Object) ApplicationWindow {
	return applicationWindow{
		Window: WrapWindow(obj),
	}
}

func marshalApplicationWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplicationWindow(obj), nil
}

// NewApplicationWindow creates a new `GtkApplicationWindow`.
func NewApplicationWindow(application Application) ApplicationWindow {
	var _arg1 *C.GtkApplication // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

	_cret = C.gtk_application_window_new(_arg1)

	var _applicationWindow ApplicationWindow // out

	_applicationWindow = WrapApplicationWindow(externglib.Take(unsafe.Pointer(_cret)))

	return _applicationWindow
}

func (w applicationWindow) HelpOverlay() ShortcutsWindow {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret *C.GtkShortcutsWindow   // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_application_window_get_help_overlay(_arg0)

	var _shortcutsWindow ShortcutsWindow // out

	_shortcutsWindow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutsWindow)

	return _shortcutsWindow
}

func (w applicationWindow) ID() uint {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret C.guint                 // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_application_window_get_id(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (w applicationWindow) ShowMenubar() bool {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_application_window_get_show_menubar(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w applicationWindow) SetHelpOverlayApplicationWindow(helpOverlay ShortcutsWindow) {
	var _arg0 *C.GtkApplicationWindow // out
	var _arg1 *C.GtkShortcutsWindow   // out

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkShortcutsWindow)(unsafe.Pointer(helpOverlay.Native()))

	C.gtk_application_window_set_help_overlay(_arg0, _arg1)
}

func (w applicationWindow) SetShowMenubarApplicationWindow(showMenubar bool) {
	var _arg0 *C.GtkApplicationWindow // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
	if showMenubar {
		_arg1 = C.TRUE
	}

	C.gtk_application_window_set_show_menubar(_arg0, _arg1)
}

func (s applicationWindow) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s applicationWindow) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s applicationWindow) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s applicationWindow) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s applicationWindow) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s applicationWindow) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s applicationWindow) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b applicationWindow) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s applicationWindow) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s applicationWindow) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s applicationWindow) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s applicationWindow) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s applicationWindow) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s applicationWindow) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s applicationWindow) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s applicationWindow) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// AspectFrame: `GtkAspectFrame` preserves the aspect ratio of its child.
//
// The frame can respect the aspect ratio of the child widget, or use its own
// aspect ratio.
//
//
// CSS nodes
//
// `GtkAspectFrame` uses a CSS node with name `frame`.
type AspectFrame interface {
	Widget

	// Child gets the child widget of @self.
	Child() Widget
	// ObeyChild returns whether the child's size request should override the
	// set aspect ratio of the `GtkAspectFrame`.
	ObeyChild() bool
	// Ratio returns the desired aspect ratio of the child.
	Ratio() float32
	// Xalign returns the horizontal alignment of the child within the
	// allocation of the `GtkAspectFrame`.
	Xalign() float32
	// Yalign returns the vertical alignment of the child within the allocation
	// of the `GtkAspectFrame`.
	Yalign() float32
	// SetChildAspectFrame sets the child widget of @self.
	SetChildAspectFrame(child Widget)
	// SetObeyChildAspectFrame sets whether the aspect ratio of the child's size
	// request should override the set aspect ratio of the `GtkAspectFrame`.
	SetObeyChildAspectFrame(obeyChild bool)
	// SetRatioAspectFrame sets the desired aspect ratio of the child.
	SetRatioAspectFrame(ratio float32)
	// SetXalignAspectFrame sets the horizontal alignment of the child within
	// the allocation of the `GtkAspectFrame`.
	SetXalignAspectFrame(xalign float32)
	// SetYalignAspectFrame sets the vertical alignment of the child within the
	// allocation of the `GtkAspectFrame`.
	SetYalignAspectFrame(yalign float32)
}

// aspectFrame implements the AspectFrame class.
type aspectFrame struct {
	Widget
}

// WrapAspectFrame wraps a GObject to the right type. It is
// primarily used internally.
func WrapAspectFrame(obj *externglib.Object) AspectFrame {
	return aspectFrame{
		Widget: WrapWidget(obj),
	}
}

func marshalAspectFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAspectFrame(obj), nil
}

// NewAspectFrame: create a new `GtkAspectFrame`.
func NewAspectFrame(xalign float32, yalign float32, ratio float32, obeyChild bool) AspectFrame {
	var _arg1 C.float      // out
	var _arg2 C.float      // out
	var _arg3 C.float      // out
	var _arg4 C.gboolean   // out
	var _cret *C.GtkWidget // in

	_arg1 = (C.float)(xalign)
	_arg2 = (C.float)(yalign)
	_arg3 = (C.float)(ratio)
	if obeyChild {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_aspect_frame_new(_arg1, _arg2, _arg3, _arg4)

	var _aspectFrame AspectFrame // out

	_aspectFrame = WrapAspectFrame(externglib.Take(unsafe.Pointer(_cret)))

	return _aspectFrame
}

func (s aspectFrame) Child() Widget {
	var _arg0 *C.GtkAspectFrame // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_aspect_frame_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s aspectFrame) ObeyChild() bool {
	var _arg0 *C.GtkAspectFrame // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_aspect_frame_get_obey_child(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s aspectFrame) Ratio() float32 {
	var _arg0 *C.GtkAspectFrame // out
	var _cret C.float           // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_aspect_frame_get_ratio(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (s aspectFrame) Xalign() float32 {
	var _arg0 *C.GtkAspectFrame // out
	var _cret C.float           // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_aspect_frame_get_xalign(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (s aspectFrame) Yalign() float32 {
	var _arg0 *C.GtkAspectFrame // out
	var _cret C.float           // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_aspect_frame_get_yalign(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (s aspectFrame) SetChildAspectFrame(child Widget) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 *C.GtkWidget      // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_aspect_frame_set_child(_arg0, _arg1)
}

func (s aspectFrame) SetObeyChildAspectFrame(obeyChild bool) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	if obeyChild {
		_arg1 = C.TRUE
	}

	C.gtk_aspect_frame_set_obey_child(_arg0, _arg1)
}

func (s aspectFrame) SetRatioAspectFrame(ratio float32) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 C.float           // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(ratio)

	C.gtk_aspect_frame_set_ratio(_arg0, _arg1)
}

func (s aspectFrame) SetXalignAspectFrame(xalign float32) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 C.float           // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(xalign)

	C.gtk_aspect_frame_set_xalign(_arg0, _arg1)
}

func (s aspectFrame) SetYalignAspectFrame(yalign float32) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 C.float           // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(yalign)

	C.gtk_aspect_frame_set_yalign(_arg0, _arg1)
}

func (s aspectFrame) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s aspectFrame) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s aspectFrame) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s aspectFrame) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s aspectFrame) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s aspectFrame) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s aspectFrame) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b aspectFrame) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Assistant: `GtkAssistant` is used to represent a complex as a series of
// steps.
//
// !An example GtkAssistant (assistant.png)
//
// Each step consists of one or more pages. `GtkAssistant` guides the user
// through the pages, and controls the page flow to collect the data needed for
// the operation.
//
// `GtkAssistant` handles which buttons to show and to make sensitive based on
// page sequence knowledge and the [enum@Gtk.AssistantPageType] of each page in
// addition to state information like the *completed* and *committed* page
// statuses.
//
// If you have a case that doesnt quite fit in `GtkAssistant`s way of handling
// buttons, you can use the GTK_ASSISTANT_PAGE_CUSTOM page type and handle
// buttons yourself.
//
// `GtkAssistant` maintains a `GtkAssistantPage` object for each added child,
// which holds additional per-child properties. You obtain the
// `GtkAssistantPage` for a child with [method@Gtk.Assistant.get_page].
//
//
// GtkAssistant as GtkBuildable
//
// The `GtkAssistant` implementation of the `GtkBuildable` interface exposes the
// @action_area as internal children with the name action_area.
//
// To add pages to an assistant in `GtkBuilder`, simply add it as a child to the
// `GtkAssistant` object. If you need to set per-object properties, create a
// `GtkAssistantPage` object explicitly, and set the child widget as a property
// on it.
//
//
// CSS nodes
//
// `GtkAssistant` has a single CSS node with the name window and style class
// .assistant.
type Assistant interface {
	Window

	// AddActionWidgetAssistant adds a widget to the action area of a
	// `GtkAssistant`.
	AddActionWidgetAssistant(child Widget)
	// AppendPageAssistant appends a page to the @assistant.
	AppendPageAssistant(page Widget) int
	// CommitAssistant erases the visited page history.
	//
	// GTK will then hide the back button on the current page, and removes the
	// cancel button from subsequent pages.
	//
	// Use this when the information provided up to the current page is
	// hereafter deemed permanent and cannot be modified or undone. For example,
	// showing a progress page to track a long-running, unreversible operation
	// after the user has clicked apply on a confirmation page.
	CommitAssistant()
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// NPages returns the number of pages in the @assistant
	NPages() int
	// NthPage returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// Page returns the `GtkAssistantPage` object for @child.
	Page(child Widget) AssistantPage
	// PageComplete gets whether @page is complete.
	PageComplete(page Widget) bool
	// PageTitle gets the title for @page.
	PageTitle(page Widget) string
	// PageType gets the page type of @page.
	PageType(page Widget) AssistantPageType
	// Pages gets a list model of the assistant pages.
	Pages() gio.ListModel
	// InsertPageAssistant inserts a page in the @assistant at a given position.
	InsertPageAssistant(page Widget, position int) int
	// NextPageAssistant: navigate to the next page.
	//
	// It is a programming error to call this function when there is no next
	// page.
	//
	// This function is for use when creating pages of the
	// GTK_ASSISTANT_PAGE_CUSTOM type.
	NextPageAssistant()
	// PrependPageAssistant prepends a page to the @assistant.
	PrependPageAssistant(page Widget) int
	// PreviousPageAssistant: navigate to the previous visited page.
	//
	// It is a programming error to call this function when no previous page is
	// available.
	//
	// This function is for use when creating pages of the
	// GTK_ASSISTANT_PAGE_CUSTOM type.
	PreviousPageAssistant()
	// RemoveActionWidgetAssistant removes a widget from the action area of a
	// `GtkAssistant`.
	RemoveActionWidgetAssistant(child Widget)
	// RemovePageAssistant removes the @page_nums page from @assistant.
	RemovePageAssistant(pageNum int)
	// SetCurrentPageAssistant switches the page to @page_num.
	//
	// Note that this will only be necessary in custom buttons, as the
	// @assistant flow can be set with gtk_assistant_set_forward_page_func().
	SetCurrentPageAssistant(pageNum int)
	// SetPageCompleteAssistant sets whether @page contents are complete.
	//
	// This will make @assistant update the buttons state to be able to continue
	// the task.
	SetPageCompleteAssistant(page Widget, complete bool)
	// SetPageTitleAssistant sets a title for @page.
	//
	// The title is displayed in the header area of the assistant when @page is
	// the current page.
	SetPageTitleAssistant(page Widget, title string)
	// SetPageTypeAssistant sets the page type for @page.
	//
	// The page type determines the page behavior in the @assistant.
	SetPageTypeAssistant(page Widget, typ AssistantPageType)
	// UpdateButtonsStateAssistant forces @assistant to recompute the buttons
	// state.
	//
	// GTK automatically takes care of this in most situations, e.g. when the
	// user goes to a different page, or when the visibility or completeness of
	// a page changes.
	//
	// One situation where it can be necessary to call this function is when
	// changing a value on the current page affects the future page flow of the
	// assistant.
	UpdateButtonsStateAssistant()
}

// assistant implements the Assistant class.
type assistant struct {
	Window
}

// WrapAssistant wraps a GObject to the right type. It is
// primarily used internally.
func WrapAssistant(obj *externglib.Object) Assistant {
	return assistant{
		Window: WrapWindow(obj),
	}
}

func marshalAssistant(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAssistant(obj), nil
}

// NewAssistant creates a new `GtkAssistant`.
func NewAssistant() Assistant {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_assistant_new()

	var _assistant Assistant // out

	_assistant = WrapAssistant(externglib.Take(unsafe.Pointer(_cret)))

	return _assistant
}

func (a assistant) AddActionWidgetAssistant(child Widget) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_assistant_add_action_widget(_arg0, _arg1)
}

func (a assistant) AppendPageAssistant(page Widget) int {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_append_page(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (a assistant) CommitAssistant() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_commit(_arg0)
}

func (a assistant) CurrentPage() int {
	var _arg0 *C.GtkAssistant // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_assistant_get_current_page(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (a assistant) NPages() int {
	var _arg0 *C.GtkAssistant // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_assistant_get_n_pages(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (a assistant) NthPage(pageNum int) Widget {
	var _arg0 *C.GtkAssistant // out
	var _arg1 C.int           // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (C.int)(pageNum)

	_cret = C.gtk_assistant_get_nth_page(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (a assistant) Page(child Widget) AssistantPage {
	var _arg0 *C.GtkAssistant     // out
	var _arg1 *C.GtkWidget        // out
	var _cret *C.GtkAssistantPage // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_assistant_get_page(_arg0, _arg1)

	var _assistantPage AssistantPage // out

	_assistantPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(AssistantPage)

	return _assistantPage
}

func (a assistant) PageComplete(page Widget) bool {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_get_page_complete(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a assistant) PageTitle(page Widget) string {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_get_page_title(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a assistant) PageType(page Widget) AssistantPageType {
	var _arg0 *C.GtkAssistant        // out
	var _arg1 *C.GtkWidget           // out
	var _cret C.GtkAssistantPageType // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_get_page_type(_arg0, _arg1)

	var _assistantPageType AssistantPageType // out

	_assistantPageType = AssistantPageType(_cret)

	return _assistantPageType
}

func (a assistant) Pages() gio.ListModel {
	var _arg0 *C.GtkAssistant // out
	var _cret *C.GListModel   // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_assistant_get_pages(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (a assistant) InsertPageAssistant(page Widget, position int) int {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.int           // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (C.int)(position)

	_cret = C.gtk_assistant_insert_page(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (a assistant) NextPageAssistant() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_next_page(_arg0)
}

func (a assistant) PrependPageAssistant(page Widget) int {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_prepend_page(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (a assistant) PreviousPageAssistant() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_previous_page(_arg0)
}

func (a assistant) RemoveActionWidgetAssistant(child Widget) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_assistant_remove_action_widget(_arg0, _arg1)
}

func (a assistant) RemovePageAssistant(pageNum int) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 C.int           // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (C.int)(pageNum)

	C.gtk_assistant_remove_page(_arg0, _arg1)
}

func (a assistant) SetCurrentPageAssistant(pageNum int) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 C.int           // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (C.int)(pageNum)

	C.gtk_assistant_set_current_page(_arg0, _arg1)
}

func (a assistant) SetPageCompleteAssistant(page Widget, complete bool) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	if complete {
		_arg2 = C.TRUE
	}

	C.gtk_assistant_set_page_complete(_arg0, _arg1, _arg2)
}

func (a assistant) SetPageTitleAssistant(page Widget, title string) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.char         // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_assistant_set_page_title(_arg0, _arg1, _arg2)
}

func (a assistant) SetPageTypeAssistant(page Widget, typ AssistantPageType) {
	var _arg0 *C.GtkAssistant        // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkAssistantPageType // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (C.GtkAssistantPageType)(typ)

	C.gtk_assistant_set_page_type(_arg0, _arg1, _arg2)
}

func (a assistant) UpdateButtonsStateAssistant() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_update_buttons_state(_arg0)
}

func (s assistant) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s assistant) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s assistant) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s assistant) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s assistant) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s assistant) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s assistant) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b assistant) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s assistant) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s assistant) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s assistant) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s assistant) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s assistant) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s assistant) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s assistant) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s assistant) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// AssistantPage: `GtkAssistantPage` is an auxiliary object used by
// `GtkAssistant.
type AssistantPage interface {

	// Child returns the child to which @page belongs.
	Child() Widget
}

// assistantPage implements the AssistantPage class.
type assistantPage struct {
	gextras.Objector
}

// WrapAssistantPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapAssistantPage(obj *externglib.Object) AssistantPage {
	return assistantPage{
		Objector: obj,
	}
}

func marshalAssistantPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAssistantPage(obj), nil
}

func (p assistantPage) Child() Widget {
	var _arg0 *C.GtkAssistantPage // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkAssistantPage)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_assistant_page_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// BinLayout: `GtkBinLayout` is a `GtkLayoutManager` subclass useful for create
// "bins" of widgets.
//
// `GtkBinLayout` will stack each child of a widget on top of each other, using
// the [property@Gtk.Widget:hexpand], [property@Gtk.Widget:vexpand],
// [property@Gtk.Widget:halign], and [property@Gtk.Widget:valign] properties of
// each child to determine where they should be positioned.
type BinLayout interface {
}

// binLayout implements the BinLayout class.
type binLayout struct {
	LayoutManager
}

// WrapBinLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapBinLayout(obj *externglib.Object) BinLayout {
	return binLayout{
		LayoutManager: WrapLayoutManager(obj),
	}
}

func marshalBinLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBinLayout(obj), nil
}

// NewBinLayout creates a new `GtkBinLayout` instance.
func NewBinLayout() BinLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_bin_layout_new()

	var _binLayout BinLayout // out

	_binLayout = WrapBinLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _binLayout
}

// BookmarkList: `GtkBookmarkList` is a list model that wraps `GBookmarkFile`.
//
// It presents a `GListModel` and fills it asynchronously with the `GFileInfo`s
// returned from that function.
//
// The `GFileInfo`s in the list have some attributes in the recent namespace
// added: `recent::private` (boolean) and `recent:applications` (stringv).
type BookmarkList interface {
	gio.ListModel

	// Attributes gets the attributes queried on the children.
	Attributes() string
	// Filename returns the filename of the bookmark file that this list is
	// loading.
	Filename() string
	// IOPriority gets the IO priority to use while loading file.
	IOPriority() int
	// IsLoadingBookmarkList returns true if the files are currently being
	// loaded.
	//
	// Files will be added to @self from time to time while loading is going on.
	// The order in which are added is undefined and may change in between runs.
	IsLoadingBookmarkList() bool
	// SetAttributesBookmarkList sets the @attributes to be enumerated and
	// starts the enumeration.
	//
	// If @attributes is nil, no attributes will be queried, but a list of Infos
	// will still be created.
	SetAttributesBookmarkList(attributes string)
	// SetIOPriorityBookmarkList sets the IO priority to use while loading
	// files.
	//
	// The default IO priority is G_PRIORITY_DEFAULT.
	SetIOPriorityBookmarkList(ioPriority int)
}

// bookmarkList implements the BookmarkList class.
type bookmarkList struct {
	gextras.Objector
}

// WrapBookmarkList wraps a GObject to the right type. It is
// primarily used internally.
func WrapBookmarkList(obj *externglib.Object) BookmarkList {
	return bookmarkList{
		Objector: obj,
	}
}

func marshalBookmarkList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBookmarkList(obj), nil
}

// NewBookmarkList creates a new `GtkBookmarkList` with the given @attributes.
func NewBookmarkList(filename string, attributes string) BookmarkList {
	var _arg1 *C.char            // out
	var _arg2 *C.char            // out
	var _cret *C.GtkBookmarkList // in

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_bookmark_list_new(_arg1, _arg2)

	var _bookmarkList BookmarkList // out

	_bookmarkList = WrapBookmarkList(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bookmarkList
}

func (s bookmarkList) Attributes() string {
	var _arg0 *C.GtkBookmarkList // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bookmark_list_get_attributes(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s bookmarkList) Filename() string {
	var _arg0 *C.GtkBookmarkList // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bookmark_list_get_filename(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s bookmarkList) IOPriority() int {
	var _arg0 *C.GtkBookmarkList // out
	var _cret C.int              // in

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bookmark_list_get_io_priority(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s bookmarkList) IsLoadingBookmarkList() bool {
	var _arg0 *C.GtkBookmarkList // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bookmark_list_is_loading(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s bookmarkList) SetAttributesBookmarkList(attributes string) {
	var _arg0 *C.GtkBookmarkList // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_bookmark_list_set_attributes(_arg0, _arg1)
}

func (s bookmarkList) SetIOPriorityBookmarkList(ioPriority int) {
	var _arg0 *C.GtkBookmarkList // out
	var _arg1 C.int              // out

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(ioPriority)

	C.gtk_bookmark_list_set_io_priority(_arg0, _arg1)
}

// BoolFilter: `GtkBoolFilter` evaluates a boolean `GtkExpression` to determine
// whether to include items.
type BoolFilter interface {

	// Expression gets the expression that the filter uses to evaluate if an
	// item should be filtered.
	Expression() Expression
	// Invert returns whether the filter inverts the expression.
	Invert() bool
	// SetExpressionBoolFilter sets the expression that the filter uses to check
	// if items should be filtered.
	//
	// The expression must have a value type of G_TYPE_BOOLEAN.
	SetExpressionBoolFilter(expression Expression)
	// SetInvertBoolFilter sets whether the filter should invert the expression.
	SetInvertBoolFilter(invert bool)
}

// boolFilter implements the BoolFilter class.
type boolFilter struct {
	Filter
}

// WrapBoolFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapBoolFilter(obj *externglib.Object) BoolFilter {
	return boolFilter{
		Filter: WrapFilter(obj),
	}
}

func marshalBoolFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBoolFilter(obj), nil
}

// NewBoolFilter creates a new bool filter.
func NewBoolFilter(expression Expression) BoolFilter {
	var _arg1 *C.GtkExpression // out
	var _cret *C.GtkBoolFilter // in

	_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	_cret = C.gtk_bool_filter_new(_arg1)

	var _boolFilter BoolFilter // out

	_boolFilter = WrapBoolFilter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _boolFilter
}

func (s boolFilter) Expression() Expression {
	var _arg0 *C.GtkBoolFilter // out
	var _cret *C.GtkExpression // in

	_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bool_filter_get_expression(_arg0)

	var _expression Expression // out

	_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

	return _expression
}

func (s boolFilter) Invert() bool {
	var _arg0 *C.GtkBoolFilter // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bool_filter_get_invert(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s boolFilter) SetExpressionBoolFilter(expression Expression) {
	var _arg0 *C.GtkBoolFilter // out
	var _arg1 *C.GtkExpression // out

	_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	C.gtk_bool_filter_set_expression(_arg0, _arg1)
}

func (s boolFilter) SetInvertBoolFilter(invert bool) {
	var _arg0 *C.GtkBoolFilter // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(s.Native()))
	if invert {
		_arg1 = C.TRUE
	}

	C.gtk_bool_filter_set_invert(_arg0, _arg1)
}

// Box: the `GtkBox` widget arranges child widgets into a single row or column.
//
// !An example GtkBox (box.png)
//
// Whether it is a row or column depends on the value of its
// [property@Gtk.Orientable:orientation] property. Within the other dimension,
// all children are allocated the same size. Of course, the
// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties can
// be used on the children to influence their allocation.
//
// Use repeated calls to [method@Gtk.Box.append] to pack widgets into a `GtkBox`
// from start to end. Use [method@Gtk.Box.remove] to remove widgets from the
// `GtkBox`. [method@Gtk.Box.insert_child_after] can be used to add a child at a
// particular position.
//
// Use [method@Gtk.Box.set_homogeneous] to specify whether or not all children
// of the `GtkBox` are forced to get the same amount of space.
//
// Use [method@Gtk.Box.set_spacing] to determine how much space will be
// minimally placed between all children in the `GtkBox`. Note that spacing is
// added *between* the children.
//
// Use [method@Gtk.Box.reorder_child_after] to move a child to a different place
// in the box.
//
//
// CSS nodes
//
// `GtkBox` uses a single CSS node with name box.
//
//
// Accessibility
//
// `GtkBox` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Box interface {
	Widget
	Orientable

	// AppendBox adds @child as the last child to @box.
	AppendBox(child Widget)
	// BaselinePosition gets the value set by gtk_box_set_baseline_position().
	BaselinePosition() BaselinePosition
	// Homogeneous returns whether the box is homogeneous (all children are the
	// same size).
	Homogeneous() bool
	// Spacing gets the value set by gtk_box_set_spacing().
	Spacing() int
	// InsertChildAfterBox inserts @child in the position after @sibling in the
	// list of @box children.
	//
	// If @sibling is nil, insert @child at the first position.
	InsertChildAfterBox(child Widget, sibling Widget)
	// PrependBox adds @child as the first child to @box.
	PrependBox(child Widget)
	// RemoveBox removes a child widget from @box.
	//
	// The child must have been added before with [method@Gtk.Box.append],
	// [method@Gtk.Box.prepend], or [method@Gtk.Box.insert_child_after].
	RemoveBox(child Widget)
	// ReorderChildAfterBox moves @child to the position after @sibling in the
	// list of @box children.
	//
	// If @sibling is nil, move @child to the first position.
	ReorderChildAfterBox(child Widget, sibling Widget)
	// SetBaselinePositionBox sets the baseline position of a box.
	//
	// This affects only horizontal boxes with at least one baseline aligned
	// child. If there is more vertical space available than requested, and the
	// baseline is not allocated by the parent then @position is used to
	// allocate the baseline with respect to the extra space available.
	SetBaselinePositionBox(position BaselinePosition)
	// SetHomogeneousBox sets whether or not all children of @box are given
	// equal space in the box.
	SetHomogeneousBox(homogeneous bool)
	// SetSpacingBox sets the number of pixels to place between children of
	// @box.
	SetSpacingBox(spacing int)
}

// box implements the Box class.
type box struct {
	Widget
}

// WrapBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapBox(obj *externglib.Object) Box {
	return box{
		Widget: WrapWidget(obj),
	}
}

func marshalBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBox(obj), nil
}

// NewBox creates a new `GtkBox`.
func NewBox(orientation Orientation, spacing int) Box {
	var _arg1 C.GtkOrientation // out
	var _arg2 C.int            // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (C.int)(spacing)

	_cret = C.gtk_box_new(_arg1, _arg2)

	var _box Box // out

	_box = WrapBox(externglib.Take(unsafe.Pointer(_cret)))

	return _box
}

func (b box) AppendBox(child Widget) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_box_append(_arg0, _arg1)
}

func (b box) BaselinePosition() BaselinePosition {
	var _arg0 *C.GtkBox             // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_get_baseline_position(_arg0)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

func (b box) Homogeneous() bool {
	var _arg0 *C.GtkBox  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_get_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b box) Spacing() int {
	var _arg0 *C.GtkBox // out
	var _cret C.int     // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (b box) InsertChildAfterBox(child Widget, sibling Widget) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))

	C.gtk_box_insert_child_after(_arg0, _arg1, _arg2)
}

func (b box) PrependBox(child Widget) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_box_prepend(_arg0, _arg1)
}

func (b box) RemoveBox(child Widget) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_box_remove(_arg0, _arg1)
}

func (b box) ReorderChildAfterBox(child Widget, sibling Widget) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))

	C.gtk_box_reorder_child_after(_arg0, _arg1, _arg2)
}

func (b box) SetBaselinePositionBox(position BaselinePosition) {
	var _arg0 *C.GtkBox             // out
	var _arg1 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkBaselinePosition)(position)

	C.gtk_box_set_baseline_position(_arg0, _arg1)
}

func (b box) SetHomogeneousBox(homogeneous bool) {
	var _arg0 *C.GtkBox  // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_box_set_homogeneous(_arg0, _arg1)
}

func (b box) SetSpacingBox(spacing int) {
	var _arg0 *C.GtkBox // out
	var _arg1 C.int     // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(spacing)

	C.gtk_box_set_spacing(_arg0, _arg1)
}

func (s box) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s box) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s box) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s box) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s box) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s box) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s box) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b box) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o box) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o box) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// BoxLayout: `GtkBoxLayout` is a layout manager that arranges children in a
// single row or column.
//
// Whether it is a row or column depends on the value of its
// [property@Gtk.Orientable:orientation] property. Within the other dimension
// all children all allocated the same size. The `GtkBoxLayout` will respect the
// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties of
// each child widget.
//
// If you want all children to be assigned the same size, you can use the
// [property@Gtk.BoxLayout:homogeneous] property.
//
// If you want to specify the amount of space placed between each child, you can
// use the [property@Gtk.BoxLayout:spacing] property.
type BoxLayout interface {
	LayoutManager
	Orientable

	// BaselinePosition gets the value set by
	// gtk_box_layout_set_baseline_position().
	BaselinePosition() BaselinePosition
	// Homogeneous returns whether the layout is set to be homogeneous.
	Homogeneous() bool
	// Spacing returns the space that @box_layout puts between children.
	Spacing() uint
	// SetBaselinePositionBoxLayout sets the baseline position of a box layout.
	//
	// The baseline position affects only horizontal boxes with at least one
	// baseline aligned child. If there is more vertical space available than
	// requested, and the baseline is not allocated by the parent then the given
	// @position is used to allocate the baseline within the extra space
	// available.
	SetBaselinePositionBoxLayout(position BaselinePosition)
	// SetHomogeneousBoxLayout sets whether the box layout will allocate the
	// same size to all children.
	SetHomogeneousBoxLayout(homogeneous bool)
	// SetSpacingBoxLayout sets how much spacing to put between children.
	SetSpacingBoxLayout(spacing uint)
}

// boxLayout implements the BoxLayout class.
type boxLayout struct {
	LayoutManager
}

// WrapBoxLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapBoxLayout(obj *externglib.Object) BoxLayout {
	return boxLayout{
		LayoutManager: WrapLayoutManager(obj),
	}
}

func marshalBoxLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBoxLayout(obj), nil
}

// NewBoxLayout creates a new `GtkBoxLayout`.
func NewBoxLayout(orientation Orientation) BoxLayout {
	var _arg1 C.GtkOrientation    // out
	var _cret *C.GtkLayoutManager // in

	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_box_layout_new(_arg1)

	var _boxLayout BoxLayout // out

	_boxLayout = WrapBoxLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _boxLayout
}

func (b boxLayout) BaselinePosition() BaselinePosition {
	var _arg0 *C.GtkBoxLayout       // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_layout_get_baseline_position(_arg0)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

func (b boxLayout) Homogeneous() bool {
	var _arg0 *C.GtkBoxLayout // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_layout_get_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b boxLayout) Spacing() uint {
	var _arg0 *C.GtkBoxLayout // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_layout_get_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (b boxLayout) SetBaselinePositionBoxLayout(position BaselinePosition) {
	var _arg0 *C.GtkBoxLayout       // out
	var _arg1 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkBaselinePosition)(position)

	C.gtk_box_layout_set_baseline_position(_arg0, _arg1)
}

func (b boxLayout) SetHomogeneousBoxLayout(homogeneous bool) {
	var _arg0 *C.GtkBoxLayout // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_box_layout_set_homogeneous(_arg0, _arg1)
}

func (b boxLayout) SetSpacingBoxLayout(spacing uint) {
	var _arg0 *C.GtkBoxLayout // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_box_layout_set_spacing(_arg0, _arg1)
}

func (o boxLayout) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o boxLayout) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// Builder: a `GtkBuilder` reads XML descriptions of a user interface and
// instantiates the described objects.
//
// To create a `GtkBuilder` from a user interface description, call
// [ctor@Gtk.Builder.new_from_file], [ctor@Gtk.Builder.new_from_resource] or
// [ctor@Gtk.Builder.new_from_string].
//
// In the (unusual) case that you want to add user interface descriptions from
// multiple sources to the same `GtkBuilder` you can call [ctor@Gtk.Builder.new]
// to get an empty builder and populate it by (multiple) calls to
// [method@Gtk.Builder.add_from_file], [method@Gtk.Builder.add_from_resource] or
// [method@Gtk.Builder.add_from_string].
//
// A `GtkBuilder` holds a reference to all objects that it has constructed and
// drops these references when it is finalized. This finalization can cause the
// destruction of non-widget objects or widgets which are not contained in a
// toplevel window. For toplevel windows constructed by a builder, it is the
// responsibility of the user to call [method@Gtk.Window.destroy] to get rid of
// them and all the widgets they contain.
//
// The functions [method@Gtk.Builder.get_object] and
// [method@Gtk.Builder.get_objects] can be used to access the widgets in the
// interface by the names assigned to them inside the UI description. Toplevel
// windows returned by these functions will stay around until the user
// explicitly destroys them with [method@Gtk.Window.destroy]. Other widgets will
// either be part of a larger hierarchy constructed by the builder (in which
// case you should not have to worry about their lifecycle), or without a
// parent, in which case they have to be added to some container to make use of
// them. Non-widget objects need to be reffed with g_object_ref() to keep them
// beyond the lifespan of the builder.
//
//
// GtkBuilder UI Definitions
//
// `GtkBuilder` parses textual descriptions of user interfaces which are
// specified in XML format. We refer to these descriptions as GtkBuilder UI
// definitions or just UI definitions if the context is clear.
//
// The toplevel element is `<interface>`. It optionally takes a domain
// attribute, which will make the builder look for translated strings using
// `dgettext()` in the domain specified. This can also be done by calling
// [method@Gtk.Builder.set_translation_domain] on the builder.
//
// Objects are described by `<object>` elements, which can contain `<property>`
// elements to set properties, `<signal>` elements which connect signals to
// handlers, and `<child>` elements, which describe child objects (most often
// widgets inside a container, but also e.g. actions in an action group, or
// columns in a tree model). A `<child>` element contains an `<object>` element
// which describes the child object.
//
// The target toolkit version(s) are described by `<requires>` elements, the
// lib attribute specifies the widget library in question (currently the only
// supported value is gtk) and the version attribute specifies the target
// version in the form `<major>`.`<minor>`. `GtkBuilder` will error out if the
// version requirements are not met.
//
// Typically, the specific kind of object represented by an `<object>` element
// is specified by the class attribute. If the type has not been loaded yet,
// GTK tries to find the `get_type()` function from the class name by applying
// heuristics. This works in most cases, but if necessary, it is possible to
// specify the name of the `get_type()` function explicitly with the "type-func"
// attribute.
//
// Objects may be given a name with the id attribute, which allows the
// application to retrieve them from the builder with
// [method@Gtk.Builder.get_object]. An id is also necessary to use the object as
// property value in other parts of the UI definition. GTK reserves ids starting
// and ending with `___` (three consecutive underscores) for its own purposes.
//
// Setting properties of objects is pretty straightforward with the `<property>`
// element: the name attribute specifies the name of the property, and the
// content of the element specifies the value. If the translatable attribute
// is set to a true value, GTK uses `gettext()` (or `dgettext()` if the builder
// has a translation domain set) to find a translation for the value. This
// happens before the value is parsed, so it can be used for properties of any
// type, but it is probably most useful for string properties. It is also
// possible to specify a context to disambiguate short strings, and comments
// which may help the translators.
//
// `GtkBuilder` can parse textual representations for the most common property
// types: characters, strings, integers, floating-point numbers, booleans
// (strings like TRUE, t, yes, y, 1 are interpreted as true, strings
// like FALSE, f, no, n, 0 are interpreted as false), enumerations
// (can be specified by their name, nick or integer value), flags (can be
// specified by their name, nick, integer value, optionally combined with |,
// e.g. GTK_INPUT_HINT_EMOJI|GTK_INPUT_HINT_LOWERCASE) and colors (in a format
// understood by [method@Gdk.RGBA.parse]).
//
// `GVariant`s can be specified in the format understood by g_variant_parse(),
// and pixbufs can be specified as a filename of an image file to load.
//
// Objects can be referred to by their name and by default refer to objects
// declared in the local XML fragment and objects exposed via
// [method@Gtk.Builder.expose_object]. In general, `GtkBuilder` allows forward
// references to objects  declared in the local XML; an object doesnt have to
// be constructed before it can be referred to. The exception to this rule is
// that an object has to be constructed before it can be used as the value of a
// construct-only property.
//
// It is also possible to bind a property value to another object's property
// value using the attributes "bind-source" to specify the source object of the
// binding, and optionally, "bind-property" and "bind-flags" to specify the
// source property and source binding flags respectively. Internally,
// `GtkBuilder` implements this using `GBinding` objects. For more information
// see g_object_bind_property().
//
// Sometimes it is necessary to refer to widgets which have implicitly been
// constructed by GTK as part of a composite widget, to set properties on them
// or to add further children (e.g. the content area of a `GtkDialog`). This can
// be achieved by setting the internal-child property of the `<child>` element
// to a true value. Note that Builder still requires an `<object>` element for
// the internal child, even if it has already been constructed.
//
// A number of widgets have different places where a child can be added (e.g.
// tabs vs. page content in notebooks). This can be reflected in a UI definition
// by specifying the type attribute on a `<child>` The possible values for the
// type attribute are described in the sections describing the widget-specific
// portions of UI definitions.
//
//
// Signal handlers and function pointers
//
// Signal handlers are set up with the `<signal>` element. The name attribute
// specifies the name of the signal, and the handler attribute specifies the
// function to connect to the signal. The remaining attributes, after,
// swapped and object, have the same meaning as the corresponding parameters
// of the g_signal_connect_object() or g_signal_connect_data() functions. A
// last_modification_time attribute is also allowed, but it does not have a
// meaning to the builder.
//
// If you rely on `GModule` support to lookup callbacks in the symbol table, the
// following details should be noted:
//
// When compiling applications for Windows, you must declare signal callbacks
// with G_MODULE_EXPORT, or they will not be put in the symbol table. On Linux
// and Unix, this is not necessary; applications should instead be compiled with
// the -Wl,--export-dynamic `CFLAGS`, and linked against `gmodule-export-2.0`.
//
//
// A GtkBuilder UI Definition
//
// `xml <interface> <object class="GtkDialog" id="dialog1"> <child
// internal-child="vbox"> <object class="GtkBox" id="vbox1"> <child
// internal-child="action_area"> <object class="GtkBox" id="hbuttonbox1">
// <child> <object class="GtkButton" id="ok_button"> <property
// name="label">gtk-ok</property> <signal name="clicked"
// handler="ok_button_clicked"/> </object> </child> </object> </child> </object>
// </child> </object> </interface> `
//
// Beyond this general structure, several object classes define their own XML
// DTD fragments for filling in the ANY placeholders in the DTD above. Note that
// a custom element in a <child> element gets parsed by the custom tag handler
// of the parent object, while a custom element in an <object> element gets
// parsed by the custom tag handler of the object.
//
// These XML fragments are explained in the documentation of the respective
// objects.
//
// A `<template>` tag can be used to define a widget classs components. See the
// GtkWidget documentation
// (class.Widget.html#building-composite-widgets-from-template-xml) for details.
type Builder interface {

	// AddFromFileBuilder parses a file containing a UI definition and merges it
	// with the current contents of @builder.
	//
	// This function is useful if you need to call
	// [method@Gtk.Builder.set_current_object]) to add user data to callbacks
	// before loading GtkBuilder UI. Otherwise, you probably want
	// [ctor@Gtk.Builder.new_from_file] instead.
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// `GError` from the `GTK_BUILDER_ERROR`, `G_MARKUP_ERROR` or `G_FILE_ERROR`
	// domains.
	//
	// Its not really reasonable to attempt to handle failures of this call.
	// You should not use this function with untrusted files (ie: files that are
	// not part of your application). Broken `GtkBuilder` files can easily crash
	// your program, and its possible that memory was leaked leading up to the
	// reported failure. The only reasonable thing to do when an error is
	// detected is to call `g_error()`.
	AddFromFileBuilder(filename string) error
	// AddFromResourceBuilder parses a resource file containing a UI definition
	// and merges it with the current contents of @builder.
	//
	// This function is useful if you need to call
	// [method@Gtk.Builder.set_current_object] to add user data to callbacks
	// before loading GtkBuilder UI. Otherwise, you probably want
	// [ctor@Gtk.Builder.new_from_resource] instead.
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// `GError` from the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_RESOURCE_ERROR
	// domain.
	//
	// Its not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromResourceBuilder(resourcePath string) error
	// AddFromStringBuilder parses a string containing a UI definition and
	// merges it with the current contents of @builder.
	//
	// This function is useful if you need to call
	// [method@Gtk.Builder.set_current_object] to add user data to callbacks
	// before loading `GtkBuilder` UI. Otherwise, you probably want
	// [ctor@Gtk.Builder.new_from_string] instead.
	//
	// Upon errors false will be returned and @error will be assigned a `GError`
	// from the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_VARIANT_PARSE_ERROR
	// domain.
	//
	// Its not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromStringBuilder(buffer string, length int) error
	// AddObjectsFromFileBuilder parses a file containing a UI definition
	// building only the requested objects and merges them with the current
	// contents of @builder.
	//
	// Upon errors, 0 will be returned and @error will be assigned a `GError`
	// from the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_FILE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a `GtkTreeView` that depends on its `GtkTreeModel`),
	// you have to explicitly list all of them in @object_ids.
	AddObjectsFromFileBuilder(filename string, objectIds []string) error
	// AddObjectsFromResourceBuilder parses a resource file containing a UI
	// definition, building only the requested objects and merges them with the
	// current contents of @builder.
	//
	// Upon errors, 0 will be returned and @error will be assigned a `GError`
	// from the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_RESOURCE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a `GtkTreeView` that depends on its `GtkTreeModel`),
	// you have to explicitly list all of them in @object_ids.
	AddObjectsFromResourceBuilder(resourcePath string, objectIds []string) error
	// AddObjectsFromStringBuilder parses a string containing a UI definition,
	// building only the requested objects and merges them with the current
	// contents of @builder.
	//
	// Upon errors false will be returned and @error will be assigned a `GError`
	// from the GTK_BUILDER_ERROR or G_MARKUP_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a `GtkTreeView` that depends on its `GtkTreeModel`),
	// you have to explicitly list all of them in @object_ids.
	AddObjectsFromStringBuilder(buffer string, length int, objectIds []string) error
	// ExposeObjectBuilder: add @object to the @builder object pool so it can be
	// referenced just like any other object built by builder.
	ExposeObjectBuilder(name string, object gextras.Objector)
	// ExtendWithTemplateBuilder: main private entry point for building
	// composite components from template XML.
	//
	// This is exported purely to let `gtk-builder-tool` validate templates,
	// applications have no need to call this function.
	ExtendWithTemplateBuilder(object gextras.Objector, templateType externglib.Type, buffer string, length int) error
	// CurrentObject gets the current object set via
	// gtk_builder_set_current_object().
	CurrentObject() gextras.Objector
	// Object gets the object named @name.
	//
	// Note that this function does not increment the reference count of the
	// returned object.
	Object(name string) gextras.Objector
	// Scope gets the scope in use that was set via gtk_builder_set_scope().
	Scope() BuilderScope
	// TranslationDomain gets the translation domain of @builder.
	TranslationDomain() string
	// TypeFromName looks up a type by name.
	//
	// This is using the virtual function that `GtkBuilder` has for that
	// purpose. This is mainly used when implementing the `GtkBuildable`
	// interface on a type.
	TypeFromName(typeName string) externglib.Type
	// SetCurrentObjectBuilder sets the current object for the @builder.
	//
	// The current object can be thought of as the `this` object that the
	// builder is working for and will often be used as the default object when
	// an object is optional.
	//
	// [method@Gtk.Widget.init_template] for example will set the current object
	// to the widget the template is inited for. For functions like
	// [ctor@Gtk.Builder.new_from_resource], the current object will be nil.
	SetCurrentObjectBuilder(currentObject gextras.Objector)
	// SetScopeBuilder sets the scope the builder should operate in.
	//
	// If @scope is nil a new [class@Gtk.BuilderCScope] will be created.
	SetScopeBuilder(scope BuilderScope)
	// SetTranslationDomainBuilder sets the translation domain of @builder.
	SetTranslationDomainBuilder(domain string)
	// ValueFromStringTypeBuilder demarshals a value from a string.
	//
	// Unlike [method@Gtk.Builder.value_from_string], this function takes a
	// `GType` instead of `GParamSpec`.
	//
	// Calls g_value_init() on the @value argument, so it need not be
	// initialised beforehand.
	//
	// Upon errors false will be returned and @error will be assigned a `GError`
	// from the GTK_BUILDER_ERROR domain.
	ValueFromStringTypeBuilder(typ externglib.Type, _string string) (externglib.Value, error)
}

// builder implements the Builder class.
type builder struct {
	gextras.Objector
}

// WrapBuilder wraps a GObject to the right type. It is
// primarily used internally.
func WrapBuilder(obj *externglib.Object) Builder {
	return builder{
		Objector: obj,
	}
}

func marshalBuilder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilder(obj), nil
}

// NewBuilder creates a new empty builder object.
//
// This function is only useful if you intend to make multiple calls to
// [method@Gtk.Builder.add_from_file], [method@Gtk.Builder.add_from_resource] or
// [method@Gtk.Builder.add_from_string] in order to merge multiple UI
// descriptions into a single builder.
func NewBuilder() Builder {
	var _cret *C.GtkBuilder // in

	_cret = C.gtk_builder_new()

	var _builder Builder // out

	_builder = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// NewBuilderFromFile parses the UI definition in the file @filename.
//
// If there is an error opening the file or parsing the description then the
// program will be aborted. You should only ever attempt to parse user interface
// descriptions that are shipped as part of your program.
func NewBuilderFromFile(filename string) Builder {
	var _arg1 *C.char       // out
	var _cret *C.GtkBuilder // in

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_new_from_file(_arg1)

	var _builder Builder // out

	_builder = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// NewBuilderFromResource parses the UI definition at @resource_path.
//
// If there is an error locating the resource or parsing the description, then
// the program will be aborted.
func NewBuilderFromResource(resourcePath string) Builder {
	var _arg1 *C.char       // out
	var _cret *C.GtkBuilder // in

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_new_from_resource(_arg1)

	var _builder Builder // out

	_builder = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// NewBuilderFromString parses the UI definition in @string.
//
// If @string is nil-terminated, then @length should be -1. If @length is not
// -1, then it is the length of @string.
//
// If there is an error parsing @string then the program will be aborted. You
// should not attempt to parse user interface description from untrusted
// sources.
func NewBuilderFromString(_string string, length int) Builder {
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _cret *C.GtkBuilder // in

	_arg1 = (*C.char)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(length)

	_cret = C.gtk_builder_new_from_string(_arg1, _arg2)

	var _builder Builder // out

	_builder = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

func (b builder) AddFromFileBuilder(filename string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_builder_add_from_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (b builder) AddFromResourceBuilder(resourcePath string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_builder_add_from_resource(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (b builder) AddFromStringBuilder(buffer string, length int) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(buffer))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(length)

	C.gtk_builder_add_from_string(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (b builder) AddObjectsFromFileBuilder(filename string, objectIds []string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 **C.char
	var _cerr *C.GError // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.char)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(objectIds))
		for i := range objectIds {
			out[i] = (*C.gchar)(C.CString(objectIds[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_builder_add_objects_from_file(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (b builder) AddObjectsFromResourceBuilder(resourcePath string, objectIds []string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 **C.char
	var _cerr *C.GError // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.char)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(objectIds))
		for i := range objectIds {
			out[i] = (*C.gchar)(C.CString(objectIds[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_builder_add_objects_from_resource(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (b builder) AddObjectsFromStringBuilder(buffer string, length int, objectIds []string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _arg3 **C.char
	var _cerr *C.GError // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(buffer))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(length)
	_arg3 = (**C.char)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(objectIds))
		for i := range objectIds {
			out[i] = (*C.gchar)(C.CString(objectIds[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_builder_add_objects_from_string(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (b builder) ExposeObjectBuilder(name string, object gextras.Objector) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 *C.GObject    // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))

	C.gtk_builder_expose_object(_arg0, _arg1, _arg2)
}

func (b builder) ExtendWithTemplateBuilder(object gextras.Objector, templateType externglib.Type, buffer string, length int) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.GObject    // out
	var _arg2 C.GType       // out
	var _arg3 *C.char       // out
	var _arg4 C.gssize      // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg2 = (C.GType)(templateType)
	_arg3 = (*C.char)(C.CString(buffer))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.gssize)(length)

	C.gtk_builder_extend_with_template(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (b builder) CurrentObject() gextras.Objector {
	var _arg0 *C.GtkBuilder // out
	var _cret *C.GObject    // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_builder_get_current_object(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (b builder) Object(name string) gextras.Objector {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cret *C.GObject    // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_get_object(_arg0, _arg1)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (b builder) Scope() BuilderScope {
	var _arg0 *C.GtkBuilder      // out
	var _cret *C.GtkBuilderScope // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_builder_get_scope(_arg0)

	var _builderScope BuilderScope // out

	_builderScope = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(BuilderScope)

	return _builderScope
}

func (b builder) TranslationDomain() string {
	var _arg0 *C.GtkBuilder // out
	var _cret *C.char       // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_builder_get_translation_domain(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (b builder) TypeFromName(typeName string) externglib.Type {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cret C.GType       // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(typeName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_get_type_from_name(_arg0, _arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (b builder) SetCurrentObjectBuilder(currentObject gextras.Objector) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.GObject    // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(currentObject.Native()))

	C.gtk_builder_set_current_object(_arg0, _arg1)
}

func (b builder) SetScopeBuilder(scope BuilderScope) {
	var _arg0 *C.GtkBuilder      // out
	var _arg1 *C.GtkBuilderScope // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkBuilderScope)(unsafe.Pointer(scope.Native()))

	C.gtk_builder_set_scope(_arg0, _arg1)
}

func (b builder) SetTranslationDomainBuilder(domain string) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_builder_set_translation_domain(_arg0, _arg1)
}

func (b builder) ValueFromStringTypeBuilder(typ externglib.Type, _string string) (externglib.Value, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 C.GType       // out
	var _arg2 *C.char       // out
	var _arg3 C.GValue      // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GType)(typ)
	_arg2 = (*C.char)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_builder_value_from_string_type(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _value externglib.Value // out
	var _goerr error            // out

	_value = *externglib.ValueFromNative(unsafe.Pointer(&_arg3))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _value, _goerr
}

// BuilderCScope: a `GtkBuilderScope` implementation for the C language.
//
// `GtkBuilderCScope` instances use symbols explicitly added to @builder with
// prior calls to [method@Gtk.BuilderCScope.add_callback_symbol]. If developers
// want to do that, they are encouraged to create their own scopes for that
// purpose.
//
// In the case that symbols are not explicitly added; GTK will uses `GModule`s
// introspective features (by opening the module nil) to look at the
// applications symbol table. From here it tries to match the signal function
// names given in the interface description with symbols in the application.
//
// Note that unless [method@Gtk.BuilderCScope.add_callback_symbol] is called for
// all signal callbacks which are referenced by the loaded XML, this
// functionality will require that `GModule` be supported on the platform.
type BuilderCScope interface {
	BuilderScope
}

// builderCScope implements the BuilderCScope class.
type builderCScope struct {
	gextras.Objector
}

// WrapBuilderCScope wraps a GObject to the right type. It is
// primarily used internally.
func WrapBuilderCScope(obj *externglib.Object) BuilderCScope {
	return builderCScope{
		Objector: obj,
	}
}

func marshalBuilderCScope(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilderCScope(obj), nil
}

// NewBuilderCScope creates a new `GtkBuilderCScope` object to use with future
// `GtkBuilder` instances.
//
// Calling this function is only necessary if you want to add custom callbacks
// via [method@Gtk.BuilderCScope.add_callback_symbol].
func NewBuilderCScope() BuilderCScope {
	var _cret *C.GtkBuilderScope // in

	_cret = C.gtk_builder_cscope_new()

	var _builderCScope BuilderCScope // out

	_builderCScope = WrapBuilderCScope(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builderCScope
}

// BuilderListItemFactory: `GtkBuilderListItemFactory` is a `GtkListItemFactory`
// that creates widgets by instantiating `GtkBuilder` UI templates.
//
// The templates must be extending `GtkListItem`, and typically use
// `GtkExpression`s to obtain data from the items in the model.
//
// Example: `xml <interface> <template class="GtkListItem"> <property
// name="child"> <object class="GtkLabel"> <property name="xalign">0</property>
// <binding name="label"> <lookup name="name" type="SettingsKey"> <lookup
// name="item">GtkListItem</lookup> </lookup> </binding> </object> </property>
// </template> </interface> `
type BuilderListItemFactory interface {

	// Resource: if the data references a resource, gets the path of that
	// resource.
	Resource() string
	// Scope gets the scope used when constructing listitems.
	Scope() BuilderScope
}

// builderListItemFactory implements the BuilderListItemFactory class.
type builderListItemFactory struct {
	ListItemFactory
}

// WrapBuilderListItemFactory wraps a GObject to the right type. It is
// primarily used internally.
func WrapBuilderListItemFactory(obj *externglib.Object) BuilderListItemFactory {
	return builderListItemFactory{
		ListItemFactory: WrapListItemFactory(obj),
	}
}

func marshalBuilderListItemFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilderListItemFactory(obj), nil
}

// NewBuilderListItemFactoryFromResource creates a new
// `GtkBuilderListItemFactory` that instantiates widgets using data read from
// the given @resource_path to pass to `GtkBuilder`.
func NewBuilderListItemFactoryFromResource(scope BuilderScope, resourcePath string) BuilderListItemFactory {
	var _arg1 *C.GtkBuilderScope    // out
	var _arg2 *C.char               // out
	var _cret *C.GtkListItemFactory // in

	_arg1 = (*C.GtkBuilderScope)(unsafe.Pointer(scope.Native()))
	_arg2 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_builder_list_item_factory_new_from_resource(_arg1, _arg2)

	var _builderListItemFactory BuilderListItemFactory // out

	_builderListItemFactory = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(BuilderListItemFactory)

	return _builderListItemFactory
}

func (s builderListItemFactory) Resource() string {
	var _arg0 *C.GtkBuilderListItemFactory // out
	var _cret *C.char                      // in

	_arg0 = (*C.GtkBuilderListItemFactory)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_builder_list_item_factory_get_resource(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s builderListItemFactory) Scope() BuilderScope {
	var _arg0 *C.GtkBuilderListItemFactory // out
	var _cret *C.GtkBuilderScope           // in

	_arg0 = (*C.GtkBuilderListItemFactory)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_builder_list_item_factory_get_scope(_arg0)

	var _builderScope BuilderScope // out

	_builderScope = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(BuilderScope)

	return _builderScope
}

// Button: the `GtkButton` widget is generally used to trigger a callback
// function that is called when the button is pressed.
//
// !An example GtkButton (button.png)
//
// The `GtkButton` widget can hold any valid child widget. That is, it can hold
// almost any other standard `GtkWidget`. The most commonly used child is the
// `GtkLabel`.
//
//
// CSS nodes
//
// `GtkButton` has a single CSS node with name button. The node will get the
// style classes .image-button or .text-button, if the content is just an image
// or label, respectively. It may also receive the .flat style class. When
// activating a button via the keyboard, the button will temporarily gain the
// .keyboard-activating style class.
//
// Other style classes that are commonly used with `GtkButton` include
// .suggested-action and .destructive-action. In special cases, buttons can be
// made round by adding the .circular style class.
//
// Button-like widgets like [class@Gtk.ToggleButton], [class@Gtk.MenuButton],
// [class@Gtk.VolumeButton], [class@Gtk.LockButton], [class@Gtk.ColorButton] or
// [class@Gtk.FontButton] use style classes such as .toggle, .popup, .scale,
// .lock, .color on the button node to differentiate themselves from a plain
// `GtkButton`.
//
//
// Accessibility
//
// `GtkButton` uses the GTK_ACCESSIBLE_ROLE_BUTTON role.
type Button interface {
	Actionable

	// Child gets the child widget of @button.
	Child() Widget
	// HasFrame returns whether the button has a frame.
	HasFrame() bool
	// IconName returns the icon name of the button.
	//
	// If the icon name has not been set with [method@Gtk.Button.set_icon_name]
	// the return value will be nil. This will be the case if you create an
	// empty button with [ctor@Gtk.Button.new] to use as a container.
	IconName() string
	// Label fetches the text from the label of the button.
	//
	// If the label text has not been set with [method@Gtk.Button.set_label] the
	// return value will be nil. This will be the case if you create an empty
	// button with [ctor@Gtk.Button.new] to use as a container.
	Label() string
	// UseUnderline gets whether underlines are interpreted as mnemonics.
	//
	// See [method@Gtk.Button.set_use_underline].
	UseUnderline() bool
	// SetChildButton sets the child widget of @button.
	SetChildButton(child Widget)
	// SetHasFrameButton sets the style of the button.
	//
	// Buttons can has a flat appearance or have a frame drawn around them.
	SetHasFrameButton(hasFrame bool)
	// SetIconNameButton adds a `GtkImage` with the given icon name as a child.
	//
	// If @button already contains a child widget, that child widget will be
	// removed and replaced with the image.
	SetIconNameButton(iconName string)
	// SetLabelButton sets the text of the label of the button to @label.
	//
	// This will also clear any previously set labels.
	SetLabelButton(label string)
	// SetUseUnderlineButton sets whether to use underlines as mnemonics.
	//
	// If true, an underline in the text of the button label indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderlineButton(useUnderline bool)
}

// button implements the Button class.
type button struct {
	Widget
}

// WrapButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapButton(obj *externglib.Object) Button {
	return button{
		Widget: WrapWidget(obj),
	}
}

func marshalButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapButton(obj), nil
}

// NewButton creates a new `GtkButton` widget.
//
// To add a child widget to the button, use [method@Gtk.Button.set_child].
func NewButton() Button {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_button_new()

	var _button Button // out

	_button = WrapButton(externglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonFromIconName creates a new button containing an icon from the
// current icon theme.
//
// If the icon name isnt known, a broken image icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
func NewButtonFromIconName(iconName string) Button {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_button_new_from_icon_name(_arg1)

	var _button Button // out

	_button = WrapButton(externglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonWithLabel creates a `GtkButton` widget with a `GtkLabel` child.
func NewButtonWithLabel(label string) Button {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_button_new_with_label(_arg1)

	var _button Button // out

	_button = WrapButton(externglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonWithMnemonic creates a new `GtkButton` containing a label.
//
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use __ (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. Pressing Alt and that key activates the
// button.
func NewButtonWithMnemonic(label string) Button {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_button_new_with_mnemonic(_arg1)

	var _button Button // out

	_button = WrapButton(externglib.Take(unsafe.Pointer(_cret)))

	return _button
}

func (b button) Child() Widget {
	var _arg0 *C.GtkButton // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (b button) HasFrame() bool {
	var _arg0 *C.GtkButton // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_has_frame(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b button) IconName() string {
	var _arg0 *C.GtkButton // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (b button) Label() string {
	var _arg0 *C.GtkButton // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (b button) UseUnderline() bool {
	var _arg0 *C.GtkButton // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b button) SetChildButton(child Widget) {
	var _arg0 *C.GtkButton // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_button_set_child(_arg0, _arg1)
}

func (b button) SetHasFrameButton(hasFrame bool) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	if hasFrame {
		_arg1 = C.TRUE
	}

	C.gtk_button_set_has_frame(_arg0, _arg1)
}

func (b button) SetIconNameButton(iconName string) {
	var _arg0 *C.GtkButton // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_button_set_icon_name(_arg0, _arg1)
}

func (b button) SetLabelButton(label string) {
	var _arg0 *C.GtkButton // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_button_set_label(_arg0, _arg1)
}

func (b button) SetUseUnderlineButton(useUnderline bool) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_button_set_use_underline(_arg0, _arg1)
}

func (s button) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s button) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s button) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s button) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s button) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s button) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s button) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (a button) ActionName() string {
	return WrapActionable(gextras.InternObject(a)).ActionName()
}

func (a button) ActionTargetValue() *glib.Variant {
	return WrapActionable(gextras.InternObject(a)).ActionTargetValue()
}

func (a button) SetActionName(actionName string) {
	WrapActionable(gextras.InternObject(a)).SetActionName(actionName)
}

func (a button) SetActionTargetValue(targetValue *glib.Variant) {
	WrapActionable(gextras.InternObject(a)).SetActionTargetValue(targetValue)
}

func (a button) SetDetailedActionName(detailedActionName string) {
	WrapActionable(gextras.InternObject(a)).SetDetailedActionName(detailedActionName)
}

func (b button) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// CClosureExpression: a variant of `GtkClosureExpression` using a C closure.
type CClosureExpression interface {
}

// cClosureExpression implements the CClosureExpression class.
type cClosureExpression struct {
	Expression
}

// WrapCClosureExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapCClosureExpression(obj *externglib.Object) CClosureExpression {
	return cClosureExpression{
		Expression: WrapExpression(obj),
	}
}

func marshalCClosureExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCClosureExpression(obj), nil
}

// Calendar: `GtkCalendar` is a widget that displays a Gregorian calendar, one
// month at a time.
//
// !An example GtkCalendar (calendar.png)
//
// A `GtkCalendar` can be created with [ctor@Gtk.Calendar.new].
//
// The date that is currently displayed can be altered with
// [method@Gtk.Calendar.select_day].
//
// To place a visual marker on a particular day, use
// [method@Gtk.Calendar.mark_day] and to remove the marker,
// [method@Gtk.Calendar.unmark_day]. Alternative, all marks can be cleared with
// [method@Gtk.Calendar.clear_marks].
//
// The selected date can be retrieved from a `GtkCalendar` using
// [method@Gtk.Calendar.get_date].
//
// Users should be aware that, although the Gregorian calendar is the legal
// calendar in most countries, it was adopted progressively between 1582 and
// 1929. Display before these dates is likely to be historically incorrect.
//
//
// CSS nodes
//
// ` calendar.view  header   button   stack.month   button  
// button   label.year   button  grid 
// label[.day-name][.week-number][.day-number][.other-month][.today] `
//
// `GtkCalendar` has a main node with name calendar. It contains a subnode
// called header containing the widgets for switching between years and months.
//
// The grid subnode contains all day labels, including week numbers on the left
// (marked with the .week-number css class) and day names on top (marked with
// the .day-name css class).
//
// Day labels that belong to the previous or next month get the .other-month
// style class. The label of the current day get the .today style class.
//
// Marked day labels get the :selected state assigned.
type Calendar interface {
	Widget

	// ClearMarksCalendar: remove all visual markers.
	ClearMarksCalendar()
	// DayIsMarked returns if the @day of the @calendar is already marked.
	DayIsMarked(day uint) bool
	// ShowDayNames returns whether @self is currently showing the names of the
	// week days.
	//
	// This is the value of the [property@Gtk.Calendar:show-day-names] property.
	ShowDayNames() bool
	// ShowHeading returns whether @self is currently showing the heading.
	//
	// This is the value of the [property@Gtk.Calendar:show-heading] property.
	ShowHeading() bool
	// ShowWeekNumbers returns whether @self is showing week numbers right now.
	//
	// This is the value of the [property@Gtk.Calendar:show-week-numbers]
	// property.
	ShowWeekNumbers() bool
	// MarkDayCalendar places a visual marker on a particular day.
	MarkDayCalendar(day uint)
	// SetShowDayNamesCalendar sets whether the calendar shows day names.
	SetShowDayNamesCalendar(value bool)
	// SetShowHeadingCalendar sets whether the calendar should show a heading.
	//
	// The heading contains the current year and month as well as buttons for
	// changing both.
	SetShowHeadingCalendar(value bool)
	// SetShowWeekNumbersCalendar sets whether week numbers are shown in the
	// calendar.
	SetShowWeekNumbersCalendar(value bool)
	// UnmarkDayCalendar removes the visual marker from a particular day.
	UnmarkDayCalendar(day uint)
}

// calendar implements the Calendar class.
type calendar struct {
	Widget
}

// WrapCalendar wraps a GObject to the right type. It is
// primarily used internally.
func WrapCalendar(obj *externglib.Object) Calendar {
	return calendar{
		Widget: WrapWidget(obj),
	}
}

func marshalCalendar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCalendar(obj), nil
}

// NewCalendar creates a new calendar, with the current date being selected.
func NewCalendar() Calendar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_calendar_new()

	var _calendar Calendar // out

	_calendar = WrapCalendar(externglib.Take(unsafe.Pointer(_cret)))

	return _calendar
}

func (c calendar) ClearMarksCalendar() {
	var _arg0 *C.GtkCalendar // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

	C.gtk_calendar_clear_marks(_arg0)
}

func (c calendar) DayIsMarked(day uint) bool {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(day)

	_cret = C.gtk_calendar_get_day_is_marked(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s calendar) ShowDayNames() bool {
	var _arg0 *C.GtkCalendar // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_calendar_get_show_day_names(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s calendar) ShowHeading() bool {
	var _arg0 *C.GtkCalendar // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_calendar_get_show_heading(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s calendar) ShowWeekNumbers() bool {
	var _arg0 *C.GtkCalendar // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_calendar_get_show_week_numbers(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c calendar) MarkDayCalendar(day uint) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(day)

	C.gtk_calendar_mark_day(_arg0, _arg1)
}

func (s calendar) SetShowDayNamesCalendar(value bool) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.gtk_calendar_set_show_day_names(_arg0, _arg1)
}

func (s calendar) SetShowHeadingCalendar(value bool) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.gtk_calendar_set_show_heading(_arg0, _arg1)
}

func (s calendar) SetShowWeekNumbersCalendar(value bool) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.gtk_calendar_set_show_week_numbers(_arg0, _arg1)
}

func (c calendar) UnmarkDayCalendar(day uint) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(day)

	C.gtk_calendar_unmark_day(_arg0, _arg1)
}

func (s calendar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s calendar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s calendar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s calendar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s calendar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s calendar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s calendar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b calendar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// CallbackAction: a `GtkShortcutAction` that invokes a callback.
type CallbackAction interface {
}

// callbackAction implements the CallbackAction class.
type callbackAction struct {
	ShortcutAction
}

// WrapCallbackAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapCallbackAction(obj *externglib.Object) CallbackAction {
	return callbackAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalCallbackAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCallbackAction(obj), nil
}

// CellArea: an abstract class for laying out GtkCellRenderers
//
// The CellArea is an abstract class for CellLayout widgets (also referred to as
// "layouting widgets") to interface with an arbitrary number of CellRenderers
// and interact with the user for a given TreeModel row.
//
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
//
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
//
//
// Requesting area sizes
//
// As outlined in [GtkWidgets geometry management
// section][geometry-management], GTK uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
//
// When requesting the size of a cell area one needs to calculate the size for a
// handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top to
// bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
//
// Its also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear columnized inside an area even
// when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
//
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, its important that the same CellAreaContext which
// was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
//
//    static gboolean
//    foo_focus (GtkWidget       *widget,
//               GtkDirectionType direction)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//      int         focus_row;
//      gboolean    have_focus = FALSE;
//
//      focus_row = priv->focus_row;
//
//      if (!gtk_widget_has_focus (widget))
//        gtk_widget_grab_focus (widget);
//
//      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//      while (valid)
//        {
//          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
//
//          if (gtk_cell_area_focus (priv->area, direction))
//            {
//               priv->focus_row = focus_row;
//               have_focus = TRUE;
//               break;
//            }
//          else
//            {
//              if (direction == GTK_DIR_RIGHT ||
//                  direction == GTK_DIR_LEFT)
//                break;
//              else if (direction == GTK_DIR_UP ||
//                       direction == GTK_DIR_TAB_BACKWARD)
//               {
//                  if (focus_row == 0)
//                    break;
//                  else
//                   {
//                      focus_row--;
//                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//                   }
//                }
//              else
//                {
//                  if (focus_row == last_row)
//                    break;
//                  else
//                    {
//                      focus_row++;
//                      valid = gtk_tree_model_iter_next (priv->model, &iter);
//                    }
//                }
//            }
//        }
//        return have_focus;
//    }
//
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
//
//
// Cell Properties
//
// The CellArea introduces cell properties for CellRenderers. This provides some
// general interfaces for defining the relationship cell areas have with their
// cells. For instance in a CellAreaBox a cell might expand and receive extra
// space when the area is allocated more than its full natural request, or a
// cell might be configured to align with adjacent rows which were requested
// and rendered with the same CellAreaContext.
//
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
//
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain the
// value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
type CellArea interface {
	Buildable
	CellLayout

	// ActivateCellArea activates @area, usually by activating the currently
	// focused cell, however some subclasses which embed widgets in the area can
	// also activate a widget if it currently has the focus.
	ActivateCellArea(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	// ActivateCellCellArea: this is used by CellArea subclasses when handling
	// events to activate cells, the base CellArea class activates cells for
	// keyboard events for free in its own GtkCellArea->activate()
	// implementation.
	ActivateCellCellArea(widget Widget, renderer CellRenderer, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) bool
	// AddCellArea adds @renderer to @area with the default child cell
	// properties.
	AddCellArea(renderer CellRenderer)
	// AddFocusSiblingCellArea adds @sibling to @renderers focusable area,
	// focus will be drawn around @renderer and all of its siblings if @renderer
	// can focus for a given row.
	//
	// Events handled by focus siblings can also activate the given focusable
	// @renderer.
	AddFocusSiblingCellArea(renderer CellRenderer, sibling CellRenderer)
	// ApplyAttributesCellArea applies any connected attributes to the renderers
	// in @area by pulling the values from @tree_model.
	ApplyAttributesCellArea(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// AttributeConnectCellArea connects an @attribute to apply values from
	// @column for the TreeModel in use.
	AttributeConnectCellArea(renderer CellRenderer, attribute string, column int)
	// AttributeDisconnectCellArea disconnects @attribute for the @renderer in
	// @area so that attribute will no longer be updated with values from the
	// model.
	AttributeDisconnectCellArea(renderer CellRenderer, attribute string)
	// AttributeGetColumnCellArea returns the model column that an attribute has
	// been mapped to, or -1 if the attribute is not mapped.
	AttributeGetColumnCellArea(renderer CellRenderer, attribute string) int
	// CellGetPropertyCellArea gets the value of a cell property for @renderer
	// in @area.
	CellGetPropertyCellArea(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CellSetPropertyCellArea sets a cell property for @renderer in @area.
	CellSetPropertyCellArea(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CopyContextCellArea: this is sometimes needed for cases where rows need
	// to share alignments in one orientation but may be separately grouped in
	// the opposing orientation.
	//
	// For instance, IconView creates all icons (rows) to have the same width
	// and the cells theirin to have the same horizontal alignments. However
	// each row of icons may have a separate collective height. IconView uses
	// this to request the heights of each row based on a context which was
	// already used to request all the row widths that are to be displayed.
	CopyContextCellArea(context CellAreaContext) CellAreaContext
	// CreateContextCellArea creates a CellAreaContext to be used with @area for
	// all purposes. CellAreaContext stores geometry information for rows for
	// which it was operated on, it is important to use the same context for the
	// same row of data at all times (i.e. one should render and handle events
	// with the same CellAreaContext which was used to request the size of those
	// rows of data).
	CreateContextCellArea() CellAreaContext
	// EventCellArea delegates event handling to a CellArea.
	EventCellArea(context CellAreaContext, widget Widget, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) int
	// FocusCellArea: this should be called by the @areas owning layout widget
	// when focus is to be passed to @area, or moved within @area for a given
	// @direction and row data.
	//
	// Implementing CellArea classes should implement this method to receive and
	// navigate focus in its own way particular to how it lays out cells.
	FocusCellArea(direction DirectionType) bool
	// CellAllocation derives the allocation of @renderer inside @area if @area
	// were to be renderered in @cell_area.
	CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle
	// CellAtPosition gets the CellRenderer at @x and @y coordinates inside
	// @area and optionally returns the full cell allocation for it inside
	// @cell_area.
	CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (gdk.Rectangle, CellRenderer)
	// CurrentPathString gets the current TreePath string for the currently
	// applied TreeIter, this is implicitly updated when
	// gtk_cell_area_apply_attributes() is called and can be used to interact
	// with renderers from CellArea subclasses.
	CurrentPathString() string
	// EditWidget gets the CellEditable widget currently used to edit the
	// currently edited cell.
	EditWidget() CellEditable
	// EditedCell gets the CellRenderer in @area that is currently being edited.
	EditedCell() CellRenderer
	// FocusCell retrieves the currently focused cell for @area
	FocusCell() CellRenderer
	// FocusFromSibling gets the CellRenderer which is expected to be focusable
	// for which @renderer is, or may be a sibling.
	//
	// This is handy for CellArea subclasses when handling events, after
	// determining the renderer at the event location it can then chose to
	// activate the focus cell for which the event cell may have been a sibling.
	FocusFromSibling(renderer CellRenderer) CellRenderer
	// PreferredHeight retrieves a cell areas initial minimum and natural
	// height.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, its not
	// important to check the @minimum_height and @natural_height of this call
	// but rather to consult gtk_cell_area_context_get_preferred_height() after
	// a series of requests.
	PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth retrieves a cell areas minimum and natural
	// height if it would be given the specified @width.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_width(). Its important to perform a
	// series of gtk_cell_area_get_preferred_width() requests with @context
	// first and then call gtk_cell_area_get_preferred_height_for_width() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the width of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_width() again and then the
	// full width of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_width().
	PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth retrieves a cell areas initial minimum and natural width.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, its not
	// important to check the @minimum_width and @natural_width of this call but
	// rather to consult gtk_cell_area_context_get_preferred_width() after a
	// series of requests.
	PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight retrieves a cell areas minimum and natural width
	// if it would be given the specified @height.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_height(). Its important to perform a
	// series of gtk_cell_area_get_preferred_height() requests with @context
	// first and then call gtk_cell_area_get_preferred_width_for_height() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the height of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_height() again and then the
	// full height of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_height().
	PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the area prefers a height-for-width layout or a
	// width-for-height layout.
	RequestMode() SizeRequestMode
	// HasRendererCellArea checks if @area contains @renderer.
	HasRendererCellArea(renderer CellRenderer) bool
	// InnerCellAreaCellArea: this is a convenience function for CellArea
	// implementations to get the inner area where a given CellRenderer will be
	// rendered. It removes any padding previously added by
	// gtk_cell_area_request_renderer().
	InnerCellAreaCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle
	// IsActivatableCellArea returns whether the area can do anything when
	// activated, after applying new attributes to @area.
	IsActivatableCellArea() bool
	// IsFocusSiblingCellArea returns whether @sibling is one of @renderers
	// focus siblings (see gtk_cell_area_add_focus_sibling()).
	IsFocusSiblingCellArea(renderer CellRenderer, sibling CellRenderer) bool
	// RemoveCellArea removes @renderer from @area.
	RemoveCellArea(renderer CellRenderer)
	// RemoveFocusSiblingCellArea removes @sibling from @renderers focus
	// sibling list (see gtk_cell_area_add_focus_sibling()).
	RemoveFocusSiblingCellArea(renderer CellRenderer, sibling CellRenderer)
	// RequestRendererCellArea: this is a convenience function for CellArea
	// implementations to request size for cell renderers. Its important to use
	// this function to request size and then use
	// gtk_cell_area_inner_cell_area() at render and event time since this
	// function will add padding around the cell for focus painting.
	RequestRendererCellArea(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int)
	// SetFocusCellCellArea: explicitly sets the currently focused cell to
	// @renderer.
	//
	// This is generally called by implementations of CellAreaClass.focus() or
	// CellAreaClass.event(), however it can also be used to implement functions
	// such as gtk_tree_view_set_cursor_on_cell().
	SetFocusCellCellArea(renderer CellRenderer)
	// SnapshotCellArea snapshots @areas cells according to @areas layout onto
	// at the given coordinates.
	SnapshotCellArea(context CellAreaContext, widget Widget, snapshot Snapshot, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
	// StopEditingCellArea: explicitly stops the editing of the currently edited
	// cell.
	//
	// If @canceled is true, the currently edited cell renderer will emit the
	// ::editing-canceled signal, otherwise the the ::editing-done signal will
	// be emitted on the current edit widget.
	//
	// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
	StopEditingCellArea(canceled bool)
}

// cellArea implements the CellArea class.
type cellArea struct {
	gextras.Objector
}

// WrapCellArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellArea(obj *externglib.Object) CellArea {
	return cellArea{
		Objector: obj,
	}
}

func marshalCellArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellArea(obj), nil
}

func (a cellArea) ActivateCellArea(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 C.GtkCellRendererState // out
	var _arg5 C.gboolean             // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg4 = (C.GtkCellRendererState)(flags)
	if editOnly {
		_arg5 = C.TRUE
	}

	_cret = C.gtk_cell_area_activate(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a cellArea) ActivateCellCellArea(widget Widget, renderer CellRenderer, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 *C.GtkCellRenderer     // out
	var _arg3 *C.GdkEvent            // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg3 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg5 = (C.GtkCellRendererState)(flags)

	_cret = C.gtk_cell_area_activate_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a cellArea) AddCellArea(renderer CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	C.gtk_cell_area_add(_arg0, _arg1)
}

func (a cellArea) AddFocusSiblingCellArea(renderer CellRenderer, sibling CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

	C.gtk_cell_area_add_focus_sibling(_arg0, _arg1, _arg2)
}

func (a cellArea) ApplyAttributesCellArea(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var _arg0 *C.GtkCellArea  // out
	var _arg1 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.gboolean      // out
	var _arg4 C.gboolean      // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	if isExpander {
		_arg3 = C.TRUE
	}
	if isExpanded {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_apply_attributes(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (a cellArea) AttributeConnectCellArea(renderer CellRenderer, attribute string, column int) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 C.int              // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.int)(column)

	C.gtk_cell_area_attribute_connect(_arg0, _arg1, _arg2, _arg3)
}

func (a cellArea) AttributeDisconnectCellArea(renderer CellRenderer, attribute string) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_cell_area_attribute_disconnect(_arg0, _arg1, _arg2)
}

func (a cellArea) AttributeGetColumnCellArea(renderer CellRenderer, attribute string) int {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _cret C.int              // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_cell_area_attribute_get_column(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (a cellArea) CellGetPropertyCellArea(renderer CellRenderer, propertyName string, value *externglib.Value) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 *C.GValue          // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.char)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	C.gtk_cell_area_cell_get_property(_arg0, _arg1, _arg2, _arg3)
}

func (a cellArea) CellSetPropertyCellArea(renderer CellRenderer, propertyName string, value *externglib.Value) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 *C.GValue          // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.char)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	C.gtk_cell_area_cell_set_property(_arg0, _arg1, _arg2, _arg3)
}

func (a cellArea) CopyContextCellArea(context CellAreaContext) CellAreaContext {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_cell_area_copy_context(_arg0, _arg1)

	var _cellAreaContext CellAreaContext // out

	_cellAreaContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(CellAreaContext)

	return _cellAreaContext
}

func (a cellArea) CreateContextCellArea() CellAreaContext {
	var _arg0 *C.GtkCellArea        // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_create_context(_arg0)

	var _cellAreaContext CellAreaContext // out

	_cellAreaContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(CellAreaContext)

	return _cellAreaContext
}

func (a cellArea) EventCellArea(context CellAreaContext, widget Widget, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) int {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkEvent            // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out
	var _cret C.int                  // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg5 = (C.GtkCellRendererState)(flags)

	_cret = C.gtk_cell_area_event(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (a cellArea) FocusCellArea(direction DirectionType) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (C.GtkDirectionType)(direction)

	_cret = C.gtk_cell_area_focus(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a cellArea) CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 *C.GtkCellRenderer    // out
	var _arg4 *C.GdkRectangle       // out
	var _allocation gdk.Rectangle

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	C.gtk_cell_area_get_cell_allocation(_arg0, _arg1, _arg2, _arg3, _arg4, (*C.GdkRectangle)(unsafe.Pointer(&_allocation)))

	return _allocation
}

func (a cellArea) CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (gdk.Rectangle, CellRenderer) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 *C.GdkRectangle       // out
	var _arg4 C.int                 // out
	var _arg5 C.int                 // out
	var _allocArea gdk.Rectangle
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg4 = (C.int)(x)
	_arg5 = (C.int)(y)

	_cret = C.gtk_cell_area_get_cell_at_position(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, (*C.GdkRectangle)(unsafe.Pointer(&_allocArea)))

	var _cellRenderer CellRenderer // out

	_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

	return _allocArea, _cellRenderer
}

func (a cellArea) CurrentPathString() string {
	var _arg0 *C.GtkCellArea // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_current_path_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a cellArea) EditWidget() CellEditable {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellEditable // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_edit_widget(_arg0)

	var _cellEditable CellEditable // out

	_cellEditable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellEditable)

	return _cellEditable
}

func (a cellArea) EditedCell() CellRenderer {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_edited_cell(_arg0)

	var _cellRenderer CellRenderer // out

	_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

	return _cellRenderer
}

func (a cellArea) FocusCell() CellRenderer {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_focus_cell(_arg0)

	var _cellRenderer CellRenderer // out

	_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

	return _cellRenderer
}

func (a cellArea) FocusFromSibling(renderer CellRenderer) CellRenderer {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	_cret = C.gtk_cell_area_get_focus_from_sibling(_arg0, _arg1)

	var _cellRenderer CellRenderer // out

	_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

	return _cellRenderer
}

func (a cellArea) PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // in
	var _arg4 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_area_get_preferred_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg3)
	_naturalHeight = (int)(_arg4)

	return _minimumHeight, _naturalHeight
}

func (a cellArea) PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // out
	var _arg4 C.int                 // in
	var _arg5 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (C.int)(width)

	C.gtk_cell_area_get_preferred_height_for_width(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg4)
	_naturalHeight = (int)(_arg5)

	return _minimumHeight, _naturalHeight
}

func (a cellArea) PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // in
	var _arg4 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_area_get_preferred_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg3)
	_naturalWidth = (int)(_arg4)

	return _minimumWidth, _naturalWidth
}

func (a cellArea) PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // out
	var _arg4 C.int                 // in
	var _arg5 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (C.int)(height)

	C.gtk_cell_area_get_preferred_width_for_height(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg4)
	_naturalWidth = (int)(_arg5)

	return _minimumWidth, _naturalWidth
}

func (a cellArea) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkCellArea       // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_request_mode(_arg0)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

func (a cellArea) HasRendererCellArea(renderer CellRenderer) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	_cret = C.gtk_cell_area_has_renderer(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a cellArea) InnerCellAreaCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle {
	var _arg0 *C.GtkCellArea  // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.GdkRectangle // out
	var _innerArea gdk.Rectangle

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	C.gtk_cell_area_inner_cell_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_innerArea)))

	return _innerArea
}

func (a cellArea) IsActivatableCellArea() bool {
	var _arg0 *C.GtkCellArea // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_is_activatable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a cellArea) IsFocusSiblingCellArea(renderer CellRenderer, sibling CellRenderer) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

	_cret = C.gtk_cell_area_is_focus_sibling(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a cellArea) RemoveCellArea(renderer CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	C.gtk_cell_area_remove(_arg0, _arg1)
}

func (a cellArea) RemoveFocusSiblingCellArea(renderer CellRenderer, sibling CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

	C.gtk_cell_area_remove_focus_sibling(_arg0, _arg1, _arg2)
}

func (a cellArea) RequestRendererCellArea(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.GtkOrientation   // out
	var _arg3 *C.GtkWidget       // out
	var _arg4 C.int              // out
	var _arg5 C.int              // in
	var _arg6 C.int              // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (C.GtkOrientation)(orientation)
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg4 = (C.int)(forSize)

	C.gtk_cell_area_request_renderer(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = (int)(_arg5)
	_naturalSize = (int)(_arg6)

	return _minimumSize, _naturalSize
}

func (a cellArea) SetFocusCellCellArea(renderer CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	C.gtk_cell_area_set_focus_cell(_arg0, _arg1)
}

func (a cellArea) SnapshotCellArea(context CellAreaContext, widget Widget, snapshot Snapshot, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool) {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GtkSnapshot         // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _arg7 C.gboolean             // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GtkSnapshot)(unsafe.Pointer(snapshot.Native()))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
	_arg5 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg6 = (C.GtkCellRendererState)(flags)
	if paintFocus {
		_arg7 = C.TRUE
	}

	C.gtk_cell_area_snapshot(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

func (a cellArea) StopEditingCellArea(canceled bool) {
	var _arg0 *C.GtkCellArea // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	if canceled {
		_arg1 = C.TRUE
	}

	C.gtk_cell_area_stop_editing(_arg0, _arg1)
}

func (b cellArea) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c cellArea) AddAttribute(cell CellRenderer, attribute string, column int) {
	WrapCellLayout(gextras.InternObject(c)).AddAttribute(cell, attribute, column)
}

func (c cellArea) Clear() {
	WrapCellLayout(gextras.InternObject(c)).Clear()
}

func (c cellArea) ClearAttributes(cell CellRenderer) {
	WrapCellLayout(gextras.InternObject(c)).ClearAttributes(cell)
}

func (c cellArea) Area() CellArea {
	return WrapCellLayout(gextras.InternObject(c)).Area()
}

func (c cellArea) PackEnd(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackEnd(cell, expand)
}

func (c cellArea) PackStart(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackStart(cell, expand)
}

func (c cellArea) Reorder(cell CellRenderer, position int) {
	WrapCellLayout(gextras.InternObject(c)).Reorder(cell, position)
}

// CellAreaBox: a cell area that renders GtkCellRenderers into a row or a column
//
// The CellAreaBox renders cell renderers into a row or a column depending on
// its Orientation.
//
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox. There are
// two reference positions: the start and the end of the box. When the
// CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
//
// Alignments of CellRenderers rendered in adjacent rows can be configured by
// configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
type CellAreaBox interface {
	CellArea
	Orientable

	// Spacing gets the spacing added between cell renderers.
	Spacing() int
	// PackEndCellAreaBox adds @renderer to @box, packed with reference to the
	// end of @box.
	//
	// The @renderer is packed after (away from end of) any other CellRenderer
	// packed with reference to the end of @box.
	PackEndCellAreaBox(renderer CellRenderer, expand bool, align bool, fixed bool)
	// PackStartCellAreaBox adds @renderer to @box, packed with reference to the
	// start of @box.
	//
	// The @renderer is packed after any other CellRenderer packed with
	// reference to the start of @box.
	PackStartCellAreaBox(renderer CellRenderer, expand bool, align bool, fixed bool)
	// SetSpacingCellAreaBox sets the spacing to add between cell renderers in
	// @box.
	SetSpacingCellAreaBox(spacing int)
}

// cellAreaBox implements the CellAreaBox class.
type cellAreaBox struct {
	CellArea
}

// WrapCellAreaBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaBox(obj *externglib.Object) CellAreaBox {
	return cellAreaBox{
		CellArea: WrapCellArea(obj),
	}
}

func marshalCellAreaBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaBox(obj), nil
}

// NewCellAreaBox creates a new CellAreaBox.
func NewCellAreaBox() CellAreaBox {
	var _cret *C.GtkCellArea // in

	_cret = C.gtk_cell_area_box_new()

	var _cellAreaBox CellAreaBox // out

	_cellAreaBox = WrapCellAreaBox(externglib.Take(unsafe.Pointer(_cret)))

	return _cellAreaBox
}

func (b cellAreaBox) Spacing() int {
	var _arg0 *C.GtkCellAreaBox // out
	var _cret C.int             // in

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_cell_area_box_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (b cellAreaBox) PackEndCellAreaBox(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var _arg0 *C.GtkCellAreaBox  // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out
	var _arg3 C.gboolean         // out
	var _arg4 C.gboolean         // out

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	if expand {
		_arg2 = C.TRUE
	}
	if align {
		_arg3 = C.TRUE
	}
	if fixed {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_box_pack_end(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (b cellAreaBox) PackStartCellAreaBox(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var _arg0 *C.GtkCellAreaBox  // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out
	var _arg3 C.gboolean         // out
	var _arg4 C.gboolean         // out

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	if expand {
		_arg2 = C.TRUE
	}
	if align {
		_arg3 = C.TRUE
	}
	if fixed {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_box_pack_start(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (b cellAreaBox) SetSpacingCellAreaBox(spacing int) {
	var _arg0 *C.GtkCellAreaBox // out
	var _arg1 C.int             // out

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(spacing)

	C.gtk_cell_area_box_set_spacing(_arg0, _arg1)
}

func (b cellAreaBox) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c cellAreaBox) AddAttribute(cell CellRenderer, attribute string, column int) {
	WrapCellLayout(gextras.InternObject(c)).AddAttribute(cell, attribute, column)
}

func (c cellAreaBox) Clear() {
	WrapCellLayout(gextras.InternObject(c)).Clear()
}

func (c cellAreaBox) ClearAttributes(cell CellRenderer) {
	WrapCellLayout(gextras.InternObject(c)).ClearAttributes(cell)
}

func (c cellAreaBox) Area() CellArea {
	return WrapCellLayout(gextras.InternObject(c)).Area()
}

func (c cellAreaBox) PackEnd(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackEnd(cell, expand)
}

func (c cellAreaBox) PackStart(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackStart(cell, expand)
}

func (c cellAreaBox) Reorder(cell CellRenderer, position int) {
	WrapCellLayout(gextras.InternObject(c)).Reorder(cell, position)
}

func (o cellAreaBox) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o cellAreaBox) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// CellAreaContext stores geometrical information for a series of rows in a
// GtkCellArea
//
// The CellAreaContext object is created by a given CellArea implementation via
// its CellAreaClass.create_context() virtual method and is used to store cell
// sizes and alignments for a series of TreeModel rows that are requested and
// rendered in the same context.
//
// CellLayout widgets can create any number of contexts in which to request and
// render groups of data rows. However, its important that the same context
// which was used to request sizes for a given TreeModel row also be used for
// the same row when calling other CellArea APIs such as gtk_cell_area_render()
// and gtk_cell_area_event().
type CellAreaContext interface {

	// AllocateCellAreaContext allocates a width and/or a height for all rows
	// which are to be rendered with @context.
	//
	// Usually allocation is performed only horizontally or sometimes vertically
	// since a group of rows are usually rendered side by side vertically or
	// horizontally and share either the same width or the same height.
	// Sometimes they are allocated in both horizontal and vertical orientations
	// producing a homogeneous effect of the rows. This is generally the case
	// for TreeView when TreeView:fixed-height-mode is enabled.
	AllocateCellAreaContext(width int, height int)
	// Allocation fetches the current allocation size for @context.
	//
	// If the context was not allocated in width or height, or if the context
	// was recently reset with gtk_cell_area_context_reset(), the returned value
	// will be -1.
	Allocation() (width int, height int)
	// Area fetches the CellArea this @context was created by.
	//
	// This is generally unneeded by layouting widgets; however, it is important
	// for the context implementation itself to fetch information about the area
	// it is being used for.
	//
	// For instance at CellAreaContextClass.allocate() time its important to
	// know details about any cell spacing that the CellArea is configured with
	// in order to compute a proper allocation.
	Area() CellArea
	// PreferredHeight gets the accumulative preferred height for all rows which
	// have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredHeight() (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth gets the accumulative preferred height for @width
	// for all rows which have been requested for the same said @width with this
	// context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth gets the accumulative preferred width for all rows which
	// have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredWidth() (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight gets the accumulative preferred width for @height
	// for all rows which have been requested for the same said @height with
	// this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int)
	// PushPreferredHeightCellAreaContext causes the minimum and/or natural
	// height to grow if the new proposed sizes exceed the current minimum and
	// natural height.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested height over a series of gtk_cell_area_get_preferred_height()
	// requests.
	PushPreferredHeightCellAreaContext(minimumHeight int, naturalHeight int)
	// PushPreferredWidthCellAreaContext causes the minimum and/or natural width
	// to grow if the new proposed sizes exceed the current minimum and natural
	// width.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested width over a series of gtk_cell_area_get_preferred_width()
	// requests.
	PushPreferredWidthCellAreaContext(minimumWidth int, naturalWidth int)
	// ResetCellAreaContext resets any previously cached request and allocation
	// data.
	//
	// When underlying TreeModel data changes its important to reset the context
	// if the content size is allowed to shrink. If the content size is only
	// allowed to grow (this is usually an option for views rendering large data
	// stores as a measure of optimization), then only the row that changed or
	// was inserted needs to be (re)requested with
	// gtk_cell_area_get_preferred_width().
	//
	// When the new overall size of the context requires that the allocated size
	// changes (or whenever this allocation changes at all), the variable row
	// sizes need to be re-requested for every row.
	//
	// For instance, if the rows are displayed all with the same width from top
	// to bottom then a change in the allocated width necessitates a
	// recalculation of all the displayed row heights using
	// gtk_cell_area_get_preferred_height_for_width().
	ResetCellAreaContext()
}

// cellAreaContext implements the CellAreaContext class.
type cellAreaContext struct {
	gextras.Objector
}

// WrapCellAreaContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaContext(obj *externglib.Object) CellAreaContext {
	return cellAreaContext{
		Objector: obj,
	}
}

func marshalCellAreaContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaContext(obj), nil
}

func (c cellAreaContext) AllocateCellAreaContext(width int, height int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(width)
	_arg2 = (C.int)(height)

	C.gtk_cell_area_context_allocate(_arg0, _arg1, _arg2)
}

func (c cellAreaContext) Allocation() (width int, height int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // in
	var _arg2 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	C.gtk_cell_area_context_get_allocation(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

func (c cellAreaContext) Area() CellArea {
	var _arg0 *C.GtkCellAreaContext // out
	var _cret *C.GtkCellArea        // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_area_context_get_area(_arg0)

	var _cellArea CellArea // out

	_cellArea = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellArea)

	return _cellArea
}

func (c cellAreaContext) PreferredHeight() (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // in
	var _arg2 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	C.gtk_cell_area_context_get_preferred_height(_arg0, &_arg1, &_arg2)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg1)
	_naturalHeight = (int)(_arg2)

	return _minimumHeight, _naturalHeight
}

func (c cellAreaContext) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // in
	var _arg3 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(width)

	C.gtk_cell_area_context_get_preferred_height_for_width(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg2)
	_naturalHeight = (int)(_arg3)

	return _minimumHeight, _naturalHeight
}

func (c cellAreaContext) PreferredWidth() (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // in
	var _arg2 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	C.gtk_cell_area_context_get_preferred_width(_arg0, &_arg1, &_arg2)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg1)
	_naturalWidth = (int)(_arg2)

	return _minimumWidth, _naturalWidth
}

func (c cellAreaContext) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // in
	var _arg3 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(height)

	C.gtk_cell_area_context_get_preferred_width_for_height(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg2)
	_naturalWidth = (int)(_arg3)

	return _minimumWidth, _naturalWidth
}

func (c cellAreaContext) PushPreferredHeightCellAreaContext(minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(minimumHeight)
	_arg2 = (C.int)(naturalHeight)

	C.gtk_cell_area_context_push_preferred_height(_arg0, _arg1, _arg2)
}

func (c cellAreaContext) PushPreferredWidthCellAreaContext(minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(minimumWidth)
	_arg2 = (C.int)(naturalWidth)

	C.gtk_cell_area_context_push_preferred_width(_arg0, _arg1, _arg2)
}

func (c cellAreaContext) ResetCellAreaContext() {
	var _arg0 *C.GtkCellAreaContext // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	C.gtk_cell_area_context_reset(_arg0)
}

// CellRenderer: an object for rendering a single cell
//
// The CellRenderer is a base class of a set of objects used for rendering a
// cell to a #cairo_t. These objects are used primarily by the TreeView widget,
// though they arent tied to them in any specific way. It is worth noting that
// CellRenderer is not a Widget and cannot be treated as such.
//
// The primary use of a CellRenderer is for drawing a certain graphical elements
// on a #cairo_t. Typically, one cell renderer is used to draw many cells on the
// screen. To this extent, it isnt expected that a CellRenderer keep any
// permanent state around. Instead, any state is set just prior to use using
// #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_preferred_size(). Finally, the cell is rendered in the
// correct location using gtk_cell_renderer_snapshot().
//
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, its important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
//
// Beyond merely rendering a cell, cell renderers can optionally provide active
// user interface elements. A cell renderer can be activatable like
// CellRendererToggle, which toggles when it gets activated by a mouse click, or
// it can be editable like CellRendererText, which allows the user to edit the
// text using a widget implementing the CellEditable interface, e.g. Entry. To
// make a cell renderer activatable or editable, you have to implement the
// CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
//
// Many properties of CellRenderer and its subclasses have a corresponding set
// property, e.g. cell-background-set corresponds to cell-background. These
// set properties reflect whether a property has been set or not. You should
// not set them independently.
type CellRenderer interface {

	// ActivateCellRenderer passes an activate event to the cell renderer for
	// possible processing. Some cell renderers may use events; for example,
	// CellRendererToggle toggles when it gets a mouse click.
	ActivateCellRenderer(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) bool
	// AlignedArea gets the aligned area used by @cell inside @cell_area. Used
	// for finding the appropriate edit and focus rectangle.
	AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle
	// Alignment fills in @xalign and @yalign with the appropriate values of
	// @cell.
	Alignment() (xalign float32, yalign float32)
	// FixedSize fills in @width and @height with the appropriate size of @cell.
	FixedSize() (width int, height int)
	// IsExpanded checks whether the given CellRenderer is expanded.
	IsExpanded() bool
	// IsExpander checks whether the given CellRenderer is an expander.
	IsExpander() bool
	// Padding fills in @xpad and @ypad with the appropriate values of @cell.
	Padding() (xpad int, ypad int)
	// PreferredHeight retrieves a renderers natural size when rendered to
	// @widget.
	PreferredHeight(widget Widget) (minimumSize int, naturalSize int)
	// PreferredHeightForWidth retrieves a cell rendererss minimum and natural
	// height if it were rendered to @widget with the specified @width.
	PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredSize retrieves the minimum and natural size of a cell taking
	// into account the widgets preference for height-for-width management.
	PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition)
	// PreferredWidth retrieves a renderers natural size when rendered to
	// @widget.
	PreferredWidth(widget Widget) (minimumSize int, naturalSize int)
	// PreferredWidthForHeight retrieves a cell rendererss minimum and natural
	// width if it were rendered to @widget with the specified @height.
	PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the cell renderer prefers a height-for-width
	// layout or a width-for-height layout.
	RequestMode() SizeRequestMode
	// Sensitive returns the cell renderers sensitivity.
	Sensitive() bool
	// State translates the cell renderer state to StateFlags, based on the cell
	// renderer and widget sensitivity, and the given CellRendererState.
	State(widget Widget, cellState CellRendererState) StateFlags
	// Visible returns the cell renderers visibility.
	Visible() bool
	// IsActivatableCellRenderer checks whether the cell renderer can do
	// something when activated.
	IsActivatableCellRenderer() bool
	// SetAlignmentCellRenderer sets the renderers alignment within its
	// available space.
	SetAlignmentCellRenderer(xalign float32, yalign float32)
	// SetFixedSizeCellRenderer sets the renderer size to be explicit,
	// independent of the properties set.
	SetFixedSizeCellRenderer(width int, height int)
	// SetIsExpandedCellRenderer sets whether the given CellRenderer is
	// expanded.
	SetIsExpandedCellRenderer(isExpanded bool)
	// SetIsExpanderCellRenderer sets whether the given CellRenderer is an
	// expander.
	SetIsExpanderCellRenderer(isExpander bool)
	// SetPaddingCellRenderer sets the renderers padding.
	SetPaddingCellRenderer(xpad int, ypad int)
	// SetSensitiveCellRenderer sets the cell renderers sensitivity.
	SetSensitiveCellRenderer(sensitive bool)
	// SetVisibleCellRenderer sets the cell renderers visibility.
	SetVisibleCellRenderer(visible bool)
	// SnapshotCellRenderer invokes the virtual render function of the
	// CellRenderer. The three passed-in rectangles are areas in @cr. Most
	// renderers will draw within @cell_area; the xalign, yalign, xpad, and ypad
	// fields of the CellRenderer should be honored with respect to @cell_area.
	// @background_area includes the blank space around the cell, and also the
	// area containing the tree expander; so the @background_area rectangles for
	// all cells tile to cover the entire @window.
	SnapshotCellRenderer(snapshot Snapshot, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState)
	// StartEditingCellRenderer starts editing the contents of this @cell,
	// through a new CellEditable widget created by the
	// CellRendererClass.start_editing virtual function.
	StartEditingCellRenderer(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) CellEditable
	// StopEditingCellRenderer informs the cell renderer that the editing is
	// stopped. If @canceled is true, the cell renderer will emit the
	// CellRenderer::editing-canceled signal.
	//
	// This function should be called by cell renderer implementations in
	// response to the CellEditable::editing-done signal of CellEditable.
	StopEditingCellRenderer(canceled bool)
}

// cellRenderer implements the CellRenderer class.
type cellRenderer struct {
	gextras.Objector
}

// WrapCellRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRenderer(obj *externglib.Object) CellRenderer {
	return cellRenderer{
		Objector: obj,
	}
}

func marshalCellRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRenderer(obj), nil
}

func (c cellRenderer) ActivateCellRenderer(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GdkEvent            // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.char                // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
	_arg5 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg6 = (C.GtkCellRendererState)(flags)

	_cret = C.gtk_cell_renderer_activate(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cellRenderer) AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkCellRendererState // out
	var _arg3 *C.GdkRectangle        // out
	var _alignedArea gdk.Rectangle

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkCellRendererState)(flags)
	_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	C.gtk_cell_renderer_get_aligned_area(_arg0, _arg1, _arg2, _arg3, (*C.GdkRectangle)(unsafe.Pointer(&_alignedArea)))

	return _alignedArea
}

func (c cellRenderer) Alignment() (xalign float32, yalign float32) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.float            // in
	var _arg2 C.float            // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	C.gtk_cell_renderer_get_alignment(_arg0, &_arg1, &_arg2)

	var _xalign float32 // out
	var _yalign float32 // out

	_xalign = (float32)(_arg1)
	_yalign = (float32)(_arg2)

	return _xalign, _yalign
}

func (c cellRenderer) FixedSize() (width int, height int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.int              // in
	var _arg2 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	C.gtk_cell_renderer_get_fixed_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

func (c cellRenderer) IsExpanded() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_get_is_expanded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cellRenderer) IsExpander() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_get_is_expander(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cellRenderer) Padding() (xpad int, ypad int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.int              // in
	var _arg2 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	C.gtk_cell_renderer_get_padding(_arg0, &_arg1, &_arg2)

	var _xpad int // out
	var _ypad int // out

	_xpad = (int)(_arg1)
	_ypad = (int)(_arg2)

	return _xpad, _ypad
}

func (c cellRenderer) PreferredHeight(widget Widget) (minimumSize int, naturalSize int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // in
	var _arg3 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_renderer_get_preferred_height(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = (int)(_arg2)
	_naturalSize = (int)(_arg3)

	return _minimumSize, _naturalSize
}

func (c cellRenderer) PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // out
	var _arg3 C.int              // in
	var _arg4 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.int)(width)

	C.gtk_cell_renderer_get_preferred_height_for_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg3)
	_naturalHeight = (int)(_arg4)

	return _minimumHeight, _naturalHeight
}

func (c cellRenderer) PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _minimumSize Requisition
	var _naturalSize Requisition

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_renderer_get_preferred_size(_arg0, _arg1, (*C.GtkRequisition)(unsafe.Pointer(&_minimumSize)), (*C.GtkRequisition)(unsafe.Pointer(&_naturalSize)))

	return _minimumSize, _naturalSize
}

func (c cellRenderer) PreferredWidth(widget Widget) (minimumSize int, naturalSize int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // in
	var _arg3 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_renderer_get_preferred_width(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = (int)(_arg2)
	_naturalSize = (int)(_arg3)

	return _minimumSize, _naturalSize
}

func (c cellRenderer) PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // out
	var _arg3 C.int              // in
	var _arg4 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.int)(height)

	C.gtk_cell_renderer_get_preferred_width_for_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg3)
	_naturalWidth = (int)(_arg4)

	return _minimumWidth, _naturalWidth
}

func (c cellRenderer) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkCellRenderer   // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_get_request_mode(_arg0)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

func (c cellRenderer) Sensitive() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_get_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cellRenderer) State(widget Widget, cellState CellRendererState) StateFlags {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkCellRendererState // out
	var _cret C.GtkStateFlags        // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkCellRendererState)(cellState)

	_cret = C.gtk_cell_renderer_get_state(_arg0, _arg1, _arg2)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

func (c cellRenderer) Visible() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cellRenderer) IsActivatableCellRenderer() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_is_activatable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cellRenderer) SetAlignmentCellRenderer(xalign float32, yalign float32) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (C.float)(xalign)
	_arg2 = (C.float)(yalign)

	C.gtk_cell_renderer_set_alignment(_arg0, _arg1, _arg2)
}

func (c cellRenderer) SetFixedSizeCellRenderer(width int, height int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(width)
	_arg2 = (C.int)(height)

	C.gtk_cell_renderer_set_fixed_size(_arg0, _arg1, _arg2)
}

func (c cellRenderer) SetIsExpandedCellRenderer(isExpanded bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	if isExpanded {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_is_expanded(_arg0, _arg1)
}

func (c cellRenderer) SetIsExpanderCellRenderer(isExpander bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	if isExpander {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_is_expander(_arg0, _arg1)
}

func (c cellRenderer) SetPaddingCellRenderer(xpad int, ypad int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(xpad)
	_arg2 = (C.int)(ypad)

	C.gtk_cell_renderer_set_padding(_arg0, _arg1, _arg2)
}

func (c cellRenderer) SetSensitiveCellRenderer(sensitive bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_sensitive(_arg0, _arg1)
}

func (c cellRenderer) SetVisibleCellRenderer(visible bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_visible(_arg0, _arg1)
}

func (c cellRenderer) SnapshotCellRenderer(snapshot Snapshot, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkSnapshot         // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkSnapshot)(unsafe.Pointer(snapshot.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg5 = (C.GtkCellRendererState)(flags)

	C.gtk_cell_renderer_snapshot(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (c cellRenderer) StartEditingCellRenderer(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) CellEditable {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GdkEvent            // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.char                // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _cret *C.GtkCellEditable     // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
	_arg5 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg6 = (C.GtkCellRendererState)(flags)

	_cret = C.gtk_cell_renderer_start_editing(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _cellEditable CellEditable // out

	_cellEditable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellEditable)

	return _cellEditable
}

func (c cellRenderer) StopEditingCellRenderer(canceled bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	if canceled {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_stop_editing(_arg0, _arg1)
}

// CellRendererAccel renders a keyboard accelerator in a cell
//
// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like `Control + a`). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
type CellRendererAccel interface {
}

// cellRendererAccel implements the CellRendererAccel class.
type cellRendererAccel struct {
	CellRendererText
}

// WrapCellRendererAccel wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererAccel(obj *externglib.Object) CellRendererAccel {
	return cellRendererAccel{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererAccel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererAccel(obj), nil
}

// NewCellRendererAccel creates a new CellRendererAccel.
func NewCellRendererAccel() CellRendererAccel {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_accel_new()

	var _cellRendererAccel CellRendererAccel // out

	_cellRendererAccel = WrapCellRendererAccel(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererAccel
}

// CellRendererCombo renders a combobox in a cell
//
// CellRendererCombo renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
//
// The combo cell renderer takes care of adding a text cell renderer to the
// combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
type CellRendererCombo interface {
}

// cellRendererCombo implements the CellRendererCombo class.
type cellRendererCombo struct {
	CellRendererText
}

// WrapCellRendererCombo wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererCombo(obj *externglib.Object) CellRendererCombo {
	return cellRendererCombo{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererCombo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererCombo(obj), nil
}

// NewCellRendererCombo creates a new CellRendererCombo. Adjust how text is
// drawn using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the text property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView.
func NewCellRendererCombo() CellRendererCombo {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_combo_new()

	var _cellRendererCombo CellRendererCombo // out

	_cellRendererCombo = WrapCellRendererCombo(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererCombo
}

// CellRendererPixbuf renders a pixbuf in a cell
//
// A CellRendererPixbuf can be used to render an image in a cell. It allows to
// render either a given Pixbuf (set via the CellRendererPixbuf:pixbuf property)
// or a named icon (set via the CellRendererPixbuf:icon-name property).
//
// To support the tree view, CellRendererPixbuf also supports rendering two
// alternative pixbufs, when the CellRenderer:is-expander property is true. If
// the CellRenderer:is-expanded property is true and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the CellRenderer:is-expanded property is false and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf, it
// renders that one.
type CellRendererPixbuf interface {
}

// cellRendererPixbuf implements the CellRendererPixbuf class.
type cellRendererPixbuf struct {
	CellRenderer
}

// WrapCellRendererPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererPixbuf(obj *externglib.Object) CellRendererPixbuf {
	return cellRendererPixbuf{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererPixbuf(obj), nil
}

// NewCellRendererPixbuf creates a new CellRendererPixbuf. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property to
// a value in a TreeModel. For example, you can bind the pixbuf property on
// the cell renderer to a pixbuf value in the model, thus rendering a different
// image in each row of the TreeView.
func NewCellRendererPixbuf() CellRendererPixbuf {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_pixbuf_new()

	var _cellRendererPixbuf CellRendererPixbuf // out

	_cellRendererPixbuf = WrapCellRendererPixbuf(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererPixbuf
}

// CellRendererProgress renders numbers as progress bars
//
// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
type CellRendererProgress interface {
	CellRenderer
	Orientable
}

// cellRendererProgress implements the CellRendererProgress class.
type cellRendererProgress struct {
	CellRenderer
}

// WrapCellRendererProgress wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererProgress(obj *externglib.Object) CellRendererProgress {
	return cellRendererProgress{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererProgress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererProgress(obj), nil
}

// NewCellRendererProgress creates a new CellRendererProgress.
func NewCellRendererProgress() CellRendererProgress {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_progress_new()

	var _cellRendererProgress CellRendererProgress // out

	_cellRendererProgress = WrapCellRendererProgress(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererProgress
}

func (o cellRendererProgress) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o cellRendererProgress) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// CellRendererSpin renders a spin button in a cell
//
// CellRendererSpin renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
//
// The range of the spinbutton is taken from the adjustment property of the cell
// renderer, which can be set explicitly or mapped to a column in the tree
// model, like all properties of cell renders. CellRendererSpin also has
// properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
//
// The CellRendererSpin cell renderer was added in GTK 2.10.
type CellRendererSpin interface {
}

// cellRendererSpin implements the CellRendererSpin class.
type cellRendererSpin struct {
	CellRendererText
}

// WrapCellRendererSpin wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpin(obj *externglib.Object) CellRendererSpin {
	return cellRendererSpin{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererSpin(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpin(obj), nil
}

// NewCellRendererSpin creates a new CellRendererSpin.
func NewCellRendererSpin() CellRendererSpin {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_spin_new()

	var _cellRendererSpin CellRendererSpin // out

	_cellRendererSpin = WrapCellRendererSpin(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererSpin
}

// CellRendererSpinner renders a spinning animation in a cell
//
// GtkCellRendererSpinner renders a spinning animation in a cell, very similar
// to Spinner. It can often be used as an alternative to a CellRendererProgress
// for displaying indefinite activity, instead of actual progress.
//
// To start the animation in a cell, set the CellRendererSpinner:active property
// to true and increment the CellRendererSpinner:pulse property at regular
// intervals. The usual way to set the cell renderer properties for each cell is
// to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
type CellRendererSpinner interface {
}

// cellRendererSpinner implements the CellRendererSpinner class.
type cellRendererSpinner struct {
	CellRenderer
}

// WrapCellRendererSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpinner(obj *externglib.Object) CellRendererSpinner {
	return cellRendererSpinner{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpinner(obj), nil
}

// NewCellRendererSpinner returns a new cell renderer which will show a spinner
// to indicate activity.
func NewCellRendererSpinner() CellRendererSpinner {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_spinner_new()

	var _cellRendererSpinner CellRendererSpinner // out

	_cellRendererSpinner = WrapCellRendererSpinner(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererSpinner
}

// CellRendererText renders text in a cell
//
// A CellRendererText renders a given text in its cell, using the font, color
// and style information provided by its properties. The text will be ellipsized
// if it is too long and the CellRendererText:ellipsize property allows it.
//
// If the CellRenderer:mode is GTK_CELL_RENDERER_MODE_EDITABLE, the
// CellRendererText allows to edit its text using an entry.
type CellRendererText interface {

	// SetFixedHeightFromFontCellRendererText sets the height of a renderer to
	// explicitly be determined by the font and y_pad property set on it.
	// Further changes in these properties do not affect the height, so they
	// must be accompanied by a subsequent call to this function. Using this
	// function is inflexible, and should really only be used if calculating the
	// size of a cell is too slow (ie, a massive number of cells displayed). If
	// @number_of_rows is -1, then the fixed height is unset, and the height is
	// determined by the properties again.
	SetFixedHeightFromFontCellRendererText(numberOfRows int)
}

// cellRendererText implements the CellRendererText class.
type cellRendererText struct {
	CellRenderer
}

// WrapCellRendererText wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererText(obj *externglib.Object) CellRendererText {
	return cellRendererText{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererText(obj), nil
}

// NewCellRendererText creates a new CellRendererText. Adjust how text is drawn
// using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the text property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView
func NewCellRendererText() CellRendererText {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_text_new()

	var _cellRendererText CellRendererText // out

	_cellRendererText = WrapCellRendererText(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererText
}

func (r cellRendererText) SetFixedHeightFromFontCellRendererText(numberOfRows int) {
	var _arg0 *C.GtkCellRendererText // out
	var _arg1 C.int                  // out

	_arg0 = (*C.GtkCellRendererText)(unsafe.Pointer(r.Native()))
	_arg1 = (C.int)(numberOfRows)

	C.gtk_cell_renderer_text_set_fixed_height_from_font(_arg0, _arg1)
}

// CellRendererToggle renders a toggle button in a cell
//
// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
type CellRendererToggle interface {

	// Activatable returns whether the cell renderer is activatable. See
	// gtk_cell_renderer_toggle_set_activatable().
	Activatable() bool
	// Active returns whether the cell renderer is active. See
	// gtk_cell_renderer_toggle_set_active().
	Active() bool
	// Radio returns whether were rendering radio toggles rather than
	// checkboxes.
	Radio() bool
	// SetActivatableCellRendererToggle makes the cell renderer activatable.
	SetActivatableCellRendererToggle(setting bool)
	// SetActiveCellRendererToggle activates or deactivates a cell renderer.
	SetActiveCellRendererToggle(setting bool)
	// SetRadioCellRendererToggle: if @radio is true, the cell renderer renders
	// a radio toggle (i.e. a toggle in a group of mutually-exclusive toggles).
	// If false, it renders a check toggle (a standalone boolean option). This
	// can be set globally for the cell renderer, or changed just before
	// rendering each cell in the model (for TreeView, you set up a per-row
	// setting using TreeViewColumn to associate model columns with cell
	// renderer properties).
	SetRadioCellRendererToggle(radio bool)
}

// cellRendererToggle implements the CellRendererToggle class.
type cellRendererToggle struct {
	CellRenderer
}

// WrapCellRendererToggle wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererToggle(obj *externglib.Object) CellRendererToggle {
	return cellRendererToggle{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererToggle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererToggle(obj), nil
}

// NewCellRendererToggle creates a new CellRendererToggle. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property to
// a value in a TreeModel. For example, you can bind the active property on
// the cell renderer to a boolean value in the model, thus causing the check
// button to reflect the state of the model.
func NewCellRendererToggle() CellRendererToggle {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_toggle_new()

	var _cellRendererToggle CellRendererToggle // out

	_cellRendererToggle = WrapCellRendererToggle(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererToggle
}

func (t cellRendererToggle) Activatable() bool {
	var _arg0 *C.GtkCellRendererToggle // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_cell_renderer_toggle_get_activatable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t cellRendererToggle) Active() bool {
	var _arg0 *C.GtkCellRendererToggle // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_cell_renderer_toggle_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t cellRendererToggle) Radio() bool {
	var _arg0 *C.GtkCellRendererToggle // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_cell_renderer_toggle_get_radio(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t cellRendererToggle) SetActivatableCellRendererToggle(setting bool) {
	var _arg0 *C.GtkCellRendererToggle // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_activatable(_arg0, _arg1)
}

func (t cellRendererToggle) SetActiveCellRendererToggle(setting bool) {
	var _arg0 *C.GtkCellRendererToggle // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_active(_arg0, _arg1)
}

func (t cellRendererToggle) SetRadioCellRendererToggle(radio bool) {
	var _arg0 *C.GtkCellRendererToggle // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if radio {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_radio(_arg0, _arg1)
}

// CellView: a widget displaying a single row of a GtkTreeModel
//
// A CellView displays a single row of a TreeModel using a CellArea and
// CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with each other (like the aligned cells in the menus of ComboBox).
//
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
//
//
// CSS nodes
//
// GtkCellView has a single CSS node with name cellview.
type CellView interface {
	Widget
	CellLayout
	Orientable

	// DisplayedRow returns a TreePath referring to the currently displayed row.
	// If no row is currently displayed, nil is returned.
	DisplayedRow() *TreePath
	// DrawSensitive gets whether @cell_view is configured to draw all of its
	// cells in a sensitive state.
	DrawSensitive() bool
	// FitModel gets whether @cell_view is configured to request space to fit
	// the entire TreeModel.
	FitModel() bool
	// Model returns the model for @cell_view. If no model is used nil is
	// returned.
	Model() TreeModel
	// SetDisplayedRowCellView sets the row of the model that is currently
	// displayed by the CellView. If the path is unset, then the contents of the
	// cellview stick at their last value; this is not normally a desired
	// result, but may be a needed intermediate state if say, the model for the
	// CellView becomes temporarily empty.
	SetDisplayedRowCellView(path *TreePath)
	// SetDrawSensitiveCellView sets whether @cell_view should draw all of its
	// cells in a sensitive state, this is used by ComboBox menus to ensure that
	// rows with insensitive cells that contain children appear sensitive in the
	// parent menu item.
	SetDrawSensitiveCellView(drawSensitive bool)
	// SetFitModelCellView sets whether @cell_view should request space to fit
	// the entire TreeModel.
	//
	// This is used by ComboBox to ensure that the cell view displayed on the
	// combo boxs button always gets enough space and does not resize when
	// selection changes.
	SetFitModelCellView(fitModel bool)
	// SetModelCellView sets the model for @cell_view. If @cell_view already has
	// a model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModelCellView(model TreeModel)
}

// cellView implements the CellView class.
type cellView struct {
	Widget
}

// WrapCellView wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellView(obj *externglib.Object) CellView {
	return cellView{
		Widget: WrapWidget(obj),
	}
}

func marshalCellView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellView(obj), nil
}

// NewCellView creates a new CellView widget.
func NewCellView() CellView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_cell_view_new()

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithContext creates a new CellView widget with a specific CellArea
// to layout cells and a specific CellAreaContext.
//
// Specifying the same context for a handful of cells lets the underlying area
// synchronize the geometry for those cells, in this way alignments with
// cellviews for other rows are possible.
func NewCellViewWithContext(area CellArea, context CellAreaContext) CellView {
	var _arg1 *C.GtkCellArea        // out
	var _arg2 *C.GtkCellAreaContext // out
	var _cret *C.GtkWidget          // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))
	_arg2 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_cell_view_new_with_context(_arg1, _arg2)

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithMarkup creates a new CellView widget, adds a CellRendererText
// to it, and makes it show @markup. The text can be marked up with the [Pango
// text markup language][PangoMarkupFormat].
func NewCellViewWithMarkup(markup string) CellView {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_cell_view_new_with_markup(_arg1)

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithText creates a new CellView widget, adds a CellRendererText to
// it, and makes it show @text.
func NewCellViewWithText(text string) CellView {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_cell_view_new_with_text(_arg1)

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithTexture creates a new CellView widget, adds a
// CellRendererPixbuf to it, and makes it show @texture.
func NewCellViewWithTexture(texture gdk.Texture) CellView {
	var _arg1 *C.GdkTexture // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))

	_cret = C.gtk_cell_view_new_with_texture(_arg1)

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

func (c cellView) DisplayedRow() *TreePath {
	var _arg0 *C.GtkCellView // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_view_get_displayed_row(_arg0)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

func (c cellView) DrawSensitive() bool {
	var _arg0 *C.GtkCellView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_view_get_draw_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cellView) FitModel() bool {
	var _arg0 *C.GtkCellView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_view_get_fit_model(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c cellView) Model() TreeModel {
	var _arg0 *C.GtkCellView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_view_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

func (c cellView) SetDisplayedRowCellView(path *TreePath) {
	var _arg0 *C.GtkCellView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_cell_view_set_displayed_row(_arg0, _arg1)
}

func (c cellView) SetDrawSensitiveCellView(drawSensitive bool) {
	var _arg0 *C.GtkCellView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	if drawSensitive {
		_arg1 = C.TRUE
	}

	C.gtk_cell_view_set_draw_sensitive(_arg0, _arg1)
}

func (c cellView) SetFitModelCellView(fitModel bool) {
	var _arg0 *C.GtkCellView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	if fitModel {
		_arg1 = C.TRUE
	}

	C.gtk_cell_view_set_fit_model(_arg0, _arg1)
}

func (c cellView) SetModelCellView(model TreeModel) {
	var _arg0 *C.GtkCellView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_cell_view_set_model(_arg0, _arg1)
}

func (s cellView) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s cellView) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s cellView) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s cellView) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s cellView) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s cellView) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s cellView) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b cellView) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c cellView) AddAttribute(cell CellRenderer, attribute string, column int) {
	WrapCellLayout(gextras.InternObject(c)).AddAttribute(cell, attribute, column)
}

func (c cellView) Clear() {
	WrapCellLayout(gextras.InternObject(c)).Clear()
}

func (c cellView) ClearAttributes(cell CellRenderer) {
	WrapCellLayout(gextras.InternObject(c)).ClearAttributes(cell)
}

func (c cellView) Area() CellArea {
	return WrapCellLayout(gextras.InternObject(c)).Area()
}

func (c cellView) PackEnd(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackEnd(cell, expand)
}

func (c cellView) PackStart(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackStart(cell, expand)
}

func (c cellView) Reorder(cell CellRenderer, position int) {
	WrapCellLayout(gextras.InternObject(c)).Reorder(cell, position)
}

func (o cellView) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o cellView) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// CenterBox: `GtkCenterBox` arranges three children in a row, keeping the
// middle child centered as well as possible.
//
// !An example GtkCenterBox (centerbox.png)
//
// To add children to `GtkCenterBox`, use
// [method@Gtk.CenterBox.set_start_widget],
// [method@Gtk.CenterBox.set_center_widget] and
// [method@Gtk.CenterBox.set_end_widget].
//
// The sizing and positioning of children can be influenced with the align and
// expand properties of the children.
//
//
// GtkCenterBox as GtkBuildable
//
// The `GtkCenterBox` implementation of the `GtkBuildable` interface supports
// placing children in the 3 positions by specifying start, center or end
// as the type attribute of a <child> element.
//
//
// CSS nodes
//
// `GtkCenterBox` uses a single CSS node with the name box,
//
// The first child of the `GtkCenterBox` will be allocated depending on the text
// direction, i.e. in left-to-right layouts it will be allocated on the left and
// in right-to-left layouts on the right.
//
// In vertical orientation, the nodes of the children are arranged from top to
// bottom.
//
//
// Accessibility
//
// `GtkCenterBox` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type CenterBox interface {
	Widget
	Orientable

	// BaselinePosition gets the value set by
	// gtk_center_box_set_baseline_position().
	BaselinePosition() BaselinePosition
	// CenterWidget gets the center widget, or nil if there is none.
	CenterWidget() Widget
	// EndWidget gets the end widget, or nil if there is none.
	EndWidget() Widget
	// StartWidget gets the start widget, or nil if there is none.
	StartWidget() Widget
	// SetBaselinePositionCenterBox sets the baseline position of a center box.
	//
	// This affects only horizontal boxes with at least one baseline aligned
	// child. If there is more vertical space available than requested, and the
	// baseline is not allocated by the parent then @position is used to
	// allocate the baseline wrt. the extra space available.
	SetBaselinePositionCenterBox(position BaselinePosition)
	// SetCenterWidgetCenterBox sets the center widget.
	//
	// To remove the existing center widget, pas nil.
	SetCenterWidgetCenterBox(child Widget)
	// SetEndWidgetCenterBox sets the end widget.
	//
	// To remove the existing end widget, pass nil.
	SetEndWidgetCenterBox(child Widget)
	// SetStartWidgetCenterBox sets the start widget.
	//
	// To remove the existing start widget, pass nil.
	SetStartWidgetCenterBox(child Widget)
}

// centerBox implements the CenterBox class.
type centerBox struct {
	Widget
}

// WrapCenterBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapCenterBox(obj *externglib.Object) CenterBox {
	return centerBox{
		Widget: WrapWidget(obj),
	}
}

func marshalCenterBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCenterBox(obj), nil
}

// NewCenterBox creates a new `GtkCenterBox`.
func NewCenterBox() CenterBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_center_box_new()

	var _centerBox CenterBox // out

	_centerBox = WrapCenterBox(externglib.Take(unsafe.Pointer(_cret)))

	return _centerBox
}

func (s centerBox) BaselinePosition() BaselinePosition {
	var _arg0 *C.GtkCenterBox       // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_center_box_get_baseline_position(_arg0)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

func (s centerBox) CenterWidget() Widget {
	var _arg0 *C.GtkCenterBox // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_center_box_get_center_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s centerBox) EndWidget() Widget {
	var _arg0 *C.GtkCenterBox // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_center_box_get_end_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s centerBox) StartWidget() Widget {
	var _arg0 *C.GtkCenterBox // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_center_box_get_start_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s centerBox) SetBaselinePositionCenterBox(position BaselinePosition) {
	var _arg0 *C.GtkCenterBox       // out
	var _arg1 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkBaselinePosition)(position)

	C.gtk_center_box_set_baseline_position(_arg0, _arg1)
}

func (s centerBox) SetCenterWidgetCenterBox(child Widget) {
	var _arg0 *C.GtkCenterBox // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_center_box_set_center_widget(_arg0, _arg1)
}

func (s centerBox) SetEndWidgetCenterBox(child Widget) {
	var _arg0 *C.GtkCenterBox // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_center_box_set_end_widget(_arg0, _arg1)
}

func (s centerBox) SetStartWidgetCenterBox(child Widget) {
	var _arg0 *C.GtkCenterBox // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_center_box_set_start_widget(_arg0, _arg1)
}

func (s centerBox) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s centerBox) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s centerBox) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s centerBox) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s centerBox) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s centerBox) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s centerBox) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b centerBox) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o centerBox) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o centerBox) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// CenterLayout: `GtkCenterLayout` is a layout manager that manages up to three
// children.
//
// The start widget is allocated at the start of the layout (left in
// left-to-right locales and right in right-to-left ones), and the end widget at
// the end.
//
// The center widget is centered regarding the full width of the layout's.
type CenterLayout interface {

	// BaselinePosition returns the baseline position of the layout.
	BaselinePosition() BaselinePosition
	// CenterWidget returns the center widget of the layout.
	CenterWidget() Widget
	// EndWidget returns the end widget of the layout.
	EndWidget() Widget
	// Orientation gets the current orienration of the layout manager.
	Orientation() Orientation
	// StartWidget returns the start widget fo the layout.
	StartWidget() Widget
	// SetBaselinePositionCenterLayout sets the new baseline position of @self
	SetBaselinePositionCenterLayout(baselinePosition BaselinePosition)
	// SetCenterWidgetCenterLayout sets the new center widget of @self.
	//
	// To remove the existing center widget, pass nil.
	SetCenterWidgetCenterLayout(widget Widget)
	// SetEndWidgetCenterLayout sets the new end widget of @self.
	//
	// To remove the existing center widget, pass nil.
	SetEndWidgetCenterLayout(widget Widget)
	// SetOrientationCenterLayout sets the orientation of @self.
	SetOrientationCenterLayout(orientation Orientation)
	// SetStartWidgetCenterLayout sets the new start widget of @self.
	//
	// To remove the existing start widget, pass nil.
	SetStartWidgetCenterLayout(widget Widget)
}

// centerLayout implements the CenterLayout class.
type centerLayout struct {
	LayoutManager
}

// WrapCenterLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapCenterLayout(obj *externglib.Object) CenterLayout {
	return centerLayout{
		LayoutManager: WrapLayoutManager(obj),
	}
}

func marshalCenterLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCenterLayout(obj), nil
}

// NewCenterLayout creates a new `GtkCenterLayout`.
func NewCenterLayout() CenterLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_center_layout_new()

	var _centerLayout CenterLayout // out

	_centerLayout = WrapCenterLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _centerLayout
}

func (s centerLayout) BaselinePosition() BaselinePosition {
	var _arg0 *C.GtkCenterLayout    // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_center_layout_get_baseline_position(_arg0)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

func (s centerLayout) CenterWidget() Widget {
	var _arg0 *C.GtkCenterLayout // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_center_layout_get_center_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s centerLayout) EndWidget() Widget {
	var _arg0 *C.GtkCenterLayout // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_center_layout_get_end_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s centerLayout) Orientation() Orientation {
	var _arg0 *C.GtkCenterLayout // out
	var _cret C.GtkOrientation   // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_center_layout_get_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

func (s centerLayout) StartWidget() Widget {
	var _arg0 *C.GtkCenterLayout // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_center_layout_get_start_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s centerLayout) SetBaselinePositionCenterLayout(baselinePosition BaselinePosition) {
	var _arg0 *C.GtkCenterLayout    // out
	var _arg1 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkBaselinePosition)(baselinePosition)

	C.gtk_center_layout_set_baseline_position(_arg0, _arg1)
}

func (s centerLayout) SetCenterWidgetCenterLayout(widget Widget) {
	var _arg0 *C.GtkCenterLayout // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_center_layout_set_center_widget(_arg0, _arg1)
}

func (s centerLayout) SetEndWidgetCenterLayout(widget Widget) {
	var _arg0 *C.GtkCenterLayout // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_center_layout_set_end_widget(_arg0, _arg1)
}

func (s centerLayout) SetOrientationCenterLayout(orientation Orientation) {
	var _arg0 *C.GtkCenterLayout // out
	var _arg1 C.GtkOrientation   // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	C.gtk_center_layout_set_orientation(_arg0, _arg1)
}

func (s centerLayout) SetStartWidgetCenterLayout(widget Widget) {
	var _arg0 *C.GtkCenterLayout // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_center_layout_set_start_widget(_arg0, _arg1)
}

// CheckButton: a `GtkCheckButton` places a label next to an indicator.
//
// !Example GtkCheckButtons (check-button.png)
//
// A `GtkCheckButton` is created by calling either [ctor@Gtk.CheckButton.new] or
// [ctor@Gtk.CheckButton.new_with_label].
//
// The state of a `GtkCheckButton` can be set specifically using
// [method@Gtk.CheckButton.set_active], and retrieved using
// [method@Gtk.CheckButton.get_active].
//
//
// Inconsistent state
//
// In addition to "on" and "off", check buttons can be an "in between" state
// that is neither on nor off. This can be used e.g. when the user has selected
// a range of elements (such as some text or spreadsheet cells) that are
// affected by a check button, and the current values in that range are
// inconsistent.
//
// To set a `GtkCheckButton` to inconsistent state, use
// [method@Gtk.CheckButton.set_inconsistent].
//
//
// Grouping
//
// Check buttons can be grouped together, to form mutually exclusive groups -
// only one of the buttons can be toggled at a time, and toggling another one
// will switch the currently toggled one off.
//
// Grouped check buttons use a different indicator, and are commonly referred to
// as *radio buttons*.
//
// !Example GtkCheckButtons (radio-button.png)
//
// To add a `GtkCheckButton` to a group, use [method@Gtk.CheckButton.set_group].
//
//
// CSS nodes
//
// ` checkbutton[.text-button]  check  [label] `
//
// A `GtkCheckButton` has a main node with name checkbutton. If the
// [property@Gtk.CheckButton:label] property is set, it contains a label child.
// The indicator node is named check when no group is set, and radio if the
// checkbutton is grouped together with other checkbuttons.
//
//
// Accessibility
//
// `GtkCheckButton` uses the GTK_ACCESSIBLE_ROLE_CHECKBOX role.
type CheckButton interface {
	Actionable

	// Active returns whether the check button is active.
	Active() bool
	// Inconsistent returns whether the check button is in an inconsistent
	// state.
	Inconsistent() bool
	// Label returns the label of the check button.
	Label() string
	// UseUnderline returns whether underlines in the label indicate mnemonics.
	UseUnderline() bool
	// SetActiveCheckButton changes the check buttons active state.
	SetActiveCheckButton(setting bool)
	// SetGroupCheckButton adds @self to the group of @group.
	//
	// In a group of multiple check buttons, only one button can be active at a
	// time. The behavior of a checkbutton in a group is also commonly known as
	// a *radio button*.
	//
	// Setting the group of a check button also changes the css name of the
	// indicator widget's CSS node to 'radio'.
	//
	// Setting up groups in a cycle leads to undefined behavior.
	//
	// Note that the same effect can be achieved via the
	// [interface@Gtk.Actionable] API, by using the same action with parameter
	// type and state type 's' for all buttons in the group, and giving each
	// button its own target value.
	SetGroupCheckButton(group CheckButton)
	// SetInconsistentCheckButton sets the `GtkCheckButton` to inconsistent
	// state.
	//
	// You shoud turn off the inconsistent state again if the user checks the
	// check button. This has to be done manually.
	SetInconsistentCheckButton(inconsistent bool)
	// SetLabelCheckButton sets the text of @self.
	//
	// If [property@Gtk.CheckButton:use-underline] is true, an underscore in
	// @label is interpreted as mnemonic indicator, see
	// [method@Gtk.CheckButton.set_use_underline] for details on this behavior.
	SetLabelCheckButton(label string)
	// SetUseUnderlineCheckButton sets whether underlines in the label indicate
	// mnemonics.
	//
	// If @setting is true, an underscore character in @self's label indicates a
	// mnemonic accelerator key. This behavior is similar to
	// [property@Gtk.Label:use-underline].
	SetUseUnderlineCheckButton(setting bool)
}

// checkButton implements the CheckButton class.
type checkButton struct {
	Widget
}

// WrapCheckButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapCheckButton(obj *externglib.Object) CheckButton {
	return checkButton{
		Widget: WrapWidget(obj),
	}
}

func marshalCheckButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCheckButton(obj), nil
}

// NewCheckButton creates a new `GtkCheckButton`.
func NewCheckButton() CheckButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_check_button_new()

	var _checkButton CheckButton // out

	_checkButton = WrapCheckButton(externglib.Take(unsafe.Pointer(_cret)))

	return _checkButton
}

// NewCheckButtonWithLabel creates a new `GtkCheckButton` with the given text.
func NewCheckButtonWithLabel(label string) CheckButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_check_button_new_with_label(_arg1)

	var _checkButton CheckButton // out

	_checkButton = WrapCheckButton(externglib.Take(unsafe.Pointer(_cret)))

	return _checkButton
}

// NewCheckButtonWithMnemonic creates a new `GtkCheckButton` with the given text
// and a mnemonic.
func NewCheckButtonWithMnemonic(label string) CheckButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_check_button_new_with_mnemonic(_arg1)

	var _checkButton CheckButton // out

	_checkButton = WrapCheckButton(externglib.Take(unsafe.Pointer(_cret)))

	return _checkButton
}

func (s checkButton) Active() bool {
	var _arg0 *C.GtkCheckButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_check_button_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c checkButton) Inconsistent() bool {
	var _arg0 *C.GtkCheckButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_check_button_get_inconsistent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s checkButton) Label() string {
	var _arg0 *C.GtkCheckButton // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_check_button_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s checkButton) UseUnderline() bool {
	var _arg0 *C.GtkCheckButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_check_button_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s checkButton) SetActiveCheckButton(setting bool) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_check_button_set_active(_arg0, _arg1)
}

func (s checkButton) SetGroupCheckButton(group CheckButton) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 *C.GtkCheckButton // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkCheckButton)(unsafe.Pointer(group.Native()))

	C.gtk_check_button_set_group(_arg0, _arg1)
}

func (c checkButton) SetInconsistentCheckButton(inconsistent bool) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(c.Native()))
	if inconsistent {
		_arg1 = C.TRUE
	}

	C.gtk_check_button_set_inconsistent(_arg0, _arg1)
}

func (s checkButton) SetLabelCheckButton(label string) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_check_button_set_label(_arg0, _arg1)
}

func (s checkButton) SetUseUnderlineCheckButton(setting bool) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_check_button_set_use_underline(_arg0, _arg1)
}

func (s checkButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s checkButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s checkButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s checkButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s checkButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s checkButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s checkButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (a checkButton) ActionName() string {
	return WrapActionable(gextras.InternObject(a)).ActionName()
}

func (a checkButton) ActionTargetValue() *glib.Variant {
	return WrapActionable(gextras.InternObject(a)).ActionTargetValue()
}

func (a checkButton) SetActionName(actionName string) {
	WrapActionable(gextras.InternObject(a)).SetActionName(actionName)
}

func (a checkButton) SetActionTargetValue(targetValue *glib.Variant) {
	WrapActionable(gextras.InternObject(a)).SetActionTargetValue(targetValue)
}

func (a checkButton) SetDetailedActionName(detailedActionName string) {
	WrapActionable(gextras.InternObject(a)).SetDetailedActionName(detailedActionName)
}

func (b checkButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// ClosureExpression: an expression using a custom `GClosure` to compute the
// value from its parameters.
type ClosureExpression interface {
}

// closureExpression implements the ClosureExpression class.
type closureExpression struct {
	Expression
}

// WrapClosureExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapClosureExpression(obj *externglib.Object) ClosureExpression {
	return closureExpression{
		Expression: WrapExpression(obj),
	}
}

func marshalClosureExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClosureExpression(obj), nil
}

// ColorButton: the `GtkColorButton` allows to open a color chooser dialog to
// change the color.
//
// !An example GtkColorButton (color-button.png)
//
// It is suitable widget for selecting a color in a preference dialog.
//
//
// CSS nodes
//
// ` colorbutton  button.color  [content] `
//
// `GtkColorButton` has a single CSS node with name colorbutton which contains a
// button node. To differentiate it from a plain `GtkButton`, it gets the .color
// style class.
type ColorButton interface {
	Widget
	ColorChooser

	// Modal gets whether the dialog is modal.
	Modal() bool
	// Title gets the title of the color chooser dialog.
	Title() string
	// SetModalColorButton sets whether the dialog should be modal.
	SetModalColorButton(modal bool)
	// SetTitleColorButton sets the title for the color chooser dialog.
	SetTitleColorButton(title string)
}

// colorButton implements the ColorButton class.
type colorButton struct {
	Widget
}

// WrapColorButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorButton(obj *externglib.Object) ColorButton {
	return colorButton{
		Widget: WrapWidget(obj),
	}
}

func marshalColorButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorButton(obj), nil
}

// NewColorButton creates a new color button.
//
// This returns a widget in the form of a small button containing a swatch
// representing the current selected color. When the button is clicked, a color
// chooser dialog will open, allowing the user to select a color. The swatch
// will be updated to reflect the new color when the user finishes.
func NewColorButton() ColorButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_color_button_new()

	var _colorButton ColorButton // out

	_colorButton = WrapColorButton(externglib.Take(unsafe.Pointer(_cret)))

	return _colorButton
}

// NewColorButtonWithRGBA creates a new color button showing the given color.
func NewColorButtonWithRGBA(rgba *gdk.RGBA) ColorButton {
	var _arg1 *C.GdkRGBA   // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

	_cret = C.gtk_color_button_new_with_rgba(_arg1)

	var _colorButton ColorButton // out

	_colorButton = WrapColorButton(externglib.Take(unsafe.Pointer(_cret)))

	return _colorButton
}

func (b colorButton) Modal() bool {
	var _arg0 *C.GtkColorButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_color_button_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b colorButton) Title() string {
	var _arg0 *C.GtkColorButton // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_color_button_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (b colorButton) SetModalColorButton(modal bool) {
	var _arg0 *C.GtkColorButton // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_color_button_set_modal(_arg0, _arg1)
}

func (b colorButton) SetTitleColorButton(title string) {
	var _arg0 *C.GtkColorButton // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_color_button_set_title(_arg0, _arg1)
}

func (s colorButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s colorButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s colorButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s colorButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s colorButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s colorButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s colorButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b colorButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c colorButton) AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA) {
	WrapColorChooser(gextras.InternObject(c)).AddPalette(orientation, colorsPerLine, colors)
}

func (c colorButton) RGBA() gdk.RGBA {
	return WrapColorChooser(gextras.InternObject(c)).RGBA()
}

func (c colorButton) UseAlpha() bool {
	return WrapColorChooser(gextras.InternObject(c)).UseAlpha()
}

func (c colorButton) SetRGBA(color *gdk.RGBA) {
	WrapColorChooser(gextras.InternObject(c)).SetRGBA(color)
}

func (c colorButton) SetUseAlpha(useAlpha bool) {
	WrapColorChooser(gextras.InternObject(c)).SetUseAlpha(useAlpha)
}

// ColorChooserDialog: a dialog for choosing a color.
//
// !An example GtkColorChooserDialog (colorchooser.png)
//
// `GtkColorChooserDialog` implements the [iface@Gtk.ColorChooser] interface and
// does not provide much API of its own.
//
// To create a `GtkColorChooserDialog`, use [ctor@Gtk.ColorChooserDialog.new].
//
// To change the initially selected color, use
// [method@Gtk.ColorChooser.set_rgba]. To get the selected color use
// [method@Gtk.ColorChooser.get_rgba].
type ColorChooserDialog interface {
	Dialog
	ColorChooser
}

// colorChooserDialog implements the ColorChooserDialog class.
type colorChooserDialog struct {
	Dialog
}

// WrapColorChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserDialog(obj *externglib.Object) ColorChooserDialog {
	return colorChooserDialog{
		Dialog: WrapDialog(obj),
	}
}

func marshalColorChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserDialog(obj), nil
}

// NewColorChooserDialog creates a new `GtkColorChooserDialog`.
func NewColorChooserDialog(title string, parent Window) ColorChooserDialog {
	var _arg1 *C.char      // out
	var _arg2 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_color_chooser_dialog_new(_arg1, _arg2)

	var _colorChooserDialog ColorChooserDialog // out

	_colorChooserDialog = WrapColorChooserDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _colorChooserDialog
}

func (s colorChooserDialog) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s colorChooserDialog) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s colorChooserDialog) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s colorChooserDialog) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s colorChooserDialog) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s colorChooserDialog) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s colorChooserDialog) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b colorChooserDialog) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c colorChooserDialog) AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA) {
	WrapColorChooser(gextras.InternObject(c)).AddPalette(orientation, colorsPerLine, colors)
}

func (c colorChooserDialog) RGBA() gdk.RGBA {
	return WrapColorChooser(gextras.InternObject(c)).RGBA()
}

func (c colorChooserDialog) UseAlpha() bool {
	return WrapColorChooser(gextras.InternObject(c)).UseAlpha()
}

func (c colorChooserDialog) SetRGBA(color *gdk.RGBA) {
	WrapColorChooser(gextras.InternObject(c)).SetRGBA(color)
}

func (c colorChooserDialog) SetUseAlpha(useAlpha bool) {
	WrapColorChooser(gextras.InternObject(c)).SetUseAlpha(useAlpha)
}

func (s colorChooserDialog) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s colorChooserDialog) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s colorChooserDialog) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s colorChooserDialog) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s colorChooserDialog) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s colorChooserDialog) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s colorChooserDialog) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s colorChooserDialog) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// ColorChooserWidget: the `GtkColorChooserWidget` widget lets the user select a
// color.
//
// By default, the chooser presents a predefined palette of colors, plus a small
// number of settable custom colors. It is also possible to select a different
// color with the single-color editor.
//
// To enter the single-color editing mode, use the context menu of any color of
// the palette, or use the '+' button to add a new custom color.
//
// The chooser automatically remembers the last selection, as well as custom
// colors.
//
// To create a `GtkColorChooserWidget`, use [ctor@Gtk.ColorChooserWidget.new].
//
// To change the initially selected color, use
// [method@Gtk.ColorChooser.set_rgba]. To get the selected color use
// [method@Gtk.ColorChooser.get_rgba].
//
// The `GtkColorChooserWidget` is used in the [class@Gtk.ColorChooserDialog] to
// provide a dialog for selecting colors.
//
//
// CSS names
//
// `GtkColorChooserWidget` has a single CSS node with name colorchooser.
type ColorChooserWidget interface {
	Widget
	ColorChooser
}

// colorChooserWidget implements the ColorChooserWidget class.
type colorChooserWidget struct {
	Widget
}

// WrapColorChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserWidget(obj *externglib.Object) ColorChooserWidget {
	return colorChooserWidget{
		Widget: WrapWidget(obj),
	}
}

func marshalColorChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserWidget(obj), nil
}

// NewColorChooserWidget creates a new `GtkColorChooserWidget`.
func NewColorChooserWidget() ColorChooserWidget {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_color_chooser_widget_new()

	var _colorChooserWidget ColorChooserWidget // out

	_colorChooserWidget = WrapColorChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _colorChooserWidget
}

func (s colorChooserWidget) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s colorChooserWidget) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s colorChooserWidget) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s colorChooserWidget) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s colorChooserWidget) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s colorChooserWidget) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s colorChooserWidget) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b colorChooserWidget) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c colorChooserWidget) AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA) {
	WrapColorChooser(gextras.InternObject(c)).AddPalette(orientation, colorsPerLine, colors)
}

func (c colorChooserWidget) RGBA() gdk.RGBA {
	return WrapColorChooser(gextras.InternObject(c)).RGBA()
}

func (c colorChooserWidget) UseAlpha() bool {
	return WrapColorChooser(gextras.InternObject(c)).UseAlpha()
}

func (c colorChooserWidget) SetRGBA(color *gdk.RGBA) {
	WrapColorChooser(gextras.InternObject(c)).SetRGBA(color)
}

func (c colorChooserWidget) SetUseAlpha(useAlpha bool) {
	WrapColorChooser(gextras.InternObject(c)).SetUseAlpha(useAlpha)
}

// ColumnView: `GtkColumnView` presents a large dynamic list of items using
// multiple columns with headers.
//
// `GtkColumnView` uses the factories of its columns to generate a cell widget
// for each column, for each visible item and displays them together as the row
// for this item.
//
// The [property@Gtk.ColumnView:show-row-separators] and
// [propertyGtk.ColumnView:show-column-separators] properties offer a simple way
// to display separators between the rows or columns.
//
// `GtkColumnView` allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on *rubberband selection*, using
// [property@Gtk.ColumnView:enable-rubberband].
//
// The column view supports sorting that can be customized by the user by
// clicking on column headers. To set this up, the `GtkSorter` returned by
// [method@Gtk.ColumnView.get_sorter] must be attached to a sort model for the
// data that the view is showing, and the columns must have sorters attached to
// them by calling [method@Gtk.ColumnViewColumn.set_sorter]. The initial sort
// order can be set with [method@Gtk.ColumnView.sort_by_column].
//
// The column view also supports interactive resizing and reordering of columns,
// via Drag-and-Drop of the column headers. This can be enabled or disabled with
// the [property@Gtk.ColumnView:reorderable] and
// [property@Gtk.ColumnViewColumn:resizable] properties.
//
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
//
//
// CSS nodes
//
// `
// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
//  header   <column header>     <column header>   listview  
//  [rubberband] `
//
// `GtkColumnView` uses a single CSS node named columnview. It may carry the
// .column-separators style class, when
// [property@Gtk.ColumnView:show-column-separators] property is set. Header
// widgets appear below a node with name header. The rows are contained in a
// `GtkListView` widget, so there is a listview node with the same structure as
// for a standalone `GtkListView` widget. If
// [property@Gtk.ColumnView:show-row-separators] is set, it will be passed on to
// the list view, causing its CSS node to carry the .separators style class. For
// rubberband selection, a node with name rubberband is used.
//
// The main columnview node may also carry style classes to select the style of
// list presentation (section-list-widget.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// `GtkColumnView` uses the GTK_ACCESSIBLE_ROLE_TREE_GRID role, header title
// widgets are using the GTK_ACCESSIBLE_ROLE_COLUMN_HEADER role. The row widgets
// are using the GTK_ACCESSIBLE_ROLE_ROW role, and individual cells are using
// the GTK_ACCESSIBLE_ROLE_GRID_CELL role
type ColumnView interface {
	Widget
	Scrollable

	// AppendColumnColumnView appends the @column to the end of the columns in
	// @self.
	AppendColumnColumnView(column ColumnViewColumn)
	// Columns gets the list of columns in this column view.
	//
	// This list is constant over the lifetime of @self and can be used to
	// monitor changes to the columns of @self by connecting to the
	// ::items-changed signal.
	Columns() gio.ListModel
	// EnableRubberband returns whether rows can be selected by dragging with
	// the mouse.
	EnableRubberband() bool
	// Model gets the model that's currently used to read the items displayed.
	Model() SelectionModel
	// Reorderable returns whether columns are reorderable.
	Reorderable() bool
	// ShowColumnSeparators returns whether the list should show separators
	// between columns.
	ShowColumnSeparators() bool
	// ShowRowSeparators returns whether the list should show separators between
	// rows.
	ShowRowSeparators() bool
	// SingleClickActivate returns whether rows will be activated on single
	// click and selected on hover.
	SingleClickActivate() bool
	// Sorter returns a special sorter that reflects the users sorting choices
	// in the column view.
	//
	// To allow users to customizable sorting by clicking on column headers,
	// this sorter needs to be set on the sort model underneath the model that
	// is displayed by the view.
	//
	// See [method@Gtk.ColumnViewColumn.set_sorter] for setting up per-column
	// sorting.
	//
	// Here is an example: `c gtk_column_view_column_set_sorter (column,
	// sorter); gtk_column_view_append_column (view, column); sorter =
	// g_object_ref (gtk_column_view_get_sorter (view))); model =
	// gtk_sort_list_model_new (store, sorter); selection = gtk_no_selection_new
	// (model); gtk_column_view_set_model (view, selection); `
	Sorter() Sorter
	// InsertColumnColumnView inserts a column at the given position in the
	// columns of @self.
	//
	// If @column is already a column of @self, it will be repositioned.
	InsertColumnColumnView(position uint, column ColumnViewColumn)
	// RemoveColumnColumnView removes the @column from the list of columns of
	// @self.
	RemoveColumnColumnView(column ColumnViewColumn)
	// SetEnableRubberbandColumnView sets whether selections can be changed by
	// dragging with the mouse.
	SetEnableRubberbandColumnView(enableRubberband bool)
	// SetModelColumnView sets the model to use.
	//
	// This must be a [iface@Gtk.SelectionModel].
	SetModelColumnView(model SelectionModel)
	// SetReorderableColumnView sets whether columns should be reorderable by
	// dragging.
	SetReorderableColumnView(reorderable bool)
	// SetShowColumnSeparatorsColumnView sets whether the list should show
	// separators between columns.
	SetShowColumnSeparatorsColumnView(showColumnSeparators bool)
	// SetShowRowSeparatorsColumnView sets whether the list should show
	// separators between rows.
	SetShowRowSeparatorsColumnView(showRowSeparators bool)
	// SetSingleClickActivateColumnView sets whether rows should be activated on
	// single click and selected on hover.
	SetSingleClickActivateColumnView(singleClickActivate bool)
	// SortByColumnColumnView sets the sorting of the view.
	//
	// This function should be used to set up the initial sorting. At runtime,
	// users can change the sorting of a column view by clicking on the list
	// headers.
	//
	// This call only has an effect if the sorter returned by
	// [method@Gtk.ColumnView.get_sorter] is set on a sort model, and
	// [method@Gtk.ColumnViewColumn.set_sorter] has been called on @column to
	// associate a sorter with the column.
	//
	// If @column is nil, the view will be unsorted.
	SortByColumnColumnView(column ColumnViewColumn, direction SortType)
}

// columnView implements the ColumnView class.
type columnView struct {
	Widget
}

// WrapColumnView wraps a GObject to the right type. It is
// primarily used internally.
func WrapColumnView(obj *externglib.Object) ColumnView {
	return columnView{
		Widget: WrapWidget(obj),
	}
}

func marshalColumnView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColumnView(obj), nil
}

// NewColumnView creates a new `GtkColumnView`.
//
// You most likely want to call [method@Gtk.ColumnView.append_column] to add
// columns next.
func NewColumnView(model SelectionModel) ColumnView {
	var _arg1 *C.GtkSelectionModel // out
	var _cret *C.GtkWidget         // in

	_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_column_view_new(_arg1)

	var _columnView ColumnView // out

	_columnView = WrapColumnView(externglib.Take(unsafe.Pointer(_cret)))

	return _columnView
}

func (s columnView) AppendColumnColumnView(column ColumnViewColumn) {
	var _arg0 *C.GtkColumnView       // out
	var _arg1 *C.GtkColumnViewColumn // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkColumnViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_column_view_append_column(_arg0, _arg1)
}

func (s columnView) Columns() gio.ListModel {
	var _arg0 *C.GtkColumnView // out
	var _cret *C.GListModel    // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_get_columns(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s columnView) EnableRubberband() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_get_enable_rubberband(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s columnView) Model() SelectionModel {
	var _arg0 *C.GtkColumnView     // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_get_model(_arg0)

	var _selectionModel SelectionModel // out

	_selectionModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SelectionModel)

	return _selectionModel
}

func (s columnView) Reorderable() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_get_reorderable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s columnView) ShowColumnSeparators() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_get_show_column_separators(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s columnView) ShowRowSeparators() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_get_show_row_separators(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s columnView) SingleClickActivate() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_get_single_click_activate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s columnView) Sorter() Sorter {
	var _arg0 *C.GtkColumnView // out
	var _cret *C.GtkSorter     // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_get_sorter(_arg0)

	var _sorter Sorter // out

	_sorter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Sorter)

	return _sorter
}

func (s columnView) InsertColumnColumnView(position uint, column ColumnViewColumn) {
	var _arg0 *C.GtkColumnView       // out
	var _arg1 C.guint                // out
	var _arg2 *C.GtkColumnViewColumn // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (*C.GtkColumnViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_column_view_insert_column(_arg0, _arg1, _arg2)
}

func (s columnView) RemoveColumnColumnView(column ColumnViewColumn) {
	var _arg0 *C.GtkColumnView       // out
	var _arg1 *C.GtkColumnViewColumn // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkColumnViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_column_view_remove_column(_arg0, _arg1)
}

func (s columnView) SetEnableRubberbandColumnView(enableRubberband bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	if enableRubberband {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_enable_rubberband(_arg0, _arg1)
}

func (s columnView) SetModelColumnView(model SelectionModel) {
	var _arg0 *C.GtkColumnView     // out
	var _arg1 *C.GtkSelectionModel // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

	C.gtk_column_view_set_model(_arg0, _arg1)
}

func (s columnView) SetReorderableColumnView(reorderable bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_reorderable(_arg0, _arg1)
}

func (s columnView) SetShowColumnSeparatorsColumnView(showColumnSeparators bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	if showColumnSeparators {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_show_column_separators(_arg0, _arg1)
}

func (s columnView) SetShowRowSeparatorsColumnView(showRowSeparators bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	if showRowSeparators {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_show_row_separators(_arg0, _arg1)
}

func (s columnView) SetSingleClickActivateColumnView(singleClickActivate bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	if singleClickActivate {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_single_click_activate(_arg0, _arg1)
}

func (s columnView) SortByColumnColumnView(column ColumnViewColumn, direction SortType) {
	var _arg0 *C.GtkColumnView       // out
	var _arg1 *C.GtkColumnViewColumn // out
	var _arg2 C.GtkSortType          // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkColumnViewColumn)(unsafe.Pointer(column.Native()))
	_arg2 = (C.GtkSortType)(direction)

	C.gtk_column_view_sort_by_column(_arg0, _arg1, _arg2)
}

func (s columnView) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s columnView) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s columnView) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s columnView) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s columnView) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s columnView) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s columnView) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b columnView) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s columnView) Border() (Border, bool) {
	return WrapScrollable(gextras.InternObject(s)).Border()
}

func (s columnView) HAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).HAdjustment()
}

func (s columnView) HScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).HScrollPolicy()
}

func (s columnView) VAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).VAdjustment()
}

func (s columnView) VScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).VScrollPolicy()
}

func (s columnView) SetHAdjustment(hadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetHAdjustment(hadjustment)
}

func (s columnView) SetHScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetHScrollPolicy(policy)
}

func (s columnView) SetVAdjustment(vadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetVAdjustment(vadjustment)
}

func (s columnView) SetVScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetVScrollPolicy(policy)
}

// ColumnViewColumn: `GtkColumnViewColumn` represents the columns being added to
// `GtkColumnView`.
//
// The main ingredient for a `GtkColumnViewColumn` is the `GtkListItemFactory`
// that tells the columnview how to create cells for this column from items in
// the model.
//
// Columns have a title, and can optionally have a header menu set with
// [method@Gtk.ColumnViewColumn.set_header_menu].
//
// A sorter can be associated with a column using
// [method@Gtk.ColumnViewColumn.set_sorter], to let users influence sorting by
// clicking on the column header.
type ColumnViewColumn interface {

	// ColumnView gets the column view that's currently displaying this column.
	//
	// If @self has not been added to a column view yet, nil is returned.
	ColumnView() ColumnView
	// Expand returns whether this column should expand.
	Expand() bool
	// Factory gets the factory that's currently used to populate list items for
	// this column.
	Factory() ListItemFactory
	// FixedWidth gets the fixed width of the column.
	FixedWidth() int
	// HeaderMenu gets the menu model that is used to create the context menu
	// for the column header.
	HeaderMenu() gio.MenuModel
	// Resizable returns whether this column is resizable.
	Resizable() bool
	// Sorter returns the sorter that is associated with the column.
	Sorter() Sorter
	// Title returns the title set with gtk_column_view_column_set_title().
	Title() string
	// Visible returns whether this column is visible.
	Visible() bool
	// SetExpandColumnViewColumn sets the column to take available extra space.
	//
	// The extra space is shared equally amongst all columns that have the
	// expand set to true.
	SetExpandColumnViewColumn(expand bool)
	// SetFactoryColumnViewColumn sets the `GtkListItemFactory` to use for
	// populating list items for this column.
	SetFactoryColumnViewColumn(factory ListItemFactory)
	// SetFixedWidthColumnViewColumn: if @fixed_width is not -1, sets the fixed
	// width of @column; otherwise unsets it.
	//
	// Setting a fixed width overrides the automatically calculated width.
	// Interactive resizing also sets the fixed-width property.
	SetFixedWidthColumnViewColumn(fixedWidth int)
	// SetHeaderMenuColumnViewColumn sets the menu model that is used to create
	// the context menu for the column header.
	SetHeaderMenuColumnViewColumn(menu gio.MenuModel)
	// SetResizableColumnViewColumn sets whether this column should be resizable
	// by dragging.
	SetResizableColumnViewColumn(resizable bool)
	// SetSorterColumnViewColumn associates a sorter with the column.
	//
	// If @sorter is nil, the column will not let users change the sorting by
	// clicking on its header.
	//
	// This sorter can be made active by clicking on the column header, or by
	// calling [method@Gtk.ColumnView.sort_by_column].
	//
	// See [method@Gtk.ColumnView.get_sorter] for the necessary steps for
	// setting up customizable sorting for [class@Gtk.ColumnView].
	SetSorterColumnViewColumn(sorter Sorter)
	// SetTitleColumnViewColumn sets the title of this column.
	//
	// The title is displayed in the header of a `GtkColumnView` for this column
	// and is therefore user-facing text that should be translated.
	SetTitleColumnViewColumn(title string)
	// SetVisibleColumnViewColumn sets whether this column should be visible in
	// views.
	SetVisibleColumnViewColumn(visible bool)
}

// columnViewColumn implements the ColumnViewColumn class.
type columnViewColumn struct {
	gextras.Objector
}

// WrapColumnViewColumn wraps a GObject to the right type. It is
// primarily used internally.
func WrapColumnViewColumn(obj *externglib.Object) ColumnViewColumn {
	return columnViewColumn{
		Objector: obj,
	}
}

func marshalColumnViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColumnViewColumn(obj), nil
}

// NewColumnViewColumn creates a new `GtkColumnViewColumn` that uses the given
// @factory for mapping items to widgets.
//
// You most likely want to call [method@Gtk.ColumnView.append_column] next.
//
// The function takes ownership of the argument, so you can write code like:
//
// `c column = gtk_column_view_column_new (_("Name"),
// gtk_builder_list_item_factory_new_from_resource ("/name.ui")); `
func NewColumnViewColumn(title string, factory ListItemFactory) ColumnViewColumn {
	var _arg1 *C.char                // out
	var _arg2 *C.GtkListItemFactory  // out
	var _cret *C.GtkColumnViewColumn // in

	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

	_cret = C.gtk_column_view_column_new(_arg1, _arg2)

	var _columnViewColumn ColumnViewColumn // out

	_columnViewColumn = WrapColumnViewColumn(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _columnViewColumn
}

func (s columnViewColumn) ColumnView() ColumnView {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.GtkColumnView       // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_column_get_column_view(_arg0)

	var _columnView ColumnView // out

	_columnView = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ColumnView)

	return _columnView
}

func (s columnViewColumn) Expand() bool {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_column_get_expand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s columnViewColumn) Factory() ListItemFactory {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.GtkListItemFactory  // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_column_get_factory(_arg0)

	var _listItemFactory ListItemFactory // out

	_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

	return _listItemFactory
}

func (s columnViewColumn) FixedWidth() int {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret C.int                  // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_column_get_fixed_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s columnViewColumn) HeaderMenu() gio.MenuModel {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.GMenuModel          // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_column_get_header_menu(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (s columnViewColumn) Resizable() bool {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_column_get_resizable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s columnViewColumn) Sorter() Sorter {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.GtkSorter           // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_column_get_sorter(_arg0)

	var _sorter Sorter // out

	_sorter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Sorter)

	return _sorter
}

func (s columnViewColumn) Title() string {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_column_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s columnViewColumn) Visible() bool {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_column_view_column_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s columnViewColumn) SetExpandColumnViewColumn(expand bool) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_column_set_expand(_arg0, _arg1)
}

func (s columnViewColumn) SetFactoryColumnViewColumn(factory ListItemFactory) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 *C.GtkListItemFactory  // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

	C.gtk_column_view_column_set_factory(_arg0, _arg1)
}

func (s columnViewColumn) SetFixedWidthColumnViewColumn(fixedWidth int) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 C.int                  // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(fixedWidth)

	C.gtk_column_view_column_set_fixed_width(_arg0, _arg1)
}

func (s columnViewColumn) SetHeaderMenuColumnViewColumn(menu gio.MenuModel) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 *C.GMenuModel          // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(menu.Native()))

	C.gtk_column_view_column_set_header_menu(_arg0, _arg1)
}

func (s columnViewColumn) SetResizableColumnViewColumn(resizable bool) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_column_set_resizable(_arg0, _arg1)
}

func (s columnViewColumn) SetSorterColumnViewColumn(sorter Sorter) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 *C.GtkSorter           // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

	C.gtk_column_view_column_set_sorter(_arg0, _arg1)
}

func (s columnViewColumn) SetTitleColumnViewColumn(title string) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_column_view_column_set_title(_arg0, _arg1)
}

func (s columnViewColumn) SetVisibleColumnViewColumn(visible bool) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_column_set_visible(_arg0, _arg1)
}

// ComboBox: a `GtkComboBox` is a widget that allows the user to choose from a
// list of valid choices.
//
// !An example GtkComboBox (combo-box.png)
//
// The `GtkComboBox` displays the selected choice; when activated, the
// `GtkComboBox` displays a popup which allows the user to make a new choice.
//
// The `GtkComboBox` uses the model-view pattern; the list of valid choices is
// specified in the form of a tree model, and the display of the choices can be
// adapted to the data in the model by using cell renderers, as you would in a
// tree view. This is possible since `GtkComboBox` implements the
// [interface@Gtk.CellLayout] interface. The tree model holding the valid
// choices is not restricted to a flat list, it can be a real tree, and the
// popup will reflect the tree structure.
//
// To allow the user to enter values not in the model, the
// [property@Gtk.ComboBox:has-entry] property allows the `GtkComboBox` to
// contain a [class@Gtk.Entry]. This entry can be accessed by calling
// [method@Gtk.ComboBox.get_child] on the combo box.
//
// For a simple list of textual choices, the model-view API of `GtkComboBox` can
// be a bit overwhelming. In this case, [class@Gtk.ComboBoxText] offers a simple
// alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain an entry.
//
//
// CSS nodes
//
// ` combobox  box.linked   button.combo   box   cellview  
// arrow  window.popup `
//
// A normal combobox contains a box with the .linked class, a button with the
// .combo class and inside those buttons, there are a cellview and an arrow.
//
// ` combobox  box.linked   entry.combo   button.combo   box 
//  arrow  window.popup `
//
// A `GtkComboBox` with an entry has a single CSS node with name combobox. It
// contains a box with the .linked class. That box contains an entry and a
// button, both with the .combo class added. The button also contains another
// node with name arrow.
//
//
// Accessibility
//
// `GtkComboBox` uses the GTK_ACCESSIBLE_ROLE_COMBO_BOX role.
type ComboBox interface {
	CellEditable
	CellLayout

	// Active returns the index of the currently active item.
	//
	// If the model is a non-flat treemodel, and the active item is not an
	// immediate child of the root of the tree, this function returns
	// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
	// [struct@Gtk.TreePath] of the active item.
	Active() int
	// ActiveID returns the ID of the active row of @combo_box.
	//
	// This value is taken from the active row and the column specified by the
	// [property@Gtk.ComboBox:id-column] property of @combo_box (see
	// [method@Gtk.ComboBox.set_id_column]).
	//
	// The returned value is an interned string which means that you can compare
	// the pointer by value to other interned strings and that you must not free
	// it.
	//
	// If the [property@Gtk.ComboBox:id-column] property of @combo_box is not
	// set, or if no row is active, or if the active row has a nil ID value,
	// then nil is returned.
	ActiveID() string
	// ActiveIter sets @iter to point to the currently active item.
	//
	// If no item is active, @iter is left unchanged.
	ActiveIter() (TreeIter, bool)
	// ButtonSensitivity returns whether the combo box sets the dropdown button
	// sensitive or not when there are no items in the model.
	ButtonSensitivity() SensitivityType
	// Child gets the child widget of @combo_box.
	Child() Widget
	// EntryTextColumn returns the column which @combo_box is using to get the
	// strings from to display in the internal entry.
	EntryTextColumn() int
	// HasEntry returns whether the combo box has an entry.
	HasEntry() bool
	// IDColumn returns the column which @combo_box is using to get string IDs
	// for values from.
	IDColumn() int
	// Model returns the `GtkTreeModel` of @combo_box.
	Model() TreeModel
	// PopupFixedWidth gets whether the popup uses a fixed width.
	PopupFixedWidth() bool
	// PopdownComboBox hides the menu or dropdown list of @combo_box.
	//
	// This function is mostly intended for use by accessibility technologies;
	// applications should have little use for it.
	PopdownComboBox()
	// PopupComboBox pops up the menu or dropdown list of @combo_box.
	//
	// This function is mostly intended for use by accessibility technologies;
	// applications should have little use for it.
	//
	// Before calling this, @combo_box must be mapped, or nothing will happen.
	PopupComboBox()
	// PopupForDeviceComboBox pops up the menu of @combo_box.
	//
	// Note that currently this does not do anything with the device, as it was
	// previously only used for list-mode combo boxes, and those were removed in
	// GTK 4. However, it is retained in case similar functionality is added
	// back later.
	PopupForDeviceComboBox(device gdk.Device)
	// SetActiveComboBox sets the active item of @combo_box to be the item at
	// @index.
	SetActiveComboBox(index_ int)
	// SetActiveIDComboBox changes the active row of @combo_box to the one that
	// has an ID equal to @active_id.
	//
	// If @active_id is nil, the active row is unset. Rows having a nil ID
	// string cannot be made active by this function.
	//
	// If the [property@Gtk.ComboBox:id-column] property of @combo_box is unset
	// or if no row has the given ID then the function does nothing and returns
	// false.
	SetActiveIDComboBox(activeId string) bool
	// SetActiveIterComboBox sets the current active item to be the one
	// referenced by @iter.
	//
	// If @iter is nil, the active item is unset.
	SetActiveIterComboBox(iter *TreeIter)
	// SetButtonSensitivityComboBox sets whether the dropdown button of the
	// combo box should update its sensitivity depending on the model contents.
	SetButtonSensitivityComboBox(sensitivity SensitivityType)
	// SetChildComboBox sets the child widget of @combo_box.
	SetChildComboBox(child Widget)
	// SetEntryTextColumnComboBox sets the model column which @combo_box should
	// use to get strings from to be @text_column.
	//
	// The column @text_column in the model of @combo_box must be of type
	// G_TYPE_STRING.
	//
	// This is only relevant if @combo_box has been created with
	// [property@Gtk.ComboBox:has-entry] as true.
	SetEntryTextColumnComboBox(textColumn int)
	// SetIDColumnComboBox sets the model column which @combo_box should use to
	// get string IDs for values from.
	//
	// The column @id_column in the model of @combo_box must be of type
	// G_TYPE_STRING.
	SetIDColumnComboBox(idColumn int)
	// SetModelComboBox sets the model used by @combo_box to be @model.
	//
	// Will unset a previously set model (if applicable). If model is nil, then
	// it will unset the model.
	//
	// Note that this function does not clear the cell renderers, you have to
	// call [method@Gtk.CellLayout.clear] yourself if you need to set up
	// different cell renderers for the new model.
	SetModelComboBox(model TreeModel)
	// SetPopupFixedWidthComboBox specifies whether the popups width should be
	// a fixed width.
	//
	// If @fixed is true, the popup's width is set to match the allocated width
	// of the combo box.
	SetPopupFixedWidthComboBox(fixed bool)
}

// comboBox implements the ComboBox class.
type comboBox struct {
	Widget
}

// WrapComboBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapComboBox(obj *externglib.Object) ComboBox {
	return comboBox{
		Widget: WrapWidget(obj),
	}
}

func marshalComboBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapComboBox(obj), nil
}

// NewComboBox creates a new empty `GtkComboBox`.
func NewComboBox() ComboBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_new()

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithEntry creates a new empty `GtkComboBox` with an entry.
func NewComboBoxWithEntry() ComboBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_new_with_entry()

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithModel creates a new `GtkComboBox` with a model.
func NewComboBoxWithModel(model TreeModel) ComboBox {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_combo_box_new_with_model(_arg1)

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithModelAndEntry creates a new empty `GtkComboBox` with an entry
// and a model.
func NewComboBoxWithModelAndEntry(model TreeModel) ComboBox {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_combo_box_new_with_model_and_entry(_arg1)

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

func (c comboBox) Active() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.int          // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_active(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c comboBox) ActiveID() string {
	var _arg0 *C.GtkComboBox // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_active_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c comboBox) ActiveIter() (TreeIter, bool) {
	var _arg0 *C.GtkComboBox // out
	var _iter TreeIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_active_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (c comboBox) ButtonSensitivity() SensitivityType {
	var _arg0 *C.GtkComboBox       // out
	var _cret C.GtkSensitivityType // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_button_sensitivity(_arg0)

	var _sensitivityType SensitivityType // out

	_sensitivityType = SensitivityType(_cret)

	return _sensitivityType
}

func (c comboBox) Child() Widget {
	var _arg0 *C.GtkComboBox // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (c comboBox) EntryTextColumn() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.int          // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_entry_text_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c comboBox) HasEntry() bool {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_has_entry(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c comboBox) IDColumn() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.int          // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_id_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c comboBox) Model() TreeModel {
	var _arg0 *C.GtkComboBox  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

func (c comboBox) PopupFixedWidth() bool {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_popup_fixed_width(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c comboBox) PopdownComboBox() {
	var _arg0 *C.GtkComboBox // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	C.gtk_combo_box_popdown(_arg0)
}

func (c comboBox) PopupComboBox() {
	var _arg0 *C.GtkComboBox // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	C.gtk_combo_box_popup(_arg0)
}

func (c comboBox) PopupForDeviceComboBox(device gdk.Device) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.GdkDevice   // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	C.gtk_combo_box_popup_for_device(_arg0, _arg1)
}

func (c comboBox) SetActiveComboBox(index_ int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(index_)

	C.gtk_combo_box_set_active(_arg0, _arg1)
}

func (c comboBox) SetActiveIDComboBox(activeId string) bool {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.char        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(activeId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_combo_box_set_active_id(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c comboBox) SetActiveIterComboBox(iter *TreeIter) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.GtkTreeIter // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_combo_box_set_active_iter(_arg0, _arg1)
}

func (c comboBox) SetButtonSensitivityComboBox(sensitivity SensitivityType) {
	var _arg0 *C.GtkComboBox       // out
	var _arg1 C.GtkSensitivityType // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkSensitivityType)(sensitivity)

	C.gtk_combo_box_set_button_sensitivity(_arg0, _arg1)
}

func (c comboBox) SetChildComboBox(child Widget) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_combo_box_set_child(_arg0, _arg1)
}

func (c comboBox) SetEntryTextColumnComboBox(textColumn int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(textColumn)

	C.gtk_combo_box_set_entry_text_column(_arg0, _arg1)
}

func (c comboBox) SetIDColumnComboBox(idColumn int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(idColumn)

	C.gtk_combo_box_set_id_column(_arg0, _arg1)
}

func (c comboBox) SetModelComboBox(model TreeModel) {
	var _arg0 *C.GtkComboBox  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_combo_box_set_model(_arg0, _arg1)
}

func (c comboBox) SetPopupFixedWidthComboBox(fixed bool) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	if fixed {
		_arg1 = C.TRUE
	}

	C.gtk_combo_box_set_popup_fixed_width(_arg0, _arg1)
}

func (s comboBox) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s comboBox) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s comboBox) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s comboBox) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s comboBox) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s comboBox) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s comboBox) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b comboBox) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c comboBox) EditingDone() {
	WrapCellEditable(gextras.InternObject(c)).EditingDone()
}

func (c comboBox) RemoveWidget() {
	WrapCellEditable(gextras.InternObject(c)).RemoveWidget()
}

func (c comboBox) StartEditing(event gdk.Event) {
	WrapCellEditable(gextras.InternObject(c)).StartEditing(event)
}

func (c comboBox) AddAttribute(cell CellRenderer, attribute string, column int) {
	WrapCellLayout(gextras.InternObject(c)).AddAttribute(cell, attribute, column)
}

func (c comboBox) Clear() {
	WrapCellLayout(gextras.InternObject(c)).Clear()
}

func (c comboBox) ClearAttributes(cell CellRenderer) {
	WrapCellLayout(gextras.InternObject(c)).ClearAttributes(cell)
}

func (c comboBox) Area() CellArea {
	return WrapCellLayout(gextras.InternObject(c)).Area()
}

func (c comboBox) PackEnd(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackEnd(cell, expand)
}

func (c comboBox) PackStart(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackStart(cell, expand)
}

func (c comboBox) Reorder(cell CellRenderer, position int) {
	WrapCellLayout(gextras.InternObject(c)).Reorder(cell, position)
}

// ComboBoxText: a `GtkComboBoxText` is a simple variant of `GtkComboBox` for
// text-only use cases.
//
// !An example GtkComboBoxText (combo-box-text.png)
//
// `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.
//
// To create a `GtkComboBoxText`, use [ctor@Gtk.ComboBoxText.new] or
// [ctor@Gtk.ComboBoxText.new_with_entry].
//
// You can add items to a `GtkComboBoxText` with
// [method@Gtk.ComboBoxText.append_text], [method@Gtk.ComboBoxText.insert_text]
// or [method@Gtk.ComboBoxText.prepend_text] and remove options with
// [method@Gtk.ComboBoxText.remove].
//
// If the `GtkComboBoxText` contains an entry (via the
// [property@Gtk.ComboBox:has-entry] property), its contents can be retrieved
// using [method@Gtk.ComboBoxText.get_active_text].
//
// You should not call [method@Gtk.ComboBox.set_model] or attempt to pack more
// cells into this combo box via its [interface@Gtk.CellLayout] interface.
//
//
// GtkComboBoxText as GtkBuildable
//
// The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element can specify the id
// corresponding to the appended text and also supports the regular translation
// attributes translatable, context and comments.
//
// Here is a UI definition fragment specifying `GtkComboBoxText` items: `xml
// <object class="GtkComboBoxText"> <items> <item translatable="yes"
// id="factory">Factory</item> <item translatable="yes" id="home">Home</item>
// <item translatable="yes" id="subway">Subway</item> </items> </object> `
//
//
// CSS nodes
//
// ` combobox  box.linked  entry.combo  button.combo  window.popup
// `
//
// `GtkComboBoxText` has a single CSS node with name combobox. It adds the style
// class .combo to the main CSS nodes of its entry and button children, and the
// .linked class to the node of its internal box.
type ComboBoxText interface {
	ComboBox

	// AppendComboBoxText appends @text to the list of strings stored in
	// @combo_box.
	//
	// If @id is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert] with a
	// position of -1.
	AppendComboBoxText(id string, text string)
	// AppendTextComboBoxText appends @text to the list of strings stored in
	// @combo_box.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert_text] with a
	// position of -1.
	AppendTextComboBoxText(text string)
	// ActiveText returns the currently active string in @combo_box.
	//
	// If no row is currently selected, nil is returned. If @combo_box contains
	// an entry, this function will return its contents (which will not
	// necessarily be an item from the list).
	ActiveText() string
	// InsertComboBoxText inserts @text at @position in the list of strings
	// stored in @combo_box.
	//
	// If @id is non-nil then it is used as the ID of the row. See
	// [property@Gtk.ComboBox:id-column].
	//
	// If @position is negative then @text is appended.
	InsertComboBoxText(position int, id string, text string)
	// InsertTextComboBoxText inserts @text at @position in the list of strings
	// stored in @combo_box.
	//
	// If @position is negative then @text is appended.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert] with a nil
	// ID string.
	InsertTextComboBoxText(position int, text string)
	// PrependComboBoxText prepends @text to the list of strings stored in
	// @combo_box.
	//
	// If @id is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert] with a
	// position of 0.
	PrependComboBoxText(id string, text string)
	// PrependTextComboBoxText prepends @text to the list of strings stored in
	// @combo_box.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert_text] with a
	// position of 0.
	PrependTextComboBoxText(text string)
	// RemoveComboBoxText removes the string at @position from @combo_box.
	RemoveComboBoxText(position int)
	// RemoveAllComboBoxText removes all the text entries from the combo box.
	RemoveAllComboBoxText()
}

// comboBoxText implements the ComboBoxText class.
type comboBoxText struct {
	ComboBox
}

// WrapComboBoxText wraps a GObject to the right type. It is
// primarily used internally.
func WrapComboBoxText(obj *externglib.Object) ComboBoxText {
	return comboBoxText{
		ComboBox: WrapComboBox(obj),
	}
}

func marshalComboBoxText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapComboBoxText(obj), nil
}

// NewComboBoxText creates a new `GtkComboBoxText`.
func NewComboBoxText() ComboBoxText {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_text_new()

	var _comboBoxText ComboBoxText // out

	_comboBoxText = WrapComboBoxText(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBoxText
}

// NewComboBoxTextWithEntry creates a new `GtkComboBoxText` with an entry.
func NewComboBoxTextWithEntry() ComboBoxText {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_text_new_with_entry()

	var _comboBoxText ComboBoxText // out

	_comboBoxText = WrapComboBoxText(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBoxText
}

func (c comboBoxText) AppendComboBoxText(id string, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.char            // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_append(_arg0, _arg1, _arg2)
}

func (c comboBoxText) AppendTextComboBoxText(text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_combo_box_text_append_text(_arg0, _arg1)
}

func (c comboBoxText) ActiveText() string {
	var _arg0 *C.GtkComboBoxText // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_text_get_active_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (c comboBoxText) InsertComboBoxText(position int, id string, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 C.int              // out
	var _arg2 *C.char            // out
	var _arg3 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(position)
	_arg2 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_combo_box_text_insert(_arg0, _arg1, _arg2, _arg3)
}

func (c comboBoxText) InsertTextComboBoxText(position int, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 C.int              // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(position)
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_insert_text(_arg0, _arg1, _arg2)
}

func (c comboBoxText) PrependComboBoxText(id string, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.char            // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_prepend(_arg0, _arg1, _arg2)
}

func (c comboBoxText) PrependTextComboBoxText(text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_combo_box_text_prepend_text(_arg0, _arg1)
}

func (c comboBoxText) RemoveComboBoxText(position int) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 C.int              // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(position)

	C.gtk_combo_box_text_remove(_arg0, _arg1)
}

func (c comboBoxText) RemoveAllComboBoxText() {
	var _arg0 *C.GtkComboBoxText // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

	C.gtk_combo_box_text_remove_all(_arg0)
}

func (s comboBoxText) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s comboBoxText) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s comboBoxText) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s comboBoxText) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s comboBoxText) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s comboBoxText) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s comboBoxText) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b comboBoxText) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c comboBoxText) EditingDone() {
	WrapCellEditable(gextras.InternObject(c)).EditingDone()
}

func (c comboBoxText) RemoveWidget() {
	WrapCellEditable(gextras.InternObject(c)).RemoveWidget()
}

func (c comboBoxText) StartEditing(event gdk.Event) {
	WrapCellEditable(gextras.InternObject(c)).StartEditing(event)
}

func (c comboBoxText) AddAttribute(cell CellRenderer, attribute string, column int) {
	WrapCellLayout(gextras.InternObject(c)).AddAttribute(cell, attribute, column)
}

func (c comboBoxText) Clear() {
	WrapCellLayout(gextras.InternObject(c)).Clear()
}

func (c comboBoxText) ClearAttributes(cell CellRenderer) {
	WrapCellLayout(gextras.InternObject(c)).ClearAttributes(cell)
}

func (c comboBoxText) Area() CellArea {
	return WrapCellLayout(gextras.InternObject(c)).Area()
}

func (c comboBoxText) PackEnd(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackEnd(cell, expand)
}

func (c comboBoxText) PackStart(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackStart(cell, expand)
}

func (c comboBoxText) Reorder(cell CellRenderer, position int) {
	WrapCellLayout(gextras.InternObject(c)).Reorder(cell, position)
}

// ConstantExpression: a constant value in a `GtkExpression`.
type ConstantExpression interface {

	// Value gets the value that a constant expression evaluates to.
	Value() *externglib.Value
}

// constantExpression implements the ConstantExpression class.
type constantExpression struct {
	Expression
}

// WrapConstantExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstantExpression(obj *externglib.Object) ConstantExpression {
	return constantExpression{
		Expression: WrapExpression(obj),
	}
}

func marshalConstantExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstantExpression(obj), nil
}

// NewConstantExpressionForValue creates an expression that always evaluates to
// the given `value`.
func NewConstantExpressionForValue(value *externglib.Value) ConstantExpression {
	var _arg1 *C.GValue        // out
	var _cret *C.GtkExpression // in

	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.gtk_constant_expression_new_for_value(_arg1)

	var _constantExpression ConstantExpression // out

	_constantExpression = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ConstantExpression)

	return _constantExpression
}

func (e constantExpression) Value() *externglib.Value {
	var _arg0 *C.GtkExpression // out
	var _cret *C.GValue        // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_constant_expression_get_value(_arg0)

	var _value *externglib.Value // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_cret))

	return _value
}

// Constraint: `GtkConstraint` describes a constraint between attributes of two
// widgets, expressed as a linear equation.
//
// The typical equation for a constraint is:
//
// ` target.target_attr = source.source_attr  multiplier + constant `
//
// Each `GtkConstraint` is part of a system that will be solved by a
// [class@Gtk.ConstraintLayout] in order to allocate and position each child
// widget or guide.
//
// The source and target, as well as their attributes, of a `GtkConstraint`
// instance are immutable after creation.
type Constraint interface {

	// Constant retrieves the constant factor added to the source attributes'
	// value.
	Constant() float64
	// Multiplier retrieves the multiplication factor applied to the source
	// attribute's value.
	Multiplier() float64
	// Relation: the order relation between the terms of the constraint.
	Relation() ConstraintRelation
	// Source retrieves the [iface@Gtk.ConstraintTarget] used as the source for
	// the constraint.
	//
	// If the source is set to `NULL` at creation, the constraint will use the
	// widget using the [class@Gtk.ConstraintLayout] as the source.
	Source() ConstraintTarget
	// SourceAttribute retrieves the attribute of the source to be read by the
	// constraint.
	SourceAttribute() ConstraintAttribute
	// Strength retrieves the strength of the constraint.
	Strength() int
	// Target retrieves the [iface@Gtk.ConstraintTarget] used as the target for
	// the constraint.
	//
	// If the targe is set to `NULL` at creation, the constraint will use the
	// widget using the [class@Gtk.ConstraintLayout] as the target.
	Target() ConstraintTarget
	// TargetAttribute retrieves the attribute of the target to be set by the
	// constraint.
	TargetAttribute() ConstraintAttribute
	// IsAttachedConstraint checks whether the constraint is attached to a
	// [class@Gtk.ConstraintLayout], and it is contributing to the layout.
	IsAttachedConstraint() bool
	// IsConstantConstraint checks whether the constraint describes a relation
	// between an attribute on the [property@Gtk.Constraint:target] and a
	// constant value.
	IsConstantConstraint() bool
	// IsRequiredConstraint checks whether the constraint is a required relation
	// for solving the constraint layout.
	IsRequiredConstraint() bool
}

// constraint implements the Constraint class.
type constraint struct {
	gextras.Objector
}

// WrapConstraint wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraint(obj *externglib.Object) Constraint {
	return constraint{
		Objector: obj,
	}
}

func marshalConstraint(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraint(obj), nil
}

// NewConstraint creates a new constraint representing a relation between a
// layout attribute on a source and a layout attribute on a target.
func NewConstraint(target ConstraintTarget, targetAttribute ConstraintAttribute, relation ConstraintRelation, source ConstraintTarget, sourceAttribute ConstraintAttribute, multiplier float64, constant float64, strength int) Constraint {
	var _arg1 C.gpointer               // out
	var _arg2 C.GtkConstraintAttribute // out
	var _arg3 C.GtkConstraintRelation  // out
	var _arg4 C.gpointer               // out
	var _arg5 C.GtkConstraintAttribute // out
	var _arg6 C.double                 // out
	var _arg7 C.double                 // out
	var _arg8 C.int                    // out
	var _cret *C.GtkConstraint         // in

	_arg1 = (C.gpointer)(unsafe.Pointer(target.Native()))
	_arg2 = (C.GtkConstraintAttribute)(targetAttribute)
	_arg3 = (C.GtkConstraintRelation)(relation)
	_arg4 = (C.gpointer)(unsafe.Pointer(source.Native()))
	_arg5 = (C.GtkConstraintAttribute)(sourceAttribute)
	_arg6 = (C.double)(multiplier)
	_arg7 = (C.double)(constant)
	_arg8 = (C.int)(strength)

	_cret = C.gtk_constraint_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)

	var _constraint Constraint // out

	_constraint = WrapConstraint(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _constraint
}

// NewConstraintConstant creates a new constraint representing a relation
// between a layout attribute on a target and a constant value.
func NewConstraintConstant(target ConstraintTarget, targetAttribute ConstraintAttribute, relation ConstraintRelation, constant float64, strength int) Constraint {
	var _arg1 C.gpointer               // out
	var _arg2 C.GtkConstraintAttribute // out
	var _arg3 C.GtkConstraintRelation  // out
	var _arg4 C.double                 // out
	var _arg5 C.int                    // out
	var _cret *C.GtkConstraint         // in

	_arg1 = (C.gpointer)(unsafe.Pointer(target.Native()))
	_arg2 = (C.GtkConstraintAttribute)(targetAttribute)
	_arg3 = (C.GtkConstraintRelation)(relation)
	_arg4 = (C.double)(constant)
	_arg5 = (C.int)(strength)

	_cret = C.gtk_constraint_new_constant(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _constraint Constraint // out

	_constraint = WrapConstraint(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _constraint
}

func (c constraint) Constant() float64 {
	var _arg0 *C.GtkConstraint // out
	var _cret C.double         // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_get_constant(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (c constraint) Multiplier() float64 {
	var _arg0 *C.GtkConstraint // out
	var _cret C.double         // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_get_multiplier(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (c constraint) Relation() ConstraintRelation {
	var _arg0 *C.GtkConstraint        // out
	var _cret C.GtkConstraintRelation // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_get_relation(_arg0)

	var _constraintRelation ConstraintRelation // out

	_constraintRelation = ConstraintRelation(_cret)

	return _constraintRelation
}

func (c constraint) Source() ConstraintTarget {
	var _arg0 *C.GtkConstraint       // out
	var _cret *C.GtkConstraintTarget // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_get_source(_arg0)

	var _constraintTarget ConstraintTarget // out

	_constraintTarget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ConstraintTarget)

	return _constraintTarget
}

func (c constraint) SourceAttribute() ConstraintAttribute {
	var _arg0 *C.GtkConstraint         // out
	var _cret C.GtkConstraintAttribute // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_get_source_attribute(_arg0)

	var _constraintAttribute ConstraintAttribute // out

	_constraintAttribute = ConstraintAttribute(_cret)

	return _constraintAttribute
}

func (c constraint) Strength() int {
	var _arg0 *C.GtkConstraint // out
	var _cret C.int            // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_get_strength(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c constraint) Target() ConstraintTarget {
	var _arg0 *C.GtkConstraint       // out
	var _cret *C.GtkConstraintTarget // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_get_target(_arg0)

	var _constraintTarget ConstraintTarget // out

	_constraintTarget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ConstraintTarget)

	return _constraintTarget
}

func (c constraint) TargetAttribute() ConstraintAttribute {
	var _arg0 *C.GtkConstraint         // out
	var _cret C.GtkConstraintAttribute // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_get_target_attribute(_arg0)

	var _constraintAttribute ConstraintAttribute // out

	_constraintAttribute = ConstraintAttribute(_cret)

	return _constraintAttribute
}

func (c constraint) IsAttachedConstraint() bool {
	var _arg0 *C.GtkConstraint // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_is_attached(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c constraint) IsConstantConstraint() bool {
	var _arg0 *C.GtkConstraint // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_is_constant(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c constraint) IsRequiredConstraint() bool {
	var _arg0 *C.GtkConstraint // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_constraint_is_required(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ConstraintGuide: a `GtkConstraintGuide` is an invisible layout element in a
// `GtkConstraintLayout`.
//
// The `GtkConstraintLayout` treats guides like widgets. They can be used as the
// source or target of a `GtkConstraint`.
//
// Guides have a minimum, maximum and natural size. Depending on the constraints
// that are applied, they can act like a guideline that widgets can be aligned
// to, or like *flexible space*.
//
// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
type ConstraintGuide interface {
	ConstraintTarget

	// MaxSize gets the maximum size of @guide.
	MaxSize(width *int, height *int)
	// MinSize gets the minimum size of @guide.
	MinSize(width *int, height *int)
	// Name retrieves the name set using gtk_constraint_guide_set_name().
	Name() string
	// NatSize gets the natural size of @guide.
	NatSize(width *int, height *int)
	// Strength retrieves the strength set using
	// gtk_constraint_guide_set_strength().
	Strength() ConstraintStrength
	// SetMaxSizeConstraintGuide sets the maximum size of @guide.
	//
	// If @guide is attached to a `GtkConstraintLayout`, the constraints will be
	// updated to reflect the new size.
	SetMaxSizeConstraintGuide(width int, height int)
	// SetMinSizeConstraintGuide sets the minimum size of @guide.
	//
	// If @guide is attached to a `GtkConstraintLayout`, the constraints will be
	// updated to reflect the new size.
	SetMinSizeConstraintGuide(width int, height int)
	// SetNameConstraintGuide sets a name for the given `GtkConstraintGuide`.
	//
	// The name is useful for debugging purposes.
	SetNameConstraintGuide(name string)
	// SetNatSizeConstraintGuide sets the natural size of @guide.
	//
	// If @guide is attached to a `GtkConstraintLayout`, the constraints will be
	// updated to reflect the new size.
	SetNatSizeConstraintGuide(width int, height int)
	// SetStrengthConstraintGuide sets the strength of the constraint on the
	// natural size of the given `GtkConstraintGuide`.
	SetStrengthConstraintGuide(strength ConstraintStrength)
}

// constraintGuide implements the ConstraintGuide class.
type constraintGuide struct {
	gextras.Objector
}

// WrapConstraintGuide wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraintGuide(obj *externglib.Object) ConstraintGuide {
	return constraintGuide{
		Objector: obj,
	}
}

func marshalConstraintGuide(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintGuide(obj), nil
}

// NewConstraintGuide creates a new `GtkConstraintGuide` object.
func NewConstraintGuide() ConstraintGuide {
	var _cret *C.GtkConstraintGuide // in

	_cret = C.gtk_constraint_guide_new()

	var _constraintGuide ConstraintGuide // out

	_constraintGuide = WrapConstraintGuide(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _constraintGuide
}

func (g constraintGuide) MaxSize(width *int, height *int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 *C.int                // out
	var _arg2 *C.int                // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.int)(unsafe.Pointer(width))
	_arg2 = (*C.int)(unsafe.Pointer(height))

	C.gtk_constraint_guide_get_max_size(_arg0, _arg1, _arg2)
}

func (g constraintGuide) MinSize(width *int, height *int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 *C.int                // out
	var _arg2 *C.int                // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.int)(unsafe.Pointer(width))
	_arg2 = (*C.int)(unsafe.Pointer(height))

	C.gtk_constraint_guide_get_min_size(_arg0, _arg1, _arg2)
}

func (g constraintGuide) Name() string {
	var _arg0 *C.GtkConstraintGuide // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_constraint_guide_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (g constraintGuide) NatSize(width *int, height *int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 *C.int                // out
	var _arg2 *C.int                // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.int)(unsafe.Pointer(width))
	_arg2 = (*C.int)(unsafe.Pointer(height))

	C.gtk_constraint_guide_get_nat_size(_arg0, _arg1, _arg2)
}

func (g constraintGuide) Strength() ConstraintStrength {
	var _arg0 *C.GtkConstraintGuide   // out
	var _cret C.GtkConstraintStrength // in

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_constraint_guide_get_strength(_arg0)

	var _constraintStrength ConstraintStrength // out

	_constraintStrength = ConstraintStrength(_cret)

	return _constraintStrength
}

func (g constraintGuide) SetMaxSizeConstraintGuide(width int, height int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(width)
	_arg2 = (C.int)(height)

	C.gtk_constraint_guide_set_max_size(_arg0, _arg1, _arg2)
}

func (g constraintGuide) SetMinSizeConstraintGuide(width int, height int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(width)
	_arg2 = (C.int)(height)

	C.gtk_constraint_guide_set_min_size(_arg0, _arg1, _arg2)
}

func (g constraintGuide) SetNameConstraintGuide(name string) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 *C.char               // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_constraint_guide_set_name(_arg0, _arg1)
}

func (g constraintGuide) SetNatSizeConstraintGuide(width int, height int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(width)
	_arg2 = (C.int)(height)

	C.gtk_constraint_guide_set_nat_size(_arg0, _arg1, _arg2)
}

func (g constraintGuide) SetStrengthConstraintGuide(strength ConstraintStrength) {
	var _arg0 *C.GtkConstraintGuide   // out
	var _arg1 C.GtkConstraintStrength // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
	_arg1 = (C.GtkConstraintStrength)(strength)

	C.gtk_constraint_guide_set_strength(_arg0, _arg1)
}

// ConstraintLayout: a layout manager using constraints to describe relations
// between widgets.
//
// `GtkConstraintLayout` is a layout manager that uses relations between widget
// attributes, expressed via [class@Gtk.Constraint] instances, to measure and
// allocate widgets.
//
//
// How do constraints work
//
// Constraints are objects defining the relationship between attributes of a
// widget; you can read the description of the [class@Gtk.Constraint] class to
// have a more in depth definition.
//
// By taking multiple constraints and applying them to the children of a widget
// using `GtkConstraintLayout`, it's possible to describe complex layout
// policies; each constraint applied to a child or to the parent widgets
// contributes to the full description of the layout, in terms of parameters for
// resolving the value of each attribute.
//
// It is important to note that a layout is defined by the totality of
// constraints; removing a child, or a constraint, from an existing layout
// without changing the remaining constraints may result in an unstable or
// unsolvable layout.
//
// Constraints have an implicit "reading order"; you should start describing
// each edge of each child, as well as their relationship with the parent
// container, from the top left (or top right, in RTL languages), horizontally
// first, and then vertically.
//
// A constraint-based layout with too few constraints can become "unstable",
// that is: have more than one solution. The behavior of an unstable layout is
// undefined.
//
// A constraint-based layout with conflicting constraints may be unsolvable, and
// lead to an unstable layout. You can use the
// [property@Gtk.Constraint:strength] property of [class@Gtk.Constraint] to
// "nudge" the layout towards a solution.
//
//
// GtkConstraintLayout as GtkBuildable
//
// `GtkConstraintLayout` implements the [iface@Gtk.Buildable] interface and has
// a custom "constraints" element which allows describing constraints in a
// [class@Gtk.Builder] UI file.
//
// An example of a UI definition fragment specifying a constraint:
//
// `xml <object class="GtkConstraintLayout"> <constraints> <constraint
// target="button" target-attribute="start" relation="eq" source="super"
// source-attribute="start" constant="12" strength="required" /> <constraint
// target="button" target-attribute="width" relation="ge" constant="250"
// strength="strong" /> </constraints> </object> `
//
// The definition above will add two constraints to the GtkConstraintLayout:
//
//    - a required constraint between the leading edge of "button" and
//      the leading edge of the widget using the constraint layout, plus
//      12 pixels
//    - a strong, constant constraint making the width of "button" greater
//      than, or equal to 250 pixels
//
// The "target" and "target-attribute" attributes are required.
//
// The "source" and "source-attribute" attributes of the "constraint" element
// are optional; if they are not specified, the constraint is assumed to be a
// constant.
//
// The "relation" attribute is optional; if not specified, the constraint is
// assumed to be an equality.
//
// The "strength" attribute is optional; if not specified, the constraint is
// assumed to be required.
//
// The "source" and "target" attributes can be set to "super" to indicate that
// the constraint target is the widget using the GtkConstraintLayout.
//
// There can be "constant" and "multiplier" attributes.
//
// Additionally, the "constraints" element can also contain a description of the
// ConstraintGuides used by the layout:
//
// `xml <constraints> <guide min-width="100" max-width="500" name="hspace"/>
// <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
// </constraints> `
//
// The "guide" element has the following optional attributes:
//
//    - "min-width", "nat-width", and "max-width", describe the minimum,
//      natural, and maximum width of the guide, respectively
//    - "min-height", "nat-height", and "max-height", describe the minimum,
//      natural, and maximum height of the guide, respectively
//    - "strength" describes the strength of the constraint on the natural
//      size of the guide; if not specified, the constraint is assumed to
//      have a medium strength
//    - "name" describes a name for the guide, useful when debugging
//
//
// Using the Visual Format Language
//
// Complex constraints can be described using a compact syntax called VFL, or
// *Visual Format Language*.
//
// The Visual Format Language describes all the constraints on a row or column,
// typically starting from the leading edge towards the trailing one. Each
// element of the layout is composed by "views", which identify a
// [iface@Gtk.ConstraintTarget].
//
// For instance:
//
// ` [button]-[textField] `
//
// Describes a constraint that binds the trailing edge of "button" to the
// leading edge of "textField", leaving a default space between the two.
//
// Using VFL is also possible to specify predicates that describe constraints on
// attributes like width and height:
//
// ` // Width must be greater than, or equal to 50 [button(>=50)]
//
//    // Width of button1 must be equal to width of button2
//    [button1(==button2)]
//
// `
//
// The default orientation for a VFL description is horizontal, unless otherwise
// specified:
//
// ` // horizontal orientation, default attribute: width H:[button(>=150)]
//
//    // vertical orientation, default attribute: height
//    V:[button1(==button2)]
//
// `
//
// It's also possible to specify multiple predicates, as well as their strength:
//
// ` // minimum width of button must be 150 // natural width of button can be
// 250 [button(>=150@required, ==250@medium)] `
//
// Finally, it's also possible to use simple arithmetic operators:
//
// ` // width of button1 must be equal to width of button2 // divided by 2 plus
// 12 [button1(button2 / 2 + 12)] `
type ConstraintLayout interface {
	LayoutManager
	Buildable

	// AddConstraintConstraintLayout adds a constraint to the layout manager.
	//
	// The [property@Gtk.Constraint:source] and [property@Gtk.Constraint:target]
	// properties of `constraint` can be:
	//
	//    - set to `NULL` to indicate that the constraint refers to the
	//      widget using `layout`
	//    - set to the [class@Gtk.Widget] using `layout`
	//    - set to a child of the [class@Gtk.Widget] using `layout`
	//    - set to a [class@Gtk.ConstraintGuide] that is part of `layout`
	//
	// The @layout acquires the ownership of @constraint after calling this
	// function.
	AddConstraintConstraintLayout(constraint Constraint)
	// AddGuideConstraintLayout adds a guide to `layout`.
	//
	// A guide can be used as the source or target of constraints, like a
	// widget, but it is not visible.
	//
	// The `layout` acquires the ownership of `guide` after calling this
	// function.
	AddGuideConstraintLayout(guide ConstraintGuide)
	// ObserveConstraintsConstraintLayout returns a `GListModel` to track the
	// constraints that are part of the layout.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// constraints and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveConstraintsConstraintLayout() gio.ListModel
	// ObserveGuidesConstraintLayout returns a `GListModel` to track the guides
	// that are part of the layout.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// guides and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveGuidesConstraintLayout() gio.ListModel
	// RemoveAllConstraintsConstraintLayout removes all constraints from the
	// layout manager.
	RemoveAllConstraintsConstraintLayout()
	// RemoveConstraintConstraintLayout removes `constraint` from the layout
	// manager, so that it no longer influences the layout.
	RemoveConstraintConstraintLayout(constraint Constraint)
	// RemoveGuideConstraintLayout removes `guide` from the layout manager, so
	// that it no longer influences the layout.
	RemoveGuideConstraintLayout(guide ConstraintGuide)
}

// constraintLayout implements the ConstraintLayout class.
type constraintLayout struct {
	LayoutManager
}

// WrapConstraintLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraintLayout(obj *externglib.Object) ConstraintLayout {
	return constraintLayout{
		LayoutManager: WrapLayoutManager(obj),
	}
}

func marshalConstraintLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintLayout(obj), nil
}

// NewConstraintLayout creates a new `GtkConstraintLayout` layout manager.
func NewConstraintLayout() ConstraintLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_constraint_layout_new()

	var _constraintLayout ConstraintLayout // out

	_constraintLayout = WrapConstraintLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _constraintLayout
}

func (l constraintLayout) AddConstraintConstraintLayout(constraint Constraint) {
	var _arg0 *C.GtkConstraintLayout // out
	var _arg1 *C.GtkConstraint       // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkConstraint)(unsafe.Pointer(constraint.Native()))

	C.gtk_constraint_layout_add_constraint(_arg0, _arg1)
}

func (l constraintLayout) AddGuideConstraintLayout(guide ConstraintGuide) {
	var _arg0 *C.GtkConstraintLayout // out
	var _arg1 *C.GtkConstraintGuide  // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkConstraintGuide)(unsafe.Pointer(guide.Native()))

	C.gtk_constraint_layout_add_guide(_arg0, _arg1)
}

func (l constraintLayout) ObserveConstraintsConstraintLayout() gio.ListModel {
	var _arg0 *C.GtkConstraintLayout // out
	var _cret *C.GListModel          // in

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_constraint_layout_observe_constraints(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (l constraintLayout) ObserveGuidesConstraintLayout() gio.ListModel {
	var _arg0 *C.GtkConstraintLayout // out
	var _cret *C.GListModel          // in

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_constraint_layout_observe_guides(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (l constraintLayout) RemoveAllConstraintsConstraintLayout() {
	var _arg0 *C.GtkConstraintLayout // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))

	C.gtk_constraint_layout_remove_all_constraints(_arg0)
}

func (l constraintLayout) RemoveConstraintConstraintLayout(constraint Constraint) {
	var _arg0 *C.GtkConstraintLayout // out
	var _arg1 *C.GtkConstraint       // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkConstraint)(unsafe.Pointer(constraint.Native()))

	C.gtk_constraint_layout_remove_constraint(_arg0, _arg1)
}

func (l constraintLayout) RemoveGuideConstraintLayout(guide ConstraintGuide) {
	var _arg0 *C.GtkConstraintLayout // out
	var _arg1 *C.GtkConstraintGuide  // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkConstraintGuide)(unsafe.Pointer(guide.Native()))

	C.gtk_constraint_layout_remove_guide(_arg0, _arg1)
}

func (b constraintLayout) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// ConstraintLayoutChild: `GtkLayoutChild` subclass for children in a
// `GtkConstraintLayout`.
type ConstraintLayoutChild interface {
}

// constraintLayoutChild implements the ConstraintLayoutChild class.
type constraintLayoutChild struct {
	LayoutChild
}

// WrapConstraintLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraintLayoutChild(obj *externglib.Object) ConstraintLayoutChild {
	return constraintLayoutChild{
		LayoutChild: WrapLayoutChild(obj),
	}
}

func marshalConstraintLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintLayoutChild(obj), nil
}

// CSSProvider: `GtkCssProvider` is an object implementing the
// `GtkStyleProvider` interface for CSS.
//
// It is able to parse CSS-like input in order to style widgets.
//
// An application can make GTK parse a specific CSS style sheet by calling
// [method@Gtk.CssProvider.load_from_file] or
// [method@Gtk.CssProvider.load_from_resource] and adding the provider with
// [method@Gtk.StyleContext.add_provider] or
// [func@Gtk.StyleContext.add_provider_for_display].
//
// In addition, certain files will be read when GTK is initialized. First, the
// file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it exists. Then, GTK
// loads the first existing file among
// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`, where `THEME` is
// the name of the current theme (see the [property@Gtk.Settings:gtk-theme-name]
// setting), `VARIANT` is the variant to load (see the
// [property@Gtk.Settings:gtk-application-prefer-dark-theme] setting), `DATADIR`
// is the prefix configured when GTK was compiled (unless overridden by the
// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK version
// number. If no file is found for the current version, GTK tries older versions
// all the way back to 4.0.
//
// To track errors while loading CSS, connect to the
// [signal@Gtk.CssProvider::parsing-error] signal.
type CSSProvider interface {
	StyleProvider

	// LoadFromDataCSSProvider loads @data into @css_provider.
	//
	// This clears any previously loaded information.
	LoadFromDataCSSProvider(data []byte)
	// LoadFromFileCSSProvider loads the data contained in @file into
	// @css_provider.
	//
	// This clears any previously loaded information.
	LoadFromFileCSSProvider(file gio.File)
	// LoadFromPathCSSProvider loads the data contained in @path into
	// @css_provider.
	//
	// This clears any previously loaded information.
	LoadFromPathCSSProvider(path string)
	// LoadFromResourceCSSProvider loads the data contained in the resource at
	// @resource_path into the @css_provider.
	//
	// This clears any previously loaded information.
	LoadFromResourceCSSProvider(resourcePath string)
	// LoadNamedCSSProvider loads a theme from the usual theme paths.
	//
	// The actual process of finding the theme might change between releases,
	// but it is guaranteed that this function uses the same mechanism to load
	// the theme that GTK uses for loading its own theme.
	LoadNamedCSSProvider(name string, variant string)
	// String converts the @provider into a string representation in CSS format.
	//
	// Using [method@Gtk.CssProvider.load_from_data] with the return value from
	// this function on a new provider created with [ctor@Gtk.CssProvider.new]
	// will basically create a duplicate of this @provider.
	String() string
}

// cssProvider implements the CSSProvider class.
type cssProvider struct {
	gextras.Objector
}

// WrapCSSProvider wraps a GObject to the right type. It is
// primarily used internally.
func WrapCSSProvider(obj *externglib.Object) CSSProvider {
	return cssProvider{
		Objector: obj,
	}
}

func marshalCSSProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCSSProvider(obj), nil
}

// NewCSSProvider returns a newly created `GtkCssProvider`.
func NewCSSProvider() CSSProvider {
	var _cret *C.GtkCssProvider // in

	_cret = C.gtk_css_provider_new()

	var _cssProvider CSSProvider // out

	_cssProvider = WrapCSSProvider(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cssProvider
}

func (c cssProvider) LoadFromDataCSSProvider(data []byte) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.char
	var _arg2 C.gssize

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
	_arg2 = C.gssize(len(data))
	_arg1 = (*C.char)(unsafe.Pointer(&data[0]))

	C.gtk_css_provider_load_from_data(_arg0, _arg1, _arg2)
}

func (c cssProvider) LoadFromFileCSSProvider(file gio.File) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.GFile          // out

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_css_provider_load_from_file(_arg0, _arg1)
}

func (c cssProvider) LoadFromPathCSSProvider(path string) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_css_provider_load_from_path(_arg0, _arg1)
}

func (c cssProvider) LoadFromResourceCSSProvider(resourcePath string) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_css_provider_load_from_resource(_arg0, _arg1)
}

func (p cssProvider) LoadNamedCSSProvider(name string, variant string) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(variant))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_css_provider_load_named(_arg0, _arg1, _arg2)
}

func (p cssProvider) String() string {
	var _arg0 *C.GtkCssProvider // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_css_provider_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// CustomFilter: `GtkCustomFilter` determines whether to include items with a
// callback.
type CustomFilter interface {
}

// customFilter implements the CustomFilter class.
type customFilter struct {
	Filter
}

// WrapCustomFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapCustomFilter(obj *externglib.Object) CustomFilter {
	return customFilter{
		Filter: WrapFilter(obj),
	}
}

func marshalCustomFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCustomFilter(obj), nil
}

// CustomLayout: `GtkCustomLayout` uses closures for size negotiation.
//
// A `GtkCustomLayout `uses closures matching to the old `GtkWidget` virtual
// functions for size negotiation, as a convenience API to ease the porting
// towards the corresponding `GtkLayoutManager virtual functions.
type CustomLayout interface {
}

// customLayout implements the CustomLayout class.
type customLayout struct {
	LayoutManager
}

// WrapCustomLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapCustomLayout(obj *externglib.Object) CustomLayout {
	return customLayout{
		LayoutManager: WrapLayoutManager(obj),
	}
}

func marshalCustomLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCustomLayout(obj), nil
}

// CustomSorter: `GtkCustomSorter` is a `GtkSorter` implementation that sorts
// via a callback function.
type CustomSorter interface {
}

// customSorter implements the CustomSorter class.
type customSorter struct {
	Sorter
}

// WrapCustomSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapCustomSorter(obj *externglib.Object) CustomSorter {
	return customSorter{
		Sorter: WrapSorter(obj),
	}
}

func marshalCustomSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCustomSorter(obj), nil
}

// Dialog dialogs are a convenient way to prompt the user for a small amount of
// input.
//
// !An example GtkDialog (dialog.png)
//
// Typical uses are to display a message, ask a question, or anything else that
// does not require extensive effort on the users part.
//
// The main area of a `GtkDialog` is called the "content area", and is yours to
// populate with widgets such a `GtkLabel` or `GtkEntry`, to present your
// information, questions, or tasks to the user.
//
// In addition, dialogs allow you to add "action widgets". Most commonly, action
// widgets are buttons. Depending on the platform, action widgets may be
// presented in the header bar at the top of the window, or at the bottom of the
// window. To add action widgets, create your `GtkDialog` using
// [ctor@Gtk.Dialog.new_with_buttons], or use [method@Gtk.Dialog.add_button],
// [method@Gtk.Dialog.add_buttons], or [method@Gtk.Dialog.add_action_widget].
//
// `GtkDialogs` uses some heuristics to decide whether to add a close button to
// the window decorations. If any of the action buttons use the response ID
// GTK_RESPONSE_CLOSE or GTK_RESPONSE_CANCEL, the close button is omitted.
//
// Clicking a button that was added as an action widget will emit the
// [signal@Gtk.Dialog::response] signal with a response ID that you specified.
// GTK will never assign a meaning to positive response IDs; these are entirely
// user-defined. But for convenience, you can use the response IDs in the
// [enum@Gtk.ResponseType] enumeration (these all have values less than zero).
// If a dialog receives a delete event, the [signal@Gtk.Dialog::response] signal
// will be emitted with the GTK_RESPONSE_DELETE_EVENT response ID.
//
// Dialogs are created with a call to [ctor@Gtk.Dialog.new] or
// [ctor@Gtk.Dialog.new_with_buttons]. The latter is recommended; it allows you
// to set the dialog title, some convenient flags, and add buttons.
//
// A modal dialog (that is, one which freezes the rest of the application from
// user input), can be created by calling [method@Gtk.Window.set_modal] on the
// dialog. When using [ctor@Gtk.Dialog.new_with_buttons], you can also pass the
// GTK_DIALOG_MODAL flag to make a dialog modal.
//
// For the simple dialog in the following example, a [class@Gtk.MessageDialog]
// would save some effort. But youd need to create the dialog contents manually
// if you had more than a simple message in the dialog.
//
// An example for simple `GtkDialog` usage: `c // Function to open a dialog box
// with a message void quick_message (GtkWindow *parent, char *message) {
// GtkWidget *dialog, *label, *content_area; GtkDialogFlags flags;
//
//    // Create the widgets
//    flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//    dialog = gtk_dialog_new_with_buttons ("Message",
//                                          parent,
//                                          flags,
//                                          _("_OK"),
//                                          GTK_RESPONSE_NONE,
//                                          NULL);
//    content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
//    label = gtk_label_new (message);
//
//    // Ensure that the dialog box is destroyed when the user responds
//
//    g_signal_connect_swapped (dialog,
//                              "response",
//                              G_CALLBACK (gtk_window_destroy),
//                              dialog);
//
//    // Add the label, and show everything weve added
//
//    gtk_box_append (GTK_BOX (content_area), label);
//    gtk_widget_show (dialog);
//
// } `
//
//
// GtkDialog as GtkBuildable
//
// The `GtkDialog` implementation of the `GtkBuildable` interface exposes the
// @content_area as an internal child with the name content_area.
//
// `GtkDialog` supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The response attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area). To mark a response as
// default, set the default attribute of the <action-widget> element to true.
//
// `GtkDialog` supports adding action widgets by specifying action as the
// type attribute of a <child> element. The widget will be added either to the
// action area or the headerbar of the dialog, depending on the use-header-bar
// property. The response id has to be associated with the action widget using
// the <action-widgets> element.
//
// An example of a Dialog UI definition fragment: `xml <object
// class="GtkDialog" id="dialog1"> <child type="action"> <object
// class="GtkButton" id="button_cancel"/> </child> <child type="action"> <object
// class="GtkButton" id="button_ok"> </object> </child> <action-widgets>
// <action-widget response="cancel">button_cancel</action-widget> <action-widget
// response="ok" default="true">button_ok</action-widget> </action-widgets>
// </object> `
//
//
// Accessibility
//
// `GtkDialog` uses the GTK_ACCESSIBLE_ROLE_DIALOG role.
type Dialog interface {
	Window

	// AddActionWidgetDialog adds an activatable widget to the action area of a
	// `GtkDialog`.
	//
	// GTK connects a signal handler that will emit the
	// [signal@Gtk.Dialog::response] signal on the dialog when the widget is
	// activated. The widget is appended to the end of the dialogs action area.
	//
	// If you want to add a non-activatable widget, simply pack it into the
	// @action_area field of the `GtkDialog` struct.
	AddActionWidgetDialog(child Widget, responseId int)
	// AddButtonDialog adds a button with the given text.
	//
	// GTK arranges things so that clicking the button will emit the
	// [signal@Gtk.Dialog::response] signal with the given @response_id. The
	// button is appended to the end of the dialogs action area. The button
	// widget is returned, but usually you dont need it.
	AddButtonDialog(buttonText string, responseId int) Widget
	// ContentArea returns the content area of @dialog.
	ContentArea() Box
	// HeaderBar returns the header bar of @dialog.
	//
	// Note that the headerbar is only used by the dialog if the
	// [property@Gtk.Dialog:use-header-bar] property is true.
	HeaderBar() HeaderBar
	// ResponseForWidget gets the response id of a widget in the action area of
	// a dialog.
	ResponseForWidget(widget Widget) int
	// WidgetForResponse gets the widget button that uses the given response ID
	// in the action area of a dialog.
	WidgetForResponse(responseId int) Widget
	// ResponseDialog emits the ::response signal with the given response ID.
	//
	// Used to indicate that the user has responded to the dialog in some way.
	ResponseDialog(responseId int)
	// SetDefaultResponseDialog sets the default widget for the dialog based on
	// the response ID.
	//
	// Pressing Enter normally activates the default widget.
	SetDefaultResponseDialog(responseId int)
	// SetResponseSensitiveDialog: a convenient way to sensitize/desensitize
	// dialog buttons.
	//
	// Calls `gtk_widget_set_sensitive (widget, @setting)` for each widget in
	// the dialogs action area with the given @response_id.
	SetResponseSensitiveDialog(responseId int, setting bool)
}

// dialog implements the Dialog class.
type dialog struct {
	Window
}

// WrapDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapDialog(obj *externglib.Object) Dialog {
	return dialog{
		Window: WrapWindow(obj),
	}
}

func marshalDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDialog(obj), nil
}

// NewDialog creates a new dialog box.
//
// Widgets should not be packed into the `GtkWindow` directly, but into the
// @content_area and @action_area, as described above.
func NewDialog() Dialog {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_dialog_new()

	var _dialog Dialog // out

	_dialog = WrapDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _dialog
}

func (d dialog) AddActionWidgetDialog(child Widget, responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.int)(responseId)

	C.gtk_dialog_add_action_widget(_arg0, _arg1, _arg2)
}

func (d dialog) AddButtonDialog(buttonText string, responseId int) Widget {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.char      // out
	var _arg2 C.int        // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.char)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(responseId)

	_cret = C.gtk_dialog_add_button(_arg0, _arg1, _arg2)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (d dialog) ContentArea() Box {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_get_content_area(_arg0)

	var _box Box // out

	_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

	return _box
}

func (d dialog) HeaderBar() HeaderBar {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_get_header_bar(_arg0)

	var _headerBar HeaderBar // out

	_headerBar = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(HeaderBar)

	return _headerBar
}

func (d dialog) ResponseForWidget(widget Widget) int {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_dialog_get_response_for_widget(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (d dialog) WidgetForResponse(responseId int) Widget {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.int        // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.int)(responseId)

	_cret = C.gtk_dialog_get_widget_for_response(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (d dialog) ResponseDialog(responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.int)(responseId)

	C.gtk_dialog_response(_arg0, _arg1)
}

func (d dialog) SetDefaultResponseDialog(responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.int)(responseId)

	C.gtk_dialog_set_default_response(_arg0, _arg1)
}

func (d dialog) SetResponseSensitiveDialog(responseId int, setting bool) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.int        // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.int)(responseId)
	if setting {
		_arg2 = C.TRUE
	}

	C.gtk_dialog_set_response_sensitive(_arg0, _arg1, _arg2)
}

func (s dialog) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s dialog) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s dialog) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s dialog) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s dialog) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s dialog) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s dialog) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b dialog) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s dialog) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s dialog) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s dialog) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s dialog) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s dialog) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s dialog) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s dialog) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s dialog) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// DirectoryList: `GtkDirectoryList` is a list model that wraps
// g_file_enumerate_children_async().
//
// It presents a `GListModel` and fills it asynchronously with the `GFileInfo`s
// returned from that function.
//
// Enumeration will start automatically when a the
// [property@Gtk.DirectoryList:file] property is set.
//
// While the `GtkDirectoryList` is being filled, the
// [property@Gtk.DirectoryList:loading] property will be set to true. You can
// listen to that property if you want to show information like a `GtkSpinner`
// or a "Loading..." text.
//
// If loading fails at any point, the [property@Gtk.DirectoryList:error]
// property will be set to give more indication about the failure.
//
// The `GFileInfo`s returned from a `GtkDirectoryList` have the "standard::file"
// attribute set to the `GFile` they refer to. This way you can get at the file
// that is referred to in the same way you would via
// g_file_enumerator_get_child(). This means you do not need access to the
// `GtkDirectoryList`, but can access the `GFile` directly from the `GFileInfo`
// when operating with a `GtkListView` or similar.
type DirectoryList interface {
	gio.ListModel

	// Attributes gets the attributes queried on the children.
	Attributes() string
	// Error gets the loading error, if any.
	//
	// If an error occurs during the loading process, the loading process will
	// finish and this property allows querying the error that happened. This
	// error will persist until a file is loaded again.
	//
	// An error being set does not mean that no files were loaded, and all
	// successfully queried files will remain in the list.
	Error() error
	// File gets the file whose children are currently enumerated.
	File() gio.File
	// IOPriority gets the IO priority set via
	// gtk_directory_list_set_io_priority().
	IOPriority() int
	// Monitored returns whether the directory list is monitoring the directory
	// for changes.
	Monitored() bool
	// IsLoadingDirectoryList returns true if the children enumeration is
	// currently in progress.
	//
	// Files will be added to @self from time to time while loading is going on.
	// The order in which are added is undefined and may change in between runs.
	IsLoadingDirectoryList() bool
	// SetAttributesDirectoryList sets the @attributes to be enumerated and
	// starts the enumeration.
	//
	// If @attributes is nil, no attributes will be queried, but a list of
	// `GFileInfo`s will still be created.
	SetAttributesDirectoryList(attributes string)
	// SetFileDirectoryList sets the @file to be enumerated and starts the
	// enumeration.
	//
	// If @file is nil, the result will be an empty list.
	SetFileDirectoryList(file gio.File)
	// SetIOPriorityDirectoryList sets the IO priority to use while loading
	// directories.
	//
	// Setting the priority while @self is loading will reprioritize the ongoing
	// load as soon as possible.
	//
	// The default IO priority is G_PRIORITY_DEFAULT, which is higher than the
	// GTK redraw priority. If you are loading a lot of directories in parallel,
	// lowering it to something like G_PRIORITY_DEFAULT_IDLE may increase
	// responsiveness.
	SetIOPriorityDirectoryList(ioPriority int)
	// SetMonitoredDirectoryList sets whether the directory list will monitor
	// the directory for changes. If monitoring is enabled, the ::items-changed
	// signal will be emitted when the directory contents change.
	//
	// When monitoring is turned on after the initial creation of the directory
	// list, the directory is reloaded to avoid missing files that appeared
	// between the initial loading and when monitoring was turned on.
	SetMonitoredDirectoryList(monitored bool)
}

// directoryList implements the DirectoryList class.
type directoryList struct {
	gextras.Objector
}

// WrapDirectoryList wraps a GObject to the right type. It is
// primarily used internally.
func WrapDirectoryList(obj *externglib.Object) DirectoryList {
	return directoryList{
		Objector: obj,
	}
}

func marshalDirectoryList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDirectoryList(obj), nil
}

// NewDirectoryList creates a new `GtkDirectoryList`.
//
// The `GtkDirectoryList` is querying the given @file with the given
// @attributes.
func NewDirectoryList(attributes string, file gio.File) DirectoryList {
	var _arg1 *C.char             // out
	var _arg2 *C.GFile            // out
	var _cret *C.GtkDirectoryList // in

	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GFile)(unsafe.Pointer(file.Native()))

	_cret = C.gtk_directory_list_new(_arg1, _arg2)

	var _directoryList DirectoryList // out

	_directoryList = WrapDirectoryList(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _directoryList
}

func (s directoryList) Attributes() string {
	var _arg0 *C.GtkDirectoryList // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_get_attributes(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s directoryList) Error() error {
	var _arg0 *C.GtkDirectoryList // out
	var _cret *C.GError           // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_get_error(_arg0)

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(_cret))

	return _err
}

func (s directoryList) File() gio.File {
	var _arg0 *C.GtkDirectoryList // out
	var _cret *C.GFile            // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_get_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

func (s directoryList) IOPriority() int {
	var _arg0 *C.GtkDirectoryList // out
	var _cret C.int               // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_get_io_priority(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s directoryList) Monitored() bool {
	var _arg0 *C.GtkDirectoryList // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_get_monitored(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s directoryList) IsLoadingDirectoryList() bool {
	var _arg0 *C.GtkDirectoryList // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_is_loading(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s directoryList) SetAttributesDirectoryList(attributes string) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_directory_list_set_attributes(_arg0, _arg1)
}

func (s directoryList) SetFileDirectoryList(file gio.File) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 *C.GFile            // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_directory_list_set_file(_arg0, _arg1)
}

func (s directoryList) SetIOPriorityDirectoryList(ioPriority int) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 C.int               // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(ioPriority)

	C.gtk_directory_list_set_io_priority(_arg0, _arg1)
}

func (s directoryList) SetMonitoredDirectoryList(monitored bool) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
	if monitored {
		_arg1 = C.TRUE
	}

	C.gtk_directory_list_set_monitored(_arg0, _arg1)
}

// DragIcon: `GtkDragIcon` is a `GtkRoot` implementation for drag icons.
//
// A drag icon moves with the pointer during a Drag-and-Drop operation and is
// destroyed when the drag ends.
//
// To set up a drag icon and associate it with an ongoing drag operation, use
// [func@Gtk.DragIcon.get_for_drag] to get the icon for a drag. You can then use
// it like any other widget and use [method@Gtk.DragIcon.set_child] to set
// whatever widget should be used for the drag icon.
//
// Keep in mind that drag icons do not allow user input.
type DragIcon interface {
	Root

	// Child gets the widget currently used as drag icon.
	Child() Widget
	// SetChildDragIcon sets the widget to display as the drag icon.
	SetChildDragIcon(child Widget)
}

// dragIcon implements the DragIcon class.
type dragIcon struct {
	Widget
}

// WrapDragIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapDragIcon(obj *externglib.Object) DragIcon {
	return dragIcon{
		Widget: WrapWidget(obj),
	}
}

func marshalDragIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDragIcon(obj), nil
}

func (s dragIcon) Child() Widget {
	var _arg0 *C.GtkDragIcon // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkDragIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drag_icon_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s dragIcon) SetChildDragIcon(child Widget) {
	var _arg0 *C.GtkDragIcon // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkDragIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_drag_icon_set_child(_arg0, _arg1)
}

func (s dragIcon) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s dragIcon) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s dragIcon) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s dragIcon) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s dragIcon) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s dragIcon) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s dragIcon) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b dragIcon) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s dragIcon) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s dragIcon) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s dragIcon) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s dragIcon) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s dragIcon) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s dragIcon) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s dragIcon) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s dragIcon) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// DragSource: `GtkDragSource` is an event controller to initiate Drag-And-Drop
// operations.
//
// `GtkDragSource` can be set up with the necessary ingredients for a DND
// operation ahead of time. This includes the source for the data that is being
// transferred, in the form of a [class@Gdk.ContentProvider], the desired
// action, and the icon to use during the drag operation. After setting it up,
// the drag source must be added to a widget as an event controller, using
// [method@Gtk.Widget.add_controller].
//
// `c static void my_widget_init (MyWidget *self) { GtkDragSource *drag_source
// = gtk_drag_source_new ();
//
//    g_signal_connect (drag_source, "prepare", G_CALLBACK (on_drag_prepare), self);
//    g_signal_connect (drag_source, "drag-begin", G_CALLBACK (on_drag_begin), self);
//
//    gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (drag_source));
//
// } `
//
// Setting up the content provider and icon ahead of time only makes sense when
// the data does not change. More commonly, you will want to set them up just in
// time. To do so, `GtkDragSource` has [signal@Gtk.DragSource::prepare] and
// [signal@Gtk.DragSource::drag-begin] signals.
//
// The ::prepare signal is emitted before a drag is started, and can be used to
// set the content provider and actions that the drag should be started with.
//
// `c static GdkContentProvider * on_drag_prepare (GtkDragSource *source,
// double x, double y, MyWidget *self) { // This widget supports two types of
// content: GFile objects // and GdkPixbuf objects; GTK will handle the
// serialization // of these types automatically GFile *file =
// my_widget_get_file (self); GdkPixbuf *pixbuf = my_widget_get_pixbuf (self);
//
//    return gdk_content_provider_new_union ((GdkContentProvider *[2]) {
//        gdk_content_provider_new_typed (G_TYPE_FILE, file),
//        gdk_content_provider_new_typed (GDK_TYPE_PIXBUF, pixbuf),
//      }, 2);
//
// } `
//
// The ::drag-begin signal is emitted after the `GdkDrag` object has been
// created, and can be used to set up the drag icon.
//
// `c static void on_drag_begin (GtkDragSource *source, GtkDrag *drag, MyWidget
// *self) { // Set the widget as the drag icon GdkPaintable *paintable =
// gtk_widget_paintable_new (GTK_WIDGET (self)); gtk_drag_source_set_icon
// (source, paintable, 0, 0); g_object_unref (paintable); } `
//
// During the DND operation, `GtkDragSource` emits signals that can be used to
// obtain updates about the status of the operation, but it is not normally
// necessary to connect to any signals, except for one case: when the supported
// actions include GDK_ACTION_MOVE, you need to listen for the
// [signal@Gtk.DragSource::drag-end] signal and delete the data after it has
// been transferred.
type DragSource interface {

	// DragCancelDragSource cancels a currently ongoing drag operation.
	DragCancelDragSource()
	// Actions gets the actions that are currently set on the `GtkDragSource`.
	Actions() gdk.DragAction
	// Content gets the current content provider of a `GtkDragSource`.
	Content() gdk.ContentProvider
	// Drag returns the underlying `GdkDrag` object for an ongoing drag.
	Drag() gdk.Drag
	// SetActionsDragSource sets the actions on the `GtkDragSource`.
	//
	// During a DND operation, the actions are offered to potential drop
	// targets. If @actions include GDK_ACTION_MOVE, you need to listen to the
	// [signal@Gtk.DragSource::drag-end] signal and handle @delete_data being
	// true.
	//
	// This function can be called before a drag is started, or in a handler for
	// the [signal@Gtk.DragSource::prepare] signal.
	SetActionsDragSource(actions gdk.DragAction)
	// SetContentDragSource sets a content provider on a `GtkDragSource`.
	//
	// When the data is requested in the cause of a DND operation, it will be
	// obtained from the content provider.
	//
	// This function can be called before a drag is started, or in a handler for
	// the [signal@Gtk.DragSource::prepare] signal.
	//
	// You may consider setting the content provider back to nil in a
	// [signal@Gtk.DragSource::drag-end] signal handler.
	SetContentDragSource(content gdk.ContentProvider)
	// SetIconDragSource sets a paintable to use as icon during DND operations.
	//
	// The hotspot coordinates determine the point on the icon that gets aligned
	// with the hotspot of the cursor.
	//
	// If @paintable is nil, a default icon is used.
	//
	// This function can be called before a drag is started, or in a
	// [signal@Gtk.DragSource::prepare] or [signal@Gtk.DragSource::drag-begin]
	// signal handler.
	SetIconDragSource(paintable gdk.Paintable, hotX int, hotY int)
}

// dragSource implements the DragSource class.
type dragSource struct {
	GestureSingle
}

// WrapDragSource wraps a GObject to the right type. It is
// primarily used internally.
func WrapDragSource(obj *externglib.Object) DragSource {
	return dragSource{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalDragSource(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDragSource(obj), nil
}

// NewDragSource creates a new `GtkDragSource` object.
func NewDragSource() DragSource {
	var _cret *C.GtkDragSource // in

	_cret = C.gtk_drag_source_new()

	var _dragSource DragSource // out

	_dragSource = WrapDragSource(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dragSource
}

func (s dragSource) DragCancelDragSource() {
	var _arg0 *C.GtkDragSource // out

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))

	C.gtk_drag_source_drag_cancel(_arg0)
}

func (s dragSource) Actions() gdk.DragAction {
	var _arg0 *C.GtkDragSource // out
	var _cret C.GdkDragAction  // in

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drag_source_get_actions(_arg0)

	var _dragAction gdk.DragAction // out

	_dragAction = gdk.DragAction(_cret)

	return _dragAction
}

func (s dragSource) Content() gdk.ContentProvider {
	var _arg0 *C.GtkDragSource      // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drag_source_get_content(_arg0)

	var _contentProvider gdk.ContentProvider // out

	_contentProvider = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.ContentProvider)

	return _contentProvider
}

func (s dragSource) Drag() gdk.Drag {
	var _arg0 *C.GtkDragSource // out
	var _cret *C.GdkDrag       // in

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drag_source_get_drag(_arg0)

	var _drag gdk.Drag // out

	_drag = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Drag)

	return _drag
}

func (s dragSource) SetActionsDragSource(actions gdk.DragAction) {
	var _arg0 *C.GtkDragSource // out
	var _arg1 C.GdkDragAction  // out

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GdkDragAction)(actions)

	C.gtk_drag_source_set_actions(_arg0, _arg1)
}

func (s dragSource) SetContentDragSource(content gdk.ContentProvider) {
	var _arg0 *C.GtkDragSource      // out
	var _arg1 *C.GdkContentProvider // out

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkContentProvider)(unsafe.Pointer(content.Native()))

	C.gtk_drag_source_set_content(_arg0, _arg1)
}

func (s dragSource) SetIconDragSource(paintable gdk.Paintable, hotX int, hotY int) {
	var _arg0 *C.GtkDragSource // out
	var _arg1 *C.GdkPaintable  // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))
	_arg2 = (C.int)(hotX)
	_arg3 = (C.int)(hotY)

	C.gtk_drag_source_set_icon(_arg0, _arg1, _arg2, _arg3)
}

// DrawingArea: `GtkDrawingArea` is a widget that allows drawing with cairo.
//
// !An example GtkDrawingArea (drawingarea.png)
//
// Its essentially a blank widget; you can draw on it. After creating a drawing
// area, the application may want to connect to:
//
// - The [signal@Gtk.Widget::realize] signal to take any necessary actions when
// the widget is instantiated on a particular display. (Create GDK resources in
// response to this signal.)
//
// - The [signal@Gtk.DrawingArea::resize] signal to take any necessary actions
// when the widget changes size.
//
// - Call [method@Gtk.DrawingArea.set_draw_func] to handle redrawing the
// contents of the widget.
//
// The following code portion demonstrates using a drawing area to display a
// circle in the normal widget foreground color.
//
//
// Simple GtkDrawingArea usage
//
// `c static void draw_function (GtkDrawingArea *area, cairo_t *cr, int width,
// int height, gpointer data) { GdkRGBA color; GtkStyleContext *context;
//
//    context = gtk_widget_get_style_context (GTK_WIDGET (area));
//
//    cairo_arc (cr,
//               width / 2.0, height / 2.0,
//               MIN (width, height) / 2.0,
//               0, 2 * G_PI);
//
//    gtk_style_context_get_color (context,
//                                 &color);
//    gdk_cairo_set_source_rgba (cr, &color);
//
//    cairo_fill (cr);
//
// }
//
// int main (int argc, char **argv) { gtk_init ();
//
//    GtkWidget *area = gtk_drawing_area_new ();
//    gtk_drawing_area_set_content_width (GTK_DRAWING_AREA (area), 100);
//    gtk_drawing_area_set_content_height (GTK_DRAWING_AREA (area), 100);
//    gtk_drawing_area_set_draw_func (GTK_DRAWING_AREA (area),
//                                    draw_function,
//                                    NULL, NULL);
//    return 0;
//
// } `
//
// The draw function is normally called when a drawing area first comes
// onscreen, or when its covered by another window and then uncovered. You can
// also force a redraw by adding to the damage region of the drawing areas
// window using [method@Gtk.Widget.queue_draw]. This will cause the drawing area
// to call the draw function again.
//
// The available routines for drawing are documented on the [GDK Drawing
// Primitives][gdk4-Cairo-Interaction] page and the cairo documentation.
//
// To receive mouse events on a drawing area, you will need to use event
// controllers. To receive keyboard events, you will need to set the can-focus
// property on the drawing area, and you should probably draw some user-visible
// indication that the drawing area is focused.
//
// If you need more complex control over your widget, you should consider
// creating your own `GtkWidget` subclass.
type DrawingArea interface {
	Widget

	// ContentHeight retrieves the content height of the `GtkDrawingArea`.
	ContentHeight() int
	// ContentWidth retrieves the content width of the `GtkDrawingArea`.
	ContentWidth() int
	// SetContentHeightDrawingArea sets the desired height of the contents of
	// the drawing area.
	//
	// Note that because widgets may be allocated larger sizes than they
	// requested, it is possible that the actual height passed to your draw
	// function is larger than the height set here. You can use
	// [method@Gtk.Widget.set_valign] to avoid that.
	//
	// If the height is set to 0 (the default), the drawing area may disappear.
	SetContentHeightDrawingArea(height int)
	// SetContentWidthDrawingArea sets the desired width of the contents of the
	// drawing area.
	//
	// Note that because widgets may be allocated larger sizes than they
	// requested, it is possible that the actual width passed to your draw
	// function is larger than the width set here. You can use
	// [method@Gtk.Widget.set_halign] to avoid that.
	//
	// If the width is set to 0 (the default), the drawing area may disappear.
	SetContentWidthDrawingArea(width int)
}

// drawingArea implements the DrawingArea class.
type drawingArea struct {
	Widget
}

// WrapDrawingArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapDrawingArea(obj *externglib.Object) DrawingArea {
	return drawingArea{
		Widget: WrapWidget(obj),
	}
}

func marshalDrawingArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrawingArea(obj), nil
}

// NewDrawingArea creates a new drawing area.
func NewDrawingArea() DrawingArea {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_drawing_area_new()

	var _drawingArea DrawingArea // out

	_drawingArea = WrapDrawingArea(externglib.Take(unsafe.Pointer(_cret)))

	return _drawingArea
}

func (s drawingArea) ContentHeight() int {
	var _arg0 *C.GtkDrawingArea // out
	var _cret C.int             // in

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drawing_area_get_content_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s drawingArea) ContentWidth() int {
	var _arg0 *C.GtkDrawingArea // out
	var _cret C.int             // in

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drawing_area_get_content_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s drawingArea) SetContentHeightDrawingArea(height int) {
	var _arg0 *C.GtkDrawingArea // out
	var _arg1 C.int             // out

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(height)

	C.gtk_drawing_area_set_content_height(_arg0, _arg1)
}

func (s drawingArea) SetContentWidthDrawingArea(width int) {
	var _arg0 *C.GtkDrawingArea // out
	var _arg1 C.int             // out

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(width)

	C.gtk_drawing_area_set_content_width(_arg0, _arg1)
}

func (s drawingArea) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s drawingArea) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s drawingArea) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s drawingArea) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s drawingArea) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s drawingArea) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s drawingArea) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b drawingArea) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// DropControllerMotion: `GtkDropControllerMotion` is an event controller
// tracking the pointer during Drag-and-Drop operations.
//
// It is modeled after [class@Gtk.EventControllerMotion] so if you have used
// that, this should feel really familiar.
//
// This controller is not able to accept drops, use [class@Gtk.DropTarget] for
// that purpose.
type DropControllerMotion interface {

	// ContainsPointerDropControllerMotion returns if a Drag-and-Drop operation
	// is within the widget @self or one of its children.
	ContainsPointerDropControllerMotion() bool
	// Drop returns the `GdkDrop` of a current Drag-and-Drop operation over the
	// widget of @self.
	Drop() gdk.Drop
	// IsPointerDropControllerMotion returns if a Drag-and-Drop operation is
	// within the widget @self, not one of its children.
	IsPointerDropControllerMotion() bool
}

// dropControllerMotion implements the DropControllerMotion class.
type dropControllerMotion struct {
	EventController
}

// WrapDropControllerMotion wraps a GObject to the right type. It is
// primarily used internally.
func WrapDropControllerMotion(obj *externglib.Object) DropControllerMotion {
	return dropControllerMotion{
		EventController: WrapEventController(obj),
	}
}

func marshalDropControllerMotion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDropControllerMotion(obj), nil
}

// NewDropControllerMotion creates a new event controller that will handle
// pointer motion events during drag and drop.
func NewDropControllerMotion() DropControllerMotion {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_drop_controller_motion_new()

	var _dropControllerMotion DropControllerMotion // out

	_dropControllerMotion = WrapDropControllerMotion(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dropControllerMotion
}

func (s dropControllerMotion) ContainsPointerDropControllerMotion() bool {
	var _arg0 *C.GtkDropControllerMotion // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkDropControllerMotion)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_controller_motion_contains_pointer(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s dropControllerMotion) Drop() gdk.Drop {
	var _arg0 *C.GtkDropControllerMotion // out
	var _cret *C.GdkDrop                 // in

	_arg0 = (*C.GtkDropControllerMotion)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_controller_motion_get_drop(_arg0)

	var _drop gdk.Drop // out

	_drop = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Drop)

	return _drop
}

func (s dropControllerMotion) IsPointerDropControllerMotion() bool {
	var _arg0 *C.GtkDropControllerMotion // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkDropControllerMotion)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_controller_motion_is_pointer(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DropDown: `GtkDropDown` is a widget that allows the user to choose an item
// from a list of options.
//
// !An example GtkDropDown (drop-down.png)
//
// The `GtkDropDown` displays the selected choice.
//
// The options are given to `GtkDropDown` in the form of `GListModel` and how
// the individual options are represented is determined by a
// [class@Gtk.ListItemFactory]. The default factory displays simple strings.
//
// `GtkDropDown` knows how to obtain strings from the items in a
// [class@Gtk.StringList]; for other models, you have to provide an expression
// to find the strings via [method@Gtk.DropDown.set_expression].
//
// `GtkDropDown` can optionally allow search in the popup, which is useful if
// the list of options is long. To enable the search entry, use
// [method@Gtk.DropDown.set_enable_search].
//
//
// CSS nodes
//
// `GtkDropDown` has a single CSS node with name dropdown, with the button and
// popover nodes as children.
//
//
// Accessibility
//
// `GtkDropDown` uses the GTK_ACCESSIBLE_ROLE_COMBO_BOX role.
type DropDown interface {
	Widget

	// EnableSearch returns whether search is enabled.
	EnableSearch() bool
	// Expression gets the expression set that is used to obtain strings from
	// items.
	//
	// See [method@Gtk.DropDown.set_expression].
	Expression() Expression
	// Factory gets the factory that's currently used to populate list items.
	//
	// The factory returned by this function is always used for the item in the
	// button. It is also used for items in the popup if
	// [property@Gtk.DropDown:list-factory] is not set.
	Factory() ListItemFactory
	// ListFactory gets the factory that's currently used to populate list items
	// in the popup.
	ListFactory() ListItemFactory
	// Model gets the model that provides the displayed items.
	Model() gio.ListModel
	// Selected gets the position of the selected item.
	Selected() uint
	// SelectedItem gets the selected item. If no item is selected, nil is
	// returned.
	SelectedItem() gextras.Objector
	// SetEnableSearchDropDown sets whether a search entry will be shown in the
	// popup that allows to search for items in the list.
	//
	// Note that [property@Gtk.DropDown:expression] must be set for search to
	// work.
	SetEnableSearchDropDown(enableSearch bool)
	// SetExpressionDropDown sets the expression that gets evaluated to obtain
	// strings from items.
	//
	// This is used for search in the popup. The expression must have a value
	// type of G_TYPE_STRING.
	SetExpressionDropDown(expression Expression)
	// SetFactoryDropDown sets the `GtkListItemFactory` to use for populating
	// list items.
	SetFactoryDropDown(factory ListItemFactory)
	// SetListFactoryDropDown sets the `GtkListItemFactory` to use for
	// populating list items in the popup.
	SetListFactoryDropDown(factory ListItemFactory)
	// SetModelDropDown sets the `GListModel` to use.
	SetModelDropDown(model gio.ListModel)
	// SetSelectedDropDown selects the item at the given position.
	SetSelectedDropDown(position uint)
}

// dropDown implements the DropDown class.
type dropDown struct {
	Widget
}

// WrapDropDown wraps a GObject to the right type. It is
// primarily used internally.
func WrapDropDown(obj *externglib.Object) DropDown {
	return dropDown{
		Widget: WrapWidget(obj),
	}
}

func marshalDropDown(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDropDown(obj), nil
}

// NewDropDown creates a new `GtkDropDown`.
//
// You may want to call [method@Gtk.DropDown.set_factory] to set up a way to map
// its items to widgets.
func NewDropDown(model gio.ListModel, expression Expression) DropDown {
	var _arg1 *C.GListModel    // out
	var _arg2 *C.GtkExpression // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	_cret = C.gtk_drop_down_new(_arg1, _arg2)

	var _dropDown DropDown // out

	_dropDown = WrapDropDown(externglib.Take(unsafe.Pointer(_cret)))

	return _dropDown
}

// NewDropDownFromStrings creates a new `GtkDropDown` that is populated with the
// strings.
func NewDropDownFromStrings(strings []string) DropDown {
	var _arg1 **C.char
	var _cret *C.GtkWidget // in

	_arg1 = (**C.char)(C.malloc(C.ulong(len(strings)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strings))
		for i := range strings {
			out[i] = (*C.char)(C.CString(strings[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gtk_drop_down_new_from_strings(_arg1)

	var _dropDown DropDown // out

	_dropDown = WrapDropDown(externglib.Take(unsafe.Pointer(_cret)))

	return _dropDown
}

func (s dropDown) EnableSearch() bool {
	var _arg0 *C.GtkDropDown // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_down_get_enable_search(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s dropDown) Expression() Expression {
	var _arg0 *C.GtkDropDown   // out
	var _cret *C.GtkExpression // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_down_get_expression(_arg0)

	var _expression Expression // out

	_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

	return _expression
}

func (s dropDown) Factory() ListItemFactory {
	var _arg0 *C.GtkDropDown        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_down_get_factory(_arg0)

	var _listItemFactory ListItemFactory // out

	_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

	return _listItemFactory
}

func (s dropDown) ListFactory() ListItemFactory {
	var _arg0 *C.GtkDropDown        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_down_get_list_factory(_arg0)

	var _listItemFactory ListItemFactory // out

	_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

	return _listItemFactory
}

func (s dropDown) Model() gio.ListModel {
	var _arg0 *C.GtkDropDown // out
	var _cret *C.GListModel  // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_down_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s dropDown) Selected() uint {
	var _arg0 *C.GtkDropDown // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_down_get_selected(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s dropDown) SelectedItem() gextras.Objector {
	var _arg0 *C.GtkDropDown // out
	var _cret C.gpointer     // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_down_get_selected_item(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (s dropDown) SetEnableSearchDropDown(enableSearch bool) {
	var _arg0 *C.GtkDropDown // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
	if enableSearch {
		_arg1 = C.TRUE
	}

	C.gtk_drop_down_set_enable_search(_arg0, _arg1)
}

func (s dropDown) SetExpressionDropDown(expression Expression) {
	var _arg0 *C.GtkDropDown   // out
	var _arg1 *C.GtkExpression // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	C.gtk_drop_down_set_expression(_arg0, _arg1)
}

func (s dropDown) SetFactoryDropDown(factory ListItemFactory) {
	var _arg0 *C.GtkDropDown        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

	C.gtk_drop_down_set_factory(_arg0, _arg1)
}

func (s dropDown) SetListFactoryDropDown(factory ListItemFactory) {
	var _arg0 *C.GtkDropDown        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

	C.gtk_drop_down_set_list_factory(_arg0, _arg1)
}

func (s dropDown) SetModelDropDown(model gio.ListModel) {
	var _arg0 *C.GtkDropDown // out
	var _arg1 *C.GListModel  // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	C.gtk_drop_down_set_model(_arg0, _arg1)
}

func (s dropDown) SetSelectedDropDown(position uint) {
	var _arg0 *C.GtkDropDown // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)

	C.gtk_drop_down_set_selected(_arg0, _arg1)
}

func (s dropDown) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s dropDown) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s dropDown) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s dropDown) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s dropDown) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s dropDown) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s dropDown) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b dropDown) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// DropTarget: `GtkDropTarget` is an event controller to receive Drag-and-Drop
// operations.
//
// The most basic way to use a `GtkDropTarget` to receive drops on a widget is
// to create it via [ctor@Gtk.DropTarget.new], passing in the `GType` of the
// data you want to receive and connect to the [signal@Gtk.DropTarget::drop]
// signal to receive the data:
//
// `c static gboolean on_drop (GtkDropTarget *target, const GValue *value,
// double x, double y, gpointer data) { MyWidget *self = data;
//
//    // Call the appropriate setter depending on the type of data
//    // that we received
//    if (G_VALUE_HOLDS (value, G_TYPE_FILE))
//      my_widget_set_file (self, g_value_get_object (value));
//    else if (G_VALUE_HOLDS (value, GDK_TYPE_PIXBUF))
//      my_widget_set_pixbuf (self, g_value_get_object (value));
//    else
//      return FALSE;
//
//    return TRUE;
//
// }
//
// static void my_widget_init (MyWidget *self) { GtkDropTarget *target =
// gtk_drop_target_new (G_TYPE_INVALID, GDK_ACTION_COPY);
//
//    // This widget accepts two types of drop types: GFile objects
//    // and GdkPixbuf objects
//    gtk_drop_target_set_gtypes (target, (GTypes [2]) {
//      G_TYPE_FILE,
//      GDK_TYPE_PIXBUF,
//    }, 2);
//
//    gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (target));
//
// } `
//
// `GtkDropTarget` supports more options, such as:
//
//    * rejecting potential drops via the [signal@Gtk.DropTarget::accept] signal
//      and the [method@Gtk.DropTarget.reject] function to let other drop
//      targets handle the drop
//    * tracking an ongoing drag operation before the drop via the
//      [signal@Gtk.DropTarget::enter], [signal@Gtk.DropTarget::motion] and
//      [signal@Gtk.DropTarget::leave] signals
//    * configuring how to receive data by setting the
//      [property@Gtk.DropTarget:preload] property and listening for its
//      availability via the [property@Gtk.DropTarget:value] property
//
// However, `GtkDropTarget` is ultimately modeled in a synchronous way and only
// supports data transferred via `GType`. If you want full control over an
// ongoing drop, the [class@Gtk.DropTargetAsync] object gives you this ability.
//
// While a pointer is dragged over the drop target's widget and the drop has not
// been rejected, that widget will receive the GTK_STATE_FLAG_DROP_ACTIVE state,
// which can be used to style the widget.
//
// If you are not interested in receiving the drop, but just want to update UI
// state during a Drag-and-Drop operation (e.g. switching tabs), you can use
// [class@Gtk.DropControllerMotion].
type DropTarget interface {

	// Actions gets the actions that this drop target supports.
	Actions() gdk.DragAction
	// Drop gets the currently handled drop operation.
	//
	// If no drop operation is going on, nil is returned.
	Drop() gdk.Drop
	// Formats gets the data formats that this drop target accepts.
	//
	// If the result is nil, all formats are expected to be supported.
	Formats() *gdk.ContentFormats
	// Preload gets whether data should be preloaded on hover.
	Preload() bool
	// Value gets the current drop data, as a `GValue`.
	Value() *externglib.Value
	// RejectDropTarget rejects the ongoing drop operation.
	//
	// If no drop operation is ongoing, i.e when [property@Gtk.DropTarget:drop]
	// is nil, this function does nothing.
	//
	// This function should be used when delaying the decision on whether to
	// accept a drag or not until after reading the data.
	RejectDropTarget()
	// SetActionsDropTarget sets the actions that this drop target supports.
	SetActionsDropTarget(actions gdk.DragAction)
	// SetGTypesDropTarget sets the supported `GTypes` for this drop target.
	SetGTypesDropTarget(types []externglib.Type)
	// SetPreloadDropTarget sets whether data should be preloaded on hover.
	SetPreloadDropTarget(preload bool)
}

// dropTarget implements the DropTarget class.
type dropTarget struct {
	EventController
}

// WrapDropTarget wraps a GObject to the right type. It is
// primarily used internally.
func WrapDropTarget(obj *externglib.Object) DropTarget {
	return dropTarget{
		EventController: WrapEventController(obj),
	}
}

func marshalDropTarget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDropTarget(obj), nil
}

// NewDropTarget creates a new `GtkDropTarget` object.
//
// If the drop target should support more than 1 type, pass G_TYPE_INVALID for
// @type and then call [method@Gtk.DropTarget.set_gtypes].
func NewDropTarget(typ externglib.Type, actions gdk.DragAction) DropTarget {
	var _arg1 C.GType          // out
	var _arg2 C.GdkDragAction  // out
	var _cret *C.GtkDropTarget // in

	_arg1 = (C.GType)(typ)
	_arg2 = (C.GdkDragAction)(actions)

	_cret = C.gtk_drop_target_new(_arg1, _arg2)

	var _dropTarget DropTarget // out

	_dropTarget = WrapDropTarget(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dropTarget
}

func (s dropTarget) Actions() gdk.DragAction {
	var _arg0 *C.GtkDropTarget // out
	var _cret C.GdkDragAction  // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_target_get_actions(_arg0)

	var _dragAction gdk.DragAction // out

	_dragAction = gdk.DragAction(_cret)

	return _dragAction
}

func (s dropTarget) Drop() gdk.Drop {
	var _arg0 *C.GtkDropTarget // out
	var _cret *C.GdkDrop       // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_target_get_drop(_arg0)

	var _drop gdk.Drop // out

	_drop = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Drop)

	return _drop
}

func (s dropTarget) Formats() *gdk.ContentFormats {
	var _arg0 *C.GtkDropTarget     // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_target_get_formats(_arg0)

	var _contentFormats *gdk.ContentFormats // out

	_contentFormats = gdk.WrapContentFormats(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_contentFormats, func(v *gdk.ContentFormats) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _contentFormats
}

func (s dropTarget) Preload() bool {
	var _arg0 *C.GtkDropTarget // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_target_get_preload(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s dropTarget) Value() *externglib.Value {
	var _arg0 *C.GtkDropTarget // out
	var _cret *C.GValue        // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_target_get_value(_arg0)

	var _value *externglib.Value // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_cret))

	return _value
}

func (s dropTarget) RejectDropTarget() {
	var _arg0 *C.GtkDropTarget // out

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

	C.gtk_drop_target_reject(_arg0)
}

func (s dropTarget) SetActionsDropTarget(actions gdk.DragAction) {
	var _arg0 *C.GtkDropTarget // out
	var _arg1 C.GdkDragAction  // out

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GdkDragAction)(actions)

	C.gtk_drop_target_set_actions(_arg0, _arg1)
}

func (s dropTarget) SetGTypesDropTarget(types []externglib.Type) {
	var _arg0 *C.GtkDropTarget // out
	var _arg1 *C.GType
	var _arg2 C.gsize

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(types))
	_arg1 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(types))
		for i := range types {
			out[i] = (C.GType)(types[i])
		}
	}

	C.gtk_drop_target_set_gtypes(_arg0, _arg1, _arg2)
}

func (s dropTarget) SetPreloadDropTarget(preload bool) {
	var _arg0 *C.GtkDropTarget // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))
	if preload {
		_arg1 = C.TRUE
	}

	C.gtk_drop_target_set_preload(_arg0, _arg1)
}

// DropTargetAsync: `GtkDropTargetAsync` is an event controller to receive
// Drag-and-Drop operations, asynchronously.
//
// It is the more complete but also more complex method of handling drop
// operations compared to [class@Gtk.DropTarget], and you should only use it if
// `GtkDropTarget` doesn't provide all the features you need.
//
// To use a `GtkDropTargetAsync` to receive drops on a widget, you create a
// `GtkDropTargetAsync` object, configure which data formats and actions you
// support, connect to its signals, and then attach it to the widget with
// [method@Gtk.Widget.add_controller].
//
// During a drag operation, the first signal that a `GtkDropTargetAsync` emits
// is [signal@Gtk.DropTargetAsync::accept], which is meant to determine whether
// the target is a possible drop site for the ongoing drop. The default handler
// for the ::accept signal accepts the drop if it finds a compatible data format
// and an action that is supported on both sides.
//
// If it is, and the widget becomes a target, you will receive a
// [signal@Gtk.DropTargetAsync::drag-enter] signal, followed by
// [signal@Gtk.DropTargetAsync::drag-motion] signals as the pointer moves,
// optionally a [signal@Gtk.DropTargetAsync::drop] signal when a drop happens,
// and finally a [signal@Gtk.DropTargetAsync::drag-leave] signal when the
// pointer moves off the widget.
//
// The ::drag-enter and ::drag-motion handler return a `GdkDragAction` to update
// the status of the ongoing operation. The ::drop handler should decide if it
// ultimately accepts the drop and if it does, it should initiate the data
// transfer and finish the operation by calling [method@Gdk.Drop.finish].
//
// Between the ::drag-enter and ::drag-leave signals the widget is a current
// drop target, and will receive the GTK_STATE_FLAG_DROP_ACTIVE state, which can
// be used by themes to style the widget as a drop target.
type DropTargetAsync interface {

	// Actions gets the actions that this drop target supports.
	Actions() gdk.DragAction
	// Formats gets the data formats that this drop target accepts.
	//
	// If the result is nil, all formats are expected to be supported.
	Formats() *gdk.ContentFormats
	// RejectDropDropTargetAsync sets the @drop as not accepted on this drag
	// site.
	//
	// This function should be used when delaying the decision on whether to
	// accept a drag or not until after reading the data.
	RejectDropDropTargetAsync(drop gdk.Drop)
	// SetActionsDropTargetAsync sets the actions that this drop target
	// supports.
	SetActionsDropTargetAsync(actions gdk.DragAction)
	// SetFormatsDropTargetAsync sets the data formats that this drop target
	// will accept.
	SetFormatsDropTargetAsync(formats *gdk.ContentFormats)
}

// dropTargetAsync implements the DropTargetAsync class.
type dropTargetAsync struct {
	EventController
}

// WrapDropTargetAsync wraps a GObject to the right type. It is
// primarily used internally.
func WrapDropTargetAsync(obj *externglib.Object) DropTargetAsync {
	return dropTargetAsync{
		EventController: WrapEventController(obj),
	}
}

func marshalDropTargetAsync(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDropTargetAsync(obj), nil
}

// NewDropTargetAsync creates a new `GtkDropTargetAsync` object.
func NewDropTargetAsync(formats *gdk.ContentFormats, actions gdk.DragAction) DropTargetAsync {
	var _arg1 *C.GdkContentFormats  // out
	var _arg2 C.GdkDragAction       // out
	var _cret *C.GtkDropTargetAsync // in

	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	_arg2 = (C.GdkDragAction)(actions)

	_cret = C.gtk_drop_target_async_new(_arg1, _arg2)

	var _dropTargetAsync DropTargetAsync // out

	_dropTargetAsync = WrapDropTargetAsync(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dropTargetAsync
}

func (s dropTargetAsync) Actions() gdk.DragAction {
	var _arg0 *C.GtkDropTargetAsync // out
	var _cret C.GdkDragAction       // in

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_target_async_get_actions(_arg0)

	var _dragAction gdk.DragAction // out

	_dragAction = gdk.DragAction(_cret)

	return _dragAction
}

func (s dropTargetAsync) Formats() *gdk.ContentFormats {
	var _arg0 *C.GtkDropTargetAsync // out
	var _cret *C.GdkContentFormats  // in

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_drop_target_async_get_formats(_arg0)

	var _contentFormats *gdk.ContentFormats // out

	_contentFormats = gdk.WrapContentFormats(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_contentFormats, func(v *gdk.ContentFormats) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _contentFormats
}

func (s dropTargetAsync) RejectDropDropTargetAsync(drop gdk.Drop) {
	var _arg0 *C.GtkDropTargetAsync // out
	var _arg1 *C.GdkDrop            // out

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkDrop)(unsafe.Pointer(drop.Native()))

	C.gtk_drop_target_async_reject_drop(_arg0, _arg1)
}

func (s dropTargetAsync) SetActionsDropTargetAsync(actions gdk.DragAction) {
	var _arg0 *C.GtkDropTargetAsync // out
	var _arg1 C.GdkDragAction       // out

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GdkDragAction)(actions)

	C.gtk_drop_target_async_set_actions(_arg0, _arg1)
}

func (s dropTargetAsync) SetFormatsDropTargetAsync(formats *gdk.ContentFormats) {
	var _arg0 *C.GtkDropTargetAsync // out
	var _arg1 *C.GdkContentFormats  // out

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))

	C.gtk_drop_target_async_set_formats(_arg0, _arg1)
}

// EditableLabel: a `GtkEditableLabel` is a label that allows users to edit the
// text by switching to an edit mode.
//
// !An example GtkEditableLabel (editable-label.png)
//
// `GtkEditableLabel` does not have API of its own, but it implements the
// [iface@Gtk.Editable] interface.
//
// The default bindings for activating the edit mode is to click or press the
// Enter key. The default bindings for leaving the edit mode are the Enter key
// (to save the results) or the Escape key (to cancel the editing).
//
//
// CSS nodes
//
// ` editablelabel[.editing]  stack  label  text `
//
// `GtkEditableLabel` has a main node with the name editablelabel. When the
// entry is in editing mode, it gets the .editing style class.
//
// For all the subnodes added to the text node in various situations, see
// [class@Gtk.Text].
type EditableLabel interface {
	Editable

	// Editing returns whether the label is currently in editing mode.
	Editing() bool
	// StartEditingEditableLabel switches the label into editing mode.
	StartEditingEditableLabel()
	// StopEditingEditableLabel switches the label out of editing mode.
	//
	// If @commit is true, the resulting text is kept as the
	// [property@Gtk.Editable:text] property value, otherwise the resulting text
	// is discarded and the label will keep its previous
	// [property@Gtk.Editable:text] property value.
	StopEditingEditableLabel(commit bool)
}

// editableLabel implements the EditableLabel class.
type editableLabel struct {
	Widget
}

// WrapEditableLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapEditableLabel(obj *externglib.Object) EditableLabel {
	return editableLabel{
		Widget: WrapWidget(obj),
	}
}

func marshalEditableLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEditableLabel(obj), nil
}

// NewEditableLabel creates a new `GtkEditableLabel` widget.
func NewEditableLabel(str string) EditableLabel {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_editable_label_new(_arg1)

	var _editableLabel EditableLabel // out

	_editableLabel = WrapEditableLabel(externglib.Take(unsafe.Pointer(_cret)))

	return _editableLabel
}

func (s editableLabel) Editing() bool {
	var _arg0 *C.GtkEditableLabel // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkEditableLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_editable_label_get_editing(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s editableLabel) StartEditingEditableLabel() {
	var _arg0 *C.GtkEditableLabel // out

	_arg0 = (*C.GtkEditableLabel)(unsafe.Pointer(s.Native()))

	C.gtk_editable_label_start_editing(_arg0)
}

func (s editableLabel) StopEditingEditableLabel(commit bool) {
	var _arg0 *C.GtkEditableLabel // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkEditableLabel)(unsafe.Pointer(s.Native()))
	if commit {
		_arg1 = C.TRUE
	}

	C.gtk_editable_label_stop_editing(_arg0, _arg1)
}

func (s editableLabel) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s editableLabel) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s editableLabel) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s editableLabel) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s editableLabel) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s editableLabel) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s editableLabel) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b editableLabel) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (e editableLabel) DeleteSelection() {
	WrapEditable(gextras.InternObject(e)).DeleteSelection()
}

func (e editableLabel) DeleteText(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).DeleteText(startPos, endPos)
}

func (e editableLabel) FinishDelegate() {
	WrapEditable(gextras.InternObject(e)).FinishDelegate()
}

func (e editableLabel) Alignment() float32 {
	return WrapEditable(gextras.InternObject(e)).Alignment()
}

func (e editableLabel) Chars(startPos int, endPos int) string {
	return WrapEditable(gextras.InternObject(e)).Chars(startPos, endPos)
}

func (e editableLabel) Delegate() Editable {
	return WrapEditable(gextras.InternObject(e)).Delegate()
}

func (e editableLabel) Editable() bool {
	return WrapEditable(gextras.InternObject(e)).Editable()
}

func (e editableLabel) EnableUndo() bool {
	return WrapEditable(gextras.InternObject(e)).EnableUndo()
}

func (e editableLabel) MaxWidthChars() int {
	return WrapEditable(gextras.InternObject(e)).MaxWidthChars()
}

func (e editableLabel) Position() int {
	return WrapEditable(gextras.InternObject(e)).Position()
}

func (e editableLabel) SelectionBounds() (startPos int, endPos int, ok bool) {
	return WrapEditable(gextras.InternObject(e)).SelectionBounds()
}

func (e editableLabel) Text() string {
	return WrapEditable(gextras.InternObject(e)).Text()
}

func (e editableLabel) WidthChars() int {
	return WrapEditable(gextras.InternObject(e)).WidthChars()
}

func (e editableLabel) InitDelegate() {
	WrapEditable(gextras.InternObject(e)).InitDelegate()
}

func (e editableLabel) SelectRegion(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).SelectRegion(startPos, endPos)
}

func (e editableLabel) SetAlignment(xalign float32) {
	WrapEditable(gextras.InternObject(e)).SetAlignment(xalign)
}

func (e editableLabel) SetEditable(isEditable bool) {
	WrapEditable(gextras.InternObject(e)).SetEditable(isEditable)
}

func (e editableLabel) SetEnableUndo(enableUndo bool) {
	WrapEditable(gextras.InternObject(e)).SetEnableUndo(enableUndo)
}

func (e editableLabel) SetMaxWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetMaxWidthChars(nChars)
}

func (e editableLabel) SetPosition(position int) {
	WrapEditable(gextras.InternObject(e)).SetPosition(position)
}

func (e editableLabel) SetText(text string) {
	WrapEditable(gextras.InternObject(e)).SetText(text)
}

func (e editableLabel) SetWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetWidthChars(nChars)
}

// EmojiChooser: the `GtkEmojiChooser` is used by text widgets such as
// `GtkEntry` or `GtkTextView` to let users insert Emoji characters.
//
// !An example GtkEmojiChooser (emojichooser.png)
//
// `GtkEmojiChooser` emits the [signal@Gtk.EmojiChooser::emoji-picked] signal
// when an Emoji is selected.
//
//
// CSS nodes
//
// ` popover  box.emoji-searchbar   entry.search  box.emoji-toolbar
//  button.image-button.emoji-section  ... 
// button.image-button.emoji-section `
//
// Every `GtkEmojiChooser` consists of a main node called popover. The contents
// of the popover are largely implementation defined and supposed to inherit
// general styles. The top searchbar used to search emoji and gets the
// .emoji-searchbar style class itself. The bottom toolbar used to switch
// between different emoji categories consists of buttons with the
// .emoji-section style class and gets the .emoji-toolbar style class itself.
type EmojiChooser interface {
	Popover
}

// emojiChooser implements the EmojiChooser class.
type emojiChooser struct {
	Popover
}

// WrapEmojiChooser wraps a GObject to the right type. It is
// primarily used internally.
func WrapEmojiChooser(obj *externglib.Object) EmojiChooser {
	return emojiChooser{
		Popover: WrapPopover(obj),
	}
}

func marshalEmojiChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEmojiChooser(obj), nil
}

// NewEmojiChooser creates a new `GtkEmojiChooser`.
func NewEmojiChooser() EmojiChooser {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_emoji_chooser_new()

	var _emojiChooser EmojiChooser // out

	_emojiChooser = WrapEmojiChooser(externglib.Take(unsafe.Pointer(_cret)))

	return _emojiChooser
}

func (s emojiChooser) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s emojiChooser) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s emojiChooser) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s emojiChooser) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s emojiChooser) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s emojiChooser) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s emojiChooser) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b emojiChooser) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s emojiChooser) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s emojiChooser) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s emojiChooser) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s emojiChooser) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s emojiChooser) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

// Entry: `GtkEntry` is a single line text entry widget.
//
// !An example GtkEntry (entry.png)
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into password mode using [method@Gtk.Entry.set_visibility]. In this
// mode, entered text is displayed using a invisible character. By default,
// GTK picks the best invisible character that is available in the current font,
// but it can be changed with [method@Gtk.Entry.set_invisible_char].
//
// `GtkEntry` has the ability to display progress or activity information behind
// the text. To make an entry display such information, use
// [method@Gtk.Entry.set_progress_fraction] or
// [method@Gtk.Entry.set_progress_pulse_step].
//
// Additionally, `GtkEntry` can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use [method@Gtk.Entry.set_icon_from_gicon] or
// one of the various other functions that set an icon from an icon name or a
// paintable. To trigger an action when the user clicks an icon, connect to the
// [signal@Gtk.Entry::icon-press] signal. To allow DND operations from an icon,
// use [method@Gtk.Entry.set_icon_drag_source]. To set a tooltip on an icon, use
// [method@Gtk.Entry.set_icon_tooltip_text] or the corresponding function for
// markup.
//
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
//
//
// CSS nodes
//
// ` entry[.flat][.warning][.error]  text[.readonly]  image.left 
// image.right  [progress[.pulse]] `
//
// `GtkEntry` has a main node with the name entry. Depending on the properties
// of the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry shows progress, it adds a subnode with the name progress. The
// node has the style class .pulse when the shown progress is pulsing.
//
// For all the subnodes added to the text node in various situations, see
// [class@Gtk.Text].
//
//
// GtkEntry as GtkBuildable
//
// The `GtkEntry` implementation of the `GtkBuildable` interface supports a
// custom <attributes> element, which supports any number of <attribute>
// elements. The <attribute> element has attributes named name, value,
// start and end and allows you to specify Attribute values for this label.
//
// An example of a UI definition fragment specifying Pango attributes: `xml
// <object class="GtkEnry"> <attributes> <attribute name="weight"
// value="PANGO_WEIGHT_BOLD"/> <attribute name="background" value="red"
// start="5" end="10"/> </attributes> </object> `
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
//
// Accessibility
//
// `GtkEntry` uses the GTK_ACCESSIBLE_ROLE_TEXT_BOX role.
type Entry interface {
	CellEditable
	Editable

	// ActivatesDefault retrieves the value set by
	// gtk_entry_set_activates_default().
	ActivatesDefault() bool
	// GetAlignment gets the value set by gtk_entry_set_alignment().
	//
	// See also: [property@Gtk.Editable:xalign]
	GetAlignment() float32
	// Attributes gets the attribute list of the `GtkEntry`.
	//
	// See [method@Gtk.Entry.set_attributes].
	Attributes() *pango.AttrList
	// Buffer: get the `GtkEntryBuffer` object which holds the text for this
	// widget.
	Buffer() EntryBuffer
	// Completion returns the auxiliary completion object currently in use by
	// @entry.
	Completion() EntryCompletion
	// CurrentIconDragSource returns the index of the icon which is the source
	// of the current DND operation, or -1.
	CurrentIconDragSource() int
	// ExtraMenu gets the menu model set with gtk_entry_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// HasFrame gets the value set by gtk_entry_set_has_frame().
	HasFrame() bool
	// IconActivatable returns whether the icon is activatable.
	IconActivatable(iconPos EntryIconPosition) bool
	// IconArea gets the area where entrys icon at @icon_pos is drawn.
	//
	// This function is useful when drawing something to the entry in a draw
	// callback.
	//
	// If the entry is not realized or has no icon at the given position,
	// @icon_area is filled with zeros. Otherwise, @icon_area will be filled
	// with the icon's allocation, relative to @entry's allocation.
	IconArea(iconPos EntryIconPosition) gdk.Rectangle
	// IconAtPos finds the icon at the given position and return its index.
	//
	// The positions coordinates are relative to the @entrys top left corner.
	// If @x, @y doesnt lie inside an icon, -1 is returned. This function is
	// intended for use in a [signal@Gtk.Widget::query-tooltip] signal handler.
	IconAtPos(x int, y int) int
	// IconGIcon retrieves the `GIcon` used for the icon.
	//
	// nil will be returned if there is no icon or if the icon was set by some
	// other method (e.g., by `GdkPaintable` or icon name).
	IconGIcon(iconPos EntryIconPosition) gio.Icon
	// IconName retrieves the icon name used for the icon.
	//
	// nil is returned if there is no icon or if the icon was set by some other
	// method (e.g., by `GdkPaintable` or gicon).
	IconName(iconPos EntryIconPosition) string
	// IconPaintable retrieves the `GdkPaintable` used for the icon.
	//
	// If no `GdkPaintable` was used for the icon, nil is returned.
	IconPaintable(iconPos EntryIconPosition) gdk.Paintable
	// IconSensitive returns whether the icon appears sensitive or insensitive.
	IconSensitive(iconPos EntryIconPosition) bool
	// IconStorageType gets the type of representation being used by the icon to
	// store image data.
	//
	// If the icon has no image data, the return value will be GTK_IMAGE_EMPTY.
	IconStorageType(iconPos EntryIconPosition) ImageType
	// IconTooltipMarkup gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipMarkup(iconPos EntryIconPosition) string
	// IconTooltipText gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipText(iconPos EntryIconPosition) string
	// InputHints gets the input hints of this `GtkEntry`.
	InputHints() InputHints
	// InputPurpose gets the input purpose of the `GtkEntry`.
	InputPurpose() InputPurpose
	// InvisibleChar retrieves the character displayed in place of the actual
	// text in password mode.
	InvisibleChar() uint32
	// MaxLength retrieves the maximum allowed length of the text in @entry.
	//
	// See [method@Gtk.Entry.set_max_length].
	MaxLength() int
	// OverwriteMode gets whether the `GtkEntry` is in overwrite mode.
	OverwriteMode() bool
	// PlaceholderText retrieves the text that will be displayed when @entry is
	// empty and unfocused
	PlaceholderText() string
	// ProgressFraction returns the current fraction of the task thats been
	// completed.
	//
	// See [method@Gtk.Entry.set_progress_fraction].
	ProgressFraction() float64
	// ProgressPulseStep retrieves the pulse step set with
	// gtk_entry_set_progress_pulse_step().
	ProgressPulseStep() float64
	// Tabs gets the tabstops of the `GtkEntry.
	//
	// See [method@Gtk.Entry.set_tabs].
	Tabs() *pango.TabArray
	// TextLength retrieves the current length of the text in @entry.
	//
	// This is equivalent to getting @entry's `GtkEntryBuffer` and calling
	// [method@Gtk.EntryBuffer.get_length] on it.
	TextLength() uint16
	// Visibility retrieves whether the text in @entry is visible.
	//
	// See [method@Gtk.Entry.set_visibility].
	Visibility() bool
	// GrabFocusWithoutSelectingEntry causes @entry to have keyboard focus.
	//
	// It behaves like [method@Gtk.Widget.grab_focus], except that it doesn't
	// select the contents of the entry. You only want to call this on some
	// special entries which the user usually doesn't want to replace all text
	// in, such as search-as-you-type entries.
	GrabFocusWithoutSelectingEntry() bool
	// ProgressPulseEntry indicates that some progress is made, but you dont
	// know how much.
	//
	// Causes the entrys progress indicator to enter activity mode, where a
	// block bounces back and forth. Each call to gtk_entry_progress_pulse()
	// causes the block to move by a little bit (the amount of movement per
	// pulse is determined by [method@Gtk.Entry.set_progress_pulse_step]).
	ProgressPulseEntry()
	// ResetImContextEntry: reset the input method context of the entry if
	// needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContextEntry()
	// SetActivatesDefaultEntry sets whether pressing Enter in the @entry will
	// activate the default widget for the window containing the entry.
	//
	// This usually means that the dialog containing the entry will be closed,
	// since the default widget is usually one of the dialog buttons.
	SetActivatesDefaultEntry(setting bool)
	// SetAlignmentEntry sets the alignment for the contents of the entry.
	//
	// This controls the horizontal positioning of the contents when the
	// displayed text is shorter than the width of the entry.
	//
	// See also: [property@Gtk.Editable:xalign]
	SetAlignmentEntry(xalign float32)
	// SetAttributesEntry sets a `PangoAttrList`.
	//
	// The attributes in the list are applied to the entry text.
	//
	// Since the attributes will be applies to text that changes as the user
	// types, it makes most sense to use attributes with unlimited extent.
	SetAttributesEntry(attrs *pango.AttrList)
	// SetBufferEntry: set the `GtkEntryBuffer` object which holds the text for
	// this widget.
	SetBufferEntry(buffer EntryBuffer)
	// SetCompletionEntry sets @completion to be the auxiliary completion object
	// to use with @entry.
	//
	// All further configuration of the completion mechanism is done on
	// @completion using the `GtkEntryCompletion` API. Completion is disabled if
	// @completion is set to nil.
	SetCompletionEntry(completion EntryCompletion)
	// SetExtraMenuEntry sets a menu model to add when constructing the context
	// menu for @entry.
	SetExtraMenuEntry(model gio.MenuModel)
	// SetHasFrameEntry sets whether the entry has a beveled frame around it.
	SetHasFrameEntry(setting bool)
	// SetIconActivatableEntry sets whether the icon is activatable.
	SetIconActivatableEntry(iconPos EntryIconPosition, activatable bool)
	// SetIconDragSourceEntry sets up the icon at the given position as drag
	// source.
	//
	// This makes it so that GTK will start a drag operation when the user
	// clicks and drags the icon.
	SetIconDragSourceEntry(iconPos EntryIconPosition, provider gdk.ContentProvider, actions gdk.DragAction)
	// SetIconFromGIconEntry sets the icon shown in the entry at the specified
	// position from the current icon theme.
	//
	// If the icon isnt known, a broken image icon will be displayed instead.
	//
	// If @icon is nil, no icon will be shown in the specified position.
	SetIconFromGIconEntry(iconPos EntryIconPosition, icon gio.Icon)
	// SetIconFromIconNameEntry sets the icon shown in the entry at the
	// specified position from the current icon theme.
	//
	// If the icon name isnt known, a broken image icon will be displayed
	// instead.
	//
	// If @icon_name is nil, no icon will be shown in the specified position.
	SetIconFromIconNameEntry(iconPos EntryIconPosition, iconName string)
	// SetIconFromPaintableEntry sets the icon shown in the specified position
	// using a `GdkPaintable`.
	//
	// If @paintable is nil, no icon will be shown in the specified position.
	SetIconFromPaintableEntry(iconPos EntryIconPosition, paintable gdk.Paintable)
	// SetIconSensitiveEntry sets the sensitivity for the specified icon.
	SetIconSensitiveEntry(iconPos EntryIconPosition, sensitive bool)
	// SetIconTooltipMarkupEntry sets @tooltip as the contents of the tooltip
	// for the icon at the specified position.
	//
	// @tooltip is assumed to be marked up with Pango Markup.
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also [method@Gtk.Widget.set_tooltip_markup] and
	// [method@Gtk.Entry.set_icon_tooltip_text].
	SetIconTooltipMarkupEntry(iconPos EntryIconPosition, tooltip string)
	// SetIconTooltipTextEntry sets @tooltip as the contents of the tooltip for
	// the icon at the specified position.
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also [method@Gtk.Widget.set_tooltip_text] and
	// [method@Gtk.Entry.set_icon_tooltip_markup].
	//
	// If you unset the widget tooltip via [method@Gtk.Widget.set_tooltip_text]
	// or [method@Gtk.Widget.set_tooltip_markup], this sets
	// [property@Gtk.Widget:has-tooltip] to false, which suppresses icon
	// tooltips too. You can resolve this by then calling
	// [method@Gtk.Widget.set_has_tooltip] to set
	// [property@Gtk.Widget:has-tooltip] back to true, or setting at least one
	// non-empty tooltip on any icon achieves the same result.
	SetIconTooltipTextEntry(iconPos EntryIconPosition, tooltip string)
	// SetInputHintsEntry: set additional hints which allow input methods to
	// fine-tune their behavior.
	SetInputHintsEntry(hints InputHints)
	// SetInputPurposeEntry sets the input purpose which can be used by input
	// methods to adjust their behavior.
	SetInputPurposeEntry(purpose InputPurpose)
	// SetInvisibleCharEntry sets the character to use in place of the actual
	// text in password mode.
	//
	// See [method@Gtk.Entry.set_visibility] for how to enable password mode.
	//
	// By default, GTK picks the best invisible char available in the current
	// font. If you set the invisible char to 0, then the user will get no
	// feedback at all; there will be no text on the screen as they type.
	SetInvisibleCharEntry(ch uint32)
	// SetMaxLengthEntry sets the maximum allowed length of the contents of the
	// widget.
	//
	// If the current contents are longer than the given length, then they will
	// be truncated to fit.
	//
	// This is equivalent to getting @entry's `GtkEntryBuffer` and calling
	// [method@Gtk.EntryBuffer.set_max_length] on it.
	SetMaxLengthEntry(max int)
	// SetOverwriteModeEntry sets whether the text is overwritten when typing in
	// the `GtkEntry`.
	SetOverwriteModeEntry(overwrite bool)
	// SetPlaceholderTextEntry sets text to be displayed in @entry when it is
	// empty.
	//
	// This can be used to give a visual hint of the expected contents of the
	// `GtkEntry`.
	SetPlaceholderTextEntry(text string)
	// SetProgressFractionEntry causes the entrys progress indicator to fill
	// in the given fraction of the bar.
	//
	// The fraction should be between 0.0 and 1.0, inclusive.
	SetProgressFractionEntry(fraction float64)
	// SetProgressPulseStepEntry sets the fraction of total entry width to move
	// the progress bouncing block for each pulse.
	//
	// Use [method@Gtk.Entry.progress_pulse] to pulse the progress.
	SetProgressPulseStepEntry(fraction float64)
	// SetTabsEntry sets a `PangoTabArray`.
	//
	// The tabstops in the array are applied to the entry text.
	SetTabsEntry(tabs *pango.TabArray)
	// SetVisibilityEntry sets whether the contents of the entry are visible or
	// not.
	//
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the entry
	// widget is copied elsewhere.
	//
	// By default, GTK picks the best invisible character available in the
	// current font, but it can be changed with
	// [method@Gtk.Entry.set_invisible_char].
	//
	// Note that you probably want to set [property@Gtk.Entry:input-purpose] to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this entry, in addition to setting
	// visibility to false.
	SetVisibilityEntry(visible bool)
	// UnsetInvisibleCharEntry unsets the invisible char, so that the default
	// invisible char is used again. See [method@Gtk.Entry.set_invisible_char].
	UnsetInvisibleCharEntry()
}

// entry implements the Entry class.
type entry struct {
	Widget
}

// WrapEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntry(obj *externglib.Object) Entry {
	return entry{
		Widget: WrapWidget(obj),
	}
}

func marshalEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntry(obj), nil
}

// NewEntry creates a new entry.
func NewEntry() Entry {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_entry_new()

	var _entry Entry // out

	_entry = WrapEntry(externglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

// NewEntryWithBuffer creates a new entry with the specified text buffer.
func NewEntryWithBuffer(buffer EntryBuffer) Entry {
	var _arg1 *C.GtkEntryBuffer // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_entry_new_with_buffer(_arg1)

	var _entry Entry // out

	_entry = WrapEntry(externglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

func (e entry) ActivatesDefault() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_activates_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e entry) GetAlignment() float32 {
	var _arg0 *C.GtkEntry // out
	var _cret C.float     // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_alignment(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (e entry) Attributes() *pango.AttrList {
	var _arg0 *C.GtkEntry      // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_attributes(_arg0)

	var _attrList *pango.AttrList // out

	_attrList = pango.WrapAttrList(unsafe.Pointer(_cret))

	return _attrList
}

func (e entry) Buffer() EntryBuffer {
	var _arg0 *C.GtkEntry       // out
	var _cret *C.GtkEntryBuffer // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_buffer(_arg0)

	var _entryBuffer EntryBuffer // out

	_entryBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryBuffer)

	return _entryBuffer
}

func (e entry) Completion() EntryCompletion {
	var _arg0 *C.GtkEntry           // out
	var _cret *C.GtkEntryCompletion // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_completion(_arg0)

	var _entryCompletion EntryCompletion // out

	_entryCompletion = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryCompletion)

	return _entryCompletion
}

func (e entry) CurrentIconDragSource() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.int       // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_current_icon_drag_source(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (e entry) ExtraMenu() gio.MenuModel {
	var _arg0 *C.GtkEntry   // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_extra_menu(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (e entry) HasFrame() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_has_frame(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e entry) IconActivatable(iconPos EntryIconPosition) bool {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_activatable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e entry) IconArea(iconPos EntryIconPosition) gdk.Rectangle {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _iconArea gdk.Rectangle

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	C.gtk_entry_get_icon_area(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_iconArea)))

	return _iconArea
}

func (e entry) IconAtPos(x int, y int) int {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.int       // out
	var _arg2 C.int       // out
	var _cret C.int       // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)

	_cret = C.gtk_entry_get_icon_at_pos(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (e entry) IconGIcon(iconPos EntryIconPosition) gio.Icon {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.GIcon               // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_gicon(_arg0, _arg1)

	var _icon gio.Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

	return _icon
}

func (e entry) IconName(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_name(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (e entry) IconPaintable(iconPos EntryIconPosition) gdk.Paintable {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.GdkPaintable        // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_paintable(_arg0, _arg1)

	var _paintable gdk.Paintable // out

	_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

	return _paintable
}

func (e entry) IconSensitive(iconPos EntryIconPosition) bool {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_sensitive(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e entry) IconStorageType(iconPos EntryIconPosition) ImageType {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret C.GtkImageType         // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_storage_type(_arg0, _arg1)

	var _imageType ImageType // out

	_imageType = ImageType(_cret)

	return _imageType
}

func (e entry) IconTooltipMarkup(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_tooltip_markup(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (e entry) IconTooltipText(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_tooltip_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (e entry) InputHints() InputHints {
	var _arg0 *C.GtkEntry     // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_input_hints(_arg0)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

func (e entry) InputPurpose() InputPurpose {
	var _arg0 *C.GtkEntry       // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_input_purpose(_arg0)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

func (e entry) InvisibleChar() uint32 {
	var _arg0 *C.GtkEntry // out
	var _cret C.gunichar  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_invisible_char(_arg0)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

func (e entry) MaxLength() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.int       // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_max_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (e entry) OverwriteMode() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_overwrite_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e entry) PlaceholderText() string {
	var _arg0 *C.GtkEntry // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_placeholder_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (e entry) ProgressFraction() float64 {
	var _arg0 *C.GtkEntry // out
	var _cret C.double    // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_progress_fraction(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (e entry) ProgressPulseStep() float64 {
	var _arg0 *C.GtkEntry // out
	var _cret C.double    // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_progress_pulse_step(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (e entry) Tabs() *pango.TabArray {
	var _arg0 *C.GtkEntry      // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_tabs(_arg0)

	var _tabArray *pango.TabArray // out

	_tabArray = pango.WrapTabArray(unsafe.Pointer(_cret))

	return _tabArray
}

func (e entry) TextLength() uint16 {
	var _arg0 *C.GtkEntry // out
	var _cret C.guint16   // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_text_length(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

func (e entry) Visibility() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_visibility(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e entry) GrabFocusWithoutSelectingEntry() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_grab_focus_without_selecting(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e entry) ProgressPulseEntry() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_progress_pulse(_arg0)
}

func (e entry) ResetImContextEntry() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_reset_im_context(_arg0)
}

func (e entry) SetActivatesDefaultEntry(setting bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_activates_default(_arg0, _arg1)
}

func (e entry) SetAlignmentEntry(xalign float32) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.float     // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.float)(xalign)

	C.gtk_entry_set_alignment(_arg0, _arg1)
}

func (e entry) SetAttributesEntry(attrs *pango.AttrList) {
	var _arg0 *C.GtkEntry      // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_entry_set_attributes(_arg0, _arg1)
}

func (e entry) SetBufferEntry(buffer EntryBuffer) {
	var _arg0 *C.GtkEntry       // out
	var _arg1 *C.GtkEntryBuffer // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_entry_set_buffer(_arg0, _arg1)
}

func (e entry) SetCompletionEntry(completion EntryCompletion) {
	var _arg0 *C.GtkEntry           // out
	var _arg1 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkEntryCompletion)(unsafe.Pointer(completion.Native()))

	C.gtk_entry_set_completion(_arg0, _arg1)
}

func (e entry) SetExtraMenuEntry(model gio.MenuModel) {
	var _arg0 *C.GtkEntry   // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_entry_set_extra_menu(_arg0, _arg1)
}

func (e entry) SetHasFrameEntry(setting bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_has_frame(_arg0, _arg1)
}

func (e entry) SetIconActivatableEntry(iconPos EntryIconPosition, activatable bool) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 C.gboolean             // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	if activatable {
		_arg2 = C.TRUE
	}

	C.gtk_entry_set_icon_activatable(_arg0, _arg1, _arg2)
}

func (e entry) SetIconDragSourceEntry(iconPos EntryIconPosition, provider gdk.ContentProvider, actions gdk.DragAction) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.GdkContentProvider  // out
	var _arg3 C.GdkDragAction        // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.GdkContentProvider)(unsafe.Pointer(provider.Native()))
	_arg3 = (C.GdkDragAction)(actions)

	C.gtk_entry_set_icon_drag_source(_arg0, _arg1, _arg2, _arg3)
}

func (e entry) SetIconFromGIconEntry(iconPos EntryIconPosition, icon gio.Icon) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.GIcon               // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_entry_set_icon_from_gicon(_arg0, _arg1, _arg2)
}

func (e entry) SetIconFromIconNameEntry(iconPos EntryIconPosition, iconName string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.char                // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_set_icon_from_icon_name(_arg0, _arg1, _arg2)
}

func (e entry) SetIconFromPaintableEntry(iconPos EntryIconPosition, paintable gdk.Paintable) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.GdkPaintable        // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_entry_set_icon_from_paintable(_arg0, _arg1, _arg2)
}

func (e entry) SetIconSensitiveEntry(iconPos EntryIconPosition, sensitive bool) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 C.gboolean             // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	if sensitive {
		_arg2 = C.TRUE
	}

	C.gtk_entry_set_icon_sensitive(_arg0, _arg1, _arg2)
}

func (e entry) SetIconTooltipMarkupEntry(iconPos EntryIconPosition, tooltip string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.char                // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.char)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_set_icon_tooltip_markup(_arg0, _arg1, _arg2)
}

func (e entry) SetIconTooltipTextEntry(iconPos EntryIconPosition, tooltip string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.char                // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.char)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_set_icon_tooltip_text(_arg0, _arg1, _arg2)
}

func (e entry) SetInputHintsEntry(hints InputHints) {
	var _arg0 *C.GtkEntry     // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkInputHints)(hints)

	C.gtk_entry_set_input_hints(_arg0, _arg1)
}

func (e entry) SetInputPurposeEntry(purpose InputPurpose) {
	var _arg0 *C.GtkEntry       // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_entry_set_input_purpose(_arg0, _arg1)
}

func (e entry) SetInvisibleCharEntry(ch uint32) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gunichar  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gunichar)(ch)

	C.gtk_entry_set_invisible_char(_arg0, _arg1)
}

func (e entry) SetMaxLengthEntry(max int) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.int)(max)

	C.gtk_entry_set_max_length(_arg0, _arg1)
}

func (e entry) SetOverwriteModeEntry(overwrite bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_overwrite_mode(_arg0, _arg1)
}

func (e entry) SetPlaceholderTextEntry(text string) {
	var _arg0 *C.GtkEntry // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_entry_set_placeholder_text(_arg0, _arg1)
}

func (e entry) SetProgressFractionEntry(fraction float64) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.double    // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.double)(fraction)

	C.gtk_entry_set_progress_fraction(_arg0, _arg1)
}

func (e entry) SetProgressPulseStepEntry(fraction float64) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.double    // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.double)(fraction)

	C.gtk_entry_set_progress_pulse_step(_arg0, _arg1)
}

func (e entry) SetTabsEntry(tabs *pango.TabArray) {
	var _arg0 *C.GtkEntry      // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.gtk_entry_set_tabs(_arg0, _arg1)
}

func (e entry) SetVisibilityEntry(visible bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_visibility(_arg0, _arg1)
}

func (e entry) UnsetInvisibleCharEntry() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_unset_invisible_char(_arg0)
}

func (s entry) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s entry) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s entry) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s entry) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s entry) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s entry) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s entry) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b entry) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c entry) EditingDone() {
	WrapCellEditable(gextras.InternObject(c)).EditingDone()
}

func (c entry) RemoveWidget() {
	WrapCellEditable(gextras.InternObject(c)).RemoveWidget()
}

func (c entry) StartEditing(event gdk.Event) {
	WrapCellEditable(gextras.InternObject(c)).StartEditing(event)
}

func (e entry) DeleteSelection() {
	WrapEditable(gextras.InternObject(e)).DeleteSelection()
}

func (e entry) DeleteText(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).DeleteText(startPos, endPos)
}

func (e entry) FinishDelegate() {
	WrapEditable(gextras.InternObject(e)).FinishDelegate()
}

func (e entry) Alignment() float32 {
	return WrapEditable(gextras.InternObject(e)).Alignment()
}

func (e entry) Chars(startPos int, endPos int) string {
	return WrapEditable(gextras.InternObject(e)).Chars(startPos, endPos)
}

func (e entry) Delegate() Editable {
	return WrapEditable(gextras.InternObject(e)).Delegate()
}

func (e entry) Editable() bool {
	return WrapEditable(gextras.InternObject(e)).Editable()
}

func (e entry) EnableUndo() bool {
	return WrapEditable(gextras.InternObject(e)).EnableUndo()
}

func (e entry) MaxWidthChars() int {
	return WrapEditable(gextras.InternObject(e)).MaxWidthChars()
}

func (e entry) Position() int {
	return WrapEditable(gextras.InternObject(e)).Position()
}

func (e entry) SelectionBounds() (startPos int, endPos int, ok bool) {
	return WrapEditable(gextras.InternObject(e)).SelectionBounds()
}

func (e entry) Text() string {
	return WrapEditable(gextras.InternObject(e)).Text()
}

func (e entry) WidthChars() int {
	return WrapEditable(gextras.InternObject(e)).WidthChars()
}

func (e entry) InitDelegate() {
	WrapEditable(gextras.InternObject(e)).InitDelegate()
}

func (e entry) SelectRegion(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).SelectRegion(startPos, endPos)
}

func (e entry) SetAlignment(xalign float32) {
	WrapEditable(gextras.InternObject(e)).SetAlignment(xalign)
}

func (e entry) SetEditable(isEditable bool) {
	WrapEditable(gextras.InternObject(e)).SetEditable(isEditable)
}

func (e entry) SetEnableUndo(enableUndo bool) {
	WrapEditable(gextras.InternObject(e)).SetEnableUndo(enableUndo)
}

func (e entry) SetMaxWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetMaxWidthChars(nChars)
}

func (e entry) SetPosition(position int) {
	WrapEditable(gextras.InternObject(e)).SetPosition(position)
}

func (e entry) SetText(text string) {
	WrapEditable(gextras.InternObject(e)).SetText(text)
}

func (e entry) SetWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetWidthChars(nChars)
}

// EntryBuffer: a `GtkEntryBuffer` hold the text displayed in a `GtkText`
// widget.
//
// A single `GtkEntryBuffer` object can be shared by multiple widgets which will
// then share the same text content, but not the cursor position, visibility
// attributes, icon etc.
//
// `GtkEntryBuffer` may be derived from. Such a derived class might allow text
// to be stored in an alternate location, such as non-pageable memory, useful in
// the case of important passwords. Or a derived class could integrate with an
// applications concept of undo/redo.
type EntryBuffer interface {

	// DeleteTextEntryBuffer deletes a sequence of characters from the buffer.
	//
	// @n_chars characters are deleted starting at @position. If @n_chars is
	// negative, then all characters until the end of the text are deleted.
	//
	// If @position or @n_chars are out of bounds, then they are coerced to sane
	// values.
	//
	// Note that the positions are specified in characters, not bytes.
	DeleteTextEntryBuffer(position uint, nChars int) uint
	// EmitDeletedTextEntryBuffer: used when subclassing `GtkEntryBuffer`.
	EmitDeletedTextEntryBuffer(position uint, nChars uint)
	// EmitInsertedTextEntryBuffer: used when subclassing `GtkEntryBuffer`.
	EmitInsertedTextEntryBuffer(position uint, chars string, nChars uint)
	// Bytes retrieves the length in bytes of the buffer.
	//
	// See [method@Gtk.EntryBuffer.get_length].
	Bytes() uint
	// Length retrieves the length in characters of the buffer.
	Length() uint
	// MaxLength retrieves the maximum allowed length of the text in @buffer.
	MaxLength() int
	// Text retrieves the contents of the buffer.
	//
	// The memory pointer returned by this call will not change unless this
	// object emits a signal, or is finalized.
	Text() string
	// InsertTextEntryBuffer inserts @n_chars characters of @chars into the
	// contents of the buffer, at position @position.
	//
	// If @n_chars is negative, then characters from chars will be inserted
	// until a null-terminator is found. If @position or @n_chars are out of
	// bounds, or the maximum buffer text length is exceeded, then they are
	// coerced to sane values.
	//
	// Note that the position and length are in characters, not in bytes.
	InsertTextEntryBuffer(position uint, chars string, nChars int) uint
	// SetMaxLengthEntryBuffer sets the maximum allowed length of the contents
	// of the buffer.
	//
	// If the current contents are longer than the given length, then they will
	// be truncated to fit.
	SetMaxLengthEntryBuffer(maxLength int)
	// SetTextEntryBuffer sets the text in the buffer.
	//
	// This is roughly equivalent to calling
	// [method@Gtk.EntryBuffer.delete_text] and
	// [method@Gtk.EntryBuffer.insert_text].
	//
	// Note that @n_chars is in characters, not in bytes.
	SetTextEntryBuffer(chars string, nChars int)
}

// entryBuffer implements the EntryBuffer class.
type entryBuffer struct {
	gextras.Objector
}

// WrapEntryBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryBuffer(obj *externglib.Object) EntryBuffer {
	return entryBuffer{
		Objector: obj,
	}
}

func marshalEntryBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryBuffer(obj), nil
}

// NewEntryBuffer: create a new `GtkEntryBuffer` object.
//
// Optionally, specify initial text to set in the buffer.
func NewEntryBuffer(initialChars string, nInitialChars int) EntryBuffer {
	var _arg1 *C.char           // out
	var _arg2 C.int             // out
	var _cret *C.GtkEntryBuffer // in

	_arg1 = (*C.char)(C.CString(initialChars))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(nInitialChars)

	_cret = C.gtk_entry_buffer_new(_arg1, _arg2)

	var _entryBuffer EntryBuffer // out

	_entryBuffer = WrapEntryBuffer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryBuffer
}

func (b entryBuffer) DeleteTextEntryBuffer(position uint, nChars int) uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 C.int             // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.int)(nChars)

	_cret = C.gtk_entry_buffer_delete_text(_arg0, _arg1, _arg2)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (b entryBuffer) EmitDeletedTextEntryBuffer(position uint, nChars uint) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 C.guint           // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.guint)(nChars)

	C.gtk_entry_buffer_emit_deleted_text(_arg0, _arg1, _arg2)
}

func (b entryBuffer) EmitInsertedTextEntryBuffer(position uint, chars string, nChars uint) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 *C.char           // out
	var _arg3 C.guint           // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (*C.char)(C.CString(chars))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.guint)(nChars)

	C.gtk_entry_buffer_emit_inserted_text(_arg0, _arg1, _arg2, _arg3)
}

func (b entryBuffer) Bytes() uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.gsize           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_entry_buffer_get_bytes(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (b entryBuffer) Length() uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_entry_buffer_get_length(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (b entryBuffer) MaxLength() int {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.int             // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_entry_buffer_get_max_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (b entryBuffer) Text() string {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_entry_buffer_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (b entryBuffer) InsertTextEntryBuffer(position uint, chars string, nChars int) uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 *C.char           // out
	var _arg3 C.int             // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (*C.char)(C.CString(chars))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.int)(nChars)

	_cret = C.gtk_entry_buffer_insert_text(_arg0, _arg1, _arg2, _arg3)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (b entryBuffer) SetMaxLengthEntryBuffer(maxLength int) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.int             // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(maxLength)

	C.gtk_entry_buffer_set_max_length(_arg0, _arg1)
}

func (b entryBuffer) SetTextEntryBuffer(chars string, nChars int) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 *C.char           // out
	var _arg2 C.int             // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(chars))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(nChars)

	C.gtk_entry_buffer_set_text(_arg0, _arg1, _arg2)
}

// EntryCompletion: `GtkEntryCompletion` is an auxiliary object to provide
// completion functionality for `GtkEntry`.
//
// It implements the [iface@Gtk.CellLayout] interface, to allow the user to add
// extra cells to the `GtkTreeView` with completion matches.
//
// Completion functionality means that when the user modifies the text in the
// entry, `GtkEntryCompletion` checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see [method@Gtk.EntryCompletion.set_text_column]),
// but this can be overridden with a custom match function (see
// [method@Gtk.EntryCompletion.set_match_func]).
//
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// [signal@Gtk.EntryCompletion::match-selected] signal and updating the entry in
// the signal handler. Note that you should return true from the signal handler
// to suppress the default behaviour.
//
// To add completion functionality to an entry, use
// [method@Gtk.Entry.set_completion].
//
// `GtkEntryCompletion` uses a [class@Gtk.TreeModelFilter] model to represent
// the subset of the entire model that is currently matching. While the
// `GtkEntryCompletion` signals [signal@Gtk.EntryCompletion::match-selected] and
// [signal@Gtk.EntryCompletion::cursor-on-match] take the original model and an
// iter pointing to that model as arguments, other callbacks and signals (such
// as `GtkCellLayoutDataFunc` or [signal@Gtk.CellArea::apply-attributes)] will
// generally take the filter model as argument. As long as you are only calling
// [method@Gtk.TreeModel.get], this will make no difference to you. If for some
// reason, you need the original model, use
// [method@Gtk.TreeModelFilter.get_model]. Dont forget to use
// [method@Gtk.TreeModelFilter.convert_iter_to_child_iter] to obtain a matching
// iter.
type EntryCompletion interface {
	Buildable
	CellLayout

	// CompleteEntryCompletion requests a completion operation, or in other
	// words a refiltering of the current list with completions, using the
	// current key.
	//
	// The completion list view will be updated accordingly.
	CompleteEntryCompletion()
	// ComputePrefixEntryCompletion computes the common prefix that is shared by
	// all rows in @completion that start with @key.
	//
	// If no row matches @key, nil will be returned. Note that a text column
	// must have been set for this function to work, see
	// [method@Gtk.EntryCompletion.set_text_column] for details.
	ComputePrefixEntryCompletion(key string) string
	// CompletionPrefix: get the original text entered by the user that
	// triggered the completion or nil if theres no completion ongoing.
	CompletionPrefix() string
	// Entry gets the entry @completion has been attached to.
	Entry() Widget
	// InlineCompletion returns whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	InlineCompletion() bool
	// InlineSelection returns true if inline-selection mode is turned on.
	InlineSelection() bool
	// MinimumKeyLength returns the minimum key length as set for @completion.
	MinimumKeyLength() int
	// Model returns the model the `GtkEntryCompletion` is using as data source.
	//
	// Returns nil if the model is unset.
	Model() TreeModel
	// PopupCompletion returns whether the completions should be presented in a
	// popup window.
	PopupCompletion() bool
	// PopupSetWidth returns whether the completion popup window will be resized
	// to the width of the entry.
	PopupSetWidth() bool
	// PopupSingleMatch returns whether the completion popup window will appear
	// even if there is only a single match.
	PopupSingleMatch() bool
	// TextColumn returns the column in the model of @completion to get strings
	// from.
	TextColumn() int
	// InsertPrefixEntryCompletion requests a prefix insertion.
	InsertPrefixEntryCompletion()
	// SetInlineCompletionEntryCompletion sets whether the common prefix of the
	// possible completions should be automatically inserted in the entry.
	SetInlineCompletionEntryCompletion(inlineCompletion bool)
	// SetInlineSelectionEntryCompletion sets whether it is possible to cycle
	// through the possible completions inside the entry.
	SetInlineSelectionEntryCompletion(inlineSelection bool)
	// SetMinimumKeyLengthEntryCompletion requires the length of the search key
	// for @completion to be at least @length.
	//
	// This is useful for long lists, where completing using a small key takes a
	// lot of time and will come up with meaningless results anyway (ie, a too
	// large dataset).
	SetMinimumKeyLengthEntryCompletion(length int)
	// SetModelEntryCompletion sets the model for a `GtkEntryCompletion`.
	//
	// If @completion already has a model set, it will remove it before setting
	// the new model. If model is nil, then it will unset the model.
	SetModelEntryCompletion(model TreeModel)
	// SetPopupCompletionEntryCompletion sets whether the completions should be
	// presented in a popup window.
	SetPopupCompletionEntryCompletion(popupCompletion bool)
	// SetPopupSetWidthEntryCompletion sets whether the completion popup window
	// will be resized to be the same width as the entry.
	SetPopupSetWidthEntryCompletion(popupSetWidth bool)
	// SetPopupSingleMatchEntryCompletion sets whether the completion popup
	// window will appear even if there is only a single match.
	//
	// You may want to set this to false if you are using
	// [property@Gtk.EntryCompletion:inline-completion].
	SetPopupSingleMatchEntryCompletion(popupSingleMatch bool)
	// SetTextColumnEntryCompletion: convenience function for setting up the
	// most used case of this code: a completion list with just strings.
	//
	// This function will set up @completion to have a list displaying all (and
	// just) strings in the completion list, and to get those strings from
	// @column in the model of @completion.
	//
	// This functions creates and adds a `GtkCellRendererText` for the selected
	// column. If you need to set the text column, but don't want the cell
	// renderer, use g_object_set() to set the
	// [property@Gtk.EntryCompletion:text-column] property directly.
	SetTextColumnEntryCompletion(column int)
}

// entryCompletion implements the EntryCompletion class.
type entryCompletion struct {
	gextras.Objector
}

// WrapEntryCompletion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryCompletion(obj *externglib.Object) EntryCompletion {
	return entryCompletion{
		Objector: obj,
	}
}

func marshalEntryCompletion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryCompletion(obj), nil
}

// NewEntryCompletion creates a new `GtkEntryCompletion` object.
func NewEntryCompletion() EntryCompletion {
	var _cret *C.GtkEntryCompletion // in

	_cret = C.gtk_entry_completion_new()

	var _entryCompletion EntryCompletion // out

	_entryCompletion = WrapEntryCompletion(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryCompletion
}

// NewEntryCompletionWithArea creates a new `GtkEntryCompletion` object using
// the specified @area.
//
// The `GtkCellArea` is used to layout cells in the underlying
// `GtkTreeViewColumn` for the drop-down menu.
func NewEntryCompletionWithArea(area CellArea) EntryCompletion {
	var _arg1 *C.GtkCellArea        // out
	var _cret *C.GtkEntryCompletion // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	_cret = C.gtk_entry_completion_new_with_area(_arg1)

	var _entryCompletion EntryCompletion // out

	_entryCompletion = WrapEntryCompletion(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryCompletion
}

func (c entryCompletion) CompleteEntryCompletion() {
	var _arg0 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	C.gtk_entry_completion_complete(_arg0)
}

func (c entryCompletion) ComputePrefixEntryCompletion(key string) string {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 *C.char               // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_entry_completion_compute_prefix(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (c entryCompletion) CompletionPrefix() string {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_completion_prefix(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c entryCompletion) Entry() Widget {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.GtkWidget          // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_entry(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (c entryCompletion) InlineCompletion() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_inline_completion(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c entryCompletion) InlineSelection() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_inline_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c entryCompletion) MinimumKeyLength() int {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_minimum_key_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c entryCompletion) Model() TreeModel {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.GtkTreeModel       // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

func (c entryCompletion) PopupCompletion() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_popup_completion(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c entryCompletion) PopupSetWidth() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_popup_set_width(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c entryCompletion) PopupSingleMatch() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_popup_single_match(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c entryCompletion) TextColumn() int {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_text_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c entryCompletion) InsertPrefixEntryCompletion() {
	var _arg0 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	C.gtk_entry_completion_insert_prefix(_arg0)
}

func (c entryCompletion) SetInlineCompletionEntryCompletion(inlineCompletion bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if inlineCompletion {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_inline_completion(_arg0, _arg1)
}

func (c entryCompletion) SetInlineSelectionEntryCompletion(inlineSelection bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if inlineSelection {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_inline_selection(_arg0, _arg1)
}

func (c entryCompletion) SetMinimumKeyLengthEntryCompletion(length int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(length)

	C.gtk_entry_completion_set_minimum_key_length(_arg0, _arg1)
}

func (c entryCompletion) SetModelEntryCompletion(model TreeModel) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 *C.GtkTreeModel       // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_entry_completion_set_model(_arg0, _arg1)
}

func (c entryCompletion) SetPopupCompletionEntryCompletion(popupCompletion bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupCompletion {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_completion(_arg0, _arg1)
}

func (c entryCompletion) SetPopupSetWidthEntryCompletion(popupSetWidth bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupSetWidth {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_set_width(_arg0, _arg1)
}

func (c entryCompletion) SetPopupSingleMatchEntryCompletion(popupSingleMatch bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupSingleMatch {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_single_match(_arg0, _arg1)
}

func (c entryCompletion) SetTextColumnEntryCompletion(column int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(column)

	C.gtk_entry_completion_set_text_column(_arg0, _arg1)
}

func (b entryCompletion) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c entryCompletion) AddAttribute(cell CellRenderer, attribute string, column int) {
	WrapCellLayout(gextras.InternObject(c)).AddAttribute(cell, attribute, column)
}

func (c entryCompletion) Clear() {
	WrapCellLayout(gextras.InternObject(c)).Clear()
}

func (c entryCompletion) ClearAttributes(cell CellRenderer) {
	WrapCellLayout(gextras.InternObject(c)).ClearAttributes(cell)
}

func (c entryCompletion) Area() CellArea {
	return WrapCellLayout(gextras.InternObject(c)).Area()
}

func (c entryCompletion) PackEnd(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackEnd(cell, expand)
}

func (c entryCompletion) PackStart(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackStart(cell, expand)
}

func (c entryCompletion) Reorder(cell CellRenderer, position int) {
	WrapCellLayout(gextras.InternObject(c)).Reorder(cell, position)
}

// EventController: `GtkEventController` is the base class for event
// controllers.
//
// These are ancillary objects associated to widgets, which react to
// `GdkEvents`, and possibly trigger actions as a consequence.
//
// Event controllers are added to a widget with
// [method@Gtk.Widget.add_controller]. It is rarely necessary to explicitly
// remove a controller with [method@Gtk.Widget.remove_controller].
//
// See the chapter of input handling (input-handling.html) for an overview of
// the basic concepts, such as the capture and bubble phases of even
// propagation.
type EventController interface {

	// CurrentEvent returns the event that is currently being handled by the
	// controller, and nil at other times.
	CurrentEvent() gdk.Event
	// CurrentEventDevice returns the device of the event that is currently
	// being handled by the controller, and nil otherwise.
	CurrentEventDevice() gdk.Device
	// CurrentEventState returns the modifier state of the event that is
	// currently being handled by the controller, and 0 otherwise.
	CurrentEventState() gdk.ModifierType
	// CurrentEventTime returns the timestamp of the event that is currently
	// being handled by the controller, and 0 otherwise.
	CurrentEventTime() uint32
	// Name gets the name of @controller.
	Name() string
	// PropagationLimit gets the propagation limit of the event controller.
	PropagationLimit() PropagationLimit
	// PropagationPhase gets the propagation phase at which @controller handles
	// events.
	PropagationPhase() PropagationPhase
	// Widget returns the Widget this controller relates to.
	Widget() Widget
	// ResetEventController resets the @controller to a clean state.
	ResetEventController()
	// SetNameEventController sets a name on the controller that can be used for
	// debugging.
	SetNameEventController(name string)
	// SetPropagationLimitEventController sets the event propagation limit on
	// the event controller.
	//
	// If the limit is set to GTK_LIMIT_SAME_NATIVE, the controller won't handle
	// events that are targeted at widgets on a different surface, such as
	// popovers.
	SetPropagationLimitEventController(limit PropagationLimit)
	// SetPropagationPhaseEventController sets the propagation phase at which a
	// controller handles events.
	//
	// If @phase is GTK_PHASE_NONE, no automatic event handling will be
	// performed, but other additional gesture maintenance will.
	SetPropagationPhaseEventController(phase PropagationPhase)
}

// eventController implements the EventController class.
type eventController struct {
	gextras.Objector
}

// WrapEventController wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventController(obj *externglib.Object) EventController {
	return eventController{
		Objector: obj,
	}
}

func marshalEventController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventController(obj), nil
}

func (c eventController) CurrentEvent() gdk.Event {
	var _arg0 *C.GtkEventController // out
	var _cret *C.GdkEvent           // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_current_event(_arg0)

	var _event gdk.Event // out

	_event = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Event)

	return _event
}

func (c eventController) CurrentEventDevice() gdk.Device {
	var _arg0 *C.GtkEventController // out
	var _cret *C.GdkDevice          // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_current_event_device(_arg0)

	var _device gdk.Device // out

	_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Device)

	return _device
}

func (c eventController) CurrentEventState() gdk.ModifierType {
	var _arg0 *C.GtkEventController // out
	var _cret C.GdkModifierType     // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_current_event_state(_arg0)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

func (c eventController) CurrentEventTime() uint32 {
	var _arg0 *C.GtkEventController // out
	var _cret C.guint32             // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_current_event_time(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

func (c eventController) Name() string {
	var _arg0 *C.GtkEventController // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c eventController) PropagationLimit() PropagationLimit {
	var _arg0 *C.GtkEventController // out
	var _cret C.GtkPropagationLimit // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_propagation_limit(_arg0)

	var _propagationLimit PropagationLimit // out

	_propagationLimit = PropagationLimit(_cret)

	return _propagationLimit
}

func (c eventController) PropagationPhase() PropagationPhase {
	var _arg0 *C.GtkEventController // out
	var _cret C.GtkPropagationPhase // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_propagation_phase(_arg0)

	var _propagationPhase PropagationPhase // out

	_propagationPhase = PropagationPhase(_cret)

	return _propagationPhase
}

func (c eventController) Widget() Widget {
	var _arg0 *C.GtkEventController // out
	var _cret *C.GtkWidget          // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (c eventController) ResetEventController() {
	var _arg0 *C.GtkEventController // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	C.gtk_event_controller_reset(_arg0)
}

func (c eventController) SetNameEventController(name string) {
	var _arg0 *C.GtkEventController // out
	var _arg1 *C.char               // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_event_controller_set_name(_arg0, _arg1)
}

func (c eventController) SetPropagationLimitEventController(limit PropagationLimit) {
	var _arg0 *C.GtkEventController // out
	var _arg1 C.GtkPropagationLimit // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkPropagationLimit)(limit)

	C.gtk_event_controller_set_propagation_limit(_arg0, _arg1)
}

func (c eventController) SetPropagationPhaseEventController(phase PropagationPhase) {
	var _arg0 *C.GtkEventController // out
	var _arg1 C.GtkPropagationPhase // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkPropagationPhase)(phase)

	C.gtk_event_controller_set_propagation_phase(_arg0, _arg1)
}

// EventControllerFocus: `GtkEventControllerFocus` is an event controller to
// keep track of keyboard focus.
//
// The event controller offers [signal@Gtk.EventControllerFocus::enter] and
// [signal@Gtk.EventControllerFocus::leave] signals, as well as
// [property@Gtk.EventControllerFocus:is-focus] and
// [property@Gtk.EventControllerFocus:contains-focus] properties which are
// updated to reflect focus changes inside the widget hierarchy that is rooted
// at the controllers widget.
type EventControllerFocus interface {

	// ContainsFocusEventControllerFocus returns true if focus is within @self
	// or one of its children.
	ContainsFocusEventControllerFocus() bool
	// IsFocusEventControllerFocus returns true if focus is within @self, but
	// not one of its children.
	IsFocusEventControllerFocus() bool
}

// eventControllerFocus implements the EventControllerFocus class.
type eventControllerFocus struct {
	EventController
}

// WrapEventControllerFocus wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerFocus(obj *externglib.Object) EventControllerFocus {
	return eventControllerFocus{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerFocus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerFocus(obj), nil
}

// NewEventControllerFocus creates a new event controller that will handle focus
// events.
func NewEventControllerFocus() EventControllerFocus {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_event_controller_focus_new()

	var _eventControllerFocus EventControllerFocus // out

	_eventControllerFocus = WrapEventControllerFocus(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerFocus
}

func (s eventControllerFocus) ContainsFocusEventControllerFocus() bool {
	var _arg0 *C.GtkEventControllerFocus // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkEventControllerFocus)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_event_controller_focus_contains_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s eventControllerFocus) IsFocusEventControllerFocus() bool {
	var _arg0 *C.GtkEventControllerFocus // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkEventControllerFocus)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_event_controller_focus_is_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EventControllerKey: `GtkEventControllerKey` is an event controller that
// provides access to key events.
type EventControllerKey interface {

	// ForwardEventControllerKey forwards the current event of this @controller
	// to a @widget.
	//
	// This function can only be used in handlers for the
	// [signal@Gtk.EventControllerKey::key-pressed],
	// [signal@Gtk.EventControllerKey::key-released] or
	// [signal@Gtk.EventControllerKey::modifiers] signals.
	ForwardEventControllerKey(widget Widget) bool
	// Group gets the key group of the current event of this @controller.
	//
	// See [method@Gdk.KeyEvent.get_layout].
	Group() uint
	// ImContext gets the input method context of the key @controller.
	ImContext() IMContext
	// SetImContextEventControllerKey sets the input method context of the key
	// @controller.
	SetImContextEventControllerKey(imContext IMContext)
}

// eventControllerKey implements the EventControllerKey class.
type eventControllerKey struct {
	EventController
}

// WrapEventControllerKey wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerKey(obj *externglib.Object) EventControllerKey {
	return eventControllerKey{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerKey(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerKey(obj), nil
}

// NewEventControllerKey creates a new event controller that will handle key
// events.
func NewEventControllerKey() EventControllerKey {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_event_controller_key_new()

	var _eventControllerKey EventControllerKey // out

	_eventControllerKey = WrapEventControllerKey(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerKey
}

func (c eventControllerKey) ForwardEventControllerKey(widget Widget) bool {
	var _arg0 *C.GtkEventControllerKey // out
	var _arg1 *C.GtkWidget             // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_event_controller_key_forward(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c eventControllerKey) Group() uint {
	var _arg0 *C.GtkEventControllerKey // out
	var _cret C.guint                  // in

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_key_get_group(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (c eventControllerKey) ImContext() IMContext {
	var _arg0 *C.GtkEventControllerKey // out
	var _cret *C.GtkIMContext          // in

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_key_get_im_context(_arg0)

	var _imContext IMContext // out

	_imContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IMContext)

	return _imContext
}

func (c eventControllerKey) SetImContextEventControllerKey(imContext IMContext) {
	var _arg0 *C.GtkEventControllerKey // out
	var _arg1 *C.GtkIMContext          // out

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkIMContext)(unsafe.Pointer(imContext.Native()))

	C.gtk_event_controller_key_set_im_context(_arg0, _arg1)
}

// EventControllerLegacy: `GtkEventControllerLegacy` is an event controller that
// provides raw access to the event stream.
//
// It should only be used as a last resort if none of the other event
// controllers or gestures do the job.
type EventControllerLegacy interface {
}

// eventControllerLegacy implements the EventControllerLegacy class.
type eventControllerLegacy struct {
	EventController
}

// WrapEventControllerLegacy wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerLegacy(obj *externglib.Object) EventControllerLegacy {
	return eventControllerLegacy{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerLegacy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerLegacy(obj), nil
}

// NewEventControllerLegacy creates a new legacy event controller.
func NewEventControllerLegacy() EventControllerLegacy {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_event_controller_legacy_new()

	var _eventControllerLegacy EventControllerLegacy // out

	_eventControllerLegacy = WrapEventControllerLegacy(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerLegacy
}

// EventControllerMotion: `GtkEventControllerMotion` is an event controller
// tracking the pointer position.
//
// The event controller offers [signal@Gtk.EventControllerMotion::enter] and
// [signal@Gtk.EventControllerMotion::leave] signals, as well as
// [property@Gtk.EventControllerMotion:is-pointer] and
// [property@Gtk.EventControllerMotion:contains-pointer] properties which are
// updated to reflect changes in the pointer position as it moves over the
// widget.
type EventControllerMotion interface {

	// ContainsPointerEventControllerMotion returns if a pointer is within @self
	// or one of its children.
	ContainsPointerEventControllerMotion() bool
	// IsPointerEventControllerMotion returns if a pointer is within @self, but
	// not one of its children.
	IsPointerEventControllerMotion() bool
}

// eventControllerMotion implements the EventControllerMotion class.
type eventControllerMotion struct {
	EventController
}

// WrapEventControllerMotion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerMotion(obj *externglib.Object) EventControllerMotion {
	return eventControllerMotion{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerMotion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerMotion(obj), nil
}

// NewEventControllerMotion creates a new event controller that will handle
// motion events.
func NewEventControllerMotion() EventControllerMotion {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_event_controller_motion_new()

	var _eventControllerMotion EventControllerMotion // out

	_eventControllerMotion = WrapEventControllerMotion(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerMotion
}

func (s eventControllerMotion) ContainsPointerEventControllerMotion() bool {
	var _arg0 *C.GtkEventControllerMotion // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GtkEventControllerMotion)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_event_controller_motion_contains_pointer(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s eventControllerMotion) IsPointerEventControllerMotion() bool {
	var _arg0 *C.GtkEventControllerMotion // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GtkEventControllerMotion)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_event_controller_motion_is_pointer(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EventControllerScroll: `GtkEventControllerScroll` is an event controller that
// handles scroll events.
//
// It is capable of handling both discrete and continuous scroll events from
// mice or touchpads, abstracting them both with the
// [signal@Gtk.EventControllerScroll::scroll] signal. Deltas in the discrete
// case are multiples of 1.
//
// In the case of continuous scroll events, `GtkEventControllerScroll` encloses
// all [signal@Gtk.EventControllerScroll::scroll] emissions between two
// [signal@Gtk.EventControllerScroll::scroll-begin] and
// [signal@Gtk.EventControllerScroll::scroll-end] signals.
//
// The behavior of the event controller can be modified by the flags given at
// creation time, or modified at a later point through
// [method@Gtk.EventControllerScroll.set_flags] (e.g. because the scrolling
// conditions of the widget changed).
//
// The controller can be set up to emit motion for either/both vertical and
// horizontal scroll events through GTK_EVENT_CONTROLLER_SCROLL_VERTICAL,
// GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL and
// GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES. If any axis is disabled, the
// respective [signal@Gtk.EventControllerScroll::scroll] delta will be 0.
// Vertical scroll events will be translated to horizontal motion for the
// devices incapable of horizontal scrolling.
//
// The event controller can also be forced to emit discrete events on all
// devices through GTK_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used to
// implement discrete actions triggered through scroll events (e.g. switching
// across combobox options).
//
// The GTK_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
// [signal@Gtk.EventControllerScroll::decelerate] signal, emitted at the end of
// scrolling with two X/Y velocity arguments that are consistent with the motion
// that was received.
type EventControllerScroll interface {

	// Flags gets the flags conditioning the scroll controller behavior.
	Flags() EventControllerScrollFlags
	// SetFlagsEventControllerScroll sets the flags conditioning scroll
	// controller behavior.
	SetFlagsEventControllerScroll(flags EventControllerScrollFlags)
}

// eventControllerScroll implements the EventControllerScroll class.
type eventControllerScroll struct {
	EventController
}

// WrapEventControllerScroll wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerScroll(obj *externglib.Object) EventControllerScroll {
	return eventControllerScroll{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerScroll(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerScroll(obj), nil
}

// NewEventControllerScroll creates a new event controller that will handle
// scroll events.
func NewEventControllerScroll(flags EventControllerScrollFlags) EventControllerScroll {
	var _arg1 C.GtkEventControllerScrollFlags // out
	var _cret *C.GtkEventController           // in

	_arg1 = (C.GtkEventControllerScrollFlags)(flags)

	_cret = C.gtk_event_controller_scroll_new(_arg1)

	var _eventControllerScroll EventControllerScroll // out

	_eventControllerScroll = WrapEventControllerScroll(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerScroll
}

func (s eventControllerScroll) Flags() EventControllerScrollFlags {
	var _arg0 *C.GtkEventControllerScroll     // out
	var _cret C.GtkEventControllerScrollFlags // in

	_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_event_controller_scroll_get_flags(_arg0)

	var _eventControllerScrollFlags EventControllerScrollFlags // out

	_eventControllerScrollFlags = EventControllerScrollFlags(_cret)

	return _eventControllerScrollFlags
}

func (s eventControllerScroll) SetFlagsEventControllerScroll(flags EventControllerScrollFlags) {
	var _arg0 *C.GtkEventControllerScroll     // out
	var _arg1 C.GtkEventControllerScrollFlags // out

	_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkEventControllerScrollFlags)(flags)

	C.gtk_event_controller_scroll_set_flags(_arg0, _arg1)
}

// EveryFilter: `GtkEveryFilter` matches an item when each of its filters
// matches.
//
// To add filters to a `GtkEveryFilter`, use [method@Gtk.MultiFilter.append].
type EveryFilter interface {
	MultiFilter
}

// everyFilter implements the EveryFilter class.
type everyFilter struct {
	MultiFilter
}

// WrapEveryFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapEveryFilter(obj *externglib.Object) EveryFilter {
	return everyFilter{
		MultiFilter: WrapMultiFilter(obj),
	}
}

func marshalEveryFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEveryFilter(obj), nil
}

// NewEveryFilter creates a new empty "every" filter.
//
// Use [method@Gtk.MultiFilter.append] to add filters to it.
//
// This filter matches an item if each of the filters added to it matches the
// item. In particular, this means that if no filter has been added to it, the
// filter matches every item.
func NewEveryFilter() EveryFilter {
	var _cret *C.GtkEveryFilter // in

	_cret = C.gtk_every_filter_new()

	var _everyFilter EveryFilter // out

	_everyFilter = WrapEveryFilter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _everyFilter
}

func (b everyFilter) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Expander: `GtkExpander` allows the user to reveal its child by clicking on an
// expander triangle.
//
// !An example GtkExpander (expander.png)
//
// This is similar to the triangles used in a `GtkTreeView`.
//
// Normally you use an expander as you would use a frame; you create the child
// widget and use [method@Gtk.Expander.set_child] to add it to the expander.
// When the expander is toggled, it will take care of showing and hiding the
// child automatically.
//
//
// Special Usage
//
// There are situations in which you may prefer to show and hide the expanded
// widget yourself, such as when you want to actually create the widget at
// expansion time. In this case, create a `GtkExpander` but do not add a child
// to it. The expander widget has an [property@Gtk.Expander:expanded[ property
// which can be used to monitor its expansion state. You should watch this
// property with a signal connection as follows:
//
// `c static void expander_callback (GObject *object, GParamSpec *param_spec,
// gpointer user_data) { GtkExpander *expander;
//
//    expander = GTK_EXPANDER (object);
//
//    if (gtk_expander_get_expanded (expander))
//      {
//        // Show or create widgets
//      }
//    else
//      {
//        // Hide or destroy widgets
//      }
//
// }
//
// static void create_expander (void) { GtkWidget *expander =
// gtk_expander_new_with_mnemonic ("_More Options"); g_signal_connect (expander,
// "notify::expanded", G_CALLBACK (expander_callback), NULL);
//
//    // ...
//
// } `
//
//
// GtkExpander as GtkBuildable
//
// The `GtkExpander` implementation of the `GtkBuildable` interface supports
// placing a child in the label position by specifying label as the type
// attribute of a <child> element. A normal content child can be specified
// without specifying a <child> type attribute.
//
// An example of a UI definition fragment with GtkExpander:
//
// `xml <object class="GtkExpander"> <child type="label"> <object
// class="GtkLabel" id="expander-label"/> </child> <child> <object
// class="GtkEntry" id="expander-content"/> </child> </object> `
//
//
// CSS nodes
//
// ` expander  box  title   arrow   <label widget>  <child> `
//
// `GtkExpander` has three CSS nodes, the main node with the name expander, a
// subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
//
//
// Accessibility
//
// `GtkExpander` uses the GTK_ACCESSIBLE_ROLE_BUTTON role.
type Expander interface {
	Widget

	// Child gets the child widget of @expander.
	Child() Widget
	// Expanded queries a Expander and returns its current state.
	//
	// Returns true if the child widget is revealed.
	Expanded() bool
	// Label fetches the text from a label widget.
	//
	// This is including any embedded underlines indicating mnemonics and Pango
	// markup, as set by [method@Gtk.Expander.set_label]. If the label text has
	// not been set the return value will be nil. This will be the case if you
	// create an empty button with gtk_button_new() to use as a container.
	Label() string
	// LabelWidget retrieves the label widget for the frame.
	LabelWidget() Widget
	// ResizeToplevel returns whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	ResizeToplevel() bool
	// UseMarkup returns whether the labels text is interpreted as Pango
	// markup.
	UseMarkup() bool
	// UseUnderline returns whether an underline in the text indicates a
	// mnemonic.
	UseUnderline() bool
	// SetChildExpander sets the child widget of @expander.
	SetChildExpander(child Widget)
	// SetExpandedExpander sets the state of the expander.
	//
	// Set to true, if you want the child widget to be revealed, and false if
	// you want the child widget to be hidden.
	SetExpandedExpander(expanded bool)
	// SetLabelExpander sets the text of the label of the expander to @label.
	//
	// This will also clear any previously set labels.
	SetLabelExpander(label string)
	// SetLabelWidgetExpander: set the label widget for the expander.
	//
	// This is the widget that will appear embedded alongside the expander
	// arrow.
	SetLabelWidgetExpander(labelWidget Widget)
	// SetResizeToplevelExpander sets whether the expander will resize the
	// toplevel widget containing the expander upon resizing and collpasing.
	SetResizeToplevelExpander(resizeToplevel bool)
	// SetUseMarkupExpander sets whether the text of the label contains Pango
	// markup.
	SetUseMarkupExpander(useMarkup bool)
	// SetUseUnderlineExpander: if true, an underline in the text indicates a
	// mnemonic.
	SetUseUnderlineExpander(useUnderline bool)
}

// expander implements the Expander class.
type expander struct {
	Widget
}

// WrapExpander wraps a GObject to the right type. It is
// primarily used internally.
func WrapExpander(obj *externglib.Object) Expander {
	return expander{
		Widget: WrapWidget(obj),
	}
}

func marshalExpander(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapExpander(obj), nil
}

// NewExpander creates a new expander using @label as the text of the label.
func NewExpander(label string) Expander {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_expander_new(_arg1)

	var _expander Expander // out

	_expander = WrapExpander(externglib.Take(unsafe.Pointer(_cret)))

	return _expander
}

// NewExpanderWithMnemonic creates a new expander using @label as the text of
// the label.
//
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use __ (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic.
//
// Pressing Alt and that key activates the button.
func NewExpanderWithMnemonic(label string) Expander {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_expander_new_with_mnemonic(_arg1)

	var _expander Expander // out

	_expander = WrapExpander(externglib.Take(unsafe.Pointer(_cret)))

	return _expander
}

func (e expander) Child() Widget {
	var _arg0 *C.GtkExpander // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (e expander) Expanded() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_expanded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e expander) Label() string {
	var _arg0 *C.GtkExpander // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (e expander) LabelWidget() Widget {
	var _arg0 *C.GtkExpander // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_label_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (e expander) ResizeToplevel() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_resize_toplevel(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e expander) UseMarkup() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_use_markup(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e expander) UseUnderline() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e expander) SetChildExpander(child Widget) {
	var _arg0 *C.GtkExpander // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_expander_set_child(_arg0, _arg1)
}

func (e expander) SetExpandedExpander(expanded bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if expanded {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_expanded(_arg0, _arg1)
}

func (e expander) SetLabelExpander(label string) {
	var _arg0 *C.GtkExpander // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_expander_set_label(_arg0, _arg1)
}

func (e expander) SetLabelWidgetExpander(labelWidget Widget) {
	var _arg0 *C.GtkExpander // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

	C.gtk_expander_set_label_widget(_arg0, _arg1)
}

func (e expander) SetResizeToplevelExpander(resizeToplevel bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if resizeToplevel {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_resize_toplevel(_arg0, _arg1)
}

func (e expander) SetUseMarkupExpander(useMarkup bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if useMarkup {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_use_markup(_arg0, _arg1)
}

func (e expander) SetUseUnderlineExpander(useUnderline bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_use_underline(_arg0, _arg1)
}

func (s expander) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s expander) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s expander) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s expander) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s expander) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s expander) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s expander) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b expander) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// FileChooserDialog: `GtkFileChooserDialog` is a dialog suitable for use with
// File Open or File Save commands.
//
// !An example GtkFileChooserDialog (filechooser.png)
//
// This widget works by putting a [class@Gtk.FileChooserWidget] inside a
// [class@Gtk.Dialog]. It exposes the [iface@Gtk.FileChooser] interface, so you
// can use all of the [iface@Gtk.FileChooser] functions on the file chooser
// dialog as well as those for [class@Gtk.Dialog].
//
// Note that `GtkFileChooserDialog` does not have any methods of its own.
// Instead, you should use the functions that work on a [iface@Gtk.FileChooser].
//
// If you want to integrate well with the platform you should use the
// [class@Gtk.FileChooserNative] API, which will use a platform-specific dialog
// if available and fall back to `GtkFileChooserDialog` otherwise.
//
//
// Typical usage
//
// In the simplest of cases, you can the following code to use
// `GtkFileChooserDialog` to select a file for opening:
//
// `c static void on_open_response (GtkDialog *dialog, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (dialog);
//
//        g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//        open_file (file);
//      }
//
//    gtk_window_destroy (GTK_WINDOW (dialog));
//
// }
//
//    // ...
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//
//    gtk_widget_show (dialog);
//
//    g_signal_connect (dialog, "response",
//                      G_CALLBACK (on_open_response),
//                      NULL);
//
// `
//
// To use a dialog for saving, you can use this:
//
// `c static void on_save_response (GtkDialog *dialog, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (dialog);
//
//        g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//        save_to_file (file);
//      }
//
//    gtk_window_destroy (GTK_WINDOW (dialog));
//
// }
//
//    // ...
//    GtkWidget *dialog;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//    dialog = gtk_file_chooser_dialog_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Save"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//    chooser = GTK_FILE_CHOOSER (dialog);
//
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//    else
//      gtk_file_chooser_set_file (chooser, existing_filename);
//
//    gtk_widget_show (dialog);
//
//    g_signal_connect (dialog, "response",
//                      G_CALLBACK (on_save_response),
//                      NULL);
//
// `
//
//
// Setting up a file chooser dialog
//
// There are various cases in which you may need to use a
// `GtkFileChooserDialog`:
//
// - To select a file for opening, use GTK_FILE_CHOOSER_ACTION_OPEN.
//
// - To save a file for the first time, use GTK_FILE_CHOOSER_ACTION_SAVE, and
// suggest a name such as Untitled with
// [method@Gtk.FileChooser.set_current_name].
//
// - To save a file under a different name, use GTK_FILE_CHOOSER_ACTION_SAVE,
// and set the existing file with [method@Gtk.FileChooser.set_file].
//
// - To choose a folder instead of a filem use
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// In general, you should only cause the file chooser to show a specific folder
// when it is appropriate to use [method@Gtk,FileChooser.set_file], i.e. when
// you are doing a Save As command and you already have a file saved
// somewhere.
//
//
// Response Codes
//
// `GtkFileChooserDialog` inherits from [class@Gtk.Dialog], so buttons that go
// in its action area have response codes such as GTK_RESPONSE_ACCEPT and
// GTK_RESPONSE_CANCEL. For example, you could call
// [ctor@Gtk.FileChooserDialog.new] as follows:
//
// `c GtkWidget *dialog; GtkFileChooserAction action =
// GTK_FILE_CHOOSER_ACTION_OPEN;
//
// dialog = gtk_file_chooser_dialog_new ("Open File", parent_window, action,
// _("_Cancel"), GTK_RESPONSE_CANCEL, _("_Open"), GTK_RESPONSE_ACCEPT, NULL); `
//
// This will create buttons for Cancel and Open that use predefined response
// identifiers from [enum@Gtk.ResponseType]. For most dialog boxes you can use
// your own custom response codes rather than the ones in
// [enum@Gtk.ResponseType], but `GtkFileChooserDialog` assumes that its
// accept-type action, e.g. an Open or Save button, will have one of the
// following response codes:
//
// - GTK_RESPONSE_ACCEPT - GTK_RESPONSE_OK - GTK_RESPONSE_YES -
// GTK_RESPONSE_APPLY
//
// This is because `GtkFileChooserDialog` must intercept responses and switch to
// folders if appropriate, rather than letting the dialog terminate  the
// implementation uses these known response codes to know which responses can be
// blocked if appropriate.
//
// To summarize, make sure you use a predefined response code when you use
// `GtkFileChooserDialog` to ensure proper operation.
type FileChooserDialog interface {
	Dialog
	FileChooser
}

// fileChooserDialog implements the FileChooserDialog class.
type fileChooserDialog struct {
	Dialog
}

// WrapFileChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserDialog(obj *externglib.Object) FileChooserDialog {
	return fileChooserDialog{
		Dialog: WrapDialog(obj),
	}
}

func marshalFileChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserDialog(obj), nil
}

func (s fileChooserDialog) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s fileChooserDialog) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s fileChooserDialog) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s fileChooserDialog) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s fileChooserDialog) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s fileChooserDialog) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s fileChooserDialog) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b fileChooserDialog) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c fileChooserDialog) AddChoice(id string, label string, options []string, optionLabels []string) {
	WrapFileChooser(gextras.InternObject(c)).AddChoice(id, label, options, optionLabels)
}

func (c fileChooserDialog) AddFilter(filter FileFilter) {
	WrapFileChooser(gextras.InternObject(c)).AddFilter(filter)
}

func (c fileChooserDialog) AddShortcutFolder(folder gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).AddShortcutFolder(folder)
}

func (c fileChooserDialog) Action() FileChooserAction {
	return WrapFileChooser(gextras.InternObject(c)).Action()
}

func (c fileChooserDialog) Choice(id string) string {
	return WrapFileChooser(gextras.InternObject(c)).Choice(id)
}

func (c fileChooserDialog) CreateFolders() bool {
	return WrapFileChooser(gextras.InternObject(c)).CreateFolders()
}

func (c fileChooserDialog) CurrentFolder() gio.File {
	return WrapFileChooser(gextras.InternObject(c)).CurrentFolder()
}

func (c fileChooserDialog) CurrentName() string {
	return WrapFileChooser(gextras.InternObject(c)).CurrentName()
}

func (c fileChooserDialog) File() gio.File {
	return WrapFileChooser(gextras.InternObject(c)).File()
}

func (c fileChooserDialog) Files() gio.ListModel {
	return WrapFileChooser(gextras.InternObject(c)).Files()
}

func (c fileChooserDialog) Filter() FileFilter {
	return WrapFileChooser(gextras.InternObject(c)).Filter()
}

func (c fileChooserDialog) Filters() gio.ListModel {
	return WrapFileChooser(gextras.InternObject(c)).Filters()
}

func (c fileChooserDialog) SelectMultiple() bool {
	return WrapFileChooser(gextras.InternObject(c)).SelectMultiple()
}

func (c fileChooserDialog) ShortcutFolders() gio.ListModel {
	return WrapFileChooser(gextras.InternObject(c)).ShortcutFolders()
}

func (c fileChooserDialog) RemoveChoice(id string) {
	WrapFileChooser(gextras.InternObject(c)).RemoveChoice(id)
}

func (c fileChooserDialog) RemoveFilter(filter FileFilter) {
	WrapFileChooser(gextras.InternObject(c)).RemoveFilter(filter)
}

func (c fileChooserDialog) RemoveShortcutFolder(folder gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).RemoveShortcutFolder(folder)
}

func (c fileChooserDialog) SetAction(action FileChooserAction) {
	WrapFileChooser(gextras.InternObject(c)).SetAction(action)
}

func (c fileChooserDialog) SetChoice(id string, option string) {
	WrapFileChooser(gextras.InternObject(c)).SetChoice(id, option)
}

func (c fileChooserDialog) SetCreateFolders(createFolders bool) {
	WrapFileChooser(gextras.InternObject(c)).SetCreateFolders(createFolders)
}

func (c fileChooserDialog) SetCurrentFolder(file gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).SetCurrentFolder(file)
}

func (c fileChooserDialog) SetCurrentName(name string) {
	WrapFileChooser(gextras.InternObject(c)).SetCurrentName(name)
}

func (c fileChooserDialog) SetFile(file gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).SetFile(file)
}

func (c fileChooserDialog) SetFilter(filter FileFilter) {
	WrapFileChooser(gextras.InternObject(c)).SetFilter(filter)
}

func (c fileChooserDialog) SetSelectMultiple(selectMultiple bool) {
	WrapFileChooser(gextras.InternObject(c)).SetSelectMultiple(selectMultiple)
}

func (s fileChooserDialog) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s fileChooserDialog) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s fileChooserDialog) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s fileChooserDialog) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s fileChooserDialog) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s fileChooserDialog) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s fileChooserDialog) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s fileChooserDialog) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// FileChooserNative: `GtkFileChooserNative` is an abstraction of a dialog
// suitable for use with File Open or File Save as commands.
//
// By default, this just uses a `GtkFileChooserDialog` to implement the actual
// dialog. However, on some platforms, such as Windows and macOS, the native
// platform file chooser is used instead. When the application is running in a
// sandboxed environment without direct filesystem access (such as Flatpak),
// `GtkFileChooserNative` may call the proper APIs (portals) to let the user
// choose a file and make it available to the application.
//
// While the API of `GtkFileChooserNative` closely mirrors
// `GtkFileChooserDialog`, the main difference is that there is no access to any
// `GtkWindow` or `GtkWidget` for the dialog. This is required, as there may not
// be one in the case of a platform native dialog.
//
// Showing, hiding and running the dialog is handled by the
// [class@Gtk.NativeDialog] functions.
//
// Note that unlike `GtkFileChooserDialog`, `GtkFileChooserNative` objects are
// not toplevel widgets, and GTK does not keep them alive. It is your
// responsibility to keep a reference until you are done with the object.
//
//
// Typical usage
//
// In the simplest of cases, you can the following code to use
// `GtkFileChooserNative` to select a file for opening:
//
// `c static void on_response (GtkNativeDialog *native, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (native); GFile *file = gtk_file_chooser_get_file (chooser);
//
//        open_file (file);
//
//        g_object_unref (file);
//      }
//
//    g_object_unref (native);
//
// }
//
//    // ...
//    GtkFileChooserNative *native;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//    native = gtk_file_chooser_native_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          "_Open",
//                                          "_Cancel");
//
//    g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//    gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
//
// `
//
// To use a `GtkFileChooserNative` for saving, you can use this:
//
// `c static void on_response (GtkNativeDialog *native, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (native); GFile *file = gtk_file_chooser_get_file (chooser);
//
//        save_to_file (file);
//
//        g_object_unref (file);
//      }
//
//    g_object_unref (native);
//
// }
//
//    // ...
//    GtkFileChooserNative *native;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//    native = gtk_file_chooser_native_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          "_Save",
//                                          "_Cancel");
//    chooser = GTK_FILE_CHOOSER (native);
//
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//    else
//      gtk_file_chooser_set_file (chooser, existing_file, NULL);
//
//    g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//    gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
//
// `
//
// For more information on how to best set up a file dialog, see the
// [class@Gtk.FileChooserDialog] documentation.
//
//
// Response Codes
//
// `GtkFileChooserNative` inherits from [class@Gtk.NativeDialog], which means it
// will return GTK_RESPONSE_ACCEPT if the user accepted, and GTK_RESPONSE_CANCEL
// if he pressed cancel. It can also return GTK_RESPONSE_DELETE_EVENT if the
// window was unexpectedly closed.
//
//
// Differences from FileChooserDialog
//
// There are a few things in the [iface@Gtk.FileChooser] interface that are not
// possible to use with `GtkFileChooserNative`, as such use would prohibit the
// use of a native dialog.
//
// No operations that change the dialog work while the dialog is visible. Set
// all the properties that are required before showing the dialog.
//
//
// Win32 details
//
// On windows the `IFileDialog` implementation (added in Windows Vista) is used.
// It supports many of the features that `GtkFileChooser` has, but there are
// some things it does not handle:
//
// * Any [class@Gtk.FileFilter] added using a mimetype
//
// If any of these features are used the regular `GtkFileChooserDialog` will be
// used in place of the native one.
//
//
// Portal details
//
// When the `org.freedesktop.portal.FileChooser` portal is available on the
// session bus, it is used to bring up an out-of-process file chooser. Depending
// on the kind of session the application is running in, this may or may not be
// a GTK file chooser.
//
// macOS details
//
// On macOS the `NSSavePanel` and `NSOpenPanel` classes are used to provide
// native file chooser dialogs. Some features provided by `GtkFileChooser` are
// not supported:
//
// * Shortcut folders.
type FileChooserNative interface {
	NativeDialog
	FileChooser

	// AcceptLabel retrieves the custom label text for the accept button.
	AcceptLabel() string
	// CancelLabel retrieves the custom label text for the cancel button.
	CancelLabel() string
	// SetAcceptLabelFileChooserNative sets the custom label text for the accept
	// button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// __ (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic.
	//
	// Pressing Alt and that key should activate the button.
	SetAcceptLabelFileChooserNative(acceptLabel string)
	// SetCancelLabelFileChooserNative sets the custom label text for the cancel
	// button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// __ (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic.
	//
	// Pressing Alt and that key should activate the button.
	SetCancelLabelFileChooserNative(cancelLabel string)
}

// fileChooserNative implements the FileChooserNative class.
type fileChooserNative struct {
	NativeDialog
}

// WrapFileChooserNative wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserNative(obj *externglib.Object) FileChooserNative {
	return fileChooserNative{
		NativeDialog: WrapNativeDialog(obj),
	}
}

func marshalFileChooserNative(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserNative(obj), nil
}

// NewFileChooserNative creates a new `GtkFileChooserNative`.
func NewFileChooserNative(title string, parent Window, action FileChooserAction, acceptLabel string, cancelLabel string) FileChooserNative {
	var _arg1 *C.char                 // out
	var _arg2 *C.GtkWindow            // out
	var _arg3 C.GtkFileChooserAction  // out
	var _arg4 *C.char                 // out
	var _arg5 *C.char                 // out
	var _cret *C.GtkFileChooserNative // in

	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg3 = (C.GtkFileChooserAction)(action)
	_arg4 = (*C.char)(C.CString(acceptLabel))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.char)(C.CString(cancelLabel))
	defer C.free(unsafe.Pointer(_arg5))

	_cret = C.gtk_file_chooser_native_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _fileChooserNative FileChooserNative // out

	_fileChooserNative = WrapFileChooserNative(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileChooserNative
}

func (s fileChooserNative) AcceptLabel() string {
	var _arg0 *C.GtkFileChooserNative // out
	var _cret *C.char                 // in

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_file_chooser_native_get_accept_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s fileChooserNative) CancelLabel() string {
	var _arg0 *C.GtkFileChooserNative // out
	var _cret *C.char                 // in

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_file_chooser_native_get_cancel_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s fileChooserNative) SetAcceptLabelFileChooserNative(acceptLabel string) {
	var _arg0 *C.GtkFileChooserNative // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(acceptLabel))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_native_set_accept_label(_arg0, _arg1)
}

func (s fileChooserNative) SetCancelLabelFileChooserNative(cancelLabel string) {
	var _arg0 *C.GtkFileChooserNative // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(cancelLabel))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_native_set_cancel_label(_arg0, _arg1)
}

func (c fileChooserNative) AddChoice(id string, label string, options []string, optionLabels []string) {
	WrapFileChooser(gextras.InternObject(c)).AddChoice(id, label, options, optionLabels)
}

func (c fileChooserNative) AddFilter(filter FileFilter) {
	WrapFileChooser(gextras.InternObject(c)).AddFilter(filter)
}

func (c fileChooserNative) AddShortcutFolder(folder gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).AddShortcutFolder(folder)
}

func (c fileChooserNative) Action() FileChooserAction {
	return WrapFileChooser(gextras.InternObject(c)).Action()
}

func (c fileChooserNative) Choice(id string) string {
	return WrapFileChooser(gextras.InternObject(c)).Choice(id)
}

func (c fileChooserNative) CreateFolders() bool {
	return WrapFileChooser(gextras.InternObject(c)).CreateFolders()
}

func (c fileChooserNative) CurrentFolder() gio.File {
	return WrapFileChooser(gextras.InternObject(c)).CurrentFolder()
}

func (c fileChooserNative) CurrentName() string {
	return WrapFileChooser(gextras.InternObject(c)).CurrentName()
}

func (c fileChooserNative) File() gio.File {
	return WrapFileChooser(gextras.InternObject(c)).File()
}

func (c fileChooserNative) Files() gio.ListModel {
	return WrapFileChooser(gextras.InternObject(c)).Files()
}

func (c fileChooserNative) Filter() FileFilter {
	return WrapFileChooser(gextras.InternObject(c)).Filter()
}

func (c fileChooserNative) Filters() gio.ListModel {
	return WrapFileChooser(gextras.InternObject(c)).Filters()
}

func (c fileChooserNative) SelectMultiple() bool {
	return WrapFileChooser(gextras.InternObject(c)).SelectMultiple()
}

func (c fileChooserNative) ShortcutFolders() gio.ListModel {
	return WrapFileChooser(gextras.InternObject(c)).ShortcutFolders()
}

func (c fileChooserNative) RemoveChoice(id string) {
	WrapFileChooser(gextras.InternObject(c)).RemoveChoice(id)
}

func (c fileChooserNative) RemoveFilter(filter FileFilter) {
	WrapFileChooser(gextras.InternObject(c)).RemoveFilter(filter)
}

func (c fileChooserNative) RemoveShortcutFolder(folder gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).RemoveShortcutFolder(folder)
}

func (c fileChooserNative) SetAction(action FileChooserAction) {
	WrapFileChooser(gextras.InternObject(c)).SetAction(action)
}

func (c fileChooserNative) SetChoice(id string, option string) {
	WrapFileChooser(gextras.InternObject(c)).SetChoice(id, option)
}

func (c fileChooserNative) SetCreateFolders(createFolders bool) {
	WrapFileChooser(gextras.InternObject(c)).SetCreateFolders(createFolders)
}

func (c fileChooserNative) SetCurrentFolder(file gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).SetCurrentFolder(file)
}

func (c fileChooserNative) SetCurrentName(name string) {
	WrapFileChooser(gextras.InternObject(c)).SetCurrentName(name)
}

func (c fileChooserNative) SetFile(file gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).SetFile(file)
}

func (c fileChooserNative) SetFilter(filter FileFilter) {
	WrapFileChooser(gextras.InternObject(c)).SetFilter(filter)
}

func (c fileChooserNative) SetSelectMultiple(selectMultiple bool) {
	WrapFileChooser(gextras.InternObject(c)).SetSelectMultiple(selectMultiple)
}

// FileChooserWidget: `GtkFileChooserWidget` is a widget for choosing files.
//
// It exposes the [iface@Gtk.FileChooser] interface, and you should use the
// methods of this interface to interact with the widget.
//
//
// CSS nodes
//
// `GtkFileChooserWidget` has a single CSS node with name filechooser.
type FileChooserWidget interface {
	Widget
	FileChooser
}

// fileChooserWidget implements the FileChooserWidget class.
type fileChooserWidget struct {
	Widget
}

// WrapFileChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserWidget(obj *externglib.Object) FileChooserWidget {
	return fileChooserWidget{
		Widget: WrapWidget(obj),
	}
}

func marshalFileChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserWidget(obj), nil
}

// NewFileChooserWidget creates a new `GtkFileChooserWidget`.
//
// This is a file chooser widget that can be embedded in custom windows, and it
// is the same widget that is used by `GtkFileChooserDialog`.
func NewFileChooserWidget(action FileChooserAction) FileChooserWidget {
	var _arg1 C.GtkFileChooserAction // out
	var _cret *C.GtkWidget           // in

	_arg1 = (C.GtkFileChooserAction)(action)

	_cret = C.gtk_file_chooser_widget_new(_arg1)

	var _fileChooserWidget FileChooserWidget // out

	_fileChooserWidget = WrapFileChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _fileChooserWidget
}

func (s fileChooserWidget) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s fileChooserWidget) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s fileChooserWidget) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s fileChooserWidget) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s fileChooserWidget) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s fileChooserWidget) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s fileChooserWidget) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b fileChooserWidget) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c fileChooserWidget) AddChoice(id string, label string, options []string, optionLabels []string) {
	WrapFileChooser(gextras.InternObject(c)).AddChoice(id, label, options, optionLabels)
}

func (c fileChooserWidget) AddFilter(filter FileFilter) {
	WrapFileChooser(gextras.InternObject(c)).AddFilter(filter)
}

func (c fileChooserWidget) AddShortcutFolder(folder gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).AddShortcutFolder(folder)
}

func (c fileChooserWidget) Action() FileChooserAction {
	return WrapFileChooser(gextras.InternObject(c)).Action()
}

func (c fileChooserWidget) Choice(id string) string {
	return WrapFileChooser(gextras.InternObject(c)).Choice(id)
}

func (c fileChooserWidget) CreateFolders() bool {
	return WrapFileChooser(gextras.InternObject(c)).CreateFolders()
}

func (c fileChooserWidget) CurrentFolder() gio.File {
	return WrapFileChooser(gextras.InternObject(c)).CurrentFolder()
}

func (c fileChooserWidget) CurrentName() string {
	return WrapFileChooser(gextras.InternObject(c)).CurrentName()
}

func (c fileChooserWidget) File() gio.File {
	return WrapFileChooser(gextras.InternObject(c)).File()
}

func (c fileChooserWidget) Files() gio.ListModel {
	return WrapFileChooser(gextras.InternObject(c)).Files()
}

func (c fileChooserWidget) Filter() FileFilter {
	return WrapFileChooser(gextras.InternObject(c)).Filter()
}

func (c fileChooserWidget) Filters() gio.ListModel {
	return WrapFileChooser(gextras.InternObject(c)).Filters()
}

func (c fileChooserWidget) SelectMultiple() bool {
	return WrapFileChooser(gextras.InternObject(c)).SelectMultiple()
}

func (c fileChooserWidget) ShortcutFolders() gio.ListModel {
	return WrapFileChooser(gextras.InternObject(c)).ShortcutFolders()
}

func (c fileChooserWidget) RemoveChoice(id string) {
	WrapFileChooser(gextras.InternObject(c)).RemoveChoice(id)
}

func (c fileChooserWidget) RemoveFilter(filter FileFilter) {
	WrapFileChooser(gextras.InternObject(c)).RemoveFilter(filter)
}

func (c fileChooserWidget) RemoveShortcutFolder(folder gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).RemoveShortcutFolder(folder)
}

func (c fileChooserWidget) SetAction(action FileChooserAction) {
	WrapFileChooser(gextras.InternObject(c)).SetAction(action)
}

func (c fileChooserWidget) SetChoice(id string, option string) {
	WrapFileChooser(gextras.InternObject(c)).SetChoice(id, option)
}

func (c fileChooserWidget) SetCreateFolders(createFolders bool) {
	WrapFileChooser(gextras.InternObject(c)).SetCreateFolders(createFolders)
}

func (c fileChooserWidget) SetCurrentFolder(file gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).SetCurrentFolder(file)
}

func (c fileChooserWidget) SetCurrentName(name string) {
	WrapFileChooser(gextras.InternObject(c)).SetCurrentName(name)
}

func (c fileChooserWidget) SetFile(file gio.File) error {
	return WrapFileChooser(gextras.InternObject(c)).SetFile(file)
}

func (c fileChooserWidget) SetFilter(filter FileFilter) {
	WrapFileChooser(gextras.InternObject(c)).SetFilter(filter)
}

func (c fileChooserWidget) SetSelectMultiple(selectMultiple bool) {
	WrapFileChooser(gextras.InternObject(c)).SetSelectMultiple(selectMultiple)
}

// FileFilter: `GtkFileFilter` filters files by name or mime type.
//
// `GtkFileFilter` can be used to restrict the files being shown in a
// `GtkFileChooser`. Files can be filtered based on their name (with
// [method@Gtk.FileFilter.add_pattern]) or on their mime type (with
// [method@Gtk.FileFilter.add_mime_type]).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that `GtkFileFilter`
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, file filters are used by adding them to a `GtkFileChooser` (see
// [method@Gtk.FileChooser.add_filter]), but it is also possible to manually use
// a file filter on any [class@Gtk.FilterListModel] containing `GFileInfo`
// objects.
//
//
// GtkFileFilter as GtkBuildable
//
// The `GtkFileFilter` implementation of the `GtkBuildable` interface supports
// adding rules using the <mime-types> and <patterns> elements and listing the
// rules within. Specifying a <mime-type> or <pattern> has the same effect as as
// calling [method@Gtk.FileFilter.add_mime_type] or
// [method@Gtk.FileFilter.add_pattern].
//
// An example of a UI definition fragment specifying `GtkFileFilter` rules:
// `xml <object class="GtkFileFilter"> <property name="name"
// translatable="yes">Text and Images</property> <mime-types>
// <mime-type>text/plain</mime-type> <mime-type>image/ *</mime-type>
// </mime-types> <patterns> <pattern>*.txt</pattern> <pattern>*.png</pattern>
// </patterns> </object> `
type FileFilter interface {
	Filter
	Buildable

	// AddMIMETypeFileFilter adds a rule allowing a given mime type to @filter.
	AddMIMETypeFileFilter(mimeType string)
	// AddPatternFileFilter adds a rule allowing a shell style glob to a filter.
	AddPatternFileFilter(pattern string)
	// AddPixbufFormatsFileFilter adds a rule allowing image files in the
	// formats supported by GdkPixbuf.
	//
	// This is equivalent to calling [method@Gtk.FileFilter.add_mime_type] for
	// all the supported mime types.
	AddPixbufFormatsFileFilter()
	// Attributes gets the attributes that need to be filled in for the
	// `GFileInfo` passed to this filter.
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of `GtkFileChooser`.
	Attributes() []string
	// Name gets the human-readable name for the filter.
	//
	// See [method@Gtk.FileFilter.set_name].
	Name() string
	// SetNameFileFilter sets a human-readable name of the filter.
	//
	// This is the string that will be displayed in the file chooser if there is
	// a selectable list of filters.
	SetNameFileFilter(name string)
	// ToGVariantFileFilter: serialize a file filter to an `a{sv}` variant.
	ToGVariantFileFilter() *glib.Variant
}

// fileFilter implements the FileFilter class.
type fileFilter struct {
	Filter
}

// WrapFileFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileFilter(obj *externglib.Object) FileFilter {
	return fileFilter{
		Filter: WrapFilter(obj),
	}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileFilter(obj), nil
}

// NewFileFilter creates a new `GtkFileFilter` with no rules added to it.
//
// Such a filter doesnt accept any files, so is not particularly useful until
// you add rules with [method@Gtk.FileFilter.add_mime_type],
// [method@Gtk.FileFilter.add_pattern], or
// [method@Gtk.FileFilter.add_pixbuf_formats].
//
// To create a filter that accepts any file, use: `c GtkFileFilter *filter =
// gtk_file_filter_new (); gtk_file_filter_add_pattern (filter, "*"); `
func NewFileFilter() FileFilter {
	var _cret *C.GtkFileFilter // in

	_cret = C.gtk_file_filter_new()

	var _fileFilter FileFilter // out

	_fileFilter = WrapFileFilter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileFilter
}

// NewFileFilterFromGVariant: deserialize a file filter from a `GVariant`.
//
// The variant must be in the format produced by
// [method@Gtk.FileFilter.to_gvariant].
func NewFileFilterFromGVariant(variant *glib.Variant) FileFilter {
	var _arg1 *C.GVariant      // out
	var _cret *C.GtkFileFilter // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	_cret = C.gtk_file_filter_new_from_gvariant(_arg1)

	var _fileFilter FileFilter // out

	_fileFilter = WrapFileFilter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileFilter
}

func (f fileFilter) AddMIMETypeFileFilter(mimeType string) {
	var _arg0 *C.GtkFileFilter // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_add_mime_type(_arg0, _arg1)
}

func (f fileFilter) AddPatternFileFilter(pattern string) {
	var _arg0 *C.GtkFileFilter // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_add_pattern(_arg0, _arg1)
}

func (f fileFilter) AddPixbufFormatsFileFilter() {
	var _arg0 *C.GtkFileFilter // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	C.gtk_file_filter_add_pixbuf_formats(_arg0)
}

func (f fileFilter) Attributes() []string {
	var _arg0 *C.GtkFileFilter // out
	var _cret **C.char

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_file_filter_get_attributes(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (f fileFilter) Name() string {
	var _arg0 *C.GtkFileFilter // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_file_filter_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (f fileFilter) SetNameFileFilter(name string) {
	var _arg0 *C.GtkFileFilter // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_set_name(_arg0, _arg1)
}

func (f fileFilter) ToGVariantFileFilter() *glib.Variant {
	var _arg0 *C.GtkFileFilter // out
	var _cret *C.GVariant      // in

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_file_filter_to_gvariant(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

func (b fileFilter) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Filter: a `GtkFilter` object describes the filtering to be performed by a
// `GtkFilterListModel`.
//
// The model will use the filter to determine if it should include items or not
// by calling [method@Gtk.Filter.match] for each item and only keeping the ones
// that the function returns true for.
//
// Filters may change what items they match through their lifetime. In that
// case, they will emit the [signal@Gtk.Filter::changed] signal to notify that
// previous filter results are no longer valid and that items should be checked
// again via [method@Gtk.Filter.match].
//
// GTK provides various pre-made filter implementations for common filtering
// operations. These filters often include properties that can be linked to
// various widgets to easily allow searches.
//
// However, in particular for large lists or complex search methods, it is also
// possible to subclass Filter and provide one's own filter.
type Filter interface {

	// ChangedFilter emits the Filter::changed signal to notify all users of the
	// filter that the filter changed. Users of the filter should then check
	// items again via gtk_filter_match().
	//
	// Depending on the @change parameter, not all items need to be changed, but
	// only some. Refer to the FilterChange documentation for details.
	//
	// This function is intended for implementors of Filter subclasses and
	// should not be called from other functions.
	ChangedFilter(change FilterChange)
	// Strictness gets the known strictness of @filters. If the strictness is
	// not known, GTK_FILTER_MATCH_SOME is returned.
	//
	// This value may change after emission of the Filter::changed signal.
	//
	// This function is meant purely for optimization purposes, filters can
	// choose to omit implementing it, but FilterListModel uses it.
	Strictness() FilterMatch
	// MatchFilter checks if the given @item is matched by the filter or not.
	MatchFilter(item gextras.Objector) bool
}

// filter implements the Filter class.
type filter struct {
	gextras.Objector
}

// WrapFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilter(obj *externglib.Object) Filter {
	return filter{
		Objector: obj,
	}
}

func marshalFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilter(obj), nil
}

func (s filter) ChangedFilter(change FilterChange) {
	var _arg0 *C.GtkFilter      // out
	var _arg1 C.GtkFilterChange // out

	_arg0 = (*C.GtkFilter)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkFilterChange)(change)

	C.gtk_filter_changed(_arg0, _arg1)
}

func (s filter) Strictness() FilterMatch {
	var _arg0 *C.GtkFilter     // out
	var _cret C.GtkFilterMatch // in

	_arg0 = (*C.GtkFilter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_filter_get_strictness(_arg0)

	var _filterMatch FilterMatch // out

	_filterMatch = FilterMatch(_cret)

	return _filterMatch
}

func (s filter) MatchFilter(item gextras.Objector) bool {
	var _arg0 *C.GtkFilter // out
	var _arg1 C.gpointer   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkFilter)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(item.Native()))

	_cret = C.gtk_filter_match(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FilterListModel: `GtkFilterListModel` is a list model that filters the
// elements of the underlying model according to a `GtkFilter`.
//
// It hides some elements from the other model according to criteria given by a
// `GtkFilter`.
//
// The model can be set up to do incremental searching, so that filtering long
// lists doesn't block the UI. See [method@Gtk.FilterListModel.set_incremental]
// for details.
type FilterListModel interface {
	gio.ListModel

	// Filter gets the `GtkFilter` currently set on @self.
	Filter() Filter
	// Incremental returns whether incremental filtering is enabled.
	//
	// See [method@Gtk.FilterListModel.set_incremental].
	Incremental() bool
	// Model gets the model currently filtered or nil if none.
	Model() gio.ListModel
	// Pending returns the number of items that have not been filtered yet.
	//
	// You can use this value to check if @self is busy filtering by comparing
	// the return value to 0 or you can compute the percentage of the filter
	// remaining by dividing the return value by the total number of items in
	// the underlying model:
	//
	// `c pending = gtk_filter_list_model_get_pending (self); model =
	// gtk_filter_list_model_get_model (self); percentage = pending / (double)
	// g_list_model_get_n_items (model); `
	//
	// If no filter operation is ongoing - in particular when
	// [property@Gtk.FilterListModel:incremental] is false - this function
	// returns 0.
	Pending() uint
	// SetFilterFilterListModel sets the filter used to filter items.
	SetFilterFilterListModel(filter Filter)
	// SetIncrementalFilterListModel sets the filter model to do an incremental
	// sort.
	//
	// When incremental filtering is enabled, the `GtkFilterListModel` will not
	// run filters immediately, but will instead queue an idle handler that
	// incrementally filters the items and adds them to the list. This of course
	// means that items are not instantly added to the list, but only appear
	// incrementally.
	//
	// When your filter blocks the UI while filtering, you might consider
	// turning this on. Depending on your model and filters, this may become
	// interesting around 10,000 to 100,000 items.
	//
	// By default, incremental filtering is disabled.
	//
	// See [method@Gtk.FilterListModel.get_pending] for progress information
	// about an ongoing incremental filtering operation.
	SetIncrementalFilterListModel(incremental bool)
	// SetModelFilterListModel sets the model to be filtered.
	//
	// Note that GTK makes no effort to ensure that @model conforms to the item
	// type of @self. It assumes that the caller knows what they are doing and
	// have set up an appropriate filter to ensure that item types match.
	SetModelFilterListModel(model gio.ListModel)
}

// filterListModel implements the FilterListModel class.
type filterListModel struct {
	gextras.Objector
}

// WrapFilterListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilterListModel(obj *externglib.Object) FilterListModel {
	return filterListModel{
		Objector: obj,
	}
}

func marshalFilterListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilterListModel(obj), nil
}

// NewFilterListModel creates a new `GtkFilterListModel` that will filter @model
// using the given @filter.
func NewFilterListModel(model gio.ListModel, filter Filter) FilterListModel {
	var _arg1 *C.GListModel         // out
	var _arg2 *C.GtkFilter          // out
	var _cret *C.GtkFilterListModel // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.GtkFilter)(unsafe.Pointer(filter.Native()))

	_cret = C.gtk_filter_list_model_new(_arg1, _arg2)

	var _filterListModel FilterListModel // out

	_filterListModel = WrapFilterListModel(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _filterListModel
}

func (s filterListModel) Filter() Filter {
	var _arg0 *C.GtkFilterListModel // out
	var _cret *C.GtkFilter          // in

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_filter_list_model_get_filter(_arg0)

	var _filter Filter // out

	_filter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Filter)

	return _filter
}

func (s filterListModel) Incremental() bool {
	var _arg0 *C.GtkFilterListModel // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_filter_list_model_get_incremental(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s filterListModel) Model() gio.ListModel {
	var _arg0 *C.GtkFilterListModel // out
	var _cret *C.GListModel         // in

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_filter_list_model_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s filterListModel) Pending() uint {
	var _arg0 *C.GtkFilterListModel // out
	var _cret C.guint               // in

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_filter_list_model_get_pending(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s filterListModel) SetFilterFilterListModel(filter Filter) {
	var _arg0 *C.GtkFilterListModel // out
	var _arg1 *C.GtkFilter          // out

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_filter_list_model_set_filter(_arg0, _arg1)
}

func (s filterListModel) SetIncrementalFilterListModel(incremental bool) {
	var _arg0 *C.GtkFilterListModel // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))
	if incremental {
		_arg1 = C.TRUE
	}

	C.gtk_filter_list_model_set_incremental(_arg0, _arg1)
}

func (s filterListModel) SetModelFilterListModel(model gio.ListModel) {
	var _arg0 *C.GtkFilterListModel // out
	var _arg1 *C.GListModel         // out

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	C.gtk_filter_list_model_set_model(_arg0, _arg1)
}

// Fixed: `GtkFixed` places its child widgets at fixed positions and with fixed
// sizes.
//
// `GtkFixed` performs no automatic layout management.
//
// For most applications, you should not use this container! It keeps you from
// having to learn about the other GTK containers, but it results in broken
// applications. With `GtkFixed`, the following things will result in truncated
// text, overlapping widgets, and other display bugs:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, `GtkFixed` does not pay attention to text direction and thus may
// produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK will order containers
// appropriately for the text direction, e.g. to put labels to the right of the
// thing they label when using an RTL language, but it cant do that with
// `GtkFixed`. So if you need to reorder widgets depending on the text
// direction, you would need to manually detect it and adjust child positions
// accordingly.
//
// Finally, fixed positioning makes it kind of annoying to add/remove UI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
//
// If you know none of these things are an issue for your application, and
// prefer the simplicity of `GtkFixed`, by all means use the widget. But you
// should be aware of the tradeoffs.
type Fixed interface {
	Widget

	// ChildPosition retrieves the translation transformation of the given child
	// `GtkWidget` in the `GtkFixed`.
	//
	// See also: [method@Gtk.Fixed.get_child_transform].
	ChildPosition(widget Widget) (x float64, y float64)
	// ChildTransform retrieves the transformation for @widget set using
	// gtk_fixed_set_child_transform().
	ChildTransform(widget Widget) *gsk.Transform
	// MoveFixed sets a translation transformation to the given @x and @y
	// coordinates to the child @widget of the `GtkFixed`.
	MoveFixed(widget Widget, x float64, y float64)
	// PutFixed adds a widget to a `GtkFixed` at the given position.
	PutFixed(widget Widget, x float64, y float64)
	// RemoveFixed removes a child from @fixed.
	RemoveFixed(widget Widget)
	// SetChildTransformFixed sets the transformation for @widget.
	//
	// This is a convenience function that retrieves the
	// [class@Gtk.FixedLayoutChild] instance associated to @widget and calls
	// [method@Gtk.FixedLayoutChild.set_transform].
	SetChildTransformFixed(widget Widget, transform *gsk.Transform)
}

// fixed implements the Fixed class.
type fixed struct {
	Widget
}

// WrapFixed wraps a GObject to the right type. It is
// primarily used internally.
func WrapFixed(obj *externglib.Object) Fixed {
	return fixed{
		Widget: WrapWidget(obj),
	}
}

func marshalFixed(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFixed(obj), nil
}

// NewFixed creates a new `GtkFixed`.
func NewFixed() Fixed {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_fixed_new()

	var _fixed Fixed // out

	_fixed = WrapFixed(externglib.Take(unsafe.Pointer(_cret)))

	return _fixed
}

func (f fixed) ChildPosition(widget Widget) (x float64, y float64) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // in
	var _arg3 C.double     // in

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_fixed_get_child_position(_arg0, _arg1, &_arg2, &_arg3)

	var _x float64 // out
	var _y float64 // out

	_x = (float64)(_arg2)
	_y = (float64)(_arg3)

	return _x, _y
}

func (f fixed) ChildTransform(widget Widget) *gsk.Transform {
	var _arg0 *C.GtkFixed     // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_fixed_get_child_transform(_arg0, _arg1)

	var _transform *gsk.Transform // out

	_transform = gsk.WrapTransform(unsafe.Pointer(_cret))

	return _transform
}

func (f fixed) MoveFixed(widget Widget, x float64, y float64) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.double)(x)
	_arg3 = (C.double)(y)

	C.gtk_fixed_move(_arg0, _arg1, _arg2, _arg3)
}

func (f fixed) PutFixed(widget Widget, x float64, y float64) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.double)(x)
	_arg3 = (C.double)(y)

	C.gtk_fixed_put(_arg0, _arg1, _arg2, _arg3)
}

func (f fixed) RemoveFixed(widget Widget) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_fixed_remove(_arg0, _arg1)
}

func (f fixed) SetChildTransformFixed(widget Widget, transform *gsk.Transform) {
	var _arg0 *C.GtkFixed     // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.GskTransform // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

	C.gtk_fixed_set_child_transform(_arg0, _arg1, _arg2)
}

func (s fixed) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s fixed) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s fixed) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s fixed) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s fixed) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s fixed) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s fixed) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b fixed) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// FixedLayout: `GtkFixedLayout` is a layout manager which can place child
// widgets at fixed positions.
//
// Most applications should never use this layout manager; fixed positioning and
// sizing requires constant recalculations on where children need to be
// positioned and sized. Other layout managers perform this kind of work
// internally so that application developers don't need to do it. Specifically,
// widgets positioned in a fixed layout manager will need to take into account:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, `GtkFixedLayout` does not pay attention to text direction and
// thus may produce unwanted results if your app is run under right-to-left
// languages such as Hebrew or Arabic. That is: normally GTK will order
// containers appropriately depending on the text direction, e.g. to put labels
// to the right of the thing they label when using an RTL language;
// `GtkFixedLayout` won't be able to do that for you.
//
// Finally, fixed positioning makes it kind of annoying to add/remove UI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
type FixedLayout interface {
}

// fixedLayout implements the FixedLayout class.
type fixedLayout struct {
	LayoutManager
}

// WrapFixedLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapFixedLayout(obj *externglib.Object) FixedLayout {
	return fixedLayout{
		LayoutManager: WrapLayoutManager(obj),
	}
}

func marshalFixedLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFixedLayout(obj), nil
}

// NewFixedLayout creates a new `GtkFixedLayout`.
func NewFixedLayout() FixedLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_fixed_layout_new()

	var _fixedLayout FixedLayout // out

	_fixedLayout = WrapFixedLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fixedLayout
}

// FixedLayoutChild: `GtkLayoutChild` subclass for children in a
// `GtkFixedLayout`.
type FixedLayoutChild interface {

	// Transform retrieves the transformation of the child.
	Transform() *gsk.Transform
	// SetTransformFixedLayoutChild sets the transformation of the child of a
	// `GtkFixedLayout`.
	SetTransformFixedLayoutChild(transform *gsk.Transform)
}

// fixedLayoutChild implements the FixedLayoutChild class.
type fixedLayoutChild struct {
	LayoutChild
}

// WrapFixedLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapFixedLayoutChild(obj *externglib.Object) FixedLayoutChild {
	return fixedLayoutChild{
		LayoutChild: WrapLayoutChild(obj),
	}
}

func marshalFixedLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFixedLayoutChild(obj), nil
}

func (c fixedLayoutChild) Transform() *gsk.Transform {
	var _arg0 *C.GtkFixedLayoutChild // out
	var _cret *C.GskTransform        // in

	_arg0 = (*C.GtkFixedLayoutChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_fixed_layout_child_get_transform(_arg0)

	var _transform *gsk.Transform // out

	_transform = gsk.WrapTransform(unsafe.Pointer(_cret))

	return _transform
}

func (c fixedLayoutChild) SetTransformFixedLayoutChild(transform *gsk.Transform) {
	var _arg0 *C.GtkFixedLayoutChild // out
	var _arg1 *C.GskTransform        // out

	_arg0 = (*C.GtkFixedLayoutChild)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

	C.gtk_fixed_layout_child_set_transform(_arg0, _arg1)
}

// FlattenListModel: `GtkFlattenListModel` is a list model that concatenates
// other list models.
//
// `GtkFlattenListModel` takes a list model containing list models, and flattens
// it into a single model.
type FlattenListModel interface {
	gio.ListModel

	// Model gets the model set via gtk_flatten_list_model_set_model().
	Model() gio.ListModel
	// ModelForItem returns the model containing the item at the given position.
	ModelForItem(position uint) gio.ListModel
	// SetModelFlattenListModel sets a new model to be flattened.
	SetModelFlattenListModel(model gio.ListModel)
}

// flattenListModel implements the FlattenListModel class.
type flattenListModel struct {
	gextras.Objector
}

// WrapFlattenListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlattenListModel(obj *externglib.Object) FlattenListModel {
	return flattenListModel{
		Objector: obj,
	}
}

func marshalFlattenListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlattenListModel(obj), nil
}

// NewFlattenListModel creates a new `GtkFlattenListModel` that flattens @list.
func NewFlattenListModel(model gio.ListModel) FlattenListModel {
	var _arg1 *C.GListModel          // out
	var _cret *C.GtkFlattenListModel // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_flatten_list_model_new(_arg1)

	var _flattenListModel FlattenListModel // out

	_flattenListModel = WrapFlattenListModel(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _flattenListModel
}

func (s flattenListModel) Model() gio.ListModel {
	var _arg0 *C.GtkFlattenListModel // out
	var _cret *C.GListModel          // in

	_arg0 = (*C.GtkFlattenListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_flatten_list_model_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s flattenListModel) ModelForItem(position uint) gio.ListModel {
	var _arg0 *C.GtkFlattenListModel // out
	var _arg1 C.guint                // out
	var _cret *C.GListModel          // in

	_arg0 = (*C.GtkFlattenListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)

	_cret = C.gtk_flatten_list_model_get_model_for_item(_arg0, _arg1)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s flattenListModel) SetModelFlattenListModel(model gio.ListModel) {
	var _arg0 *C.GtkFlattenListModel // out
	var _arg1 *C.GListModel          // out

	_arg0 = (*C.GtkFlattenListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	C.gtk_flatten_list_model_set_model(_arg0, _arg1)
}

// FlowBox: a `GtkFlowBox` puts child widgets in reflowing grid.
//
// For instance, with the horizontal orientation, the widgets will be arranged
// from left to right, starting a new row under the previous row when necessary.
// Reducing the width in this case will require more rows, so a larger height
// will be requested.
//
// Likewise, with the vertical orientation, the widgets will be arranged from
// top to bottom, starting a new column to the right when necessary. Reducing
// the height will require more columns, so a larger width will be requested.
//
// The size request of a `GtkFlowBox` alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a `GtkScrolledWindow` to enable that.
//
// The children of a `GtkFlowBox` can be dynamically sorted and filtered.
//
// Although a `GtkFlowBox` must have only `GtkFlowBoxChild` children, you can
// add any kind of widget to it via [method@Gtk.FlowBox.insert], and a
// `GtkFlowBoxChild` widget will automatically be inserted between the box and
// the widget.
//
// Also see [class@Gtk.ListBox].
//
//
// CSS nodes
//
// ` flowbox  flowboxchild   <child>  flowboxchild   <child> 
//  [rubberband] `
//
// `GtkFlowBox` uses a single CSS node with name flowbox. `GtkFlowBoxChild` uses
// a single CSS node with name flowboxchild. For rubberband selection, a subnode
// with name rubberband is used.
//
//
// Accessibility
//
// `GtkFlowBox` uses the GTK_ACCESSIBLE_ROLE_GRID role, and `GtkFlowBoxChild`
// uses the GTK_ACCESSIBLE_ROLE_GRID_CELL role.
type FlowBox interface {
	Widget
	Orientable

	// ActivateOnSingleClick returns whether children activate on single clicks.
	ActivateOnSingleClick() bool
	// ChildAtIndex gets the nth child in the @box.
	ChildAtIndex(idx int) FlowBoxChild
	// ChildAtPos gets the child in the (@x, @y) position.
	//
	// Both @x and @y are assumed to be relative to the origin of @box.
	ChildAtPos(x int, y int) FlowBoxChild
	// ColumnSpacing gets the horizontal spacing.
	ColumnSpacing() uint
	// Homogeneous returns whether the box is homogeneous.
	Homogeneous() bool
	// MaxChildrenPerLine gets the maximum number of children per line.
	MaxChildrenPerLine() uint
	// MinChildrenPerLine gets the minimum number of children per line.
	MinChildrenPerLine() uint
	// RowSpacing gets the vertical spacing.
	RowSpacing() uint
	// SelectionMode gets the selection mode of @box.
	SelectionMode() SelectionMode
	// InsertFlowBox inserts the @widget into @box at @position.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	//
	// If @position is -1, or larger than the total number of children in the
	// @box, then the @widget will be appended to the end.
	InsertFlowBox(widget Widget, position int)
	// InvalidateFilterFlowBox updates the filtering for all children.
	//
	// Call this function when the result of the filter function on the @box is
	// changed due ot an external factor. For instance, this would be used if
	// the filter function just looked for a specific search term, and the entry
	// with the string has changed.
	InvalidateFilterFlowBox()
	// InvalidateSortFlowBox updates the sorting for all children.
	//
	// Call this when the result of the sort function on @box is changed due to
	// an external factor.
	InvalidateSortFlowBox()
	// RemoveFlowBox removes a child from @box.
	RemoveFlowBox(widget Widget)
	// SelectAllFlowBox: select all children of @box, if the selection mode
	// allows it.
	SelectAllFlowBox()
	// SelectChildFlowBox selects a single child of @box, if the selection mode
	// allows it.
	SelectChildFlowBox(child FlowBoxChild)
	// SetActivateOnSingleClickFlowBox: if @single is true, children will be
	// activated when you click on them, otherwise you need to double-click.
	SetActivateOnSingleClickFlowBox(single bool)
	// SetColumnSpacingFlowBox sets the horizontal space to add between
	// children.
	SetColumnSpacingFlowBox(spacing uint)
	// SetHAdjustmentFlowBox hooks up an adjustment to focus handling in @box.
	//
	// The adjustment is also used for autoscrolling during rubberband
	// selection. See [method@Gtk.ScrolledWindow.get_hadjustment] for a typical
	// way of obtaining the adjustment, and [method@Gtk.FlowBox.set_vadjustment]
	// for setting the vertical adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetHAdjustmentFlowBox(adjustment Adjustment)
	// SetHomogeneousFlowBox sets whether or not all children of @box are given
	// equal space in the box.
	SetHomogeneousFlowBox(homogeneous bool)
	// SetMaxChildrenPerLineFlowBox sets the maximum number of children to
	// request and allocate space for in @boxs orientation.
	//
	// Setting the maximum number of children per line limits the overall
	// natural size request to be no more than @n_children children long in the
	// given orientation.
	SetMaxChildrenPerLineFlowBox(nChildren uint)
	// SetMinChildrenPerLineFlowBox sets the minimum number of children to line
	// up in @boxs orientation before flowing.
	SetMinChildrenPerLineFlowBox(nChildren uint)
	// SetRowSpacingFlowBox sets the vertical space to add between children.
	SetRowSpacingFlowBox(spacing uint)
	// SetSelectionModeFlowBox sets how selection works in @box.
	SetSelectionModeFlowBox(mode SelectionMode)
	// SetVAdjustmentFlowBox hooks up an adjustment to focus handling in @box.
	//
	// The adjustment is also used for autoscrolling during rubberband
	// selection. See [method@Gtk.ScrolledWindow.get_vadjustment] for a typical
	// way of obtaining the adjustment, and [method@Gtk.FlowBox.set_hadjustment]
	// for setting the horizontal adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetVAdjustmentFlowBox(adjustment Adjustment)
	// UnselectAllFlowBox: unselect all children of @box, if the selection mode
	// allows it.
	UnselectAllFlowBox()
	// UnselectChildFlowBox unselects a single child of @box, if the selection
	// mode allows it.
	UnselectChildFlowBox(child FlowBoxChild)
}

// flowBox implements the FlowBox class.
type flowBox struct {
	Widget
}

// WrapFlowBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBox(obj *externglib.Object) FlowBox {
	return flowBox{
		Widget: WrapWidget(obj),
	}
}

func marshalFlowBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBox(obj), nil
}

// NewFlowBox creates a `GtkFlowBox`.
func NewFlowBox() FlowBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_flow_box_new()

	var _flowBox FlowBox // out

	_flowBox = WrapFlowBox(externglib.Take(unsafe.Pointer(_cret)))

	return _flowBox
}

func (b flowBox) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_activate_on_single_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b flowBox) ChildAtIndex(idx int) FlowBoxChild {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 C.int              // out
	var _cret *C.GtkFlowBoxChild // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)

	_cret = C.gtk_flow_box_get_child_at_index(_arg0, _arg1)

	var _flowBoxChild FlowBoxChild // out

	_flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FlowBoxChild)

	return _flowBoxChild
}

func (b flowBox) ChildAtPos(x int, y int) FlowBoxChild {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out
	var _cret *C.GtkFlowBoxChild // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)

	_cret = C.gtk_flow_box_get_child_at_pos(_arg0, _arg1, _arg2)

	var _flowBoxChild FlowBoxChild // out

	_flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FlowBoxChild)

	return _flowBoxChild
}

func (b flowBox) ColumnSpacing() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_column_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (b flowBox) Homogeneous() bool {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b flowBox) MaxChildrenPerLine() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_max_children_per_line(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (b flowBox) MinChildrenPerLine() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_min_children_per_line(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (b flowBox) RowSpacing() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_row_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (b flowBox) SelectionMode() SelectionMode {
	var _arg0 *C.GtkFlowBox      // out
	var _cret C.GtkSelectionMode // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_selection_mode(_arg0)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

func (b flowBox) InsertFlowBox(widget Widget, position int) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.int)(position)

	C.gtk_flow_box_insert(_arg0, _arg1, _arg2)
}

func (b flowBox) InvalidateFilterFlowBox() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_invalidate_filter(_arg0)
}

func (b flowBox) InvalidateSortFlowBox() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_invalidate_sort(_arg0)
}

func (b flowBox) RemoveFlowBox(widget Widget) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_flow_box_remove(_arg0, _arg1)
}

func (b flowBox) SelectAllFlowBox() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_select_all(_arg0)
}

func (b flowBox) SelectChildFlowBox(child FlowBoxChild) {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

	C.gtk_flow_box_select_child(_arg0, _arg1)
}

func (b flowBox) SetActivateOnSingleClickFlowBox(single bool) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_flow_box_set_activate_on_single_click(_arg0, _arg1)
}

func (b flowBox) SetColumnSpacingFlowBox(spacing uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_flow_box_set_column_spacing(_arg0, _arg1)
}

func (b flowBox) SetHAdjustmentFlowBox(adjustment Adjustment) {
	var _arg0 *C.GtkFlowBox    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_flow_box_set_hadjustment(_arg0, _arg1)
}

func (b flowBox) SetHomogeneousFlowBox(homogeneous bool) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_flow_box_set_homogeneous(_arg0, _arg1)
}

func (b flowBox) SetMaxChildrenPerLineFlowBox(nChildren uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(nChildren)

	C.gtk_flow_box_set_max_children_per_line(_arg0, _arg1)
}

func (b flowBox) SetMinChildrenPerLineFlowBox(nChildren uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(nChildren)

	C.gtk_flow_box_set_min_children_per_line(_arg0, _arg1)
}

func (b flowBox) SetRowSpacingFlowBox(spacing uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_flow_box_set_row_spacing(_arg0, _arg1)
}

func (b flowBox) SetSelectionModeFlowBox(mode SelectionMode) {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 C.GtkSelectionMode // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_flow_box_set_selection_mode(_arg0, _arg1)
}

func (b flowBox) SetVAdjustmentFlowBox(adjustment Adjustment) {
	var _arg0 *C.GtkFlowBox    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_flow_box_set_vadjustment(_arg0, _arg1)
}

func (b flowBox) UnselectAllFlowBox() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_unselect_all(_arg0)
}

func (b flowBox) UnselectChildFlowBox(child FlowBoxChild) {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

	C.gtk_flow_box_unselect_child(_arg0, _arg1)
}

func (s flowBox) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s flowBox) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s flowBox) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s flowBox) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s flowBox) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s flowBox) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s flowBox) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b flowBox) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o flowBox) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o flowBox) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// FlowBoxChild: `GtkFlowBoxChild` is the kind of widget that can be added to a
// `GtkFlowBox`.
type FlowBoxChild interface {
	Widget

	// ChangedFlowBoxChild marks @child as changed, causing any state that
	// depends on this to be updated.
	//
	// This affects sorting and filtering.
	//
	// Note that calls to this method must be in sync with the data used for the
	// sorting and filtering functions. For instance, if the list is mirroring
	// some external data set, and *two* children changed in the external data
	// set when you call gtk_flow_box_child_changed() on the first child, the
	// sort function must only read the new data for the first of the two
	// changed children, otherwise the resorting of the children will be wrong.
	//
	// This generally means that if you dont fully control the data model, you
	// have to duplicate the data that affects the sorting and filtering
	// functions into the widgets themselves.
	//
	// Another alternative is to call [method@Gtk.FlowBox.invalidate_sort] on
	// any model change, but that is more expensive.
	ChangedFlowBoxChild()
	// Child gets the child widget of @self.
	Child() Widget
	// Index gets the current index of the @child in its `GtkFlowBox` container.
	Index() int
	// IsSelectedFlowBoxChild returns whether the @child is currently selected
	// in its `GtkFlowBox` container.
	IsSelectedFlowBoxChild() bool
	// SetChildFlowBoxChild sets the child widget of @self.
	SetChildFlowBoxChild(child Widget)
}

// flowBoxChild implements the FlowBoxChild class.
type flowBoxChild struct {
	Widget
}

// WrapFlowBoxChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBoxChild(obj *externglib.Object) FlowBoxChild {
	return flowBoxChild{
		Widget: WrapWidget(obj),
	}
}

func marshalFlowBoxChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBoxChild(obj), nil
}

// NewFlowBoxChild creates a new `GtkFlowBoxChild`.
//
// This should only be used as a child of a `GtkFlowBox`.
func NewFlowBoxChild() FlowBoxChild {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_flow_box_child_new()

	var _flowBoxChild FlowBoxChild // out

	_flowBoxChild = WrapFlowBoxChild(externglib.Take(unsafe.Pointer(_cret)))

	return _flowBoxChild
}

func (c flowBoxChild) ChangedFlowBoxChild() {
	var _arg0 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

	C.gtk_flow_box_child_changed(_arg0)
}

func (s flowBoxChild) Child() Widget {
	var _arg0 *C.GtkFlowBoxChild // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_flow_box_child_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (c flowBoxChild) Index() int {
	var _arg0 *C.GtkFlowBoxChild // out
	var _cret C.int              // in

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_flow_box_child_get_index(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c flowBoxChild) IsSelectedFlowBoxChild() bool {
	var _arg0 *C.GtkFlowBoxChild // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_flow_box_child_is_selected(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s flowBoxChild) SetChildFlowBoxChild(child Widget) {
	var _arg0 *C.GtkFlowBoxChild // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_flow_box_child_set_child(_arg0, _arg1)
}

func (s flowBoxChild) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s flowBoxChild) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s flowBoxChild) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s flowBoxChild) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s flowBoxChild) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s flowBoxChild) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s flowBoxChild) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b flowBoxChild) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// FontButton: the `GtkFontButton` allows to open a font chooser dialog to
// change the font.
//
// !An example GtkFontButton (font-button.png)
//
// It is suitable widget for selecting a font in a preference dialog.
//
//
// CSS nodes
//
// ` fontbutton  button.font  [content] `
//
// `GtkFontButton` has a single CSS node with name fontbutton which contains a
// button node with the .font style class.
type FontButton interface {
	Widget
	FontChooser

	// Modal gets whether the dialog is modal.
	Modal() bool
	// Title retrieves the title of the font chooser dialog.
	Title() string
	// UseFont returns whether the selected font is used in the label.
	UseFont() bool
	// UseSize returns whether the selected size is used in the label.
	UseSize() bool
	// SetModalFontButton sets whether the dialog should be modal.
	SetModalFontButton(modal bool)
	// SetTitleFontButton sets the title for the font chooser dialog.
	SetTitleFontButton(title string)
	// SetUseFontFontButton: if @use_font is true, the font name will be written
	// using the selected font.
	SetUseFontFontButton(useFont bool)
	// SetUseSizeFontButton: if @use_size is true, the font name will be written
	// using the selected size.
	SetUseSizeFontButton(useSize bool)
}

// fontButton implements the FontButton class.
type fontButton struct {
	Widget
}

// WrapFontButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontButton(obj *externglib.Object) FontButton {
	return fontButton{
		Widget: WrapWidget(obj),
	}
}

func marshalFontButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontButton(obj), nil
}

// NewFontButton creates a new font picker widget.
func NewFontButton() FontButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_font_button_new()

	var _fontButton FontButton // out

	_fontButton = WrapFontButton(externglib.Take(unsafe.Pointer(_cret)))

	return _fontButton
}

// NewFontButtonWithFont creates a new font picker widget showing the given
// font.
func NewFontButtonWithFont(fontname string) FontButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(fontname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_font_button_new_with_font(_arg1)

	var _fontButton FontButton // out

	_fontButton = WrapFontButton(externglib.Take(unsafe.Pointer(_cret)))

	return _fontButton
}

func (f fontButton) Modal() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f fontButton) Title() string {
	var _arg0 *C.GtkFontButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (f fontButton) UseFont() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_use_font(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f fontButton) UseSize() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_use_size(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f fontButton) SetModalFontButton(modal bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_modal(_arg0, _arg1)
}

func (f fontButton) SetTitleFontButton(title string) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_button_set_title(_arg0, _arg1)
}

func (f fontButton) SetUseFontFontButton(useFont bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if useFont {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_use_font(_arg0, _arg1)
}

func (f fontButton) SetUseSizeFontButton(useSize bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if useSize {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_use_size(_arg0, _arg1)
}

func (s fontButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s fontButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s fontButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s fontButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s fontButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s fontButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s fontButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b fontButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (f fontButton) Font() string {
	return WrapFontChooser(gextras.InternObject(f)).Font()
}

func (f fontButton) FontDesc() *pango.FontDescription {
	return WrapFontChooser(gextras.InternObject(f)).FontDesc()
}

func (f fontButton) FontFace() pango.FontFace {
	return WrapFontChooser(gextras.InternObject(f)).FontFace()
}

func (f fontButton) FontFamily() pango.FontFamily {
	return WrapFontChooser(gextras.InternObject(f)).FontFamily()
}

func (f fontButton) FontFeatures() string {
	return WrapFontChooser(gextras.InternObject(f)).FontFeatures()
}

func (f fontButton) FontMap() pango.FontMap {
	return WrapFontChooser(gextras.InternObject(f)).FontMap()
}

func (f fontButton) FontSize() int {
	return WrapFontChooser(gextras.InternObject(f)).FontSize()
}

func (f fontButton) Language() string {
	return WrapFontChooser(gextras.InternObject(f)).Language()
}

func (f fontButton) Level() FontChooserLevel {
	return WrapFontChooser(gextras.InternObject(f)).Level()
}

func (f fontButton) PreviewText() string {
	return WrapFontChooser(gextras.InternObject(f)).PreviewText()
}

func (f fontButton) ShowPreviewEntry() bool {
	return WrapFontChooser(gextras.InternObject(f)).ShowPreviewEntry()
}

func (f fontButton) SetFont(fontname string) {
	WrapFontChooser(gextras.InternObject(f)).SetFont(fontname)
}

func (f fontButton) SetFontDesc(fontDesc *pango.FontDescription) {
	WrapFontChooser(gextras.InternObject(f)).SetFontDesc(fontDesc)
}

func (f fontButton) SetFontMap(fontmap pango.FontMap) {
	WrapFontChooser(gextras.InternObject(f)).SetFontMap(fontmap)
}

func (f fontButton) SetLanguage(language string) {
	WrapFontChooser(gextras.InternObject(f)).SetLanguage(language)
}

func (f fontButton) SetLevel(level FontChooserLevel) {
	WrapFontChooser(gextras.InternObject(f)).SetLevel(level)
}

func (f fontButton) SetPreviewText(text string) {
	WrapFontChooser(gextras.InternObject(f)).SetPreviewText(text)
}

func (f fontButton) SetShowPreviewEntry(showPreviewEntry bool) {
	WrapFontChooser(gextras.InternObject(f)).SetShowPreviewEntry(showPreviewEntry)
}

// FontChooserDialog: the `GtkFontChooserDialog` widget is a dialog for
// selecting a font.
//
// !An example GtkFontChooserDialog (fontchooser.png)
//
// `GtkFontChooserDialog` implements the [iface@Gtk.FontChooser] interface and
// does not provide much API of its own.
//
// To create a `GtkFontChooserDialog`, use [ctor@Gtk.FontChooserDialog.new].
//
//
// GtkFontChooserDialog as GtkBuildable
//
// The `GtkFontChooserDialog` implementation of the `GtkBuildable` interface
// exposes the buttons with the names select_button and cancel_button.
type FontChooserDialog interface {
	Dialog
	FontChooser
}

// fontChooserDialog implements the FontChooserDialog class.
type fontChooserDialog struct {
	Dialog
}

// WrapFontChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserDialog(obj *externglib.Object) FontChooserDialog {
	return fontChooserDialog{
		Dialog: WrapDialog(obj),
	}
}

func marshalFontChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserDialog(obj), nil
}

// NewFontChooserDialog creates a new `GtkFontChooserDialog`.
func NewFontChooserDialog(title string, parent Window) FontChooserDialog {
	var _arg1 *C.char      // out
	var _arg2 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_font_chooser_dialog_new(_arg1, _arg2)

	var _fontChooserDialog FontChooserDialog // out

	_fontChooserDialog = WrapFontChooserDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _fontChooserDialog
}

func (s fontChooserDialog) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s fontChooserDialog) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s fontChooserDialog) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s fontChooserDialog) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s fontChooserDialog) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s fontChooserDialog) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s fontChooserDialog) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b fontChooserDialog) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (f fontChooserDialog) Font() string {
	return WrapFontChooser(gextras.InternObject(f)).Font()
}

func (f fontChooserDialog) FontDesc() *pango.FontDescription {
	return WrapFontChooser(gextras.InternObject(f)).FontDesc()
}

func (f fontChooserDialog) FontFace() pango.FontFace {
	return WrapFontChooser(gextras.InternObject(f)).FontFace()
}

func (f fontChooserDialog) FontFamily() pango.FontFamily {
	return WrapFontChooser(gextras.InternObject(f)).FontFamily()
}

func (f fontChooserDialog) FontFeatures() string {
	return WrapFontChooser(gextras.InternObject(f)).FontFeatures()
}

func (f fontChooserDialog) FontMap() pango.FontMap {
	return WrapFontChooser(gextras.InternObject(f)).FontMap()
}

func (f fontChooserDialog) FontSize() int {
	return WrapFontChooser(gextras.InternObject(f)).FontSize()
}

func (f fontChooserDialog) Language() string {
	return WrapFontChooser(gextras.InternObject(f)).Language()
}

func (f fontChooserDialog) Level() FontChooserLevel {
	return WrapFontChooser(gextras.InternObject(f)).Level()
}

func (f fontChooserDialog) PreviewText() string {
	return WrapFontChooser(gextras.InternObject(f)).PreviewText()
}

func (f fontChooserDialog) ShowPreviewEntry() bool {
	return WrapFontChooser(gextras.InternObject(f)).ShowPreviewEntry()
}

func (f fontChooserDialog) SetFont(fontname string) {
	WrapFontChooser(gextras.InternObject(f)).SetFont(fontname)
}

func (f fontChooserDialog) SetFontDesc(fontDesc *pango.FontDescription) {
	WrapFontChooser(gextras.InternObject(f)).SetFontDesc(fontDesc)
}

func (f fontChooserDialog) SetFontMap(fontmap pango.FontMap) {
	WrapFontChooser(gextras.InternObject(f)).SetFontMap(fontmap)
}

func (f fontChooserDialog) SetLanguage(language string) {
	WrapFontChooser(gextras.InternObject(f)).SetLanguage(language)
}

func (f fontChooserDialog) SetLevel(level FontChooserLevel) {
	WrapFontChooser(gextras.InternObject(f)).SetLevel(level)
}

func (f fontChooserDialog) SetPreviewText(text string) {
	WrapFontChooser(gextras.InternObject(f)).SetPreviewText(text)
}

func (f fontChooserDialog) SetShowPreviewEntry(showPreviewEntry bool) {
	WrapFontChooser(gextras.InternObject(f)).SetShowPreviewEntry(showPreviewEntry)
}

func (s fontChooserDialog) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s fontChooserDialog) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s fontChooserDialog) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s fontChooserDialog) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s fontChooserDialog) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s fontChooserDialog) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s fontChooserDialog) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s fontChooserDialog) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// FontChooserWidget: the `GtkFontChooserWidget` widget lets the user select a
// font.
//
// It is used in the `GtkFontChooserDialog` widget to provide a dialog for
// selecting fonts.
//
// To set the font which is initially selected, use
// [method@Gtk.FontChooser.set_font] or [method@Gtk.FontChooser.set_font_desc].
//
// To get the selected font use [method@Gtk.FontChooser.get_font] or
// [method@Gtk.FontChooser.get_font_desc].
//
// To change the text which is shown in the preview area, use
// [method@Gtk.FontChooser.set_preview_text].
//
//
// CSS nodes
//
// `GtkFontChooserWidget` has a single CSS node with name fontchooser.
type FontChooserWidget interface {
	Widget
	FontChooser
}

// fontChooserWidget implements the FontChooserWidget class.
type fontChooserWidget struct {
	Widget
}

// WrapFontChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserWidget(obj *externglib.Object) FontChooserWidget {
	return fontChooserWidget{
		Widget: WrapWidget(obj),
	}
}

func marshalFontChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserWidget(obj), nil
}

// NewFontChooserWidget creates a new `GtkFontChooserWidget`.
func NewFontChooserWidget() FontChooserWidget {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_font_chooser_widget_new()

	var _fontChooserWidget FontChooserWidget // out

	_fontChooserWidget = WrapFontChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _fontChooserWidget
}

func (s fontChooserWidget) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s fontChooserWidget) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s fontChooserWidget) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s fontChooserWidget) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s fontChooserWidget) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s fontChooserWidget) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s fontChooserWidget) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b fontChooserWidget) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (f fontChooserWidget) Font() string {
	return WrapFontChooser(gextras.InternObject(f)).Font()
}

func (f fontChooserWidget) FontDesc() *pango.FontDescription {
	return WrapFontChooser(gextras.InternObject(f)).FontDesc()
}

func (f fontChooserWidget) FontFace() pango.FontFace {
	return WrapFontChooser(gextras.InternObject(f)).FontFace()
}

func (f fontChooserWidget) FontFamily() pango.FontFamily {
	return WrapFontChooser(gextras.InternObject(f)).FontFamily()
}

func (f fontChooserWidget) FontFeatures() string {
	return WrapFontChooser(gextras.InternObject(f)).FontFeatures()
}

func (f fontChooserWidget) FontMap() pango.FontMap {
	return WrapFontChooser(gextras.InternObject(f)).FontMap()
}

func (f fontChooserWidget) FontSize() int {
	return WrapFontChooser(gextras.InternObject(f)).FontSize()
}

func (f fontChooserWidget) Language() string {
	return WrapFontChooser(gextras.InternObject(f)).Language()
}

func (f fontChooserWidget) Level() FontChooserLevel {
	return WrapFontChooser(gextras.InternObject(f)).Level()
}

func (f fontChooserWidget) PreviewText() string {
	return WrapFontChooser(gextras.InternObject(f)).PreviewText()
}

func (f fontChooserWidget) ShowPreviewEntry() bool {
	return WrapFontChooser(gextras.InternObject(f)).ShowPreviewEntry()
}

func (f fontChooserWidget) SetFont(fontname string) {
	WrapFontChooser(gextras.InternObject(f)).SetFont(fontname)
}

func (f fontChooserWidget) SetFontDesc(fontDesc *pango.FontDescription) {
	WrapFontChooser(gextras.InternObject(f)).SetFontDesc(fontDesc)
}

func (f fontChooserWidget) SetFontMap(fontmap pango.FontMap) {
	WrapFontChooser(gextras.InternObject(f)).SetFontMap(fontmap)
}

func (f fontChooserWidget) SetLanguage(language string) {
	WrapFontChooser(gextras.InternObject(f)).SetLanguage(language)
}

func (f fontChooserWidget) SetLevel(level FontChooserLevel) {
	WrapFontChooser(gextras.InternObject(f)).SetLevel(level)
}

func (f fontChooserWidget) SetPreviewText(text string) {
	WrapFontChooser(gextras.InternObject(f)).SetPreviewText(text)
}

func (f fontChooserWidget) SetShowPreviewEntry(showPreviewEntry bool) {
	WrapFontChooser(gextras.InternObject(f)).SetShowPreviewEntry(showPreviewEntry)
}

// Frame: `GtkFrame` is a widget that surrounds its child with a decorative
// frame and an optional label.
//
// !An example GtkFrame (frame.png)
//
// If present, the label is drawn inside the top edge of the frame. The
// horizontal position of the label can be controlled with
// [method@Gtk.Frame.set_label_align].
//
// `GtkFrame` clips its child. You can use this to add rounded corners to
// widgets, but be aware that it also cuts off shadows.
//
//
// GtkFrame as GtkBuildable
//
// The `GtkFrame` implementation of the `GtkBuildable` interface supports
// placing a child in the label position by specifying label as the type
// attribute of a <child> element. A normal content child can be specified
// without specifying a <child> type attribute.
//
// An example of a UI definition fragment with GtkFrame: `xml <object
// class="GtkFrame"> <child type="label"> <object class="GtkLabel"
// id="frame_label"/> </child> <child> <object class="GtkEntry"
// id="frame_content"/> </child> </object> `
//
//
// CSS nodes
//
// ` frame  <label widget>  <child> `
//
// `GtkFrame` has a main CSS node with name frame, which is used to draw the
// visible border. You can set the appearance of the border using CSS properties
// like border-style on this node.
type Frame interface {
	Widget

	// Child gets the child widget of @frame.
	Child() Widget
	// Label returns the frame labels text.
	//
	// If the frame's label widget is not a `GtkLabel`, nil is returned.
	Label() string
	// LabelAlign retrieves the X alignment of the frames label.
	LabelAlign() float32
	// LabelWidget retrieves the label widget for the frame.
	LabelWidget() Widget
	// SetChildFrame sets the child widget of @frame.
	SetChildFrame(child Widget)
	// SetLabelFrame creates a new `GtkLabel` with the @label and sets it as the
	// frame's label widget.
	SetLabelFrame(label string)
	// SetLabelAlignFrame sets the X alignment of the frame widgets label.
	//
	// The default value for a newly created frame is 0.0.
	SetLabelAlignFrame(xalign float32)
	// SetLabelWidgetFrame sets the label widget for the frame.
	//
	// This is the widget that will appear embedded in the top edge of the frame
	// as a title.
	SetLabelWidgetFrame(labelWidget Widget)
}

// frame implements the Frame class.
type frame struct {
	Widget
}

// WrapFrame wraps a GObject to the right type. It is
// primarily used internally.
func WrapFrame(obj *externglib.Object) Frame {
	return frame{
		Widget: WrapWidget(obj),
	}
}

func marshalFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFrame(obj), nil
}

// NewFrame creates a new `GtkFrame`, with optional label @label.
//
// If @label is nil, the label is omitted.
func NewFrame(label string) Frame {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_frame_new(_arg1)

	var _frame Frame // out

	_frame = WrapFrame(externglib.Take(unsafe.Pointer(_cret)))

	return _frame
}

func (f frame) Child() Widget {
	var _arg0 *C.GtkFrame  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_frame_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (f frame) Label() string {
	var _arg0 *C.GtkFrame // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_frame_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (f frame) LabelAlign() float32 {
	var _arg0 *C.GtkFrame // out
	var _cret C.float     // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_frame_get_label_align(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (f frame) LabelWidget() Widget {
	var _arg0 *C.GtkFrame  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_frame_get_label_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (f frame) SetChildFrame(child Widget) {
	var _arg0 *C.GtkFrame  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_frame_set_child(_arg0, _arg1)
}

func (f frame) SetLabelFrame(label string) {
	var _arg0 *C.GtkFrame // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_frame_set_label(_arg0, _arg1)
}

func (f frame) SetLabelAlignFrame(xalign float32) {
	var _arg0 *C.GtkFrame // out
	var _arg1 C.float     // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
	_arg1 = (C.float)(xalign)

	C.gtk_frame_set_label_align(_arg0, _arg1)
}

func (f frame) SetLabelWidgetFrame(labelWidget Widget) {
	var _arg0 *C.GtkFrame  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

	C.gtk_frame_set_label_widget(_arg0, _arg1)
}

func (s frame) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s frame) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s frame) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s frame) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s frame) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s frame) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s frame) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b frame) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// GLArea: `GtkGLArea` is a widget that allows drawing with OpenGL.
//
// !An example GtkGLArea (glarea.png)
//
// `GtkGLArea` sets up its own [class@Gdk.GLContext], and creates a custom GL
// framebuffer that the widget will do GL rendering onto. It also ensures that
// this framebuffer is the default GL rendering target when rendering.
//
// In order to draw, you have to connect to the [signal@Gtk.GLArea::render]
// signal, or subclass `GtkGLArea` and override the GtkGLAreaClass.render
// virtual function.
//
// The `GtkGLArea` widget ensures that the `GdkGLContext` is associated with the
// widget's drawing area, and it is kept updated when the size and position of
// the drawing area changes.
//
//
// Drawing with GtkGLArea
//
// The simplest way to draw using OpenGL commands in a `GtkGLArea` is to create
// a widget instance and connect to the [signal@Gtk.GLArea::render] signal:
//
// The `render()` function will be called when the `GtkGLArea` is ready for you
// to draw its content:
//
// `c static gboolean render (GtkGLArea *area, GdkGLContext *context) { //
// inside this function it's safe to use GL; the given // GLContext has been
// made current to the drawable // surface used by the `GtkGLArea` and the
// viewport has // already been set to be the size of the allocation
//
//    // we can start by clearing the buffer
//    glClearColor (0, 0, 0, 0);
//    glClear (GL_COLOR_BUFFER_BIT);
//
//    // draw your object
//    // draw_an_object ();
//
//    // we completed our drawing; the draw commands will be
//    // flushed at the end of the signal emission chain, and
//    // the buffers will be drawn on the window
//    return TRUE;
//
// }
//
// void setup_glarea (void) { // create a GtkGLArea instance GtkWidget *gl_area
// = gtk_gl_area_new ();
//
//    // connect to the "render" signal
//    g_signal_connect (gl_area, "render", G_CALLBACK (render), NULL);
//
// } `
//
// If you need to initialize OpenGL state, e.g. buffer objects or shaders, you
// should use the [signal@Gtk.Widget::realize] signal; you can use the
// [signal@Gtk.Widget::unrealize] signal to clean up. Since the `GdkGLContext`
// creation and initialization may fail, you will need to check for errors,
// using [method@Gtk.GLArea.get_error].
//
// An example of how to safely initialize the GL state is:
//
// `c static void on_realize (GtkGLarea *area) { // We need to make the context
// current if we want to // call GL API gtk_gl_area_make_current (area);
//
//    // If there were errors during the initialization or
//    // when trying to make the context current, this
//    // function will return a #GError for you to catch
//    if (gtk_gl_area_get_error (area) != NULL)
//      return;
//
//    // You can also use gtk_gl_area_set_error() in order
//    // to show eventual initialization errors on the
//    // GtkGLArea widget itself
//    GError *internal_error = NULL;
//    init_buffer_objects (&error);
//    if (error != NULL)
//      {
//        gtk_gl_area_set_error (area, error);
//        g_error_free (error);
//        return;
//      }
//
//    init_shaders (&error);
//    if (error != NULL)
//      {
//        gtk_gl_area_set_error (area, error);
//        g_error_free (error);
//        return;
//      }
//
// } `
//
// If you need to change the options for creating the `GdkGLContext` you should
// use the [signal@Gtk.GLArea::create-context] signal.
type GLArea interface {
	Widget

	// AttachBuffersGLArea binds buffers to the framebuffer.
	//
	// Ensures that the @area framebuffer object is made the current draw and
	// read target, and that all the required buffers for the @area are created
	// and bound to the framebuffer.
	//
	// This function is automatically called before emitting the
	// [signal@Gtk.GLArea::render] signal, and doesn't normally need to be
	// called by application code.
	AttachBuffersGLArea()
	// AutoRender returns whether the area is in auto render mode or not.
	AutoRender() bool
	// Context retrieves the `GdkGLContext` used by @area.
	Context() gdk.GLContext
	// Error gets the current error set on the @area.
	Error() error
	// HasDepthBuffer returns whether the area has a depth buffer.
	HasDepthBuffer() bool
	// HasStencilBuffer returns whether the area has a stencil buffer.
	HasStencilBuffer() bool
	// RequiredVersion retrieves the required version of OpenGL.
	//
	// See [method@Gtk.GLArea.set_required_version].
	RequiredVersion() (major int, minor int)
	// UseES returns whether the `GtkGLArea` should use OpenGL ES.
	//
	// See [method@Gtk.GLArea.set_use_es].
	UseES() bool
	// MakeCurrentGLArea ensures that the `GdkGLContext` used by @area is
	// associated with the `GtkGLArea`.
	//
	// This function is automatically called before emitting the
	// [signal@Gtk.GLArea::render] signal, and doesn't normally need to be
	// called by application code.
	MakeCurrentGLArea()
	// QueueRenderGLArea marks the currently rendered data (if any) as invalid,
	// and queues a redraw of the widget.
	//
	// This ensures that the [signal@Gtk.GLArea::render] signal is emitted
	// during the draw.
	//
	// This is only needed when [method@Gtk.GLArea.set_auto_render] has been
	// called with a false value. The default behaviour is to emit
	// [signal@Gtk.GLArea::render] on each draw.
	QueueRenderGLArea()
	// SetAutoRenderGLArea sets whether the `GtkGLArea` is in auto render mode.
	//
	// If @auto_render is true the [signal@Gtk.GLArea::render] signal will be
	// emitted every time the widget draws. This is the default and is useful if
	// drawing the widget is faster.
	//
	// If @auto_render is false the data from previous rendering is kept around
	// and will be used for drawing the widget the next time, unless the window
	// is resized. In order to force a rendering
	// [method@Gtk.GLArea.queue_render] must be called. This mode is useful when
	// the scene changes seldom, but takes a long time to redraw.
	SetAutoRenderGLArea(autoRender bool)
	// SetErrorGLArea sets an error on the area which will be shown instead of
	// the GL rendering.
	//
	// This is useful in the [signal@Gtk.GLArea::create-context] signal if GL
	// context creation fails.
	SetErrorGLArea(err error)
	// SetHasDepthBufferGLArea sets whether the `GtkGLArea` should use a depth
	// buffer.
	//
	// If @has_depth_buffer is true the widget will allocate and enable a depth
	// buffer for the target framebuffer. Otherwise there will be none.
	SetHasDepthBufferGLArea(hasDepthBuffer bool)
	// SetHasStencilBufferGLArea sets whether the `GtkGLArea` should use a
	// stencil buffer.
	//
	// If @has_stencil_buffer is true the widget will allocate and enable a
	// stencil buffer for the target framebuffer. Otherwise there will be none.
	SetHasStencilBufferGLArea(hasStencilBuffer bool)
	// SetRequiredVersionGLArea sets the required version of OpenGL to be used
	// when creating the context for the widget.
	//
	// This function must be called before the area has been realized.
	SetRequiredVersionGLArea(major int, minor int)
	// SetUseESGLArea sets whether the @area should create an OpenGL or an
	// OpenGL ES context.
	//
	// You should check the capabilities of the GLContext before drawing with
	// either API.
	SetUseESGLArea(useEs bool)
}

// glArea implements the GLArea class.
type glArea struct {
	Widget
}

// WrapGLArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLArea(obj *externglib.Object) GLArea {
	return glArea{
		Widget: WrapWidget(obj),
	}
}

func marshalGLArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLArea(obj), nil
}

// NewGLArea creates a new `GtkGLArea` widget.
func NewGLArea() GLArea {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_gl_area_new()

	var _glArea GLArea // out

	_glArea = WrapGLArea(externglib.Take(unsafe.Pointer(_cret)))

	return _glArea
}

func (a glArea) AttachBuffersGLArea() {
	var _arg0 *C.GtkGLArea // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	C.gtk_gl_area_attach_buffers(_arg0)
}

func (a glArea) AutoRender() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_auto_render(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a glArea) Context() gdk.GLContext {
	var _arg0 *C.GtkGLArea    // out
	var _cret *C.GdkGLContext // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_context(_arg0)

	var _glContext gdk.GLContext // out

	_glContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.GLContext)

	return _glContext
}

func (a glArea) Error() error {
	var _arg0 *C.GtkGLArea // out
	var _cret *C.GError    // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_error(_arg0)

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(_cret))

	return _err
}

func (a glArea) HasDepthBuffer() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_has_depth_buffer(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a glArea) HasStencilBuffer() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_has_stencil_buffer(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a glArea) RequiredVersion() (major int, minor int) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.int        // in
	var _arg2 C.int        // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	C.gtk_gl_area_get_required_version(_arg0, &_arg1, &_arg2)

	var _major int // out
	var _minor int // out

	_major = (int)(_arg1)
	_minor = (int)(_arg2)

	return _major, _minor
}

func (a glArea) UseES() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_use_es(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a glArea) MakeCurrentGLArea() {
	var _arg0 *C.GtkGLArea // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	C.gtk_gl_area_make_current(_arg0)
}

func (a glArea) QueueRenderGLArea() {
	var _arg0 *C.GtkGLArea // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	C.gtk_gl_area_queue_render(_arg0)
}

func (a glArea) SetAutoRenderGLArea(autoRender bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	if autoRender {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_auto_render(_arg0, _arg1)
}

func (a glArea) SetErrorGLArea(err error) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 *C.GError    // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GError)(gerror.New(err))
	defer C.g_error_free(_arg1)

	C.gtk_gl_area_set_error(_arg0, _arg1)
}

func (a glArea) SetHasDepthBufferGLArea(hasDepthBuffer bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	if hasDepthBuffer {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_has_depth_buffer(_arg0, _arg1)
}

func (a glArea) SetHasStencilBufferGLArea(hasStencilBuffer bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	if hasStencilBuffer {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_has_stencil_buffer(_arg0, _arg1)
}

func (a glArea) SetRequiredVersionGLArea(major int, minor int) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	_arg1 = (C.int)(major)
	_arg2 = (C.int)(minor)

	C.gtk_gl_area_set_required_version(_arg0, _arg1, _arg2)
}

func (a glArea) SetUseESGLArea(useEs bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	if useEs {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_use_es(_arg0, _arg1)
}

func (s glArea) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s glArea) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s glArea) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s glArea) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s glArea) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s glArea) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s glArea) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b glArea) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Gesture: `GtkGesture` is the base class for gesture recognition.
//
// Although `GtkGesture` is quite generalized to serve as a base for multi-touch
// gestures, it is suitable to implement single-touch and pointer-based gestures
// (using the special nil `GdkEventSequence` value for these).
//
// The number of touches that a `GtkGesture` need to be recognized is controlled
// by the [property@Gtk.Gesture:n-points] property, if a gesture is keeping
// track of less or more than that number of sequences, it won't check whether
// the gesture is recognized.
//
// As soon as the gesture has the expected number of touches, it will check
// regularly if it is recognized, the criteria to consider a gesture as
// "recognized" is left to `GtkGesture` subclasses.
//
// A recognized gesture will then emit the following signals:
//
// - [signal@Gtk.Gesture::begin] when the gesture is recognized. -
// [signal@Gtk.Gesture::update], whenever an input event is processed. -
// [signal@Gtk.Gesture::end] when the gesture is no longer recognized.
//
//
// Event propagation
//
// In order to receive events, a gesture needs to set a propagation phase
// through [method@Gtk.EventController.set_propagation_phase].
//
// In the capture phase, events are propagated from the toplevel down to the
// target widget, and gestures that are attached to containers above the widget
// get a chance to interact with the event before it reaches the target.
//
// In the bubble phase, events are propagated up from the target widget to the
// toplevel, and gestures that are attached to containers above the widget get a
// chance to interact with events that have not been handled yet.
//
//
// States of a sequence
//
// Whenever input interaction happens, a single event may trigger a cascade of
// `GtkGesture`s, both across the parents of the widget receiving the event and
// in parallel within an individual widget. It is a responsibility of the
// widgets using those gestures to set the state of touch sequences accordingly
// in order to enable cooperation of gestures around the `GdkEventSequence`s
// triggering those.
//
// Within a widget, gestures can be grouped through [method@Gtk.Gesture.group].
// Grouped gestures synchronize the state of sequences, so calling
// [method@Gtk.Gesture.set_sequence_state] on one will effectively propagate the
// state throughout the group.
//
// By default, all sequences start out in the GTK_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
//
// If a sequence enters into the GTK_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while the
// touch is active.
//
// If a sequence enters in the GTK_EVENT_SEQUENCE_CLAIMED state, the gesture
// group will grab all interaction on the sequence, by:
//
// - Setting the same sequence to GTK_EVENT_SEQUENCE_DENIED on every other
// gesture group within the widget, and every gesture on parent widgets in the
// propagation chain. - Emitting [signal@Gtk.Gesture::cancel] on every gesture
// in widgets underneath in the propagation chain. - Stopping event propagation
// after the gesture group handles the event.
//
// Note: if a sequence is set early to GTK_EVENT_SEQUENCE_CLAIMED on
// GDK_TOUCH_BEGIN/GDK_BUTTON_PRESS (so those events are captured before
// reaching the event widget, this implies GTK_PHASE_CAPTURE), one similar event
// will emulated if the sequence changes to GTK_EVENT_SEQUENCE_DENIED. This way
// event coherence is preserved before event propagation is unstopped again.
//
// Sequence states can't be changed freely. See
// [method@Gtk.Gesture.set_sequence_state] to know about the possible lifetimes
// of a `GdkEventSequence`.
//
//
// Touchpad gestures
//
// On the platforms that support it, `GtkGesture` will handle transparently
// touchpad gesture events. The only precautions users of `GtkGesture` should do
// to enable this support are:
//
// - If the gesture has GTK_PHASE_NONE, ensuring events of type
// GDK_TOUCHPAD_SWIPE and GDK_TOUCHPAD_PINCH are handled by the `GtkGesture`
type Gesture interface {

	// BoundingBox: if there are touch sequences being currently handled by
	// @gesture, returns true and fills in @rect with the bounding box
	// containing all active touches.
	//
	// Otherwise, false will be returned.
	//
	// Note: This function will yield unexpected results on touchpad gestures.
	// Since there is no correlation between physical and pixel distances, these
	// will look as if constrained in an infinitely small area, @rect width and
	// height will thus be 0 regardless of the number of touchpoints.
	BoundingBox() (gdk.Rectangle, bool)
	// BoundingBoxCenter: if there are touch sequences being currently handled
	// by @gesture, returns true and fills in @x and @y with the center of the
	// bounding box containing all active touches.
	//
	// Otherwise, false will be returned.
	BoundingBoxCenter() (x float64, y float64, ok bool)
	// Device returns the logical `GdkDevice` that is currently operating on
	// @gesture.
	//
	// This returns nil if the gesture is not being interacted.
	Device() gdk.Device
	// LastEvent returns the last event that was processed for @sequence.
	//
	// Note that the returned pointer is only valid as long as the @sequence is
	// still interpreted by the @gesture. If in doubt, you should make a copy of
	// the event.
	LastEvent(sequence *gdk.EventSequence) gdk.Event
	// LastUpdatedSequence returns the `GdkEventSequence` that was last updated
	// on @gesture.
	LastUpdatedSequence() *gdk.EventSequence
	// Point: if @sequence is currently being interpreted by @gesture, returns
	// true and fills in @x and @y with the last coordinates stored for that
	// event sequence.
	//
	// The coordinates are always relative to the widget allocation.
	Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool)
	// SequenceState returns the @sequence state, as seen by @gesture.
	SequenceState(sequence *gdk.EventSequence) EventSequenceState
	// GroupGesture adds @gesture to the same group than @group_gesture.
	//
	// Gestures are by default isolated in their own groups.
	//
	// Both gestures must have been added to the same widget before they can be
	// grouped.
	//
	// When gestures are grouped, the state of `GdkEventSequences` is kept in
	// sync for all of those, so calling
	// [method@Gtk.Gesture.set_sequence_state], on one will transfer the same
	// value to the others.
	//
	// Groups also perform an "implicit grabbing" of sequences, if a
	// `GdkEventSequence` state is set to GTK_EVENT_SEQUENCE_CLAIMED on one
	// group, every other gesture group attached to the same `GtkWidget` will
	// switch the state for that sequence to GTK_EVENT_SEQUENCE_DENIED.
	GroupGesture(gesture Gesture)
	// HandlesSequenceGesture returns true if @gesture is currently handling
	// events corresponding to @sequence.
	HandlesSequenceGesture(sequence *gdk.EventSequence) bool
	// IsActiveGesture returns true if the gesture is currently active.
	//
	// A gesture is active while there are touch sequences interacting with it.
	IsActiveGesture() bool
	// IsGroupedWithGesture returns true if both gestures pertain to the same
	// group.
	IsGroupedWithGesture(other Gesture) bool
	// IsRecognizedGesture returns true if the gesture is currently recognized.
	//
	// A gesture is recognized if there are as many interacting touch sequences
	// as required by @gesture.
	IsRecognizedGesture() bool
	// SetSequenceStateGesture sets the state of @sequence in @gesture.
	//
	// Sequences start in state GTK_EVENT_SEQUENCE_NONE, and whenever they
	// change state, they can never go back to that state. Likewise, sequences
	// in state GTK_EVENT_SEQUENCE_DENIED cannot turn back to a not denied
	// state. With these rules, the lifetime of an event sequence is constrained
	// to the next four:
	//
	// * None * None  Denied * None  Claimed * None  Claimed  Denied
	//
	// Note: Due to event handling ordering, it may be unsafe to set the state
	// on another gesture within a [signal@Gtk.Gesture::begin] signal handler,
	// as the callback might be executed before the other gesture knows about
	// the sequence. A safe way to perform this could be:
	//
	// `c static void first_gesture_begin_cb (GtkGesture *first_gesture,
	// GdkEventSequence *sequence, gpointer user_data) {
	// gtk_gesture_set_sequence_state (first_gesture, sequence,
	// GTK_EVENT_SEQUENCE_CLAIMED); gtk_gesture_set_sequence_state
	// (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED); }
	//
	// static void second_gesture_begin_cb (GtkGesture *second_gesture,
	// GdkEventSequence *sequence, gpointer user_data) { if
	// (gtk_gesture_get_sequence_state (first_gesture, sequence) ==
	// GTK_EVENT_SEQUENCE_CLAIMED) gtk_gesture_set_sequence_state
	// (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED); } `
	//
	// If both gestures are in the same group, just set the state on the gesture
	// emitting the event, the sequence will be already be initialized to the
	// group's global state when the second gesture processes the event.
	SetSequenceStateGesture(sequence *gdk.EventSequence, state EventSequenceState) bool
	// SetStateGesture sets the state of all sequences that @gesture is
	// currently interacting with.
	//
	// See [method@Gtk.Gesture.set_sequence_state] for more details on sequence
	// states.
	SetStateGesture(state EventSequenceState) bool
	// UngroupGesture separates @gesture into an isolated group.
	UngroupGesture()
}

// gesture implements the Gesture class.
type gesture struct {
	EventController
}

// WrapGesture wraps a GObject to the right type. It is
// primarily used internally.
func WrapGesture(obj *externglib.Object) Gesture {
	return gesture{
		EventController: WrapEventController(obj),
	}
}

func marshalGesture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGesture(obj), nil
}

func (g gesture) BoundingBox() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkGesture // out
	var _rect gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_get_bounding_box(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

func (g gesture) BoundingBoxCenter() (x float64, y float64, ok bool) {
	var _arg0 *C.GtkGesture // out
	var _arg1 C.double      // in
	var _arg2 C.double      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_get_bounding_box_center(_arg0, &_arg1, &_arg2)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = (float64)(_arg1)
	_y = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

func (g gesture) Device() gdk.Device {
	var _arg0 *C.GtkGesture // out
	var _cret *C.GdkDevice  // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_get_device(_arg0)

	var _device gdk.Device // out

	_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Device)

	return _device
}

func (g gesture) LastEvent(sequence *gdk.EventSequence) gdk.Event {
	var _arg0 *C.GtkGesture       // out
	var _arg1 *C.GdkEventSequence // out
	var _cret *C.GdkEvent         // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

	_cret = C.gtk_gesture_get_last_event(_arg0, _arg1)

	var _event gdk.Event // out

	_event = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Event)

	return _event
}

func (g gesture) LastUpdatedSequence() *gdk.EventSequence {
	var _arg0 *C.GtkGesture       // out
	var _cret *C.GdkEventSequence // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_get_last_updated_sequence(_arg0)

	var _eventSequence *gdk.EventSequence // out

	_eventSequence = gdk.WrapEventSequence(unsafe.Pointer(_cret))

	return _eventSequence
}

func (g gesture) Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool) {
	var _arg0 *C.GtkGesture       // out
	var _arg1 *C.GdkEventSequence // out
	var _arg2 C.double            // in
	var _arg3 C.double            // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

	_cret = C.gtk_gesture_get_point(_arg0, _arg1, &_arg2, &_arg3)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = (float64)(_arg2)
	_y = (float64)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

func (g gesture) SequenceState(sequence *gdk.EventSequence) EventSequenceState {
	var _arg0 *C.GtkGesture           // out
	var _arg1 *C.GdkEventSequence     // out
	var _cret C.GtkEventSequenceState // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

	_cret = C.gtk_gesture_get_sequence_state(_arg0, _arg1)

	var _eventSequenceState EventSequenceState // out

	_eventSequenceState = EventSequenceState(_cret)

	return _eventSequenceState
}

func (g gesture) GroupGesture(gesture Gesture) {
	var _arg0 *C.GtkGesture // out
	var _arg1 *C.GtkGesture // out

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkGesture)(unsafe.Pointer(gesture.Native()))

	C.gtk_gesture_group(_arg0, _arg1)
}

func (g gesture) HandlesSequenceGesture(sequence *gdk.EventSequence) bool {
	var _arg0 *C.GtkGesture       // out
	var _arg1 *C.GdkEventSequence // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

	_cret = C.gtk_gesture_handles_sequence(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gesture) IsActiveGesture() bool {
	var _arg0 *C.GtkGesture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gesture) IsGroupedWithGesture(other Gesture) bool {
	var _arg0 *C.GtkGesture // out
	var _arg1 *C.GtkGesture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkGesture)(unsafe.Pointer(other.Native()))

	_cret = C.gtk_gesture_is_grouped_with(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gesture) IsRecognizedGesture() bool {
	var _arg0 *C.GtkGesture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_is_recognized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gesture) SetSequenceStateGesture(sequence *gdk.EventSequence, state EventSequenceState) bool {
	var _arg0 *C.GtkGesture           // out
	var _arg1 *C.GdkEventSequence     // out
	var _arg2 C.GtkEventSequenceState // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))
	_arg2 = (C.GtkEventSequenceState)(state)

	_cret = C.gtk_gesture_set_sequence_state(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gesture) SetStateGesture(state EventSequenceState) bool {
	var _arg0 *C.GtkGesture           // out
	var _arg1 C.GtkEventSequenceState // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (C.GtkEventSequenceState)(state)

	_cret = C.gtk_gesture_set_state(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gesture) UngroupGesture() {
	var _arg0 *C.GtkGesture // out

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	C.gtk_gesture_ungroup(_arg0)
}

// GestureClick: `GtkGestureClick` is a `GtkGesture` implementation for clicks.
//
// It is able to recognize multiple clicks on a nearby zone, which can be
// listened for through the [signal@Gtk.GestureClick::pressed] signal. Whenever
// time or distance between clicks exceed the GTK defaults,
// [signal@Gtk.GestureClick::stopped] is emitted, and the click counter is
// reset.
type GestureClick interface {
}

// gestureClick implements the GestureClick class.
type gestureClick struct {
	GestureSingle
}

// WrapGestureClick wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureClick(obj *externglib.Object) GestureClick {
	return gestureClick{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureClick(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureClick(obj), nil
}

// NewGestureClick returns a newly created `GtkGesture` that recognizes single
// and multiple presses.
func NewGestureClick() GestureClick {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_click_new()

	var _gestureClick GestureClick // out

	_gestureClick = WrapGestureClick(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureClick
}

// GestureDrag: `GtkGestureDrag` is a `GtkGesture` implementation for drags.
//
// The drag operation itself can be tracked throughout the
// [signal@Gtk.GestureDrag::drag-begin], [signal@Gtk.GestureDrag::drag-update]
// and [signal@Gtk.GestureDrag::drag-end] signals, and the relevant coordinates
// can be extracted through [method@Gtk.GestureDrag.get_offset] and
// [method@Gtk.GestureDrag.get_start_point].
type GestureDrag interface {

	// Offset gets the offset from the start point.
	//
	// If the @gesture is active, this function returns true and fills in @x and
	// @y with the coordinates of the current point, as an offset to the
	// starting drag point.
	Offset() (x float64, y float64, ok bool)
	// StartPoint gets the point where the drag started.
	//
	// If the @gesture is active, this function returns true and fills in @x and
	// @y with the drag start coordinates, in surface-relative coordinates.
	StartPoint() (x float64, y float64, ok bool)
}

// gestureDrag implements the GestureDrag class.
type gestureDrag struct {
	GestureSingle
}

// WrapGestureDrag wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureDrag(obj *externglib.Object) GestureDrag {
	return gestureDrag{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureDrag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureDrag(obj), nil
}

// NewGestureDrag returns a newly created `GtkGesture` that recognizes drags.
func NewGestureDrag() GestureDrag {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_drag_new()

	var _gestureDrag GestureDrag // out

	_gestureDrag = WrapGestureDrag(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureDrag
}

func (g gestureDrag) Offset() (x float64, y float64, ok bool) {
	var _arg0 *C.GtkGestureDrag // out
	var _arg1 C.double          // in
	var _arg2 C.double          // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_drag_get_offset(_arg0, &_arg1, &_arg2)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = (float64)(_arg1)
	_y = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

func (g gestureDrag) StartPoint() (x float64, y float64, ok bool) {
	var _arg0 *C.GtkGestureDrag // out
	var _arg1 C.double          // in
	var _arg2 C.double          // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_drag_get_start_point(_arg0, &_arg1, &_arg2)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = (float64)(_arg1)
	_y = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// GestureLongPress: `GtkGestureLongPress` is a `GtkGesture` for long presses.
//
// This gesture is also known as Press and Hold.
//
// When the timeout is exceeded, the gesture is triggering the
// [signal@Gtk.GestureLongPress::pressed] signal.
//
// If the touchpoint is lifted before the timeout passes, or if it drifts too
// far of the initial press point, the [signal@Gtk.GestureLongPress::cancelled]
// signal will be emitted.
//
// How long the timeout is before the ::pressed signal gets emitted is
// determined by the [property@Gtk.Settings:gtk-long-press-time] setting. It can
// be modified by the [property@Gtk.GestureLongPress:delay-factor] property.
type GestureLongPress interface {

	// DelayFactor returns the delay factor.
	DelayFactor() float64
	// SetDelayFactorGestureLongPress applies the given delay factor.
	//
	// The default long press time will be multiplied by this value. Valid
	// values are in the range [0.5..2.0].
	SetDelayFactorGestureLongPress(delayFactor float64)
}

// gestureLongPress implements the GestureLongPress class.
type gestureLongPress struct {
	GestureSingle
}

// WrapGestureLongPress wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureLongPress(obj *externglib.Object) GestureLongPress {
	return gestureLongPress{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureLongPress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureLongPress(obj), nil
}

// NewGestureLongPress returns a newly created `GtkGesture` that recognizes long
// presses.
func NewGestureLongPress() GestureLongPress {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_long_press_new()

	var _gestureLongPress GestureLongPress // out

	_gestureLongPress = WrapGestureLongPress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureLongPress
}

func (g gestureLongPress) DelayFactor() float64 {
	var _arg0 *C.GtkGestureLongPress // out
	var _cret C.double               // in

	_arg0 = (*C.GtkGestureLongPress)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_long_press_get_delay_factor(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (g gestureLongPress) SetDelayFactorGestureLongPress(delayFactor float64) {
	var _arg0 *C.GtkGestureLongPress // out
	var _arg1 C.double               // out

	_arg0 = (*C.GtkGestureLongPress)(unsafe.Pointer(g.Native()))
	_arg1 = (C.double)(delayFactor)

	C.gtk_gesture_long_press_set_delay_factor(_arg0, _arg1)
}

// GesturePan: `GtkGesturePan` is a `GtkGesture` for pan gestures.
//
// These are drags that are locked to happen along one axis. The axis that a
// `GtkGesturePan` handles is defined at construct time, and can be changed
// through [method@Gtk.GesturePan.set_orientation].
//
// When the gesture starts to be recognized, `GtkGesturePan` will attempt to
// determine as early as possible whether the sequence is moving in the expected
// direction, and denying the sequence if this does not happen.
//
// Once a panning gesture along the expected axis is recognized, the
// [signal@Gtk.GesturePan::pan] signal will be emitted as input events are
// received, containing the offset in the given axis.
type GesturePan interface {

	// Orientation returns the orientation of the pan gestures that this
	// @gesture expects.
	Orientation() Orientation
	// SetOrientationGesturePan sets the orientation to be expected on pan
	// gestures.
	SetOrientationGesturePan(orientation Orientation)
}

// gesturePan implements the GesturePan class.
type gesturePan struct {
	GestureDrag
}

// WrapGesturePan wraps a GObject to the right type. It is
// primarily used internally.
func WrapGesturePan(obj *externglib.Object) GesturePan {
	return gesturePan{
		GestureDrag: WrapGestureDrag(obj),
	}
}

func marshalGesturePan(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGesturePan(obj), nil
}

// NewGesturePan returns a newly created `GtkGesture` that recognizes pan
// gestures.
func NewGesturePan(orientation Orientation) GesturePan {
	var _arg1 C.GtkOrientation // out
	var _cret *C.GtkGesture    // in

	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_gesture_pan_new(_arg1)

	var _gesturePan GesturePan // out

	_gesturePan = WrapGesturePan(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gesturePan
}

func (g gesturePan) Orientation() Orientation {
	var _arg0 *C.GtkGesturePan // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_pan_get_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

func (g gesturePan) SetOrientationGesturePan(orientation Orientation) {
	var _arg0 *C.GtkGesturePan // out
	var _arg1 C.GtkOrientation // out

	_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(g.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	C.gtk_gesture_pan_set_orientation(_arg0, _arg1)
}

// GestureRotate: `GtkGestureRotate` is a `GtkGesture` for 2-finger rotations.
//
// Whenever the angle between both handled sequences changes, the
// [signal@Gtk.GestureRotate::angle-changed] signal is emitted.
type GestureRotate interface {

	// AngleDelta gets the angle delta in radians.
	//
	// If @gesture is active, this function returns the angle difference in
	// radians since the gesture was first recognized. If @gesture is not
	// active, 0 is returned.
	AngleDelta() float64
}

// gestureRotate implements the GestureRotate class.
type gestureRotate struct {
	Gesture
}

// WrapGestureRotate wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureRotate(obj *externglib.Object) GestureRotate {
	return gestureRotate{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureRotate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureRotate(obj), nil
}

// NewGestureRotate returns a newly created `GtkGesture` that recognizes 2-touch
// rotation gestures.
func NewGestureRotate() GestureRotate {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_rotate_new()

	var _gestureRotate GestureRotate // out

	_gestureRotate = WrapGestureRotate(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureRotate
}

func (g gestureRotate) AngleDelta() float64 {
	var _arg0 *C.GtkGestureRotate // out
	var _cret C.double            // in

	_arg0 = (*C.GtkGestureRotate)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_rotate_get_angle_delta(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// GestureSingle: `GtkGestureSingle` is a `GtkGestures` subclass optimized for
// singe-touch and mouse gestures.
//
// Under interaction, these gestures stick to the first interacting sequence,
// which is accessible through [method@Gtk.GestureSingle.get_current_sequence]
// while the gesture is being interacted with.
//
// By default gestures react to both GDK_BUTTON_PRIMARY and touch events.
// [method@Gtk.GestureSingle.set_touch_only] can be used to change the touch
// behavior. Callers may also specify a different mouse button number to
// interact with through [method@Gtk.GestureSingle.set_button], or react to any
// mouse button by setting it to 0. While the gesture is active, the button
// being currently pressed can be known through
// [method@Gtk.GestureSingle.get_current_button].
type GestureSingle interface {

	// Button returns the button number @gesture listens for.
	//
	// If this is 0, the gesture reacts to any button press.
	Button() uint
	// CurrentButton returns the button number currently interacting with
	// @gesture, or 0 if there is none.
	CurrentButton() uint
	// CurrentSequence returns the event sequence currently interacting with
	// @gesture.
	//
	// This is only meaningful if [method@Gtk.Gesture.is_active] returns true.
	CurrentSequence() *gdk.EventSequence
	// Exclusive gets whether a gesture is exclusive.
	//
	// For more information, see [method@Gtk.GestureSingle.set_exclusive].
	Exclusive() bool
	// TouchOnly returns true if the gesture is only triggered by touch events.
	TouchOnly() bool
	// SetButtonGestureSingle sets the button number @gesture listens to.
	//
	// If non-0, every button press from a different button number will be
	// ignored. Touch events implicitly match with button 1.
	SetButtonGestureSingle(button uint)
	// SetExclusiveGestureSingle sets whether @gesture is exclusive.
	//
	// An exclusive gesture will only handle pointer and "pointer emulated"
	// touch events, so at any given time, there is only one sequence able to
	// interact with those.
	SetExclusiveGestureSingle(exclusive bool)
	// SetTouchOnlyGestureSingle sets whether to handle only touch events.
	//
	// If @touch_only is true, @gesture will only handle events of type
	// GDK_TOUCH_BEGIN, GDK_TOUCH_UPDATE or GDK_TOUCH_END. If false, mouse
	// events will be handled too.
	SetTouchOnlyGestureSingle(touchOnly bool)
}

// gestureSingle implements the GestureSingle class.
type gestureSingle struct {
	Gesture
}

// WrapGestureSingle wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureSingle(obj *externglib.Object) GestureSingle {
	return gestureSingle{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureSingle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureSingle(obj), nil
}

func (g gestureSingle) Button() uint {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_button(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (g gestureSingle) CurrentButton() uint {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_current_button(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (g gestureSingle) CurrentSequence() *gdk.EventSequence {
	var _arg0 *C.GtkGestureSingle // out
	var _cret *C.GdkEventSequence // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_current_sequence(_arg0)

	var _eventSequence *gdk.EventSequence // out

	_eventSequence = gdk.WrapEventSequence(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_eventSequence, func(v *gdk.EventSequence) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _eventSequence
}

func (g gestureSingle) Exclusive() bool {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_exclusive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gestureSingle) TouchOnly() bool {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_touch_only(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gestureSingle) SetButtonGestureSingle(button uint) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.guint             // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
	_arg1 = (C.guint)(button)

	C.gtk_gesture_single_set_button(_arg0, _arg1)
}

func (g gestureSingle) SetExclusiveGestureSingle(exclusive bool) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
	if exclusive {
		_arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_exclusive(_arg0, _arg1)
}

func (g gestureSingle) SetTouchOnlyGestureSingle(touchOnly bool) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
	if touchOnly {
		_arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_touch_only(_arg0, _arg1)
}

// GestureStylus: `GtkGestureStylus` is a `GtkGesture` specific to stylus input.
//
// The provided signals just relay the basic information of the stylus events.
type GestureStylus interface {

	// Axis returns the current value for the requested @axis.
	//
	// This function must be called from the handler of one of the
	// [signal@Gtk.GestureStylus::down], [signal@Gtk.GestureStylus::motion],
	// [signal@Gtk.GestureStylus::up] or [signal@Gtk.GestureStylus::proximity]
	// signals.
	Axis(axis gdk.AxisUse) (float64, bool)
	// Backlog returns the accumulated backlog of tracking information.
	//
	// By default, GTK will limit rate of input events. On stylus input where
	// accuracy of strokes is paramount, this function returns the accumulated
	// coordinate/timing state before the emission of the current
	// [Gtk.GestureStylus::motion] signal.
	//
	// This function may only be called within a
	// [signal@Gtk.GestureStylus::motion] signal handler, the state given in
	// this signal and obtainable through [method@Gtk.GestureStylus.get_axis]
	// express the latest (most up-to-date) state in motion history.
	//
	// The @backlog is provided in chronological order.
	Backlog() ([]gdk.TimeCoord, bool)
	// DeviceTool returns the `GdkDeviceTool` currently driving input through
	// this gesture.
	//
	// This function must be called from the handler of one of the
	// [signal@Gtk.GestureStylus::down], [signal@Gtk.GestureStylus::motion],
	// [signal@Gtk.GestureStylus::up] or [signal@Gtk.GestureStylus::proximity]
	// signals.
	DeviceTool() gdk.DeviceTool
}

// gestureStylus implements the GestureStylus class.
type gestureStylus struct {
	GestureSingle
}

// WrapGestureStylus wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureStylus(obj *externglib.Object) GestureStylus {
	return gestureStylus{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureStylus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureStylus(obj), nil
}

// NewGestureStylus creates a new `GtkGestureStylus`.
func NewGestureStylus() GestureStylus {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_stylus_new()

	var _gestureStylus GestureStylus // out

	_gestureStylus = WrapGestureStylus(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureStylus
}

func (g gestureStylus) Axis(axis gdk.AxisUse) (float64, bool) {
	var _arg0 *C.GtkGestureStylus // out
	var _arg1 C.GdkAxisUse        // out
	var _arg2 C.double            // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))
	_arg1 = (C.GdkAxisUse)(axis)

	_cret = C.gtk_gesture_stylus_get_axis(_arg0, _arg1, &_arg2)

	var _value float64 // out
	var _ok bool       // out

	_value = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

func (g gestureStylus) Backlog() ([]gdk.TimeCoord, bool) {
	var _arg0 *C.GtkGestureStylus // out
	var _arg1 *C.GdkTimeCoord
	var _arg2 C.guint    // in
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_stylus_get_backlog(_arg0, &_arg1, &_arg2)

	var _backlog []gdk.TimeCoord
	var _ok bool // out

	_backlog = unsafe.Slice((*gdk.TimeCoord)(unsafe.Pointer(_arg1)), _arg2)
	runtime.SetFinalizer(&_backlog, func(v *[]gdk.TimeCoord) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	if _cret != 0 {
		_ok = true
	}

	return _backlog, _ok
}

func (g gestureStylus) DeviceTool() gdk.DeviceTool {
	var _arg0 *C.GtkGestureStylus // out
	var _cret *C.GdkDeviceTool    // in

	_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_stylus_get_device_tool(_arg0)

	var _deviceTool gdk.DeviceTool // out

	_deviceTool = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.DeviceTool)

	return _deviceTool
}

// GestureSwipe: `GtkGestureSwipe` is a `GtkGesture` for swipe gestures.
//
// After a press/move/.../move/release sequence happens, the
// [signal@Gtk.GestureSwipe::swipe] signal will be emitted, providing the
// velocity and directionality of the sequence at the time it was lifted.
//
// If the velocity is desired in intermediate points,
// [method@Gtk.GestureSwipe.get_velocity] can be called in a
// [signal@Gtk.Gesture::update] handler.
//
// All velocities are reported in pixels/sec units.
type GestureSwipe interface {

	// Velocity gets the current velocity.
	//
	// If the gesture is recognized, this function returns true and fills in
	// @velocity_x and @velocity_y with the recorded velocity, as per the last
	// events processed.
	Velocity() (velocityX float64, velocityY float64, ok bool)
}

// gestureSwipe implements the GestureSwipe class.
type gestureSwipe struct {
	GestureSingle
}

// WrapGestureSwipe wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureSwipe(obj *externglib.Object) GestureSwipe {
	return gestureSwipe{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureSwipe(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureSwipe(obj), nil
}

// NewGestureSwipe returns a newly created `GtkGesture` that recognizes swipes.
func NewGestureSwipe() GestureSwipe {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_swipe_new()

	var _gestureSwipe GestureSwipe // out

	_gestureSwipe = WrapGestureSwipe(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureSwipe
}

func (g gestureSwipe) Velocity() (velocityX float64, velocityY float64, ok bool) {
	var _arg0 *C.GtkGestureSwipe // out
	var _arg1 C.double           // in
	var _arg2 C.double           // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkGestureSwipe)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_swipe_get_velocity(_arg0, &_arg1, &_arg2)

	var _velocityX float64 // out
	var _velocityY float64 // out
	var _ok bool           // out

	_velocityX = (float64)(_arg1)
	_velocityY = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _velocityX, _velocityY, _ok
}

// GestureZoom: `GtkGestureZoom` is a `GtkGesture` for 2-finger pinch/zoom
// gestures.
//
// Whenever the distance between both tracked sequences changes, the
// [signal@Gtk.GestureZoom::scale-changed] signal is emitted to report the scale
// factor.
type GestureZoom interface {

	// ScaleDelta gets the scale delta.
	//
	// If @gesture is active, this function returns the zooming difference since
	// the gesture was recognized (hence the starting point is considered 1:1).
	// If @gesture is not active, 1 is returned.
	ScaleDelta() float64
}

// gestureZoom implements the GestureZoom class.
type gestureZoom struct {
	Gesture
}

// WrapGestureZoom wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureZoom(obj *externglib.Object) GestureZoom {
	return gestureZoom{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureZoom(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureZoom(obj), nil
}

// NewGestureZoom returns a newly created `GtkGesture` that recognizes
// pinch/zoom gestures.
func NewGestureZoom() GestureZoom {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_zoom_new()

	var _gestureZoom GestureZoom // out

	_gestureZoom = WrapGestureZoom(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureZoom
}

func (g gestureZoom) ScaleDelta() float64 {
	var _arg0 *C.GtkGestureZoom // out
	var _cret C.double          // in

	_arg0 = (*C.GtkGestureZoom)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_zoom_get_scale_delta(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Grid: `GtkGrid` is a container which arranges its child widgets in rows and
// columns.
//
// !An example GtkGrid (grid.png)
//
// It supports arbitrary positions and horizontal/vertical spans.
//
// Children are added using [method@Gtk.Grid.attach]. They can span multiple
// rows or columns. It is also possible to add a child next to an existing
// child, using [method@Gtk.Grid.attach_next_to]. To remove a child from the
// grid, use [method@Gtk.Grid.remove].
//
// The behaviour of `GtkGrid` when several children occupy the same grid cell is
// undefined.
//
//
// GtkGrid as GtkBuildable
//
// Every child in a `GtkGrid` has access to a custom [iface@Gtk.Buildable]
// element, called <layout>. It can by used to specify a position in the grid
// and optionally spans. All properties that can be used in the <layout>
// element are implemented by [class@Gtk.GridLayoutChild].
//
// It is implemented by `GtkWidget` using [class@Gtk.LayoutManager].
//
// To showcase it, here is a simple example:
//
// `xml <object class="GtkGrid" id="my_grid"> <child> <object class="GtkButton"
// id="button1"> <property name="label">Button 1</property> <layout> <property
// name="column">0</property> <property name="row">0</property> </layout>
// </object> </child> <child> <object class="GtkButton" id="button2"> <property
// name="label">Button 2</property> <layout> <property
// name="column">1</property> <property name="row">0</property> </layout>
// </object> </child> <child> <object class="GtkButton" id="button3"> <property
// name="label">Button 3</property> <layout> <property
// name="column">2</property> <property name="row">0</property> <property
// name="row-span">2</property> </layout> </object> </child> <child> <object
// class="GtkButton" id="button4"> <property name="label">Button 4</property>
// <layout> <property name="column">0</property> <property
// name="row">1</property> <property name="column-span">2</property> </layout>
// </object> </child> </object> `
//
// It organizes the first two buttons side-by-side in one cell each. The third
// button is in the last column but spans across two rows. This is defined by
// the row-span property. The last button is located in the second row and
// spans across two columns, which is defined by the column-span property.
//
//
// CSS nodes
//
// `GtkGrid` uses a single CSS node with name `grid`.
//
//
// Accessibility
//
// `GtkGrid` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Grid interface {
	Widget
	Orientable

	// AttachGrid adds a widget to the grid.
	//
	// The position of @child is determined by @column and @row. The number of
	// cells that @child will occupy is determined by @width and @height.
	AttachGrid(child Widget, column int, row int, width int, height int)
	// AttachNextToGrid adds a widget to the grid.
	//
	// The widget is placed next to @sibling, on the side determined by @side.
	// When @sibling is nil, the widget is placed in row (for left or right
	// placement) or column 0 (for top or bottom placement), at the end
	// indicated by @side.
	//
	// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
	// GTK_POS_LEFT yields a layout of [3][2][1].
	AttachNextToGrid(child Widget, sibling Widget, side PositionType, width int, height int)
	// BaselineRow returns which row defines the global baseline of @grid.
	BaselineRow() int
	// ChildAt gets the child of @grid whose area covers the grid cell at
	// @column, @row.
	ChildAt(column int, row int) Widget
	// ColumnHomogeneous returns whether all columns of @grid have the same
	// width.
	ColumnHomogeneous() bool
	// ColumnSpacing returns the amount of space between the columns of @grid.
	ColumnSpacing() uint
	// RowBaselinePosition returns the baseline position of @row.
	//
	// See [method@Gtk.Grid.set_row_baseline_position].
	RowBaselinePosition(row int) BaselinePosition
	// RowHomogeneous returns whether all rows of @grid have the same height.
	RowHomogeneous() bool
	// RowSpacing returns the amount of space between the rows of @grid.
	RowSpacing() uint
	// InsertColumnGrid inserts a column at the specified position.
	//
	// Children which are attached at or to the right of this position are moved
	// one column to the right. Children which span across this position are
	// grown to span the new column.
	InsertColumnGrid(position int)
	// InsertNextToGrid inserts a row or column at the specified position.
	//
	// The new row or column is placed next to @sibling, on the side determined
	// by @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted.
	// If @side is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
	InsertNextToGrid(sibling Widget, side PositionType)
	// InsertRowGrid inserts a row at the specified position.
	//
	// Children which are attached at or below this position are moved one row
	// down. Children which span across this position are grown to span the new
	// row.
	InsertRowGrid(position int)
	// QueryChildGrid queries the attach points and spans of @child inside the
	// given `GtkGrid`.
	QueryChildGrid(child Widget) (column int, row int, width int, height int)
	// RemoveGrid removes a child from @grid.
	//
	// The child must have been added with [method@Gtk.Grid.attach] or
	// [method@Gtk.Grid.attach_next_to].
	RemoveGrid(child Widget)
	// RemoveColumnGrid removes a column from the grid.
	//
	// Children that are placed in this column are removed, spanning children
	// that overlap this column have their width reduced by one, and children
	// after the column are moved to the left.
	RemoveColumnGrid(position int)
	// RemoveRowGrid removes a row from the grid.
	//
	// Children that are placed in this row are removed, spanning children that
	// overlap this row have their height reduced by one, and children below the
	// row are moved up.
	RemoveRowGrid(position int)
	// SetBaselineRowGrid sets which row defines the global baseline for the
	// entire grid.
	//
	// Each row in the grid can have its own local baseline, but only one of
	// those is global, meaning it will be the baseline in the parent of the
	// @grid.
	SetBaselineRowGrid(row int)
	// SetColumnHomogeneousGrid sets whether all columns of @grid will have the
	// same width.
	SetColumnHomogeneousGrid(homogeneous bool)
	// SetColumnSpacingGrid sets the amount of space between columns of @grid.
	SetColumnSpacingGrid(spacing uint)
	// SetRowBaselinePositionGrid sets how the baseline should be positioned on
	// @row of the grid, in case that row is assigned more space than is
	// requested.
	//
	// The default baseline position is GTK_BASELINE_POSITION_CENTER.
	SetRowBaselinePositionGrid(row int, pos BaselinePosition)
	// SetRowHomogeneousGrid sets whether all rows of @grid will have the same
	// height.
	SetRowHomogeneousGrid(homogeneous bool)
	// SetRowSpacingGrid sets the amount of space between rows of @grid.
	SetRowSpacingGrid(spacing uint)
}

// grid implements the Grid class.
type grid struct {
	Widget
}

// WrapGrid wraps a GObject to the right type. It is
// primarily used internally.
func WrapGrid(obj *externglib.Object) Grid {
	return grid{
		Widget: WrapWidget(obj),
	}
}

func marshalGrid(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGrid(obj), nil
}

// NewGrid creates a new grid widget.
func NewGrid() Grid {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_grid_new()

	var _grid Grid // out

	_grid = WrapGrid(externglib.Take(unsafe.Pointer(_cret)))

	return _grid
}

func (g grid) AttachGrid(child Widget, column int, row int, width int, height int) {
	var _arg0 *C.GtkGrid   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.int        // out
	var _arg5 C.int        // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.int)(column)
	_arg3 = (C.int)(row)
	_arg4 = (C.int)(width)
	_arg5 = (C.int)(height)

	C.gtk_grid_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (g grid) AttachNextToGrid(child Widget, sibling Widget, side PositionType, width int, height int) {
	var _arg0 *C.GtkGrid        // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 *C.GtkWidget      // out
	var _arg3 C.GtkPositionType // out
	var _arg4 C.int             // out
	var _arg5 C.int             // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
	_arg3 = (C.GtkPositionType)(side)
	_arg4 = (C.int)(width)
	_arg5 = (C.int)(height)

	C.gtk_grid_attach_next_to(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (g grid) BaselineRow() int {
	var _arg0 *C.GtkGrid // out
	var _cret C.int      // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_baseline_row(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (g grid) ChildAt(column int, row int) Widget {
	var _arg0 *C.GtkGrid   // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(column)
	_arg2 = (C.int)(row)

	_cret = C.gtk_grid_get_child_at(_arg0, _arg1, _arg2)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (g grid) ColumnHomogeneous() bool {
	var _arg0 *C.GtkGrid // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_column_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g grid) ColumnSpacing() uint {
	var _arg0 *C.GtkGrid // out
	var _cret C.guint    // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_column_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (g grid) RowBaselinePosition(row int) BaselinePosition {
	var _arg0 *C.GtkGrid            // out
	var _arg1 C.int                 // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(row)

	_cret = C.gtk_grid_get_row_baseline_position(_arg0, _arg1)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

func (g grid) RowHomogeneous() bool {
	var _arg0 *C.GtkGrid // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_row_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g grid) RowSpacing() uint {
	var _arg0 *C.GtkGrid // out
	var _cret C.guint    // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_row_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (g grid) InsertColumnGrid(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(position)

	C.gtk_grid_insert_column(_arg0, _arg1)
}

func (g grid) InsertNextToGrid(sibling Widget, side PositionType) {
	var _arg0 *C.GtkGrid        // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 C.GtkPositionType // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
	_arg2 = (C.GtkPositionType)(side)

	C.gtk_grid_insert_next_to(_arg0, _arg1, _arg2)
}

func (g grid) InsertRowGrid(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(position)

	C.gtk_grid_insert_row(_arg0, _arg1)
}

func (g grid) QueryChildGrid(child Widget) (column int, row int, width int, height int) {
	var _arg0 *C.GtkGrid   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.int        // in
	var _arg3 C.int        // in
	var _arg4 C.int        // in
	var _arg5 C.int        // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_grid_query_child(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

	var _column int // out
	var _row int    // out
	var _width int  // out
	var _height int // out

	_column = (int)(_arg2)
	_row = (int)(_arg3)
	_width = (int)(_arg4)
	_height = (int)(_arg5)

	return _column, _row, _width, _height
}

func (g grid) RemoveGrid(child Widget) {
	var _arg0 *C.GtkGrid   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_grid_remove(_arg0, _arg1)
}

func (g grid) RemoveColumnGrid(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(position)

	C.gtk_grid_remove_column(_arg0, _arg1)
}

func (g grid) RemoveRowGrid(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(position)

	C.gtk_grid_remove_row(_arg0, _arg1)
}

func (g grid) SetBaselineRowGrid(row int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(row)

	C.gtk_grid_set_baseline_row(_arg0, _arg1)
}

func (g grid) SetColumnHomogeneousGrid(homogeneous bool) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_set_column_homogeneous(_arg0, _arg1)
}

func (g grid) SetColumnSpacingGrid(spacing uint) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_grid_set_column_spacing(_arg0, _arg1)
}

func (g grid) SetRowBaselinePositionGrid(row int, pos BaselinePosition) {
	var _arg0 *C.GtkGrid            // out
	var _arg1 C.int                 // out
	var _arg2 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(row)
	_arg2 = (C.GtkBaselinePosition)(pos)

	C.gtk_grid_set_row_baseline_position(_arg0, _arg1, _arg2)
}

func (g grid) SetRowHomogeneousGrid(homogeneous bool) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_set_row_homogeneous(_arg0, _arg1)
}

func (g grid) SetRowSpacingGrid(spacing uint) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_grid_set_row_spacing(_arg0, _arg1)
}

func (s grid) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s grid) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s grid) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s grid) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s grid) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s grid) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s grid) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b grid) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o grid) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o grid) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// GridLayout: `GtkGridLayout` is a layout manager which arranges child widgets
// in rows and columns.
//
// Children have an "attach point" defined by the horizontal and vertical index
// of the cell they occupy; children can span multiple rows or columns. The
// layout properties for setting the attach points and spans are set using the
// [class@Gtk.GridLayoutChild] associated to each child widget.
//
// The behaviour of `GtkGridLayout` when several children occupy the same grid
// cell is undefined.
//
// `GtkGridLayout` can be used like a `GtkBoxLayout` if all children are
// attached to the same row or column; however, if you only ever need a single
// row or column, you should consider using `GtkBoxLayout`.
type GridLayout interface {

	// BaselineRow retrieves the row set with
	// gtk_grid_layout_set_baseline_row().
	BaselineRow() int
	// ColumnHomogeneous checks whether all columns of @grid should have the
	// same width.
	ColumnHomogeneous() bool
	// ColumnSpacing retrieves the spacing set with
	// gtk_grid_layout_set_column_spacing().
	ColumnSpacing() uint
	// RowBaselinePosition returns the baseline position of @row.
	//
	// If no value has been set with
	// [method@Gtk.GridLayout.set_row_baseline_position], the default value of
	// GTK_BASELINE_POSITION_CENTER is returned.
	RowBaselinePosition(row int) BaselinePosition
	// RowHomogeneous checks whether all rows of @grid should have the same
	// height.
	RowHomogeneous() bool
	// RowSpacing retrieves the spacing set with
	// gtk_grid_layout_set_row_spacing().
	RowSpacing() uint
	// SetBaselineRowGridLayout sets which row defines the global baseline for
	// the entire grid.
	//
	// Each row in the grid can have its own local baseline, but only one of
	// those is global, meaning it will be the baseline in the parent of the
	// @grid.
	SetBaselineRowGridLayout(row int)
	// SetColumnHomogeneousGridLayout sets whether all columns of @grid should
	// have the same width.
	SetColumnHomogeneousGridLayout(homogeneous bool)
	// SetColumnSpacingGridLayout sets the amount of space to insert between
	// consecutive columns.
	SetColumnSpacingGridLayout(spacing uint)
	// SetRowBaselinePositionGridLayout sets how the baseline should be
	// positioned on @row of the grid, in case that row is assigned more space
	// than is requested.
	SetRowBaselinePositionGridLayout(row int, pos BaselinePosition)
	// SetRowHomogeneousGridLayout sets whether all rows of @grid should have
	// the same height.
	SetRowHomogeneousGridLayout(homogeneous bool)
	// SetRowSpacingGridLayout sets the amount of space to insert between
	// consecutive rows.
	SetRowSpacingGridLayout(spacing uint)
}

// gridLayout implements the GridLayout class.
type gridLayout struct {
	LayoutManager
}

// WrapGridLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapGridLayout(obj *externglib.Object) GridLayout {
	return gridLayout{
		LayoutManager: WrapLayoutManager(obj),
	}
}

func marshalGridLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGridLayout(obj), nil
}

// NewGridLayout creates a new `GtkGridLayout`.
func NewGridLayout() GridLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_grid_layout_new()

	var _gridLayout GridLayout // out

	_gridLayout = WrapGridLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gridLayout
}

func (g gridLayout) BaselineRow() int {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.int            // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_layout_get_baseline_row(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (g gridLayout) ColumnHomogeneous() bool {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_layout_get_column_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gridLayout) ColumnSpacing() uint {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_layout_get_column_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (g gridLayout) RowBaselinePosition(row int) BaselinePosition {
	var _arg0 *C.GtkGridLayout      // out
	var _arg1 C.int                 // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(row)

	_cret = C.gtk_grid_layout_get_row_baseline_position(_arg0, _arg1)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

func (g gridLayout) RowHomogeneous() bool {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_layout_get_row_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gridLayout) RowSpacing() uint {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_layout_get_row_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (g gridLayout) SetBaselineRowGridLayout(row int) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.int            // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(row)

	C.gtk_grid_layout_set_baseline_row(_arg0, _arg1)
}

func (g gridLayout) SetColumnHomogeneousGridLayout(homogeneous bool) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_layout_set_column_homogeneous(_arg0, _arg1)
}

func (g gridLayout) SetColumnSpacingGridLayout(spacing uint) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_grid_layout_set_column_spacing(_arg0, _arg1)
}

func (g gridLayout) SetRowBaselinePositionGridLayout(row int, pos BaselinePosition) {
	var _arg0 *C.GtkGridLayout      // out
	var _arg1 C.int                 // out
	var _arg2 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(row)
	_arg2 = (C.GtkBaselinePosition)(pos)

	C.gtk_grid_layout_set_row_baseline_position(_arg0, _arg1, _arg2)
}

func (g gridLayout) SetRowHomogeneousGridLayout(homogeneous bool) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_layout_set_row_homogeneous(_arg0, _arg1)
}

func (g gridLayout) SetRowSpacingGridLayout(spacing uint) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_grid_layout_set_row_spacing(_arg0, _arg1)
}

// GridLayoutChild: `GtkLayoutChild` subclass for children in a `GtkGridLayout`.
type GridLayoutChild interface {

	// Column retrieves the column number to which @child attaches its left
	// side.
	Column() int
	// ColumnSpan retrieves the number of columns that @child spans to.
	ColumnSpan() int
	// Row retrieves the row number to which @child attaches its top side.
	Row() int
	// RowSpan retrieves the number of rows that @child spans to.
	RowSpan() int
	// SetColumnGridLayoutChild sets the column number to attach the left side
	// of @child.
	SetColumnGridLayoutChild(column int)
	// SetColumnSpanGridLayoutChild sets the number of columns @child spans to.
	SetColumnSpanGridLayoutChild(span int)
	// SetRowGridLayoutChild sets the row to place @child in.
	SetRowGridLayoutChild(row int)
	// SetRowSpanGridLayoutChild sets the number of rows @child spans to.
	SetRowSpanGridLayoutChild(span int)
}

// gridLayoutChild implements the GridLayoutChild class.
type gridLayoutChild struct {
	LayoutChild
}

// WrapGridLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapGridLayoutChild(obj *externglib.Object) GridLayoutChild {
	return gridLayoutChild{
		LayoutChild: WrapLayoutChild(obj),
	}
}

func marshalGridLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGridLayoutChild(obj), nil
}

func (c gridLayoutChild) Column() int {
	var _arg0 *C.GtkGridLayoutChild // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_grid_layout_child_get_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c gridLayoutChild) ColumnSpan() int {
	var _arg0 *C.GtkGridLayoutChild // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_grid_layout_child_get_column_span(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c gridLayoutChild) Row() int {
	var _arg0 *C.GtkGridLayoutChild // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_grid_layout_child_get_row(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c gridLayoutChild) RowSpan() int {
	var _arg0 *C.GtkGridLayoutChild // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_grid_layout_child_get_row_span(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c gridLayoutChild) SetColumnGridLayoutChild(column int) {
	var _arg0 *C.GtkGridLayoutChild // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(column)

	C.gtk_grid_layout_child_set_column(_arg0, _arg1)
}

func (c gridLayoutChild) SetColumnSpanGridLayoutChild(span int) {
	var _arg0 *C.GtkGridLayoutChild // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(span)

	C.gtk_grid_layout_child_set_column_span(_arg0, _arg1)
}

func (c gridLayoutChild) SetRowGridLayoutChild(row int) {
	var _arg0 *C.GtkGridLayoutChild // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(row)

	C.gtk_grid_layout_child_set_row(_arg0, _arg1)
}

func (c gridLayoutChild) SetRowSpanGridLayoutChild(span int) {
	var _arg0 *C.GtkGridLayoutChild // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(span)

	C.gtk_grid_layout_child_set_row_span(_arg0, _arg1)
}

// GridView: `GtkGridView` presents a large dynamic grid of items.
//
// `GtkGridView` uses its factory to generate one child widget for each visible
// item and shows them in a grid. The orientation of the grid view determines if
// the grid reflows vertically or horizontally.
//
// `GtkGridView` allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on _rubberband selection_, using
// [property@Gtk.GridView:enable-rubberband].
//
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
//
//
// CSS nodes
//
// ` gridview  child   child    [rubberband] `
//
// `GtkGridView` uses a single CSS node with name gridview. Each child uses a
// single CSS node with name child. For rubberband selection, a subnode with
// name rubberband is used.
//
//
// Accessibility
//
// `GtkGridView` uses the GTK_ACCESSIBLE_ROLE_GRID role, and the items use the
// GTK_ACCESSIBLE_ROLE_GRID_CELL role.
type GridView interface {
	ListBase

	// EnableRubberband returns whether rows can be selected by dragging with
	// the mouse.
	EnableRubberband() bool
	// Factory gets the factory that's currently used to populate list items.
	Factory() ListItemFactory
	// MaxColumns gets the maximum number of columns that the grid will use.
	MaxColumns() uint
	// MinColumns gets the minimum number of columns that the grid will use.
	MinColumns() uint
	// Model gets the model that's currently used to read the items displayed.
	Model() SelectionModel
	// SingleClickActivate returns whether items will be activated on single
	// click and selected on hover.
	SingleClickActivate() bool
	// SetEnableRubberbandGridView sets whether selections can be changed by
	// dragging with the mouse.
	SetEnableRubberbandGridView(enableRubberband bool)
	// SetFactoryGridView sets the `GtkListItemFactory` to use for populating
	// list items.
	SetFactoryGridView(factory ListItemFactory)
	// SetMaxColumnsGridView sets the maximum number of columns to use.
	//
	// This number must be at least 1.
	//
	// If @max_columns is smaller than the minimum set via
	// [method@Gtk.GridView.set_min_columns], that value is used instead.
	SetMaxColumnsGridView(maxColumns uint)
	// SetMinColumnsGridView sets the minimum number of columns to use.
	//
	// This number must be at least 1.
	//
	// If @min_columns is smaller than the minimum set via
	// [method@Gtk.GridView.set_max_columns], that value is ignored.
	SetMinColumnsGridView(minColumns uint)
	// SetModelGridView sets the imodel to use.
	//
	// This must be a [iface@Gtk.SelectionModel].
	SetModelGridView(model SelectionModel)
	// SetSingleClickActivateGridView sets whether items should be activated on
	// single click and selected on hover.
	SetSingleClickActivateGridView(singleClickActivate bool)
}

// gridView implements the GridView class.
type gridView struct {
	ListBase
}

// WrapGridView wraps a GObject to the right type. It is
// primarily used internally.
func WrapGridView(obj *externglib.Object) GridView {
	return gridView{
		ListBase: WrapListBase(obj),
	}
}

func marshalGridView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGridView(obj), nil
}

// NewGridView creates a new `GtkGridView` that uses the given @factory for
// mapping items to widgets.
//
// The function takes ownership of the arguments, so you can write code like `c
// grid_view = gtk_grid_view_new (create_model (),
// gtk_builder_list_item_factory_new_from_resource ("/resource.ui")); `
func NewGridView(model SelectionModel, factory ListItemFactory) GridView {
	var _arg1 *C.GtkSelectionModel  // out
	var _arg2 *C.GtkListItemFactory // out
	var _cret *C.GtkWidget          // in

	_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

	_cret = C.gtk_grid_view_new(_arg1, _arg2)

	var _gridView GridView // out

	_gridView = WrapGridView(externglib.Take(unsafe.Pointer(_cret)))

	return _gridView
}

func (s gridView) EnableRubberband() bool {
	var _arg0 *C.GtkGridView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_grid_view_get_enable_rubberband(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s gridView) Factory() ListItemFactory {
	var _arg0 *C.GtkGridView        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_grid_view_get_factory(_arg0)

	var _listItemFactory ListItemFactory // out

	_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

	return _listItemFactory
}

func (s gridView) MaxColumns() uint {
	var _arg0 *C.GtkGridView // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_grid_view_get_max_columns(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s gridView) MinColumns() uint {
	var _arg0 *C.GtkGridView // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_grid_view_get_min_columns(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s gridView) Model() SelectionModel {
	var _arg0 *C.GtkGridView       // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_grid_view_get_model(_arg0)

	var _selectionModel SelectionModel // out

	_selectionModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SelectionModel)

	return _selectionModel
}

func (s gridView) SingleClickActivate() bool {
	var _arg0 *C.GtkGridView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_grid_view_get_single_click_activate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s gridView) SetEnableRubberbandGridView(enableRubberband bool) {
	var _arg0 *C.GtkGridView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
	if enableRubberband {
		_arg1 = C.TRUE
	}

	C.gtk_grid_view_set_enable_rubberband(_arg0, _arg1)
}

func (s gridView) SetFactoryGridView(factory ListItemFactory) {
	var _arg0 *C.GtkGridView        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

	C.gtk_grid_view_set_factory(_arg0, _arg1)
}

func (s gridView) SetMaxColumnsGridView(maxColumns uint) {
	var _arg0 *C.GtkGridView // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(maxColumns)

	C.gtk_grid_view_set_max_columns(_arg0, _arg1)
}

func (s gridView) SetMinColumnsGridView(minColumns uint) {
	var _arg0 *C.GtkGridView // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(minColumns)

	C.gtk_grid_view_set_min_columns(_arg0, _arg1)
}

func (s gridView) SetModelGridView(model SelectionModel) {
	var _arg0 *C.GtkGridView       // out
	var _arg1 *C.GtkSelectionModel // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

	C.gtk_grid_view_set_model(_arg0, _arg1)
}

func (s gridView) SetSingleClickActivateGridView(singleClickActivate bool) {
	var _arg0 *C.GtkGridView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
	if singleClickActivate {
		_arg1 = C.TRUE
	}

	C.gtk_grid_view_set_single_click_activate(_arg0, _arg1)
}

func (s gridView) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s gridView) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s gridView) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s gridView) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s gridView) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s gridView) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s gridView) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b gridView) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o gridView) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o gridView) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

func (s gridView) Border() (Border, bool) {
	return WrapScrollable(gextras.InternObject(s)).Border()
}

func (s gridView) HAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).HAdjustment()
}

func (s gridView) HScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).HScrollPolicy()
}

func (s gridView) VAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).VAdjustment()
}

func (s gridView) VScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).VScrollPolicy()
}

func (s gridView) SetHAdjustment(hadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetHAdjustment(hadjustment)
}

func (s gridView) SetHScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetHScrollPolicy(policy)
}

func (s gridView) SetVAdjustment(vadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetVAdjustment(vadjustment)
}

func (s gridView) SetVScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetVScrollPolicy(policy)
}

// HeaderBar: `GtkHeaderBar` is a widget for creating custom title bars for
// windows.
//
// !An example GtkHeaderBar (headerbar.png)
//
// `GtkHeaderBar` is similar to a horizontal `GtkCenterBox`. It allows children
// to be placed at the start or the end. In addition, it allows the window title
// to be displayed. The title will be centered with respect to the width of the
// box, even if the children at either side take up different amounts of space.
//
// `GtkHeaderBar` can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
//
// For these reasons, `GtkHeaderBar` is the natural choice for use as the custom
// titlebar widget of a `GtkWindow (see [method@Gtk.Window.set_titlebar]), as it
// gives features typical of titlebars while allowing the addition of child
// widgets.
//
//
// GtkHeaderBar as GtkBuildable
//
// The `GtkHeaderBar` implementation of the `GtkBuildable` interface supports
// adding children at the start or end sides by specifying start or end as
// the type attribute of a <child> element, or setting the title widget by
// specifying title value.
//
// By default the `GtkHeaderBar` uses a `GtkLabel` displaying the title of the
// window it is contained in as the title widget, equivalent to the following UI
// definition:
//
// `xml <object class="GtkHeaderBar"> <property name="title-widget"> <object
// class="GtkLabel"> <property name="label" translatable="yes">Label</property>
// <property name="single-line-mode">True</property> <property
// name="ellipsize">end</property> <property name="width-chars">5</property>
// <style> <class name="title"/> </style> </object> </property> </object> `
//
//
// CSS nodes
//
// ` headerbar  windowhandle  box  box.start  
// windowcontrols.start   [other children]  [Title Widget]  box.end
//  [other children]  windowcontrols.end `
//
// A `GtkHeaderBar`'s CSS node is called `headerbar`. It contains a
// `windowhandle` subnode, which contains a `box` subnode, which contains two
// `box` subnodes at the start and end of the header bar, as well as a center
// node that represents the title.
//
// Each of the boxes contains a `windowcontrols` subnode, see
// [class@Gtk.WindowControls] for details, as well as other children.
//
//
// Accessibility
//
// `GtkHeaderBar` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type HeaderBar interface {
	Widget

	// DecorationLayout gets the decoration layout of the `GtkHeaderBar`.
	DecorationLayout() string
	// ShowTitleButtons returns whether this header bar shows the standard
	// window title buttons.
	ShowTitleButtons() bool
	// TitleWidget retrieves the title widget of the header.
	//
	// See [method@Gtk.HeaderBar.set_title_widget].
	TitleWidget() Widget
	// PackEndHeaderBar adds @child to @bar, packed with reference to the end of
	// the @bar.
	PackEndHeaderBar(child Widget)
	// PackStartHeaderBar adds @child to @bar, packed with reference to the
	// start of the @bar.
	PackStartHeaderBar(child Widget)
	// RemoveHeaderBar removes a child from the `GtkHeaderBar`.
	//
	// The child must have been added with [method@Gtk.HeaderBar.pack_start],
	// [method@Gtk.HeaderBar.pack_end] or
	// [method@Gtk.HeaderBar.set_title_widget].
	RemoveHeaderBar(child Widget)
	// SetDecorationLayoutHeaderBar sets the decoration layout for this header
	// bar.
	//
	// This property overrides the [property@Gtk.Settings:gtk-decoration-layout]
	// setting.
	//
	// There can be valid reasons for overriding the setting, such as a header
	// bar design that does not allow for buttons to take room on the right, or
	// only offers room for a single close button. Split header bars are another
	// example for overriding the setting.
	//
	// The format of the string is button names, separated by commas. A colon
	// separates the buttons that should appear on the left from those on the
	// right. Recognized button names are minimize, maximize, close and icon
	// (the window icon).
	//
	// For example, icon:minimize,maximize,close specifies a icon on the left,
	// and minimize, maximize and close buttons on the right.
	SetDecorationLayoutHeaderBar(layout string)
	// SetShowTitleButtonsHeaderBar sets whether this header bar shows the
	// standard window title buttons.
	SetShowTitleButtonsHeaderBar(setting bool)
	// SetTitleWidgetHeaderBar sets the title for the `GtkHeaderBar`.
	//
	// When set to nil, the headerbar will display the title of the window it is
	// contained in.
	//
	// The title should help a user identify the current view. To achieve the
	// same style as the builtin title, use the title style class.
	//
	// You should set the title widget to nil, for the window title label to be
	// visible again.
	SetTitleWidgetHeaderBar(titleWidget Widget)
}

// headerBar implements the HeaderBar class.
type headerBar struct {
	Widget
}

// WrapHeaderBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapHeaderBar(obj *externglib.Object) HeaderBar {
	return headerBar{
		Widget: WrapWidget(obj),
	}
}

func marshalHeaderBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHeaderBar(obj), nil
}

// NewHeaderBar creates a new `GtkHeaderBar` widget.
func NewHeaderBar() HeaderBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_header_bar_new()

	var _headerBar HeaderBar // out

	_headerBar = WrapHeaderBar(externglib.Take(unsafe.Pointer(_cret)))

	return _headerBar
}

func (b headerBar) DecorationLayout() string {
	var _arg0 *C.GtkHeaderBar // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_header_bar_get_decoration_layout(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (b headerBar) ShowTitleButtons() bool {
	var _arg0 *C.GtkHeaderBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_header_bar_get_show_title_buttons(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b headerBar) TitleWidget() Widget {
	var _arg0 *C.GtkHeaderBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_header_bar_get_title_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (b headerBar) PackEndHeaderBar(child Widget) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_pack_end(_arg0, _arg1)
}

func (b headerBar) PackStartHeaderBar(child Widget) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_pack_start(_arg0, _arg1)
}

func (b headerBar) RemoveHeaderBar(child Widget) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_remove(_arg0, _arg1)
}

func (b headerBar) SetDecorationLayoutHeaderBar(layout string) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(layout))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_header_bar_set_decoration_layout(_arg0, _arg1)
}

func (b headerBar) SetShowTitleButtonsHeaderBar(setting bool) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_header_bar_set_show_title_buttons(_arg0, _arg1)
}

func (b headerBar) SetTitleWidgetHeaderBar(titleWidget Widget) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(titleWidget.Native()))

	C.gtk_header_bar_set_title_widget(_arg0, _arg1)
}

func (s headerBar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s headerBar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s headerBar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s headerBar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s headerBar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s headerBar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s headerBar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b headerBar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// IMContext: `GtkIMContext` defines the interface for GTK input methods.
//
// `GtkIMContext` is used by GTK text input widgets like `GtkText` to map from
// key events to Unicode character strings.
//
// By default, GTK uses a platform-dependent default input method. On Windows,
// the default implementation is IME-based and on Wayland, it is using the
// Wayland text protocol. The choice can be overridden programmatically via the
// [property@Gtk.Settings:gtk-im-module] setting. Users may set the
// `GTK_IM_MODULE` environment variable to override the default.
//
// Text widgets have a :im-module property (e.g.
// [property@Gtk.TextView:im-module]) that may also be used to set input methods
// for specific widget instances. For instance, a certain entry widget might be
// expected to contain certain characters which would be easier to input with a
// specific input method.
//
// An input method may consume multiple key events in sequence before finally
// outputting the composed result. This is called *preediting*, and an input
// method may provide feedback about this process by displaying the intermediate
// composition states as preedit text.
//
// For instance, the built-in GTK input method `GtkIMContextSimple` implements
// the input of arbitrary Unicode code points by holding down the
// <kbd>Control</kbd> and <kbd>Shift</kbd> keys and then typing <kbd>U</kbd>
// followed by the hexadecimal digits of the code point. When releasing the
// <kbd>Control</kbd> and <kbd>Shift</kbd> keys, preediting ends and the
// character is inserted as text. For example,
//
//    Ctrl+Shift+u 2 0 A C
//
// results in the  sign.
//
// Additional input methods can be made available for use by GTK widgets as
// loadable modules. An input method module is a small shared library which
// provides a `GIOExtension` for the extension point named "gtk-im-module".
type IMContext interface {

	// DeleteSurroundingIMContext asks the widget that the input context is
	// attached to delete characters around the cursor position by emitting the
	// GtkIMContext::delete_surrounding signal.
	//
	// Note that @offset and @n_chars are in characters not in bytes which
	// differs from the usage other places in IMContext.
	//
	// In order to use this function, you should first call
	// gtk_im_context_get_surrounding() to get the current context, and call
	// this function immediately afterwards to make sure that you know what you
	// are deleting. You should also account for the fact that even if the
	// signal was handled, the input context might not have deleted all the
	// characters that were requested to be deleted.
	//
	// This function is used by an input method that wants to make subsitutions
	// in the existing text in response to new input. It is not useful for
	// applications.
	DeleteSurroundingIMContext(offset int, nChars int) bool
	// FilterKeyIMContext: allow an input method to forward key press and
	// release events to another input methodm without necessarily having a
	// `GdkEvent` available.
	FilterKeyIMContext(press bool, surface gdk.Surface, device gdk.Device, time uint32, keycode uint, state gdk.ModifierType, group int) bool
	// FilterKeypressIMContext: allow an input method to internally handle key
	// press and release events.
	//
	// If this function returns true, then no further processing should be done
	// for this key event.
	FilterKeypressIMContext(event gdk.Event) bool
	// FocusInIMContext: notify the input method that the widget to which this
	// input context corresponds has gained focus.
	//
	// The input method may, for example, change the displayed feedback to
	// reflect this change.
	FocusInIMContext()
	// FocusOutIMContext: notify the input method that the widget to which this
	// input context corresponds has lost focus.
	//
	// The input method may, for example, change the displayed feedback or reset
	// the contexts state to reflect this change.
	FocusOutIMContext()
	// PreeditString: retrieve the current preedit string for the input context,
	// and a list of attributes to apply to the string.
	//
	// This string should be displayed inserted at the insertion point.
	PreeditString() (string, *pango.AttrList, int)
	// Surrounding retrieves context around the insertion point.
	//
	// Input methods typically want context in order to constrain input text
	// based on existing text; this is important for languages such as Thai
	// where only some sequences of characters are allowed.
	//
	// This function is implemented by emitting the
	// [signal@Gtk.IMContext::retrieve-surrounding] signal on the input method;
	// in response to this signal, a widget should provide as much context as is
	// available, up to an entire paragraph, by calling
	// [method@Gtk.IMContext.set_surrounding].
	//
	// Note that there is no obligation for a widget to respond to the
	// `::retrieve-surrounding` signal, so input methods must be prepared to
	// function without context.
	Surrounding() (string, int, bool)
	// SurroundingWithSelection retrieves context around the insertion point.
	//
	// Input methods typically want context in order to constrain input text
	// based on existing text; this is important for languages such as Thai
	// where only some sequences of characters are allowed.
	//
	// This function is implemented by emitting the
	// [signal@Gtk.IMContext::retrieve-surrounding] signal on the input method;
	// in response to this signal, a widget should provide as much context as is
	// available, up to an entire paragraph, by calling
	// [method@Gtk.IMContext.set_surrounding_with_selection].
	//
	// Note that there is no obligation for a widget to respond to the
	// `::retrieve-surrounding` signal, so input methods must be prepared to
	// function without context.
	SurroundingWithSelection() (text string, cursorIndex int, anchorIndex int, ok bool)
	// ResetIMContext: notify the input method that a change such as a change in
	// cursor position has been made.
	//
	// This will typically cause the input method to clear the preedit state.
	ResetIMContext()
	// SetClientWidgetIMContext: set the client widget for the input context.
	//
	// This is the `GtkWidget` holding the input focus. This widget is used in
	// order to correctly position status windows, and may also be used for
	// purposes internal to the input method.
	SetClientWidgetIMContext(widget Widget)
	// SetCursorLocationIMContext: notify the input method that a change in
	// cursor position has been made.
	//
	// The location is relative to the client window.
	SetCursorLocationIMContext(area *gdk.Rectangle)
	// SetSurroundingIMContext sets surrounding context around the insertion
	// point and preedit string.
	//
	// This function is expected to be called in response to the
	// [signal@Gtk.IMContext::retrieve-surrounding] signal, and will likely have
	// no effect if called at other times.
	SetSurroundingIMContext(text string, len int, cursorIndex int)
	// SetSurroundingWithSelectionIMContext sets surrounding context around the
	// insertion point and preedit string. This function is expected to be
	// called in response to the GtkIMContext::retrieve_surrounding signal, and
	// will likely have no effect if called at other times.
	SetSurroundingWithSelectionIMContext(text string, len int, cursorIndex int, anchorIndex int)
	// SetUsePreeditIMContext sets whether the IM context should use the preedit
	// string to display feedback.
	//
	// If @use_preedit is false (default is true), then the IM context may use
	// some other method to display feedback, such as displaying it in a child
	// of the root window.
	SetUsePreeditIMContext(usePreedit bool)
}

// imContext implements the IMContext class.
type imContext struct {
	gextras.Objector
}

// WrapIMContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMContext(obj *externglib.Object) IMContext {
	return imContext{
		Objector: obj,
	}
}

func marshalIMContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMContext(obj), nil
}

func (c imContext) DeleteSurroundingIMContext(offset int, nChars int) bool {
	var _arg0 *C.GtkIMContext // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(offset)
	_arg2 = (C.int)(nChars)

	_cret = C.gtk_im_context_delete_surrounding(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c imContext) FilterKeyIMContext(press bool, surface gdk.Surface, device gdk.Device, time uint32, keycode uint, state gdk.ModifierType, group int) bool {
	var _arg0 *C.GtkIMContext   // out
	var _arg1 C.gboolean        // out
	var _arg2 *C.GdkSurface     // out
	var _arg3 *C.GdkDevice      // out
	var _arg4 C.guint32         // out
	var _arg5 C.guint           // out
	var _arg6 C.GdkModifierType // out
	var _arg7 C.int             // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	if press {
		_arg1 = C.TRUE
	}
	_arg2 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))
	_arg3 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	_arg4 = (C.guint32)(time)
	_arg5 = (C.guint)(keycode)
	_arg6 = (C.GdkModifierType)(state)
	_arg7 = (C.int)(group)

	_cret = C.gtk_im_context_filter_key(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c imContext) FilterKeypressIMContext(event gdk.Event) bool {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GdkEvent     // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_im_context_filter_keypress(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c imContext) FocusInIMContext() {
	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	C.gtk_im_context_focus_in(_arg0)
}

func (c imContext) FocusOutIMContext() {
	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	C.gtk_im_context_focus_out(_arg0)
}

func (c imContext) PreeditString() (string, *pango.AttrList, int) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // in
	var _attrs *pango.AttrList
	var _arg3 C.int // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	C.gtk_im_context_get_preedit_string(_arg0, &_arg1, (**C.PangoAttrList)(unsafe.Pointer(&_attrs)), &_arg3)

	var _str string // out

	var _cursorPos int // out

	_str = C.GoString(_arg1)
	defer C.free(unsafe.Pointer(_arg1))

	_cursorPos = (int)(_arg3)

	return _str, _attrs, _cursorPos
}

func (c imContext) Surrounding() (string, int, bool) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // in
	var _arg2 C.int           // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_im_context_get_surrounding(_arg0, &_arg1, &_arg2)

	var _text string     // out
	var _cursorIndex int // out
	var _ok bool         // out

	_text = C.GoString(_arg1)
	defer C.free(unsafe.Pointer(_arg1))
	_cursorIndex = (int)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _text, _cursorIndex, _ok
}

func (c imContext) SurroundingWithSelection() (text string, cursorIndex int, anchorIndex int, ok bool) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // in
	var _arg2 C.int           // in
	var _arg3 C.int           // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_im_context_get_surrounding_with_selection(_arg0, &_arg1, &_arg2, &_arg3)

	var _text string     // out
	var _cursorIndex int // out
	var _anchorIndex int // out
	var _ok bool         // out

	_text = C.GoString(_arg1)
	defer C.free(unsafe.Pointer(_arg1))
	_cursorIndex = (int)(_arg2)
	_anchorIndex = (int)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _text, _cursorIndex, _anchorIndex, _ok
}

func (c imContext) ResetIMContext() {
	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	C.gtk_im_context_reset(_arg0)
}

func (c imContext) SetClientWidgetIMContext(widget Widget) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_im_context_set_client_widget(_arg0, _arg1)
}

func (c imContext) SetCursorLocationIMContext(area *gdk.Rectangle) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(area.Native()))

	C.gtk_im_context_set_cursor_location(_arg0, _arg1)
}

func (c imContext) SetSurroundingIMContext(text string, len int, cursorIndex int) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // out
	var _arg2 C.int           // out
	var _arg3 C.int           // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(len)
	_arg3 = (C.int)(cursorIndex)

	C.gtk_im_context_set_surrounding(_arg0, _arg1, _arg2, _arg3)
}

func (c imContext) SetSurroundingWithSelectionIMContext(text string, len int, cursorIndex int, anchorIndex int) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // out
	var _arg2 C.int           // out
	var _arg3 C.int           // out
	var _arg4 C.int           // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(len)
	_arg3 = (C.int)(cursorIndex)
	_arg4 = (C.int)(anchorIndex)

	C.gtk_im_context_set_surrounding_with_selection(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (c imContext) SetUsePreeditIMContext(usePreedit bool) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	if usePreedit {
		_arg1 = C.TRUE
	}

	C.gtk_im_context_set_use_preedit(_arg0, _arg1)
}

// IMContextSimple: `GtkIMContextSimple` is an input method supporting
// table-based input methods.
//
// `GtkIMContextSimple` has a built-in table of compose sequences that is
// derived from the X11 Compose files.
//
// `GtkIMContextSimple` reads additional compose sequences from the first of the
// following files that is found: ~/.config/gtk-4.0/Compose, ~/.XCompose,
// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
// Compose file). The syntax of these files is described in the Compose(5)
// manual page.
//
//
// Unicode characters
//
// `GtkIMContextSimple` also supports numeric entry of Unicode characters by
// typing <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>u</kbd>, followed by a
// hexadecimal Unicode codepoint.
//
// For example,
//
//    Ctrl-Shift-u 1 2 3 Enter
//
// yields U+0123 LATIN SMALL LETTER G WITH CEDILLA, i.e. .
type IMContextSimple interface {

	// AddComposeFileIMContextSimple adds an additional table from the X11
	// compose file.
	AddComposeFileIMContextSimple(composeFile string)
}

// imContextSimple implements the IMContextSimple class.
type imContextSimple struct {
	IMContext
}

// WrapIMContextSimple wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMContextSimple(obj *externglib.Object) IMContextSimple {
	return imContextSimple{
		IMContext: WrapIMContext(obj),
	}
}

func marshalIMContextSimple(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMContextSimple(obj), nil
}

// NewIMContextSimple creates a new IMContextSimple.
func NewIMContextSimple() IMContextSimple {
	var _cret *C.GtkIMContext // in

	_cret = C.gtk_im_context_simple_new()

	var _imContextSimple IMContextSimple // out

	_imContextSimple = WrapIMContextSimple(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _imContextSimple
}

func (c imContextSimple) AddComposeFileIMContextSimple(composeFile string) {
	var _arg0 *C.GtkIMContextSimple // out
	var _arg1 *C.char               // out

	_arg0 = (*C.GtkIMContextSimple)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(composeFile))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_im_context_simple_add_compose_file(_arg0, _arg1)
}

// IMMulticontext: `GtkIMMulticontext` is input method supporting multiple,
// switchable input methods.
//
// Text widgets such as `GtkText` or `GtkTextView` use a `GtkIMMultiContext` to
// implement their `im-module` property for switching between different input
// methods.
type IMMulticontext interface {

	// ContextID gets the id of the currently active delegate of the @context.
	ContextID() string
	// SetContextIDIMMulticontext sets the context id for @context.
	//
	// This causes the currently active delegate of @context to be replaced by
	// the delegate corresponding to the new context id.
	SetContextIDIMMulticontext(contextId string)
}

// imMulticontext implements the IMMulticontext class.
type imMulticontext struct {
	IMContext
}

// WrapIMMulticontext wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMMulticontext(obj *externglib.Object) IMMulticontext {
	return imMulticontext{
		IMContext: WrapIMContext(obj),
	}
}

func marshalIMMulticontext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMMulticontext(obj), nil
}

// NewIMMulticontext creates a new `GtkIMMulticontext`.
func NewIMMulticontext() IMMulticontext {
	var _cret *C.GtkIMContext // in

	_cret = C.gtk_im_multicontext_new()

	var _imMulticontext IMMulticontext // out

	_imMulticontext = WrapIMMulticontext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _imMulticontext
}

func (c imMulticontext) ContextID() string {
	var _arg0 *C.GtkIMMulticontext // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_im_multicontext_get_context_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c imMulticontext) SetContextIDIMMulticontext(contextId string) {
	var _arg0 *C.GtkIMMulticontext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(contextId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_im_multicontext_set_context_id(_arg0, _arg1)
}

// IconPaintable contains information found when looking up an icon in
// `GtkIconTheme`.
//
// `GtkIconPaintable` implements `GdkPaintable`.
type IconPaintable interface {
	gdk.Paintable

	// File gets the `GFile` that was used to load the icon.
	//
	// Returns nil if the icon was not loaded from a file.
	File() gio.File
	// IconName: get the icon name being used for this icon.
	//
	// When an icon looked up in the icon theme was not available, the icon
	// theme may use fallback icons - either those specified to
	// gtk_icon_theme_lookup_icon() or the always-available "image-missing". The
	// icon chosen is returned by this function.
	//
	// If the icon was created without an icon theme, this function returns nil.
	IconName() string
	// IsSymbolicIconPaintable checks if the icon is symbolic or not.
	//
	// This currently uses only the file name and not the file contents for
	// determining this. This behaviour may change in the future.
	//
	// Note that to render a symbolic `GtkIconPaintable` properly (with
	// recoloring), you have to set its icon name on a `GtkImage`.
	IsSymbolicIconPaintable() bool
}

// iconPaintable implements the IconPaintable class.
type iconPaintable struct {
	gextras.Objector
}

// WrapIconPaintable wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconPaintable(obj *externglib.Object) IconPaintable {
	return iconPaintable{
		Objector: obj,
	}
}

func marshalIconPaintable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconPaintable(obj), nil
}

// NewIconPaintableForFile creates a `GtkIconPaintable` for a file with a given
// size and scale.
//
// The icon can then be rendered by using it as a `GdkPaintable`.
func NewIconPaintableForFile(file gio.File, size int, scale int) IconPaintable {
	var _arg1 *C.GFile            // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _cret *C.GtkIconPaintable // in

	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))
	_arg2 = (C.int)(size)
	_arg3 = (C.int)(scale)

	_cret = C.gtk_icon_paintable_new_for_file(_arg1, _arg2, _arg3)

	var _iconPaintable IconPaintable // out

	_iconPaintable = WrapIconPaintable(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconPaintable
}

func (s iconPaintable) File() gio.File {
	var _arg0 *C.GtkIconPaintable // out
	var _cret *C.GFile            // in

	_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_paintable_get_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

func (s iconPaintable) IconName() string {
	var _arg0 *C.GtkIconPaintable // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_paintable_get_icon_name(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (s iconPaintable) IsSymbolicIconPaintable() bool {
	var _arg0 *C.GtkIconPaintable // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_paintable_is_symbolic(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconTheme: `GtkIconTheme` provides a facility for loading themed icons.
//
// The main reason for using a name rather than simply providing a filename is
// to allow different icons to be used depending on what icon theme is
// selected by the user. The operation of icon themes on Linux and Unix follows
// the Icon Theme Specification
// (http://www.freedesktop.org/Standards/icon-theme-spec) There is a fallback
// icon theme, named `hicolor`, where applications should install their icons,
// but additional icon themes can be installed as operating system vendors and
// users choose.
//
// In many cases, named themes are used indirectly, via [class@Gtk.Image] rather
// than directly, but looking up icons directly is also simple. The
// `GtkIconTheme` object acts as a database of all the icons in the current
// theme. You can create new `GtkIconTheme` objects, but its much more
// efficient to use the standard icon theme of the `GtkWidget` so that the icon
// information is shared with other people looking up icons.
//
// `c GtkIconTheme *icon_theme; GtkIconPaintable *icon; GdkPaintable
// *paintable;
//
// icon_theme = gtk_icon_theme_get_for_display (gtk_widget_get_display
// (my_widget)); icon = gtk_icon_theme_lookup_icon (icon_theme, "my-icon-name",
// // icon name 48, // icon size 1, // scale 0, // flags); paintable =
// GDK_PAINTABLE (icon); // Use the paintable g_object_unref (icon); `
type IconTheme interface {

	// AddResourcePathIconTheme adds a resource path that will be looked at when
	// looking for icons, similar to search paths.
	//
	// See [method@Gtk.IconTheme.set_resource_path].
	//
	// This function should be used to make application-specific icons available
	// as part of the icon theme.
	AddResourcePathIconTheme(path string)
	// AddSearchPathIconTheme appends a directory to the search path.
	//
	// See [method@Gtk.IconTheme.set_search_path].
	AddSearchPathIconTheme(path string)
	// Display returns the display that the `GtkIconTheme` object was created
	// for.
	Display() gdk.Display
	// IconNames lists the names of icons in the current icon theme.
	IconNames() []string
	// IconSizes returns an array of integers describing the sizes at which the
	// icon is available without scaling.
	//
	// A size of -1 means that the icon is available in a scalable format. The
	// array is zero-terminated.
	IconSizes(iconName string) []int
	// ResourcePath gets the current resource path.
	//
	// See [method@Gtk.IconTheme.set_resource_path].
	ResourcePath() []string
	// SearchPath gets the current search path.
	//
	// See [method@Gtk.IconTheme.set_search_path].
	SearchPath() []string
	// ThemeName gets the current icon theme name.
	//
	// Returns (transfer full): the current icon theme name,
	ThemeName() string
	// HasGIconIconTheme checks whether an icon theme includes an icon for a
	// particular `GIcon`.
	HasGIconIconTheme(gicon gio.Icon) bool
	// HasIconIconTheme checks whether an icon theme includes an icon for a
	// particular name.
	HasIconIconTheme(iconName string) bool
	// LookupByGIconIconTheme looks up a icon for a desired size and window
	// scale.
	//
	// The icon can then be rendered by using it as a `GdkPaintable`, or you can
	// get information such as the filename and size.
	LookupByGIconIconTheme(icon gio.Icon, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable
	// LookupIconIconTheme looks up a named icon for a desired size and window
	// scale, returning a `GtkIconPaintable`.
	//
	// The icon can then be rendered by using it as a `GdkPaintable`, or you can
	// get information such as the filename and size.
	//
	// If the available @icon_name is not available and @fallbacks are provided,
	// they will be tried in order.
	//
	// If no matching icon is found, then a paintable that renders the "missing
	// icon" icon is returned. If you need to do something else for missing
	// icons you need to use [method@Gtk.IconTheme.has_icon].
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by overriding the
	// GtkWidgetClass.css-changed() function.
	LookupIconIconTheme(iconName string, fallbacks []string, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable
	// SetResourcePathIconTheme sets the resource paths that will be looked at
	// when looking for icons, similar to search paths.
	//
	// The resources are considered as part of the hicolor icon theme and must
	// be located in subdirectories that are defined in the hicolor icon theme,
	// such as `@path/16x16/actions/run.png` or
	// `@path/scalable/actions/run.svg`.
	//
	// Icons that are directly placed in the resource path instead of a
	// subdirectory are also considered as ultimate fallback, but they are
	// treated like unthemed icons.
	SetResourcePathIconTheme(path *string)
	// SetSearchPathIconTheme sets the search path for the icon theme object.
	//
	// When looking for an icon theme, GTK will search for a subdirectory of one
	// or more of the directories in @path with the same name as the icon theme
	// containing an index.theme file. (Themes from multiple of the path
	// elements are combined to allow themes to be extended by adding icons in
	// the users home directory.)
	//
	// In addition if an icon found isnt found either in the current icon theme
	// or the default icon theme, and an image file with the right name is found
	// directly in one of the elements of @path, then that image will be used
	// for the icon name. (This is legacy feature, and new icons should be put
	// into the fallback icon theme, which is called hicolor, rather than
	// directly on the icon path.)
	SetSearchPathIconTheme(path []string)
	// SetThemeNameIconTheme sets the name of the icon theme that the
	// `GtkIconTheme` object uses overriding system configuration.
	//
	// This function cannot be called on the icon theme objects returned from
	// [type_func@Gtk.IconTheme.get_for_display].
	SetThemeNameIconTheme(themeName string)
}

// iconTheme implements the IconTheme class.
type iconTheme struct {
	gextras.Objector
}

// WrapIconTheme wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconTheme(obj *externglib.Object) IconTheme {
	return iconTheme{
		Objector: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconTheme(obj), nil
}

// NewIconTheme creates a new icon theme object.
//
// Icon theme objects are used to lookup up an icon by name in a particular icon
// theme. Usually, youll want to use [func@Gtk.IconTheme.get_for_display]
// rather than creating a new icon theme object for scratch.
func NewIconTheme() IconTheme {
	var _cret *C.GtkIconTheme // in

	_cret = C.gtk_icon_theme_new()

	var _iconTheme IconTheme // out

	_iconTheme = WrapIconTheme(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconTheme
}

func (s iconTheme) AddResourcePathIconTheme(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_add_resource_path(_arg0, _arg1)
}

func (s iconTheme) AddSearchPathIconTheme(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_add_search_path(_arg0, _arg1)
}

func (s iconTheme) Display() gdk.Display {
	var _arg0 *C.GtkIconTheme // out
	var _cret *C.GdkDisplay   // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_theme_get_display(_arg0)

	var _display gdk.Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

	return _display
}

func (s iconTheme) IconNames() []string {
	var _arg0 *C.GtkIconTheme // out
	var _cret **C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_theme_get_icon_names(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (s iconTheme) IconSizes(iconName string) []int {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out
	var _cret *C.int

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_theme_get_icon_sizes(_arg0, _arg1)

	var _gints []int

	{
		var i int
		var z C.int
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_gints = make([]int, i)
		for i := range src {
			_gints[i] = (int)(src[i])
		}
	}

	return _gints
}

func (s iconTheme) ResourcePath() []string {
	var _arg0 *C.GtkIconTheme // out
	var _cret **C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_theme_get_resource_path(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (s iconTheme) SearchPath() []string {
	var _arg0 *C.GtkIconTheme // out
	var _cret **C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_theme_get_search_path(_arg0)

	var _filenames []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

func (s iconTheme) ThemeName() string {
	var _arg0 *C.GtkIconTheme // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_theme_get_theme_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (s iconTheme) HasGIconIconTheme(gicon gio.Icon) bool {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.GIcon        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))

	_cret = C.gtk_icon_theme_has_gicon(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s iconTheme) HasIconIconTheme(iconName string) bool {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_theme_has_icon(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s iconTheme) LookupByGIconIconTheme(icon gio.Icon, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.GIcon             // out
	var _arg2 C.int                // out
	var _arg3 C.int                // out
	var _arg4 C.GtkTextDirection   // out
	var _arg5 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconPaintable  // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg2 = (C.int)(size)
	_arg3 = (C.int)(scale)
	_arg4 = (C.GtkTextDirection)(direction)
	_arg5 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_lookup_by_gicon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _iconPaintable IconPaintable // out

	_iconPaintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconPaintable)

	return _iconPaintable
}

func (s iconTheme) LookupIconIconTheme(iconName string, fallbacks []string, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out
	var _arg2 **C.char
	var _arg3 C.int                // out
	var _arg4 C.int                // out
	var _arg5 C.GtkTextDirection   // out
	var _arg6 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconPaintable  // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.char)(C.malloc(C.ulong(len(fallbacks)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(fallbacks))
		for i := range fallbacks {
			out[i] = (*C.char)(C.CString(fallbacks[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg3 = (C.int)(size)
	_arg4 = (C.int)(scale)
	_arg5 = (C.GtkTextDirection)(direction)
	_arg6 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_lookup_icon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _iconPaintable IconPaintable // out

	_iconPaintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconPaintable)

	return _iconPaintable
}

func (s iconTheme) SetResourcePathIconTheme(path *string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.char        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_set_resource_path(_arg0, _arg1)
}

func (s iconTheme) SetSearchPathIconTheme(path []string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.char)(C.malloc(C.ulong(len(path)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(path))
		for i := range path {
			out[i] = (*C.gchar)(C.CString(path[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_icon_theme_set_search_path(_arg0, _arg1)
}

func (s iconTheme) SetThemeNameIconTheme(themeName string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(themeName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_set_theme_name(_arg0, _arg1)
}

// IconView: `GtkIconView` is a widget which displays data in a grid of icons.
//
// `GtkIconView` provides an alternative view on a `GtkTreeModel`. It displays
// the model as a grid of icons with labels. Like [class@Gtk.TreeView], it
// allows to select one or multiple items (depending on the selection mode, see
// [method@Gtk.IconView.set_selection_mode]). In addition to selection with the
// arrow keys, `GtkIconView` supports rubberband selection, which is controlled
// by dragging the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the trees branches.
//
//
// CSS nodes
//
// ` iconview.view  [rubberband] `
//
// `GtkIconView` has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView interface {
	Widget
	CellLayout
	Scrollable

	// CreateDragIconIconView creates a #cairo_surface_t representation of the
	// item at @path. This image is used for a drag icon.
	CreateDragIconIconView(path *TreePath) gdk.Paintable
	// EnableModelDragDestIconView turns @icon_view into a drop destination for
	// automatic DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragDestIconView(formats *gdk.ContentFormats, actions gdk.DragAction)
	// EnableModelDragSourceIconView turns @icon_view into a drag source for
	// automatic DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragSourceIconView(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)
	// ActivateOnSingleClick gets the setting set by
	// gtk_icon_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// CellRect fills the bounding rectangle in widget coordinates for the cell
	// specified by @path and @cell. If @cell is nil the main cell area is used.
	//
	// This function is only valid if @icon_view is realized.
	CellRect(path *TreePath, cell CellRenderer) (gdk.Rectangle, bool)
	// ColumnSpacing returns the value of the ::column-spacing property.
	ColumnSpacing() int
	// Columns returns the value of the ::columns property.
	Columns() int
	// Cursor fills in @path and @cell with the current cursor path and cell. If
	// the cursor isnt currently set, then *@path will be nil. If no cell
	// currently has focus, then *@cell will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free().
	Cursor() (*TreePath, CellRenderer, bool)
	// DestItemAtPos determines the destination item for a given position.
	DestItemAtPos(dragX int, dragY int) (*TreePath, IconViewDropPosition, bool)
	// DragDestItem gets information about the item that is highlighted for
	// feedback.
	DragDestItem() (*TreePath, IconViewDropPosition)
	// ItemAtPos gets the path and cell for the icon at the given position.
	ItemAtPos(x int, y int) (*TreePath, CellRenderer, bool)
	// ItemColumn gets the column in which the item @path is currently
	// displayed. Column numbers start at 0.
	ItemColumn(path *TreePath) int
	// ItemOrientation returns the value of the ::item-orientation property
	// which determines whether the labels are drawn beside the icons instead of
	// below.
	ItemOrientation() Orientation
	// ItemPadding returns the value of the ::item-padding property.
	ItemPadding() int
	// ItemRow gets the row in which the item @path is currently displayed. Row
	// numbers start at 0.
	ItemRow(path *TreePath) int
	// ItemWidth returns the value of the ::item-width property.
	ItemWidth() int
	// Margin returns the value of the ::margin property.
	Margin() int
	// MarkupColumn returns the column with markup text for @icon_view.
	MarkupColumn() int
	// Model returns the model the IconView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// PathAtPos gets the path for the icon at the given position.
	PathAtPos(x int, y int) *TreePath
	// PixbufColumn returns the column with pixbufs for @icon_view.
	PixbufColumn() int
	// Reorderable retrieves whether the user can reorder the list via
	// drag-and-drop. See gtk_icon_view_set_reorderable().
	Reorderable() bool
	// RowSpacing returns the value of the ::row-spacing property.
	RowSpacing() int
	// SelectionMode gets the selection mode of the @icon_view.
	SelectionMode() SelectionMode
	// Spacing returns the value of the ::spacing property.
	Spacing() int
	// TextColumn returns the column with text for @icon_view.
	TextColumn() int
	// TooltipColumn returns the column of @icon_views model which is being
	// used for displaying tooltips on @icon_views rows.
	TooltipColumn() int
	// TooltipContext: this function is supposed to be used in a
	// Widget::query-tooltip signal handler for IconView. The @x, @y and
	// @keyboard_tip values which are received in the signal handler, should be
	// passed to this function without modification.
	//
	// The return value indicates whether there is an icon view item at the
	// given coordinates (true) or not (false) for mouse tooltips. For keyboard
	// tooltips the item returned will be the cursor item. When true, then any
	// of @model, @path and @iter which have been provided will be set to point
	// to that row and the corresponding model.
	TooltipContext(x int, y int, keyboardTip bool) (TreeModel, *TreePath, TreeIter, bool)
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// Both paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// ItemActivatedIconView activates the item determined by @path.
	ItemActivatedIconView(path *TreePath)
	// PathIsSelectedIconView returns true if the icon pointed to by @path is
	// currently selected. If @path does not point to a valid location, false is
	// returned.
	PathIsSelectedIconView(path *TreePath) bool
	// ScrollToPathIconView moves the alignments of @icon_view to the position
	// specified by @path. @row_align determines where the row is placed, and
	// @col_align determines where @column is placed. Both are expected to be
	// between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom
	// alignment, 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the item onto the screen.
	// This means that the item will be scrolled to the edge closest to its
	// current position. If the item is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @icon_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToPathIconView(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)
	// SelectAllIconView selects all the icons. @icon_view must has its
	// selection mode set to K_SELECTION_MULTIPLE.
	SelectAllIconView()
	// SelectPathIconView selects the row at @path.
	SelectPathIconView(path *TreePath)
	// SetActivateOnSingleClickIconView causes the IconView::item-activated
	// signal to be emitted on a single click instead of a double click.
	SetActivateOnSingleClickIconView(single bool)
	// SetColumnSpacingIconView sets the ::column-spacing property which
	// specifies the space which is inserted between the columns of the icon
	// view.
	SetColumnSpacingIconView(columnSpacing int)
	// SetColumnsIconView sets the ::columns property which determines in how
	// many columns the icons are arranged. If @columns is -1, the number of
	// columns will be chosen automatically to fill the available area.
	SetColumnsIconView(columns int)
	// SetCursorIconView sets the current keyboard focus to be at @path, and
	// selects it. This is useful when you want to focus the users attention on
	// a particular item. If @cell is not nil, then focus is given to the cell
	// specified by it. Additionally, if @start_editing is true, then editing
	// should be started in the specified cell.
	//
	// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
	// order to give keyboard focus to the widget. Please note that editing can
	// only happen when the widget is realized.
	SetCursorIconView(path *TreePath, cell CellRenderer, startEditing bool)
	// SetDragDestItemIconView sets the item that is highlighted for feedback.
	SetDragDestItemIconView(path *TreePath, pos IconViewDropPosition)
	// SetItemOrientationIconView sets the ::item-orientation property which
	// determines whether the labels are drawn beside the icons instead of
	// below.
	SetItemOrientationIconView(orientation Orientation)
	// SetItemPaddingIconView sets the IconView:item-padding property which
	// specifies the padding around each of the icon views items.
	SetItemPaddingIconView(itemPadding int)
	// SetItemWidthIconView sets the ::item-width property which specifies the
	// width to use for each item. If it is set to -1, the icon view will
	// automatically determine a suitable item size.
	SetItemWidthIconView(itemWidth int)
	// SetMarginIconView sets the ::margin property which specifies the space
	// which is inserted at the top, bottom, left and right of the icon view.
	SetMarginIconView(margin int)
	// SetMarkupColumnIconView sets the column with markup information for
	// @icon_view to be @column. The markup column must be of type TYPE_STRING.
	// If the markup column is set to something, it overrides the text column
	// set by gtk_icon_view_set_text_column().
	SetMarkupColumnIconView(column int)
	// SetModelIconView sets the model for a IconView. If the @icon_view already
	// has a model set, it will remove it before setting the new model. If
	// @model is nil, then it will unset the old model.
	SetModelIconView(model TreeModel)
	// SetPixbufColumnIconView sets the column with pixbufs for @icon_view to be
	// @column. The pixbuf column must be of type K_TYPE_PIXBUF
	SetPixbufColumnIconView(column int)
	// SetReorderableIconView: this function is a convenience function to allow
	// you to reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model's row_inserted and row_deleted signals. The reordering is
	// implemented by setting up the icon view as a drag source and destination.
	// Therefore, drag and drop can not be used in a reorderable view for any
	// other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderableIconView(reorderable bool)
	// SetRowSpacingIconView sets the ::row-spacing property which specifies the
	// space which is inserted between the rows of the icon view.
	SetRowSpacingIconView(rowSpacing int)
	// SetSelectionModeIconView sets the selection mode of the @icon_view.
	SetSelectionModeIconView(mode SelectionMode)
	// SetSpacingIconView sets the ::spacing property which specifies the space
	// which is inserted between the cells (i.e. the icon and the text) of an
	// item.
	SetSpacingIconView(spacing int)
	// SetTextColumnIconView sets the column with text for @icon_view to be
	// @column. The text column must be of type TYPE_STRING.
	SetTextColumnIconView(column int)
	// SetTooltipCellIconView sets the tip area of @tooltip to the area which
	// @cell occupies in the item pointed to by @path. See also
	// gtk_tooltip_set_tip_area().
	//
	// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCellIconView(tooltip Tooltip, path *TreePath, cell CellRenderer)
	// SetTooltipColumnIconView: if you only plan to have simple (text-only)
	// tooltips on full items, you can use this function to have IconView handle
	// these automatically for you. @column should be set to the column in
	// @icon_views model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @icon_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumnIconView(column int)
	// SetTooltipItemIconView sets the tip area of @tooltip to be the area
	// covered by the item at @path. See also gtk_icon_view_set_tooltip_column()
	// for a simpler alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipItemIconView(tooltip Tooltip, path *TreePath)
	// UnselectAllIconView unselects all the icons.
	UnselectAllIconView()
	// UnselectPathIconView unselects the row at @path.
	UnselectPathIconView(path *TreePath)
	// UnsetModelDragDestIconView undoes the effect of
	// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragDestIconView()
	// UnsetModelDragSourceIconView undoes the effect of
	// gtk_icon_view_enable_model_drag_source(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragSourceIconView()
}

// iconView implements the IconView class.
type iconView struct {
	Widget
}

// WrapIconView wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconView(obj *externglib.Object) IconView {
	return iconView{
		Widget: WrapWidget(obj),
	}
}

func marshalIconView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconView(obj), nil
}

// NewIconView creates a new IconView widget
func NewIconView() IconView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_icon_view_new()

	var _iconView IconView // out

	_iconView = WrapIconView(externglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// NewIconViewWithArea creates a new IconView widget using the specified @area
// to layout cells inside the icons.
func NewIconViewWithArea(area CellArea) IconView {
	var _arg1 *C.GtkCellArea // out
	var _cret *C.GtkWidget   // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	_cret = C.gtk_icon_view_new_with_area(_arg1)

	var _iconView IconView // out

	_iconView = WrapIconView(externglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// NewIconViewWithModel creates a new IconView widget with the model @model.
func NewIconViewWithModel(model TreeModel) IconView {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_icon_view_new_with_model(_arg1)

	var _iconView IconView // out

	_iconView = WrapIconView(externglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

func (i iconView) CreateDragIconIconView(path *TreePath) gdk.Paintable {
	var _arg0 *C.GtkIconView  // out
	var _arg1 *C.GtkTreePath  // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_icon_view_create_drag_icon(_arg0, _arg1)

	var _paintable gdk.Paintable // out

	_paintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.Paintable)

	return _paintable
}

func (i iconView) EnableModelDragDestIconView(formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView       // out
	var _arg1 *C.GdkContentFormats // out
	var _arg2 C.GdkDragAction      // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	_arg2 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_dest(_arg0, _arg1, _arg2)
}

func (i iconView) EnableModelDragSourceIconView(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView       // out
	var _arg1 C.GdkModifierType    // out
	var _arg2 *C.GdkContentFormats // out
	var _arg3 C.GdkDragAction      // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GdkModifierType)(startButtonMask)
	_arg2 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	_arg3 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3)
}

func (i iconView) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkIconView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_activate_on_single_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i iconView) CellRect(path *TreePath, cell CellRenderer) (gdk.Rectangle, bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GtkCellRenderer // out
	var _rect gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	_cret = C.gtk_icon_view_get_cell_rect(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

func (i iconView) ColumnSpacing() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_column_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) Columns() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_columns(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) Cursor() (*TreePath, CellRenderer, bool) {
	var _arg0 *C.GtkIconView // out
	var _path *TreePath
	var _arg2 *C.GtkCellRenderer // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_cursor(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)

	var _cell CellRenderer // out
	var _ok bool           // out

	_cell = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(CellRenderer)
	if _cret != 0 {
		_ok = true
	}

	return _path, _cell, _ok
}

func (i iconView) DestItemAtPos(dragX int, dragY int) (*TreePath, IconViewDropPosition, bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _path *TreePath
	var _arg4 C.GtkIconViewDropPosition // in
	var _cret C.gboolean                // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(dragX)
	_arg2 = (C.int)(dragY)

	_cret = C.gtk_icon_view_get_dest_item_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)

	var _pos IconViewDropPosition // out
	var _ok bool                  // out

	_pos = IconViewDropPosition(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _path, _pos, _ok
}

func (i iconView) DragDestItem() (*TreePath, IconViewDropPosition) {
	var _arg0 *C.GtkIconView // out
	var _path *TreePath
	var _arg2 C.GtkIconViewDropPosition // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_get_drag_dest_item(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)

	var _pos IconViewDropPosition // out

	_pos = IconViewDropPosition(_arg2)

	return _path, _pos
}

func (i iconView) ItemAtPos(x int, y int) (*TreePath, CellRenderer, bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _path *TreePath
	var _arg4 *C.GtkCellRenderer // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)

	_cret = C.gtk_icon_view_get_item_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)

	var _cell CellRenderer // out
	var _ok bool           // out

	_cell = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(CellRenderer)
	if _cret != 0 {
		_ok = true
	}

	return _path, _cell, _ok
}

func (i iconView) ItemColumn(path *TreePath) int {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_icon_view_get_item_column(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) ItemOrientation() Orientation {
	var _arg0 *C.GtkIconView   // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_item_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

func (i iconView) ItemPadding() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_item_padding(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) ItemRow(path *TreePath) int {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_icon_view_get_item_row(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) ItemWidth() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_item_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) Margin() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) MarkupColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_markup_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) Model() TreeModel {
	var _arg0 *C.GtkIconView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

func (i iconView) PathAtPos(x int, y int) *TreePath {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)

	_cret = C.gtk_icon_view_get_path_at_pos(_arg0, _arg1, _arg2)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

func (i iconView) PixbufColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_pixbuf_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) Reorderable() bool {
	var _arg0 *C.GtkIconView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_reorderable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i iconView) RowSpacing() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_row_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) SelectionMode() SelectionMode {
	var _arg0 *C.GtkIconView     // out
	var _cret C.GtkSelectionMode // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_selection_mode(_arg0)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

func (i iconView) Spacing() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) TextColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_text_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) TooltipColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_tooltip_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i iconView) TooltipContext(x int, y int, keyboardTip bool) (TreeModel, *TreePath, TreeIter, bool) {
	var _arg0 *C.GtkIconView  // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.gboolean      // out
	var _arg4 *C.GtkTreeModel // in
	var _path *TreePath
	var _iter TreeIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)
	if keyboardTip {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_icon_view_get_tooltip_context(_arg0, _arg1, _arg2, _arg3, &_arg4, (**C.GtkTreePath)(unsafe.Pointer(&_path)), (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _model TreeModel // out

	var _ok bool // out

	_model = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeModel)

	if _cret != 0 {
		_ok = true
	}

	return _model, _path, _iter, _ok
}

func (i iconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var _arg0 *C.GtkIconView // out
	var _startPath *TreePath
	var _endPath *TreePath
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_visible_range(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_startPath)), (**C.GtkTreePath)(unsafe.Pointer(&_endPath)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

func (i iconView) ItemActivatedIconView(path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_item_activated(_arg0, _arg1)
}

func (i iconView) PathIsSelectedIconView(path *TreePath) bool {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_icon_view_path_is_selected(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i iconView) ScrollToPathIconView(path *TreePath, useAlign bool, rowAlign float32, colAlign float32) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _arg2 C.gboolean     // out
	var _arg3 C.float        // out
	var _arg4 C.float        // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	if useAlign {
		_arg2 = C.TRUE
	}
	_arg3 = (C.float)(rowAlign)
	_arg4 = (C.float)(colAlign)

	C.gtk_icon_view_scroll_to_path(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (i iconView) SelectAllIconView() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_select_all(_arg0)
}

func (i iconView) SelectPathIconView(path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_select_path(_arg0, _arg1)
}

func (i iconView) SetActivateOnSingleClickIconView(single bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_icon_view_set_activate_on_single_click(_arg0, _arg1)
}

func (i iconView) SetColumnSpacingIconView(columnSpacing int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(columnSpacing)

	C.gtk_icon_view_set_column_spacing(_arg0, _arg1)
}

func (i iconView) SetColumnsIconView(columns int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(columns)

	C.gtk_icon_view_set_columns(_arg0, _arg1)
}

func (i iconView) SetCursorIconView(path *TreePath, cell CellRenderer, startEditing bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GtkCellRenderer // out
	var _arg3 C.gboolean         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if startEditing {
		_arg3 = C.TRUE
	}

	C.gtk_icon_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
}

func (i iconView) SetDragDestItemIconView(path *TreePath, pos IconViewDropPosition) {
	var _arg0 *C.GtkIconView            // out
	var _arg1 *C.GtkTreePath            // out
	var _arg2 C.GtkIconViewDropPosition // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (C.GtkIconViewDropPosition)(pos)

	C.gtk_icon_view_set_drag_dest_item(_arg0, _arg1, _arg2)
}

func (i iconView) SetItemOrientationIconView(orientation Orientation) {
	var _arg0 *C.GtkIconView   // out
	var _arg1 C.GtkOrientation // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	C.gtk_icon_view_set_item_orientation(_arg0, _arg1)
}

func (i iconView) SetItemPaddingIconView(itemPadding int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(itemPadding)

	C.gtk_icon_view_set_item_padding(_arg0, _arg1)
}

func (i iconView) SetItemWidthIconView(itemWidth int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(itemWidth)

	C.gtk_icon_view_set_item_width(_arg0, _arg1)
}

func (i iconView) SetMarginIconView(margin int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(margin)

	C.gtk_icon_view_set_margin(_arg0, _arg1)
}

func (i iconView) SetMarkupColumnIconView(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(column)

	C.gtk_icon_view_set_markup_column(_arg0, _arg1)
}

func (i iconView) SetModelIconView(model TreeModel) {
	var _arg0 *C.GtkIconView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_icon_view_set_model(_arg0, _arg1)
}

func (i iconView) SetPixbufColumnIconView(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(column)

	C.gtk_icon_view_set_pixbuf_column(_arg0, _arg1)
}

func (i iconView) SetReorderableIconView(reorderable bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_icon_view_set_reorderable(_arg0, _arg1)
}

func (i iconView) SetRowSpacingIconView(rowSpacing int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(rowSpacing)

	C.gtk_icon_view_set_row_spacing(_arg0, _arg1)
}

func (i iconView) SetSelectionModeIconView(mode SelectionMode) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 C.GtkSelectionMode // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_icon_view_set_selection_mode(_arg0, _arg1)
}

func (i iconView) SetSpacingIconView(spacing int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(spacing)

	C.gtk_icon_view_set_spacing(_arg0, _arg1)
}

func (i iconView) SetTextColumnIconView(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(column)

	C.gtk_icon_view_set_text_column(_arg0, _arg1)
}

func (i iconView) SetTooltipCellIconView(tooltip Tooltip, path *TreePath, cell CellRenderer) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTooltip      // out
	var _arg2 *C.GtkTreePath     // out
	var _arg3 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_icon_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3)
}

func (i iconView) SetTooltipColumnIconView(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(column)

	C.gtk_icon_view_set_tooltip_column(_arg0, _arg1)
}

func (i iconView) SetTooltipItemIconView(tooltip Tooltip, path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTooltip  // out
	var _arg2 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_set_tooltip_item(_arg0, _arg1, _arg2)
}

func (i iconView) UnselectAllIconView() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unselect_all(_arg0)
}

func (i iconView) UnselectPathIconView(path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_unselect_path(_arg0, _arg1)
}

func (i iconView) UnsetModelDragDestIconView() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_dest(_arg0)
}

func (i iconView) UnsetModelDragSourceIconView() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_source(_arg0)
}

func (s iconView) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s iconView) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s iconView) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s iconView) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s iconView) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s iconView) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s iconView) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b iconView) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c iconView) AddAttribute(cell CellRenderer, attribute string, column int) {
	WrapCellLayout(gextras.InternObject(c)).AddAttribute(cell, attribute, column)
}

func (c iconView) Clear() {
	WrapCellLayout(gextras.InternObject(c)).Clear()
}

func (c iconView) ClearAttributes(cell CellRenderer) {
	WrapCellLayout(gextras.InternObject(c)).ClearAttributes(cell)
}

func (c iconView) Area() CellArea {
	return WrapCellLayout(gextras.InternObject(c)).Area()
}

func (c iconView) PackEnd(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackEnd(cell, expand)
}

func (c iconView) PackStart(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackStart(cell, expand)
}

func (c iconView) Reorder(cell CellRenderer, position int) {
	WrapCellLayout(gextras.InternObject(c)).Reorder(cell, position)
}

func (s iconView) Border() (Border, bool) {
	return WrapScrollable(gextras.InternObject(s)).Border()
}

func (s iconView) HAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).HAdjustment()
}

func (s iconView) HScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).HScrollPolicy()
}

func (s iconView) VAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).VAdjustment()
}

func (s iconView) VScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).VScrollPolicy()
}

func (s iconView) SetHAdjustment(hadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetHAdjustment(hadjustment)
}

func (s iconView) SetHScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetHScrollPolicy(policy)
}

func (s iconView) SetVAdjustment(vadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetVAdjustment(vadjustment)
}

func (s iconView) SetVScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetVScrollPolicy(policy)
}

// Image: the `GtkImage` widget displays an image.
//
// !An example GtkImage (image.png)
//
// Various kinds of object can be displayed as an image; most typically, you
// would load a `GdkTexture` from a file, using the convenience function
// [ctor@Gtk.Image.new_from_file], for instance:
//
// `c GtkWidget *image = gtk_image_new_from_file ("myfile.png"); `
//
// If the file isnt loaded successfully, the image will contain a broken
// image icon similar to that used in many web browsers.
//
// If you want to handle errors in loading the file yourself, for example by
// displaying an error message, then load the image with
// [ctor@Gdk.Texture.new_from_file], then create the `GtkImage` with
// [ctor@Gtk.Image.new_from_paintable].
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of `GResource` inside GIO, for
// details. In this case, [property@Gtk.Image:resource],
// [ctor@Gtk.Image.new_from_resource], and [method@Gtk.Image.set_from_resource]
// should be used.
//
// `GtkImage` displays its image as an icon, with a size that is determined by
// the application. See [class@Gtk.Picture] if you want to show an image at is
// actual size.
//
//
// CSS nodes
//
// `GtkImage` has a single CSS node with the name `image`. The style classes
// `.normal-icons` or `.large-icons` may appear, depending on the
// [property@Gtk.Image:icon-size] property.
//
//
// Accessibility
//
// `GtkImage` uses the `GTK_ACCESSIBLE_ROLE_IMG` role.
type Image interface {
	Widget

	// ClearImage resets the image to be empty.
	ClearImage()
	// GIcon gets the `GIcon` being displayed by the `GtkImage`.
	//
	// The storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON
	// (see [method@Gtk.Image.get_storage_type]). The caller of this function
	// does not own a reference to the returned `GIcon`.
	GIcon() gio.Icon
	// IconName gets the icon name and size being displayed by the `GtkImage`.
	//
	// The storage type of the image must be GTK_IMAGE_EMPTY or
	// GTK_IMAGE_ICON_NAME (see [method@Gtk.Image.get_storage_type]). The
	// returned string is owned by the `GtkImage` and should not be freed.
	IconName() string
	// IconSize gets the icon size used by the @image when rendering icons.
	IconSize() IconSize
	// Paintable gets the image `GdkPaintable` being displayed by the
	// `GtkImage`.
	//
	// The storage type of the image must be GTK_IMAGE_EMPTY or
	// GTK_IMAGE_PAINTABLE (see [method@Gtk.Image.get_storage_type]). The caller
	// of this function does not own a reference to the returned paintable.
	Paintable() gdk.Paintable
	// PixelSize gets the pixel size used for named icons.
	PixelSize() int
	// StorageType gets the type of representation being used by the `GtkImage`
	// to store image data.
	//
	// If the `GtkImage` has no image data, the return value will be
	// GTK_IMAGE_EMPTY.
	StorageType() ImageType
	// SetFromFileImage sets a `GtkImage` to show a file.
	//
	// See [ctor@Gtk.Image.new_from_file] for details.
	SetFromFileImage(filename string)
	// SetFromGIconImage sets a `GtkImage` to show a `GIcon`.
	//
	// See [ctor@Gtk.Image.new_from_gicon] for details.
	SetFromGIconImage(icon gio.Icon)
	// SetFromIconNameImage sets a `GtkImage` to show a named icon.
	//
	// See [ctor@Gtk.Image.new_from_icon_name] for details.
	SetFromIconNameImage(iconName string)
	// SetFromPaintableImage sets a `GtkImage` to show a `GdkPaintable`.
	//
	// See [ctor@Gtk.Image.new_from_paintable] for details.
	SetFromPaintableImage(paintable gdk.Paintable)
	// SetFromPixbufImage sets a `GtkImage` to show a `GdkPixbuf`.
	//
	// See [ctor@Gtk.Image.new_from_pixbuf] for details.
	//
	// Note: This is a helper for [method@Gtk.Image.set_from_paintable], and you
	// can't get back the exact pixbuf once this is called, only a paintable.
	SetFromPixbufImage(pixbuf gdkpixbuf.Pixbuf)
	// SetFromResourceImage sets a `GtkImage` to show a resource.
	//
	// See [ctor@Gtk.Image.new_from_resource] for details.
	SetFromResourceImage(resourcePath string)
	// SetIconSizeImage suggests an icon size to the theme for named icons.
	SetIconSizeImage(iconSize IconSize)
	// SetPixelSizeImage sets the pixel size to use for named icons.
	//
	// If the pixel size is set to a value != -1, it is used instead of the icon
	// size set by [method@Gtk.Image.set_from_icon_name].
	SetPixelSizeImage(pixelSize int)
}

// image implements the Image class.
type image struct {
	Widget
}

// WrapImage wraps a GObject to the right type. It is
// primarily used internally.
func WrapImage(obj *externglib.Object) Image {
	return image{
		Widget: WrapWidget(obj),
	}
}

func marshalImage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapImage(obj), nil
}

// NewImage creates a new empty `GtkImage` widget.
func NewImage() Image {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_image_new()

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromFile creates a new `GtkImage` displaying the file @filename.
//
// If the file isnt found or cant be loaded, the resulting `GtkImage` will
// display a broken image icon. This function never returns nil, it always
// returns a valid `GtkImage` widget.
//
// If you need to detect failures to load the file, use
// [ctor@Gdk.Texture.new_from_file] to load the file yourself, then create the
// `GtkImage` from the texture.
//
// The storage type (see [method@Gtk.Image.get_storage_type]) of the returned
// image is not defined, it will be whatever is appropriate for displaying the
// file.
func NewImageFromFile(filename string) Image {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_image_new_from_file(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromGIcon creates a `GtkImage` displaying an icon from the current
// icon theme.
//
// If the icon name isnt known, a broken image icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
func NewImageFromGIcon(icon gio.Icon) Image {
	var _arg1 *C.GIcon     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	_cret = C.gtk_image_new_from_gicon(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromIconName creates a `GtkImage` displaying an icon from the current
// icon theme.
//
// If the icon name isnt known, a broken image icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
func NewImageFromIconName(iconName string) Image {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_image_new_from_icon_name(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromPaintable creates a new `GtkImage` displaying @paintable.
//
// The `GtkImage` does not assume a reference to the paintable; you still need
// to unref it if you own references. `GtkImage` will add its own reference
// rather than adopting yours.
//
// The `GtkImage` will track changes to the @paintable and update its size and
// contents in response to it.
func NewImageFromPaintable(paintable gdk.Paintable) Image {
	var _arg1 *C.GdkPaintable // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	_cret = C.gtk_image_new_from_paintable(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromPixbuf creates a new `GtkImage` displaying @pixbuf.
//
// The `GtkImage` does not assume a reference to the pixbuf; you still need to
// unref it if you own references. `GtkImage` will add its own reference rather
// than adopting yours.
//
// This is a helper for [ctor@Gtk.Image.new_from_paintable], and you can't get
// back the exact pixbuf once this is called, only a texture.
//
// Note that this function just creates an `GtkImage` from the pixbuf. The
// `GtkImage` created will not react to state changes. Should you want that, you
// should use [ctor@Gtk.Image.new_from_icon_name].
func NewImageFromPixbuf(pixbuf gdkpixbuf.Pixbuf) Image {
	var _arg1 *C.GdkPixbuf // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_image_new_from_pixbuf(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromResource creates a new `GtkImage` displaying the resource file
// @resource_path.
//
// If the file isnt found or cant be loaded, the resulting `GtkImage` will
// display a broken image icon. This function never returns nil, it always
// returns a valid `GtkImage` widget.
//
// If you need to detect failures to load the file, use
// [ctor@GdkPixbuf.Pixbuf.new_from_file] to load the file yourself, then create
// the `GtkImage` from the pixbuf.
//
// The storage type (see [method@Gtk.Image.get_storage_type]) of the returned
// image is not defined, it will be whatever is appropriate for displaying the
// file.
func NewImageFromResource(resourcePath string) Image {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_image_new_from_resource(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

func (i image) ClearImage() {
	var _arg0 *C.GtkImage // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	C.gtk_image_clear(_arg0)
}

func (i image) GIcon() gio.Icon {
	var _arg0 *C.GtkImage // out
	var _cret *C.GIcon    // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_gicon(_arg0)

	var _icon gio.Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

	return _icon
}

func (i image) IconName() string {
	var _arg0 *C.GtkImage // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i image) IconSize() IconSize {
	var _arg0 *C.GtkImage   // out
	var _cret C.GtkIconSize // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_icon_size(_arg0)

	var _iconSize IconSize // out

	_iconSize = IconSize(_cret)

	return _iconSize
}

func (i image) Paintable() gdk.Paintable {
	var _arg0 *C.GtkImage     // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_paintable(_arg0)

	var _paintable gdk.Paintable // out

	_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

	return _paintable
}

func (i image) PixelSize() int {
	var _arg0 *C.GtkImage // out
	var _cret C.int       // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_pixel_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (i image) StorageType() ImageType {
	var _arg0 *C.GtkImage    // out
	var _cret C.GtkImageType // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_storage_type(_arg0)

	var _imageType ImageType // out

	_imageType = ImageType(_cret)

	return _imageType
}

func (i image) SetFromFileImage(filename string) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_image_set_from_file(_arg0, _arg1)
}

func (i image) SetFromGIconImage(icon gio.Icon) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.GIcon    // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_image_set_from_gicon(_arg0, _arg1)
}

func (i image) SetFromIconNameImage(iconName string) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_image_set_from_icon_name(_arg0, _arg1)
}

func (i image) SetFromPaintableImage(paintable gdk.Paintable) {
	var _arg0 *C.GtkImage     // out
	var _arg1 *C.GdkPaintable // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_image_set_from_paintable(_arg0, _arg1)
}

func (i image) SetFromPixbufImage(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkImage  // out
	var _arg1 *C.GdkPixbuf // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_image_set_from_pixbuf(_arg0, _arg1)
}

func (i image) SetFromResourceImage(resourcePath string) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_image_set_from_resource(_arg0, _arg1)
}

func (i image) SetIconSizeImage(iconSize IconSize) {
	var _arg0 *C.GtkImage   // out
	var _arg1 C.GtkIconSize // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkIconSize)(iconSize)

	C.gtk_image_set_icon_size(_arg0, _arg1)
}

func (i image) SetPixelSizeImage(pixelSize int) {
	var _arg0 *C.GtkImage // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(pixelSize)

	C.gtk_image_set_pixel_size(_arg0, _arg1)
}

func (s image) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s image) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s image) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s image) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s image) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s image) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s image) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b image) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// InfoBar: `GtkInfoBar` can be show messages to the user without a dialog.
//
// !An example GtkInfoBar (info-bar.png)
//
// It is often temporarily shown at the top or bottom of a document. In contrast
// to [class@Gtk.Dialog], which has an action area at the bottom, `GtkInfoBar`
// has an action area at the side.
//
// The API of `GtkInfoBar` is very similar to `GtkDialog`, allowing you to add
// buttons to the action area with [method@Gtk.InfoBar.add_button] or
// [ctor@Gtk.InfoBar.new_with_buttons]. The sensitivity of action widgets can be
// controlled with [method@Gtk.InfoBar.set_response_sensitive].
//
// To add widgets to the main content area of a `GtkInfoBar`, use
// [method@Gtk.InfoBar.add_child].
//
// Similar to [class@Gtk.MessageDialog], the contents of a `GtkInfoBar` can by
// classified as error message, warning, informational message, etc, by using
// [method@Gtk.InfoBar.set_message_type]. GTK may use the message type to
// determine how the message is displayed.
//
// A simple example for using a `GtkInfoBar`: `c GtkWidget *message_label;
// GtkWidget *widget; GtkWidget *grid; GtkInfoBar *bar;
//
// // set up info bar widget = gtk_info_bar_new (); bar = GTK_INFO_BAR (widget);
// // grid = gtk_grid_new ();
//
// message_label = gtk_label_new (""); gtk_info_bar_add_child (bar,
// message_label); gtk_info_bar_add_button (bar, _("_OK"), GTK_RESPONSE_OK);
// g_signal_connect (bar, "response", G_CALLBACK (gtk_widget_hide), NULL);
// gtk_grid_attach (GTK_GRID (grid), widget, 0, 2, 1, 1);
//
// // ...
//
// // show an error message gtk_label_set_text (GTK_LABEL (message_label), "An
// // error occurred!"); gtk_info_bar_set_message_type (bar, GTK_MESSAGE_ERROR);
// // gtk_widget_show (bar); `
//
//
// GtkInfoBar as GtkBuildable
//
// The `GtkInfoBar` implementation of the `GtkBuildable` interface exposes the
// content area and action area as internal children with the names
// content_area and action_area.
//
// `GtkInfoBar` supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The response attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area).
//
//
// CSS nodes
//
// `GtkInfoBar` has a single CSS node with name infobar. The node may get one of
// the style classes .info, .warning, .error or .question, depending on the
// message type. If the info bar shows a close button, that button will have the
// .close style class applied.
type InfoBar interface {
	Widget

	// AddActionWidgetInfoBar: add an activatable widget to the action area of a
	// `GtkInfoBar`.
	//
	// This also connects a signal handler that will emit the
	// [signal@Gtk.InfoBar::response] signal on the message area when the widget
	// is activated. The widget is appended to the end of the message areas
	// action area.
	AddActionWidgetInfoBar(child Widget, responseId int)
	// AddButtonInfoBar adds a button with the given text.
	//
	// Clicking the button will emit the [signal@Gtk.InfoBar::response] signal
	// with the given response_id. The button is appended to the end of the info
	// bars's action area. The button widget is returned, but usually you don't
	// need it.
	AddButtonInfoBar(buttonText string, responseId int) Button
	// AddChildInfoBar adds a widget to the content area of the info bar.
	AddChildInfoBar(widget Widget)
	// MessageType returns the message type of the message area.
	MessageType() MessageType
	// Revealed returns whether the info bar is currently revealed.
	Revealed() bool
	// ShowCloseButton returns whether the widget will display a standard close
	// button.
	ShowCloseButton() bool
	// RemoveActionWidgetInfoBar removes a widget from the action area of
	// @info_bar.
	//
	// The widget must have been put there by a call to
	// [method@Gtk.InfoBar.add_action_widget] or
	// [method@Gtk.InfoBar.add_button].
	RemoveActionWidgetInfoBar(widget Widget)
	// RemoveChildInfoBar removes a widget from the content area of the info
	// bar.
	RemoveChildInfoBar(widget Widget)
	// ResponseInfoBar emits the response signal with the given @response_id.
	ResponseInfoBar(responseId int)
	// SetDefaultResponseInfoBar sets the last widget in the info bars action
	// area with the given response_id as the default widget for the dialog.
	//
	// Pressing Enter normally activates the default widget.
	//
	// Note that this function currently requires @info_bar to be added to a
	// widget hierarchy.
	SetDefaultResponseInfoBar(responseId int)
	// SetMessageTypeInfoBar sets the message type of the message area.
	//
	// GTK uses this type to determine how the message is displayed.
	SetMessageTypeInfoBar(messageType MessageType)
	// SetResponseSensitiveInfoBar sets the sensitivity of action widgets for
	// @response_id.
	//
	// Calls `gtk_widget_set_sensitive (widget, setting)` for each widget in the
	// info barss action area with the given @response_id. A convenient way to
	// sensitize/desensitize buttons.
	SetResponseSensitiveInfoBar(responseId int, setting bool)
	// SetRevealedInfoBar sets whether the `GtkInfoBar` is revealed.
	//
	// Changing this will make @info_bar reveal or conceal itself via a sliding
	// transition.
	//
	// Note: this does not show or hide @info_bar in the
	// [property@Gtk.Widget:visible] sense, so revealing has no effect if
	// [property@Gtk.Widget:visible] is false.
	SetRevealedInfoBar(revealed bool)
	// SetShowCloseButtonInfoBar: if true, a standard close button is shown.
	//
	// When clicked it emits the response GTK_RESPONSE_CLOSE.
	SetShowCloseButtonInfoBar(setting bool)
}

// infoBar implements the InfoBar class.
type infoBar struct {
	Widget
}

// WrapInfoBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapInfoBar(obj *externglib.Object) InfoBar {
	return infoBar{
		Widget: WrapWidget(obj),
	}
}

func marshalInfoBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInfoBar(obj), nil
}

// NewInfoBar creates a new `GtkInfoBar` object.
func NewInfoBar() InfoBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_info_bar_new()

	var _infoBar InfoBar // out

	_infoBar = WrapInfoBar(externglib.Take(unsafe.Pointer(_cret)))

	return _infoBar
}

func (i infoBar) AddActionWidgetInfoBar(child Widget, responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.int)(responseId)

	C.gtk_info_bar_add_action_widget(_arg0, _arg1, _arg2)
}

func (i infoBar) AddButtonInfoBar(buttonText string, responseId int) Button {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.char       // out
	var _arg2 C.int         // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(responseId)

	_cret = C.gtk_info_bar_add_button(_arg0, _arg1, _arg2)

	var _button Button // out

	_button = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

	return _button
}

func (i infoBar) AddChildInfoBar(widget Widget) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_add_child(_arg0, _arg1)
}

func (i infoBar) MessageType() MessageType {
	var _arg0 *C.GtkInfoBar    // out
	var _cret C.GtkMessageType // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_message_type(_arg0)

	var _messageType MessageType // out

	_messageType = MessageType(_cret)

	return _messageType
}

func (i infoBar) Revealed() bool {
	var _arg0 *C.GtkInfoBar // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_revealed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i infoBar) ShowCloseButton() bool {
	var _arg0 *C.GtkInfoBar // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_show_close_button(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i infoBar) RemoveActionWidgetInfoBar(widget Widget) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_remove_action_widget(_arg0, _arg1)
}

func (i infoBar) RemoveChildInfoBar(widget Widget) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_remove_child(_arg0, _arg1)
}

func (i infoBar) ResponseInfoBar(responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.int         // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(responseId)

	C.gtk_info_bar_response(_arg0, _arg1)
}

func (i infoBar) SetDefaultResponseInfoBar(responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.int         // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(responseId)

	C.gtk_info_bar_set_default_response(_arg0, _arg1)
}

func (i infoBar) SetMessageTypeInfoBar(messageType MessageType) {
	var _arg0 *C.GtkInfoBar    // out
	var _arg1 C.GtkMessageType // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkMessageType)(messageType)

	C.gtk_info_bar_set_message_type(_arg0, _arg1)
}

func (i infoBar) SetResponseSensitiveInfoBar(responseId int, setting bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.int         // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(responseId)
	if setting {
		_arg2 = C.TRUE
	}

	C.gtk_info_bar_set_response_sensitive(_arg0, _arg1, _arg2)
}

func (i infoBar) SetRevealedInfoBar(revealed bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if revealed {
		_arg1 = C.TRUE
	}

	C.gtk_info_bar_set_revealed(_arg0, _arg1)
}

func (i infoBar) SetShowCloseButtonInfoBar(setting bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_info_bar_set_show_close_button(_arg0, _arg1)
}

func (s infoBar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s infoBar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s infoBar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s infoBar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s infoBar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s infoBar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s infoBar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b infoBar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// KeyvalTrigger: a `GtkShortcutTrigger` that triggers when a specific keyval
// and modifiers are pressed.
type KeyvalTrigger interface {

	// Keyval gets the keyval that must be pressed to succeed triggering @self.
	Keyval() uint
	// Modifiers gets the modifiers that must be present to succeed triggering
	// @self.
	Modifiers() gdk.ModifierType
}

// keyvalTrigger implements the KeyvalTrigger class.
type keyvalTrigger struct {
	ShortcutTrigger
}

// WrapKeyvalTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapKeyvalTrigger(obj *externglib.Object) KeyvalTrigger {
	return keyvalTrigger{
		ShortcutTrigger: WrapShortcutTrigger(obj),
	}
}

func marshalKeyvalTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapKeyvalTrigger(obj), nil
}

// NewKeyvalTrigger creates a `GtkShortcutTrigger` that will trigger whenever
// the key with the given @keyval and @modifiers is pressed.
func NewKeyvalTrigger(keyval uint, modifiers gdk.ModifierType) KeyvalTrigger {
	var _arg1 C.guint               // out
	var _arg2 C.GdkModifierType     // out
	var _cret *C.GtkShortcutTrigger // in

	_arg1 = (C.guint)(keyval)
	_arg2 = (C.GdkModifierType)(modifiers)

	_cret = C.gtk_keyval_trigger_new(_arg1, _arg2)

	var _keyvalTrigger KeyvalTrigger // out

	_keyvalTrigger = WrapKeyvalTrigger(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _keyvalTrigger
}

func (s keyvalTrigger) Keyval() uint {
	var _arg0 *C.GtkKeyvalTrigger // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkKeyvalTrigger)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_keyval_trigger_get_keyval(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s keyvalTrigger) Modifiers() gdk.ModifierType {
	var _arg0 *C.GtkKeyvalTrigger // out
	var _cret C.GdkModifierType   // in

	_arg0 = (*C.GtkKeyvalTrigger)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_keyval_trigger_get_modifiers(_arg0)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// Label: the `GtkLabel` widget displays a small amount of text.
//
// As the name implies, most labels are used to label another widget such as a
// [class@Button].
//
// !An example GtkLabel (label.png)
//
//
// CSS nodes
//
// ` label  [selection]  [link]   [link] `
//
// `GtkLabel` has a single CSS node with the name label. A wide variety of style
// classes may be applied to labels, such as .title, .subtitle, .dim-label, etc.
// In the `GtkShortcutsWindow`, labels are used with the .keycap style class.
//
// If the label has a selection, it gets a subnode with name selection.
//
// If the label has links, there is one subnode per link. These subnodes carry
// the link or visited state depending on whether they have been visited. In
// this case, label node also gets a .link style class.
//
//
// GtkLabel as GtkBuildable
//
// The GtkLabel implementation of the GtkBuildable interface supports a custom
// <attributes> element, which supports any number of <attribute> elements. The
// <attribute> element has attributes named name, value, start and end
// and allows you to specify [struct@Pango.Attribute] values for this label.
//
// An example of a UI definition fragment specifying Pango attributes: `xml
// <object class="GtkLabel"> <attributes> <attribute name="weight"
// value="PANGO_WEIGHT_BOLD"/> <attribute name="background" value="red"
// start="5" end="10"/> </attributes> </object> `
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
//
// Accessibility
//
// `GtkLabel` uses the K_ACCESSIBLE_ROLE_LABEL role.
//
//
// Mnemonics
//
// Labels may contain mnemonics. Mnemonics are underlined characters in the
// label, used for keyboard navigation. Mnemonics are created by providing a
// string with an underscore before the mnemonic character, such as `"_File"`,
// to the functions [ctor@Gtk.Label.new_with_mnemonic] or
// [method@Gtk.Label.set_text_with_mnemonic].
//
// Mnemonics automatically activate any activatable widget the label is inside,
// such as a [class@Gtk.Button]; if the label is not inside the mnemonics
// target widget, you have to tell the label about the target using
// [class@Gtk.Label.set_mnemonic_widget]. Heres a simple example where the
// label is inside a button:
//
// `c // Pressing Alt+H will activate this button GtkWidget *button =
// gtk_button_new (); GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_button_set_child (GTK_BUTTON (button), label); `
//
// Theres a convenience function to create buttons with a mnemonic label
// already inside:
//
// `c // Pressing Alt+H will activate this button GtkWidget *button =
// gtk_button_new_with_mnemonic ("_Hello"); `
//
// To create a mnemonic for a widget alongside the label, such as a
// [class@Gtk.Entry], you have to point the label at the entry with
// [method@Gtk.Label.set_mnemonic_widget]:
//
// `c // Pressing Alt+H will focus the entry GtkWidget *entry = gtk_entry_new
// (); GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry); `
//
// Markup (styled text)
//
// To make it easy to format text in a label (changing colors, fonts, etc.),
// label text can be provided in a simple markup format:
//
// Heres how to create a label with a small font: `c GtkWidget *label =
// gtk_label_new (NULL); gtk_label_set_markup (GTK_LABEL (label), "<small>Small
// text</small>"); `
//
// (See the Pango manual for complete documentation] of available tags,
// [func@Pango.parse_markup])
//
// The markup passed to gtk_label_set_markup() must be valid; for example,
// literal <, > and & characters must be escaped as &lt;, &gt;, and &amp;. If
// you pass text obtained from the user, file, or a network to
// [method@Gtk.Label.set_markup], youll want to escape it with
// g_markup_escape_text() or g_markup_printf_escaped().
//
// Markup strings are just a convenient way to set the [struct@Pango.AttrList]
// on a label; [method@Gtk.Label.set_attributes] may be a simpler way to set
// attributes in some cases. Be careful though; [struct@Pango.AttrList] tends to
// cause internationalization problems, unless youre applying attributes to the
// entire string (i.e. unless you set the range of each attribute to [0,
// G_MAXINT)). The reason is that specifying the start_index and end_index for a
// [struct@Pango.Attribute] requires knowledge of the exact string being
// displayed, so translations will cause problems.
//
//
// Selectable labels
//
// Labels can be made selectable with [method@Gtk.Label.set_selectable].
// Selectable labels allow the user to copy the label contents to the clipboard.
// Only labels that contain useful-to-copy information  such as error messages
//  should be made selectable.
//
//
// Text layout
//
// A label can contain any number of paragraphs, but will have performance
// problems if it contains more than a small number. Paragraphs are separated by
// newlines or other paragraph separators understood by Pango.
//
// Labels can automatically wrap text if you call [method@Gtk.Label.set_wrap].
//
// [method@Gtk.Label.set_justify] sets how the lines in a label align with one
// another. If you want to set how the label as a whole aligns in its available
// space, see the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
// properties.
//
// The [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
// properties can be used to control the size allocation of ellipsized or
// wrapped labels. For ellipsizing labels, if either is specified (and less than
// the actual text size), it is used as the minimum width, and the actual text
// size is used as the natural width of the label. For wrapping labels,
// width-chars is used as the minimum width, if specified, and max-width-chars
// is used as the natural width. Even if max-width-chars specified, wrapping
// labels will be rewrapped to use all of the available width.
//
//
// Links
//
// GTK supports markup for clickable hyperlinks in addition to regular Pango
// markup. The markup for links is borrowed from HTML, using the `<a>` with
// href, title and class attributes. GTK renders links similar to the way
// they appear in web browsers, with colored, underlined text. The title
// attribute is displayed as a tooltip on the link. The class attribute is
// used as style class on the CSS node for the link.
//
// An example looks like this:
//
// `c const char *text = "Go to the" "<a href=\"http://www.gtk.org
// title=\"&lt;i&gt;Our&lt;/i&gt; website\">" "GTK website</a> for more...";
// GtkWidget *label = gtk_label_new (NULL); gtk_label_set_markup (GTK_LABEL
// (label), text); `
//
// It is possible to implement custom handling for links and their tooltips with
// the [signal@Gtk.Label::activate-link] signal and the
// [method@Gtk.Label.get_current_uri] function.
type Label interface {
	Widget

	// Attributes gets the labels attribute list.
	//
	// This is the [struct@Pango.AttrList] that was set on the label using
	// [method@Gtk.Label.set_attributes], if any. This function does not reflect
	// attributes that come from the labels markup (see
	// [method@Gtk.Label.set_markup]). If you want to get the effective
	// attributes for the label, use `pango_layout_get_attribute
	// (gtk_label_get_layout (self))`.
	Attributes() *pango.AttrList
	// CurrentURI returns the URI for the currently active link in the label.
	//
	// The active link is the one under the mouse pointer or, in a selectable
	// label, the link in which the text cursor is currently positioned.
	//
	// This function is intended for use in a [signal@Gtk.Label::activate-link]
	// handler or for use in a [signal@Gtk.Widget::query-tooltip] handler.
	CurrentURI() string
	// Ellipsize returns the ellipsizing position of the label.
	//
	// See [method@Gtk.Label.set_ellipsize].
	Ellipsize() pango.EllipsizeMode
	// ExtraMenu gets the extra menu model of @label.
	//
	// See [method@Gtk.Label.set_extra_menu].
	ExtraMenu() gio.MenuModel
	// Justify returns the justification of the label.
	//
	// See [method@Gtk.Label.set_justify].
	Justify() Justification
	// Label fetches the text from a label.
	//
	// The returned text includes any embedded underlines indicating mnemonics
	// and Pango markup. (See [method@Gtk.Label.get_text]).
	Label() string
	// Layout gets the `PangoLayout` used to display the label.
	//
	// The layout is useful to e.g. convert text positions to pixel positions,
	// in combination with [method@Gtk.Label.get_layout_offsets]. The returned
	// layout is owned by the @label so need not be freed by the caller. The
	// @label is free to recreate its layout at any time, so it should be
	// considered read-only.
	Layout() pango.Layout
	// LayoutOffsets obtains the coordinates where the label will draw its
	// `PangoLayout`.
	//
	// The coordinates are useful to convert mouse events into coordinates
	// inside the [class@Pango.Layout], e.g. to take some action if some part of
	// the label is clicked. Remember when using the [class@Pango.Layout]
	// functions you need to convert to and from pixels using PANGO_PIXELS() or
	// [constant@Pango.SCALE].
	LayoutOffsets() (x int, y int)
	// Lines gets the number of lines to which an ellipsized, wrapping label
	// should be limited.
	//
	// See [method@Gtk.Label.set_lines].
	Lines() int
	// MaxWidthChars retrieves the desired maximum width of @label, in
	// characters.
	//
	// See [method@Gtk.Label.set_width_chars].
	MaxWidthChars() int
	// MnemonicKeyval: return the mnemonic accelerator.
	//
	// If the label has been set so that it has a mnemonic key this function
	// returns the keyval used for the mnemonic accelerator. If there is no
	// mnemonic set up it returns `GDK_KEY_VoidSymbol`.
	MnemonicKeyval() uint
	// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut)
	// of this label.
	//
	// See [method@Gtk.Label.set_mnemonic_widget].
	MnemonicWidget() Widget
	// Selectable returns whether the label is selectable.
	Selectable() bool
	// SelectionBounds gets the selected range of characters in the label.
	SelectionBounds() (start int, end int, ok bool)
	// SingleLineMode returns whether the label is in single line mode.
	SingleLineMode() bool
	// Text fetches the text from a label.
	//
	// The returned text is as it appears on screen. This does not include any
	// embedded underlines indicating mnemonics or Pango markup. (See
	// [method@Gtk.Label.get_label])
	Text() string
	// UseMarkup returns whether the labels text is interpreted as Pango
	// markup.
	//
	// See [method@Gtk.Label.set_use_markup].
	UseMarkup() bool
	// UseUnderline returns whether an embedded underlines in the label indicate
	// mnemonics.
	//
	// See [method@Gtk.Label.set_use_underline].
	UseUnderline() bool
	// WidthChars retrieves the desired width of @label, in characters.
	//
	// See [method@Gtk.Label.set_width_chars].
	WidthChars() int
	// Wrap returns whether lines in the label are automatically wrapped.
	//
	// See [method@Gtk.Label.set_wrap].
	Wrap() bool
	// WrapMode returns line wrap mode used by the label.
	//
	// See [method@Gtk.Label.set_wrap_mode].
	WrapMode() pango.WrapMode
	// Xalign gets the `xalign` of the label.
	//
	// See the [property@Gtk.Label:xalign] property.
	Xalign() float32
	// Yalign gets the `yalign` of the label.
	//
	// See the [property@Gtk.Label:yalign] property.
	Yalign() float32
	// SelectRegionLabel selects a range of characters in the label, if the
	// label is selectable.
	//
	// See [method@Gtk.Label.set_selectable]. If the label is not selectable,
	// this function has no effect. If @start_offset or @end_offset are -1, then
	// the end of the label will be substituted.
	SelectRegionLabel(startOffset int, endOffset int)
	// SetAttributesLabel: apply attributes to the label text.
	//
	// The attributes set with this function will be applied and merged with any
	// other attributes previously effected by way of the
	// [property@Gtk.Label:use-underline] or [property@Gtk.Label:use-markup]
	// properties. While it is not recommended to mix markup strings with
	// manually set attributes, if you must; know that the attributes will be
	// applied to the label after the markup string is parsed.
	SetAttributesLabel(attrs *pango.AttrList)
	// SetEllipsizeLabel sets the mode used to ellipsizei the text.
	//
	// The text will be ellipsized if there is not enough space to render the
	// entire string.
	SetEllipsizeLabel(mode pango.EllipsizeMode)
	// SetExtraMenuLabel sets a menu model to add when constructing the context
	// menu for @label.
	SetExtraMenuLabel(model gio.MenuModel)
	// SetJustifyLabel sets the alignment of the lines in the text of the label
	// relative to each other.
	//
	// GTK_JUSTIFY_LEFT is the default value when the widget is first created
	// with [ctor@Gtk.Label.new]. If you instead want to set the alignment of
	// the label as a whole, use [method@Gtk.Widget.set_halign] instead.
	// [method@Gtk.Label.set_justify] has no effect on labels containing only a
	// single line.
	SetJustifyLabel(jtype Justification)
	// SetLabelLabel sets the text of the label.
	//
	// The label is interpreted as including embedded underlines and/or Pango
	// markup depending on the values of the [property@Gtk.Label:use-underline]
	// and [property@Gtk.Label:use-markup] properties.
	SetLabelLabel(str string)
	// SetLinesLabel sets the number of lines to which an ellipsized, wrapping
	// label should be limited.
	//
	// This has no effect if the label is not wrapping or ellipsized. Set this
	// to -1 if you dont want to limit the number of lines.
	SetLinesLabel(lines int)
	// SetMarkupLabel sets the labels text and attributes from markup.
	//
	// The string must be marked up with Pango markup (see
	// [func@Pango.parse_markup]).
	//
	// If the @str is external data, you may need to escape it with
	// g_markup_escape_text() or g_markup_printf_escaped():
	//
	// `c GtkWidget *self = gtk_label_new (NULL); const char *str = "...";
	// const char *format = "<span style=\"italic\">\s</span>"; char *markup;
	//
	// markup = g_markup_printf_escaped (format, str); gtk_label_set_markup
	// (GTK_LABEL (self), markup); g_free (markup); `
	//
	// This function will set the [property@Gtk.Label:use-markup] property to
	// true as a side effect.
	//
	// If you set the label contents using the [property@Gtk.Label:label]
	// property you should also ensure that you set the
	// [property@Gtk.Label:use-markup] property accordingly.
	//
	// See also: [method@Gtk.Label.set_text]
	SetMarkupLabel(str string)
	// SetMarkupWithMnemonicLabel sets the labels text, attributes and mnemonic
	// from markup.
	//
	// Parses @str which is marked up with Pango markup (see
	// [func@Pango.parse_markup]), setting the labels text and attribute list
	// based on the parse results. If characters in @str are preceded by an
	// underscore, they are underlined indicating that they represent a keyboard
	// accelerator called a mnemonic.
	//
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using method@Gtk.Label.set_mnemonic_widget].
	SetMarkupWithMnemonicLabel(str string)
	// SetMaxWidthCharsLabel sets the desired maximum width in characters of
	// @label to @n_chars.
	SetMaxWidthCharsLabel(nChars int)
	// SetMnemonicWidgetLabel: associate the label with its mnemonic target.
	//
	// If the label has been set so that it has a mnemonic key (using i.e.
	// [method@Gtk.Label.set_markup_with_mnemonic],
	// [method@Gtk.Label.set_text_with_mnemonic],
	// [ctor@Gtk.Label.new_with_mnemonic] or the
	// [property@Gtk.Label:use_underline] property) the label can be associated
	// with a widget that is the target of the mnemonic. When the label is
	// inside a widget (like a [class@Gtk.Button] or a [class@Gtk.Notebook] tab)
	// it is automatically associated with the correct widget, but sometimes
	// (i.e. when the target is a [class@Gtk.Entry] next to the label) you need
	// to set it explicitly using this function.
	//
	// The target widget will be accelerated by emitting the
	// [signal@GtkWidget::mnemonic-activate] signal on it. The default handler
	// for this signal will activate the widget if there are no mnemonic
	// collisions and toggle focus between the colliding widgets otherwise.
	SetMnemonicWidgetLabel(widget Widget)
	// SetSelectableLabel makes text in the label selectable.
	//
	// Selectable labels allow the user to select text from the label, for
	// copy-and-paste.
	SetSelectableLabel(setting bool)
	// SetSingleLineModeLabel sets whether the label is in single line mode.
	SetSingleLineModeLabel(singleLineMode bool)
	// SetTextLabel sets the text within the `GtkLabel` widget.
	//
	// It overwrites any text that was there before.
	//
	// This function will clear any previously set mnemonic accelerators, and
	// set the [property@Gtk.Label:use-underline property] to false as a side
	// effect.
	//
	// This function will set the [property@Gtk.Label:use-markup] property to
	// false as a side effect.
	//
	// See also: [method@Gtk.Label.set_markup]
	SetTextLabel(str string)
	// SetTextWithMnemonicLabel sets the labels text from the string @str.
	//
	// If characters in @str are preceded by an underscore, they are underlined
	// indicating that they represent a keyboard accelerator called a mnemonic.
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using
	// [method@Gtk.Label.set_mnemonic_widget].
	SetTextWithMnemonicLabel(str string)
	// SetUseMarkupLabel sets whether the text of the label contains markup.
	//
	// See [method@Gtk.Label.set_markup].
	SetUseMarkupLabel(setting bool)
	// SetUseUnderlineLabel sets whether underlines in the text indicate
	// mnemonics.
	SetUseUnderlineLabel(setting bool)
	// SetWidthCharsLabel sets the desired width in characters of @label to
	// @n_chars.
	SetWidthCharsLabel(nChars int)
	// SetWrapLabel toggles line wrapping within the `GtkLabel` widget.
	//
	// true makes it break lines if text exceeds the widgets size. false lets
	// the text get cut off by the edge of the widget if it exceeds the widget
	// size.
	//
	// Note that setting line wrapping to true does not make the label wrap at
	// its parent containers width, because GTK widgets conceptually cant make
	// their requisition depend on the parent containers size. For a label that
	// wraps at a specific position, set the labels width using
	// [method@Gtk.Widget.set_size_request].
	SetWrapLabel(wrap bool)
	// SetWrapModeLabel controls how line wrapping is done.
	//
	// This only affects the label if line wrapping is on. (See
	// [method@Gtk.Label.set_wrap]) The default is PANGO_WRAP_WORD which means
	// wrap on word boundaries.
	SetWrapModeLabel(wrapMode pango.WrapMode)
	// SetXalignLabel sets the `xalign` of the label.
	//
	// See the [property@Gtk.Label:xalign] property.
	SetXalignLabel(xalign float32)
	// SetYalignLabel sets the `yalign` of the label.
	//
	// See the [property@Gtk.Label:yalign] property.
	SetYalignLabel(yalign float32)
}

// label implements the Label class.
type label struct {
	Widget
}

// WrapLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapLabel(obj *externglib.Object) Label {
	return label{
		Widget: WrapWidget(obj),
	}
}

func marshalLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLabel(obj), nil
}

// NewLabel creates a new label with the given text inside it.
//
// You can pass nil to get an empty label widget.
func NewLabel(str string) Label {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_label_new(_arg1)

	var _label Label // out

	_label = WrapLabel(externglib.Take(unsafe.Pointer(_cret)))

	return _label
}

// NewLabelWithMnemonic creates a new `GtkLabel`, containing the text in @str.
//
// If characters in @str are preceded by an underscore, they are underlined. If
// you need a literal underscore character in a label, use '__' (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. The mnemonic key can be used to activate
// another widget, chosen automatically, or explicitly using
// [method@Gtk.Label.set_mnemonic_widget].
//
// If [method@Gtk.Label.set_mnemonic_widget] is not called, then the first
// activatable ancestor of the `GtkLabel` will be chosen as the mnemonic widget.
// For instance, if the label is inside a button or menu item, the button or
// menu item will automatically become the mnemonic widget and be activated by
// the mnemonic.
func NewLabelWithMnemonic(str string) Label {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_label_new_with_mnemonic(_arg1)

	var _label Label // out

	_label = WrapLabel(externglib.Take(unsafe.Pointer(_cret)))

	return _label
}

func (s label) Attributes() *pango.AttrList {
	var _arg0 *C.GtkLabel      // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_attributes(_arg0)

	var _attrList *pango.AttrList // out

	_attrList = pango.WrapAttrList(unsafe.Pointer(_cret))

	return _attrList
}

func (s label) CurrentURI() string {
	var _arg0 *C.GtkLabel // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_current_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s label) Ellipsize() pango.EllipsizeMode {
	var _arg0 *C.GtkLabel          // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_ellipsize(_arg0)

	var _ellipsizeMode pango.EllipsizeMode // out

	_ellipsizeMode = pango.EllipsizeMode(_cret)

	return _ellipsizeMode
}

func (s label) ExtraMenu() gio.MenuModel {
	var _arg0 *C.GtkLabel   // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_extra_menu(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (s label) Justify() Justification {
	var _arg0 *C.GtkLabel        // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_justify(_arg0)

	var _justification Justification // out

	_justification = Justification(_cret)

	return _justification
}

func (s label) Label() string {
	var _arg0 *C.GtkLabel // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s label) Layout() pango.Layout {
	var _arg0 *C.GtkLabel    // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_layout(_arg0)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

func (s label) LayoutOffsets() (x int, y int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	C.gtk_label_get_layout_offsets(_arg0, &_arg1, &_arg2)

	var _x int // out
	var _y int // out

	_x = (int)(_arg1)
	_y = (int)(_arg2)

	return _x, _y
}

func (s label) Lines() int {
	var _arg0 *C.GtkLabel // out
	var _cret C.int       // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_lines(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s label) MaxWidthChars() int {
	var _arg0 *C.GtkLabel // out
	var _cret C.int       // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_max_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s label) MnemonicKeyval() uint {
	var _arg0 *C.GtkLabel // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_mnemonic_keyval(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s label) MnemonicWidget() Widget {
	var _arg0 *C.GtkLabel  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_mnemonic_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s label) Selectable() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_selectable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s label) SelectionBounds() (start int, end int, ok bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_selection_bounds(_arg0, &_arg1, &_arg2)

	var _start int // out
	var _end int   // out
	var _ok bool   // out

	_start = (int)(_arg1)
	_end = (int)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

func (s label) SingleLineMode() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_single_line_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s label) Text() string {
	var _arg0 *C.GtkLabel // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s label) UseMarkup() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_use_markup(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s label) UseUnderline() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s label) WidthChars() int {
	var _arg0 *C.GtkLabel // out
	var _cret C.int       // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s label) Wrap() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_wrap(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s label) WrapMode() pango.WrapMode {
	var _arg0 *C.GtkLabel     // out
	var _cret C.PangoWrapMode // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_wrap_mode(_arg0)

	var _wrapMode pango.WrapMode // out

	_wrapMode = pango.WrapMode(_cret)

	return _wrapMode
}

func (s label) Xalign() float32 {
	var _arg0 *C.GtkLabel // out
	var _cret C.float     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_xalign(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (s label) Yalign() float32 {
	var _arg0 *C.GtkLabel // out
	var _cret C.float     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_label_get_yalign(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (s label) SelectRegionLabel(startOffset int, endOffset int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // out
	var _arg2 C.int       // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(startOffset)
	_arg2 = (C.int)(endOffset)

	C.gtk_label_select_region(_arg0, _arg1, _arg2)
}

func (s label) SetAttributesLabel(attrs *pango.AttrList) {
	var _arg0 *C.GtkLabel      // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_label_set_attributes(_arg0, _arg1)
}

func (s label) SetEllipsizeLabel(mode pango.EllipsizeMode) {
	var _arg0 *C.GtkLabel          // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_label_set_ellipsize(_arg0, _arg1)
}

func (s label) SetExtraMenuLabel(model gio.MenuModel) {
	var _arg0 *C.GtkLabel   // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_label_set_extra_menu(_arg0, _arg1)
}

func (s label) SetJustifyLabel(jtype Justification) {
	var _arg0 *C.GtkLabel        // out
	var _arg1 C.GtkJustification // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkJustification)(jtype)

	C.gtk_label_set_justify(_arg0, _arg1)
}

func (s label) SetLabelLabel(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_label(_arg0, _arg1)
}

func (s label) SetLinesLabel(lines int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(lines)

	C.gtk_label_set_lines(_arg0, _arg1)
}

func (s label) SetMarkupLabel(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_markup(_arg0, _arg1)
}

func (s label) SetMarkupWithMnemonicLabel(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_markup_with_mnemonic(_arg0, _arg1)
}

func (s label) SetMaxWidthCharsLabel(nChars int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(nChars)

	C.gtk_label_set_max_width_chars(_arg0, _arg1)
}

func (s label) SetMnemonicWidgetLabel(widget Widget) {
	var _arg0 *C.GtkLabel  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_label_set_mnemonic_widget(_arg0, _arg1)
}

func (s label) SetSelectableLabel(setting bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_selectable(_arg0, _arg1)
}

func (s label) SetSingleLineModeLabel(singleLineMode bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if singleLineMode {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_single_line_mode(_arg0, _arg1)
}

func (s label) SetTextLabel(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_text(_arg0, _arg1)
}

func (s label) SetTextWithMnemonicLabel(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_text_with_mnemonic(_arg0, _arg1)
}

func (s label) SetUseMarkupLabel(setting bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_use_markup(_arg0, _arg1)
}

func (s label) SetUseUnderlineLabel(setting bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_use_underline(_arg0, _arg1)
}

func (s label) SetWidthCharsLabel(nChars int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(nChars)

	C.gtk_label_set_width_chars(_arg0, _arg1)
}

func (s label) SetWrapLabel(wrap bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if wrap {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_wrap(_arg0, _arg1)
}

func (s label) SetWrapModeLabel(wrapMode pango.WrapMode) {
	var _arg0 *C.GtkLabel     // out
	var _arg1 C.PangoWrapMode // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.PangoWrapMode)(wrapMode)

	C.gtk_label_set_wrap_mode(_arg0, _arg1)
}

func (s label) SetXalignLabel(xalign float32) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.float     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(xalign)

	C.gtk_label_set_xalign(_arg0, _arg1)
}

func (s label) SetYalignLabel(yalign float32) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.float     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(yalign)

	C.gtk_label_set_yalign(_arg0, _arg1)
}

func (s label) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s label) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s label) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s label) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s label) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s label) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s label) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b label) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// LayoutChild: `GtkLayoutChild` is the base class for objects that are meant to
// hold layout properties.
//
// If a `GtkLayoutManager` has per-child properties, like their packing type, or
// the horizontal and vertical span, or the icon name, then the layout manager
// should use a `GtkLayoutChild` implementation to store those properties.
//
// A `GtkLayoutChild` instance is only ever valid while a widget is part of a
// layout.
type LayoutChild interface {

	// ChildWidget retrieves the `GtkWidget` associated to the given
	// @layout_child.
	ChildWidget() Widget
	// LayoutManager retrieves the `GtkLayoutManager` instance that created the
	// given @layout_child.
	LayoutManager() LayoutManager
}

// layoutChild implements the LayoutChild class.
type layoutChild struct {
	gextras.Objector
}

// WrapLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapLayoutChild(obj *externglib.Object) LayoutChild {
	return layoutChild{
		Objector: obj,
	}
}

func marshalLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLayoutChild(obj), nil
}

func (l layoutChild) ChildWidget() Widget {
	var _arg0 *C.GtkLayoutChild // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkLayoutChild)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_layout_child_get_child_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (l layoutChild) LayoutManager() LayoutManager {
	var _arg0 *C.GtkLayoutChild   // out
	var _cret *C.GtkLayoutManager // in

	_arg0 = (*C.GtkLayoutChild)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_layout_child_get_layout_manager(_arg0)

	var _layoutManager LayoutManager // out

	_layoutManager = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(LayoutManager)

	return _layoutManager
}

// LayoutManager: layout managers are delegate classes that handle the preferred
// size and the allocation of a widget.
//
// You typically subclass `GtkLayoutManager` if you want to implement a layout
// policy for the children of a widget, or if you want to determine the size of
// a widget depending on its contents.
//
// Each `GtkWidget` can only have a `GtkLayoutManager` instance associated to it
// at any given time; it is possible, though, to replace the layout manager
// instance using [method@Gtk.Widget.set_layout_manager].
//
//
// Layout properties
//
// A layout manager can expose properties for controlling the layout of each
// child, by creating an object type derived from [class@Gtk.LayoutChild] and
// installing the properties on it as normal `GObject` properties.
//
// Each `GtkLayoutChild` instance storing the layout properties for a specific
// child is created through the [method@Gtk.LayoutManager.get_layout_child]
// method; a `GtkLayoutManager` controls the creation of its `GtkLayoutChild`
// instances by overriding the GtkLayoutManagerClass.create_layout_child()
// virtual function. The typical implementation should look like:
//
// `c static GtkLayoutChild * create_layout_child (GtkLayoutManager *manager,
// GtkWidget *container, GtkWidget *child) { return g_object_new
// (your_layout_child_get_type (), "layout-manager", manager, "child-widget",
// child, NULL); } `
//
// The [property@Gtk.LayoutChild:layout-manager] and
// [property@Gtk.LayoutChild:child-widget] properties on the newly created
// `GtkLayoutChild` instance are mandatory. The `GtkLayoutManager` will cache
// the newly created `GtkLayoutChild` instance until the widget is removed from
// its parent, or the parent removes the layout manager.
//
// Each `GtkLayoutManager` instance creating a `GtkLayoutChild` should use
// [method@Gtk.LayoutManager.get_layout_child] every time it needs to query the
// layout properties; each `GtkLayoutChild` instance should call
// [method@Gtk.LayoutManager.layout_changed] every time a property is updated,
// in order to queue a new size measuring and allocation.
type LayoutManager interface {

	// AllocateLayoutManager assigns the given @width, @height, and @baseline to
	// a @widget, and computes the position and sizes of the children of the
	// @widget using the layout management policy of @manager.
	AllocateLayoutManager(widget Widget, width int, height int, baseline int)
	// LayoutChild retrieves a `GtkLayoutChild` instance for the
	// `GtkLayoutManager`, creating one if necessary.
	//
	// The @child widget must be a child of the widget using @manager.
	//
	// The `GtkLayoutChild` instance is owned by the `GtkLayoutManager`, and is
	// guaranteed to exist as long as @child is a child of the `GtkWidget` using
	// the given `GtkLayoutManager`.
	LayoutChild(child Widget) LayoutChild
	// RequestMode retrieves the request mode of @manager.
	RequestMode() SizeRequestMode
	// Widget retrieves the `GtkWidget` using the given `GtkLayoutManager`.
	Widget() Widget
	// LayoutChangedLayoutManager queues a resize on the `GtkWidget` using
	// @manager, if any.
	//
	// This function should be called by subclasses of `GtkLayoutManager` in
	// response to changes to their layout management policies.
	LayoutChangedLayoutManager()
	// MeasureLayoutManager measures the size of the @widget using @manager, for
	// the given @orientation and size.
	//
	// See the [class@Gtk.Widget] documentation on layout management for more
	// details.
	MeasureLayoutManager(widget Widget, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
}

// layoutManager implements the LayoutManager class.
type layoutManager struct {
	gextras.Objector
}

// WrapLayoutManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapLayoutManager(obj *externglib.Object) LayoutManager {
	return layoutManager{
		Objector: obj,
	}
}

func marshalLayoutManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLayoutManager(obj), nil
}

func (m layoutManager) AllocateLayoutManager(widget Widget, width int, height int, baseline int) {
	var _arg0 *C.GtkLayoutManager // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // out

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.int)(width)
	_arg3 = (C.int)(height)
	_arg4 = (C.int)(baseline)

	C.gtk_layout_manager_allocate(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (m layoutManager) LayoutChild(child Widget) LayoutChild {
	var _arg0 *C.GtkLayoutManager // out
	var _arg1 *C.GtkWidget        // out
	var _cret *C.GtkLayoutChild   // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_layout_manager_get_layout_child(_arg0, _arg1)

	var _layoutChild LayoutChild // out

	_layoutChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(LayoutChild)

	return _layoutChild
}

func (m layoutManager) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkLayoutManager  // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_layout_manager_get_request_mode(_arg0)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

func (m layoutManager) Widget() Widget {
	var _arg0 *C.GtkLayoutManager // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_layout_manager_get_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (m layoutManager) LayoutChangedLayoutManager() {
	var _arg0 *C.GtkLayoutManager // out

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))

	C.gtk_layout_manager_layout_changed(_arg0)
}

func (m layoutManager) MeasureLayoutManager(widget Widget, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	var _arg0 *C.GtkLayoutManager // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.GtkOrientation    // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in
	var _arg6 C.int               // in
	var _arg7 C.int               // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkOrientation)(orientation)
	_arg3 = (C.int)(forSize)

	C.gtk_layout_manager_measure(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6, &_arg7)

	var _minimum int         // out
	var _natural int         // out
	var _minimumBaseline int // out
	var _naturalBaseline int // out

	_minimum = (int)(_arg4)
	_natural = (int)(_arg5)
	_minimumBaseline = (int)(_arg6)
	_naturalBaseline = (int)(_arg7)

	return _minimum, _natural, _minimumBaseline, _naturalBaseline
}

// LevelBar: `GtkLevelBar` is a widget that can be used as a level indicator.
//
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
//
// !An example GtkLevelBar (levelbar.png)
//
// Use [method@Gtk.LevelBar.set_value] to set the current value, and
// [method@Gtk.LevelBar.add_offset_value] to set the value offsets at which the
// bar will be considered in a different state. GTK will add a few offsets by
// default on the level bar: GTK_LEVEL_BAR_OFFSET_LOW, GTK_LEVEL_BAR_OFFSET_HIGH
// and GTK_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK will simply clamp them to the new
// range.
//
//
// Adding a custom offset on the bar
//
// `c static GtkWidget * create_level_bar (void) { GtkWidget *widget;
// GtkLevelBar *bar;
//
//    widget = gtk_level_bar_new ();
//    bar = GTK_LEVEL_BAR (widget);
//
//    // This changes the value of the default low offset
//
//    gtk_level_bar_add_offset_value (bar,
//                                    GTK_LEVEL_BAR_OFFSET_LOW,
//                                    0.10);
//
//    // This adds a new offset to the bar; the application will
//    // be able to change its color CSS like this:
//    //
//    // levelbar block.my-offset {
//    //   background-color: magenta;
//    //   border-style: solid;
//    //   border-color: black;
//    //   border-style: 1px;
//    // }
//
//    gtk_level_bar_add_offset_value (bar, "my-offset", 0.60);
//
//    return widget;
//
// } `
//
// The default interval of values is between zero and one, but its possible to
// modify the interval using [method@Gtk.LevelBar.set_min_value] and
// [method@Gtk.LevelBar.set_max_value]. The value will be always drawn in
// proportion to the admissible interval, i.e. a value of 15 with a specified
// interval between 10 and 20 is equivalent to a value of 0.5 with an interval
// between 0 and 1. When K_LEVEL_BAR_MODE_DISCRETE is used, the bar level is
// rendered as a finite number of separated blocks instead of a single one. The
// number of blocks that will be rendered is equal to the number of units
// specified by the admissible interval.
//
// For instance, to build a bar rendered with five blocks, its sufficient to
// set the minimum value to 0 and the maximum value to 5 after changing the
// indicator mode to discrete.
//
//
// GtkLevelBar as GtkBuildable
//
// The `GtkLevelBar` implementation of the `GtkBuildable` interface supports a
// custom <offsets> element, which can contain any number of <offset> elements,
// each of which must have name and value attributes.
//
//
// CSS nodes
//
// ` levelbar[.discrete]  trough  block.filled.level-name  
// block.empty  `
//
// `GtkLevelBar` has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
//
//
// Accessibility
//
// `GtkLevelBar` uses the K_ACCESSIBLE_ROLE_METER role.
type LevelBar interface {
	Widget
	Orientable

	// AddOffsetValueLevelBar adds a new offset marker on @self at the position
	// specified by @value.
	//
	// When the bar value is in the interval topped by @value (or between @value
	// and [property@Gtk.LevelBar:max-value] in case the offset is the last one
	// on the bar) a style class named `level-`@name will be applied when
	// rendering the level bar fill.
	//
	// If another offset marker named @name exists, its value will be replaced
	// by @value.
	AddOffsetValueLevelBar(name string, value float64)
	// Inverted returns whether the levelbar is inverted.
	Inverted() bool
	// MaxValue returns the `max-value` of the `GtkLevelBar`.
	MaxValue() float64
	// MinValue returns the `min-value of the `GtkLevelBar`.
	MinValue() float64
	// Mode returns the `mode` of the `GtkLevelBar`.
	Mode() LevelBarMode
	// OffsetValue fetches the value specified for the offset marker @name in
	// @self.
	OffsetValue(name string) (float64, bool)
	// Value returns the `value` of the `GtkLevelBar`.
	Value() float64
	// RemoveOffsetValueLevelBar removes an offset marker from a `GtkLevelBar`.
	//
	// The marker must have been previously added with
	// [method@Gtk.LevelBar.add_offset_value].
	RemoveOffsetValueLevelBar(name string)
	// SetInvertedLevelBar sets whether the `GtkLevelBar` is inverted.
	SetInvertedLevelBar(inverted bool)
	// SetMaxValueLevelBar sets the `max-value` of the `GtkLevelBar`.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMaxValueLevelBar(value float64)
	// SetMinValueLevelBar sets the `min-value` of the `GtkLevelBar`.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMinValueLevelBar(value float64)
	// SetModeLevelBar sets the `mode` of the `GtkLevelBar`.
	SetModeLevelBar(mode LevelBarMode)
	// SetValueLevelBar sets the value of the `GtkLevelBar`.
	SetValueLevelBar(value float64)
}

// levelBar implements the LevelBar class.
type levelBar struct {
	Widget
}

// WrapLevelBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapLevelBar(obj *externglib.Object) LevelBar {
	return levelBar{
		Widget: WrapWidget(obj),
	}
}

func marshalLevelBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLevelBar(obj), nil
}

// NewLevelBar creates a new `GtkLevelBar`.
func NewLevelBar() LevelBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_level_bar_new()

	var _levelBar LevelBar // out

	_levelBar = WrapLevelBar(externglib.Take(unsafe.Pointer(_cret)))

	return _levelBar
}

// NewLevelBarForInterval creates a new `GtkLevelBar` for the specified
// interval.
func NewLevelBarForInterval(minValue float64, maxValue float64) LevelBar {
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _cret *C.GtkWidget // in

	_arg1 = (C.double)(minValue)
	_arg2 = (C.double)(maxValue)

	_cret = C.gtk_level_bar_new_for_interval(_arg1, _arg2)

	var _levelBar LevelBar // out

	_levelBar = WrapLevelBar(externglib.Take(unsafe.Pointer(_cret)))

	return _levelBar
}

func (s levelBar) AddOffsetValueLevelBar(name string, value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.char        // out
	var _arg2 C.double       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.double)(value)

	C.gtk_level_bar_add_offset_value(_arg0, _arg1, _arg2)
}

func (s levelBar) Inverted() bool {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_inverted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s levelBar) MaxValue() float64 {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.double       // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_max_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s levelBar) MinValue() float64 {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.double       // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_min_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s levelBar) Mode() LevelBarMode {
	var _arg0 *C.GtkLevelBar    // out
	var _cret C.GtkLevelBarMode // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_mode(_arg0)

	var _levelBarMode LevelBarMode // out

	_levelBarMode = LevelBarMode(_cret)

	return _levelBarMode
}

func (s levelBar) OffsetValue(name string) (float64, bool) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.char        // out
	var _arg2 C.double       // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_level_bar_get_offset_value(_arg0, _arg1, &_arg2)

	var _value float64 // out
	var _ok bool       // out

	_value = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

func (s levelBar) Value() float64 {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.double       // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s levelBar) RemoveOffsetValueLevelBar(name string) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_level_bar_remove_offset_value(_arg0, _arg1)
}

func (s levelBar) SetInvertedLevelBar(inverted bool) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	if inverted {
		_arg1 = C.TRUE
	}

	C.gtk_level_bar_set_inverted(_arg0, _arg1)
}

func (s levelBar) SetMaxValueLevelBar(value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(value)

	C.gtk_level_bar_set_max_value(_arg0, _arg1)
}

func (s levelBar) SetMinValueLevelBar(value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(value)

	C.gtk_level_bar_set_min_value(_arg0, _arg1)
}

func (s levelBar) SetModeLevelBar(mode LevelBarMode) {
	var _arg0 *C.GtkLevelBar    // out
	var _arg1 C.GtkLevelBarMode // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkLevelBarMode)(mode)

	C.gtk_level_bar_set_mode(_arg0, _arg1)
}

func (s levelBar) SetValueLevelBar(value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(value)

	C.gtk_level_bar_set_value(_arg0, _arg1)
}

func (s levelBar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s levelBar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s levelBar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s levelBar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s levelBar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s levelBar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s levelBar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b levelBar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o levelBar) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o levelBar) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// LinkButton: a `GtkLinkButton` is a button with a hyperlink.
//
// !An example GtkLinkButton (link-button.png)
//
// It is useful to show quick links to resources.
//
// A link button is created by calling either [ctor@Gtk.LinkButton.new] or
// [ctor@Gtk.LinkButton.new_with_label]. If using the former, the URI you pass
// to the constructor is used as a label for the widget.
//
// The URI bound to a `GtkLinkButton` can be set specifically using
// [method@Gtk.LinkButton.set_uri].
//
// By default, `GtkLinkButton` calls [func@Gtk.show_uri] when the button is
// clicked. This behaviour can be overridden by connecting to the
// [signal@Gtk.LinkButton::activate-link] signal and returning true from the
// signal handler.
//
//
// CSS nodes
//
// `GtkLinkButton` has a single CSS node with name button. To differentiate it
// from a plain `GtkButton`, it gets the .link style class.
//
//
// Accessibility
//
// `GtkLinkButton` uses the K_ACCESSIBLE_ROLE_LINK role.
type LinkButton interface {
	Button

	// URI retrieves the URI of the `GtkLinkButton`.
	URI() string
	// Visited retrieves the visited state of the `GtkLinkButton`.
	//
	// The button becomes visited when it is clicked. If the URI is changed on
	// the button, the visited state is unset again.
	//
	// The state may also be changed using [method@Gtk.LinkButton.set_visited].
	Visited() bool
	// SetURILinkButton sets @uri as the URI where the `GtkLinkButton` points.
	//
	// As a side-effect this unsets the visited state of the button.
	SetURILinkButton(uri string)
	// SetVisitedLinkButton sets the visited state of the `GtkLinkButton`.
	//
	// See [method@Gtk.LinkButton.get_visited] for more details.
	SetVisitedLinkButton(visited bool)
}

// linkButton implements the LinkButton class.
type linkButton struct {
	Button
}

// WrapLinkButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLinkButton(obj *externglib.Object) LinkButton {
	return linkButton{
		Button: WrapButton(obj),
	}
}

func marshalLinkButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLinkButton(obj), nil
}

// NewLinkButton creates a new `GtkLinkButton` with the URI as its text.
func NewLinkButton(uri string) LinkButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_link_button_new(_arg1)

	var _linkButton LinkButton // out

	_linkButton = WrapLinkButton(externglib.Take(unsafe.Pointer(_cret)))

	return _linkButton
}

// NewLinkButtonWithLabel creates a new `GtkLinkButton` containing a label.
func NewLinkButtonWithLabel(uri string, label string) LinkButton {
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_link_button_new_with_label(_arg1, _arg2)

	var _linkButton LinkButton // out

	_linkButton = WrapLinkButton(externglib.Take(unsafe.Pointer(_cret)))

	return _linkButton
}

func (l linkButton) URI() string {
	var _arg0 *C.GtkLinkButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_link_button_get_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (l linkButton) Visited() bool {
	var _arg0 *C.GtkLinkButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_link_button_get_visited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (l linkButton) SetURILinkButton(uri string) {
	var _arg0 *C.GtkLinkButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_link_button_set_uri(_arg0, _arg1)
}

func (l linkButton) SetVisitedLinkButton(visited bool) {
	var _arg0 *C.GtkLinkButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
	if visited {
		_arg1 = C.TRUE
	}

	C.gtk_link_button_set_visited(_arg0, _arg1)
}

func (s linkButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s linkButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s linkButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s linkButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s linkButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s linkButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s linkButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (a linkButton) ActionName() string {
	return WrapActionable(gextras.InternObject(a)).ActionName()
}

func (a linkButton) ActionTargetValue() *glib.Variant {
	return WrapActionable(gextras.InternObject(a)).ActionTargetValue()
}

func (a linkButton) SetActionName(actionName string) {
	WrapActionable(gextras.InternObject(a)).SetActionName(actionName)
}

func (a linkButton) SetActionTargetValue(targetValue *glib.Variant) {
	WrapActionable(gextras.InternObject(a)).SetActionTargetValue(targetValue)
}

func (a linkButton) SetDetailedActionName(detailedActionName string) {
	WrapActionable(gextras.InternObject(a)).SetDetailedActionName(detailedActionName)
}

func (b linkButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// ListBase: `GtkListBase` is the abstract base class for GTK's list widgets.
type ListBase interface {
	Widget
	Orientable
	Scrollable
}

// listBase implements the ListBase class.
type listBase struct {
	Widget
}

// WrapListBase wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBase(obj *externglib.Object) ListBase {
	return listBase{
		Widget: WrapWidget(obj),
	}
}

func marshalListBase(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBase(obj), nil
}

func (s listBase) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s listBase) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s listBase) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s listBase) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s listBase) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s listBase) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s listBase) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b listBase) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o listBase) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o listBase) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

func (s listBase) Border() (Border, bool) {
	return WrapScrollable(gextras.InternObject(s)).Border()
}

func (s listBase) HAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).HAdjustment()
}

func (s listBase) HScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).HScrollPolicy()
}

func (s listBase) VAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).VAdjustment()
}

func (s listBase) VScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).VScrollPolicy()
}

func (s listBase) SetHAdjustment(hadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetHAdjustment(hadjustment)
}

func (s listBase) SetHScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetHScrollPolicy(policy)
}

func (s listBase) SetVAdjustment(vadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetVAdjustment(vadjustment)
}

func (s listBase) SetVScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetVScrollPolicy(policy)
}

// ListBox: `GtkListBox` is a vertical list.
//
// A `GtkListBox` only contains `GtkListBoxRow` children. These rows can by
// dynamically sorted and filtered, and headers can be added dynamically
// depending on the row content. It also allows keyboard and mouse navigation
// and selection like a typical list.
//
// Using `GtkListBox` is often an alternative to `GtkTreeView`, especially when
// the list contents has a more complicated layout than what is allowed by a
// `GtkCellRenderer`, or when the contents is interactive (i.e. has a button in
// it).
//
// Although a `GtkListBox` must have only `GtkListBoxRow` children, you can add
// any kind of widget to it via [method@Gtk.ListBox.prepend],
// [method@Gtk.ListBox.append] and [method@Gtk.ListBox.insert] and a
// `GtkListBoxRow` widget will automatically be inserted between the list and
// the widget.
//
// `GtkListBoxRows` can be marked as activatable or selectable. If a row is
// activatable, [signal@Gtk.ListBox::row-activated] will be emitted for it when
// the user tries to activate it. If it is selectable, the row will be marked as
// selected when the user tries to select it.
//
//
// GtkListBox as GtkBuildable
//
// The `GtkListBox` implementation of the `GtkBuildable` interface supports
// setting a child as the placeholder by specifying placeholder as the type
// attribute of a <child> element. See [method@Gtk.ListBox.set_placeholder] for
// info.
//
// CSS nodes
//
//    list[.separators][.rich-list][.navigation-sidebar]
//     row[.activatable]
//
// `GtkListBox` uses a single CSS node named list. It may carry the .separators
// style class, when the [property@Gtk.ListBox:show-separators] property is set.
// Each `GtkListBoxRow` uses a single CSS node named row. The row nodes get the
// .activatable style class added when appropriate.
//
// The main list node may also carry style classes to select the style of list
// presentation (section-list-widget.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// `GtkListBox` uses the GTK_ACCESSIBLE_ROLE_LIST role and `GtkListBoxRow` uses
// the GTK_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListBox interface {
	Widget

	// AppendListBox: append a widget to the list.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	AppendListBox(child Widget)
	// DragHighlightRowListBox: add a drag highlight to a row.
	//
	// This is a helper function for implementing DnD onto a `GtkListBox`. The
	// passed in @row will be highlighted by setting the
	// GTK_STATE_FLAG_DROP_ACTIVE state and any previously highlighted row will
	// be unhighlighted.
	//
	// The row will also be unhighlighted when the widget gets a drag leave
	// event.
	DragHighlightRowListBox(row ListBoxRow)
	// DragUnhighlightRowListBox: if a row has previously been highlighted via
	// gtk_list_box_drag_highlight_row(), it will have the highlight removed.
	DragUnhighlightRowListBox()
	// ActivateOnSingleClick returns whether rows activate on single clicks.
	ActivateOnSingleClick() bool
	// Adjustment gets the adjustment (if any) that the widget uses to for
	// vertical scrolling.
	Adjustment() Adjustment
	// RowAtIndex gets the n-th child in the list (not counting headers).
	//
	// If @index_ is negative or larger than the number of items in the list,
	// nil is returned.
	RowAtIndex(index_ int) ListBoxRow
	// RowAtY gets the row at the @y position.
	RowAtY(y int) ListBoxRow
	// SelectedRow gets the selected row, or nil if no rows are selected.
	//
	// Note that the box may allow multiple selection, in which case you should
	// use [method@Gtk.ListBox.selected_foreach] to find all selected rows.
	SelectedRow() ListBoxRow
	// SelectionMode gets the selection mode of the listbox.
	SelectionMode() SelectionMode
	// ShowSeparators returns whether the list box should show separators
	// between rows.
	ShowSeparators() bool
	// InsertListBox: insert the @child into the @box at @position.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	//
	// If @position is -1, or larger than the total number of items in the @box,
	// then the @child will be appended to the end.
	InsertListBox(child Widget, position int)
	// InvalidateFilterListBox: update the filtering for all rows.
	//
	// Call this when result of the filter function on the @box is changed due
	// to an external factor. For instance, this would be used if the filter
	// function just looked for a specific search string and the entry with the
	// search string has changed.
	InvalidateFilterListBox()
	// InvalidateHeadersListBox: update the separators for all rows.
	//
	// Call this when result of the header function on the @box is changed due
	// to an external factor.
	InvalidateHeadersListBox()
	// InvalidateSortListBox: update the sorting for all rows.
	//
	// Call this when result of the sort function on the @box is changed due to
	// an external factor.
	InvalidateSortListBox()
	// PrependListBox: prepend a widget to the list.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	PrependListBox(child Widget)
	// RemoveListBox removes a child from @box.
	RemoveListBox(child Widget)
	// SelectAllListBox: select all children of @box, if the selection mode
	// allows it.
	SelectAllListBox()
	// SelectRowListBox: make @row the currently selected row.
	SelectRowListBox(row ListBoxRow)
	// SetActivateOnSingleClickListBox: if @single is true, rows will be
	// activated when you click on them, otherwise you need to double-click.
	SetActivateOnSingleClickListBox(single bool)
	// SetAdjustmentListBox sets the adjustment (if any) that the widget uses to
	// for vertical scrolling.
	//
	// For instance, this is used to get the page size for PageUp/Down key
	// handling.
	//
	// In the normal case when the @box is packed inside a `GtkScrolledWindow`
	// the adjustment from that will be picked up automatically, so there is no
	// need to manually do that.
	SetAdjustmentListBox(adjustment Adjustment)
	// SetPlaceholderListBox sets the placeholder widget that is shown in the
	// list when it doesn't display any visible children.
	SetPlaceholderListBox(placeholder Widget)
	// SetSelectionModeListBox sets how selection works in the listbox.
	SetSelectionModeListBox(mode SelectionMode)
	// SetShowSeparatorsListBox sets whether the list box should show separators
	// between rows.
	SetShowSeparatorsListBox(showSeparators bool)
	// UnselectAllListBox: unselect all children of @box, if the selection mode
	// allows it.
	UnselectAllListBox()
	// UnselectRowListBox unselects a single row of @box, if the selection mode
	// allows it.
	UnselectRowListBox(row ListBoxRow)
}

// listBox implements the ListBox class.
type listBox struct {
	Widget
}

// WrapListBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBox(obj *externglib.Object) ListBox {
	return listBox{
		Widget: WrapWidget(obj),
	}
}

func marshalListBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBox(obj), nil
}

// NewListBox creates a new `GtkListBox` container.
func NewListBox() ListBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_list_box_new()

	var _listBox ListBox // out

	_listBox = WrapListBox(externglib.Take(unsafe.Pointer(_cret)))

	return _listBox
}

func (b listBox) AppendListBox(child Widget) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_append(_arg0, _arg1)
}

func (b listBox) DragHighlightRowListBox(row ListBoxRow) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_drag_highlight_row(_arg0, _arg1)
}

func (b listBox) DragUnhighlightRowListBox() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_drag_unhighlight_row(_arg0)
}

func (b listBox) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkListBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_list_box_get_activate_on_single_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b listBox) Adjustment() Adjustment {
	var _arg0 *C.GtkListBox    // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_list_box_get_adjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (b listBox) RowAtIndex(index_ int) ListBoxRow {
	var _arg0 *C.GtkListBox    // out
	var _arg1 C.int            // out
	var _cret *C.GtkListBoxRow // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(index_)

	_cret = C.gtk_list_box_get_row_at_index(_arg0, _arg1)

	var _listBoxRow ListBoxRow // out

	_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

	return _listBoxRow
}

func (b listBox) RowAtY(y int) ListBoxRow {
	var _arg0 *C.GtkListBox    // out
	var _arg1 C.int            // out
	var _cret *C.GtkListBoxRow // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(y)

	_cret = C.gtk_list_box_get_row_at_y(_arg0, _arg1)

	var _listBoxRow ListBoxRow // out

	_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

	return _listBoxRow
}

func (b listBox) SelectedRow() ListBoxRow {
	var _arg0 *C.GtkListBox    // out
	var _cret *C.GtkListBoxRow // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_list_box_get_selected_row(_arg0)

	var _listBoxRow ListBoxRow // out

	_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

	return _listBoxRow
}

func (b listBox) SelectionMode() SelectionMode {
	var _arg0 *C.GtkListBox      // out
	var _cret C.GtkSelectionMode // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_list_box_get_selection_mode(_arg0)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

func (b listBox) ShowSeparators() bool {
	var _arg0 *C.GtkListBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_list_box_get_show_separators(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b listBox) InsertListBox(child Widget, position int) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.int)(position)

	C.gtk_list_box_insert(_arg0, _arg1, _arg2)
}

func (b listBox) InvalidateFilterListBox() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_filter(_arg0)
}

func (b listBox) InvalidateHeadersListBox() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_headers(_arg0)
}

func (b listBox) InvalidateSortListBox() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_sort(_arg0)
}

func (b listBox) PrependListBox(child Widget) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_prepend(_arg0, _arg1)
}

func (b listBox) RemoveListBox(child Widget) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_remove(_arg0, _arg1)
}

func (b listBox) SelectAllListBox() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_select_all(_arg0)
}

func (b listBox) SelectRowListBox(row ListBoxRow) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_select_row(_arg0, _arg1)
}

func (b listBox) SetActivateOnSingleClickListBox(single bool) {
	var _arg0 *C.GtkListBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_set_activate_on_single_click(_arg0, _arg1)
}

func (b listBox) SetAdjustmentListBox(adjustment Adjustment) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_list_box_set_adjustment(_arg0, _arg1)
}

func (b listBox) SetPlaceholderListBox(placeholder Widget) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(placeholder.Native()))

	C.gtk_list_box_set_placeholder(_arg0, _arg1)
}

func (b listBox) SetSelectionModeListBox(mode SelectionMode) {
	var _arg0 *C.GtkListBox      // out
	var _arg1 C.GtkSelectionMode // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_list_box_set_selection_mode(_arg0, _arg1)
}

func (b listBox) SetShowSeparatorsListBox(showSeparators bool) {
	var _arg0 *C.GtkListBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	if showSeparators {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_set_show_separators(_arg0, _arg1)
}

func (b listBox) UnselectAllListBox() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_unselect_all(_arg0)
}

func (b listBox) UnselectRowListBox(row ListBoxRow) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_unselect_row(_arg0, _arg1)
}

func (s listBox) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s listBox) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s listBox) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s listBox) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s listBox) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s listBox) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s listBox) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b listBox) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// ListBoxRow: `GtkListBoxRow` is the kind of widget that can be added to a
// `GtkListBox`.
type ListBoxRow interface {
	Actionable

	// ChangedListBoxRow marks @row as changed, causing any state that depends
	// on this to be updated.
	//
	// This affects sorting, filtering and headers.
	//
	// Note that calls to this method must be in sync with the data used for the
	// row functions. For instance, if the list is mirroring some external data
	// set, and *two* rows changed in the external data set then when you call
	// gtk_list_box_row_changed() on the first row the sort function must only
	// read the new data for the first of the two changed rows, otherwise the
	// resorting of the rows will be wrong.
	//
	// This generally means that if you dont fully control the data model you
	// have to duplicate the data that affects the listbox row functions into
	// the row widgets themselves. Another alternative is to call
	// [method@Gtk.ListBox.invalidate_sort] on any model change, but that is
	// more expensive.
	ChangedListBoxRow()
	// Activatable gets whether the row is activatable.
	Activatable() bool
	// Child gets the child widget of @row.
	Child() Widget
	// Header returns the current header of the @row.
	//
	// This can be used in a [callback@Gtk.ListBoxUpdateHeaderFunc] to see if
	// there is a header set already, and if so to update the state of it.
	Header() Widget
	// Index gets the current index of the @row in its `GtkListBox` container.
	Index() int
	// Selectable gets whether the row can be selected.
	Selectable() bool
	// IsSelectedListBoxRow returns whether the child is currently selected in
	// its `GtkListBox` container.
	IsSelectedListBoxRow() bool
	// SetActivatableListBoxRow: set whether the row is activatable.
	SetActivatableListBoxRow(activatable bool)
	// SetChildListBoxRow sets the child widget of @self.
	SetChildListBoxRow(child Widget)
	// SetHeaderListBoxRow sets the current header of the @row.
	//
	// This is only allowed to be called from a
	// [callback@Gtk.ListBoxUpdateHeaderFunc]. It will replace any existing
	// header in the row, and be shown in front of the row in the listbox.
	SetHeaderListBoxRow(header Widget)
	// SetSelectableListBoxRow: set whether the row can be selected.
	SetSelectableListBoxRow(selectable bool)
}

// listBoxRow implements the ListBoxRow class.
type listBoxRow struct {
	Widget
}

// WrapListBoxRow wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBoxRow(obj *externglib.Object) ListBoxRow {
	return listBoxRow{
		Widget: WrapWidget(obj),
	}
}

func marshalListBoxRow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBoxRow(obj), nil
}

// NewListBoxRow creates a new `GtkListBoxRow`.
func NewListBoxRow() ListBoxRow {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_list_box_row_new()

	var _listBoxRow ListBoxRow // out

	_listBoxRow = WrapListBoxRow(externglib.Take(unsafe.Pointer(_cret)))

	return _listBoxRow
}

func (r listBoxRow) ChangedListBoxRow() {
	var _arg0 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	C.gtk_list_box_row_changed(_arg0)
}

func (r listBoxRow) Activatable() bool {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_get_activatable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r listBoxRow) Child() Widget {
	var _arg0 *C.GtkListBoxRow // out
	var _cret *C.GtkWidget     // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (r listBoxRow) Header() Widget {
	var _arg0 *C.GtkListBoxRow // out
	var _cret *C.GtkWidget     // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_get_header(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (r listBoxRow) Index() int {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.int            // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_get_index(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (r listBoxRow) Selectable() bool {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_get_selectable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r listBoxRow) IsSelectedListBoxRow() bool {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_is_selected(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r listBoxRow) SetActivatableListBoxRow(activatable bool) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
	if activatable {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_row_set_activatable(_arg0, _arg1)
}

func (r listBoxRow) SetChildListBoxRow(child Widget) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_row_set_child(_arg0, _arg1)
}

func (r listBoxRow) SetHeaderListBoxRow(header Widget) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(header.Native()))

	C.gtk_list_box_row_set_header(_arg0, _arg1)
}

func (r listBoxRow) SetSelectableListBoxRow(selectable bool) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
	if selectable {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_row_set_selectable(_arg0, _arg1)
}

func (s listBoxRow) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s listBoxRow) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s listBoxRow) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s listBoxRow) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s listBoxRow) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s listBoxRow) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s listBoxRow) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (a listBoxRow) ActionName() string {
	return WrapActionable(gextras.InternObject(a)).ActionName()
}

func (a listBoxRow) ActionTargetValue() *glib.Variant {
	return WrapActionable(gextras.InternObject(a)).ActionTargetValue()
}

func (a listBoxRow) SetActionName(actionName string) {
	WrapActionable(gextras.InternObject(a)).SetActionName(actionName)
}

func (a listBoxRow) SetActionTargetValue(targetValue *glib.Variant) {
	WrapActionable(gextras.InternObject(a)).SetActionTargetValue(targetValue)
}

func (a listBoxRow) SetDetailedActionName(detailedActionName string) {
	WrapActionable(gextras.InternObject(a)).SetDetailedActionName(detailedActionName)
}

func (b listBoxRow) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// ListItem: `GtkListItem` is used by list widgets to represent items in a
// `GListModel`.
//
// The `GtkListItem`s are managed by the list widget (with its factory) and
// cannot be created by applications, but they need to be populated by
// application code. This is done by calling [method@Gtk.ListItem.set_child].
//
// `GtkListItem`s exist in 2 stages:
//
// 1. The unbound stage where the listitem is not currently connected to an item
// in the list. In that case, the [property@Gtk.ListItem:item] property is set
// to nil.
//
// 2. The bound stage where the listitem references an item from the list. The
// [property@Gtk.ListItem:item] property is not nil.
type ListItem interface {

	// Activatable checks if a list item has been set to be activatable via
	// gtk_list_item_set_activatable().
	Activatable() bool
	// Child gets the child previously set via gtk_list_item_set_child() or nil
	// if none was set.
	Child() Widget
	// Item gets the model item that associated with @self.
	//
	// If @self is unbound, this function returns nil.
	Item() gextras.Objector
	// Position gets the position in the model that @self currently displays.
	//
	// If @self is unbound, GTK_INVALID_LIST_POSITION is returned.
	Position() uint
	// Selectable checks if a list item has been set to be selectable via
	// gtk_list_item_set_selectable().
	//
	// Do not confuse this function with [method@Gtk.ListItem.get_selected].
	Selectable() bool
	// Selected checks if the item is displayed as selected.
	//
	// The selected state is maintained by the liste widget and its model and
	// cannot be set otherwise.
	Selected() bool
	// SetActivatableListItem sets @self to be activatable.
	//
	// If an item is activatable, double-clicking on the item, using the Return
	// key or calling gtk_widget_activate() will activate the item. Activating
	// instructs the containing view to handle activation. `GtkListView` for
	// example will be emitting the [signal@Gtk.ListView::activate] signal.
	//
	// By default, list items are activatable.
	SetActivatableListItem(activatable bool)
	// SetChildListItem sets the child to be used for this listitem.
	//
	// This function is typically called by applications when setting up a
	// listitem so that the widget can be reused when binding it multiple times.
	SetChildListItem(child Widget)
	// SetSelectableListItem sets @self to be selectable.
	//
	// If an item is selectable, clicking on the item or using the keyboard will
	// try to select or unselect the item. If this succeeds is up to the model
	// to determine, as it is managing the selected state.
	//
	// Note that this means that making an item non-selectable has no influence
	// on the selected state at all. A non-selectable item may still be
	// selected.
	//
	// By default, list items are selectable. When rebinding them to a new item,
	// they will also be reset to be selectable by GTK.
	SetSelectableListItem(selectable bool)
}

// listItem implements the ListItem class.
type listItem struct {
	gextras.Objector
}

// WrapListItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapListItem(obj *externglib.Object) ListItem {
	return listItem{
		Objector: obj,
	}
}

func marshalListItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListItem(obj), nil
}

func (s listItem) Activatable() bool {
	var _arg0 *C.GtkListItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_item_get_activatable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s listItem) Child() Widget {
	var _arg0 *C.GtkListItem // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_item_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s listItem) Item() gextras.Objector {
	var _arg0 *C.GtkListItem // out
	var _cret C.gpointer     // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_item_get_item(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (s listItem) Position() uint {
	var _arg0 *C.GtkListItem // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_item_get_position(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s listItem) Selectable() bool {
	var _arg0 *C.GtkListItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_item_get_selectable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s listItem) Selected() bool {
	var _arg0 *C.GtkListItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_item_get_selected(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s listItem) SetActivatableListItem(activatable bool) {
	var _arg0 *C.GtkListItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))
	if activatable {
		_arg1 = C.TRUE
	}

	C.gtk_list_item_set_activatable(_arg0, _arg1)
}

func (s listItem) SetChildListItem(child Widget) {
	var _arg0 *C.GtkListItem // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_item_set_child(_arg0, _arg1)
}

func (s listItem) SetSelectableListItem(selectable bool) {
	var _arg0 *C.GtkListItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))
	if selectable {
		_arg1 = C.TRUE
	}

	C.gtk_list_item_set_selectable(_arg0, _arg1)
}

// ListItemFactory: a `GtkListItemFactory` creates widgets for the items taken
// from a `GListModel`.
//
// This is one of the core concepts of handling list widgets such as
// [class@Gtk.ListView] or [class@Gtk.GridView].
//
// The `GtkListItemFactory` is tasked with creating widgets for items taken from
// the model when the views need them and updating them as the items displayed
// by the view change.
//
// A view is usually only able to display anything after both a factory and a
// model have been set on the view. So it is important that you do not skip this
// step when setting up your first view.
//
// Because views do not display the whole list at once but only a few items,
// they only need to maintain a few widgets at a time. They will instruct the
// `GtkListItemFactory` to create these widgets and bind them to the items that
// are currently displayed.
//
// As the list model changes or the user scrolls to the list, the items will
// change and the view will instruct the factory to bind the widgets to those
// new items.
//
// The actual widgets used for displaying those widgets is provided by you.
//
// When the factory needs widgets created, it will create a `GtkListItem` and
// hand it to your code to set up a widget for. This list item will provide
// various properties with information about what item to display and provide
// you with some opportunities to configure its behavior. See the
// [class@Gtk.ListItem] documentation for further details.
//
// Various implementations of `GtkListItemFactory` exist to allow you different
// ways to provide those widgets. The most common implementations are
// [class@Gtk.BuilderListItemFactory] which takes a `GtkBuilder` .ui file and
// then creates widgets and manages everything automatically from the
// information in that file and [class@Gtk.SignalListItemFactory] which allows
// you to connect to signals with your own code and retain full control over how
// the widgets are setup and managed.
//
// A `GtkListItemFactory` is supposed to be final - that means its behavior
// should not change and the first widget created from it should behave the same
// way as the last widget created from it. If you intend to do changes to the
// behavior, it is recommended that you create a new `GtkListItemFactory` which
// will allow the views to recreate its widgets.
//
// Once you have chosen your factory and created it, you need to set it on the
// view widget you want to use it with, such as via
// [method@Gtk.ListView.set_factory]. Reusing factories across different views
// is allowed, but very uncommon.
type ListItemFactory interface {
}

// listItemFactory implements the ListItemFactory class.
type listItemFactory struct {
	gextras.Objector
}

// WrapListItemFactory wraps a GObject to the right type. It is
// primarily used internally.
func WrapListItemFactory(obj *externglib.Object) ListItemFactory {
	return listItemFactory{
		Objector: obj,
	}
}

func marshalListItemFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListItemFactory(obj), nil
}

// ListStore: a list-like data structure that can be used with the GtkTreeView
//
// The ListStore object is a list model for use with a TreeView widget. It
// implements the TreeModel interface, and consequentialy, can use all of the
// methods available there. It also implements the TreeSortable interface so it
// can be sorted by the view. Finally, it also implements the tree [drag and
// drop][gtk4-GtkTreeView-drag-and-drop] interfaces.
//
// The ListStore can accept most GObject types as a column type, though it cant
// accept all custom types. Internally, it will keep a copy of data passed in
// (such as a string or a boxed pointer). Columns that accept #GObjects are
// handled a little differently. The ListStore will keep a reference to the
// object instead of copying the value. As a result, if the object is modified,
// it is up to the application writer to call gtk_tree_model_row_changed() to
// emit the TreeModel::row_changed signal. This most commonly affects lists with
// Textures stored.
//
// An example for creating a simple list store:
//
//    <object class="GtkListStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//      <data>
//        <row>
//          <col id="0">John</col>
//          <col id="1">Doe</col>
//          <col id="2">25</col>
//        </row>
//        <row>
//          <col id="0">Johan</col>
//          <col id="1">Dahlin</col>
//          <col id="2">50</col>
//        </row>
//      </data>
//    </object>
type ListStore interface {
	Buildable
	TreeDragDest
	TreeDragSource
	TreeSortable

	// AppendListStore appends a new row to @list_store. @iter will be changed
	// to point to this new row. The row will be empty after this function is
	// called. To fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	AppendListStore() TreeIter
	// ClearListStore removes all rows from the list store.
	ClearListStore()
	// InsertListStore creates a new row at @position. @iter will be changed to
	// point to this new row. If @position is -1 or is larger than the number of
	// rows on the list, then the new row will be appended to the list. The row
	// will be empty after this function is called. To fill in values, you need
	// to call gtk_list_store_set() or gtk_list_store_set_value().
	InsertListStore(position int) TreeIter
	// InsertAfterListStore inserts a new row after @sibling. If @sibling is
	// nil, then the row will be prepended to the beginning of the list. @iter
	// will be changed to point to this new row. The row will be empty after
	// this function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	InsertAfterListStore(sibling *TreeIter) TreeIter
	// InsertBeforeListStore inserts a new row before @sibling. If @sibling is
	// nil, then the row will be appended to the end of the list. @iter will be
	// changed to point to this new row. The row will be empty after this
	// function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	InsertBeforeListStore(sibling *TreeIter) TreeIter
	// InsertWithValuesvListStore: a variant of
	// gtk_list_store_insert_with_values() which takes the columns and values as
	// two arrays, instead of varargs.
	//
	// This function is mainly intended for language-bindings.
	InsertWithValuesvListStore(position int, columns []int, values []externglib.Value) TreeIter
	// IterIsValidListStore: > This function is slow. Only use it for debugging
	// and/or testing > purposes.
	//
	// Checks if the given iter is a valid iter for this ListStore.
	IterIsValidListStore(iter *TreeIter) bool
	// MoveAfterListStore moves @iter in @store to the position after @position.
	// Note that this function only works with unsorted stores. If @position is
	// nil, @iter will be moved to the start of the list.
	MoveAfterListStore(iter *TreeIter, position *TreeIter)
	// MoveBeforeListStore moves @iter in @store to the position before
	// @position. Note that this function only works with unsorted stores. If
	// @position is nil, @iter will be moved to the end of the list.
	MoveBeforeListStore(iter *TreeIter, position *TreeIter)
	// PrependListStore prepends a new row to @list_store. @iter will be changed
	// to point to this new row. The row will be empty after this function is
	// called. To fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	PrependListStore() TreeIter
	// RemoveListStore removes the given row from the list store. After being
	// removed, @iter is set to be the next valid row, or invalidated if it
	// pointed to the last row in @list_store.
	RemoveListStore(iter *TreeIter) bool
	// ReorderListStore reorders @store to follow the order indicated by
	// @new_order. Note that this function only works with unsorted stores.
	ReorderListStore(newOrder []int)
	// SetColumnTypesListStore: this function is meant primarily for #GObjects
	// that inherit from ListStore, and should only be used when constructing a
	// new ListStore. It will not function after a row has been added, or a
	// method on the TreeModel interface is called.
	SetColumnTypesListStore(types []externglib.Type)
	// SetValueListStore sets the data in the cell specified by @iter and
	// @column. The type of @value must be convertible to the type of the
	// column.
	SetValueListStore(iter *TreeIter, column int, value *externglib.Value)
	// SetValuesvListStore: a variant of gtk_list_store_set_valist() which takes
	// the columns and values as two arrays, instead of varargs. This function
	// is mainly intended for language-bindings and in case the number of
	// columns to change is not known until run-time.
	SetValuesvListStore(iter *TreeIter, columns []int, values []externglib.Value)
	// SwapListStore swaps @a and @b in @store. Note that this function only
	// works with unsorted stores.
	SwapListStore(a *TreeIter, b *TreeIter)
}

// listStore implements the ListStore class.
type listStore struct {
	gextras.Objector
}

// WrapListStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapListStore(obj *externglib.Object) ListStore {
	return listStore{
		Objector: obj,
	}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListStore(obj), nil
}

// NewListStoreV: non-vararg creation function. Used primarily by language
// bindings.
func NewListStoreV(types []externglib.Type) ListStore {
	var _arg2 *C.GType
	var _arg1 C.int
	var _cret *C.GtkListStore // in

	_arg1 = C.int(len(types))
	_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(types))
		for i := range types {
			out[i] = (C.GType)(types[i])
		}
	}

	_cret = C.gtk_list_store_newv(_arg1, _arg2)

	var _listStore ListStore // out

	_listStore = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ListStore)

	return _listStore
}

func (l listStore) AppendListStore() TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

	C.gtk_list_store_append(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	return _iter
}

func (l listStore) ClearListStore() {
	var _arg0 *C.GtkListStore // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

	C.gtk_list_store_clear(_arg0)
}

func (l listStore) InsertListStore(position int) TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter
	var _arg2 C.int // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg2 = (C.int)(position)

	C.gtk_list_store_insert(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

func (l listStore) InsertAfterListStore(sibling *TreeIter) TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

	C.gtk_list_store_insert_after(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

func (l listStore) InsertBeforeListStore(sibling *TreeIter) TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

	C.gtk_list_store_insert_before(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

func (l listStore) InsertWithValuesvListStore(position int, columns []int, values []externglib.Value) TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter
	var _arg2 C.int // out
	var _arg3 *C.int
	var _arg5 C.int
	var _arg4 *C.GValue
	var _arg5 C.int

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg2 = (C.int)(position)
	_arg5 = C.int(len(columns))
	_arg3 = (*C.int)(unsafe.Pointer(&columns[0]))
	_arg5 = C.int(len(values))
	_arg4 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(values))
		for i := range values {
			out[i] = (C.GValue)(unsafe.Pointer(&values[i].GValue))
		}
	}

	C.gtk_list_store_insert_with_valuesv(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3, _arg4, _arg5)

	return _iter
}

func (l listStore) IterIsValidListStore(iter *TreeIter) bool {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_list_store_iter_is_valid(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s listStore) MoveAfterListStore(iter *TreeIter, position *TreeIter) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

	C.gtk_list_store_move_after(_arg0, _arg1, _arg2)
}

func (s listStore) MoveBeforeListStore(iter *TreeIter, position *TreeIter) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

	C.gtk_list_store_move_before(_arg0, _arg1, _arg2)
}

func (l listStore) PrependListStore() TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

	C.gtk_list_store_prepend(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	return _iter
}

func (l listStore) RemoveListStore(iter *TreeIter) bool {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_list_store_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s listStore) ReorderListStore(newOrder []int) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.int

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
	{
		var zero int
		newOrder = append(newOrder, zero)
	}
	_arg1 = (*C.int)(unsafe.Pointer(&newOrder[0]))

	C.gtk_list_store_reorder(_arg0, _arg1)
}

func (l listStore) SetColumnTypesListStore(types []externglib.Type) {
	var _arg0 *C.GtkListStore // out
	var _arg2 *C.GType
	var _arg1 C.int

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = C.int(len(types))
	_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(types))
		for i := range types {
			out[i] = (C.GType)(types[i])
		}
	}

	C.gtk_list_store_set_column_types(_arg0, _arg1, _arg2)
}

func (l listStore) SetValueListStore(iter *TreeIter, column int, value *externglib.Value) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.int           // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.int)(column)
	_arg3 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	C.gtk_list_store_set_value(_arg0, _arg1, _arg2, _arg3)
}

func (l listStore) SetValuesvListStore(iter *TreeIter, columns []int, values []externglib.Value) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.int
	var _arg4 C.int
	var _arg3 *C.GValue
	var _arg4 C.int

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg4 = C.int(len(columns))
	_arg2 = (*C.int)(unsafe.Pointer(&columns[0]))
	_arg4 = C.int(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			out[i] = (C.GValue)(unsafe.Pointer(&values[i].GValue))
		}
	}

	C.gtk_list_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s listStore) SwapListStore(a *TreeIter, b *TreeIter) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(a.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(b.Native()))

	C.gtk_list_store_swap(_arg0, _arg1, _arg2)
}

func (b listStore) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (d listStore) DragDataReceived(dest *TreePath, value *externglib.Value) bool {
	return WrapTreeDragDest(gextras.InternObject(d)).DragDataReceived(dest, value)
}

func (d listStore) RowDropPossible(destPath *TreePath, value *externglib.Value) bool {
	return WrapTreeDragDest(gextras.InternObject(d)).RowDropPossible(destPath, value)
}

func (d listStore) DragDataDelete(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataDelete(path)
}

func (d listStore) DragDataGet(path *TreePath) gdk.ContentProvider {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataGet(path)
}

func (d listStore) RowDraggable(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).RowDraggable(path)
}

func (c listStore) NewFilter(root *TreePath) TreeModel {
	return WrapTreeModel(gextras.InternObject(c)).NewFilter(root)
}

func (t listStore) ColumnType(index_ int) externglib.Type {
	return WrapTreeModel(gextras.InternObject(t)).ColumnType(index_)
}

func (t listStore) Flags() TreeModelFlags {
	return WrapTreeModel(gextras.InternObject(t)).Flags()
}

func (t listStore) Iter(path *TreePath) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).Iter(path)
}

func (t listStore) IterFirst() (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterFirst()
}

func (t listStore) IterFromString(pathString string) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterFromString(pathString)
}

func (t listStore) NColumns() int {
	return WrapTreeModel(gextras.InternObject(t)).NColumns()
}

func (t listStore) Path(iter *TreeIter) *TreePath {
	return WrapTreeModel(gextras.InternObject(t)).Path(iter)
}

func (t listStore) StringFromIter(iter *TreeIter) string {
	return WrapTreeModel(gextras.InternObject(t)).StringFromIter(iter)
}

func (t listStore) Value(iter *TreeIter, column int) externglib.Value {
	return WrapTreeModel(gextras.InternObject(t)).Value(iter, column)
}

func (t listStore) IterChildren(parent *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterChildren(parent)
}

func (t listStore) IterHasChild(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterHasChild(iter)
}

func (t listStore) IterNChildren(iter *TreeIter) int {
	return WrapTreeModel(gextras.InternObject(t)).IterNChildren(iter)
}

func (t listStore) IterNext(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterNext(iter)
}

func (t listStore) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterNthChild(parent, n)
}

func (t listStore) IterParent(child *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterParent(child)
}

func (t listStore) IterPrevious(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterPrevious(iter)
}

func (t listStore) RefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RefNode(iter)
}

func (t listStore) RowChanged(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowChanged(path, iter)
}

func (t listStore) RowDeleted(path *TreePath) {
	WrapTreeModel(gextras.InternObject(t)).RowDeleted(path)
}

func (t listStore) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowHasChildToggled(path, iter)
}

func (t listStore) RowInserted(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowInserted(path, iter)
}

func (t listStore) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int) {
	WrapTreeModel(gextras.InternObject(t)).RowsReorderedWithLength(path, iter, newOrder)
}

func (t listStore) UnrefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).UnrefNode(iter)
}

func (s listStore) SortColumnID() (int, SortType, bool) {
	return WrapTreeSortable(gextras.InternObject(s)).SortColumnID()
}

func (s listStore) HasDefaultSortFunc() bool {
	return WrapTreeSortable(gextras.InternObject(s)).HasDefaultSortFunc()
}

func (s listStore) SetSortColumnID(sortColumnId int, order SortType) {
	WrapTreeSortable(gextras.InternObject(s)).SetSortColumnID(sortColumnId, order)
}

func (s listStore) SortColumnChanged() {
	WrapTreeSortable(gextras.InternObject(s)).SortColumnChanged()
}

// ListView: `GtkListView` presents a large dynamic list of items.
//
// `GtkListView` uses its factory to generate one row widget for each visible
// item and shows them in a linear display, either vertically or horizontally.
//
// The [property@Gtk.ListView:show-separators] property offers a simple way to
// display separators between the rows.
//
// `GtkListView` allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on _rubberband selection_, using
// [property@Gtk.ListView:enable-rubberband].
//
// If you need multiple columns with headers, see [class@Gtk.ColumnView].
//
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
//
// An example of using `GtkListView`: `c static void setup_listitem_cb
// (GtkListItemFactory *factory, GtkListItem *list_item) { GtkWidget *image;
//
//    image = gtk_image_new ();
//    gtk_image_set_icon_size (GTK_IMAGE (image), GTK_ICON_SIZE_LARGE);
//    gtk_list_item_set_child (list_item, image);
//
// }
//
// static void bind_listitem_cb (GtkListItemFactory *factory, GtkListItem
// *list_item) { GtkWidget *image; GAppInfo *app_info;
//
//    image = gtk_list_item_get_child (list_item);
//    app_info = gtk_list_item_get_item (list_item);
//    gtk_image_set_from_gicon (GTK_IMAGE (image), g_app_info_get_icon (app_info));
//
// }
//
// static void activate_cb (GtkListView *list, guint position, gpointer unused)
// { GAppInfo *app_info;
//
//    app_info = g_list_model_get_item (G_LIST_MODEL (gtk_list_view_get_model (list)), position);
//    g_app_info_launch (app_info, NULL, NULL, NULL);
//    g_object_unref (app_info);
//
// }
//
// ...
//
//    model = create_application_list ();
//
//    factory = gtk_signal_list_item_factory_new ();
//    g_signal_connect (factory, "setup", G_CALLBACK (setup_listitem_cb), NULL);
//    g_signal_connect (factory, "bind", G_CALLBACK (bind_listitem_cb), NULL);
//
//    list = gtk_list_view_new (GTK_SELECTION_MODEL (gtk_single_selection_new (model)), factory);
//
//    g_signal_connect (list, "activate", G_CALLBACK (activate_cb), NULL);
//
//    gtk_scrolled_window_set_child (GTK_SCROLLED_WINDOW (sw), list);
//
// `
//
//
// CSS nodes
//
// ` listview[.separators][.rich-list][.navigation-sidebar][.data-table] 
// row   row    [rubberband] `
//
// `GtkListView` uses a single CSS node named listview. It may carry the
// .separators style class, when `GtkListView`:show-separators property is set.
// Each child widget uses a single CSS node named row. For rubberband selection,
// a node with name rubberband is used.
//
// The main listview node may also carry style classes to select the style of
// list presentation (ListContainers.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// `GtkListView` uses the GTK_ACCESSIBLE_ROLE_LIST role, and the list items use
// the GTK_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListView interface {
	ListBase

	// EnableRubberband returns whether rows can be selected by dragging with
	// the mouse.
	EnableRubberband() bool
	// Factory gets the factory that's currently used to populate list items.
	Factory() ListItemFactory
	// Model gets the model that's currently used to read the items displayed.
	Model() SelectionModel
	// ShowSeparators returns whether the list box should show separators
	// between rows.
	ShowSeparators() bool
	// SingleClickActivate returns whether rows will be activated on single
	// click and selected on hover.
	SingleClickActivate() bool
	// SetEnableRubberbandListView sets whether selections can be changed by
	// dragging with the mouse.
	SetEnableRubberbandListView(enableRubberband bool)
	// SetFactoryListView sets the `GtkListItemFactory` to use for populating
	// list items.
	SetFactoryListView(factory ListItemFactory)
	// SetModelListView sets the model to use.
	//
	// This must be a [iface@Gtk.SelectionModel] to use.
	SetModelListView(model SelectionModel)
	// SetShowSeparatorsListView sets whether the list box should show
	// separators between rows.
	SetShowSeparatorsListView(showSeparators bool)
	// SetSingleClickActivateListView sets whether rows should be activated on
	// single click and selected on hover.
	SetSingleClickActivateListView(singleClickActivate bool)
}

// listView implements the ListView class.
type listView struct {
	ListBase
}

// WrapListView wraps a GObject to the right type. It is
// primarily used internally.
func WrapListView(obj *externglib.Object) ListView {
	return listView{
		ListBase: WrapListBase(obj),
	}
}

func marshalListView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListView(obj), nil
}

// NewListView creates a new `GtkListView` that uses the given @factory for
// mapping items to widgets.
//
// The function takes ownership of the arguments, so you can write code like `c
// list_view = gtk_list_view_new (create_model (),
// gtk_builder_list_item_factory_new_from_resource ("/resource.ui")); `
func NewListView(model SelectionModel, factory ListItemFactory) ListView {
	var _arg1 *C.GtkSelectionModel  // out
	var _arg2 *C.GtkListItemFactory // out
	var _cret *C.GtkWidget          // in

	_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

	_cret = C.gtk_list_view_new(_arg1, _arg2)

	var _listView ListView // out

	_listView = WrapListView(externglib.Take(unsafe.Pointer(_cret)))

	return _listView
}

func (s listView) EnableRubberband() bool {
	var _arg0 *C.GtkListView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_view_get_enable_rubberband(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s listView) Factory() ListItemFactory {
	var _arg0 *C.GtkListView        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_view_get_factory(_arg0)

	var _listItemFactory ListItemFactory // out

	_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

	return _listItemFactory
}

func (s listView) Model() SelectionModel {
	var _arg0 *C.GtkListView       // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_view_get_model(_arg0)

	var _selectionModel SelectionModel // out

	_selectionModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SelectionModel)

	return _selectionModel
}

func (s listView) ShowSeparators() bool {
	var _arg0 *C.GtkListView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_view_get_show_separators(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s listView) SingleClickActivate() bool {
	var _arg0 *C.GtkListView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_list_view_get_single_click_activate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s listView) SetEnableRubberbandListView(enableRubberband bool) {
	var _arg0 *C.GtkListView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
	if enableRubberband {
		_arg1 = C.TRUE
	}

	C.gtk_list_view_set_enable_rubberband(_arg0, _arg1)
}

func (s listView) SetFactoryListView(factory ListItemFactory) {
	var _arg0 *C.GtkListView        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

	C.gtk_list_view_set_factory(_arg0, _arg1)
}

func (s listView) SetModelListView(model SelectionModel) {
	var _arg0 *C.GtkListView       // out
	var _arg1 *C.GtkSelectionModel // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

	C.gtk_list_view_set_model(_arg0, _arg1)
}

func (s listView) SetShowSeparatorsListView(showSeparators bool) {
	var _arg0 *C.GtkListView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
	if showSeparators {
		_arg1 = C.TRUE
	}

	C.gtk_list_view_set_show_separators(_arg0, _arg1)
}

func (s listView) SetSingleClickActivateListView(singleClickActivate bool) {
	var _arg0 *C.GtkListView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
	if singleClickActivate {
		_arg1 = C.TRUE
	}

	C.gtk_list_view_set_single_click_activate(_arg0, _arg1)
}

func (s listView) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s listView) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s listView) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s listView) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s listView) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s listView) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s listView) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b listView) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o listView) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o listView) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

func (s listView) Border() (Border, bool) {
	return WrapScrollable(gextras.InternObject(s)).Border()
}

func (s listView) HAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).HAdjustment()
}

func (s listView) HScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).HScrollPolicy()
}

func (s listView) VAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).VAdjustment()
}

func (s listView) VScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).VScrollPolicy()
}

func (s listView) SetHAdjustment(hadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetHAdjustment(hadjustment)
}

func (s listView) SetHScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetHScrollPolicy(policy)
}

func (s listView) SetVAdjustment(vadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetVAdjustment(vadjustment)
}

func (s listView) SetVScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetVScrollPolicy(policy)
}

// LockButton: `GtkLockButton` is a widget to obtain and revoke authorizations
// needed to operate the controls.
//
// !An example GtkLockButton (lock-button.png)
//
// It is typically used in preference dialogs or control panels.
//
// The required authorization is represented by a `GPermission` object. Concrete
// implementations of `GPermission` may use PolicyKit or some other
// authorization framework. To obtain a PolicyKit-based `GPermission`, use
// `polkit_permission_new()`.
//
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
//
// ! (lockbutton-locked.png)
//
// and the user can click the button to request the permission. Depending on the
// platform, this may pop up an authentication dialog or ask the user to
// authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
//
// ! (lockbutton-unlocked.png)
//
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
//
// ! (lockbutton-sorry.png)
//
// If the user has the permission and cannot drop it, the button is hidden.
//
// The text (and tooltips) that are shown in the various cases can be adjusted
// with the [property@Gtk.LockButton:text-lock],
// [property@Gtk.LockButton:text-unlock],
// [property@Gtk.LockButton:tooltip-lock],
// [property@Gtk.LockButton:tooltip-unlock] and
// [property@Gtk.LockButton:tooltip-not-authorized] properties.
type LockButton interface {
	Button

	// Permission obtains the `GPermission` object that controls @button.
	Permission() gio.Permission
	// SetPermissionLockButton sets the `GPermission` object that controls
	// @button.
	SetPermissionLockButton(permission gio.Permission)
}

// lockButton implements the LockButton class.
type lockButton struct {
	Button
}

// WrapLockButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLockButton(obj *externglib.Object) LockButton {
	return lockButton{
		Button: WrapButton(obj),
	}
}

func marshalLockButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLockButton(obj), nil
}

// NewLockButton creates a new lock button which reflects the @permission.
func NewLockButton(permission gio.Permission) LockButton {
	var _arg1 *C.GPermission // out
	var _cret *C.GtkWidget   // in

	_arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

	_cret = C.gtk_lock_button_new(_arg1)

	var _lockButton LockButton // out

	_lockButton = WrapLockButton(externglib.Take(unsafe.Pointer(_cret)))

	return _lockButton
}

func (b lockButton) Permission() gio.Permission {
	var _arg0 *C.GtkLockButton // out
	var _cret *C.GPermission   // in

	_arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_lock_button_get_permission(_arg0)

	var _permission gio.Permission // out

	_permission = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Permission)

	return _permission
}

func (b lockButton) SetPermissionLockButton(permission gio.Permission) {
	var _arg0 *C.GtkLockButton // out
	var _arg1 *C.GPermission   // out

	_arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

	C.gtk_lock_button_set_permission(_arg0, _arg1)
}

func (s lockButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s lockButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s lockButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s lockButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s lockButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s lockButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s lockButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (a lockButton) ActionName() string {
	return WrapActionable(gextras.InternObject(a)).ActionName()
}

func (a lockButton) ActionTargetValue() *glib.Variant {
	return WrapActionable(gextras.InternObject(a)).ActionTargetValue()
}

func (a lockButton) SetActionName(actionName string) {
	WrapActionable(gextras.InternObject(a)).SetActionName(actionName)
}

func (a lockButton) SetActionTargetValue(targetValue *glib.Variant) {
	WrapActionable(gextras.InternObject(a)).SetActionTargetValue(targetValue)
}

func (a lockButton) SetDetailedActionName(detailedActionName string) {
	WrapActionable(gextras.InternObject(a)).SetDetailedActionName(detailedActionName)
}

func (b lockButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// MapListModel: a `GtkMapListModel` maps the items in a list model to different
// items.
//
// `GtkMapListModel` uses a [callback@Gtk.MapListModelMapFunc].
//
// Example: Create a list of `GtkEventControllers` `c static gpointer
// map_to_controllers (gpointer widget, gpointer data) { gpointer result =
// gtk_widget_observe_controllers (widget); g_object_unref (widget); return
// result; }
//
// widgets = gtk_widget_observe_children (widget);
//
// controllers = gtk_map_list_model_new (G_TYPE_LIST_MODEL, widgets,
// map_to_controllers, NULL, NULL);
//
// model = gtk_flatten_list_model_new (GTK_TYPE_EVENT_CONTROLLER, controllers);
// `
//
// `GtkMapListModel` will attempt to discard the mapped objects as soon as they
// are no longer needed and recreate them if necessary.
type MapListModel interface {
	gio.ListModel

	// Model gets the model that is currently being mapped or nil if none.
	Model() gio.ListModel
	// HasMapMapListModel checks if a map function is currently set on @self.
	HasMapMapListModel() bool
	// SetModelMapListModel sets the model to be mapped.
	//
	// GTK makes no effort to ensure that @model conforms to the item type
	// expected by the map function. It assumes that the caller knows what they
	// are doing and have set up an appropriate map function.
	SetModelMapListModel(model gio.ListModel)
}

// mapListModel implements the MapListModel class.
type mapListModel struct {
	gextras.Objector
}

// WrapMapListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapMapListModel(obj *externglib.Object) MapListModel {
	return mapListModel{
		Objector: obj,
	}
}

func marshalMapListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMapListModel(obj), nil
}

func (s mapListModel) Model() gio.ListModel {
	var _arg0 *C.GtkMapListModel // out
	var _cret *C.GListModel      // in

	_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_map_list_model_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s mapListModel) HasMapMapListModel() bool {
	var _arg0 *C.GtkMapListModel // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_map_list_model_has_map(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mapListModel) SetModelMapListModel(model gio.ListModel) {
	var _arg0 *C.GtkMapListModel // out
	var _arg1 *C.GListModel      // out

	_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	C.gtk_map_list_model_set_model(_arg0, _arg1)
}

// MediaControls: `GtkMediaControls` is a widget to show controls for a video.
//
// !An example GtkMediaControls (media-controls.png)
//
// Usually, `GtkMediaControls` is used as part of [class@Gtk.Video].
type MediaControls interface {
	Widget

	// MediaStream gets the media stream managed by @controls or nil if none.
	MediaStream() MediaStream
	// SetMediaStreamMediaControls sets the stream that is controlled by
	// @controls.
	SetMediaStreamMediaControls(stream MediaStream)
}

// mediaControls implements the MediaControls class.
type mediaControls struct {
	Widget
}

// WrapMediaControls wraps a GObject to the right type. It is
// primarily used internally.
func WrapMediaControls(obj *externglib.Object) MediaControls {
	return mediaControls{
		Widget: WrapWidget(obj),
	}
}

func marshalMediaControls(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMediaControls(obj), nil
}

// NewMediaControls creates a new `GtkMediaControls` managing the @stream passed
// to it.
func NewMediaControls(stream MediaStream) MediaControls {
	var _arg1 *C.GtkMediaStream // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(stream.Native()))

	_cret = C.gtk_media_controls_new(_arg1)

	var _mediaControls MediaControls // out

	_mediaControls = WrapMediaControls(externglib.Take(unsafe.Pointer(_cret)))

	return _mediaControls
}

func (c mediaControls) MediaStream() MediaStream {
	var _arg0 *C.GtkMediaControls // out
	var _cret *C.GtkMediaStream   // in

	_arg0 = (*C.GtkMediaControls)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_media_controls_get_media_stream(_arg0)

	var _mediaStream MediaStream // out

	_mediaStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(MediaStream)

	return _mediaStream
}

func (c mediaControls) SetMediaStreamMediaControls(stream MediaStream) {
	var _arg0 *C.GtkMediaControls // out
	var _arg1 *C.GtkMediaStream   // out

	_arg0 = (*C.GtkMediaControls)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(stream.Native()))

	C.gtk_media_controls_set_media_stream(_arg0, _arg1)
}

func (s mediaControls) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s mediaControls) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s mediaControls) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s mediaControls) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s mediaControls) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s mediaControls) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s mediaControls) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b mediaControls) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// MediaFile: `GtkMediaFile` implements `GtkMediaStream` for files.
//
// This provides a simple way to play back video files with GTK.
//
// GTK provides a GIO extension point for `GtkMediaFile` implementations to
// allow for external implementations using various media frameworks.
//
// GTK itself includes implementations using GStreamer and ffmpeg.
type MediaFile interface {
	MediaStream

	// ClearMediaFile resets the media file to be empty.
	ClearMediaFile()
	// File returns the file that @self is currently playing from.
	//
	// When @self is not playing or not playing from a file, nil is returned.
	File() gio.File
	// InputStream returns the stream that @self is currently playing from.
	//
	// When @self is not playing or not playing from a stream, nil is returned.
	InputStream() gio.InputStream
	// SetFileMediaFile sets the `GtkMediaFile` to play the given file.
	//
	// If any file is still playing, stop playing it.
	SetFileMediaFile(file gio.File)
	// SetFilenameMediaFile sets the `GtkMediaFile to play the given file.
	//
	// This is a utility function that converts the given @filename to a `GFile`
	// and calls [method@Gtk.MediaFile.set_file].
	SetFilenameMediaFile(filename string)
	// SetInputStreamMediaFile sets the `GtkMediaFile` to play the given stream.
	//
	// If anything is still playing, stop playing it.
	//
	// Full control about the @stream is assumed for the duration of playback.
	// The stream will not be closed.
	SetInputStreamMediaFile(stream gio.InputStream)
	// SetResourceMediaFile sets the `GtkMediaFile to play the given resource.
	//
	// This is a utility function that converts the given @resource_path to a
	// `GFile` and calls [method@Gtk.MediaFile.set_file].
	SetResourceMediaFile(resourcePath string)
}

// mediaFile implements the MediaFile class.
type mediaFile struct {
	MediaStream
}

// WrapMediaFile wraps a GObject to the right type. It is
// primarily used internally.
func WrapMediaFile(obj *externglib.Object) MediaFile {
	return mediaFile{
		MediaStream: WrapMediaStream(obj),
	}
}

func marshalMediaFile(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMediaFile(obj), nil
}

// NewMediaFile creates a new empty media file.
func NewMediaFile() MediaFile {
	var _cret *C.GtkMediaStream // in

	_cret = C.gtk_media_file_new()

	var _mediaFile MediaFile // out

	_mediaFile = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

// NewMediaFileForFile creates a new media file to play @file.
func NewMediaFileForFile(file gio.File) MediaFile {
	var _arg1 *C.GFile          // out
	var _cret *C.GtkMediaStream // in

	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	_cret = C.gtk_media_file_new_for_file(_arg1)

	var _mediaFile MediaFile // out

	_mediaFile = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

// NewMediaFileForFilename creates a new media file for the given filename.
//
// This is a utility function that converts the given @filename to a `GFile` and
// calls [ctor@Gtk.MediaFile.new_for_file].
func NewMediaFileForFilename(filename string) MediaFile {
	var _arg1 *C.char           // out
	var _cret *C.GtkMediaStream // in

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_media_file_new_for_filename(_arg1)

	var _mediaFile MediaFile // out

	_mediaFile = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

// NewMediaFileForInputStream creates a new media file to play @stream.
//
// If you want the resulting media to be seekable, the stream should implement
// the `GSeekable` interface.
func NewMediaFileForInputStream(stream gio.InputStream) MediaFile {
	var _arg1 *C.GInputStream   // out
	var _cret *C.GtkMediaStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))

	_cret = C.gtk_media_file_new_for_input_stream(_arg1)

	var _mediaFile MediaFile // out

	_mediaFile = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

// NewMediaFileForResource creates a new new media file for the given resource.
//
// This is a utility function that converts the given @resource to a `GFile` and
// calls [ctor@Gtk.MediaFile.new_for_file].
func NewMediaFileForResource(resourcePath string) MediaFile {
	var _arg1 *C.char           // out
	var _cret *C.GtkMediaStream // in

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_media_file_new_for_resource(_arg1)

	var _mediaFile MediaFile // out

	_mediaFile = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

func (s mediaFile) ClearMediaFile() {
	var _arg0 *C.GtkMediaFile // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))

	C.gtk_media_file_clear(_arg0)
}

func (s mediaFile) File() gio.File {
	var _arg0 *C.GtkMediaFile // out
	var _cret *C.GFile        // in

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_file_get_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

func (s mediaFile) InputStream() gio.InputStream {
	var _arg0 *C.GtkMediaFile // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_file_get_input_stream(_arg0)

	var _inputStream gio.InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.InputStream)

	return _inputStream
}

func (s mediaFile) SetFileMediaFile(file gio.File) {
	var _arg0 *C.GtkMediaFile // out
	var _arg1 *C.GFile        // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_media_file_set_file(_arg0, _arg1)
}

func (s mediaFile) SetFilenameMediaFile(filename string) {
	var _arg0 *C.GtkMediaFile // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_media_file_set_filename(_arg0, _arg1)
}

func (s mediaFile) SetInputStreamMediaFile(stream gio.InputStream) {
	var _arg0 *C.GtkMediaFile // out
	var _arg1 *C.GInputStream // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))

	C.gtk_media_file_set_input_stream(_arg0, _arg1)
}

func (s mediaFile) SetResourceMediaFile(resourcePath string) {
	var _arg0 *C.GtkMediaFile // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_media_file_set_resource(_arg0, _arg1)
}

// MediaStream: `GtkMediaStream` is the integration point for media playback
// inside GTK.
//
// GTK provides an implementation of the `GtkMediaStream` interface that is
// called [class@Gtk.MediaFile].
//
// Apart from application-facing API for stream playback, `GtkMediaStream` has a
// number of APIs that are only useful for implementations and should not be
// used in applications: [method@Gtk.MediaStream.prepared],
// [method@Gtk.MediaStream.unprepared], [method@Gtk.MediaStream.update],
// [method@Gtk.MediaStream.ended], [method@Gtk.MediaStream.seek_success],
// [method@Gtk.MediaStream.seek_failed], [method@Gtk.MediaStream.gerror],
// [method@Gtk.MediaStream.error], [method@Gtk.MediaStream.error_valist].
type MediaStream interface {
	gdk.Paintable

	// EndedMediaStream pauses the media stream and marks it as ended.
	//
	// This is a hint only, calls to GtkMediaStream.play() may still happen.
	//
	// The media stream must be prepared when this function is called.
	EndedMediaStream()
	// GerrorMediaStream sets @self into an error state.
	//
	// This will pause the stream (you can check for an error via
	// [method@Gtk.MediaStream.get_error] in your GtkMediaStream.pause()
	// implementation), abort pending seeks and mark the stream as prepared.
	//
	// if the stream is already in an error state, this call will be ignored and
	// the existing error will be retained.
	//
	// To unset an error, the stream must be reset via a call to
	// [method@Gtk.MediaStream.unprepared].
	GerrorMediaStream(err error)
	// Duration gets the duration of the stream.
	//
	// If the duration is not known, 0 will be returned.
	Duration() int64
	// Ended returns whether the streams playback is finished.
	Ended() bool
	// Error: if the stream is in an error state, returns the `GError`
	// explaining that state.
	//
	// Any type of error can be reported here depending on the implementation of
	// the media stream.
	//
	// A media stream in an error cannot be operated on, calls like
	// [method@Gtk.MediaStream.play] or [method@Gtk.MediaStream.seek] will not
	// have any effect.
	//
	// `GtkMediaStream` itself does not provide a way to unset an error, but
	// implementations may provide options. For example, a [class@Gtk.MediaFile]
	// will unset errors when a new source is set, e.g. with
	// [method@Gtk.MediaFile.set_file].
	Error() error
	// Loop returns whether the stream is set to loop.
	//
	// See [method@Gtk.MediaStream.set_loop] for details.
	Loop() bool
	// Muted returns whether the audio for the stream is muted.
	//
	// See [method@Gtk.MediaStream.set_muted] for details.
	Muted() bool
	// Playing: return whether the stream is currently playing.
	Playing() bool
	// Timestamp returns the current presentation timestamp in microseconds.
	Timestamp() int64
	// Volume returns the volume of the audio for the stream.
	//
	// See [method@Gtk.MediaStream.set_volume] for details.
	Volume() float64
	// HasAudioMediaStream returns whether the stream has audio.
	HasAudioMediaStream() bool
	// HasVideoMediaStream returns whether the stream has video.
	HasVideoMediaStream() bool
	// IsPreparedMediaStream returns whether the stream has finished
	// initializing.
	//
	// At this point the existence of audio and video is known.
	IsPreparedMediaStream() bool
	// IsSeekableMediaStream checks if a stream may be seekable.
	//
	// This is meant to be a hint. Streams may not allow seeking even if this
	// function returns true. However, if this function returns false, streams
	// are guaranteed to not be seekable and user interfaces may hide controls
	// that allow seeking.
	//
	// It is allowed to call [method@Gtk.MediaStream.seek] on a non-seekable
	// stream, though it will not do anything.
	IsSeekableMediaStream() bool
	// IsSeekingMediaStream checks if there is currently a seek operation going
	// on.
	IsSeekingMediaStream() bool
	// PauseMediaStream pauses playback of the stream.
	//
	// If the stream is not playing, do nothing.
	PauseMediaStream()
	// PlayMediaStream starts playing the stream.
	//
	// If the stream is in error or already playing, do nothing.
	PlayMediaStream()
	// PreparedMediaStream: called by `GtkMediaStream` implementations to
	// advertise the stream being ready to play and providing details about the
	// stream.
	//
	// Note that the arguments are hints. If the stream implementation cannot
	// determine the correct values, it is better to err on the side of caution
	// and return true. User interfaces will use those values to determine what
	// controls to show.
	//
	// This function may not be called again until the stream has been reset via
	// [method@Gtk.MediaStream.unprepared].
	PreparedMediaStream(hasAudio bool, hasVideo bool, seekable bool, duration int64)
	// RealizeMediaStream: called by users to attach the media stream to a
	// `GdkSurface` they manage.
	//
	// The stream can then access the resources of @surface for its rendering
	// purposes. In particular, media streams might want to create a
	// `GdkGLContext` or sync to the `GdkFrameClock`.
	//
	// Whoever calls this function is responsible for calling
	// [method@Gtk.MediaStream.unrealize] before either the stream or @surface
	// get destroyed.
	//
	// Multiple calls to this function may happen from different users of the
	// video, even with the same @surface. Each of these calls must be followed
	// by its own call to [method@Gtk.MediaStream.unrealize].
	//
	// It is not required to call this function to make a media stream work.
	RealizeMediaStream(surface gdk.Surface)
	// SeekMediaStream: start a seek operation on @self to @timestamp.
	//
	// If @timestamp is out of range, it will be clamped.
	//
	// Seek operations may not finish instantly. While a seek operation is in
	// process, the [property@Gtk.MediaStream:seeking] property will be set.
	//
	// When calling gtk_media_stream_seek() during an ongoing seek operation,
	// the new seek will override any pending seek.
	SeekMediaStream(timestamp int64)
	// SeekFailedMediaStream ends a seek operation started via
	// GtkMediaStream.seek() as a failure.
	//
	// This will not cause an error on the stream and will assume that playback
	// continues as if no seek had happened.
	//
	// See [method@Gtk.MediaStream.seek_success] for the other way of ending a
	// seek.
	SeekFailedMediaStream()
	// SeekSuccessMediaStream ends a seek operation started via
	// GtkMediaStream.seek() successfully.
	//
	// This function will unset the GtkMediaStream:ended property if it was set.
	//
	// See [method@Gtk.MediaStream.seek_failed] for the other way of ending a
	// seek.
	SeekSuccessMediaStream()
	// SetLoopMediaStream sets whether the stream should loop.
	//
	// In this case, it will attempt to restart playback from the beginning
	// instead of stopping at the end.
	//
	// Not all streams may support looping, in particular non-seekable streams.
	// Those streams will ignore the loop setting and just end.
	SetLoopMediaStream(loop bool)
	// SetMutedMediaStream sets whether the audio stream should be muted.
	//
	// Muting a stream will cause no audio to be played, but it does not modify
	// the volume. This means that muting and then unmuting the stream will
	// restore the volume settings.
	//
	// If the stream has no audio, calling this function will still work but it
	// will not have an audible effect.
	SetMutedMediaStream(muted bool)
	// SetPlayingMediaStream starts or pauses playback of the stream.
	SetPlayingMediaStream(playing bool)
	// SetVolumeMediaStream sets the volume of the audio stream.
	//
	// This function call will work even if the stream is muted.
	//
	// The given @volume should range from 0.0 for silence to 1.0 for as loud as
	// possible. Values outside of this range will be clamped to the nearest
	// value.
	//
	// If the stream has no audio or is muted, calling this function will still
	// work but it will not have an immediate audible effect. When the stream is
	// unmuted, the new volume setting will take effect.
	SetVolumeMediaStream(volume float64)
	// UnpreparedMediaStream resets a given media stream implementation.
	//
	// [method@Gtk.MediaStream.prepared] can then be called again.
	//
	// This function will also reset any error state the stream was in.
	UnpreparedMediaStream()
	// UnrealizeMediaStream undoes a previous call to
	// gtk_media_stream_realize().
	//
	// This causes the stream to release all resources it had allocated from
	// @surface.
	UnrealizeMediaStream(surface gdk.Surface)
	// UpdateMediaStream: media stream implementations should regularly call
	// this function to update the timestamp reported by the stream.
	//
	// It is up to implementations to call this at the frequency they deem
	// appropriate.
	//
	// The media stream must be prepared when this function is called.
	UpdateMediaStream(timestamp int64)
}

// mediaStream implements the MediaStream class.
type mediaStream struct {
	gextras.Objector
}

// WrapMediaStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapMediaStream(obj *externglib.Object) MediaStream {
	return mediaStream{
		Objector: obj,
	}
}

func marshalMediaStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMediaStream(obj), nil
}

func (s mediaStream) EndedMediaStream() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_ended(_arg0)
}

func (s mediaStream) GerrorMediaStream(err error) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 *C.GError         // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GError)(gerror.New(err))

	C.gtk_media_stream_gerror(_arg0, _arg1)
}

func (s mediaStream) Duration() int64 {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gint64          // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_get_duration(_arg0)

	var _gint64 int64 // out

	_gint64 = (int64)(_cret)

	return _gint64
}

func (s mediaStream) Ended() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_get_ended(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mediaStream) Error() error {
	var _arg0 *C.GtkMediaStream // out
	var _cret *C.GError         // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_get_error(_arg0)

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(_cret))

	return _err
}

func (s mediaStream) Loop() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_get_loop(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mediaStream) Muted() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_get_muted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mediaStream) Playing() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_get_playing(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mediaStream) Timestamp() int64 {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gint64          // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_get_timestamp(_arg0)

	var _gint64 int64 // out

	_gint64 = (int64)(_cret)

	return _gint64
}

func (s mediaStream) Volume() float64 {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.double          // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_get_volume(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s mediaStream) HasAudioMediaStream() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_has_audio(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mediaStream) HasVideoMediaStream() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_has_video(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mediaStream) IsPreparedMediaStream() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_is_prepared(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mediaStream) IsSeekableMediaStream() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_is_seekable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mediaStream) IsSeekingMediaStream() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_media_stream_is_seeking(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s mediaStream) PauseMediaStream() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_pause(_arg0)
}

func (s mediaStream) PlayMediaStream() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_play(_arg0)
}

func (s mediaStream) PreparedMediaStream(hasAudio bool, hasVideo bool, seekable bool, duration int64) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gboolean        // out
	var _arg2 C.gboolean        // out
	var _arg3 C.gboolean        // out
	var _arg4 C.gint64          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	if hasAudio {
		_arg1 = C.TRUE
	}
	if hasVideo {
		_arg2 = C.TRUE
	}
	if seekable {
		_arg3 = C.TRUE
	}
	_arg4 = (C.gint64)(duration)

	C.gtk_media_stream_prepared(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s mediaStream) RealizeMediaStream(surface gdk.Surface) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 *C.GdkSurface     // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

	C.gtk_media_stream_realize(_arg0, _arg1)
}

func (s mediaStream) SeekMediaStream(timestamp int64) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gint64          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint64)(timestamp)

	C.gtk_media_stream_seek(_arg0, _arg1)
}

func (s mediaStream) SeekFailedMediaStream() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_seek_failed(_arg0)
}

func (s mediaStream) SeekSuccessMediaStream() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_seek_success(_arg0)
}

func (s mediaStream) SetLoopMediaStream(loop bool) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	if loop {
		_arg1 = C.TRUE
	}

	C.gtk_media_stream_set_loop(_arg0, _arg1)
}

func (s mediaStream) SetMutedMediaStream(muted bool) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	if muted {
		_arg1 = C.TRUE
	}

	C.gtk_media_stream_set_muted(_arg0, _arg1)
}

func (s mediaStream) SetPlayingMediaStream(playing bool) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	if playing {
		_arg1 = C.TRUE
	}

	C.gtk_media_stream_set_playing(_arg0, _arg1)
}

func (s mediaStream) SetVolumeMediaStream(volume float64) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.double          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(volume)

	C.gtk_media_stream_set_volume(_arg0, _arg1)
}

func (s mediaStream) UnpreparedMediaStream() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_unprepared(_arg0)
}

func (s mediaStream) UnrealizeMediaStream(surface gdk.Surface) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 *C.GdkSurface     // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

	C.gtk_media_stream_unrealize(_arg0, _arg1)
}

func (s mediaStream) UpdateMediaStream(timestamp int64) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gint64          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint64)(timestamp)

	C.gtk_media_stream_update(_arg0, _arg1)
}

// MenuButton: the `GtkMenuButton` widget is used to display a popup when
// clicked.
//
// !An example GtkMenuButton (menu-button.png)
//
// This popup can be provided either as a `GtkPopover` or as an abstract
// `GMenuModel`.
//
// The `GtkMenuButton` widget can show either an icon (set with the
// [property@Gtk.MenuButton:icon-name] property) or a label (set with the
// [property@Gtk.MenuButton:label] property). If neither is explicitly set, a
// [class@Gtk.Image] is automatically created, using an arrow image oriented
// according to [property@Gtk.MenuButton:direction] or the generic
// open-menu-symbolic icon if the direction is not set.
//
// The positioning of the popup is determined by the
// [property@Gtk.MenuButton:direction] property of the menu button.
//
// For menus, the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
// properties of the menu are also taken into account. For example, when the
// direction is GTK_ARROW_DOWN and the horizontal alignment is GTK_ALIGN_START,
// the menu will be positioned below the button, with the starting edge
// (depending on the text direction) of the menu aligned with the starting edge
// of the button. If there is not enough space below the button, the menu is
// popped up above the button instead. If the alignment would move part of the
// menu offscreen, it is pushed in.
//
// | | start | center | end | | - | --- | --- | --- | | **down** | !
// (down-start.png) | ! (down-center.png) | ! (down-end.png) | | **up** | !
// (up-start.png) | ! (up-center.png) | ! (up-end.png) | | **left** | !
// (left-start.png) | ! (left-center.png) | ! (left-end.png) | | **right** | !
// (right-start.png) | ! (right-center.png) | ! (right-end.png) |
//
//
// CSS nodes
//
// ` menubutton  button.toggle  <content>  [arrow] `
//
// `GtkMenuButton` has a single CSS node with name `menubutton` which contains a
// `button` node with a `.toggle` style class.
//
// Inside the toggle button content, there is an `arrow` node for the indicator,
// which will carry one of the `.none`, `.up`, `.down`, `.left` or `.right`
// style classes to indicate the direction that the menu will appear in. The CSS
// is expected to provide a suitable image for each of these cases using the
// `-gtk-icon-source` property.
//
// Optionally, the `menubutton` node can carry the `.circular` style class to
// request a round appearance.
//
//
// Accessibility
//
// `GtkMenuButton` uses the K_ACCESSIBLE_ROLE_BUTTON role.
type MenuButton interface {
	Widget

	// Direction returns the direction the popup will be pointing at when popped
	// up.
	Direction() ArrowType
	// HasFrame returns whether the button has a frame.
	HasFrame() bool
	// IconName gets the name of the icon shown in the button.
	IconName() string
	// Label gets the label shown in the button
	Label() string
	// MenuModel returns the `GMenuModel` used to generate the popup.
	MenuModel() gio.MenuModel
	// Popover returns the `GtkPopover` that pops out of the button.
	//
	// If the button is not using a `GtkPopover`, this function returns nil.
	Popover() Popover
	// UseUnderline returns whether an embedded underline in the text indicates
	// a mnemonic.
	UseUnderline() bool
	// PopdownMenuButton dismiss the menu.
	PopdownMenuButton()
	// PopupMenuButton: pop up the menu.
	PopupMenuButton()
	// SetDirectionMenuButton sets the direction in which the popup will be
	// popped up.
	//
	// If the button is automatically populated with an arrow icon, its
	// direction will be changed to match.
	//
	// If the does not fit in the available space in the given direction, GTK
	// will its best to keep it inside the screen and fully visible.
	//
	// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if
	// you passed GTK_ARROW_DOWN (although you wont see any arrows).
	SetDirectionMenuButton(direction ArrowType)
	// SetHasFrameMenuButton sets the style of the button.
	SetHasFrameMenuButton(hasFrame bool)
	// SetIconNameMenuButton sets the name of an icon to show inside the menu
	// button.
	SetIconNameMenuButton(iconName string)
	// SetLabelMenuButton sets the label to show inside the menu button.
	SetLabelMenuButton(label string)
	// SetMenuModelMenuButton sets the `GMenuModel` from which the popup will be
	// constructed.
	//
	// If @menu_model is nil, the button is disabled.
	//
	// A [class@Gtk.Popover] will be created from the menu model with
	// [ctor@Gtk.PopoverMenu.new_from_model]. Actions will be connected as
	// documented for this function.
	//
	// If [property@Gtk.MenuButton:popover] is already set, it will be
	// dissociated from the @menu_button, and the property is set to nil.
	SetMenuModelMenuButton(menuModel gio.MenuModel)
	// SetPopoverMenuButton sets the `GtkPopover` that will be popped up when
	// the @menu_button is clicked.
	//
	// If @popover is nil, the button is disabled.
	//
	// If [property@Gtk.MenuButton:menu-model] is set, the menu model is
	// dissociated from the @menu_button, and the property is set to nil.
	SetPopoverMenuButton(popover Widget)
	// SetUseUnderlineMenuButton: if true, an underline in the text indicates a
	// mnemonic.
	SetUseUnderlineMenuButton(useUnderline bool)
}

// menuButton implements the MenuButton class.
type menuButton struct {
	Widget
}

// WrapMenuButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuButton(obj *externglib.Object) MenuButton {
	return menuButton{
		Widget: WrapWidget(obj),
	}
}

func marshalMenuButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuButton(obj), nil
}

// NewMenuButton creates a new `GtkMenuButton` widget with downwards-pointing
// arrow as the only child.
//
// You can replace the child widget with another `GtkWidget` should you wish to.
func NewMenuButton() MenuButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_menu_button_new()

	var _menuButton MenuButton // out

	_menuButton = WrapMenuButton(externglib.Take(unsafe.Pointer(_cret)))

	return _menuButton
}

func (m menuButton) Direction() ArrowType {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.GtkArrowType   // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_direction(_arg0)

	var _arrowType ArrowType // out

	_arrowType = ArrowType(_cret)

	return _arrowType
}

func (m menuButton) HasFrame() bool {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_has_frame(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m menuButton) IconName() string {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m menuButton) Label() string {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m menuButton) MenuModel() gio.MenuModel {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GMenuModel    // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_menu_model(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (m menuButton) Popover() Popover {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GtkPopover    // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_popover(_arg0)

	var _popover Popover // out

	_popover = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Popover)

	return _popover
}

func (m menuButton) UseUnderline() bool {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m menuButton) PopdownMenuButton() {
	var _arg0 *C.GtkMenuButton // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	C.gtk_menu_button_popdown(_arg0)
}

func (m menuButton) PopupMenuButton() {
	var _arg0 *C.GtkMenuButton // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	C.gtk_menu_button_popup(_arg0)
}

func (m menuButton) SetDirectionMenuButton(direction ArrowType) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.GtkArrowType   // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GtkArrowType)(direction)

	C.gtk_menu_button_set_direction(_arg0, _arg1)
}

func (m menuButton) SetHasFrameMenuButton(hasFrame bool) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	if hasFrame {
		_arg1 = C.TRUE
	}

	C.gtk_menu_button_set_has_frame(_arg0, _arg1)
}

func (m menuButton) SetIconNameMenuButton(iconName string) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_button_set_icon_name(_arg0, _arg1)
}

func (m menuButton) SetLabelMenuButton(label string) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_button_set_label(_arg0, _arg1)
}

func (m menuButton) SetMenuModelMenuButton(menuModel gio.MenuModel) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GMenuModel    // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(menuModel.Native()))

	C.gtk_menu_button_set_menu_model(_arg0, _arg1)
}

func (m menuButton) SetPopoverMenuButton(popover Widget) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(popover.Native()))

	C.gtk_menu_button_set_popover(_arg0, _arg1)
}

func (m menuButton) SetUseUnderlineMenuButton(useUnderline bool) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_menu_button_set_use_underline(_arg0, _arg1)
}

func (s menuButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s menuButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s menuButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s menuButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s menuButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s menuButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s menuButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b menuButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// MessageDialog: `GtkMessageDialog` presents a dialog with some message text.
//
// !An example GtkMessageDialog (messagedialog.png)
//
// Its simply a convenience widget; you could construct the equivalent of
// `GtkMessageDialog` from `GtkDialog` without too much effort, but
// `GtkMessageDialog` saves typing.
//
// The easiest way to do a modal message dialog is to use the GTK_DIALOG_MODAL
// flag, which will call [method@Gtk.Window.set_modal] internally. The dialog
// will prevent interaction with the parent window until it's hidden or
// destroyed. You can use the [signal@Gtk.Dialog::response] signal to know when
// the user dismissed the dialog.
//
// An example for using a modal dialog: `c GtkDialogFlags flags =
// GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL; dialog =
// gtk_message_dialog_new (parent_window, flags, GTK_MESSAGE_ERROR,
// GTK_BUTTONS_CLOSE, "Error reading s: s", filename, g_strerror (errno)); //
// Destroy the dialog when the user responds to it // (e.g. clicks a button)
//
// g_signal_connect (dialog, "response", G_CALLBACK (gtk_window_destroy), NULL);
// `
//
// You might do a non-modal `GtkMessageDialog` simply by omitting the
// GTK_DIALOG_MODAL flag:
//
// `c GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT; dialog =
// gtk_message_dialog_new (parent_window, flags, GTK_MESSAGE_ERROR,
// GTK_BUTTONS_CLOSE, "Error reading s: s", filename, g_strerror (errno));
//
// // Destroy the dialog when the user responds to it // (e.g. clicks a button)
// // g_signal_connect (dialog, "response", G_CALLBACK (gtk_window_destroy), NULL);
// // `
//
//
// GtkMessageDialog as GtkBuildable
//
// The `GtkMessageDialog` implementation of the `GtkBuildable` interface exposes
// the message area as an internal child with the name message_area.
type MessageDialog interface {
	Dialog

	// MessageArea returns the message area of the dialog.
	//
	// This is the box where the dialogs primary and secondary labels are
	// packed. You can add your own extra content to that box and it will appear
	// below those labels. See [method@Gtk.Dialog.get_content_area] for the
	// corresponding function in the parent [class@Gtk.Dialog].
	MessageArea() Widget
	// SetMarkupMessageDialog sets the text of the message dialog.
	SetMarkupMessageDialog(str string)
}

// messageDialog implements the MessageDialog class.
type messageDialog struct {
	Dialog
}

// WrapMessageDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapMessageDialog(obj *externglib.Object) MessageDialog {
	return messageDialog{
		Dialog: WrapDialog(obj),
	}
}

func marshalMessageDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMessageDialog(obj), nil
}

func (m messageDialog) MessageArea() Widget {
	var _arg0 *C.GtkMessageDialog // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_message_dialog_get_message_area(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (m messageDialog) SetMarkupMessageDialog(str string) {
	var _arg0 *C.GtkMessageDialog // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_message_dialog_set_markup(_arg0, _arg1)
}

func (s messageDialog) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s messageDialog) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s messageDialog) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s messageDialog) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s messageDialog) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s messageDialog) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s messageDialog) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b messageDialog) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s messageDialog) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s messageDialog) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s messageDialog) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s messageDialog) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s messageDialog) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s messageDialog) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s messageDialog) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s messageDialog) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// MnemonicAction: a `GtkShortcutAction` that calls
// gtk_widget_mnemonic_activate().
type MnemonicAction interface {
}

// mnemonicAction implements the MnemonicAction class.
type mnemonicAction struct {
	ShortcutAction
}

// WrapMnemonicAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapMnemonicAction(obj *externglib.Object) MnemonicAction {
	return mnemonicAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalMnemonicAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMnemonicAction(obj), nil
}

// MnemonicTrigger: a `GtkShortcutTrigger` that triggers when a specific
// mnemonic is pressed.
//
// Mnemonics require a *mnemonic modifier* (typically <kbd>Alt</kbd>) to be
// pressed together with the mnemonic key.
type MnemonicTrigger interface {

	// Keyval gets the keyval that must be pressed to succeed triggering @self.
	Keyval() uint
}

// mnemonicTrigger implements the MnemonicTrigger class.
type mnemonicTrigger struct {
	ShortcutTrigger
}

// WrapMnemonicTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapMnemonicTrigger(obj *externglib.Object) MnemonicTrigger {
	return mnemonicTrigger{
		ShortcutTrigger: WrapShortcutTrigger(obj),
	}
}

func marshalMnemonicTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMnemonicTrigger(obj), nil
}

// NewMnemonicTrigger creates a `GtkShortcutTrigger` that will trigger whenever
// the key with the given @keyval is pressed and mnemonics have been activated.
//
// Mnemonics are activated by calling code when a key event with the right
// modifiers is detected.
func NewMnemonicTrigger(keyval uint) MnemonicTrigger {
	var _arg1 C.guint               // out
	var _cret *C.GtkShortcutTrigger // in

	_arg1 = (C.guint)(keyval)

	_cret = C.gtk_mnemonic_trigger_new(_arg1)

	var _mnemonicTrigger MnemonicTrigger // out

	_mnemonicTrigger = WrapMnemonicTrigger(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mnemonicTrigger
}

func (s mnemonicTrigger) Keyval() uint {
	var _arg0 *C.GtkMnemonicTrigger // out
	var _cret C.guint               // in

	_arg0 = (*C.GtkMnemonicTrigger)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_mnemonic_trigger_get_keyval(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// MountOperation: `GtkMountOperation` is an implementation of
// `GMountOperation`.
//
// The functions and objects described here make working with GTK and GIO more
// convenient.
//
// `GtkMountOperation` is needed when mounting volumes: It is an implementation
// of `GMountOperation` that can be used with GIO functions for mounting volumes
// such as g_file_mount_enclosing_volume(), g_file_mount_mountable(),
// g_volume_mount(), g_mount_unmount_with_operation() and others.
//
// When necessary, `GtkMountOperation` shows dialogs to let the user enter
// passwords, ask questions or show processes blocking unmount.
type MountOperation interface {

	// Display gets the display on which windows of the `GtkMountOperation` will
	// be shown.
	Display() gdk.Display
	// Parent gets the transient parent used by the `GtkMountOperation`.
	Parent() Window
	// IsShowingMountOperation returns whether the `GtkMountOperation` is
	// currently displaying a window.
	IsShowingMountOperation() bool
	// SetDisplayMountOperation sets the display to show windows of the
	// `GtkMountOperation` on.
	SetDisplayMountOperation(display gdk.Display)
	// SetParentMountOperation sets the transient parent for windows shown by
	// the `GtkMountOperation`.
	SetParentMountOperation(parent Window)
}

// mountOperation implements the MountOperation class.
type mountOperation struct {
	gio.MountOperation
}

// WrapMountOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapMountOperation(obj *externglib.Object) MountOperation {
	return mountOperation{
		MountOperation: gio.WrapMountOperation(obj),
	}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMountOperation(obj), nil
}

// NewMountOperation creates a new `GtkMountOperation`.
func NewMountOperation(parent Window) MountOperation {
	var _arg1 *C.GtkWindow       // out
	var _cret *C.GMountOperation // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_mount_operation_new(_arg1)

	var _mountOperation MountOperation // out

	_mountOperation = WrapMountOperation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mountOperation
}

func (o mountOperation) Display() gdk.Display {
	var _arg0 *C.GtkMountOperation // out
	var _cret *C.GdkDisplay        // in

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_mount_operation_get_display(_arg0)

	var _display gdk.Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

	return _display
}

func (o mountOperation) Parent() Window {
	var _arg0 *C.GtkMountOperation // out
	var _cret *C.GtkWindow         // in

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_mount_operation_get_parent(_arg0)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

func (o mountOperation) IsShowingMountOperation() bool {
	var _arg0 *C.GtkMountOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_mount_operation_is_showing(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o mountOperation) SetDisplayMountOperation(display gdk.Display) {
	var _arg0 *C.GtkMountOperation // out
	var _arg1 *C.GdkDisplay        // out

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	C.gtk_mount_operation_set_display(_arg0, _arg1)
}

func (o mountOperation) SetParentMountOperation(parent Window) {
	var _arg0 *C.GtkMountOperation // out
	var _arg1 *C.GtkWindow         // out

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	C.gtk_mount_operation_set_parent(_arg0, _arg1)
}

// MultiFilter: `GtkMultiFilter` is the base class for filters that combine
// multiple filters.
type MultiFilter interface {
	Filter
	gio.ListModel
	Buildable

	// AppendMultiFilter adds a @filter to @self to use for matching.
	AppendMultiFilter(filter Filter)
	// RemoveMultiFilter removes the filter at the given @position from the list
	// of filters used by @self.
	//
	// If @position is larger than the number of filters, nothing happens and
	// the function returns.
	RemoveMultiFilter(position uint)
}

// multiFilter implements the MultiFilter class.
type multiFilter struct {
	Filter
}

// WrapMultiFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMultiFilter(obj *externglib.Object) MultiFilter {
	return multiFilter{
		Filter: WrapFilter(obj),
	}
}

func marshalMultiFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMultiFilter(obj), nil
}

func (s multiFilter) AppendMultiFilter(filter Filter) {
	var _arg0 *C.GtkMultiFilter // out
	var _arg1 *C.GtkFilter      // out

	_arg0 = (*C.GtkMultiFilter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_multi_filter_append(_arg0, _arg1)
}

func (s multiFilter) RemoveMultiFilter(position uint) {
	var _arg0 *C.GtkMultiFilter // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkMultiFilter)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)

	C.gtk_multi_filter_remove(_arg0, _arg1)
}

func (b multiFilter) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// MultiSelection: `GtkMultiSelection` is a `GtkSelectionModel` that allows
// selecting multiple elements.
type MultiSelection interface {
	SelectionModel

	// Model returns the underlying model of @self.
	Model() gio.ListModel
	// SetModelMultiSelection sets the model that @self should wrap.
	//
	// If @model is nil, @self will be empty.
	SetModelMultiSelection(model gio.ListModel)
}

// multiSelection implements the MultiSelection class.
type multiSelection struct {
	gextras.Objector
}

// WrapMultiSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapMultiSelection(obj *externglib.Object) MultiSelection {
	return multiSelection{
		Objector: obj,
	}
}

func marshalMultiSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMultiSelection(obj), nil
}

// NewMultiSelection creates a new selection to handle @model.
func NewMultiSelection(model gio.ListModel) MultiSelection {
	var _arg1 *C.GListModel        // out
	var _cret *C.GtkMultiSelection // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_multi_selection_new(_arg1)

	var _multiSelection MultiSelection // out

	_multiSelection = WrapMultiSelection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _multiSelection
}

func (s multiSelection) Model() gio.ListModel {
	var _arg0 *C.GtkMultiSelection // out
	var _cret *C.GListModel        // in

	_arg0 = (*C.GtkMultiSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_multi_selection_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s multiSelection) SetModelMultiSelection(model gio.ListModel) {
	var _arg0 *C.GtkMultiSelection // out
	var _arg1 *C.GListModel        // out

	_arg0 = (*C.GtkMultiSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	C.gtk_multi_selection_set_model(_arg0, _arg1)
}

func (m multiSelection) Selection() *Bitset {
	return WrapSelectionModel(gextras.InternObject(m)).Selection()
}

func (m multiSelection) SelectionInRange(position uint, nItems uint) *Bitset {
	return WrapSelectionModel(gextras.InternObject(m)).SelectionInRange(position, nItems)
}

func (m multiSelection) IsSelected(position uint) bool {
	return WrapSelectionModel(gextras.InternObject(m)).IsSelected(position)
}

func (m multiSelection) SelectAll() bool {
	return WrapSelectionModel(gextras.InternObject(m)).SelectAll()
}

func (m multiSelection) SelectItem(position uint, unselectRest bool) bool {
	return WrapSelectionModel(gextras.InternObject(m)).SelectItem(position, unselectRest)
}

func (m multiSelection) SelectRange(position uint, nItems uint, unselectRest bool) bool {
	return WrapSelectionModel(gextras.InternObject(m)).SelectRange(position, nItems, unselectRest)
}

func (m multiSelection) SelectionChanged(position uint, nItems uint) {
	WrapSelectionModel(gextras.InternObject(m)).SelectionChanged(position, nItems)
}

func (m multiSelection) SetSelection(selected *Bitset, mask *Bitset) bool {
	return WrapSelectionModel(gextras.InternObject(m)).SetSelection(selected, mask)
}

func (m multiSelection) UnselectAll() bool {
	return WrapSelectionModel(gextras.InternObject(m)).UnselectAll()
}

func (m multiSelection) UnselectItem(position uint) bool {
	return WrapSelectionModel(gextras.InternObject(m)).UnselectItem(position)
}

func (m multiSelection) UnselectRange(position uint, nItems uint) bool {
	return WrapSelectionModel(gextras.InternObject(m)).UnselectRange(position, nItems)
}

// MultiSorter: `GtkMultiSorter` combines multiple sorters by trying them in
// turn.
//
// If the first sorter compares two items as equal, the second is tried next,
// and so on.
type MultiSorter interface {
	Sorter
	gio.ListModel
	Buildable

	// AppendMultiSorter: add @sorter to @self to use for sorting at the end.
	//
	// @self will consult all existing sorters before it will sort with the
	// given @sorter.
	AppendMultiSorter(sorter Sorter)
	// RemoveMultiSorter removes the sorter at the given @position from the list
	// of sorter used by @self.
	//
	// If @position is larger than the number of sorters, nothing happens.
	RemoveMultiSorter(position uint)
}

// multiSorter implements the MultiSorter class.
type multiSorter struct {
	Sorter
}

// WrapMultiSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMultiSorter(obj *externglib.Object) MultiSorter {
	return multiSorter{
		Sorter: WrapSorter(obj),
	}
}

func marshalMultiSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMultiSorter(obj), nil
}

// NewMultiSorter creates a new multi sorter.
//
// This sorter compares items by trying each of the sorters in turn, until one
// returns non-zero. In particular, if no sorter has been added to it, it will
// always compare items as equal.
func NewMultiSorter() MultiSorter {
	var _cret *C.GtkMultiSorter // in

	_cret = C.gtk_multi_sorter_new()

	var _multiSorter MultiSorter // out

	_multiSorter = WrapMultiSorter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _multiSorter
}

func (s multiSorter) AppendMultiSorter(sorter Sorter) {
	var _arg0 *C.GtkMultiSorter // out
	var _arg1 *C.GtkSorter      // out

	_arg0 = (*C.GtkMultiSorter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

	C.gtk_multi_sorter_append(_arg0, _arg1)
}

func (s multiSorter) RemoveMultiSorter(position uint) {
	var _arg0 *C.GtkMultiSorter // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkMultiSorter)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)

	C.gtk_multi_sorter_remove(_arg0, _arg1)
}

func (b multiSorter) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// NamedAction: a `GtkShortcutAction` that activates an action by name.
type NamedAction interface {

	// ActionName returns the name of the action that will be activated.
	ActionName() string
}

// namedAction implements the NamedAction class.
type namedAction struct {
	ShortcutAction
}

// WrapNamedAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapNamedAction(obj *externglib.Object) NamedAction {
	return namedAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalNamedAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNamedAction(obj), nil
}

// NewNamedAction creates an action that when activated, activates the named
// action on the widget.
//
// It also passes the given arguments to it.
//
// See [method@Gtk.Widget.insert_action_group] for how to add actions to
// widgets.
func NewNamedAction(name string) NamedAction {
	var _arg1 *C.char              // out
	var _cret *C.GtkShortcutAction // in

	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_named_action_new(_arg1)

	var _namedAction NamedAction // out

	_namedAction = WrapNamedAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _namedAction
}

func (s namedAction) ActionName() string {
	var _arg0 *C.GtkNamedAction // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkNamedAction)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_named_action_get_action_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// NativeDialog: native dialogs are platform dialogs that don't use `GtkDialog`.
//
// They are used in order to integrate better with a platform, by looking the
// same as other native applications and supporting platform specific features.
//
// The [class@Gtk.Dialog] functions cannot be used on such objects, but we need
// a similar API in order to drive them. The `GtkNativeDialog` object is an API
// that allows you to do this. It allows you to set various common properties on
// the dialog, as well as show and hide it and get a
// [signal@Gtk.NativeDialog::response] signal when the user finished with the
// dialog.
//
// Note that unlike `GtkDialog`, `GtkNativeDialog` objects are not toplevel
// widgets, and GTK does not keep them alive. It is your responsibility to keep
// a reference until you are done with the object.
type NativeDialog interface {

	// DestroyNativeDialog destroys a dialog.
	//
	// When a dialog is destroyed, it will break any references it holds to
	// other objects.
	//
	// If it is visible it will be hidden and any underlying window system
	// resources will be destroyed.
	//
	// Note that this does not release any reference to the object (as opposed
	// to destroying a `GtkWindow`) because there is no reference from the
	// windowing system to the `GtkNativeDialog`.
	DestroyNativeDialog()
	// Modal returns whether the dialog is modal.
	Modal() bool
	// Title gets the title of the `GtkNativeDialog`.
	Title() string
	// TransientFor fetches the transient parent for this window.
	TransientFor() Window
	// Visible determines whether the dialog is visible.
	Visible() bool
	// HideNativeDialog hides the dialog if it is visible, aborting any
	// interaction.
	//
	// Once this is called the [signal@Gtk.NativeDialog::response] signal will
	// *not* be emitted until after the next call to
	// [method@Gtk.NativeDialog.show].
	//
	// If the dialog is not visible this does nothing.
	HideNativeDialog()
	// SetModalNativeDialog sets a dialog modal or non-modal.
	//
	// Modal dialogs prevent interaction with other windows in the same
	// application. To keep modal dialogs on top of main application windows,
	// use [method@Gtk.NativeDialog.set_transient_for] to make the dialog
	// transient for the parent; most window managers will then disallow
	// lowering the dialog below the parent.
	SetModalNativeDialog(modal bool)
	// SetTitleNativeDialog sets the title of the `GtkNativeDialog.`
	SetTitleNativeDialog(title string)
	// SetTransientForNativeDialog: dialog windows should be set transient for
	// the main application window they were spawned from.
	//
	// This allows window managers to e.g. keep the dialog on top of the main
	// window, or center the dialog over the main window.
	//
	// Passing nil for @parent unsets the current transient window.
	SetTransientForNativeDialog(parent Window)
	// ShowNativeDialog shows the dialog on the display.
	//
	// When the user accepts the state of the dialog the dialog will be
	// automatically hidden and the [signal@Gtk.NativeDialog::response] signal
	// will be emitted.
	//
	// Multiple calls while the dialog is visible will be ignored.
	ShowNativeDialog()
}

// nativeDialog implements the NativeDialog class.
type nativeDialog struct {
	gextras.Objector
}

// WrapNativeDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeDialog(obj *externglib.Object) NativeDialog {
	return nativeDialog{
		Objector: obj,
	}
}

func marshalNativeDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeDialog(obj), nil
}

func (s nativeDialog) DestroyNativeDialog() {
	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	C.gtk_native_dialog_destroy(_arg0)
}

func (s nativeDialog) Modal() bool {
	var _arg0 *C.GtkNativeDialog // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_dialog_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s nativeDialog) Title() string {
	var _arg0 *C.GtkNativeDialog // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_dialog_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s nativeDialog) TransientFor() Window {
	var _arg0 *C.GtkNativeDialog // out
	var _cret *C.GtkWindow       // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_dialog_get_transient_for(_arg0)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

func (s nativeDialog) Visible() bool {
	var _arg0 *C.GtkNativeDialog // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_dialog_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s nativeDialog) HideNativeDialog() {
	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	C.gtk_native_dialog_hide(_arg0)
}

func (s nativeDialog) SetModalNativeDialog(modal bool) {
	var _arg0 *C.GtkNativeDialog // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_native_dialog_set_modal(_arg0, _arg1)
}

func (s nativeDialog) SetTitleNativeDialog(title string) {
	var _arg0 *C.GtkNativeDialog // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_native_dialog_set_title(_arg0, _arg1)
}

func (s nativeDialog) SetTransientForNativeDialog(parent Window) {
	var _arg0 *C.GtkNativeDialog // out
	var _arg1 *C.GtkWindow       // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	C.gtk_native_dialog_set_transient_for(_arg0, _arg1)
}

func (s nativeDialog) ShowNativeDialog() {
	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	C.gtk_native_dialog_show(_arg0)
}

// NeverTrigger: a `GtkShortcutTrigger` that never triggers.
type NeverTrigger interface {
}

// neverTrigger implements the NeverTrigger class.
type neverTrigger struct {
	ShortcutTrigger
}

// WrapNeverTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapNeverTrigger(obj *externglib.Object) NeverTrigger {
	return neverTrigger{
		ShortcutTrigger: WrapShortcutTrigger(obj),
	}
}

func marshalNeverTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNeverTrigger(obj), nil
}

// NoSelection: `GtkNoSelection` is a `GtkSelectionModel` that does not allow
// selecting anything.
//
// This model is meant to be used as a simple wrapper around a `GListModel` when
// a `GtkSelectionModel` is required.
type NoSelection interface {
	SelectionModel

	// Model gets the model that @self is wrapping.
	Model() gio.ListModel
	// SetModelNoSelection sets the model that @self should wrap.
	//
	// If @model is nil, this model will be empty.
	SetModelNoSelection(model gio.ListModel)
}

// noSelection implements the NoSelection class.
type noSelection struct {
	gextras.Objector
}

// WrapNoSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapNoSelection(obj *externglib.Object) NoSelection {
	return noSelection{
		Objector: obj,
	}
}

func marshalNoSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNoSelection(obj), nil
}

// NewNoSelection creates a new selection to handle @model.
func NewNoSelection(model gio.ListModel) NoSelection {
	var _arg1 *C.GListModel     // out
	var _cret *C.GtkNoSelection // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_no_selection_new(_arg1)

	var _noSelection NoSelection // out

	_noSelection = WrapNoSelection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _noSelection
}

func (s noSelection) Model() gio.ListModel {
	var _arg0 *C.GtkNoSelection // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkNoSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_no_selection_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s noSelection) SetModelNoSelection(model gio.ListModel) {
	var _arg0 *C.GtkNoSelection // out
	var _arg1 *C.GListModel     // out

	_arg0 = (*C.GtkNoSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	C.gtk_no_selection_set_model(_arg0, _arg1)
}

func (m noSelection) Selection() *Bitset {
	return WrapSelectionModel(gextras.InternObject(m)).Selection()
}

func (m noSelection) SelectionInRange(position uint, nItems uint) *Bitset {
	return WrapSelectionModel(gextras.InternObject(m)).SelectionInRange(position, nItems)
}

func (m noSelection) IsSelected(position uint) bool {
	return WrapSelectionModel(gextras.InternObject(m)).IsSelected(position)
}

func (m noSelection) SelectAll() bool {
	return WrapSelectionModel(gextras.InternObject(m)).SelectAll()
}

func (m noSelection) SelectItem(position uint, unselectRest bool) bool {
	return WrapSelectionModel(gextras.InternObject(m)).SelectItem(position, unselectRest)
}

func (m noSelection) SelectRange(position uint, nItems uint, unselectRest bool) bool {
	return WrapSelectionModel(gextras.InternObject(m)).SelectRange(position, nItems, unselectRest)
}

func (m noSelection) SelectionChanged(position uint, nItems uint) {
	WrapSelectionModel(gextras.InternObject(m)).SelectionChanged(position, nItems)
}

func (m noSelection) SetSelection(selected *Bitset, mask *Bitset) bool {
	return WrapSelectionModel(gextras.InternObject(m)).SetSelection(selected, mask)
}

func (m noSelection) UnselectAll() bool {
	return WrapSelectionModel(gextras.InternObject(m)).UnselectAll()
}

func (m noSelection) UnselectItem(position uint) bool {
	return WrapSelectionModel(gextras.InternObject(m)).UnselectItem(position)
}

func (m noSelection) UnselectRange(position uint, nItems uint) bool {
	return WrapSelectionModel(gextras.InternObject(m)).UnselectRange(position, nItems)
}

// Notebook: `GtkNotebook` is a container whose children are pages switched
// between using tabs.
//
// !An example GtkNotebook (notebook.png)
//
// There are many configuration options for `GtkNotebook`. Among other things,
// you can choose on which edge the tabs appear (see
// [method@Gtk.Notebook.set_tab_pos]), whether, if there are too many tabs to
// fit the notebook should be made bigger or scrolling arrows added (see
// [method@Gtk.Notebook.set_scrollable]), and whether there will be a popup menu
// allowing the users to switch pages. (see [method@Gtk.Notebook.popup_enable]).
//
//
// GtkNotebook as GtkBuildable
//
// The `GtkNotebook` implementation of the `GtkBuildable` interface supports
// placing children into tabs by specifying tab as the type attribute of a
// <child> element. Note that the content of the tab must be created before the
// tab can be filled. A tab child can be specified without specifying a <child>
// type attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// action-end as the type attribute of the <child> element.
//
// An example of a UI definition fragment with `GtkNotebook`:
//
// `xml <object class="GtkNotebook"> <child> <object class="GtkLabel"
// id="notebook-content"> <property name="label">Content</property> </object>
// </child> <child type="tab"> <object class="GtkLabel" id="notebook-tab">
// <property name="label">Tab</property> </object> </child> </object> `
//
//
// CSS nodes
//
// ` notebook  header.top   [<action widget>]   tabs    [arrow]
//    tab     <tab label>       tab[.reorderable-page]   
//  <tab label>    [arrow]   [<action widget>]   stack 
// <child>   <child> `
//
// `GtkNotebook` has a main CSS node with name `notebook`, a subnode with name
// `header` and below that a subnode with name `tabs` which contains one subnode
// per tab with name `tab`.
//
// If action widgets are present, their CSS nodes are placed next to the `tabs`
// node. If the notebook is scrollable, CSS nodes with name `arrow` are placed
// as first and last child of the `tabs` node.
//
// The main node gets the `.frame` style class when the notebook has a border
// (see [method@Gtk.Notebook.set_show_border]).
//
// The header node gets one of the style class `.top`, `.bottom`, `.left` or
// `.right`, depending on where the tabs are placed. For reorderable pages, the
// tab node gets the `.reorderable-page` class.
//
// A `tab` node gets the `.dnd` style class while it is moved with
// drag-and-drop.
//
// The nodes are always arranged from left-to-right, regardless of text
// direction.
//
//
// Accessibility
//
// `GtkNotebook` uses the following roles:
//
//    - GTK_ACCESSIBLE_ROLE_GROUP for the notebook widget
//    - GTK_ACCESSIBLE_ROLE_TAB_LIST for the list of tabs
//    - GTK_ACCESSIBLE_ROLE_TAB role for each tab
//    - GTK_ACCESSIBLE_ROLE_TAB_PANEL for each page
type Notebook interface {
	Widget

	// AppendPageNotebook appends a page to @notebook.
	AppendPageNotebook(child Widget, tabLabel Widget) int
	// AppendPageMenuNotebook appends a page to @notebook, specifying the widget
	// to use as the label in the popup menu.
	AppendPageMenuNotebook(child Widget, tabLabel Widget, menuLabel Widget) int
	// DetachTabNotebook removes the child from the notebook.
	//
	// This function is very similar to [method@Gtk.Notebook.remove_page], but
	// additionally informs the notebook that the removal is happening as part
	// of a tab DND operation, which should not be cancelled.
	DetachTabNotebook(child Widget)
	// ActionWidget gets one of the action widgets.
	//
	// See [method@Gtk.Notebook.set_action_widget].
	ActionWidget(packType PackType) Widget
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// GroupName gets the current group name for @notebook.
	GroupName() string
	// MenuLabel retrieves the menu label widget of the page containing @child.
	MenuLabel(child Widget) Widget
	// MenuLabelText retrieves the text of the menu label for the page
	// containing @child.
	MenuLabelText(child Widget) string
	// NPages gets the number of pages in a notebook.
	NPages() int
	// NthPage returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// Page returns the `GtkNotebookPage` for @child.
	Page(child Widget) NotebookPage
	// Pages returns a `GListModel` that contains the pages of the notebook.
	//
	// This can be used to keep an up-to-date view. The model also implements
	// [iface@Gtk.SelectionModel] and can be used to track and modify the
	// visible page.
	Pages() gio.ListModel
	// Scrollable returns whether the tab label area has arrows for scrolling.
	Scrollable() bool
	// ShowBorder returns whether a bevel will be drawn around the notebook
	// pages.
	ShowBorder() bool
	// ShowTabs returns whether the tabs of the notebook are shown.
	ShowTabs() bool
	// TabDetachable returns whether the tab contents can be detached from
	// @notebook.
	TabDetachable(child Widget) bool
	// TabLabel returns the tab label widget for the page @child.
	//
	// nil is returned if @child is not in @notebook or if no tab label has
	// specifically been set for @child.
	TabLabel(child Widget) Widget
	// TabLabelText retrieves the text of the tab label for the page containing
	// @child.
	TabLabelText(child Widget) string
	// TabPos gets the edge at which the tabs are drawn.
	TabPos() PositionType
	// TabReorderable gets whether the tab can be reordered via drag and drop or
	// not.
	TabReorderable(child Widget) bool
	// InsertPageNotebook: insert a page into @notebook at the given position.
	InsertPageNotebook(child Widget, tabLabel Widget, position int) int
	// InsertPageMenuNotebook: insert a page into @notebook at the given
	// position, specifying the widget to use as the label in the popup menu.
	InsertPageMenuNotebook(child Widget, tabLabel Widget, menuLabel Widget, position int) int
	// NextPageNotebook switches to the next page.
	//
	// Nothing happens if the current page is the last page.
	NextPageNotebook()
	// PageNumNotebook finds the index of the page which contains the given
	// child widget.
	PageNumNotebook(child Widget) int
	// PopupDisableNotebook disables the popup menu.
	PopupDisableNotebook()
	// PopupEnableNotebook enables the popup menu.
	//
	// If the user clicks with the right mouse button on the tab labels, a menu
	// with all the pages will be popped up.
	PopupEnableNotebook()
	// PrependPageNotebook prepends a page to @notebook.
	PrependPageNotebook(child Widget, tabLabel Widget) int
	// PrependPageMenuNotebook prepends a page to @notebook, specifying the
	// widget to use as the label in the popup menu.
	PrependPageMenuNotebook(child Widget, tabLabel Widget, menuLabel Widget) int
	// PrevPageNotebook switches to the previous page.
	//
	// Nothing happens if the current page is the first page.
	PrevPageNotebook()
	// RemovePageNotebook removes a page from the notebook given its index in
	// the notebook.
	RemovePageNotebook(pageNum int)
	// ReorderChildNotebook reorders the page containing @child, so that it
	// appears in position @position.
	//
	// If @position is greater than or equal to the number of children in the
	// list or negative, @child will be moved to the end of the list.
	ReorderChildNotebook(child Widget, position int)
	// SetActionWidgetNotebook sets @widget as one of the action widgets.
	//
	// Depending on the pack type the widget will be placed before or after the
	// tabs. You can use a `GtkBox` if you need to pack more than one widget on
	// the same side.
	SetActionWidgetNotebook(widget Widget, packType PackType)
	// SetCurrentPageNotebook switches to the page number @page_num.
	//
	// Note that due to historical reasons, GtkNotebook refuses to switch to a
	// page unless the child widget is visible. Therefore, it is recommended to
	// show child widgets before adding them to a notebook.
	SetCurrentPageNotebook(pageNum int)
	// SetGroupNameNotebook sets a group name for @notebook.
	//
	// Notebooks with the same name will be able to exchange tabs via drag and
	// drop. A notebook with a nil group name will not be able to exchange tabs
	// with any other notebook.
	SetGroupNameNotebook(groupName string)
	// SetMenuLabelNotebook changes the menu label for the page containing
	// @child.
	SetMenuLabelNotebook(child Widget, menuLabel Widget)
	// SetMenuLabelTextNotebook creates a new label and sets it as the menu
	// label of @child.
	SetMenuLabelTextNotebook(child Widget, menuText string)
	// SetScrollableNotebook sets whether the tab label area will have arrows
	// for scrolling if there are too many tabs to fit in the area.
	SetScrollableNotebook(scrollable bool)
	// SetShowBorderNotebook sets whether a bevel will be drawn around the
	// notebook pages.
	//
	// This only has a visual effect when the tabs are not shown.
	SetShowBorderNotebook(showBorder bool)
	// SetShowTabsNotebook sets whether to show the tabs for the notebook or
	// not.
	SetShowTabsNotebook(showTabs bool)
	// SetTabDetachableNotebook sets whether the tab can be detached from
	// @notebook to another notebook or widget.
	//
	// Note that two notebooks must share a common group identificator (see
	// [method@Gtk.Notebook.set_group_name]) to allow automatic tabs interchange
	// between them.
	//
	// If you want a widget to interact with a notebook through DnD (i.e.:
	// accept dragged tabs from it) it must be set as a drop destination and
	// accept the target GTK_NOTEBOOK_TAB. The notebook will fill the
	// selection with a GtkWidget** pointing to the child widget that
	// corresponds to the dropped tab.
	//
	// Note that you should use [method@Gtk.Notebook.detach_tab] instead of
	// [method@Gtk.Notebook.remove_page] if you want to remove the tab from the
	// source notebook as part of accepting a drop. Otherwise, the source
	// notebook will think that the dragged tab was removed from underneath the
	// ongoing drag operation, and will initiate a drag cancel animation.
	//
	// `c static void on_drag_data_received (GtkWidget *widget, GdkDrop *drop,
	// GtkSelectionData *data, guint time, gpointer user_data) { GtkDrag *drag;
	// GtkWidget *notebook; GtkWidget **child;
	//
	//    drag = gtk_drop_get_drag (drop);
	//    notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
	//    child = (void*) gtk_selection_data_get_data (data);
	//
	//    // process_widget (*child);
	//
	//    gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
	//
	// } `
	//
	// If you want a notebook to accept drags from other widgets, you will have
	// to set your own DnD code to do it.
	SetTabDetachableNotebook(child Widget, detachable bool)
	// SetTabLabelNotebook changes the tab label for @child.
	//
	// If nil is specified for @tab_label, then the page will have the label
	// page N.
	SetTabLabelNotebook(child Widget, tabLabel Widget)
	// SetTabLabelTextNotebook creates a new label and sets it as the tab label
	// for the page containing @child.
	SetTabLabelTextNotebook(child Widget, tabText string)
	// SetTabPosNotebook sets the edge at which the tabs are drawn.
	SetTabPosNotebook(pos PositionType)
	// SetTabReorderableNotebook sets whether the notebook tab can be reordered
	// via drag and drop or not.
	SetTabReorderableNotebook(child Widget, reorderable bool)
}

// notebook implements the Notebook class.
type notebook struct {
	Widget
}

// WrapNotebook wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebook(obj *externglib.Object) Notebook {
	return notebook{
		Widget: WrapWidget(obj),
	}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebook(obj), nil
}

// NewNotebook creates a new `GtkNotebook` widget with no pages.
func NewNotebook() Notebook {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_notebook_new()

	var _notebook Notebook // out

	_notebook = WrapNotebook(externglib.Take(unsafe.Pointer(_cret)))

	return _notebook
}

func (n notebook) AppendPageNotebook(child Widget, tabLabel Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	_cret = C.gtk_notebook_append_page(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (n notebook) AppendPageMenuNotebook(child Widget, tabLabel Widget, menuLabel Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	_cret = C.gtk_notebook_append_page_menu(_arg0, _arg1, _arg2, _arg3)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (n notebook) DetachTabNotebook(child Widget) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_notebook_detach_tab(_arg0, _arg1)
}

func (n notebook) ActionWidget(packType PackType) Widget {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.GtkPackType  // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.GtkPackType)(packType)

	_cret = C.gtk_notebook_get_action_widget(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (n notebook) CurrentPage() int {
	var _arg0 *C.GtkNotebook // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_current_page(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (n notebook) GroupName() string {
	var _arg0 *C.GtkNotebook // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_group_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (n notebook) MenuLabel(child Widget) Widget {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_menu_label(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (n notebook) MenuLabelText(child Widget) string {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_menu_label_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (n notebook) NPages() int {
	var _arg0 *C.GtkNotebook // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_n_pages(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (n notebook) NthPage(pageNum int) Widget {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.int          // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.int)(pageNum)

	_cret = C.gtk_notebook_get_nth_page(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (n notebook) Page(child Widget) NotebookPage {
	var _arg0 *C.GtkNotebook     // out
	var _arg1 *C.GtkWidget       // out
	var _cret *C.GtkNotebookPage // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_page(_arg0, _arg1)

	var _notebookPage NotebookPage // out

	_notebookPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(NotebookPage)

	return _notebookPage
}

func (n notebook) Pages() gio.ListModel {
	var _arg0 *C.GtkNotebook // out
	var _cret *C.GListModel  // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_pages(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (n notebook) Scrollable() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_scrollable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (n notebook) ShowBorder() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_show_border(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (n notebook) ShowTabs() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_show_tabs(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (n notebook) TabDetachable(child Widget) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_tab_detachable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (n notebook) TabLabel(child Widget) Widget {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_tab_label(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (n notebook) TabLabelText(child Widget) string {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_tab_label_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (n notebook) TabPos() PositionType {
	var _arg0 *C.GtkNotebook    // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_tab_pos(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

func (n notebook) TabReorderable(child Widget) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_tab_reorderable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (n notebook) InsertPageNotebook(child Widget, tabLabel Widget, position int) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 C.int          // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (C.int)(position)

	_cret = C.gtk_notebook_insert_page(_arg0, _arg1, _arg2, _arg3)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (n notebook) InsertPageMenuNotebook(child Widget, tabLabel Widget, menuLabel Widget, position int) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _arg4 C.int          // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))
	_arg4 = (C.int)(position)

	_cret = C.gtk_notebook_insert_page_menu(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (n notebook) NextPageNotebook() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_next_page(_arg0)
}

func (n notebook) PageNumNotebook(child Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_page_num(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (n notebook) PopupDisableNotebook() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_popup_disable(_arg0)
}

func (n notebook) PopupEnableNotebook() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_popup_enable(_arg0)
}

func (n notebook) PrependPageNotebook(child Widget, tabLabel Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	_cret = C.gtk_notebook_prepend_page(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (n notebook) PrependPageMenuNotebook(child Widget, tabLabel Widget, menuLabel Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	_cret = C.gtk_notebook_prepend_page_menu(_arg0, _arg1, _arg2, _arg3)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (n notebook) PrevPageNotebook() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_prev_page(_arg0)
}

func (n notebook) RemovePageNotebook(pageNum int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.int)(pageNum)

	C.gtk_notebook_remove_page(_arg0, _arg1)
}

func (n notebook) ReorderChildNotebook(child Widget, position int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.int)(position)

	C.gtk_notebook_reorder_child(_arg0, _arg1, _arg2)
}

func (n notebook) SetActionWidgetNotebook(widget Widget, packType PackType) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.GtkPackType  // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkPackType)(packType)

	C.gtk_notebook_set_action_widget(_arg0, _arg1, _arg2)
}

func (n notebook) SetCurrentPageNotebook(pageNum int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.int)(pageNum)

	C.gtk_notebook_set_current_page(_arg0, _arg1)
}

func (n notebook) SetGroupNameNotebook(groupName string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_notebook_set_group_name(_arg0, _arg1)
}

func (n notebook) SetMenuLabelNotebook(child Widget, menuLabel Widget) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	C.gtk_notebook_set_menu_label(_arg0, _arg1, _arg2)
}

func (n notebook) SetMenuLabelTextNotebook(child Widget, menuText string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.char        // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(menuText))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_menu_label_text(_arg0, _arg1, _arg2)
}

func (n notebook) SetScrollableNotebook(scrollable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if scrollable {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_scrollable(_arg0, _arg1)
}

func (n notebook) SetShowBorderNotebook(showBorder bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if showBorder {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_show_border(_arg0, _arg1)
}

func (n notebook) SetShowTabsNotebook(showTabs bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if showTabs {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_show_tabs(_arg0, _arg1)
}

func (n notebook) SetTabDetachableNotebook(child Widget, detachable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if detachable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_detachable(_arg0, _arg1, _arg2)
}

func (n notebook) SetTabLabelNotebook(child Widget, tabLabel Widget) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	C.gtk_notebook_set_tab_label(_arg0, _arg1, _arg2)
}

func (n notebook) SetTabLabelTextNotebook(child Widget, tabText string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.char        // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(tabText))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_tab_label_text(_arg0, _arg1, _arg2)
}

func (n notebook) SetTabPosNotebook(pos PositionType) {
	var _arg0 *C.GtkNotebook    // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.GtkPositionType)(pos)

	C.gtk_notebook_set_tab_pos(_arg0, _arg1)
}

func (n notebook) SetTabReorderableNotebook(child Widget, reorderable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if reorderable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_reorderable(_arg0, _arg1, _arg2)
}

func (s notebook) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s notebook) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s notebook) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s notebook) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s notebook) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s notebook) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s notebook) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b notebook) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// NotebookPage: `GtkNotebookPage` is an auxiliary object used by `GtkNotebook`.
type NotebookPage interface {

	// Child returns the notebook child to which @page belongs.
	Child() Widget
}

// notebookPage implements the NotebookPage class.
type notebookPage struct {
	gextras.Objector
}

// WrapNotebookPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebookPage(obj *externglib.Object) NotebookPage {
	return notebookPage{
		Objector: obj,
	}
}

func marshalNotebookPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebookPage(obj), nil
}

func (p notebookPage) Child() Widget {
	var _arg0 *C.GtkNotebookPage // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkNotebookPage)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_notebook_page_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// NothingAction: a `GtkShortcutAction` that does nothing.
type NothingAction interface {
}

// nothingAction implements the NothingAction class.
type nothingAction struct {
	ShortcutAction
}

// WrapNothingAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapNothingAction(obj *externglib.Object) NothingAction {
	return nothingAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalNothingAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNothingAction(obj), nil
}

// NumericSorter: `GtkNumericSorter` is a `GtkSorter` that compares numbers.
//
// To obtain the numbers to compare, this sorter evaluates a
// [class@Gtk.Expression].
type NumericSorter interface {

	// Expression gets the expression that is evaluated to obtain numbers from
	// items.
	Expression() Expression
	// SortOrder gets whether this sorter will sort smaller numbers first.
	SortOrder() SortType
	// SetExpressionNumericSorter sets the expression that is evaluated to
	// obtain numbers from items.
	//
	// Unless an expression is set on @self, the sorter will always compare
	// items as invalid.
	//
	// The expression must have a return type that can be compared numerically,
	// such as G_TYPE_INT or G_TYPE_DOUBLE.
	SetExpressionNumericSorter(expression Expression)
	// SetSortOrderNumericSorter sets whether to sort smaller numbers before
	// larger ones.
	SetSortOrderNumericSorter(sortOrder SortType)
}

// numericSorter implements the NumericSorter class.
type numericSorter struct {
	Sorter
}

// WrapNumericSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapNumericSorter(obj *externglib.Object) NumericSorter {
	return numericSorter{
		Sorter: WrapSorter(obj),
	}
}

func marshalNumericSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNumericSorter(obj), nil
}

// NewNumericSorter creates a new numeric sorter using the given @expression.
//
// Smaller numbers will be sorted first. You can call
// [method@Gtk.NumericSorter.set_sort_order] to change this.
func NewNumericSorter(expression Expression) NumericSorter {
	var _arg1 *C.GtkExpression    // out
	var _cret *C.GtkNumericSorter // in

	_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	_cret = C.gtk_numeric_sorter_new(_arg1)

	var _numericSorter NumericSorter // out

	_numericSorter = WrapNumericSorter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _numericSorter
}

func (s numericSorter) Expression() Expression {
	var _arg0 *C.GtkNumericSorter // out
	var _cret *C.GtkExpression    // in

	_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_numeric_sorter_get_expression(_arg0)

	var _expression Expression // out

	_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

	return _expression
}

func (s numericSorter) SortOrder() SortType {
	var _arg0 *C.GtkNumericSorter // out
	var _cret C.GtkSortType       // in

	_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_numeric_sorter_get_sort_order(_arg0)

	var _sortType SortType // out

	_sortType = SortType(_cret)

	return _sortType
}

func (s numericSorter) SetExpressionNumericSorter(expression Expression) {
	var _arg0 *C.GtkNumericSorter // out
	var _arg1 *C.GtkExpression    // out

	_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	C.gtk_numeric_sorter_set_expression(_arg0, _arg1)
}

func (s numericSorter) SetSortOrderNumericSorter(sortOrder SortType) {
	var _arg0 *C.GtkNumericSorter // out
	var _arg1 C.GtkSortType       // out

	_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSortType)(sortOrder)

	C.gtk_numeric_sorter_set_sort_order(_arg0, _arg1)
}

// ObjectExpression: a `GObject` value in a `GtkExpression`.
type ObjectExpression interface {

	// Object gets the object that the expression evaluates to.
	Object() gextras.Objector
}

// objectExpression implements the ObjectExpression class.
type objectExpression struct {
	Expression
}

// WrapObjectExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapObjectExpression(obj *externglib.Object) ObjectExpression {
	return objectExpression{
		Expression: WrapExpression(obj),
	}
}

func marshalObjectExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapObjectExpression(obj), nil
}

// NewObjectExpression creates an expression evaluating to the given `object`
// with a weak reference.
//
// Once the `object` is disposed, it will fail to evaluate.
//
// This expression is meant to break reference cycles.
//
// If you want to keep a reference to `object`, use
// [ctor@Gtk.ConstantExpression.new].
func NewObjectExpression(object gextras.Objector) ObjectExpression {
	var _arg1 *C.GObject       // out
	var _cret *C.GtkExpression // in

	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))

	_cret = C.gtk_object_expression_new(_arg1)

	var _objectExpression ObjectExpression // out

	_objectExpression = WrapObjectExpression(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _objectExpression
}

func (e objectExpression) Object() gextras.Objector {
	var _arg0 *C.GtkExpression // out
	var _cret *C.GObject       // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_object_expression_get_object(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

// Overlay: `GtkOverlay` is a container which contains a single main child, on
// top of which it can place overlay widgets.
//
// !An example GtkOverlay (overlay.png)
//
// The position of each overlay widget is determined by its
// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties.
// E.g. a widget with both alignments set to GTK_ALIGN_START will be placed at
// the top left corner of the `GtkOverlay` container, whereas an overlay with
// halign set to GTK_ALIGN_CENTER and valign set to GTK_ALIGN_END will be placed
// a the bottom edge of the `GtkOverlay`, horizontally centered. The position
// can be adjusted by setting the margin properties of the child to non-zero
// values.
//
// More complicated placement of overlays is possible by connecting to the
// [signal@Gtk.Overlay::get-child-position] signal.
//
// An overlays minimum and natural sizes are those of its main child. The sizes
// of overlay children are not considered when measuring these preferred sizes.
//
//
// GtkOverlay as GtkBuildable
//
// The `GtkOverlay` implementation of the `GtkBuildable` interface supports
// placing a child as an overlay by specifying overlay as the type attribute
// of a `<child>` element.
//
//
// CSS nodes
//
// `GtkOverlay` has a single CSS node with the name overlay. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// .left, .right, .top, and/or .bottom according to their position.
type Overlay interface {
	Widget

	// AddOverlayOverlay adds @widget to @overlay.
	//
	// The widget will be stacked on top of the main widget added with
	// [method@Gtk.Overlay.set_child].
	//
	// The position at which @widget is placed is determined from its
	// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties.
	AddOverlayOverlay(widget Widget)
	// Child gets the child widget of @overlay.
	Child() Widget
	// ClipOverlay gets whether @widget should be clipped within the parent.
	ClipOverlay(widget Widget) bool
	// MeasureOverlay gets whether @widget's size is included in the measurement
	// of @overlay.
	MeasureOverlay(widget Widget) bool
	// RemoveOverlayOverlay removes an overlay that was added with
	// gtk_overlay_add_overlay().
	RemoveOverlayOverlay(widget Widget)
	// SetChildOverlay sets the child widget of @overlay.
	SetChildOverlay(child Widget)
	// SetClipOverlayOverlay sets whether @widget should be clipped within the
	// parent.
	SetClipOverlayOverlay(widget Widget, clipOverlay bool)
	// SetMeasureOverlayOverlay sets whether @widget is included in the measured
	// size of @overlay.
	//
	// The overlay will request the size of the largest child that has this
	// property set to true. Children who are not included may be drawn outside
	// of @overlay's allocation if they are too large.
	SetMeasureOverlayOverlay(widget Widget, measure bool)
}

// overlay implements the Overlay class.
type overlay struct {
	Widget
}

// WrapOverlay wraps a GObject to the right type. It is
// primarily used internally.
func WrapOverlay(obj *externglib.Object) Overlay {
	return overlay{
		Widget: WrapWidget(obj),
	}
}

func marshalOverlay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOverlay(obj), nil
}

// NewOverlay creates a new `GtkOverlay`.
func NewOverlay() Overlay {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_overlay_new()

	var _overlay Overlay // out

	_overlay = WrapOverlay(externglib.Take(unsafe.Pointer(_cret)))

	return _overlay
}

func (o overlay) AddOverlayOverlay(widget Widget) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_overlay_add_overlay(_arg0, _arg1)
}

func (o overlay) Child() Widget {
	var _arg0 *C.GtkOverlay // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_overlay_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (o overlay) ClipOverlay(widget Widget) bool {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_overlay_get_clip_overlay(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o overlay) MeasureOverlay(widget Widget) bool {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_overlay_get_measure_overlay(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o overlay) RemoveOverlayOverlay(widget Widget) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_overlay_remove_overlay(_arg0, _arg1)
}

func (o overlay) SetChildOverlay(child Widget) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_overlay_set_child(_arg0, _arg1)
}

func (o overlay) SetClipOverlayOverlay(widget Widget, clipOverlay bool) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	if clipOverlay {
		_arg2 = C.TRUE
	}

	C.gtk_overlay_set_clip_overlay(_arg0, _arg1, _arg2)
}

func (o overlay) SetMeasureOverlayOverlay(widget Widget, measure bool) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	if measure {
		_arg2 = C.TRUE
	}

	C.gtk_overlay_set_measure_overlay(_arg0, _arg1, _arg2)
}

func (s overlay) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s overlay) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s overlay) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s overlay) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s overlay) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s overlay) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s overlay) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b overlay) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// OverlayLayout: `GtkOverlayLayout` is the layout manager used by `GtkOverlay`.
//
// It places widgets as overlays on top of the main child.
//
// This is not a reusable layout manager, since it expects its widget to be a
// `GtkOverlay`. It only listed here so that its layout properties get
// documented.
type OverlayLayout interface {
}

// overlayLayout implements the OverlayLayout class.
type overlayLayout struct {
	LayoutManager
}

// WrapOverlayLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapOverlayLayout(obj *externglib.Object) OverlayLayout {
	return overlayLayout{
		LayoutManager: WrapLayoutManager(obj),
	}
}

func marshalOverlayLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOverlayLayout(obj), nil
}

// NewOverlayLayout creates a new `GtkOverlayLayout` instance.
func NewOverlayLayout() OverlayLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_overlay_layout_new()

	var _overlayLayout OverlayLayout // out

	_overlayLayout = WrapOverlayLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _overlayLayout
}

// OverlayLayoutChild: `GtkLayoutChild` subclass for children in a
// `GtkOverlayLayout`.
type OverlayLayoutChild interface {

	// ClipOverlay retrieves whether the child is clipped.
	ClipOverlay() bool
	// Measure retrieves whether the child is measured.
	Measure() bool
	// SetClipOverlayOverlayLayoutChild sets whether to clip this child.
	SetClipOverlayOverlayLayoutChild(clipOverlay bool)
	// SetMeasureOverlayLayoutChild sets whether to measure this child.
	SetMeasureOverlayLayoutChild(measure bool)
}

// overlayLayoutChild implements the OverlayLayoutChild class.
type overlayLayoutChild struct {
	LayoutChild
}

// WrapOverlayLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapOverlayLayoutChild(obj *externglib.Object) OverlayLayoutChild {
	return overlayLayoutChild{
		LayoutChild: WrapLayoutChild(obj),
	}
}

func marshalOverlayLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOverlayLayoutChild(obj), nil
}

func (c overlayLayoutChild) ClipOverlay() bool {
	var _arg0 *C.GtkOverlayLayoutChild // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_overlay_layout_child_get_clip_overlay(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c overlayLayoutChild) Measure() bool {
	var _arg0 *C.GtkOverlayLayoutChild // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_overlay_layout_child_get_measure(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c overlayLayoutChild) SetClipOverlayOverlayLayoutChild(clipOverlay bool) {
	var _arg0 *C.GtkOverlayLayoutChild // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(c.Native()))
	if clipOverlay {
		_arg1 = C.TRUE
	}

	C.gtk_overlay_layout_child_set_clip_overlay(_arg0, _arg1)
}

func (c overlayLayoutChild) SetMeasureOverlayLayoutChild(measure bool) {
	var _arg0 *C.GtkOverlayLayoutChild // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(c.Native()))
	if measure {
		_arg1 = C.TRUE
	}

	C.gtk_overlay_layout_child_set_measure(_arg0, _arg1)
}

// PadController: `GtkPadController` is an event controller for the pads found
// in drawing tablets.
//
// Pads are the collection of buttons and tactile sensors often found around the
// stylus-sensitive area.
//
// These buttons and sensors have no implicit meaning, and by default they
// perform no action. `GtkPadController` is provided to map those to `GAction`
// objects, thus letting the application give them a more semantic meaning.
//
// Buttons and sensors are not constrained to triggering a single action, some
// GDK_SOURCE_TABLET_PAD devices feature multiple "modes". All these input
// elements have one current mode, which may determine the final action being
// triggered.
//
// Pad devices often divide buttons and sensors into groups. All elements in a
// group share the same current mode, but different groups may have different
// modes. See [method@Gdk.DevicePad.get_n_groups] and
// [method@Gdk.DevicePad.get_group_n_modes].
//
// Each of the actions that a given button/strip/ring performs for a given mode
// is defined by a [struct@Gtk.PadActionEntry]. It contains an action name that
// will be looked up in the given `GActionGroup` and activated whenever the
// specified input element and mode are triggered.
//
// A simple example of `GtkPadController` usage: Assigning button 1 in all modes
// and pad devices to an "invert-selection" action:
//
// `c GtkPadActionEntry *pad_actions[] = { { GTK_PAD_ACTION_BUTTON, 1, -1,
// "Invert selection", "pad-actions.invert-selection" },  };
//
//  action_group = g_simple_action_group_new (); action = g_simple_action_new
// ("pad-actions.invert-selection", NULL); g_signal_connect (action, "activate",
// on_invert_selection_activated, NULL); g_action_map_add_action (G_ACTION_MAP
// (action_group), action);  pad_controller = gtk_pad_controller_new
// (action_group, NULL); `
//
// The actions belonging to rings/strips will be activated with a parameter of
// type G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it is
// required that those are made stateful and accepting this `GVariantType`.
type PadController interface {

	// SetActionPadController adds an individual action to @controller.
	//
	// This action will only be activated if the given button/ring/strip number
	// in @index is interacted while the current mode is @mode. -1 may be used
	// for simple cases, so the action is triggered on all modes.
	//
	// The given @label should be considered user-visible, so
	// internationalization rules apply. Some windowing systems may be able to
	// use those for user feedback.
	SetActionPadController(typ PadActionType, index int, mode int, label string, actionName string)
	// SetActionEntriesPadController: a convenience function to add a group of
	// action entries on @controller.
	//
	// See [struct@Gtk.PadActionEntry] and
	// [method@Gtk.PadController.set_action].
	SetActionEntriesPadController(entries []PadActionEntry)
}

// padController implements the PadController class.
type padController struct {
	EventController
}

// WrapPadController wraps a GObject to the right type. It is
// primarily used internally.
func WrapPadController(obj *externglib.Object) PadController {
	return padController{
		EventController: WrapEventController(obj),
	}
}

func marshalPadController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPadController(obj), nil
}

// NewPadController creates a new `GtkPadController` that will associate events
// from @pad to actions.
//
// A nil pad may be provided so the controller manages all pad devices
// generically, it is discouraged to mix `GtkPadController` objects with nil and
// non-nil @pad argument on the same toplevel window, as execution order is not
// guaranteed.
//
// The `GtkPadController` is created with no mapped actions. In order to map pad
// events to actions, use [method@Gtk.PadController.set_action_entries] or
// [method@Gtk.PadController.set_action].
//
// Be aware that pad events will only be delivered to `GtkWindow`s, so adding a
// pad controller to any other type of widget will not have an effect.
func NewPadController(group gio.ActionGroup, pad gdk.Device) PadController {
	var _arg1 *C.GActionGroup     // out
	var _arg2 *C.GdkDevice        // out
	var _cret *C.GtkPadController // in

	_arg1 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))
	_arg2 = (*C.GdkDevice)(unsafe.Pointer(pad.Native()))

	_cret = C.gtk_pad_controller_new(_arg1, _arg2)

	var _padController PadController // out

	_padController = WrapPadController(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _padController
}

func (c padController) SetActionPadController(typ PadActionType, index int, mode int, label string, actionName string) {
	var _arg0 *C.GtkPadController // out
	var _arg1 C.GtkPadActionType  // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 *C.char             // out
	var _arg5 *C.char             // out

	_arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkPadActionType)(typ)
	_arg2 = (C.int)(index)
	_arg3 = (C.int)(mode)
	_arg4 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.char)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg5))

	C.gtk_pad_controller_set_action(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (c padController) SetActionEntriesPadController(entries []PadActionEntry) {
	var _arg0 *C.GtkPadController // out
	var _arg1 *C.GtkPadActionEntry
	var _arg2 C.int

	_arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))
	_arg2 = C.int(len(entries))
	_arg1 = (*C.GtkPadActionEntry)(unsafe.Pointer(&entries[0]))

	C.gtk_pad_controller_set_action_entries(_arg0, _arg1, _arg2)
}

// PageSetup: a `GtkPageSetup` object stores the page size, orientation and
// margins.
//
// The idea is that you can get one of these from the page setup dialog and then
// pass it to the `GtkPrintOperation` when printing. The benefit of splitting
// this out of the `GtkPrintSettings` is that these affect the actual layout of
// the page, and thus need to be set long before user prints.
//
//
// Margins
//
// The margins specified in this object are the print margins, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
//
// To obtain a `GtkPageSetup` use [ctor@Gtk.PageSetup.new] to get the defaults,
// or use [func@Gtk.print_run_page_setup_dialog] to show the page setup dialog
// and receive the resulting page setup.
//
//
// A page setup dialog
//
// `c static GtkPrintSettings *settings = NULL; static GtkPageSetup *page_setup
// = NULL;
//
// static void do_page_setup (void) { GtkPageSetup *new_page_setup;
//
//    if (settings == NULL)
//      settings = gtk_print_settings_new ();
//
//    new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                      page_setup, settings);
//
//    if (page_setup)
//      g_object_unref (page_setup);
//
//    page_setup = new_page_setup;
//
// } `
type PageSetup interface {

	// CopyPageSetup copies a `GtkPageSetup`.
	CopyPageSetup() PageSetup
	// BottomMargin gets the bottom margin in units of @unit.
	BottomMargin(unit Unit) float64
	// LeftMargin gets the left margin in units of @unit.
	LeftMargin(unit Unit) float64
	// Orientation gets the page orientation of the `GtkPageSetup`.
	Orientation() PageOrientation
	// PageHeight returns the page height in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See [method@Gtk.PageSetup.get_paper_height].
	PageHeight(unit Unit) float64
	// PageWidth returns the page width in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See [method@Gtk.PageSetup.get_paper_width].
	PageWidth(unit Unit) float64
	// PaperHeight returns the paper height in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See [method@Gtk.PageSetup.get_page_height].
	PaperHeight(unit Unit) float64
	// PaperSize gets the paper size of the `GtkPageSetup`.
	PaperSize() *PaperSize
	// PaperWidth returns the paper width in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See [method@Gtk.PageSetup.get_page_width].
	PaperWidth(unit Unit) float64
	// RightMargin gets the right margin in units of @unit.
	RightMargin(unit Unit) float64
	// TopMargin gets the top margin in units of @unit.
	TopMargin(unit Unit) float64
	// LoadFilePageSetup reads the page setup from the file @file_name.
	//
	// See [method@Gtk.PageSetup.to_file].
	LoadFilePageSetup(fileName string) error
	// LoadKeyFilePageSetup reads the page setup from the group @group_name in
	// the key file @key_file.
	LoadKeyFilePageSetup(keyFile *glib.KeyFile, groupName string) error
	// SetBottomMarginPageSetup sets the bottom margin of the `GtkPageSetup`.
	SetBottomMarginPageSetup(margin float64, unit Unit)
	// SetLeftMarginPageSetup sets the left margin of the `GtkPageSetup`.
	SetLeftMarginPageSetup(margin float64, unit Unit)
	// SetOrientationPageSetup sets the page orientation of the `GtkPageSetup`.
	SetOrientationPageSetup(orientation PageOrientation)
	// SetPaperSizePageSetup sets the paper size of the `GtkPageSetup` without
	// changing the margins.
	//
	// See [method@Gtk.PageSetup.set_paper_size_and_default_margins].
	SetPaperSizePageSetup(size *PaperSize)
	// SetPaperSizeAndDefaultMarginsPageSetup sets the paper size of the
	// `GtkPageSetup` and modifies the margins according to the new paper size.
	SetPaperSizeAndDefaultMarginsPageSetup(size *PaperSize)
	// SetRightMarginPageSetup sets the right margin of the `GtkPageSetup`.
	SetRightMarginPageSetup(margin float64, unit Unit)
	// SetTopMarginPageSetup sets the top margin of the `GtkPageSetup`.
	SetTopMarginPageSetup(margin float64, unit Unit)
	// ToFilePageSetup: this function saves the information from @setup to
	// @file_name.
	ToFilePageSetup(fileName string) error
	// ToGVariantPageSetup: serialize page setup to an a{sv} variant.
	ToGVariantPageSetup() *glib.Variant
	// ToKeyFilePageSetup: this function adds the page setup from @setup to
	// @key_file.
	ToKeyFilePageSetup(keyFile *glib.KeyFile, groupName string)
}

// pageSetup implements the PageSetup class.
type pageSetup struct {
	gextras.Objector
}

// WrapPageSetup wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetup(obj *externglib.Object) PageSetup {
	return pageSetup{
		Objector: obj,
	}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetup(obj), nil
}

// NewPageSetup creates a new `GtkPageSetup`.
func NewPageSetup() PageSetup {
	var _cret *C.GtkPageSetup // in

	_cret = C.gtk_page_setup_new()

	var _pageSetup PageSetup // out

	_pageSetup = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pageSetup
}

// NewPageSetupFromFile reads the page setup from the file @file_name.
//
// Returns a new `GtkPageSetup` object with the restored page setup, or nil if
// an error occurred. See [method@Gtk.PageSetup.to_file].
func NewPageSetupFromFile(fileName string) (PageSetup, error) {
	var _arg1 *C.char         // out
	var _cret *C.GtkPageSetup // in
	var _cerr *C.GError       // in

	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_page_setup_new_from_file(_arg1, &_cerr)

	var _pageSetup PageSetup // out
	var _goerr error         // out

	_pageSetup = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pageSetup, _goerr
}

// NewPageSetupFromGVariant: desrialize a page setup from an a{sv} variant.
//
// The variant must be in the format produced by
// [method@Gtk.PageSetup.to_gvariant].
func NewPageSetupFromGVariant(variant *glib.Variant) PageSetup {
	var _arg1 *C.GVariant     // out
	var _cret *C.GtkPageSetup // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	_cret = C.gtk_page_setup_new_from_gvariant(_arg1)

	var _pageSetup PageSetup // out

	_pageSetup = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pageSetup
}

// NewPageSetupFromKeyFile reads the page setup from the group @group_name in
// the key file @key_file.
//
// Returns a new `GtkPageSetup` object with the restored page setup, or nil if
// an error occurred.
func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) (PageSetup, error) {
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out
	var _cret *C.GtkPageSetup // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_page_setup_new_from_key_file(_arg1, _arg2, &_cerr)

	var _pageSetup PageSetup // out
	var _goerr error         // out

	_pageSetup = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pageSetup, _goerr
}

func (o pageSetup) CopyPageSetup() PageSetup {
	var _arg0 *C.GtkPageSetup // out
	var _cret *C.GtkPageSetup // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_page_setup_copy(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

func (s pageSetup) BottomMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_bottom_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s pageSetup) LeftMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_left_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s pageSetup) Orientation() PageOrientation {
	var _arg0 *C.GtkPageSetup      // out
	var _cret C.GtkPageOrientation // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_page_setup_get_orientation(_arg0)

	var _pageOrientation PageOrientation // out

	_pageOrientation = PageOrientation(_cret)

	return _pageOrientation
}

func (s pageSetup) PageHeight(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_page_height(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s pageSetup) PageWidth(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_page_width(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s pageSetup) PaperHeight(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_paper_height(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s pageSetup) PaperSize() *PaperSize {
	var _arg0 *C.GtkPageSetup // out
	var _cret *C.GtkPaperSize // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_page_setup_get_paper_size(_arg0)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))

	return _paperSize
}

func (s pageSetup) PaperWidth(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_paper_width(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s pageSetup) RightMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_right_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s pageSetup) TopMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_top_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s pageSetup) LoadFilePageSetup(fileName string) error {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_page_setup_load_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s pageSetup) LoadKeyFilePageSetup(keyFile *glib.KeyFile, groupName string) error {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_page_setup_load_key_file(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s pageSetup) SetBottomMarginPageSetup(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.double        // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_bottom_margin(_arg0, _arg1, _arg2)
}

func (s pageSetup) SetLeftMarginPageSetup(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.double        // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_left_margin(_arg0, _arg1, _arg2)
}

func (s pageSetup) SetOrientationPageSetup(orientation PageOrientation) {
	var _arg0 *C.GtkPageSetup      // out
	var _arg1 C.GtkPageOrientation // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_page_setup_set_orientation(_arg0, _arg1)
}

func (s pageSetup) SetPaperSizePageSetup(size *PaperSize) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GtkPaperSize // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size(_arg0, _arg1)
}

func (s pageSetup) SetPaperSizeAndDefaultMarginsPageSetup(size *PaperSize) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GtkPaperSize // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size_and_default_margins(_arg0, _arg1)
}

func (s pageSetup) SetRightMarginPageSetup(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.double        // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_right_margin(_arg0, _arg1, _arg2)
}

func (s pageSetup) SetTopMarginPageSetup(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.double        // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_top_margin(_arg0, _arg1, _arg2)
}

func (s pageSetup) ToFilePageSetup(fileName string) error {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_page_setup_to_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s pageSetup) ToGVariantPageSetup() *glib.Variant {
	var _arg0 *C.GtkPageSetup // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_page_setup_to_gvariant(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

func (s pageSetup) ToKeyFilePageSetup(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_page_setup_to_key_file(_arg0, _arg1, _arg2)
}

// PageSetupUnixDialog: `GtkPageSetupUnixDialog` implements a page setup dialog
// for platforms which dont provide a native page setup dialog, like Unix.
//
// !An example GtkPageSetupUnixDialog (pagesetupdialog.png)
//
// It can be used very much like any other GTK dialog, at the cost of the
// portability offered by the high-level printing API in
// [class@Gtk.PrintOperation].
type PageSetupUnixDialog interface {
	Dialog

	// PageSetup gets the currently selected page setup from the dialog.
	PageSetup() PageSetup
	// PrintSettings gets the current print settings from the dialog.
	PrintSettings() PrintSettings
	// SetPageSetupPageSetupUnixDialog sets the `GtkPageSetup` from which the
	// page setup dialog takes its values.
	SetPageSetupPageSetupUnixDialog(pageSetup PageSetup)
	// SetPrintSettingsPageSetupUnixDialog sets the `GtkPrintSettings` from
	// which the page setup dialog takes its values.
	SetPrintSettingsPageSetupUnixDialog(printSettings PrintSettings)
}

// pageSetupUnixDialog implements the PageSetupUnixDialog class.
type pageSetupUnixDialog struct {
	Dialog
}

// WrapPageSetupUnixDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetupUnixDialog(obj *externglib.Object) PageSetupUnixDialog {
	return pageSetupUnixDialog{
		Dialog: WrapDialog(obj),
	}
}

func marshalPageSetupUnixDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetupUnixDialog(obj), nil
}

// NewPageSetupUnixDialog creates a new page setup dialog.
func NewPageSetupUnixDialog(title string, parent Window) PageSetupUnixDialog {
	var _arg1 *C.char      // out
	var _arg2 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_page_setup_unix_dialog_new(_arg1, _arg2)

	var _pageSetupUnixDialog PageSetupUnixDialog // out

	_pageSetupUnixDialog = WrapPageSetupUnixDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _pageSetupUnixDialog
}

func (d pageSetupUnixDialog) PageSetup() PageSetup {
	var _arg0 *C.GtkPageSetupUnixDialog // out
	var _cret *C.GtkPageSetup           // in

	_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_page_setup_unix_dialog_get_page_setup(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

func (d pageSetupUnixDialog) PrintSettings() PrintSettings {
	var _arg0 *C.GtkPageSetupUnixDialog // out
	var _cret *C.GtkPrintSettings       // in

	_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_page_setup_unix_dialog_get_print_settings(_arg0)

	var _printSettings PrintSettings // out

	_printSettings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PrintSettings)

	return _printSettings
}

func (d pageSetupUnixDialog) SetPageSetupPageSetupUnixDialog(pageSetup PageSetup) {
	var _arg0 *C.GtkPageSetupUnixDialog // out
	var _arg1 *C.GtkPageSetup           // out

	_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))

	C.gtk_page_setup_unix_dialog_set_page_setup(_arg0, _arg1)
}

func (d pageSetupUnixDialog) SetPrintSettingsPageSetupUnixDialog(printSettings PrintSettings) {
	var _arg0 *C.GtkPageSetupUnixDialog // out
	var _arg1 *C.GtkPrintSettings       // out

	_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(printSettings.Native()))

	C.gtk_page_setup_unix_dialog_set_print_settings(_arg0, _arg1)
}

func (s pageSetupUnixDialog) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s pageSetupUnixDialog) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s pageSetupUnixDialog) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s pageSetupUnixDialog) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s pageSetupUnixDialog) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s pageSetupUnixDialog) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s pageSetupUnixDialog) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b pageSetupUnixDialog) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s pageSetupUnixDialog) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s pageSetupUnixDialog) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s pageSetupUnixDialog) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s pageSetupUnixDialog) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s pageSetupUnixDialog) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s pageSetupUnixDialog) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s pageSetupUnixDialog) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s pageSetupUnixDialog) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// Paned: `GtkPaned` has two panes, arranged either horizontally or vertically.
//
// !An example GtkPaned (panes.png)
//
// The division between the two panes is adjustable by the user by dragging a
// handle.
//
// Child widgets are added to the panes of the widget with
// [method@Gtk.Paned.set_start_child] and [method@Gtk.Paned.set_end_child]. The
// division between the two children is set by default from the size requests of
// the children, but it can be adjusted by the user.
//
// A paned widget draws a separator between the two child widgets and a small
// handle that the user can drag to adjust the division. It does not draw any
// relief around the children or around the separator. (The space in which the
// separator is called the gutter.) Often, it is useful to put each child inside
// a [class@Gtk.Frame] so that the gutter appears as a ridge. No separator is
// drawn if one of the children is missing.
//
// Each child has two options that can be set, @resize and @shrink. If @resize
// is true, then when the `GtkPaned` is resized, that child will expand or
// shrink along with the paned widget. If @shrink is true, then that child can
// be made smaller than its requisition by the user. Setting @shrink to false
// allows the application to set a minimum size. If @resize is false for both
// children, then this is treated as if @resize is true for both children.
//
// The application can set the position of the slider as if it were set by the
// user, by calling [method@Gtk.Paned.set_position].
//
//
// CSS nodes
//
// ` paned  <child>  separator[.wide]  <child> `
//
// `GtkPaned` has a main CSS node with name paned, and a subnode for the
// separator with name separator. The subnode gets a .wide style class when the
// paned is supposed to be wide.
//
// In horizontal orientation, the nodes are arranged based on the text
// direction, so in left-to-right mode, :first-child will select the leftmost
// child, while it will select the rightmost child in RTL layouts.
//
// Creating a paned widget with minimum sizes.
//
// `c GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL); GtkWidget
// *frame1 = gtk_frame_new (NULL); GtkWidget *frame2 = gtk_frame_new (NULL);
//
// gtk_widget_set_size_request (hpaned, 200, -1);
//
// gtk_paned_set_start_child (GTK_PANED (hpaned), frame1);
// gtk_paned_set_start_child_resize (GTK_PANED (hpaned), TRUE);
// gtk_paned_set_start_child_shrink (GTK_PANED (hpaned), FALSE);
// gtk_widget_set_size_request (frame1, 50, -1);
//
// gtk_paned_set_end_child (GTK_PANED (hpaned), frame2);
// gtk_paned_set_end_child_resize (GTK_PANED (hpaned), FALSE);
// gtk_paned_set_end_child_shrink (GTK_PANED (hpaned), FALSE);
// gtk_widget_set_size_request (frame2, 50, -1); `
type Paned interface {
	Widget
	Orientable

	// EndChild retrieves the end child of the given `GtkPaned`.
	//
	// See also: `GtkPaned`:end-child
	EndChild() Widget
	// Position obtains the position of the divider between the two panes.
	Position() int
	// ResizeEndChild returns whether the end child can be resized.
	ResizeEndChild() bool
	// ResizeStartChild returns whether the start child can be resized.
	ResizeStartChild() bool
	// ShrinkEndChild returns whether the end child can be shrunk.
	ShrinkEndChild() bool
	// ShrinkStartChild returns whether the start child can be shrunk.
	ShrinkStartChild() bool
	// StartChild retrieves the start child of the given `GtkPaned`.
	//
	// See also: `GtkPaned`:start-child
	StartChild() Widget
	// WideHandle gets whether the separator should be wide.
	WideHandle() bool
	// SetEndChildPaned sets the end child of @paned to @child.
	SetEndChildPaned(child Widget)
	// SetPositionPaned sets the position of the divider between the two panes.
	SetPositionPaned(position int)
	// SetResizeEndChildPaned sets the `GtkPaned`:resize-end-child property
	SetResizeEndChildPaned(resize bool)
	// SetResizeStartChildPaned sets the `GtkPaned`:resize-start-child property
	SetResizeStartChildPaned(resize bool)
	// SetShrinkEndChildPaned sets the `GtkPaned`:shrink-end-child property
	SetShrinkEndChildPaned(resize bool)
	// SetShrinkStartChildPaned sets the `GtkPaned`:shrink-start-child property
	SetShrinkStartChildPaned(resize bool)
	// SetStartChildPaned sets the start child of @paned to @child.
	SetStartChildPaned(child Widget)
	// SetWideHandlePaned sets whether the separator should be wide.
	SetWideHandlePaned(wide bool)
}

// paned implements the Paned class.
type paned struct {
	Widget
}

// WrapPaned wraps a GObject to the right type. It is
// primarily used internally.
func WrapPaned(obj *externglib.Object) Paned {
	return paned{
		Widget: WrapWidget(obj),
	}
}

func marshalPaned(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPaned(obj), nil
}

// NewPaned creates a new `GtkPaned` widget.
func NewPaned(orientation Orientation) Paned {
	var _arg1 C.GtkOrientation // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_paned_new(_arg1)

	var _paned Paned // out

	_paned = WrapPaned(externglib.Take(unsafe.Pointer(_cret)))

	return _paned
}

func (p paned) EndChild() Widget {
	var _arg0 *C.GtkPaned  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_end_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (p paned) Position() int {
	var _arg0 *C.GtkPaned // out
	var _cret C.int       // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_position(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (p paned) ResizeEndChild() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_resize_end_child(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p paned) ResizeStartChild() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_resize_start_child(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p paned) ShrinkEndChild() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_shrink_end_child(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p paned) ShrinkStartChild() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_shrink_start_child(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p paned) StartChild() Widget {
	var _arg0 *C.GtkPaned  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_start_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (p paned) WideHandle() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_wide_handle(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p paned) SetEndChildPaned(child Widget) {
	var _arg0 *C.GtkPaned  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_paned_set_end_child(_arg0, _arg1)
}

func (p paned) SetPositionPaned(position int) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (C.int)(position)

	C.gtk_paned_set_position(_arg0, _arg1)
}

func (p paned) SetResizeEndChildPaned(resize bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_resize_end_child(_arg0, _arg1)
}

func (p paned) SetResizeStartChildPaned(resize bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_resize_start_child(_arg0, _arg1)
}

func (p paned) SetShrinkEndChildPaned(resize bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_shrink_end_child(_arg0, _arg1)
}

func (p paned) SetShrinkStartChildPaned(resize bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_shrink_start_child(_arg0, _arg1)
}

func (p paned) SetStartChildPaned(child Widget) {
	var _arg0 *C.GtkPaned  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_paned_set_start_child(_arg0, _arg1)
}

func (p paned) SetWideHandlePaned(wide bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if wide {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_wide_handle(_arg0, _arg1)
}

func (s paned) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s paned) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s paned) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s paned) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s paned) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s paned) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s paned) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b paned) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o paned) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o paned) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// PasswordEntry: `GtkPasswordEntry` is an entry that has been tailored for
// entering secrets.
//
// !An example GtkPasswordEntry (password-entry.png)
//
// It does not show its contents in clear text, does not allow to copy it to the
// clipboard, and it shows a warning when Caps Lock is engaged. If the
// underlying platform allows it, `GtkPasswordEntry` will also place the text in
// a non-pageable memory area, to avoid it being written out to disk by the
// operating system.
//
// Optionally, it can offer a way to reveal the contents in clear text.
//
// `GtkPasswordEntry` provides only minimal API and should be used with the
// [iface@Gtk.Editable] API.
//
//
// CSS Nodes
//
// ` entry.password  text  image.caps-lock-indicator  `
//
// `GtkPasswordEntry` has a single CSS node with name entry that carries a
// .passwordstyle class. The text Css node below it has a child with name image
// and style class .caps-lock-indicator for the Caps Lock icon, and possibly
// other children.
//
//
// Accessibility
//
// `GtkPasswordEntry` uses the GTK_ACCESSIBLE_ROLE_TEXT_BOX role.
type PasswordEntry interface {
	Editable

	// ExtraMenu gets the menu model set with
	// gtk_password_entry_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// ShowPeekIcon returns whether the entry is showing an icon to reveal the
	// contents.
	ShowPeekIcon() bool
	// SetExtraMenuPasswordEntry sets a menu model to add when constructing the
	// context menu for @entry.
	SetExtraMenuPasswordEntry(model gio.MenuModel)
	// SetShowPeekIconPasswordEntry sets whether the entry should have a
	// clickable icon to reveal the contents.
	//
	// Setting this to false also hides the text again.
	SetShowPeekIconPasswordEntry(showPeekIcon bool)
}

// passwordEntry implements the PasswordEntry class.
type passwordEntry struct {
	Widget
}

// WrapPasswordEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapPasswordEntry(obj *externglib.Object) PasswordEntry {
	return passwordEntry{
		Widget: WrapWidget(obj),
	}
}

func marshalPasswordEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPasswordEntry(obj), nil
}

// NewPasswordEntry creates a `GtkPasswordEntry`.
func NewPasswordEntry() PasswordEntry {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_password_entry_new()

	var _passwordEntry PasswordEntry // out

	_passwordEntry = WrapPasswordEntry(externglib.Take(unsafe.Pointer(_cret)))

	return _passwordEntry
}

func (e passwordEntry) ExtraMenu() gio.MenuModel {
	var _arg0 *C.GtkPasswordEntry // out
	var _cret *C.GMenuModel       // in

	_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_password_entry_get_extra_menu(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (e passwordEntry) ShowPeekIcon() bool {
	var _arg0 *C.GtkPasswordEntry // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_password_entry_get_show_peek_icon(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e passwordEntry) SetExtraMenuPasswordEntry(model gio.MenuModel) {
	var _arg0 *C.GtkPasswordEntry // out
	var _arg1 *C.GMenuModel       // out

	_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_password_entry_set_extra_menu(_arg0, _arg1)
}

func (e passwordEntry) SetShowPeekIconPasswordEntry(showPeekIcon bool) {
	var _arg0 *C.GtkPasswordEntry // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(e.Native()))
	if showPeekIcon {
		_arg1 = C.TRUE
	}

	C.gtk_password_entry_set_show_peek_icon(_arg0, _arg1)
}

func (s passwordEntry) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s passwordEntry) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s passwordEntry) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s passwordEntry) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s passwordEntry) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s passwordEntry) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s passwordEntry) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b passwordEntry) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (e passwordEntry) DeleteSelection() {
	WrapEditable(gextras.InternObject(e)).DeleteSelection()
}

func (e passwordEntry) DeleteText(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).DeleteText(startPos, endPos)
}

func (e passwordEntry) FinishDelegate() {
	WrapEditable(gextras.InternObject(e)).FinishDelegate()
}

func (e passwordEntry) Alignment() float32 {
	return WrapEditable(gextras.InternObject(e)).Alignment()
}

func (e passwordEntry) Chars(startPos int, endPos int) string {
	return WrapEditable(gextras.InternObject(e)).Chars(startPos, endPos)
}

func (e passwordEntry) Delegate() Editable {
	return WrapEditable(gextras.InternObject(e)).Delegate()
}

func (e passwordEntry) Editable() bool {
	return WrapEditable(gextras.InternObject(e)).Editable()
}

func (e passwordEntry) EnableUndo() bool {
	return WrapEditable(gextras.InternObject(e)).EnableUndo()
}

func (e passwordEntry) MaxWidthChars() int {
	return WrapEditable(gextras.InternObject(e)).MaxWidthChars()
}

func (e passwordEntry) Position() int {
	return WrapEditable(gextras.InternObject(e)).Position()
}

func (e passwordEntry) SelectionBounds() (startPos int, endPos int, ok bool) {
	return WrapEditable(gextras.InternObject(e)).SelectionBounds()
}

func (e passwordEntry) Text() string {
	return WrapEditable(gextras.InternObject(e)).Text()
}

func (e passwordEntry) WidthChars() int {
	return WrapEditable(gextras.InternObject(e)).WidthChars()
}

func (e passwordEntry) InitDelegate() {
	WrapEditable(gextras.InternObject(e)).InitDelegate()
}

func (e passwordEntry) SelectRegion(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).SelectRegion(startPos, endPos)
}

func (e passwordEntry) SetAlignment(xalign float32) {
	WrapEditable(gextras.InternObject(e)).SetAlignment(xalign)
}

func (e passwordEntry) SetEditable(isEditable bool) {
	WrapEditable(gextras.InternObject(e)).SetEditable(isEditable)
}

func (e passwordEntry) SetEnableUndo(enableUndo bool) {
	WrapEditable(gextras.InternObject(e)).SetEnableUndo(enableUndo)
}

func (e passwordEntry) SetMaxWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetMaxWidthChars(nChars)
}

func (e passwordEntry) SetPosition(position int) {
	WrapEditable(gextras.InternObject(e)).SetPosition(position)
}

func (e passwordEntry) SetText(text string) {
	WrapEditable(gextras.InternObject(e)).SetText(text)
}

func (e passwordEntry) SetWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetWidthChars(nChars)
}

// Picture: the `GtkPicture` widget displays a `GdkPaintable`.
//
// !An example GtkPicture (picture.png)
//
// Many convenience functions are provided to make pictures simple to use. For
// example, if you want to load an image from a file, and then display it,
// theres a convenience function to do this:
//
// `c GtkWidget *widget = gtk_picture_new_for_filename ("myfile.png"); `
//
// If the file isnt loaded successfully, the picture will contain a broken
// image icon similar to that used in many web browsers. If you want to handle
// errors in loading the file yourself, for example by displaying an error
// message, then load the image with [ctor@Gdk.Texture.new_from_file], then
// create the `GtkPicture` with [ctor@Gtk.Picture.new_for_paintable].
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of `GResource` for details. In
// this case, [ctor@Gtk.Picture.new_for_resource] and
// [method@Gtk.Picture.set_resource] should be used.
//
// `GtkPicture` displays an image at its natural size. See [class@Gtk.Image] if
// you want to display a fixed-size image, such as an icon.
//
//
// Sizing the paintable
//
// You can influence how the paintable is displayed inside the `GtkPicture`. By
// turning off [property@Gtk.Picture:keep-aspect-ratio] you can allow the
// paintable to get stretched. [property@Gtk.Picture:can-shrink] can be unset to
// make sure that paintables are never made smaller than their ideal size - but
// be careful if you do not know the size of the paintable in use (like when
// displaying user-loaded images). This can easily cause the picture to grow
// larger than the screen. And [property@GtkWidget:halign] and
// [property@GtkWidget:valign] can be used to make sure the paintable doesn't
// fill all available space but is instead displayed at its original size.
//
//
// CSS nodes
//
// `GtkPicture` has a single CSS node with the name `picture`.
//
//
// Accessibility
//
// `GtkPicture` uses the `GTK_ACCESSIBLE_ROLE_IMG` role.
type Picture interface {
	Widget

	// AlternativeText gets the alternative textual description of the picture.
	//
	// The returned string will be nil if the picture cannot be described
	// textually.
	AlternativeText() string
	// CanShrink returns whether the `GtkPicture` respects its contents size.
	CanShrink() bool
	// File gets the `GFile` currently displayed if @self is displaying a file.
	//
	// If @self is not displaying a file, for example when
	// [method@Gtk.Picture.set_paintable] was used, then nil is returned.
	File() gio.File
	// KeepAspectRatio returns whether the `GtkPicture` preserves its contents
	// aspect ratio.
	KeepAspectRatio() bool
	// Paintable gets the `GdkPaintable` being displayed by the `GtkPicture`.
	Paintable() gdk.Paintable
	// SetAlternativeTextPicture sets an alternative textual description for the
	// picture contents.
	//
	// It is equivalent to the "alt" attribute for images on websites.
	//
	// This text will be made available to accessibility tools.
	//
	// If the picture cannot be described textually, set this property to nil.
	SetAlternativeTextPicture(alternativeText string)
	// SetCanShrinkPicture: if set to true, the @self can be made smaller than
	// its contents.
	//
	// The contents will then be scaled down when rendering.
	//
	// If you want to still force a minimum size manually, consider using
	// [method@Gtk.Widget.set_size_request].
	//
	// Also of note is that a similar function for growing does not exist
	// because the grow behavior can be controlled via
	// [method@Gtk.Widget.set_halign] and [method@Gtk.Widget.set_valign].
	SetCanShrinkPicture(canShrink bool)
	// SetFilePicture makes @self load and display @file.
	//
	// See [ctor@Gtk.Picture.new_for_file] for details.
	SetFilePicture(file gio.File)
	// SetFilenamePicture makes @self load and display the given @filename.
	//
	// This is a utility function that calls [method@Gtk.Picture.set_file].
	SetFilenamePicture(filename string)
	// SetKeepAspectRatioPicture: if set to true, the @self will render its
	// contents according to their aspect ratio.
	//
	// That means that empty space may show up at the top/bottom or left/right
	// of @self.
	//
	// If set to false or if the contents provide no aspect ratio, the contents
	// will be stretched over the picture's whole area.
	SetKeepAspectRatioPicture(keepAspectRatio bool)
	// SetPaintablePicture makes @self display the given @paintable.
	//
	// If @paintable is nil, nothing will be displayed.
	//
	// See [ctor@Gtk.Picture.new_for_paintable] for details.
	SetPaintablePicture(paintable gdk.Paintable)
	// SetPixbufPicture sets a `GtkPicture` to show a `GdkPixbuf`.
	//
	// See [ctor@Gtk.Picture.new_for_pixbuf] for details.
	//
	// This is a utility function that calls [method@Gtk.Picture.set_paintable].
	SetPixbufPicture(pixbuf gdkpixbuf.Pixbuf)
	// SetResourcePicture makes @self load and display the resource at the given
	// @resource_path.
	//
	// This is a utility function that calls [method@Gtk.Picture.set_file].
	SetResourcePicture(resourcePath string)
}

// picture implements the Picture class.
type picture struct {
	Widget
}

// WrapPicture wraps a GObject to the right type. It is
// primarily used internally.
func WrapPicture(obj *externglib.Object) Picture {
	return picture{
		Widget: WrapWidget(obj),
	}
}

func marshalPicture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPicture(obj), nil
}

// NewPicture creates a new empty `GtkPicture` widget.
func NewPicture() Picture {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_picture_new()

	var _picture Picture // out

	_picture = WrapPicture(externglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForFile creates a new `GtkPicture` displaying the given @file.
//
// If the file isnt found or cant be loaded, the resulting `GtkPicture` is
// empty.
//
// If you need to detect failures to load the file, use
// [ctor@Gdk.Texture.new_from_file] to load the file yourself, then create the
// `GtkPicture` from the texture.
func NewPictureForFile(file gio.File) Picture {
	var _arg1 *C.GFile     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	_cret = C.gtk_picture_new_for_file(_arg1)

	var _picture Picture // out

	_picture = WrapPicture(externglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForFilename creates a new `GtkPicture` displaying the file
// @filename.
//
// This is a utility function that calls [ctor@Gtk.Picture.new_for_file]. See
// that function for details.
func NewPictureForFilename(filename string) Picture {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_picture_new_for_filename(_arg1)

	var _picture Picture // out

	_picture = WrapPicture(externglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForPaintable creates a new `GtkPicture` displaying @paintable.
//
// The `GtkPicture` will track changes to the @paintable and update its size and
// contents in response to it.
func NewPictureForPaintable(paintable gdk.Paintable) Picture {
	var _arg1 *C.GdkPaintable // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	_cret = C.gtk_picture_new_for_paintable(_arg1)

	var _picture Picture // out

	_picture = WrapPicture(externglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForPixbuf creates a new `GtkPicture` displaying @pixbuf.
//
// This is a utility function that calls [ctor@Gtk.Picture.new_for_paintable],
// See that function for details.
//
// The pixbuf must not be modified after passing it to this function.
func NewPictureForPixbuf(pixbuf gdkpixbuf.Pixbuf) Picture {
	var _arg1 *C.GdkPixbuf // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_picture_new_for_pixbuf(_arg1)

	var _picture Picture // out

	_picture = WrapPicture(externglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForResource creates a new `GtkPicture` displaying the resource at
// @resource_path.
//
// This is a utility function that calls [ctor@Gtk.Picture.new_for_file]. See
// that function for details.
func NewPictureForResource(resourcePath string) Picture {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_picture_new_for_resource(_arg1)

	var _picture Picture // out

	_picture = WrapPicture(externglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

func (s picture) AlternativeText() string {
	var _arg0 *C.GtkPicture // out
	var _cret *C.char       // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_picture_get_alternative_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s picture) CanShrink() bool {
	var _arg0 *C.GtkPicture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_picture_get_can_shrink(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s picture) File() gio.File {
	var _arg0 *C.GtkPicture // out
	var _cret *C.GFile      // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_picture_get_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

func (s picture) KeepAspectRatio() bool {
	var _arg0 *C.GtkPicture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_picture_get_keep_aspect_ratio(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s picture) Paintable() gdk.Paintable {
	var _arg0 *C.GtkPicture   // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_picture_get_paintable(_arg0)

	var _paintable gdk.Paintable // out

	_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

	return _paintable
}

func (s picture) SetAlternativeTextPicture(alternativeText string) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(alternativeText))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_picture_set_alternative_text(_arg0, _arg1)
}

func (s picture) SetCanShrinkPicture(canShrink bool) {
	var _arg0 *C.GtkPicture // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
	if canShrink {
		_arg1 = C.TRUE
	}

	C.gtk_picture_set_can_shrink(_arg0, _arg1)
}

func (s picture) SetFilePicture(file gio.File) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.GFile      // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_picture_set_file(_arg0, _arg1)
}

func (s picture) SetFilenamePicture(filename string) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_picture_set_filename(_arg0, _arg1)
}

func (s picture) SetKeepAspectRatioPicture(keepAspectRatio bool) {
	var _arg0 *C.GtkPicture // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
	if keepAspectRatio {
		_arg1 = C.TRUE
	}

	C.gtk_picture_set_keep_aspect_ratio(_arg0, _arg1)
}

func (s picture) SetPaintablePicture(paintable gdk.Paintable) {
	var _arg0 *C.GtkPicture   // out
	var _arg1 *C.GdkPaintable // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_picture_set_paintable(_arg0, _arg1)
}

func (s picture) SetPixbufPicture(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.GdkPixbuf  // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_picture_set_pixbuf(_arg0, _arg1)
}

func (s picture) SetResourcePicture(resourcePath string) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_picture_set_resource(_arg0, _arg1)
}

func (s picture) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s picture) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s picture) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s picture) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s picture) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s picture) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s picture) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b picture) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Popover: `GtkPopover` is a bubble-like context popup.
//
// !An example GtkPopover (popover.png)
//
// It is primarily meant to provide context-dependent information or options.
// Popovers are attached to a parent widget. By default, they point to the whole
// widget area, although this behavior can be changed with
// [method@Gtk.Popover.set_pointing_to].
//
// The position of a popover relative to the widget it is attached to can also
// be changed with [method@Gtk.Popover.set_position]
//
// By default, `GtkPopover` performs a grab, in order to ensure input events get
// redirected to it while it is shown, and also so the popover is dismissed in
// the expected situations (clicks outside the popover, or the Escape key being
// pressed). If no such modal behavior is desired on a popover,
// [method@Gtk.Popover.set_autohide] may be called on it to tweak its behavior.
//
//
// GtkPopover as menu replacement
//
// `GtkPopover` is often used to replace menus. The best was to do this is to
// use the [class@Gtk.PopoverMenu] subclass which supports being populated from
// a `GMenuModel` with [ctor@Gtk.PopoverMenu.new_from_model].
//
// `xml <section> <attribute name="display-hint">horizontal-buttons</attribute>
// <item> <attribute name="label">Cut</attribute> <attribute
// name="action">app.cut</attribute> <attribute
// name="verb-icon">edit-cut-symbolic</attribute> </item> <item> <attribute
// name="label">Copy</attribute> <attribute name="action">app.copy</attribute>
// <attribute name="verb-icon">edit-copy-symbolic</attribute> </item> <item>
// <attribute name="label">Paste</attribute> <attribute
// name="action">app.paste</attribute> <attribute
// name="verb-icon">edit-paste-symbolic</attribute> </item> </section> `
//
//
// CSS nodes
//
// ` popover[.menu]  arrow  contents.background  <child> `
//
// The contents child node always gets the .background style class and the
// popover itself gets the .menu style class if the popover is menu-like (i.e.
// `GtkPopoverMenu`).
//
// Particular uses of `GtkPopover`, such as touch selection popups or magnifiers
// in `GtkEntry` or `GtkTextView` get style classes like .touch-selection or
// .magnifier to differentiate from plain popovers.
//
// When styling a popover directly, the popover node should usually not have any
// background. The visible part of the popover can have a shadow. To specify it
// in CSS, set the box-shadow of the contents node.
//
// Note that, in order to accomplish appropriate arrow visuals, `GtkPopover`
// uses custom drawing for the arrow node. This makes it possible for the arrow
// to change its shape dynamically, but it also limits the possibilities of
// styling it using CSS. In particular, the arrow gets drawn over the content
// node's border and shadow, so they look like one shape, which means that the
// border width of the content node and the arrow node should be the same. The
// arrow also does not support any border shape other than solid, no
// border-radius, only one border width (border-bottom-width is used) and no
// box-shadow.
type Popover interface {
	Native
	ShortcutManager

	// Autohide returns whether the popover is modal.
	//
	// See [method@Gtk.Popover.set_autohide] for the implications of this.
	Autohide() bool
	// CascadePopdown returns whether the popover will close after a modal child
	// is closed.
	CascadePopdown() bool
	// Child gets the child widget of @popover.
	Child() Widget
	// HasArrow gets whether this popover is showing an arrow pointing at the
	// widget that it is relative to.
	HasArrow() bool
	// MnemonicsVisible gets whether mnemonics are visible.
	MnemonicsVisible() bool
	// Offset gets the offset previous set with gtk_popover_set_offset().
	Offset() (xOffset int, yOffset int)
	// PointingTo gets the rectangle that the popover points to.
	//
	// If a rectangle to point to has been set, this function will return true
	// and fill in @rect with such rectangle, otherwise it will return false and
	// fill in @rect with the parent widget coordinates.
	PointingTo() (gdk.Rectangle, bool)
	// Position returns the preferred position of @popover.
	Position() PositionType
	// PopdownPopover pops @popover down.
	//
	// This is different from a [method@Gtk.Widget.hide] call in that it may
	// show the popover with a transition. If you want to hide the popover
	// without a transition, just use [method@Gtk.Widget.hide].
	PopdownPopover()
	// PopupPopover pops @popover up.
	//
	// This is different from a [method@Gtk.Widget.show() call in that it may
	// show the popover with a transition. If you want to show the popover
	// without a transition, just use [method@Gtk.Widget.show].
	PopupPopover()
	// PresentPopover presents the popover to the user.
	PresentPopover()
	// SetAutohidePopover sets whether @popover is modal.
	//
	// A modal popover will grab the keyboard focus on it when being displayed.
	// Clicking outside the popover area or pressing Esc will dismiss the
	// popover.
	//
	// Called this function on an already showing popup with a new autohide
	// value different from the current one, will cause the popup to be hidden.
	SetAutohidePopover(autohide bool)
	// SetCascadePopdownPopover: if @cascade_popdown is true, the popover will
	// be closed when a child modal popover is closed.
	//
	// If false, @popover will stay visible.
	SetCascadePopdownPopover(cascadePopdown bool)
	// SetChildPopover sets the child widget of @popover.
	SetChildPopover(child Widget)
	// SetDefaultWidgetPopover sets the default widget of a `GtkPopover`.
	//
	// The default widget is the widget thats activated when the user presses
	// Enter in a dialog (for example). This function sets or unsets the default
	// widget for a `GtkPopover`.
	SetDefaultWidgetPopover(widget Widget)
	// SetHasArrowPopover sets whether this popover should draw an arrow
	// pointing at the widget it is relative to.
	SetHasArrowPopover(hasArrow bool)
	// SetMnemonicsVisiblePopover sets whether mnemonics should be visible.
	SetMnemonicsVisiblePopover(mnemonicsVisible bool)
	// SetOffsetPopover sets the offset to use when calculating the position of
	// the popover.
	//
	// These values are used when preparing the [struct@Gdk.PopupLayout] for
	// positioning the popover.
	SetOffsetPopover(xOffset int, yOffset int)
	// SetPointingToPopover sets the rectangle that @popover points to.
	//
	// This is in the coordinate space of the @popover parent.
	SetPointingToPopover(rect *gdk.Rectangle)
	// SetPositionPopover sets the preferred position for @popover to appear.
	//
	// If the @popover is currently visible, it will be immediately updated.
	//
	// This preference will be respected where possible, although on lack of
	// space (eg. if close to the window edges), the `GtkPopover` may choose to
	// appear on the opposite side.
	SetPositionPopover(position PositionType)
}

// popover implements the Popover class.
type popover struct {
	Widget
}

// WrapPopover wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopover(obj *externglib.Object) Popover {
	return popover{
		Widget: WrapWidget(obj),
	}
}

func marshalPopover(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopover(obj), nil
}

// NewPopover creates a new `GtkPopover`.
func NewPopover() Popover {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_popover_new()

	var _popover Popover // out

	_popover = WrapPopover(externglib.Take(unsafe.Pointer(_cret)))

	return _popover
}

func (p popover) Autohide() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_autohide(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p popover) CascadePopdown() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_cascade_popdown(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p popover) Child() Widget {
	var _arg0 *C.GtkPopover // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (p popover) HasArrow() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_has_arrow(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p popover) MnemonicsVisible() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_mnemonics_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p popover) Offset() (xOffset int, yOffset int) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.int         // in
	var _arg2 C.int         // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	C.gtk_popover_get_offset(_arg0, &_arg1, &_arg2)

	var _xOffset int // out
	var _yOffset int // out

	_xOffset = (int)(_arg1)
	_yOffset = (int)(_arg2)

	return _xOffset, _yOffset
}

func (p popover) PointingTo() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkPopover // out
	var _rect gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_pointing_to(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

func (p popover) Position() PositionType {
	var _arg0 *C.GtkPopover     // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_position(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

func (p popover) PopdownPopover() {
	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	C.gtk_popover_popdown(_arg0)
}

func (p popover) PopupPopover() {
	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	C.gtk_popover_popup(_arg0)
}

func (p popover) PresentPopover() {
	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	C.gtk_popover_present(_arg0)
}

func (p popover) SetAutohidePopover(autohide bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	if autohide {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_autohide(_arg0, _arg1)
}

func (p popover) SetCascadePopdownPopover(cascadePopdown bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	if cascadePopdown {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_cascade_popdown(_arg0, _arg1)
}

func (p popover) SetChildPopover(child Widget) {
	var _arg0 *C.GtkPopover // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_popover_set_child(_arg0, _arg1)
}

func (p popover) SetDefaultWidgetPopover(widget Widget) {
	var _arg0 *C.GtkPopover // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_popover_set_default_widget(_arg0, _arg1)
}

func (p popover) SetHasArrowPopover(hasArrow bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	if hasArrow {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_has_arrow(_arg0, _arg1)
}

func (p popover) SetMnemonicsVisiblePopover(mnemonicsVisible bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	if mnemonicsVisible {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_mnemonics_visible(_arg0, _arg1)
}

func (p popover) SetOffsetPopover(xOffset int, yOffset int) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.int         // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (C.int)(xOffset)
	_arg2 = (C.int)(yOffset)

	C.gtk_popover_set_offset(_arg0, _arg1, _arg2)
}

func (p popover) SetPointingToPopover(rect *gdk.Rectangle) {
	var _arg0 *C.GtkPopover   // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

	C.gtk_popover_set_pointing_to(_arg0, _arg1)
}

func (p popover) SetPositionPopover(position PositionType) {
	var _arg0 *C.GtkPopover     // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (C.GtkPositionType)(position)

	C.gtk_popover_set_position(_arg0, _arg1)
}

func (s popover) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s popover) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s popover) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s popover) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s popover) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s popover) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s popover) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b popover) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s popover) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s popover) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s popover) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s popover) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s popover) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

// PopoverMenu: `GtkPopoverMenu` is a subclass of `GtkPopover` that implements
// menu behavior.
//
// !An example GtkPopoverMenu (menu.png)
//
// `GtkPopoverMenu` treats its children like menus and allows switching between
// them. It can open submenus as traditional, nested submenus, or in a more
// touch-friendly sliding fashion.
//
// `GtkPopoverMenu` is meant to be used primarily with menu models, using
// [ctor@Gtk.PopoverMenu.new_from_model]. If you need to put other widgets such
// as a `GtkSpinButton` or a `GtkSwitch` into a popover, you can use
// [method@Gtk.PopoverMenu.add_child].
//
// For more dialog-like behavior, use a plain `GtkPopover`.
//
//
// Menu models
//
// The XML format understood by `GtkBuilder` for `GMenuModel` consists of a
// toplevel `<menu>` element, which contains one or more `<item>` elements. Each
// `<item>` element contains `<attribute>` and `<link>` elements with a
// mandatory name attribute. `<link>` elements have the same content model as
// `<menu>`. Instead of `<link name="submenu>` or `<link name="section">`, you
// can use `<submenu>` or `<section>` elements.
//
// `xml <menu id='app-menu'> <section> <item> <attribute name='label'
// translatable='yes'>_New Window</attribute> <attribute
// name='action'>app.new</attribute> </item> <item> <attribute name='label'
// translatable='yes'>_About Sunny</attribute> <attribute
// name='action'>app.about</attribute> </item> <item> <attribute name='label'
// translatable='yes'>_Quit</attribute> <attribute
// name='action'>app.quit</attribute> </item> </section> </menu> `
//
// Attribute values can be translated using gettext, like other `GtkBuilder`
// content. `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the Builder must have been given the gettext domain to
// use.
//
// The following attributes are used when constructing menu items:
//
// - "label": a user-visible string to display - "action": the prefixed name of
// the action to trigger - "target": the parameter to use when activating the
// action - "icon" and "verb-icon": names of icons that may be displayed -
// "submenu-action": name of an action that may be used to determine if a
// submenu can be opened - "hidden-when": a string used to determine when the
// item will be hidden. Possible values include "action-disabled",
// "action-missing", "macos-menubar". This is mainly useful for exported menus,
// see [method@Gtk.Application.set_menubar]. - "custom": a string used to match
// against the ID of a custom child added with
// [method@Gtk.PopoverMenu.add_child], [method@Gtk.PopoverMenuBar.add_child], or
// in the ui file with `<child type="ID">`.
//
// The following attributes are used when constructing sections:
//
// - "label": a user-visible string to use as section heading - "display-hint":
// a string used to determine special formatting for the section. Possible
// values include "horizontal-buttons", "circular-buttons" and "inline-buttons".
// They all indicate that section should be displayed as a horizontal row of
// buttons. - "text-direction": a string used to determine the
// `GtkTextDirection` to use when "display-hint" is set to "horizontal-buttons".
// Possible values include "rtl", "ltr", and "none".
//
// The following attributes are used when constructing submenus:
//
// - "label": a user-visible string to display - "icon": icon name to display
//
// Menu items will also show accelerators, which are usually associated with
// actions via [method@Gtk.Application.set_accels_for_action],
// [id@gtk_widget_class_add_binding_action] or
// [method@Gtk.ShortcutController.add_shortcut].
//
//
// CSS Nodes
//
// `GtkPopoverMenu` is just a subclass of `GtkPopover` that adds custom content
// to it, therefore it has the same CSS nodes. It is one of the cases that add a
// .menu style class to the popover's main node.
//
//
// Accessibility
//
// `GtkPopoverMenu` uses the GTK_ACCESSIBLE_ROLE_MENU role, and its items use
// the GTK_ACCESSIBLE_ROLE_MENU_ITEM, GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX or
// GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO roles, depending on the action they are
// connected to.
type PopoverMenu interface {
	Popover

	// AddChildPopoverMenu adds a custom widget to a generated menu.
	//
	// For this to work, the menu model of @popover must have an item with a
	// `custom` attribute that matches @id.
	AddChildPopoverMenu(child Widget, id string) bool
	// MenuModel returns the menu model used to populate the popover.
	MenuModel() gio.MenuModel
	// RemoveChildPopoverMenu removes a widget that has previously been added
	// with gtk_popover_menu_add_child().
	RemoveChildPopoverMenu(child Widget) bool
	// SetMenuModelPopoverMenu sets a new menu model on @popover.
	//
	// The existing contents of @popover are removed, and the @popover is
	// populated with new contents according to @model.
	SetMenuModelPopoverMenu(model gio.MenuModel)
}

// popoverMenu implements the PopoverMenu class.
type popoverMenu struct {
	Popover
}

// WrapPopoverMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverMenu(obj *externglib.Object) PopoverMenu {
	return popoverMenu{
		Popover: WrapPopover(obj),
	}
}

func marshalPopoverMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverMenu(obj), nil
}

// NewPopoverMenuFromModel creates a `GtkPopoverMenu` and populates it according
// to @model.
//
// The created buttons are connected to actions found in the
// `GtkApplicationWindow` to which the popover belongs - typically by means of
// being attached to a widget that is contained within the
// `GtkApplicationWindow`s widget hierarchy.
//
// Actions can also be added using [method@Gtk.Widget.insert_action_group] on
// the menus attach widget or on any of its parent widgets.
//
// This function creates menus with sliding submenus. See
// [ctor@Gtk.PopoverMenu.new_from_model_full] for a way to control this.
func NewPopoverMenuFromModel(model gio.MenuModel) PopoverMenu {
	var _arg1 *C.GMenuModel // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_popover_menu_new_from_model(_arg1)

	var _popoverMenu PopoverMenu // out

	_popoverMenu = WrapPopoverMenu(externglib.Take(unsafe.Pointer(_cret)))

	return _popoverMenu
}

// NewPopoverMenuFromModelFull creates a `GtkPopoverMenu` and populates it
// according to @model.
//
// The created buttons are connected to actions found in the action groups that
// are accessible from the parent widget. This includes the
// `GtkApplicationWindow` to which the popover belongs. Actions can also be
// added using [method@Gtk.Widget.insert_action_group] on the parent widget or
// on any of its parent widgets.
//
// The only flag that is supported currently is GTK_POPOVER_MENU_NESTED, which
// makes GTK create traditional, nested submenus instead of the default sliding
// submenus.
func NewPopoverMenuFromModelFull(model gio.MenuModel, flags PopoverMenuFlags) PopoverMenu {
	var _arg1 *C.GMenuModel         // out
	var _arg2 C.GtkPopoverMenuFlags // out
	var _cret *C.GtkWidget          // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	_arg2 = (C.GtkPopoverMenuFlags)(flags)

	_cret = C.gtk_popover_menu_new_from_model_full(_arg1, _arg2)

	var _popoverMenu PopoverMenu // out

	_popoverMenu = WrapPopoverMenu(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _popoverMenu
}

func (p popoverMenu) AddChildPopoverMenu(child Widget, id string) bool {
	var _arg0 *C.GtkPopoverMenu // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 *C.char           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_popover_menu_add_child(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p popoverMenu) MenuModel() gio.MenuModel {
	var _arg0 *C.GtkPopoverMenu // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_menu_get_menu_model(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (p popoverMenu) RemoveChildPopoverMenu(child Widget) bool {
	var _arg0 *C.GtkPopoverMenu // out
	var _arg1 *C.GtkWidget      // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_popover_menu_remove_child(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p popoverMenu) SetMenuModelPopoverMenu(model gio.MenuModel) {
	var _arg0 *C.GtkPopoverMenu // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_popover_menu_set_menu_model(_arg0, _arg1)
}

func (s popoverMenu) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s popoverMenu) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s popoverMenu) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s popoverMenu) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s popoverMenu) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s popoverMenu) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s popoverMenu) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b popoverMenu) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s popoverMenu) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s popoverMenu) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s popoverMenu) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s popoverMenu) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s popoverMenu) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

// PopoverMenuBar: `GtkPopoverMenuBar` presents a horizontal bar of items that
// pop up popover menus when clicked.
//
// !An example GtkPopoverMenuBar (menubar.png)
//
// The only way to create instances of `GtkPopoverMenuBar` is from a
// `GMenuModel`.
//
//
// CSS nodes
//
// ` menubar  item[.active]   popover  item  popover `
//
// `GtkPopoverMenuBar` has a single CSS node with name menubar, below which each
// item has its CSS node, and below that the corresponding popover.
//
// The item whose popover is currently open gets the .active style class.
//
//
// Accessibility
//
// `GtkPopoverMenuBar` uses the GTK_ACCESSIBLE_ROLE_MENU_BAR role, the menu
// items use the GTK_ACCESSIBLE_ROLE_MENU_ITEM role and the menus use the
// GTK_ACCESSIBLE_ROLE_MENU role.
type PopoverMenuBar interface {
	Widget

	// AddChildPopoverMenuBar adds a custom widget to a generated menubar.
	//
	// For this to work, the menu model of @bar must have an item with a
	// `custom` attribute that matches @id.
	AddChildPopoverMenuBar(child Widget, id string) bool
	// MenuModel returns the model from which the contents of @bar are taken.
	MenuModel() gio.MenuModel
	// RemoveChildPopoverMenuBar removes a widget that has previously been added
	// with gtk_popover_menu_bar_add_child().
	RemoveChildPopoverMenuBar(child Widget) bool
	// SetMenuModelPopoverMenuBar sets a menu model from which @bar should take
	// its contents.
	SetMenuModelPopoverMenuBar(model gio.MenuModel)
}

// popoverMenuBar implements the PopoverMenuBar class.
type popoverMenuBar struct {
	Widget
}

// WrapPopoverMenuBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverMenuBar(obj *externglib.Object) PopoverMenuBar {
	return popoverMenuBar{
		Widget: WrapWidget(obj),
	}
}

func marshalPopoverMenuBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverMenuBar(obj), nil
}

// NewPopoverMenuBarFromModel creates a `GtkPopoverMenuBar` from a `GMenuModel`.
func NewPopoverMenuBarFromModel(model gio.MenuModel) PopoverMenuBar {
	var _arg1 *C.GMenuModel // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_popover_menu_bar_new_from_model(_arg1)

	var _popoverMenuBar PopoverMenuBar // out

	_popoverMenuBar = WrapPopoverMenuBar(externglib.Take(unsafe.Pointer(_cret)))

	return _popoverMenuBar
}

func (b popoverMenuBar) AddChildPopoverMenuBar(child Widget, id string) bool {
	var _arg0 *C.GtkPopoverMenuBar // out
	var _arg1 *C.GtkWidget         // out
	var _arg2 *C.char              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_popover_menu_bar_add_child(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b popoverMenuBar) MenuModel() gio.MenuModel {
	var _arg0 *C.GtkPopoverMenuBar // out
	var _cret *C.GMenuModel        // in

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_popover_menu_bar_get_menu_model(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (b popoverMenuBar) RemoveChildPopoverMenuBar(child Widget) bool {
	var _arg0 *C.GtkPopoverMenuBar // out
	var _arg1 *C.GtkWidget         // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_popover_menu_bar_remove_child(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b popoverMenuBar) SetMenuModelPopoverMenuBar(model gio.MenuModel) {
	var _arg0 *C.GtkPopoverMenuBar // out
	var _arg1 *C.GMenuModel        // out

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_popover_menu_bar_set_menu_model(_arg0, _arg1)
}

func (s popoverMenuBar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s popoverMenuBar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s popoverMenuBar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s popoverMenuBar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s popoverMenuBar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s popoverMenuBar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s popoverMenuBar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b popoverMenuBar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// PrintContext: a `GtkPrintContext` encapsulates context information that is
// required when drawing pages for printing.
//
// This includes the cairo context and important parameters like page size and
// resolution. It also lets you easily create [class@Pango.Layout] and
// [class@Pango.Context] objects that match the font metrics of the cairo
// surface.
//
// `GtkPrintContext` objects get passed to the
// [signal@Gtk.PrintOperation::begin-print],
// [signal@Gtk.PrintOperation::end-print],
// [signal@Gtk.PrintOperation::request-page-setup] and
// [signal@Gtk.PrintOperation::draw-page] signals on the
// [class@Gtk.PrintOperation] object.
//
// Using GtkPrintContext in a ::draw-page callback
//
// `c static void draw_page (GtkPrintOperation *operation, GtkPrintContext
// *context, int page_nr) { cairo_t *cr; PangoLayout *layout;
// PangoFontDescription *desc;
//
//    cr = gtk_print_context_get_cairo_context (context);
//
//    // Draw a red rectangle, as wide as the paper (inside the margins)
//    cairo_set_source_rgb (cr, 1.0, 0, 0);
//    cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//    cairo_fill (cr);
//
//    // Draw some lines
//    cairo_move_to (cr, 20, 10);
//    cairo_line_to (cr, 40, 20);
//    cairo_arc (cr, 60, 60, 20, 0, M_PI);
//    cairo_line_to (cr, 80, 20);
//
//    cairo_set_source_rgb (cr, 0, 0, 0);
//    cairo_set_line_width (cr, 5);
//    cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//    cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//    cairo_stroke (cr);
//
//    // Draw some text
//    layout = gtk_print_context_create_pango_layout (context);
//    pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//    desc = pango_font_description_from_string ("sans 28");
//    pango_layout_set_font_description (layout, desc);
//    pango_font_description_free (desc);
//
//    cairo_move_to (cr, 30, 20);
//    pango_cairo_layout_path (cr, layout);
//
//    // Font Outline
//    cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//    cairo_set_line_width (cr, 0.5);
//    cairo_stroke_preserve (cr);
//
//    // Font Fill
//    cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//    cairo_fill (cr);
//
//    g_object_unref (layout);
//
// } `
type PrintContext interface {

	// CreatePangoContextPrintContext creates a new `PangoContext` that can be
	// used with the `GtkPrintContext`.
	CreatePangoContextPrintContext() pango.Context
	// CreatePangoLayoutPrintContext creates a new `PangoLayout` that is
	// suitable for use with the `GtkPrintContext`.
	CreatePangoLayoutPrintContext() pango.Layout
	// CairoContext obtains the cairo context that is associated with the
	// `GtkPrintContext`.
	CairoContext() *cairo.Context
	// DPIX obtains the horizontal resolution of the `GtkPrintContext`, in dots
	// per inch.
	DPIX() float64
	// DPIY obtains the vertical resolution of the `GtkPrintContext`, in dots
	// per inch.
	DPIY() float64
	// HardMargins obtains the hardware printer margins of the
	// `GtkPrintContext`, in units.
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// Height obtains the height of the `GtkPrintContext`, in pixels.
	Height() float64
	// PageSetup obtains the `GtkPageSetup` that determines the page dimensions
	// of the `GtkPrintContext`.
	PageSetup() PageSetup
	// PangoFontmap returns a `PangoFontMap` that is suitable for use with the
	// `GtkPrintContext`.
	PangoFontmap() pango.FontMap
	// Width obtains the width of the `GtkPrintContext`, in pixels.
	Width() float64
	// SetCairoContextPrintContext sets a new cairo context on a print context.
	//
	// This function is intended to be used when implementing an internal print
	// preview, it is not needed for printing, since GTK itself creates a
	// suitable cairo context in that case.
	SetCairoContextPrintContext(cr *cairo.Context, dpiX float64, dpiY float64)
}

// printContext implements the PrintContext class.
type printContext struct {
	gextras.Objector
}

// WrapPrintContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintContext(obj *externglib.Object) PrintContext {
	return printContext{
		Objector: obj,
	}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintContext(obj), nil
}

func (c printContext) CreatePangoContextPrintContext() pango.Context {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.PangoContext    // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_create_pango_context(_arg0)

	var _ret pango.Context // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Context)

	return _ret
}

func (c printContext) CreatePangoLayoutPrintContext() pango.Layout {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.PangoLayout     // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_create_pango_layout(_arg0)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

func (c printContext) CairoContext() *cairo.Context {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.cairo_t         // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_cairo_context(_arg0)

	var _ret *cairo.Context // out

	_ret = cairo.WrapContext(unsafe.Pointer(_cret))

	return _ret
}

func (c printContext) DPIX() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.double           // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_dpi_x(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (c printContext) DPIY() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.double           // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_dpi_y(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (c printContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
	var _arg0 *C.GtkPrintContext // out
	var _arg1 C.double           // in
	var _arg2 C.double           // in
	var _arg3 C.double           // in
	var _arg4 C.double           // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_hard_margins(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _top float64    // out
	var _bottom float64 // out
	var _left float64   // out
	var _right float64  // out
	var _ok bool        // out

	_top = (float64)(_arg1)
	_bottom = (float64)(_arg2)
	_left = (float64)(_arg3)
	_right = (float64)(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _top, _bottom, _left, _right, _ok
}

func (c printContext) Height() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.double           // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_height(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (c printContext) PageSetup() PageSetup {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.GtkPageSetup    // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_page_setup(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

func (c printContext) PangoFontmap() pango.FontMap {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.PangoFontMap    // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_pango_fontmap(_arg0)

	var _fontMap pango.FontMap // out

	_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontMap)

	return _fontMap
}

func (c printContext) Width() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.double           // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_width(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (c printContext) SetCairoContextPrintContext(cr *cairo.Context, dpiX float64, dpiY float64) {
	var _arg0 *C.GtkPrintContext // out
	var _arg1 *C.cairo_t         // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (C.double)(dpiX)
	_arg3 = (C.double)(dpiY)

	C.gtk_print_context_set_cairo_context(_arg0, _arg1, _arg2, _arg3)
}

// PrintJob: a `GtkPrintJob` object represents a job that is sent to a printer.
//
// You only need to deal directly with print jobs if you use the non-portable
// [class@Gtk.PrintUnixDialog] API.
//
// Use [method@Gtk.PrintJob.get_surface] to obtain the cairo surface onto which
// the pages must be drawn. Use [method@Gtk.PrintJob.send] to send the finished
// job to the printer. If you dont use cairo `GtkPrintJob` also supports
// printing of manually generated PostScript, via
// [method@Gtk.PrintJob.set_source_file].
type PrintJob interface {

	// Collate gets whether this job is printed collated.
	Collate() bool
	// NUp gets the n-up setting for this job.
	NUp() uint
	// NUpLayout gets the n-up layout setting for this job.
	NUpLayout() NumberUpLayout
	// NumCopies gets the number of copies of this job.
	NumCopies() int
	// PageSet gets the `GtkPageSet` setting for this job.
	PageSet() PageSet
	// Pages gets the `GtkPrintPages` setting for this job.
	Pages() PrintPages
	// Printer gets the `GtkPrinter` of the print job.
	Printer() Printer
	// Reverse gets whether this job is printed reversed.
	Reverse() bool
	// Rotate gets whether the job is printed rotated.
	Rotate() bool
	// Scale gets the scale for this job.
	Scale() float64
	// Settings gets the `GtkPrintSettings` of the print job.
	Settings() PrintSettings
	// Status gets the status of the print job.
	Status() PrintStatus
	// Surface gets a cairo surface onto which the pages of the print job should
	// be rendered.
	Surface() (*cairo.Surface, error)
	// Title gets the job title.
	Title() string
	// TrackPrintStatus returns whether jobs will be tracked after printing.
	//
	// For details, see [method@Gtk.PrintJob.set_track_print_status].
	TrackPrintStatus() bool
	// SetCollatePrintJob sets whether this job is printed collated.
	SetCollatePrintJob(collate bool)
	// SetNUpPrintJob sets the n-up setting for this job.
	SetNUpPrintJob(nUp uint)
	// SetNUpLayoutPrintJob sets the n-up layout setting for this job.
	SetNUpLayoutPrintJob(layout NumberUpLayout)
	// SetNumCopiesPrintJob sets the number of copies for this job.
	SetNumCopiesPrintJob(numCopies int)
	// SetPageRangesPrintJob sets the page ranges for this job.
	SetPageRangesPrintJob(ranges []PageRange)
	// SetPageSetPrintJob sets the `GtkPageSet` setting for this job.
	SetPageSetPrintJob(pageSet PageSet)
	// SetPagesPrintJob sets the `GtkPrintPages` setting for this job.
	SetPagesPrintJob(pages PrintPages)
	// SetReversePrintJob sets whether this job is printed reversed.
	SetReversePrintJob(reverse bool)
	// SetRotatePrintJob sets whether this job is printed rotated.
	SetRotatePrintJob(rotate bool)
	// SetScalePrintJob sets the scale for this job.
	//
	// 1.0 means unscaled.
	SetScalePrintJob(scale float64)
	// SetSourceFdPrintJob: make the `GtkPrintJob` send an existing document to
	// the printing system.
	//
	// The file can be in any format understood by the platforms printing system
	// (typically PostScript, but on many platforms PDF may work too). See
	// [method@Gtk.Printer.accepts_pdf] and [method@Gtk.Printer.accepts_ps].
	//
	// This is similar to [method@Gtk.PrintJob.set_source_file], but takes
	// expects an open file descriptor for the file, instead of a filename.
	SetSourceFdPrintJob(fd int) error
	// SetSourceFilePrintJob: make the `GtkPrintJob` send an existing document
	// to the printing system.
	//
	// The file can be in any format understood by the platforms printing system
	// (typically PostScript, but on many platforms PDF may work too). See
	// [method@Gtk.Printer.accepts_pdf] and [method@Gtk.Printer.accepts_ps].
	SetSourceFilePrintJob(filename string) error
	// SetTrackPrintStatusPrintJob: if track_status is true, the print job will
	// try to continue report on the status of the print job in the printer
	// queues and printer.
	//
	// This can allow your application to show things like out of paper
	// issues, and when the print job actually reaches the printer.
	//
	// This function is often implemented using some form of polling, so it
	// should not be enabled unless needed.
	SetTrackPrintStatusPrintJob(trackStatus bool)
}

// printJob implements the PrintJob class.
type printJob struct {
	gextras.Objector
}

// WrapPrintJob wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintJob(obj *externglib.Object) PrintJob {
	return printJob{
		Objector: obj,
	}
}

func marshalPrintJob(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintJob(obj), nil
}

// NewPrintJob creates a new `GtkPrintJob`.
func NewPrintJob(title string, printer Printer, settings PrintSettings, pageSetup PageSetup) PrintJob {
	var _arg1 *C.char             // out
	var _arg2 *C.GtkPrinter       // out
	var _arg3 *C.GtkPrintSettings // out
	var _arg4 *C.GtkPageSetup     // out
	var _cret *C.GtkPrintJob      // in

	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkPrinter)(unsafe.Pointer(printer.Native()))
	_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))
	_arg4 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))

	_cret = C.gtk_print_job_new(_arg1, _arg2, _arg3, _arg4)

	var _printJob PrintJob // out

	_printJob = WrapPrintJob(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printJob
}

func (j printJob) Collate() bool {
	var _arg0 *C.GtkPrintJob // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_collate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (j printJob) NUp() uint {
	var _arg0 *C.GtkPrintJob // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_n_up(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (j printJob) NUpLayout() NumberUpLayout {
	var _arg0 *C.GtkPrintJob      // out
	var _cret C.GtkNumberUpLayout // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_n_up_layout(_arg0)

	var _numberUpLayout NumberUpLayout // out

	_numberUpLayout = NumberUpLayout(_cret)

	return _numberUpLayout
}

func (j printJob) NumCopies() int {
	var _arg0 *C.GtkPrintJob // out
	var _cret C.int          // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_num_copies(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (j printJob) PageSet() PageSet {
	var _arg0 *C.GtkPrintJob // out
	var _cret C.GtkPageSet   // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_page_set(_arg0)

	var _pageSet PageSet // out

	_pageSet = PageSet(_cret)

	return _pageSet
}

func (j printJob) Pages() PrintPages {
	var _arg0 *C.GtkPrintJob  // out
	var _cret C.GtkPrintPages // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_pages(_arg0)

	var _printPages PrintPages // out

	_printPages = PrintPages(_cret)

	return _printPages
}

func (j printJob) Printer() Printer {
	var _arg0 *C.GtkPrintJob // out
	var _cret *C.GtkPrinter  // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_printer(_arg0)

	var _printer Printer // out

	_printer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Printer)

	return _printer
}

func (j printJob) Reverse() bool {
	var _arg0 *C.GtkPrintJob // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_reverse(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (j printJob) Rotate() bool {
	var _arg0 *C.GtkPrintJob // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_rotate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (j printJob) Scale() float64 {
	var _arg0 *C.GtkPrintJob // out
	var _cret C.double       // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_scale(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (j printJob) Settings() PrintSettings {
	var _arg0 *C.GtkPrintJob      // out
	var _cret *C.GtkPrintSettings // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_settings(_arg0)

	var _printSettings PrintSettings // out

	_printSettings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PrintSettings)

	return _printSettings
}

func (j printJob) Status() PrintStatus {
	var _arg0 *C.GtkPrintJob   // out
	var _cret C.GtkPrintStatus // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_status(_arg0)

	var _printStatus PrintStatus // out

	_printStatus = PrintStatus(_cret)

	return _printStatus
}

func (j printJob) Surface() (*cairo.Surface, error) {
	var _arg0 *C.GtkPrintJob     // out
	var _cret *C.cairo_surface_t // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_surface(_arg0, &_cerr)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = cairo.WrapSurface(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _surface, _goerr
}

func (j printJob) Title() string {
	var _arg0 *C.GtkPrintJob // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (j printJob) TrackPrintStatus() bool {
	var _arg0 *C.GtkPrintJob // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	_cret = C.gtk_print_job_get_track_print_status(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (j printJob) SetCollatePrintJob(collate bool) {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	if collate {
		_arg1 = C.TRUE
	}

	C.gtk_print_job_set_collate(_arg0, _arg1)
}

func (j printJob) SetNUpPrintJob(nUp uint) {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.guint)(nUp)

	C.gtk_print_job_set_n_up(_arg0, _arg1)
}

func (j printJob) SetNUpLayoutPrintJob(layout NumberUpLayout) {
	var _arg0 *C.GtkPrintJob      // out
	var _arg1 C.GtkNumberUpLayout // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.GtkNumberUpLayout)(layout)

	C.gtk_print_job_set_n_up_layout(_arg0, _arg1)
}

func (j printJob) SetNumCopiesPrintJob(numCopies int) {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.int)(numCopies)

	C.gtk_print_job_set_num_copies(_arg0, _arg1)
}

func (j printJob) SetPageRangesPrintJob(ranges []PageRange) {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 *C.GtkPageRange
	var _arg2 C.int

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg2 = C.int(len(ranges))
	_arg1 = (*C.GtkPageRange)(C.malloc(C.ulong(len(ranges)) * C.ulong(C.sizeof_GtkPageRange)))
	{
		out := unsafe.Slice(_arg1, len(ranges))
		for i := range ranges {
			out[i] = *(*C.GtkPageRange)(unsafe.Pointer(ranges[i].Native()))
		}
	}

	C.gtk_print_job_set_page_ranges(_arg0, _arg1, _arg2)
}

func (j printJob) SetPageSetPrintJob(pageSet PageSet) {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 C.GtkPageSet   // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_job_set_page_set(_arg0, _arg1)
}

func (j printJob) SetPagesPrintJob(pages PrintPages) {
	var _arg0 *C.GtkPrintJob  // out
	var _arg1 C.GtkPrintPages // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_job_set_pages(_arg0, _arg1)
}

func (j printJob) SetReversePrintJob(reverse bool) {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	if reverse {
		_arg1 = C.TRUE
	}

	C.gtk_print_job_set_reverse(_arg0, _arg1)
}

func (j printJob) SetRotatePrintJob(rotate bool) {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	if rotate {
		_arg1 = C.TRUE
	}

	C.gtk_print_job_set_rotate(_arg0, _arg1)
}

func (j printJob) SetScalePrintJob(scale float64) {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.double)(scale)

	C.gtk_print_job_set_scale(_arg0, _arg1)
}

func (j printJob) SetSourceFdPrintJob(fd int) error {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 C.int          // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.int)(fd)

	C.gtk_print_job_set_source_fd(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (j printJob) SetSourceFilePrintJob(filename string) error {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 *C.char        // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_job_set_source_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (j printJob) SetTrackPrintStatusPrintJob(trackStatus bool) {
	var _arg0 *C.GtkPrintJob // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	if trackStatus {
		_arg1 = C.TRUE
	}

	C.gtk_print_job_set_track_print_status(_arg0, _arg1)
}

// PrintOperation: `GtkPrintOperation` is the high-level, portable printing API.
//
// It looks a bit different than other GTK dialogs such as the `GtkFileChooser`,
// since some platforms dont expose enough infrastructure to implement a good
// print dialog. On such platforms, `GtkPrintOperation` uses the native print
// dialog. On platforms which do not provide a native print dialog, GTK uses its
// own, see [class@Gtk.PrintUnixDialog].
//
// The typical way to use the high-level printing API is to create a
// `GtkPrintOperation` object with [ctor@Gtk.PrintOperation.new] when the user
// selects to print. Then you set some properties on it, e.g. the page size, any
// [class@Gtk.PrintSettings] from previous print operations, the number of
// pages, the current page, etc.
//
// Then you start the print operation by calling
// [method@Gtk.PrintOperation.run]. It will then show a dialog, let the user
// select a printer and options. When the user finished the dialog, various
// signals will be emitted on the `GtkPrintOperation`, the main one being
// [signal@Gtk.PrintOperation::draw-page], which you are supposed to handle and
// render the page on the provided [class@Gtk.PrintContext] using Cairo.
//
//
// The high-level printing API
//
// `c static GtkPrintSettings *settings = NULL;
//
// static void do_print (void) { GtkPrintOperation *print;
// GtkPrintOperationResult res;
//
//    print = gtk_print_operation_new ();
//
//    if (settings != NULL)
//      gtk_print_operation_set_print_settings (print, settings);
//
//    g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//    g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//    res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                   GTK_WINDOW (main_window), NULL);
//
//    if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//      {
//        if (settings != NULL)
//          g_object_unref (settings);
//        settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//      }
//
//    g_object_unref (print);
//
// } `
//
// By default `GtkPrintOperation` uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions
// [method@Gtk.PrintOperationPreview.render_page],
// [method@Gtk.PrintOperationPreview.end_preview] and
// [method@Gtk.PrintOperationPreview.is_selected] are useful when implementing a
// print preview.
type PrintOperation interface {
	PrintOperationPreview

	// CancelPrintOperation cancels a running print operation.
	//
	// This function may be called from a
	// [signal@Gtk.PrintOperation::begin-print],
	// [signal@Gtk.PrintOperation::paginate] or
	// [signal@Gtk.PrintOperation::draw-page] signal handler to stop the
	// currently running print operation.
	CancelPrintOperation()
	// DrawPageFinishPrintOperation: signal that drawing of particular page is
	// complete.
	//
	// It is called after completion of page drawing (e.g. drawing in another
	// thread). If [method@Gtk.PrintOperation.set_defer_drawing] was called
	// before, then this function has to be called by application. Otherwise it
	// is called by GTK itself.
	DrawPageFinishPrintOperation()
	// DefaultPageSetup returns the default page setup.
	DefaultPageSetup() PageSetup
	// EmbedPageSetup gets whether page setup selection combos are embedded
	EmbedPageSetup() bool
	// Error: call this when the result of a print operation is
	// GTK_PRINT_OPERATION_RESULT_ERROR.
	//
	// It can be called either after [method@Gtk.PrintOperation.run] returns, or
	// in the [signal@Gtk.PrintOperation::done] signal handler.
	//
	// The returned `GError` will contain more details on what went wrong.
	Error() error
	// HasSelection gets whether there is a selection.
	HasSelection() bool
	// NPagesToPrint returns the number of pages that will be printed.
	//
	// Note that this value is set during print preparation phase
	// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
	// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You
	// can connect to the [signal@Gtk.PrintOperation::status-changed] signal and
	// call gtk_print_operation_get_n_pages_to_print() when print status is
	// GTK_PRINT_STATUS_GENERATING_DATA.
	//
	// This is typically used to track the progress of print operation.
	NPagesToPrint() int
	// PrintSettings returns the current print settings.
	//
	// Note that the return value is nil until either
	// [method@Gtk.PrintOperation.set_print_settings] or
	// [method@Gtk.PrintOperation.run] have been called.
	PrintSettings() PrintSettings
	// Status returns the status of the print operation.
	//
	// Also see [method@Gtk.PrintOperation.get_status_string].
	Status() PrintStatus
	// StatusString returns a string representation of the status of the print
	// operation.
	//
	// The string is translated and suitable for displaying the print status
	// e.g. in a `GtkStatusbar`.
	//
	// Use [method@Gtk.PrintOperation.get_status] to obtain a status value that
	// is suitable for programmatic use.
	StatusString() string
	// SupportSelection gets whether the application supports print of selection
	SupportSelection() bool
	// IsFinishedPrintOperation: a convenience function to find out if the print
	// operation is finished.
	//
	// a print operation is finished if its status is either
	// GTK_PRINT_STATUS_FINISHED or GTK_PRINT_STATUS_FINISHED_ABORTED.
	//
	// Note: when you enable print status tracking the print operation can be in
	// a non-finished state even after done has been called, as the operation
	// status then tracks the print job status on the printer.
	IsFinishedPrintOperation() bool
	// RunPrintOperation runs the print operation.
	//
	// Normally that this function does not return until the rendering of all
	// pages is complete. You can connect to the
	// [signal@Gtk.PrintOperation::status-changed] signal on @op to obtain some
	// information about the progress of the print operation.
	//
	// Furthermore, it may use a recursive mainloop to show the print dialog.
	//
	// If you set the [Gtk.PrintOperation:allow-async] property, the operation
	// will run asynchronously if this is supported on the platform. The
	// [signal@Gtk.PrintOperation::done] signal will be emitted with the result
	// of the operation when the it is done (i.e. when the dialog is canceled,
	// or when the print succeeds or fails).
	//
	// `c if (settings != NULL) gtk_print_operation_set_print_settings (print,
	// settings);
	//
	// if (page_setup != NULL) gtk_print_operation_set_default_page_setup
	// (print, page_setup);
	//
	// g_signal_connect (print, "begin-print", G_CALLBACK (begin_print), &data);
	// g_signal_connect (print, "draw-page", G_CALLBACK (draw_page), &data);
	//
	// res = gtk_print_operation_run (print,
	// GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG, parent, &error);
	//
	// if (res == GTK_PRINT_OPERATION_RESULT_ERROR) { error_dialog =
	// gtk_message_dialog_new (GTK_WINDOW (parent),
	// GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE,
	// "Error printing file:\ns", error->message); g_signal_connect
	// (error_dialog, "response", G_CALLBACK (gtk_window_destroy), NULL);
	// gtk_widget_show (error_dialog); g_error_free (error); } else if (res ==
	// GTK_PRINT_OPERATION_RESULT_APPLY) { if (settings != NULL) g_object_unref
	// (settings); settings = g_object_ref
	// (gtk_print_operation_get_print_settings (print)); } `
	//
	// Note that gtk_print_operation_run() can only be called once on a given
	// `GtkPrintOperation`.
	RunPrintOperation(action PrintOperationAction, parent Window) (PrintOperationResult, error)
	// SetAllowAsyncPrintOperation sets whether gtk_print_operation_run() may
	// return before the print operation is completed.
	//
	// Note that some platforms may not allow asynchronous operation.
	SetAllowAsyncPrintOperation(allowAsync bool)
	// SetCurrentPagePrintOperation sets the current page.
	//
	// If this is called before [method@Gtk.PrintOperation.run], the user will
	// be able to select to print only the current page.
	//
	// Note that this only makes sense for pre-paginated documents.
	SetCurrentPagePrintOperation(currentPage int)
	// SetCustomTabLabelPrintOperation sets the label for the tab holding custom
	// widgets.
	SetCustomTabLabelPrintOperation(label string)
	// SetDefaultPageSetupPrintOperation makes @default_page_setup the default
	// page setup for @op.
	//
	// This page setup will be used by [method@Gtk.PrintOperation.run], but it
	// can be overridden on a per-page basis by connecting to the
	// [signal@Gtk.PrintOperation::request-page-setup] signal.
	SetDefaultPageSetupPrintOperation(defaultPageSetup PageSetup)
	// SetDeferDrawingPrintOperation sets up the `GtkPrintOperation` to wait for
	// calling of [method@Gtk.PrintOperation.draw_page_finish from application.
	//
	// This can be used for drawing page in another thread.
	//
	// This function must be called in the callback of the
	// [signal@Gtk.PrintOperation::draw-page] signal.
	SetDeferDrawingPrintOperation()
	// SetEmbedPageSetupPrintOperation: embed page size combo box and
	// orientation combo box into page setup page.
	//
	// Selected page setup is stored as default page setup in
	// `GtkPrintOperation`.
	SetEmbedPageSetupPrintOperation(embed bool)
	// SetExportFilenamePrintOperation sets up the `GtkPrintOperation` to
	// generate a file instead of showing the print dialog.
	//
	// The intended use of this function is for implementing Export to PDF
	// actions. Currently, PDF is the only supported format.
	//
	// Print to PDF support is independent of this and is done by letting the
	// user pick the Print to PDF item from the list of printers in the print
	// dialog.
	SetExportFilenamePrintOperation(filename string)
	// SetHasSelectionPrintOperation sets whether there is a selection to print.
	//
	// Application has to set number of pages to which the selection will draw
	// by [method@Gtk.PrintOperation.set_n_pages] in a handler for the
	// [signal@Gtk.PrintOperation::begin-print] signal.
	SetHasSelectionPrintOperation(hasSelection bool)
	// SetJobNamePrintOperation sets the name of the print job.
	//
	// The name is used to identify the job (e.g. in monitoring applications
	// like eggcups).
	//
	// If you dont set a job name, GTK picks a default one by numbering
	// successive print jobs.
	SetJobNamePrintOperation(jobName string)
	// SetNPagesPrintOperation sets the number of pages in the document.
	//
	// This must be set to a positive number before the rendering starts. It may
	// be set in a [signal@Gtk.PrintOperation::begin-print] signal handler.
	//
	// Note that the page numbers passed to the
	// [signal@Gtk.PrintOperation::request-page-setup] and
	// [signal@Gtk.PrintOperation::draw-page] signals are 0-based, i.e. if the
	// user chooses to print all pages, the last ::draw-page signal will be for
	// page @n_pages - 1.
	SetNPagesPrintOperation(nPages int)
	// SetPrintSettingsPrintOperation sets the print settings for @op.
	//
	// This is typically used to re-establish print settings from a previous
	// print operation, see [method@Gtk.PrintOperation.run].
	SetPrintSettingsPrintOperation(printSettings PrintSettings)
	// SetShowProgressPrintOperation: if @show_progress is true, the print
	// operation will show a progress dialog during the print operation.
	SetShowProgressPrintOperation(showProgress bool)
	// SetSupportSelectionPrintOperation sets whether selection is supported by
	// `GtkPrintOperation`.
	SetSupportSelectionPrintOperation(supportSelection bool)
	// SetTrackPrintStatusPrintOperation: if track_status is true, the print
	// operation will try to continue report on the status of the print job in
	// the printer queues and printer.
	//
	// This can allow your application to show things like out of paper
	// issues, and when the print job actually reaches the printer.
	//
	// This function is often implemented using some form of polling, so it
	// should not be enabled unless needed.
	SetTrackPrintStatusPrintOperation(trackStatus bool)
	// SetUnitPrintOperation sets up the transformation for the cairo context
	// obtained from `GtkPrintContext` in such a way that distances are measured
	// in units of @unit.
	SetUnitPrintOperation(unit Unit)
	// SetUseFullPagePrintOperation: if @full_page is true, the transformation
	// for the cairo context obtained from `GtkPrintContext` puts the origin at
	// the top left corner of the page.
	//
	// This may not be the top left corner of the sheet, depending on page
	// orientation and the number of pages per sheet). Otherwise, the origin is
	// at the top left corner of the imageable area (i.e. inside the margins).
	SetUseFullPagePrintOperation(fullPage bool)
}

// printOperation implements the PrintOperation class.
type printOperation struct {
	gextras.Objector
}

// WrapPrintOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintOperation(obj *externglib.Object) PrintOperation {
	return printOperation{
		Objector: obj,
	}
}

func marshalPrintOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintOperation(obj), nil
}

// NewPrintOperation creates a new `GtkPrintOperation`.
func NewPrintOperation() PrintOperation {
	var _cret *C.GtkPrintOperation // in

	_cret = C.gtk_print_operation_new()

	var _printOperation PrintOperation // out

	_printOperation = WrapPrintOperation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printOperation
}

func (o printOperation) CancelPrintOperation() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_cancel(_arg0)
}

func (o printOperation) DrawPageFinishPrintOperation() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_draw_page_finish(_arg0)
}

func (o printOperation) DefaultPageSetup() PageSetup {
	var _arg0 *C.GtkPrintOperation // out
	var _cret *C.GtkPageSetup      // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_default_page_setup(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

func (o printOperation) EmbedPageSetup() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_embed_page_setup(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o printOperation) Error() error {
	var _arg0 *C.GtkPrintOperation // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_get_error(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (o printOperation) HasSelection() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_has_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o printOperation) NPagesToPrint() int {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.int                // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_n_pages_to_print(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (o printOperation) PrintSettings() PrintSettings {
	var _arg0 *C.GtkPrintOperation // out
	var _cret *C.GtkPrintSettings  // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_print_settings(_arg0)

	var _printSettings PrintSettings // out

	_printSettings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PrintSettings)

	return _printSettings
}

func (o printOperation) Status() PrintStatus {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.GtkPrintStatus     // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_status(_arg0)

	var _printStatus PrintStatus // out

	_printStatus = PrintStatus(_cret)

	return _printStatus
}

func (o printOperation) StatusString() string {
	var _arg0 *C.GtkPrintOperation // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_status_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (o printOperation) SupportSelection() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_support_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o printOperation) IsFinishedPrintOperation() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_is_finished(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o printOperation) RunPrintOperation(action PrintOperationAction, parent Window) (PrintOperationResult, error) {
	var _arg0 *C.GtkPrintOperation      // out
	var _arg1 C.GtkPrintOperationAction // out
	var _arg2 *C.GtkWindow              // out
	var _cret C.GtkPrintOperationResult // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GtkPrintOperationAction)(action)
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_print_operation_run(_arg0, _arg1, _arg2, &_cerr)

	var _printOperationResult PrintOperationResult // out
	var _goerr error                               // out

	_printOperationResult = PrintOperationResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _printOperationResult, _goerr
}

func (o printOperation) SetAllowAsyncPrintOperation(allowAsync bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if allowAsync {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_allow_async(_arg0, _arg1)
}

func (o printOperation) SetCurrentPagePrintOperation(currentPage int) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.int)(currentPage)

	C.gtk_print_operation_set_current_page(_arg0, _arg1)
}

func (o printOperation) SetCustomTabLabelPrintOperation(label string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_custom_tab_label(_arg0, _arg1)
}

func (o printOperation) SetDefaultPageSetupPrintOperation(defaultPageSetup PageSetup) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPageSetup      // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(defaultPageSetup.Native()))

	C.gtk_print_operation_set_default_page_setup(_arg0, _arg1)
}

func (o printOperation) SetDeferDrawingPrintOperation() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_set_defer_drawing(_arg0)
}

func (o printOperation) SetEmbedPageSetupPrintOperation(embed bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if embed {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_embed_page_setup(_arg0, _arg1)
}

func (o printOperation) SetExportFilenamePrintOperation(filename string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_export_filename(_arg0, _arg1)
}

func (o printOperation) SetHasSelectionPrintOperation(hasSelection bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if hasSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_has_selection(_arg0, _arg1)
}

func (o printOperation) SetJobNamePrintOperation(jobName string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(jobName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_job_name(_arg0, _arg1)
}

func (o printOperation) SetNPagesPrintOperation(nPages int) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.int)(nPages)

	C.gtk_print_operation_set_n_pages(_arg0, _arg1)
}

func (o printOperation) SetPrintSettingsPrintOperation(printSettings PrintSettings) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPrintSettings  // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(printSettings.Native()))

	C.gtk_print_operation_set_print_settings(_arg0, _arg1)
}

func (o printOperation) SetShowProgressPrintOperation(showProgress bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if showProgress {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_show_progress(_arg0, _arg1)
}

func (o printOperation) SetSupportSelectionPrintOperation(supportSelection bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if supportSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_support_selection(_arg0, _arg1)
}

func (o printOperation) SetTrackPrintStatusPrintOperation(trackStatus bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if trackStatus {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_track_print_status(_arg0, _arg1)
}

func (o printOperation) SetUnitPrintOperation(unit Unit) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.GtkUnit            // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GtkUnit)(unit)

	C.gtk_print_operation_set_unit(_arg0, _arg1)
}

func (o printOperation) SetUseFullPagePrintOperation(fullPage bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if fullPage {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_use_full_page(_arg0, _arg1)
}

func (p printOperation) EndPreview() {
	WrapPrintOperationPreview(gextras.InternObject(p)).EndPreview()
}

func (p printOperation) IsSelected(pageNr int) bool {
	return WrapPrintOperationPreview(gextras.InternObject(p)).IsSelected(pageNr)
}

func (p printOperation) RenderPage(pageNr int) {
	WrapPrintOperationPreview(gextras.InternObject(p)).RenderPage(pageNr)
}

// PrintSettings: a `GtkPrintSettings` object represents the settings of a print
// dialog in a system-independent way.
//
// The main use for this object is that once youve printed you can get a
// settings object that represents the settings the user chose, and the next
// time you print you can pass that object in so that the user doesnt have to
// re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
type PrintSettings interface {

	// CopyPrintSettings copies a `GtkPrintSettings` object.
	CopyPrintSettings() PrintSettings
	// GetPrintSettings looks up the string value associated with @key.
	GetPrintSettings(key string) string
	// Bool returns the boolean represented by the value that is associated with
	// @key.
	//
	// The string true represents true, any other string false.
	Bool(key string) bool
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	Collate() bool
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	DefaultSource() string
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	Dither() string
	// Double returns the double value associated with @key, or 0.
	Double(key string) float64
	// DoubleWithDefault returns the floating point number represented by the
	// value that is associated with @key, or @default_val if the value does not
	// represent a floating point number.
	//
	// Floating point numbers are parsed with g_ascii_strtod().
	DoubleWithDefault(key string, def float64) float64
	// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	Duplex() PrintDuplex
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	Finishings() string
	// Int returns the integer value of @key, or 0.
	Int(key string) int
	// IntWithDefault returns the value of @key, interpreted as an integer, or
	// the default value.
	IntWithDefault(key string, def int) int
	// Length returns the value associated with @key, interpreted as a length.
	//
	// The returned value is converted to @units.
	Length(key string, unit Unit) float64
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	MediaType() string
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	NCopies() int
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	NumberUp() int
	// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	NumberUpLayout() NumberUpLayout
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
	// to a `GtkPageOrientation`.
	Orientation() PageOrientation
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	OutputBin() string
	// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	PageSet() PageSet
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
	// to @unit.
	PaperHeight(unit Unit) float64
	// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
	// a `GtkPaperSize`.
	PaperSize() *PaperSize
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
	// @unit.
	PaperWidth(unit Unit) float64
	// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	PrintPages() PrintPages
	// Printer: convenience function to obtain the value of
	// GTK_PRINT_SETTINGS_PRINTER.
	Printer() string
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	PrinterLpi() float64
	// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
	Quality() PrintQuality
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	Resolution() int
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	ResolutionX() int
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	ResolutionY() int
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	Reverse() bool
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	Scale() float64
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	UseColor() bool
	// HasKeyPrintSettings returns true, if a value is associated with @key.
	HasKeyPrintSettings(key string) bool
	// LoadFilePrintSettings reads the print settings from @file_name.
	//
	// If the file could not be loaded then error is set to either a
	// `GFileError` or `GKeyFileError`.
	//
	// See [method@Gtk.PrintSettings.to_file].
	LoadFilePrintSettings(fileName string) error
	// LoadKeyFilePrintSettings reads the print settings from the group
	// @group_name in @key_file.
	//
	// If the file could not be loaded then error is set to either a
	// `GFileError` or `GKeyFileError`.
	LoadKeyFilePrintSettings(keyFile *glib.KeyFile, groupName string) error
	// SetPrintSettings associates @value with @key.
	SetPrintSettings(key string, value string)
	// SetBoolPrintSettings sets @key to a boolean value.
	SetBoolPrintSettings(key string, value bool)
	// SetCollatePrintSettings sets the value of GTK_PRINT_SETTINGS_COLLATE.
	SetCollatePrintSettings(collate bool)
	// SetDefaultSourcePrintSettings sets the value of
	// GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	SetDefaultSourcePrintSettings(defaultSource string)
	// SetDitherPrintSettings sets the value of GTK_PRINT_SETTINGS_DITHER.
	SetDitherPrintSettings(dither string)
	// SetDoublePrintSettings sets @key to a double value.
	SetDoublePrintSettings(key string, value float64)
	// SetDuplexPrintSettings sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	SetDuplexPrintSettings(duplex PrintDuplex)
	// SetFinishingsPrintSettings sets the value of
	// GTK_PRINT_SETTINGS_FINISHINGS.
	SetFinishingsPrintSettings(finishings string)
	// SetIntPrintSettings sets @key to an integer value.
	SetIntPrintSettings(key string, value int)
	// SetLengthPrintSettings associates a length in units of @unit with @key.
	SetLengthPrintSettings(key string, value float64, unit Unit)
	// SetMediaTypePrintSettings sets the value of
	// GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	SetMediaTypePrintSettings(mediaType string)
	// SetNCopiesPrintSettings sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	SetNCopiesPrintSettings(numCopies int)
	// SetNumberUpPrintSettings sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	SetNumberUpPrintSettings(numberUp int)
	// SetNumberUpLayoutPrintSettings sets the value of
	// GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	SetNumberUpLayoutPrintSettings(numberUpLayout NumberUpLayout)
	// SetOrientationPrintSettings sets the value of
	// GTK_PRINT_SETTINGS_ORIENTATION.
	SetOrientationPrintSettings(orientation PageOrientation)
	// SetOutputBinPrintSettings sets the value of
	// GTK_PRINT_SETTINGS_OUTPUT_BIN.
	SetOutputBinPrintSettings(outputBin string)
	// SetPageRangesPrintSettings sets the value of
	// GTK_PRINT_SETTINGS_PAGE_RANGES.
	SetPageRangesPrintSettings(pageRanges []PageRange)
	// SetPageSetPrintSettings sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	SetPageSetPrintSettings(pageSet PageSet)
	// SetPaperHeightPrintSettings sets the value of
	// GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperHeightPrintSettings(height float64, unit Unit)
	// SetPaperSizePrintSettings sets the value of
	// GTK_PRINT_SETTINGS_PAPER_FORMAT, GTK_PRINT_SETTINGS_PAPER_WIDTH and
	// GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperSizePrintSettings(paperSize *PaperSize)
	// SetPaperWidthPrintSettings sets the value of
	// GTK_PRINT_SETTINGS_PAPER_WIDTH.
	SetPaperWidthPrintSettings(width float64, unit Unit)
	// SetPrintPagesPrintSettings sets the value of
	// GTK_PRINT_SETTINGS_PRINT_PAGES.
	SetPrintPagesPrintSettings(pages PrintPages)
	// SetPrinterPrintSettings: convenience function to set
	// GTK_PRINT_SETTINGS_PRINTER to @printer.
	SetPrinterPrintSettings(printer string)
	// SetPrinterLpiPrintSettings sets the value of
	// GTK_PRINT_SETTINGS_PRINTER_LPI.
	SetPrinterLpiPrintSettings(lpi float64)
	// SetQualityPrintSettings sets the value of GTK_PRINT_SETTINGS_QUALITY.
	SetQualityPrintSettings(quality PrintQuality)
	// SetResolutionPrintSettings sets the values of
	// GTK_PRINT_SETTINGS_RESOLUTION, GTK_PRINT_SETTINGS_RESOLUTION_X and
	// GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionPrintSettings(resolution int)
	// SetResolutionXYPrintSettings sets the values of
	// GTK_PRINT_SETTINGS_RESOLUTION, GTK_PRINT_SETTINGS_RESOLUTION_X and
	// GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionXYPrintSettings(resolutionX int, resolutionY int)
	// SetReversePrintSettings sets the value of GTK_PRINT_SETTINGS_REVERSE.
	SetReversePrintSettings(reverse bool)
	// SetScalePrintSettings sets the value of GTK_PRINT_SETTINGS_SCALE.
	SetScalePrintSettings(scale float64)
	// SetUseColorPrintSettings sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	SetUseColorPrintSettings(useColor bool)
	// ToFilePrintSettings: this function saves the print settings from
	// @settings to @file_name.
	//
	// If the file could not be written then error is set to either a
	// `GFileError` or `GKeyFileError`.
	ToFilePrintSettings(fileName string) error
	// ToGVariantPrintSettings: serialize print settings to an a{sv} variant.
	ToGVariantPrintSettings() *glib.Variant
	// ToKeyFilePrintSettings: this function adds the print settings from
	// @settings to @key_file.
	ToKeyFilePrintSettings(keyFile *glib.KeyFile, groupName string)
	// UnsetPrintSettings removes any value associated with @key.
	//
	// This has the same effect as setting the value to nil.
	UnsetPrintSettings(key string)
}

// printSettings implements the PrintSettings class.
type printSettings struct {
	gextras.Objector
}

// WrapPrintSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintSettings(obj *externglib.Object) PrintSettings {
	return printSettings{
		Objector: obj,
	}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintSettings(obj), nil
}

// NewPrintSettings creates a new `GtkPrintSettings` object.
func NewPrintSettings() PrintSettings {
	var _cret *C.GtkPrintSettings // in

	_cret = C.gtk_print_settings_new()

	var _printSettings PrintSettings // out

	_printSettings = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printSettings
}

// NewPrintSettingsFromFile reads the print settings from @file_name.
//
// Returns a new `GtkPrintSettings` object with the restored settings, or nil if
// an error occurred. If the file could not be loaded then error is set to
// either a `GFileError` or `GKeyFileError`.
//
// See [method@Gtk.PrintSettings.to_file].
func NewPrintSettingsFromFile(fileName string) (PrintSettings, error) {
	var _arg1 *C.char             // out
	var _cret *C.GtkPrintSettings // in
	var _cerr *C.GError           // in

	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_new_from_file(_arg1, &_cerr)

	var _printSettings PrintSettings // out
	var _goerr error                 // out

	_printSettings = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _printSettings, _goerr
}

// NewPrintSettingsFromGVariant: deserialize print settings from an a{sv}
// variant.
//
// The variant must be in the format produced by
// [method@Gtk.PrintSettings.to_gvariant].
func NewPrintSettingsFromGVariant(variant *glib.Variant) PrintSettings {
	var _arg1 *C.GVariant         // out
	var _cret *C.GtkPrintSettings // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	_cret = C.gtk_print_settings_new_from_gvariant(_arg1)

	var _printSettings PrintSettings // out

	_printSettings = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printSettings
}

// NewPrintSettingsFromKeyFile reads the print settings from the group
// @group_name in @key_file.
//
// Returns a new `GtkPrintSettings` object with the restored settings, or nil if
// an error occurred. If the file could not be loaded then error is set to
// either `GFileError` or `GKeyFileError`.
func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) (PrintSettings, error) {
	var _arg1 *C.GKeyFile         // out
	var _arg2 *C.char             // out
	var _cret *C.GtkPrintSettings // in
	var _cerr *C.GError           // in

	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_print_settings_new_from_key_file(_arg1, _arg2, &_cerr)

	var _printSettings PrintSettings // out
	var _goerr error                 // out

	_printSettings = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _printSettings, _goerr
}

func (o printSettings) CopyPrintSettings() PrintSettings {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GtkPrintSettings // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_settings_copy(_arg0)

	var _printSettings PrintSettings // out

	_printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PrintSettings)

	return _printSettings
}

func (s printSettings) GetPrintSettings(key string) string {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s printSettings) Bool(key string) bool {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get_bool(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s printSettings) Collate() bool {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_collate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s printSettings) DefaultSource() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_default_source(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s printSettings) Dither() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_dither(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s printSettings) Double(key string) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get_double(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s printSettings) DoubleWithDefault(key string, def float64) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.double            // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.double)(def)

	_cret = C.gtk_print_settings_get_double_with_default(_arg0, _arg1, _arg2)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s printSettings) Duplex() PrintDuplex {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPrintDuplex    // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_duplex(_arg0)

	var _printDuplex PrintDuplex // out

	_printDuplex = PrintDuplex(_cret)

	return _printDuplex
}

func (s printSettings) Finishings() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_finishings(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s printSettings) Int(key string) int {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get_int(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s printSettings) IntWithDefault(key string, def int) int {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.int               // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(def)

	_cret = C.gtk_print_settings_get_int_with_default(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s printSettings) Length(key string, unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.GtkUnit           // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkUnit)(unit)

	_cret = C.gtk_print_settings_get_length(_arg0, _arg1, _arg2)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s printSettings) MediaType() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_media_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s printSettings) NCopies() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_n_copies(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s printSettings) NumberUp() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_number_up(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s printSettings) NumberUpLayout() NumberUpLayout {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkNumberUpLayout // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_number_up_layout(_arg0)

	var _numberUpLayout NumberUpLayout // out

	_numberUpLayout = NumberUpLayout(_cret)

	return _numberUpLayout
}

func (s printSettings) Orientation() PageOrientation {
	var _arg0 *C.GtkPrintSettings  // out
	var _cret C.GtkPageOrientation // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_orientation(_arg0)

	var _pageOrientation PageOrientation // out

	_pageOrientation = PageOrientation(_cret)

	return _pageOrientation
}

func (s printSettings) OutputBin() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_output_bin(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s printSettings) PageSet() PageSet {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPageSet        // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_page_set(_arg0)

	var _pageSet PageSet // out

	_pageSet = PageSet(_cret)

	return _pageSet
}

func (s printSettings) PaperHeight(unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkUnit           // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_print_settings_get_paper_height(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s printSettings) PaperSize() *PaperSize {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GtkPaperSize     // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_paper_size(_arg0)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

func (s printSettings) PaperWidth(unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkUnit           // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_print_settings_get_paper_width(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s printSettings) PrintPages() PrintPages {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPrintPages     // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_print_pages(_arg0)

	var _printPages PrintPages // out

	_printPages = PrintPages(_cret)

	return _printPages
}

func (s printSettings) Printer() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_printer(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s printSettings) PrinterLpi() float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_printer_lpi(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s printSettings) Quality() PrintQuality {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPrintQuality   // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_quality(_arg0)

	var _printQuality PrintQuality // out

	_printQuality = PrintQuality(_cret)

	return _printQuality
}

func (s printSettings) Resolution() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_resolution(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s printSettings) ResolutionX() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_resolution_x(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s printSettings) ResolutionY() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_resolution_y(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s printSettings) Reverse() bool {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_reverse(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s printSettings) Scale() float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_scale(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s printSettings) UseColor() bool {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_use_color(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s printSettings) HasKeyPrintSettings(key string) bool {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_has_key(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s printSettings) LoadFilePrintSettings(fileName string) error {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_load_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s printSettings) LoadKeyFilePrintSettings(keyFile *glib.KeyFile, groupName string) error {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GKeyFile         // out
	var _arg2 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_print_settings_load_key_file(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s printSettings) SetPrintSettings(key string, value string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_print_settings_set(_arg0, _arg1, _arg2)
}

func (s printSettings) SetBoolPrintSettings(key string, value bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	if value {
		_arg2 = C.TRUE
	}

	C.gtk_print_settings_set_bool(_arg0, _arg1, _arg2)
}

func (s printSettings) SetCollatePrintSettings(collate bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if collate {
		_arg1 = C.TRUE
	}

	C.gtk_print_settings_set_collate(_arg0, _arg1)
}

func (s printSettings) SetDefaultSourcePrintSettings(defaultSource string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(defaultSource))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_default_source(_arg0, _arg1)
}

func (s printSettings) SetDitherPrintSettings(dither string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(dither))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_dither(_arg0, _arg1)
}

func (s printSettings) SetDoublePrintSettings(key string, value float64) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.double            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.double)(value)

	C.gtk_print_settings_set_double(_arg0, _arg1, _arg2)
}

func (s printSettings) SetDuplexPrintSettings(duplex PrintDuplex) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPrintDuplex    // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPrintDuplex)(duplex)

	C.gtk_print_settings_set_duplex(_arg0, _arg1)
}

func (s printSettings) SetFinishingsPrintSettings(finishings string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(finishings))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_finishings(_arg0, _arg1)
}

func (s printSettings) SetIntPrintSettings(key string, value int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(value)

	C.gtk_print_settings_set_int(_arg0, _arg1, _arg2)
}

func (s printSettings) SetLengthPrintSettings(key string, value float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.double            // out
	var _arg3 C.GtkUnit           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.double)(value)
	_arg3 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_length(_arg0, _arg1, _arg2, _arg3)
}

func (s printSettings) SetMediaTypePrintSettings(mediaType string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(mediaType))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_media_type(_arg0, _arg1)
}

func (s printSettings) SetNCopiesPrintSettings(numCopies int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(numCopies)

	C.gtk_print_settings_set_n_copies(_arg0, _arg1)
}

func (s printSettings) SetNumberUpPrintSettings(numberUp int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(numberUp)

	C.gtk_print_settings_set_number_up(_arg0, _arg1)
}

func (s printSettings) SetNumberUpLayoutPrintSettings(numberUpLayout NumberUpLayout) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkNumberUpLayout // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

	C.gtk_print_settings_set_number_up_layout(_arg0, _arg1)
}

func (s printSettings) SetOrientationPrintSettings(orientation PageOrientation) {
	var _arg0 *C.GtkPrintSettings  // out
	var _arg1 C.GtkPageOrientation // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_print_settings_set_orientation(_arg0, _arg1)
}

func (s printSettings) SetOutputBinPrintSettings(outputBin string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(outputBin))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_output_bin(_arg0, _arg1)
}

func (s printSettings) SetPageRangesPrintSettings(pageRanges []PageRange) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GtkPageRange
	var _arg2 C.int

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg2 = C.int(len(pageRanges))
	_arg1 = (*C.GtkPageRange)(unsafe.Pointer(&pageRanges[0]))

	C.gtk_print_settings_set_page_ranges(_arg0, _arg1, _arg2)
}

func (s printSettings) SetPageSetPrintSettings(pageSet PageSet) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPageSet        // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_settings_set_page_set(_arg0, _arg1)
}

func (s printSettings) SetPaperHeightPrintSettings(height float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.double            // out
	var _arg2 C.GtkUnit           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(height)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_height(_arg0, _arg1, _arg2)
}

func (s printSettings) SetPaperSizePrintSettings(paperSize *PaperSize) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GtkPaperSize     // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

	C.gtk_print_settings_set_paper_size(_arg0, _arg1)
}

func (s printSettings) SetPaperWidthPrintSettings(width float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.double            // out
	var _arg2 C.GtkUnit           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(width)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_width(_arg0, _arg1, _arg2)
}

func (s printSettings) SetPrintPagesPrintSettings(pages PrintPages) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPrintPages     // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_settings_set_print_pages(_arg0, _arg1)
}

func (s printSettings) SetPrinterPrintSettings(printer string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(printer))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_printer(_arg0, _arg1)
}

func (s printSettings) SetPrinterLpiPrintSettings(lpi float64) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.double            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(lpi)

	C.gtk_print_settings_set_printer_lpi(_arg0, _arg1)
}

func (s printSettings) SetQualityPrintSettings(quality PrintQuality) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPrintQuality   // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPrintQuality)(quality)

	C.gtk_print_settings_set_quality(_arg0, _arg1)
}

func (s printSettings) SetResolutionPrintSettings(resolution int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(resolution)

	C.gtk_print_settings_set_resolution(_arg0, _arg1)
}

func (s printSettings) SetResolutionXYPrintSettings(resolutionX int, resolutionY int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.int               // out
	var _arg2 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(resolutionX)
	_arg2 = (C.int)(resolutionY)

	C.gtk_print_settings_set_resolution_xy(_arg0, _arg1, _arg2)
}

func (s printSettings) SetReversePrintSettings(reverse bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if reverse {
		_arg1 = C.TRUE
	}

	C.gtk_print_settings_set_reverse(_arg0, _arg1)
}

func (s printSettings) SetScalePrintSettings(scale float64) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.double            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(scale)

	C.gtk_print_settings_set_scale(_arg0, _arg1)
}

func (s printSettings) SetUseColorPrintSettings(useColor bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if useColor {
		_arg1 = C.TRUE
	}

	C.gtk_print_settings_set_use_color(_arg0, _arg1)
}

func (s printSettings) ToFilePrintSettings(fileName string) error {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_to_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s printSettings) ToGVariantPrintSettings() *glib.Variant {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GVariant         // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_to_gvariant(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

func (s printSettings) ToKeyFilePrintSettings(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GKeyFile         // out
	var _arg2 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_print_settings_to_key_file(_arg0, _arg1, _arg2)
}

func (s printSettings) UnsetPrintSettings(key string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_unset(_arg0, _arg1)
}

// PrintUnixDialog: `GtkPrintUnixDialog` implements a print dialog for platforms
// which dont provide a native print dialog, like Unix.
//
// !An example GtkPrintUnixDialog (printdialog.png)
//
// It can be used very much like any other GTK dialog, at the cost of the
// portability offered by the high-level printing API with
// [class@Gtk.PrintOperation].
//
// In order to print something with `GtkPrintUnixDialog`, you need to use
// [method@Gtk.PrintUnixDialog.get_selected_printer] to obtain a
// [class@Gtk.Printer] object and use it to construct a [class@Gtk.PrintJob]
// using [ctor@Gtk.PrintJob.new].
//
// `GtkPrintUnixDialog` uses the following response values:
//
// - GTK_RESPONSE_OK: for the Print button - GTK_RESPONSE_APPLY: for the
// Preview button - GTK_RESPONSE_CANCEL: for the Cancel button
//
//
// GtkPrintUnixDialog as GtkBuildable
//
// The `GtkPrintUnixDialog` implementation of the `GtkBuildable` interface
// exposes its @notebook internal children with the name notebook.
//
// An example of a `GtkPrintUnixDialog` UI definition fragment:
//
// `xml <object class="GtkPrintUnixDialog" id="dialog1"> <child
// internal-child="notebook"> <object class="GtkNotebook" id="notebook"> <child>
// <object type="GtkNotebookPage"> <property name="tab_expand">False</property>
// <property name="tab_fill">False</property> <property name="tab"> <object
// class="GtkLabel" id="tablabel"> <property name="label">Tab label</property>
// </object> </property> <property name="child"> <object class="GtkLabel"
// id="tabcontent"> <property name="label">Content on notebook tab</property>
// </object> </property> </object> </child> </object> </child> </object> `
//
//
// CSS nodes
//
// `GtkPrintUnixDialog` has a single CSS node with name window. The style
// classes dialog and print are added.
type PrintUnixDialog interface {
	Dialog

	// AddCustomTabPrintUnixDialog adds a custom tab to the print dialog.
	AddCustomTabPrintUnixDialog(child Widget, tabLabel Widget)
	// CurrentPage gets the current page of the `GtkPrintUnixDialog`.
	CurrentPage() int
	// EmbedPageSetup gets whether to embed the page setup.
	EmbedPageSetup() bool
	// HasSelection gets whether there is a selection.
	HasSelection() bool
	// ManualCapabilities gets the capabilities that have been set on this
	// `GtkPrintUnixDialog`.
	ManualCapabilities() PrintCapabilities
	// PageSetup gets the page setup that is used by the `GtkPrintUnixDialog`.
	PageSetup() PageSetup
	// PageSetupSet gets whether a page setup was set by the user.
	PageSetupSet() bool
	// SelectedPrinter gets the currently selected printer.
	SelectedPrinter() Printer
	// Settings gets a new `GtkPrintSettings` object that represents the current
	// values in the print dialog.
	//
	// Note that this creates a new object, and you need to unref it if dont
	// want to keep it.
	Settings() PrintSettings
	// SupportSelection gets whether the print dialog allows user to print a
	// selection.
	SupportSelection() bool
	// SetCurrentPagePrintUnixDialog sets the current page number.
	//
	// If @current_page is not -1, this enables the current page choice for the
	// range of pages to print.
	SetCurrentPagePrintUnixDialog(currentPage int)
	// SetEmbedPageSetupPrintUnixDialog: embed page size combo box and
	// orientation combo box into page setup page.
	SetEmbedPageSetupPrintUnixDialog(embed bool)
	// SetHasSelectionPrintUnixDialog sets whether a selection exists.
	SetHasSelectionPrintUnixDialog(hasSelection bool)
	// SetManualCapabilitiesPrintUnixDialog: this lets you specify the printing
	// capabilities your application supports.
	//
	// For instance, if you can handle scaling the output then you pass
	// GTK_PRINT_CAPABILITY_SCALE. If you dont pass that, then the dialog will
	// only let you select the scale if the printing system automatically
	// handles scaling.
	SetManualCapabilitiesPrintUnixDialog(capabilities PrintCapabilities)
	// SetPageSetupPrintUnixDialog sets the page setup of the
	// `GtkPrintUnixDialog`.
	SetPageSetupPrintUnixDialog(pageSetup PageSetup)
	// SetSettingsPrintUnixDialog sets the `GtkPrintSettings` for the
	// `GtkPrintUnixDialog`.
	//
	// Typically, this is used to restore saved print settings from a previous
	// print operation before the print dialog is shown.
	SetSettingsPrintUnixDialog(settings PrintSettings)
	// SetSupportSelectionPrintUnixDialog sets whether the print dialog allows
	// user to print a selection.
	SetSupportSelectionPrintUnixDialog(supportSelection bool)
}

// printUnixDialog implements the PrintUnixDialog class.
type printUnixDialog struct {
	Dialog
}

// WrapPrintUnixDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintUnixDialog(obj *externglib.Object) PrintUnixDialog {
	return printUnixDialog{
		Dialog: WrapDialog(obj),
	}
}

func marshalPrintUnixDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintUnixDialog(obj), nil
}

// NewPrintUnixDialog creates a new `GtkPrintUnixDialog`.
func NewPrintUnixDialog(title string, parent Window) PrintUnixDialog {
	var _arg1 *C.char      // out
	var _arg2 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_print_unix_dialog_new(_arg1, _arg2)

	var _printUnixDialog PrintUnixDialog // out

	_printUnixDialog = WrapPrintUnixDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _printUnixDialog
}

func (d printUnixDialog) AddCustomTabPrintUnixDialog(child Widget, tabLabel Widget) {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _arg1 *C.GtkWidget          // out
	var _arg2 *C.GtkWidget          // out

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	C.gtk_print_unix_dialog_add_custom_tab(_arg0, _arg1, _arg2)
}

func (d printUnixDialog) CurrentPage() int {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_print_unix_dialog_get_current_page(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (d printUnixDialog) EmbedPageSetup() bool {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_print_unix_dialog_get_embed_page_setup(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d printUnixDialog) HasSelection() bool {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_print_unix_dialog_get_has_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d printUnixDialog) ManualCapabilities() PrintCapabilities {
	var _arg0 *C.GtkPrintUnixDialog  // out
	var _cret C.GtkPrintCapabilities // in

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_print_unix_dialog_get_manual_capabilities(_arg0)

	var _printCapabilities PrintCapabilities // out

	_printCapabilities = PrintCapabilities(_cret)

	return _printCapabilities
}

func (d printUnixDialog) PageSetup() PageSetup {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _cret *C.GtkPageSetup       // in

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_print_unix_dialog_get_page_setup(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

func (d printUnixDialog) PageSetupSet() bool {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_print_unix_dialog_get_page_setup_set(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d printUnixDialog) SelectedPrinter() Printer {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _cret *C.GtkPrinter         // in

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_print_unix_dialog_get_selected_printer(_arg0)

	var _printer Printer // out

	_printer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Printer)

	return _printer
}

func (d printUnixDialog) Settings() PrintSettings {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _cret *C.GtkPrintSettings   // in

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_print_unix_dialog_get_settings(_arg0)

	var _printSettings PrintSettings // out

	_printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PrintSettings)

	return _printSettings
}

func (d printUnixDialog) SupportSelection() bool {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_print_unix_dialog_get_support_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d printUnixDialog) SetCurrentPagePrintUnixDialog(currentPage int) {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.int)(currentPage)

	C.gtk_print_unix_dialog_set_current_page(_arg0, _arg1)
}

func (d printUnixDialog) SetEmbedPageSetupPrintUnixDialog(embed bool) {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	if embed {
		_arg1 = C.TRUE
	}

	C.gtk_print_unix_dialog_set_embed_page_setup(_arg0, _arg1)
}

func (d printUnixDialog) SetHasSelectionPrintUnixDialog(hasSelection bool) {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	if hasSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_unix_dialog_set_has_selection(_arg0, _arg1)
}

func (d printUnixDialog) SetManualCapabilitiesPrintUnixDialog(capabilities PrintCapabilities) {
	var _arg0 *C.GtkPrintUnixDialog  // out
	var _arg1 C.GtkPrintCapabilities // out

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.GtkPrintCapabilities)(capabilities)

	C.gtk_print_unix_dialog_set_manual_capabilities(_arg0, _arg1)
}

func (d printUnixDialog) SetPageSetupPrintUnixDialog(pageSetup PageSetup) {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _arg1 *C.GtkPageSetup       // out

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))

	C.gtk_print_unix_dialog_set_page_setup(_arg0, _arg1)
}

func (d printUnixDialog) SetSettingsPrintUnixDialog(settings PrintSettings) {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _arg1 *C.GtkPrintSettings   // out

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))

	C.gtk_print_unix_dialog_set_settings(_arg0, _arg1)
}

func (d printUnixDialog) SetSupportSelectionPrintUnixDialog(supportSelection bool) {
	var _arg0 *C.GtkPrintUnixDialog // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	if supportSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_unix_dialog_set_support_selection(_arg0, _arg1)
}

func (s printUnixDialog) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s printUnixDialog) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s printUnixDialog) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s printUnixDialog) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s printUnixDialog) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s printUnixDialog) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s printUnixDialog) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b printUnixDialog) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s printUnixDialog) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s printUnixDialog) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s printUnixDialog) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s printUnixDialog) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s printUnixDialog) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s printUnixDialog) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s printUnixDialog) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s printUnixDialog) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// Printer: a `GtkPrinter` object represents a printer.
//
// You only need to deal directly with printers if you use the non-portable
// [class@Gtk.PrintUnixDialog] API.
//
// A `GtkPrinter` allows to get status information about the printer, such as
// its description, its location, the number of queued jobs, etc. Most
// importantly, a `GtkPrinter` object can be used to create a
// [class@Gtk.PrintJob] object, which lets you print to the printer.
type Printer interface {

	// AcceptsPDFPrinter returns whether the printer accepts input in PDF
	// format.
	AcceptsPDFPrinter() bool
	// AcceptsPSPrinter returns whether the printer accepts input in PostScript
	// format.
	AcceptsPSPrinter() bool
	// ComparePrinter compares two printers.
	ComparePrinter(b Printer) int
	// Backend returns the backend of the printer.
	Backend() *PrintBackend
	// Capabilities returns the printers capabilities.
	//
	// This is useful when youre using `GtkPrintUnixDialog`s
	// manual-capabilities setting and need to know which settings the printer
	// can handle and which you must handle yourself.
	//
	// This will return 0 unless the printers details are available, see
	// [method@Gtk.Printer.has_details] and
	// [method@Gtk.Printer.request_details].
	Capabilities() PrintCapabilities
	// DefaultPageSize returns default page size of @printer.
	DefaultPageSize() PageSetup
	// Description gets the description of the printer.
	Description() string
	// HardMargins: retrieve the hard margins of @printer.
	//
	// These are the margins that define the area at the borders of the paper
	// that the printer cannot print to.
	//
	// Note: This will not succeed unless the printers details are available,
	// see [method@Gtk.Printer.has_details] and
	// [method@Gtk.Printer.request_details].
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// HardMarginsForPaperSize: retrieve the hard margins of @printer for
	// @paper_size.
	//
	// These are the margins that define the area at the borders of the paper
	// that the printer cannot print to.
	//
	// Note: This will not succeed unless the printers details are available,
	// see [method@Gtk.Printer.has_details] and
	// [method@Gtk.Printer.request_details].
	HardMarginsForPaperSize(paperSize *PaperSize) (top float64, bottom float64, left float64, right float64, ok bool)
	// IconName gets the name of the icon to use for the printer.
	IconName() string
	// JobCount gets the number of jobs currently queued on the printer.
	JobCount() int
	// Location returns a description of the location of the printer.
	Location() string
	// Name returns the name of the printer.
	Name() string
	// StateMessage returns the state message describing the current state of
	// the printer.
	StateMessage() string
	// HasDetailsPrinter returns whether the printer details are available.
	HasDetailsPrinter() bool
	// IsAcceptingJobsPrinter returns whether the printer is accepting jobs
	IsAcceptingJobsPrinter() bool
	// IsActivePrinter returns whether the printer is currently active (i.e.
	// accepts new jobs).
	IsActivePrinter() bool
	// IsDefaultPrinter returns whether the printer is the default printer.
	IsDefaultPrinter() bool
	// IsPausedPrinter returns whether the printer is currently paused.
	//
	// A paused printer still accepts jobs, but it is not printing them.
	IsPausedPrinter() bool
	// IsVirtualPrinter returns whether the printer is virtual (i.e. does not
	// represent actual printer hardware, but something like a CUPS class).
	IsVirtualPrinter() bool
	// RequestDetailsPrinter requests the printer details.
	//
	// When the details are available, the
	// [signal@Gtk.Printer::details-acquired] signal will be emitted on
	// @printer.
	RequestDetailsPrinter()
}

// printer implements the Printer class.
type printer struct {
	gextras.Objector
}

// WrapPrinter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrinter(obj *externglib.Object) Printer {
	return printer{
		Objector: obj,
	}
}

func marshalPrinter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrinter(obj), nil
}

// NewPrinter creates a new `GtkPrinter`.
func NewPrinter(name string, backend *PrintBackend, virtual_ bool) Printer {
	var _arg1 *C.char            // out
	var _arg2 *C.GtkPrintBackend // out
	var _arg3 C.gboolean         // out
	var _cret *C.GtkPrinter      // in

	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkPrintBackend)(unsafe.Pointer(backend.Native()))
	if virtual_ {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_printer_new(_arg1, _arg2, _arg3)

	var _printer Printer // out

	_printer = WrapPrinter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printer
}

func (p printer) AcceptsPDFPrinter() bool {
	var _arg0 *C.GtkPrinter // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_accepts_pdf(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p printer) AcceptsPSPrinter() bool {
	var _arg0 *C.GtkPrinter // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_accepts_ps(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a printer) ComparePrinter(b Printer) int {
	var _arg0 *C.GtkPrinter // out
	var _arg1 *C.GtkPrinter // out
	var _cret C.int         // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkPrinter)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_printer_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (p printer) Backend() *PrintBackend {
	var _arg0 *C.GtkPrinter      // out
	var _cret *C.GtkPrintBackend // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_backend(_arg0)

	var _printBackend *PrintBackend // out

	_printBackend = WrapPrintBackend(unsafe.Pointer(_cret))

	return _printBackend
}

func (p printer) Capabilities() PrintCapabilities {
	var _arg0 *C.GtkPrinter          // out
	var _cret C.GtkPrintCapabilities // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_capabilities(_arg0)

	var _printCapabilities PrintCapabilities // out

	_printCapabilities = PrintCapabilities(_cret)

	return _printCapabilities
}

func (p printer) DefaultPageSize() PageSetup {
	var _arg0 *C.GtkPrinter   // out
	var _cret *C.GtkPageSetup // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_default_page_size(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

func (p printer) Description() string {
	var _arg0 *C.GtkPrinter // out
	var _cret *C.char       // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p printer) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
	var _arg0 *C.GtkPrinter // out
	var _arg1 C.double      // in
	var _arg2 C.double      // in
	var _arg3 C.double      // in
	var _arg4 C.double      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_hard_margins(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _top float64    // out
	var _bottom float64 // out
	var _left float64   // out
	var _right float64  // out
	var _ok bool        // out

	_top = (float64)(_arg1)
	_bottom = (float64)(_arg2)
	_left = (float64)(_arg3)
	_right = (float64)(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _top, _bottom, _left, _right, _ok
}

func (p printer) HardMarginsForPaperSize(paperSize *PaperSize) (top float64, bottom float64, left float64, right float64, ok bool) {
	var _arg0 *C.GtkPrinter   // out
	var _arg1 *C.GtkPaperSize // out
	var _arg2 C.double        // in
	var _arg3 C.double        // in
	var _arg4 C.double        // in
	var _arg5 C.double        // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

	_cret = C.gtk_printer_get_hard_margins_for_paper_size(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

	var _top float64    // out
	var _bottom float64 // out
	var _left float64   // out
	var _right float64  // out
	var _ok bool        // out

	_top = (float64)(_arg2)
	_bottom = (float64)(_arg3)
	_left = (float64)(_arg4)
	_right = (float64)(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _top, _bottom, _left, _right, _ok
}

func (p printer) IconName() string {
	var _arg0 *C.GtkPrinter // out
	var _cret *C.char       // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p printer) JobCount() int {
	var _arg0 *C.GtkPrinter // out
	var _cret C.int         // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_job_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (p printer) Location() string {
	var _arg0 *C.GtkPrinter // out
	var _cret *C.char       // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_location(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p printer) Name() string {
	var _arg0 *C.GtkPrinter // out
	var _cret *C.char       // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p printer) StateMessage() string {
	var _arg0 *C.GtkPrinter // out
	var _cret *C.char       // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_get_state_message(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p printer) HasDetailsPrinter() bool {
	var _arg0 *C.GtkPrinter // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_has_details(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p printer) IsAcceptingJobsPrinter() bool {
	var _arg0 *C.GtkPrinter // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_is_accepting_jobs(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p printer) IsActivePrinter() bool {
	var _arg0 *C.GtkPrinter // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p printer) IsDefaultPrinter() bool {
	var _arg0 *C.GtkPrinter // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_is_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p printer) IsPausedPrinter() bool {
	var _arg0 *C.GtkPrinter // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_is_paused(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p printer) IsVirtualPrinter() bool {
	var _arg0 *C.GtkPrinter // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_printer_is_virtual(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p printer) RequestDetailsPrinter() {
	var _arg0 *C.GtkPrinter // out

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	C.gtk_printer_request_details(_arg0)
}

// ProgressBar: `GtkProgressBar` is typically used to display the progress of a
// long running operation.
//
// It provides a visual clue that processing is underway. `GtkProgressBar` can
// be used in two different modes: percentage mode and activity mode.
//
// !An example GtkProgressBar (progressbar.png)
//
// When an application can determine how much work needs to take place (e.g.
// read a fixed number of bytes from a file) and can monitor its progress, it
// can use the `GtkProgressBar` in percentage mode and the user sees a growing
// bar indicating the percentage of the work that has been completed. In this
// mode, the application is required to call
// [method@Gtk.ProgressBar.set_fraction] periodically to update the progress
// bar.
//
// When an application has no accurate way of knowing the amount of work to do,
// it can use the `GtkProgressBar` in activity mode, which shows activity by a
// block moving back and forth within the progress area. In this mode, the
// application is required to call [method@Gtk.ProgressBar.pulse] periodically
// to update the progress bar.
//
// There is quite a bit of flexibility provided to control the appearance of the
// `GtkProgressBar`. Functions are provided to control the orientation of the
// bar, optional text can be displayed along with the bar, and the step size
// used in activity mode can be set.
//
//
// CSS nodes
//
// ` progressbar[.osd]  [text]  trough[.empty][.full] 
// progress[.pulse] `
//
// `GtkProgressBar` has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
//
//
// Accessibility
//
// `GtkProgressBar` uses the K_ACCESSIBLE_ROLE_PROGRESS_BAR role.
type ProgressBar interface {
	Widget
	Orientable

	// Ellipsize returns the ellipsizing position of the progress bar.
	//
	// See [method@Gtk.ProgressBar.set_ellipsize].
	Ellipsize() pango.EllipsizeMode
	// Fraction returns the current fraction of the task thats been completed.
	Fraction() float64
	// Inverted returns whether the progress bar is inverted.
	Inverted() bool
	// PulseStep retrieves the pulse step.
	//
	// See [method@Gtk.ProgressBar.set_pulse_step].
	PulseStep() float64
	// ShowText returns whether the `GtkProgressBar` shows text.
	//
	// See [method@Gtk.ProgressBar.set_show_text].
	ShowText() bool
	// Text retrieves the text that is displayed with the progress bar.
	//
	// The return value is a reference to the text, not a copy of it, so will
	// become invalid if you change the text in the progress bar.
	Text() string
	// PulseProgressBar indicates that some progress has been made, but you
	// dont know how much.
	//
	// Causes the progress bar to enter activity mode, where a block bounces
	// back and forth. Each call to [method@Gtk.ProgressBar.pulse] causes the
	// block to move by a little bit (the amount of movement per pulse is
	// determined by [method@Gtk.ProgressBar.set_pulse_step]).
	PulseProgressBar()
	// SetEllipsizeProgressBar sets the mode used to ellipsize the text.
	//
	// The text is ellipsized if there is not enough space to render the entire
	// string.
	SetEllipsizeProgressBar(mode pango.EllipsizeMode)
	// SetFractionProgressBar causes the progress bar to fill in the given
	// fraction of the bar.
	//
	// The fraction should be between 0.0 and 1.0, inclusive.
	SetFractionProgressBar(fraction float64)
	// SetInvertedProgressBar sets whether the progress bar is inverted.
	//
	// Progress bars normally grow from top to bottom or left to right. Inverted
	// progress bars grow in the opposite direction.
	SetInvertedProgressBar(inverted bool)
	// SetPulseStepProgressBar sets the fraction of total progress bar length to
	// move the bouncing block.
	//
	// The bouncing block is moved when [method@Gtk.ProgressBar.pulse] is
	// called.
	SetPulseStepProgressBar(fraction float64)
	// SetShowTextProgressBar sets whether the progress bar will show text next
	// to the bar.
	//
	// The shown text is either the value of the [property@Gtk.ProgressBar:text]
	// property or, if that is nil, the [property@Gtk.ProgressBar:fraction]
	// value, as a percentage.
	//
	// To make a progress bar that is styled and sized suitably for containing
	// text (even if the actual text is blank), set
	// [property@Gtk.ProgressBar:show-text] to true and
	// [property@Gtk.ProgressBar:text] to the empty string (not nil).
	SetShowTextProgressBar(showText bool)
	// SetTextProgressBar causes the given @text to appear next to the progress
	// bar.
	//
	// If @text is nil and [property@Gtk.ProgressBar:show-text] is true, the
	// current value of [property@Gtk.ProgressBar:fraction] will be displayed as
	// a percentage.
	//
	// If @text is non-nil and [property@Gtk.ProgressBar:show-text] is true, the
	// text will be displayed. In this case, it will not display the progress
	// percentage. If @text is the empty string, the progress bar will still be
	// styled and sized suitably for containing text, as long as
	// [property@Gtk.ProgressBar:show-text] is true.
	SetTextProgressBar(text string)
}

// progressBar implements the ProgressBar class.
type progressBar struct {
	Widget
}

// WrapProgressBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapProgressBar(obj *externglib.Object) ProgressBar {
	return progressBar{
		Widget: WrapWidget(obj),
	}
}

func marshalProgressBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProgressBar(obj), nil
}

// NewProgressBar creates a new `GtkProgressBar`.
func NewProgressBar() ProgressBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_progress_bar_new()

	var _progressBar ProgressBar // out

	_progressBar = WrapProgressBar(externglib.Take(unsafe.Pointer(_cret)))

	return _progressBar
}

func (p progressBar) Ellipsize() pango.EllipsizeMode {
	var _arg0 *C.GtkProgressBar    // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_ellipsize(_arg0)

	var _ellipsizeMode pango.EllipsizeMode // out

	_ellipsizeMode = pango.EllipsizeMode(_cret)

	return _ellipsizeMode
}

func (p progressBar) Fraction() float64 {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.double          // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_fraction(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (p progressBar) Inverted() bool {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_inverted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p progressBar) PulseStep() float64 {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.double          // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_pulse_step(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (p progressBar) ShowText() bool {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_show_text(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p progressBar) Text() string {
	var _arg0 *C.GtkProgressBar // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (p progressBar) PulseProgressBar() {
	var _arg0 *C.GtkProgressBar // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	C.gtk_progress_bar_pulse(_arg0)
}

func (p progressBar) SetEllipsizeProgressBar(mode pango.EllipsizeMode) {
	var _arg0 *C.GtkProgressBar    // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_progress_bar_set_ellipsize(_arg0, _arg1)
}

func (p progressBar) SetFractionProgressBar(fraction float64) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.double          // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (C.double)(fraction)

	C.gtk_progress_bar_set_fraction(_arg0, _arg1)
}

func (p progressBar) SetInvertedProgressBar(inverted bool) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	if inverted {
		_arg1 = C.TRUE
	}

	C.gtk_progress_bar_set_inverted(_arg0, _arg1)
}

func (p progressBar) SetPulseStepProgressBar(fraction float64) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.double          // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (C.double)(fraction)

	C.gtk_progress_bar_set_pulse_step(_arg0, _arg1)
}

func (p progressBar) SetShowTextProgressBar(showText bool) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	if showText {
		_arg1 = C.TRUE
	}

	C.gtk_progress_bar_set_show_text(_arg0, _arg1)
}

func (p progressBar) SetTextProgressBar(text string) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_progress_bar_set_text(_arg0, _arg1)
}

func (s progressBar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s progressBar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s progressBar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s progressBar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s progressBar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s progressBar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s progressBar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b progressBar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o progressBar) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o progressBar) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// PropertyExpression: a `GObject` property value in a `GtkExpression`.
type PropertyExpression interface {

	// GetExpression gets the expression specifying the object of a property
	// expression.
	GetExpression() Expression
}

// propertyExpression implements the PropertyExpression class.
type propertyExpression struct {
	Expression
}

// WrapPropertyExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapPropertyExpression(obj *externglib.Object) PropertyExpression {
	return propertyExpression{
		Expression: WrapExpression(obj),
	}
}

func marshalPropertyExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPropertyExpression(obj), nil
}

// NewPropertyExpression creates an expression that looks up a property via the
// given `expression` or the `this` argument when `expression` is `NULL`.
//
// If the resulting object conforms to `this_type`, its property named
// `property_name` will be queried. Otherwise, this expression's evaluation will
// fail.
//
// The given `this_type` must have a property with `property_name`.
func NewPropertyExpression(thisType externglib.Type, expression Expression, propertyName string) PropertyExpression {
	var _arg1 C.GType          // out
	var _arg2 *C.GtkExpression // out
	var _arg3 *C.char          // out
	var _cret *C.GtkExpression // in

	_arg1 = (C.GType)(thisType)
	_arg2 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))
	_arg3 = (*C.char)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_property_expression_new(_arg1, _arg2, _arg3)

	var _propertyExpression PropertyExpression // out

	_propertyExpression = WrapPropertyExpression(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _propertyExpression
}

func (e propertyExpression) GetExpression() Expression {
	var _arg0 *C.GtkExpression // out
	var _cret *C.GtkExpression // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_property_expression_get_expression(_arg0)

	var _ret Expression // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

	return _ret
}

// Range: `GtkRange` is the common base class for widgets which visualize an
// adjustment.
//
// Widgets that are derived from `GtkRange` include [class@Gtk.Scale] and
// [class@Gtk.Scrollbar].
//
// Apart from signals for monitoring the parameters of the adjustment,
// `GtkRange` provides properties and methods for setting a fill level on
// range widgets. See [method@Gtk.Range.set_fill_level].
type Range interface {
	Widget
	Orientable

	// Adjustment: get the adjustment which is the model object for
	// `GtkRange`.
	Adjustment() Adjustment
	// FillLevel gets the current position of the fill level indicator.
	FillLevel() float64
	// Flippable gets whether the `GtkRange` respects text direction.
	//
	// See [method@Gtk.Range.set_flippable].
	Flippable() bool
	// Inverted gets whether the range is inverted.
	//
	// See [method@Gtk.Range.set_inverted].
	Inverted() bool
	// RangeRect: this function returns the area that contains the ranges
	// trough, in coordinates relative to @range's origin.
	//
	// This function is useful mainly for `GtkRange` subclasses.
	RangeRect() gdk.Rectangle
	// RestrictToFillLevel gets whether the range is restricted to the fill
	// level.
	RestrictToFillLevel() bool
	// RoundDigits gets the number of digits to round the value to when it
	// changes.
	//
	// See [signal@Gtk.Range::change-value].
	RoundDigits() int
	// ShowFillLevel gets whether the range displays the fill level graphically.
	ShowFillLevel() bool
	// SliderRange: this function returns sliders range along the long
	// dimension, in widget->window coordinates.
	//
	// This function is useful mainly for `GtkRange` subclasses.
	SliderRange() (sliderStart int, sliderEnd int)
	// SliderSizeFixed: this function is useful mainly for `GtkRange`
	// subclasses.
	//
	// See [method@Gtk.Range.set_slider_size_fixed].
	SliderSizeFixed() bool
	// Value gets the current value of the range.
	Value() float64
	// SetAdjustmentRange sets the adjustment to be used as the model object
	// for the `GtkRange`
	//
	// The adjustment indicates the current range value, the minimum and maximum
	// range values, the step/page increments used for keybindings and
	// scrolling, and the page size.
	//
	// The page size is normally 0 for `GtkScale` and nonzero for
	// `GtkScrollbar`, and indicates the size of the visible area of the widget
	// being scrolled. The page size affects the size of the scrollbar slider.
	SetAdjustmentRange(adjustment Adjustment)
	// SetFillLevelRange: set the new position of the fill level indicator.
	//
	// The fill level is probably best described by its most prominent use
	// case, which is an indicator for the amount of pre-buffering in a
	// streaming media player. In that use case, the value of the range would
	// indicate the current play position, and the fill level would be the
	// position up to which the file/stream has been downloaded.
	//
	// This amount of prebuffering can be displayed on the ranges trough and is
	// themeable separately from the trough. To enable fill level display, use
	// [method@Gtk.Range.set_show_fill_level]. The range defaults to not showing
	// the fill level.
	//
	// Additionally, its possible to restrict the ranges slider position to
	// values which are smaller than the fill level. This is controlled by
	// [method@Gtk.Range.set_restrict_to_fill_level] and is by default enabled.
	SetFillLevelRange(fillLevel float64)
	// SetFlippableRange sets whether the `GtkRange` respects text direction.
	//
	// If a range is flippable, it will switch its direction if it is horizontal
	// and its direction is GTK_TEXT_DIR_RTL.
	//
	// See [method@Gtk.Widget.get_direction].
	SetFlippableRange(flippable bool)
	// SetIncrementsRange sets the step and page sizes for the range.
	//
	// The step size is used when the user clicks the `GtkScrollbar` arrows or
	// moves a `GtkScale` via arrow keys. The page size is used for example when
	// moving via Page Up or Page Down keys.
	SetIncrementsRange(step float64, page float64)
	// SetInvertedRange sets whether to invert the range.
	//
	// Ranges normally move from lower to higher values as the slider moves from
	// top to bottom or left to right. Inverted ranges have higher values at the
	// top or on the right rather than on the bottom or left.
	SetInvertedRange(setting bool)
	// SetRangeRange sets the allowable values in the `GtkRange`.
	//
	// The range value is clamped to be between @min and @max. (If the range has
	// a non-zero page size, it is clamped between @min and @max - page-size.)
	SetRangeRange(min float64, max float64)
	// SetRestrictToFillLevelRange sets whether the slider is restricted to the
	// fill level.
	//
	// See [method@Gtk.Range.set_fill_level] for a general description of the
	// fill level concept.
	SetRestrictToFillLevelRange(restrictToFillLevel bool)
	// SetRoundDigitsRange sets the number of digits to round the value to when
	// it changes.
	//
	// See [signal@Gtk.Range::change-value].
	SetRoundDigitsRange(roundDigits int)
	// SetShowFillLevelRange sets whether a graphical fill level is show on the
	// trough.
	//
	// See [method@Gtk.Range.set_fill_level] for a general description of the
	// fill level concept.
	SetShowFillLevelRange(showFillLevel bool)
	// SetSliderSizeFixedRange sets whether the ranges slider has a fixed size,
	// or a size that depends on its adjustments page size.
	//
	// This function is useful mainly for `GtkRange` subclasses.
	SetSliderSizeFixedRange(sizeFixed bool)
	// SetValueRange sets the current value of the range.
	//
	// If the value is outside the minimum or maximum range values, it will be
	// clamped to fit inside them. The range emits the
	// [signal@Gtk.Range::value-changed] signal if the value changes.
	SetValueRange(value float64)
}

// _range implements the Range class.
type _range struct {
	Widget
}

// WrapRange wraps a GObject to the right type. It is
// primarily used internally.
func WrapRange(obj *externglib.Object) Range {
	return _range{
		Widget: WrapWidget(obj),
	}
}

func marshalRange(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRange(obj), nil
}

func (r _range) Adjustment() Adjustment {
	var _arg0 *C.GtkRange      // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_adjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (r _range) FillLevel() float64 {
	var _arg0 *C.GtkRange // out
	var _cret C.double    // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_fill_level(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (r _range) Flippable() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_flippable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r _range) Inverted() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_inverted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r _range) RangeRect() gdk.Rectangle {
	var _arg0 *C.GtkRange // out
	var _rangeRect gdk.Rectangle

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	C.gtk_range_get_range_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rangeRect)))

	return _rangeRect
}

func (r _range) RestrictToFillLevel() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_restrict_to_fill_level(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r _range) RoundDigits() int {
	var _arg0 *C.GtkRange // out
	var _cret C.int       // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_round_digits(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (r _range) ShowFillLevel() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_show_fill_level(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r _range) SliderRange() (sliderStart int, sliderEnd int) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	C.gtk_range_get_slider_range(_arg0, &_arg1, &_arg2)

	var _sliderStart int // out
	var _sliderEnd int   // out

	_sliderStart = (int)(_arg1)
	_sliderEnd = (int)(_arg2)

	return _sliderStart, _sliderEnd
}

func (r _range) SliderSizeFixed() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_slider_size_fixed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r _range) Value() float64 {
	var _arg0 *C.GtkRange // out
	var _cret C.double    // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (r _range) SetAdjustmentRange(adjustment Adjustment) {
	var _arg0 *C.GtkRange      // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_range_set_adjustment(_arg0, _arg1)
}

func (r _range) SetFillLevelRange(fillLevel float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.double    // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.double)(fillLevel)

	C.gtk_range_set_fill_level(_arg0, _arg1)
}

func (r _range) SetFlippableRange(flippable bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if flippable {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_flippable(_arg0, _arg1)
}

func (r _range) SetIncrementsRange(step float64, page float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.double    // out
	var _arg2 C.double    // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.double)(step)
	_arg2 = (C.double)(page)

	C.gtk_range_set_increments(_arg0, _arg1, _arg2)
}

func (r _range) SetInvertedRange(setting bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_inverted(_arg0, _arg1)
}

func (r _range) SetRangeRange(min float64, max float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.double    // out
	var _arg2 C.double    // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.double)(min)
	_arg2 = (C.double)(max)

	C.gtk_range_set_range(_arg0, _arg1, _arg2)
}

func (r _range) SetRestrictToFillLevelRange(restrictToFillLevel bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if restrictToFillLevel {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_restrict_to_fill_level(_arg0, _arg1)
}

func (r _range) SetRoundDigitsRange(roundDigits int) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.int)(roundDigits)

	C.gtk_range_set_round_digits(_arg0, _arg1)
}

func (r _range) SetShowFillLevelRange(showFillLevel bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if showFillLevel {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_show_fill_level(_arg0, _arg1)
}

func (r _range) SetSliderSizeFixedRange(sizeFixed bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if sizeFixed {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_slider_size_fixed(_arg0, _arg1)
}

func (r _range) SetValueRange(value float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.double    // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.double)(value)

	C.gtk_range_set_value(_arg0, _arg1)
}

func (s _range) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s _range) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s _range) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s _range) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s _range) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s _range) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s _range) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b _range) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o _range) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o _range) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// RecentManager: `GtkRecentManager` manages and looks up recently used files.
//
// Each recently used file is identified by its URI, and has meta-data
// associated to it, like the names and command lines of the applications that
// have registered it, the number of time each application has registered the
// same file, the mime type of the file and whether the file should be displayed
// only by the applications that have registered it.
//
// The recently used files list is per user.
//
// `GtkRecentManager` acts like a database of all the recently used files. You
// can create new `GtkRecentManager` objects, but it is more efficient to use
// the default manager created by GTK.
//
// Adding a new recently used file is as simple as:
//
// `c GtkRecentManager *manager;
//
// manager = gtk_recent_manager_get_default (); gtk_recent_manager_add_item
// (manager, file_uri); `
//
// The `GtkRecentManager` will try to gather all the needed information from the
// file itself through GIO.
//
// Looking up the meta-data associated with a recently used file given its URI
// requires calling [method@Gtk.RecentManager.lookup_item]:
//
// `c GtkRecentManager *manager; GtkRecentInfo *info; GError *error = NULL;
//
// manager = gtk_recent_manager_get_default (); info =
// gtk_recent_manager_lookup_item (manager, file_uri, &error); if (error) {
// g_warning ("Could not find the file: s", error->message); g_error_free
// (error); } else { // Use the info object gtk_recent_info_unref (info); } `
//
// In order to retrieve the list of recently used files, you can use
// [method@Gtk.RecentManager.get_items], which returns a list of
// [struct@Gtk.RecentInfo].
//
// Note that the maximum age of the recently used files list is controllable
// through the [property@Gtk.Settings:gtk-recent-files-max-age] property.
type RecentManager interface {

	// AddFullRecentManager adds a new resource, pointed by @uri, into the
	// recently used resources list, using the metadata specified inside the
	// `GtkRecentData` passed in @recent_data.
	//
	// The passed URI will be used to identify this resource inside the list.
	//
	// In order to register the new recently used resource, metadata about the
	// resource must be passed as well as the URI; the metadata is stored in a
	// `GtkRecentData`, which must contain the MIME type of the resource pointed
	// by the URI; the name of the application that is registering the item, and
	// a command line to be used when launching the item.
	//
	// Optionally, a `GtkRecentData` might contain a UTF-8 string to be used
	// when viewing the item instead of the last component of the URI; a short
	// description of the item; whether the item should be considered private -
	// that is, should be displayed only by the applications that have
	// registered it.
	AddFullRecentManager(uri string, recentData *RecentData) bool
	// AddItemRecentManager adds a new resource, pointed by @uri, into the
	// recently used resources list.
	//
	// This function automatically retrieves some of the needed metadata and
	// setting other metadata to common default values; it then feeds the data
	// to [method@Gtk.RecentManager.add_full].
	//
	// See [method@Gtk.RecentManager.add_full] if you want to explicitly define
	// the metadata for the resource pointed by @uri.
	AddItemRecentManager(uri string) bool
	// HasItemRecentManager checks whether there is a recently used resource
	// registered with @uri inside the recent manager.
	HasItemRecentManager(uri string) bool
	// LookupItemRecentManager searches for a URI inside the recently used
	// resources list, and returns a `GtkRecentInfo` containing information
	// about the resource like its MIME type, or its display name.
	LookupItemRecentManager(uri string) (*RecentInfo, error)
	// MoveItemRecentManager changes the location of a recently used resource
	// from @uri to @new_uri.
	//
	// Please note that this function will not affect the resource pointed by
	// the URIs, but only the URI used in the recently used resources list.
	MoveItemRecentManager(uri string, newUri string) error
	// PurgeItemsRecentManager purges every item from the recently used
	// resources list.
	PurgeItemsRecentManager() (int, error)
	// RemoveItemRecentManager removes a resource pointed by @uri from the
	// recently used resources list handled by a recent manager.
	RemoveItemRecentManager(uri string) error
}

// recentManager implements the RecentManager class.
type recentManager struct {
	gextras.Objector
}

// WrapRecentManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentManager(obj *externglib.Object) RecentManager {
	return recentManager{
		Objector: obj,
	}
}

func marshalRecentManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentManager(obj), nil
}

// NewRecentManager creates a new recent manager object.
//
// Recent manager objects are used to handle the list of recently used
// resources. A `GtkRecentManager` object monitors the recently used resources
// list, and emits the [signal@Gtk.RecentManager::changed] signal each time
// something inside the list changes.
//
// `GtkRecentManager` objects are expensive: be sure to create them only when
// needed. You should use [type_func@Gtk.RecentManager.get_default] instead.
func NewRecentManager() RecentManager {
	var _cret *C.GtkRecentManager // in

	_cret = C.gtk_recent_manager_new()

	var _recentManager RecentManager // out

	_recentManager = WrapRecentManager(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _recentManager
}

func (m recentManager) AddFullRecentManager(uri string, recentData *RecentData) bool {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _arg2 *C.GtkRecentData    // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkRecentData)(unsafe.Pointer(recentData.Native()))

	_cret = C.gtk_recent_manager_add_full(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m recentManager) AddItemRecentManager(uri string) bool {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_manager_add_item(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m recentManager) HasItemRecentManager(uri string) bool {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_manager_has_item(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m recentManager) LookupItemRecentManager(uri string) (*RecentInfo, error) {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _cret *C.GtkRecentInfo    // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_manager_lookup_item(_arg0, _arg1, &_cerr)

	var _recentInfo *RecentInfo // out
	var _goerr error            // out

	_recentInfo = WrapRecentInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _recentInfo, _goerr
}

func (m recentManager) MoveItemRecentManager(uri string, newUri string) error {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _arg2 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(newUri))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_recent_manager_move_item(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (m recentManager) PurgeItemsRecentManager() (int, error) {
	var _arg0 *C.GtkRecentManager // out
	var _cret C.int               // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_recent_manager_purge_items(_arg0, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (m recentManager) RemoveItemRecentManager(uri string) error {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_manager_remove_item(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Revealer: a `GtkRevealer` animates the transition of its child from invisible
// to visible.
//
// The style of transition can be controlled with
// [method@Gtk.Revealer.set_transition_type].
//
// These animations respect the [property@Gtk.Settings:gtk-enable-animations]
// setting.
//
//
// CSS nodes
//
// `GtkRevealer` has a single CSS node with name revealer. When styling
// `GtkRevealer` using CSS, remember that it only hides its contents, not
// itself. That means applied margin, padding and borders will be visible even
// when the [property@Gtk.Revealer:reveal-child] property is set to false.
//
//
// Accessibility
//
// `GtkRevealer` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
//
// The child of `GtkRevealer`, if set, is always available in the accessibility
// tree, regardless of the state of the revealer widget.
type Revealer interface {
	Widget

	// Child gets the child widget of @revealer.
	Child() Widget
	// ChildRevealed returns whether the child is fully revealed.
	//
	// In other words, this returns whether the transition to the revealed state
	// is completed.
	ChildRevealed() bool
	// RevealChild returns whether the child is currently revealed.
	//
	// This function returns true as soon as the transition is to the revealed
	// state is started. To learn whether the child is fully revealed (ie the
	// transition is completed), use [method@Gtk.Revealer.get_child_revealed].
	RevealChild() bool
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions will take.
	TransitionDuration() uint
	// TransitionType gets the type of animation that will be used for
	// transitions in @revealer.
	TransitionType() RevealerTransitionType
	// SetChildRevealer sets the child widget of @revealer.
	SetChildRevealer(child Widget)
	// SetRevealChildRevealer tells the `GtkRevealer` to reveal or conceal its
	// child.
	//
	// The transition will be animated with the current transition type of
	// @revealer.
	SetRevealChildRevealer(revealChild bool)
	// SetTransitionDurationRevealer sets the duration that transitions will
	// take.
	SetTransitionDurationRevealer(duration uint)
	// SetTransitionTypeRevealer sets the type of animation that will be used
	// for transitions in @revealer.
	//
	// Available types include various kinds of fades and slides.
	SetTransitionTypeRevealer(transition RevealerTransitionType)
}

// revealer implements the Revealer class.
type revealer struct {
	Widget
}

// WrapRevealer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRevealer(obj *externglib.Object) Revealer {
	return revealer{
		Widget: WrapWidget(obj),
	}
}

func marshalRevealer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRevealer(obj), nil
}

// NewRevealer creates a new `GtkRevealer`.
func NewRevealer() Revealer {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_revealer_new()

	var _revealer Revealer // out

	_revealer = WrapRevealer(externglib.Take(unsafe.Pointer(_cret)))

	return _revealer
}

func (r revealer) Child() Widget {
	var _arg0 *C.GtkRevealer // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_revealer_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (r revealer) ChildRevealed() bool {
	var _arg0 *C.GtkRevealer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_revealer_get_child_revealed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r revealer) RevealChild() bool {
	var _arg0 *C.GtkRevealer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_revealer_get_reveal_child(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r revealer) TransitionDuration() uint {
	var _arg0 *C.GtkRevealer // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_revealer_get_transition_duration(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (r revealer) TransitionType() RevealerTransitionType {
	var _arg0 *C.GtkRevealer              // out
	var _cret C.GtkRevealerTransitionType // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_revealer_get_transition_type(_arg0)

	var _revealerTransitionType RevealerTransitionType // out

	_revealerTransitionType = RevealerTransitionType(_cret)

	return _revealerTransitionType
}

func (r revealer) SetChildRevealer(child Widget) {
	var _arg0 *C.GtkRevealer // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_revealer_set_child(_arg0, _arg1)
}

func (r revealer) SetRevealChildRevealer(revealChild bool) {
	var _arg0 *C.GtkRevealer // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	if revealChild {
		_arg1 = C.TRUE
	}

	C.gtk_revealer_set_reveal_child(_arg0, _arg1)
}

func (r revealer) SetTransitionDurationRevealer(duration uint) {
	var _arg0 *C.GtkRevealer // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.guint)(duration)

	C.gtk_revealer_set_transition_duration(_arg0, _arg1)
}

func (r revealer) SetTransitionTypeRevealer(transition RevealerTransitionType) {
	var _arg0 *C.GtkRevealer              // out
	var _arg1 C.GtkRevealerTransitionType // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.GtkRevealerTransitionType)(transition)

	C.gtk_revealer_set_transition_type(_arg0, _arg1)
}

func (s revealer) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s revealer) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s revealer) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s revealer) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s revealer) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s revealer) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s revealer) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b revealer) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Scale: a `GtkScale` is a slider control used to select a numeric value.
//
// !An example GtkScale (scales.png)
//
// To use it, youll probably want to investigate the methods on its base class,
// [class@GtkRange], in addition to the methods for `GtkScale` itself. To set
// the value of a scale, you would normally use [method@Gtk.Range.set_value]. To
// detect changes to the value, you would normally use the
// [signal@Gtk.Range::value-changed] signal.
//
// Note that using the same upper and lower bounds for the `GtkScale` (through
// the `GtkRange` methods) will hide the slider itself. This is useful for
// applications that want to show an undeterminate value on the scale, without
// changing the layout of the application (such as movie or music players).
//
//
// GtkScale as GtkBuildable
//
// `GtkScale` supports a custom <marks> element, which can contain multiple
// <mark\> elements. The value and position attributes have the same meaning
// as [method@Gtk.Scale.add_mark] parameters of the same name. If the element is
// not empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual translatable and context attributes.
//
//
// CSS nodes
//
// ` scale[.fine-tune][.marks-before][.marks-after] 
// [value][.top][.right][.bottom][.left]  marks.top   mark   
// [label]    indicator     mark  marks.bottom   mark   
// indicator    [label]     mark  trough  [fill] 
// [highlight]  slider `
//
// `GtkScale` has a main CSS node with name scale and a subnode for its
// contents, with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see [method@Gtk.Scale.set_has_origin]), there is
// a subnode with name highlight below the trough node that is used for
// rendering the highlighted part of the trough.
//
// If the scale is showing a fill level (see
// [method@Gtk.Range.set_show_fill_level]), there is a subnode with name fill
// below the trough node that is used for rendering the filled in part of the
// trough.
//
// If marks are present, there is a marks subnode before or after the trough
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see [property@Gtk.Scale:draw-value]),
// there is subnode with name value. This node will get the .top or .bottom
// style classes similar to the marks node.
//
//
// Accessibility
//
// `GtkScale` uses the GTK_ACCESSIBLE_ROLE_SLIDER role.
type Scale interface {
	Range

	// AddMarkScale adds a mark at @value.
	//
	// A mark is indicated visually by drawing a tick mark next to the scale,
	// and GTK makes it easy for the user to position the scale exactly at the
	// marks value.
	//
	// If @markup is not nil, text is shown next to the tick mark.
	//
	// To remove marks from a scale, use [method@Gtk.Scale.clear_marks].
	AddMarkScale(value float64, position PositionType, markup string)
	// ClearMarksScale removes any marks that have been added.
	ClearMarksScale()
	// Digits gets the number of decimal places that are displayed in the value.
	Digits() int
	// DrawValue returns whether the current value is displayed as a string next
	// to the slider.
	DrawValue() bool
	// HasOrigin returns whether the scale has an origin.
	HasOrigin() bool
	// Layout gets the `PangoLayout` used to display the scale.
	//
	// The returned object is owned by the scale so does not need to be freed by
	// the caller.
	Layout() pango.Layout
	// LayoutOffsets obtains the coordinates where the scale will draw the
	// `PangoLayout` representing the text in the scale.
	//
	// Remember when using the `PangoLayout` function you need to convert to and
	// from pixels using `PANGO_PIXELS()` or `PANGO_SCALE`.
	//
	// If the [property@GtkScale:draw-value] property is false, the return
	// values are undefined.
	LayoutOffsets() (x int, y int)
	// ValuePos gets the position in which the current value is displayed.
	ValuePos() PositionType
	// SetDigitsScale sets the number of decimal places that are displayed in
	// the value.
	//
	// Also causes the value of the adjustment to be rounded to this number of
	// digits, so the retrieved value matches the displayed one, if
	// [property@GtkScale:draw-value] is true when the value changes. If you
	// want to enforce rounding the value when [property@GtkScale:draw-value] is
	// false, you can set [property@GtkRange:round-digits] instead.
	//
	// Note that rounding to a small number of digits can interfere with the
	// smooth autoscrolling that is built into `GtkScale`. As an alternative,
	// you can use [method@Gtk.Scale.set_format_value_func] to format the
	// displayed value yourself.
	SetDigitsScale(digits int)
	// SetDrawValueScale specifies whether the current value is displayed as a
	// string next to the slider.
	SetDrawValueScale(drawValue bool)
	// SetHasOriginScale sets whether the scale has an origin.
	//
	// If [property@GtkScale:has-origin] is set to true (the default), the scale
	// will highlight the part of the trough between the origin (bottom or left
	// side) and the current value.
	SetHasOriginScale(hasOrigin bool)
	// SetValuePosScale sets the position in which the current value is
	// displayed.
	SetValuePosScale(pos PositionType)
}

// scale implements the Scale class.
type scale struct {
	Range
}

// WrapScale wraps a GObject to the right type. It is
// primarily used internally.
func WrapScale(obj *externglib.Object) Scale {
	return scale{
		Range: WrapRange(obj),
	}
}

func marshalScale(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScale(obj), nil
}

// NewScale creates a new `GtkScale`.
func NewScale(orientation Orientation, adjustment Adjustment) Scale {
	var _arg1 C.GtkOrientation // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	_cret = C.gtk_scale_new(_arg1, _arg2)

	var _scale Scale // out

	_scale = WrapScale(externglib.Take(unsafe.Pointer(_cret)))

	return _scale
}

// NewScaleWithRange creates a new scale widget with a range from @min to @max.
//
// The returns scale will have the given orientation and will let the user input
// a number between @min and @max (including @min and @max) with the increment
// @step. @step must be nonzero; its the distance the slider moves when using
// the arrow keys to adjust the scale value.
//
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// [method@Gtk.Scale.set_digits] to correct it.
func NewScaleWithRange(orientation Orientation, min float64, max float64, step float64) Scale {
	var _arg1 C.GtkOrientation // out
	var _arg2 C.double         // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (C.double)(min)
	_arg3 = (C.double)(max)
	_arg4 = (C.double)(step)

	_cret = C.gtk_scale_new_with_range(_arg1, _arg2, _arg3, _arg4)

	var _scale Scale // out

	_scale = WrapScale(externglib.Take(unsafe.Pointer(_cret)))

	return _scale
}

func (s scale) AddMarkScale(value float64, position PositionType, markup string) {
	var _arg0 *C.GtkScale       // out
	var _arg1 C.double          // out
	var _arg2 C.GtkPositionType // out
	var _arg3 *C.char           // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(value)
	_arg2 = (C.GtkPositionType)(position)
	_arg3 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_scale_add_mark(_arg0, _arg1, _arg2, _arg3)
}

func (s scale) ClearMarksScale() {
	var _arg0 *C.GtkScale // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	C.gtk_scale_clear_marks(_arg0)
}

func (s scale) Digits() int {
	var _arg0 *C.GtkScale // out
	var _cret C.int       // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_digits(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s scale) DrawValue() bool {
	var _arg0 *C.GtkScale // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_draw_value(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scale) HasOrigin() bool {
	var _arg0 *C.GtkScale // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_has_origin(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scale) Layout() pango.Layout {
	var _arg0 *C.GtkScale    // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_layout(_arg0)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

func (s scale) LayoutOffsets() (x int, y int) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	C.gtk_scale_get_layout_offsets(_arg0, &_arg1, &_arg2)

	var _x int // out
	var _y int // out

	_x = (int)(_arg1)
	_y = (int)(_arg2)

	return _x, _y
}

func (s scale) ValuePos() PositionType {
	var _arg0 *C.GtkScale       // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_value_pos(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

func (s scale) SetDigitsScale(digits int) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(digits)

	C.gtk_scale_set_digits(_arg0, _arg1)
}

func (s scale) SetDrawValueScale(drawValue bool) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	if drawValue {
		_arg1 = C.TRUE
	}

	C.gtk_scale_set_draw_value(_arg0, _arg1)
}

func (s scale) SetHasOriginScale(hasOrigin bool) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	if hasOrigin {
		_arg1 = C.TRUE
	}

	C.gtk_scale_set_has_origin(_arg0, _arg1)
}

func (s scale) SetValuePosScale(pos PositionType) {
	var _arg0 *C.GtkScale       // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPositionType)(pos)

	C.gtk_scale_set_value_pos(_arg0, _arg1)
}

func (s scale) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s scale) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s scale) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s scale) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s scale) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s scale) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s scale) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b scale) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o scale) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o scale) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// ScaleButton: `GtkScaleButton` provides a button which pops up a scale widget.
//
// This kind of widget is commonly used for volume controls in multimedia
// applications, and GTK provides a [class@Gtk.VolumeButton] subclass that is
// tailored for this use case.
//
//
// CSS nodes
//
// `GtkScaleButton` has a single CSS node with name button. To differentiate it
// from a plain `GtkButton`, it gets the .scale style class.
type ScaleButton interface {
	Widget
	Orientable

	// Adjustment gets the `GtkAdjustment` associated with the
	// `GtkScaleButton`s scale.
	//
	// See [method@Gtk.Range.get_adjustment] for details.
	Adjustment() Adjustment
	// MinusButton retrieves the minus button of the `GtkScaleButton`.
	MinusButton() Button
	// PlusButton retrieves the plus button of the `GtkScaleButton.`
	PlusButton() Button
	// Popup retrieves the popup of the `GtkScaleButton`.
	Popup() Widget
	// Value gets the current value of the scale button.
	Value() float64
	// SetAdjustmentScaleButton sets the `GtkAdjustment` to be used as a model
	// for the `GtkScaleButton`s scale.
	//
	// See [method@Gtk.Range.set_adjustment] for details.
	SetAdjustmentScaleButton(adjustment Adjustment)
	// SetIconsScaleButton sets the icons to be used by the scale button.
	SetIconsScaleButton(icons []string)
	// SetValueScaleButton sets the current value of the scale.
	//
	// If the value is outside the minimum or maximum range values, it will be
	// clamped to fit inside them.
	//
	// The scale button emits the [signal@Gtk.ScaleButton::value-changed] signal
	// if the value changes.
	SetValueScaleButton(value float64)
}

// scaleButton implements the ScaleButton class.
type scaleButton struct {
	Widget
}

// WrapScaleButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapScaleButton(obj *externglib.Object) ScaleButton {
	return scaleButton{
		Widget: WrapWidget(obj),
	}
}

func marshalScaleButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScaleButton(obj), nil
}

// NewScaleButton creates a `GtkScaleButton`.
//
// The new scale button has a range between @min and @max, with a stepping of
// @step.
func NewScaleButton(min float64, max float64, step float64, icons []string) ScaleButton {
	var _arg1 C.double // out
	var _arg2 C.double // out
	var _arg3 C.double // out
	var _arg4 **C.char
	var _cret *C.GtkWidget // in

	_arg1 = (C.double)(min)
	_arg2 = (C.double)(max)
	_arg3 = (C.double)(step)
	_arg4 = (**C.char)(C.malloc(C.ulong(len(icons)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(icons))
		for i := range icons {
			out[i] = (*C.char)(C.CString(icons[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gtk_scale_button_new(_arg1, _arg2, _arg3, _arg4)

	var _scaleButton ScaleButton // out

	_scaleButton = WrapScaleButton(externglib.Take(unsafe.Pointer(_cret)))

	return _scaleButton
}

func (b scaleButton) Adjustment() Adjustment {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkAdjustment  // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_adjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (b scaleButton) MinusButton() Button {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_minus_button(_arg0)

	var _ret Button // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

	return _ret
}

func (b scaleButton) PlusButton() Button {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_plus_button(_arg0)

	var _ret Button // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

	return _ret
}

func (b scaleButton) Popup() Widget {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_popup(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (b scaleButton) Value() float64 {
	var _arg0 *C.GtkScaleButton // out
	var _cret C.double          // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (b scaleButton) SetAdjustmentScaleButton(adjustment Adjustment) {
	var _arg0 *C.GtkScaleButton // out
	var _arg1 *C.GtkAdjustment  // out

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_scale_button_set_adjustment(_arg0, _arg1)
}

func (b scaleButton) SetIconsScaleButton(icons []string) {
	var _arg0 *C.GtkScaleButton // out
	var _arg1 **C.char

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
	_arg1 = (**C.char)(C.malloc(C.ulong(len(icons)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(icons))
		for i := range icons {
			out[i] = (*C.char)(C.CString(icons[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_scale_button_set_icons(_arg0, _arg1)
}

func (b scaleButton) SetValueScaleButton(value float64) {
	var _arg0 *C.GtkScaleButton // out
	var _arg1 C.double          // out

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
	_arg1 = (C.double)(value)

	C.gtk_scale_button_set_value(_arg0, _arg1)
}

func (s scaleButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s scaleButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s scaleButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s scaleButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s scaleButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s scaleButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s scaleButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b scaleButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o scaleButton) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o scaleButton) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// Scrollbar: the `GtkScrollbar` widget is a horizontal or vertical scrollbar.
//
// !An example GtkScrollbar (scrollbar.png)
//
// Its position and movement are controlled by the adjustment that is passed to
// or created by [ctor@Gtk.Scrollbar.new]. See [class.Gtk.Adjustment] for more
// details. The [property@Gtk.Adjustment:value] field sets the position of the
// thumb and must be between [property@Gtk.Adjustment:lower] and
// [property@Gtk.Adjustment:upper] - [property@Gtk.Adjustment:page-size]. The
// [property@Gtk.Adjustment:page-size] represents the size of the visible
// scrollable area.
//
// The fields [property@Gtk.Adjustment:step-increment] and
// [property@Gtk.Adjustment:page-increment] fields are added to or subtracted
// from the [property@Gtk.Adjustment:value] when the user asks to move by a step
// (using e.g. the cursor arrow keys) or by a page (using e.g. the Page Down/Up
// keys).
//
//
// CSS nodes
//
// ` scrollbar  range[.fine-tune]  trough  slider `
//
// `GtkScrollbar` has a main CSS node with name scrollbar and a subnode for its
// contents. The main node gets the .horizontal or .vertical style classes
// applied, depending on the scrollbar's orientation.
//
// The range node gets the style class .fine-tune added when the scrollbar is in
// 'fine-tuning' mode.
//
// Other style classes that may be added to scrollbars inside
// [class@Gtk.ScrolledWindow] include the positional classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering).
//
//
// Accessibility
//
// `GtkScrollbar` uses the GTK_ACCESSIBLE_ROLE_SCROLLBAR role.
type Scrollbar interface {
	Widget
	Orientable

	// Adjustment returns the scrollbar's adjustment.
	Adjustment() Adjustment
	// SetAdjustmentScrollbar makes the scrollbar use the given adjustment.
	SetAdjustmentScrollbar(adjustment Adjustment)
}

// scrollbar implements the Scrollbar class.
type scrollbar struct {
	Widget
}

// WrapScrollbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrollbar(obj *externglib.Object) Scrollbar {
	return scrollbar{
		Widget: WrapWidget(obj),
	}
}

func marshalScrollbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrollbar(obj), nil
}

// NewScrollbar creates a new scrollbar with the given orientation.
func NewScrollbar(orientation Orientation, adjustment Adjustment) Scrollbar {
	var _arg1 C.GtkOrientation // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	_cret = C.gtk_scrollbar_new(_arg1, _arg2)

	var _scrollbar Scrollbar // out

	_scrollbar = WrapScrollbar(externglib.Take(unsafe.Pointer(_cret)))

	return _scrollbar
}

func (s scrollbar) Adjustment() Adjustment {
	var _arg0 *C.GtkScrollbar  // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkScrollbar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollbar_get_adjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (s scrollbar) SetAdjustmentScrollbar(adjustment Adjustment) {
	var _arg0 *C.GtkScrollbar  // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkScrollbar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_scrollbar_set_adjustment(_arg0, _arg1)
}

func (s scrollbar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s scrollbar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s scrollbar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s scrollbar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s scrollbar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s scrollbar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s scrollbar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b scrollbar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o scrollbar) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o scrollbar) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// ScrolledWindow: `GtkScrolledWindow` is a container that makes its child
// scrollable.
//
// It does so using either internally added scrollbars or externally associated
// adjustments, and optionally draws a frame around the child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// [iface@Gtk.Scrollable] interface, are added directly. For other types of
// widget, the class [class@Gtk.Viewport] acts as an adaptor, giving
// scrollability to other widgets. [method@Gtk.ScrolledWindow.set_child]
// intelligently accounts for whether or not the added child is a
// `GtkScrollable`. If it isnt, then it wraps the child in a `GtkViewport`.
// Therefore, you can just add any child widget and not worry about the details.
//
// If [method@Gtk.ScrolledWindow.set_child] has added a `GtkViewport` for you,
// you can remove both your added child widget from the `GtkViewport`, and the
// `GtkViewport` from the `GtkScrolledWindow`, like this:
//
// `c GtkWidget *scrolled_window = gtk_scrolled_window_new (); GtkWidget
// *child_widget = gtk_button_new ();
//
// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
// // add a GtkViewport. gtk_box_append (GTK_BOX (scrolled_window),
// // child_widget);
//
// // Either of these will result in child_widget being unparented:
// // gtk_box_remove (GTK_BOX (scrolled_window), child_widget); // or
// // gtk_box_remove (GTK_BOX (scrolled_window), gtk_bin_get_child (GTK_BIN
// // (scrolled_window))); `
//
// Unless [property@Gtk.ScrolledWindow:hscrollbar-policy] and
// [property@Gtk.ScrolledWindow:vscrollbar-policy] are GTK_POLICY_NEVER or
// GTK_POLICY_EXTERNAL, `GtkScrolledWindow` adds internal `GtkScrollbar` widgets
// around its child. The scroll position of the child, and if applicable the
// scrollbars, is controlled by the [property@Gtk.ScrolledWindow:hadjustment]
// and [property@Gtk.ScrolledWindow:vadjustment] that are associated with the
// `GtkScrolledWindow`. See the docs on [class@Gtk.Scrollbar] for the details,
// but note that the step_increment and page_increment fields are only
// effective if the policy causes scrollbars to be present.
//
// If a `GtkScrolledWindow` doesnt behave quite as you would like, or doesnt
// have exactly the right layout, its very possible to set up your own
// scrolling with `GtkScrollbar` and for example a `GtkGrid`.
//
//
// Touch support
//
// `GtkScrolledWindow` has built-in support for touch devices. When a
// touchscreen is used, swiping will move the scrolled window, and will expose
// 'kinetic' behavior. This can be turned off with the
// [property@Gtk.ScrolledWindow:kinetic-scrolling] property if it is undesired.
//
// `GtkScrolledWindow` also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// [signal@Gtk.ScrolledWindow::edge-overshot] signal.
//
// If no mouse device is present, the scrollbars will overlaid as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the [property@Gtk.ScrolledWindow:overlay-scrolling] property.
//
//
// CSS nodes
//
// `GtkScrolledWindow` has a main CSS node with name scrolledwindow. It gets a
// .frame style class added when [property@Gtk.ScrolledWindow:has-frame] is
// true.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// `GtkScrolledWindow` also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
//
//
// Accessibility
//
// `GtkScrolledWindow` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type ScrolledWindow interface {
	Widget

	// Child gets the child widget of @scrolled_window.
	Child() Widget
	// HAdjustment returns the horizontal scrollbars adjustment.
	//
	// This is the adjustment used to connect the horizontal scrollbar to the
	// child widgets horizontal scroll functionality.
	HAdjustment() Adjustment
	// HasFrame gets whether the scrolled window draws a frame.
	HasFrame() bool
	// HScrollbar returns the horizontal scrollbar of @scrolled_window.
	HScrollbar() Widget
	// KineticScrolling returns the specified kinetic scrolling behavior.
	KineticScrolling() bool
	// MaxContentHeight returns the maximum content height set.
	MaxContentHeight() int
	// MaxContentWidth returns the maximum content width set.
	MaxContentWidth() int
	// MinContentHeight gets the minimal content height of @scrolled_window.
	MinContentHeight() int
	// MinContentWidth gets the minimum content width of @scrolled_window.
	MinContentWidth() int
	// OverlayScrolling returns whether overlay scrolling is enabled for this
	// scrolled window.
	OverlayScrolling() bool
	// Placement gets the placement of the contents with respect to the
	// scrollbars.
	Placement() CornerType
	// Policy retrieves the current policy values for the horizontal and
	// vertical scrollbars.
	//
	// See [method@Gtk.ScrolledWindow.set_policy].
	Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// PropagateNaturalHeight reports whether the natural height of the child
	// will be calculated and propagated through the scrolled windows requested
	// natural height.
	PropagateNaturalHeight() bool
	// PropagateNaturalWidth reports whether the natural width of the child will
	// be calculated and propagated through the scrolled windows requested
	// natural width.
	PropagateNaturalWidth() bool
	// VAdjustment returns the vertical scrollbars adjustment.
	//
	// This is the adjustment used to connect the vertical scrollbar to the
	// child widgets vertical scroll functionality.
	VAdjustment() Adjustment
	// VScrollbar returns the vertical scrollbar of @scrolled_window.
	VScrollbar() Widget
	// SetChildScrolledWindow sets the child widget of @scrolled_window.
	SetChildScrolledWindow(child Widget)
	// SetHAdjustmentScrolledWindow sets the `GtkAdjustment` for the horizontal
	// scrollbar.
	SetHAdjustmentScrolledWindow(hadjustment Adjustment)
	// SetHasFrameScrolledWindow changes the frame drawn around the contents of
	// @scrolled_window.
	SetHasFrameScrolledWindow(hasFrame bool)
	// SetKineticScrollingScrolledWindow turns kinetic scrolling on or off.
	//
	// Kinetic scrolling only applies to devices with source
	// GDK_SOURCE_TOUCHSCREEN.
	SetKineticScrollingScrolledWindow(kineticScrolling bool)
	// SetMaxContentHeightScrolledWindow sets the maximum height that
	// @scrolled_window should keep visible.
	//
	// The @scrolled_window will grow up to this height before it starts
	// scrolling the content.
	//
	// It is a programming error to set the maximum content height to a value
	// smaller than [property@Gtk.ScrolledWindow:min-content-height].
	SetMaxContentHeightScrolledWindow(height int)
	// SetMaxContentWidthScrolledWindow sets the maximum width that
	// @scrolled_window should keep visible.
	//
	// The @scrolled_window will grow up to this width before it starts
	// scrolling the content.
	//
	// It is a programming error to set the maximum content width to a value
	// smaller than [property@Gtk.ScrolledWindow:min-content-width].
	SetMaxContentWidthScrolledWindow(width int)
	// SetMinContentHeightScrolledWindow sets the minimum height that
	// @scrolled_window should keep visible.
	//
	// Note that this can and (usually will) be smaller than the minimum size of
	// the content.
	//
	// It is a programming error to set the minimum content height to a value
	// greater than [property@Gtk.ScrolledWindow:max-content-height].
	SetMinContentHeightScrolledWindow(height int)
	// SetMinContentWidthScrolledWindow sets the minimum width that
	// @scrolled_window should keep visible.
	//
	// Note that this can and (usually will) be smaller than the minimum size of
	// the content.
	//
	// It is a programming error to set the minimum content width to a value
	// greater than [property@Gtk.ScrolledWindow:max-content-width].
	SetMinContentWidthScrolledWindow(width int)
	// SetOverlayScrollingScrolledWindow enables or disables overlay scrolling
	// for this scrolled window.
	SetOverlayScrollingScrolledWindow(overlayScrolling bool)
	// SetPlacementScrolledWindow sets the placement of the contents with
	// respect to the scrollbars for the scrolled window.
	//
	// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
	// with the scrollbars underneath and to the right. Other values in
	// [enum@Gtk.CornerType] are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT,
	// and GTK_CORNER_BOTTOM_RIGHT.
	//
	// See also [method@Gtk.ScrolledWindow.get_placement] and
	// [method@Gtk.ScrolledWindow.unset_placement].
	SetPlacementScrolledWindow(windowPlacement CornerType)
	// SetPolicyScrolledWindow sets the scrollbar policy for the horizontal and
	// vertical scrollbars.
	//
	// The policy determines when the scrollbar should appear; it is a value
	// from the [enum@Gtk.PolicyType] enumeration. If GTK_POLICY_ALWAYS, the
	// scrollbar is always present; if GTK_POLICY_NEVER, the scrollbar is never
	// present; if GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed
	// (that is, if the slider part of the bar would be smaller than the trough
	//  the display is larger than the page size).
	SetPolicyScrolledWindow(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// SetPropagateNaturalHeightScrolledWindow sets whether the natural height
	// of the child should be calculated and propagated through the scrolled
	// windows requested natural height.
	SetPropagateNaturalHeightScrolledWindow(propagate bool)
	// SetPropagateNaturalWidthScrolledWindow sets whether the natural width of
	// the child should be calculated and propagated through the scrolled
	// windows requested natural width.
	SetPropagateNaturalWidthScrolledWindow(propagate bool)
	// SetVAdjustmentScrolledWindow sets the `GtkAdjustment` for the vertical
	// scrollbar.
	SetVAdjustmentScrolledWindow(vadjustment Adjustment)
	// UnsetPlacementScrolledWindow unsets the placement of the contents with
	// respect to the scrollbars.
	//
	// If no window placement is set for a scrolled window, it defaults to
	// GTK_CORNER_TOP_LEFT.
	UnsetPlacementScrolledWindow()
}

// scrolledWindow implements the ScrolledWindow class.
type scrolledWindow struct {
	Widget
}

// WrapScrolledWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrolledWindow(obj *externglib.Object) ScrolledWindow {
	return scrolledWindow{
		Widget: WrapWidget(obj),
	}
}

func marshalScrolledWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrolledWindow(obj), nil
}

// NewScrolledWindow creates a new scrolled window.
func NewScrolledWindow() ScrolledWindow {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_scrolled_window_new()

	var _scrolledWindow ScrolledWindow // out

	_scrolledWindow = WrapScrolledWindow(externglib.Take(unsafe.Pointer(_cret)))

	return _scrolledWindow
}

func (s scrolledWindow) Child() Widget {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s scrolledWindow) HAdjustment() Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (s scrolledWindow) HasFrame() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_has_frame(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) HScrollbar() Widget {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_hscrollbar(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s scrolledWindow) KineticScrolling() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_kinetic_scrolling(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) MaxContentHeight() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_max_content_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s scrolledWindow) MaxContentWidth() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_max_content_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s scrolledWindow) MinContentHeight() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_min_content_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s scrolledWindow) MinContentWidth() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_min_content_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s scrolledWindow) OverlayScrolling() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_overlay_scrolling(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) Placement() CornerType {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.GtkCornerType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_placement(_arg0)

	var _cornerType CornerType // out

	_cornerType = CornerType(_cret)

	return _cornerType
}

func (s scrolledWindow) Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // in
	var _arg2 C.GtkPolicyType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	C.gtk_scrolled_window_get_policy(_arg0, &_arg1, &_arg2)

	var _hscrollbarPolicy PolicyType // out
	var _vscrollbarPolicy PolicyType // out

	_hscrollbarPolicy = PolicyType(_arg1)
	_vscrollbarPolicy = PolicyType(_arg2)

	return _hscrollbarPolicy, _vscrollbarPolicy
}

func (s scrolledWindow) PropagateNaturalHeight() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_propagate_natural_height(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) PropagateNaturalWidth() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_propagate_natural_width(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) VAdjustment() Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (s scrolledWindow) VScrollbar() Widget {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_vscrollbar(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s scrolledWindow) SetChildScrolledWindow(child Widget) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_scrolled_window_set_child(_arg0, _arg1)
}

func (s scrolledWindow) SetHAdjustmentScrolledWindow(hadjustment Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

	C.gtk_scrolled_window_set_hadjustment(_arg0, _arg1)
}

func (s scrolledWindow) SetHasFrameScrolledWindow(hasFrame bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if hasFrame {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_has_frame(_arg0, _arg1)
}

func (s scrolledWindow) SetKineticScrollingScrolledWindow(kineticScrolling bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if kineticScrolling {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_kinetic_scrolling(_arg0, _arg1)
}

func (s scrolledWindow) SetMaxContentHeightScrolledWindow(height int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(height)

	C.gtk_scrolled_window_set_max_content_height(_arg0, _arg1)
}

func (s scrolledWindow) SetMaxContentWidthScrolledWindow(width int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(width)

	C.gtk_scrolled_window_set_max_content_width(_arg0, _arg1)
}

func (s scrolledWindow) SetMinContentHeightScrolledWindow(height int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(height)

	C.gtk_scrolled_window_set_min_content_height(_arg0, _arg1)
}

func (s scrolledWindow) SetMinContentWidthScrolledWindow(width int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(width)

	C.gtk_scrolled_window_set_min_content_width(_arg0, _arg1)
}

func (s scrolledWindow) SetOverlayScrollingScrolledWindow(overlayScrolling bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if overlayScrolling {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_overlay_scrolling(_arg0, _arg1)
}

func (s scrolledWindow) SetPlacementScrolledWindow(windowPlacement CornerType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkCornerType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkCornerType)(windowPlacement)

	C.gtk_scrolled_window_set_placement(_arg0, _arg1)
}

func (s scrolledWindow) SetPolicyScrolledWindow(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // out
	var _arg2 C.GtkPolicyType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPolicyType)(hscrollbarPolicy)
	_arg2 = (C.GtkPolicyType)(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy(_arg0, _arg1, _arg2)
}

func (s scrolledWindow) SetPropagateNaturalHeightScrolledWindow(propagate bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_propagate_natural_height(_arg0, _arg1)
}

func (s scrolledWindow) SetPropagateNaturalWidthScrolledWindow(propagate bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_propagate_natural_width(_arg0, _arg1)
}

func (s scrolledWindow) SetVAdjustmentScrolledWindow(vadjustment Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	C.gtk_scrolled_window_set_vadjustment(_arg0, _arg1)
}

func (s scrolledWindow) UnsetPlacementScrolledWindow() {
	var _arg0 *C.GtkScrolledWindow // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	C.gtk_scrolled_window_unset_placement(_arg0)
}

func (s scrolledWindow) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s scrolledWindow) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s scrolledWindow) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s scrolledWindow) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s scrolledWindow) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s scrolledWindow) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s scrolledWindow) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b scrolledWindow) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// SearchBar: `GtkSearchBar` is a container made to have a search entry.
//
// !An example GtkSearchBar (search-bar.png)
//
// It can also contain additional widgets, such as drop-down menus, or buttons.
// The search bar would appear when a search is started through typing on the
// keyboard, or the applications search mode is toggled on.
//
// For keyboard presses to start a search, the search bar must be told of a
// widget to capture key events from through
// [method@Gtk.SearchBar.set_key_capture_widget]. This widget will typically be
// the top-level window, or a parent container of the search bar. Common
// shortcuts such as Ctrl+F should be handled as an application action, or
// through the menu items.
//
// You will also need to tell the search bar about which entry you are using as
// your search entry using [method@Gtk.SearchBar.connect_entry].
//
//
// Creating a search bar
//
// The following example shows you how to create a more complex search entry.
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
//
//
// CSS nodes
//
// ` searchbar  revealer  box  [child]  [button.close] `
//
// `GtkSearchBar` has a main CSS node with name searchbar. It has a child node
// with name revealer that contains a node with name box. The box node contains
// both the CSS node of the child widget as well as an optional button node
// which gets the .close style class applied.
//
//
// Accessibility
//
// `GtkSearchBar` uses the GTK_ACCESSIBLE_ROLE_SEARCH role.
type SearchBar interface {
	Widget

	// ConnectEntrySearchBar connects the `GtkEditable widget passed as the one
	// to be used in this search bar.
	//
	// The entry should be a descendant of the search bar. Calling this function
	// manually is only required if the entry isnt the direct child of the
	// search bar (as in our main example).
	ConnectEntrySearchBar(entry Editable)
	// Child gets the child widget of @bar.
	Child() Widget
	// KeyCaptureWidget gets the widget that @bar is capturing key events from.
	KeyCaptureWidget() Widget
	// SearchMode returns whether the search mode is on or off.
	SearchMode() bool
	// ShowCloseButton returns whether the close button is shown.
	ShowCloseButton() bool
	// SetChildSearchBar sets the child widget of @bar.
	SetChildSearchBar(child Widget)
	// SetKeyCaptureWidgetSearchBar sets @widget as the widget that @bar will
	// capture key events from.
	//
	// If key events are handled by the search bar, the bar will be shown, and
	// the entry populated with the entered text.
	//
	// Note that despite the name of this function, the events are only
	// 'captured' in the bubble phase, which means that editable child widgets
	// of @widget will receive text input before it gets captured. If that is
	// not desired, you can capture and forward the events yourself with
	// [method@Gtk.EventControllerKey.forward].
	SetKeyCaptureWidgetSearchBar(widget Widget)
	// SetSearchModeSearchBar switches the search mode on or off.
	SetSearchModeSearchBar(searchMode bool)
	// SetShowCloseButtonSearchBar shows or hides the close button.
	//
	// Applications that already have a search toggle button should not show a
	// close button in their search bar, as it duplicates the role of the toggle
	// button.
	SetShowCloseButtonSearchBar(visible bool)
}

// searchBar implements the SearchBar class.
type searchBar struct {
	Widget
}

// WrapSearchBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchBar(obj *externglib.Object) SearchBar {
	return searchBar{
		Widget: WrapWidget(obj),
	}
}

func marshalSearchBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchBar(obj), nil
}

// NewSearchBar creates a `GtkSearchBar`.
//
// You will need to tell it about which widget is going to be your text entry
// using [method@Gtk.SearchBar.connect_entry].
func NewSearchBar() SearchBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_search_bar_new()

	var _searchBar SearchBar // out

	_searchBar = WrapSearchBar(externglib.Take(unsafe.Pointer(_cret)))

	return _searchBar
}

func (b searchBar) ConnectEntrySearchBar(entry Editable) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 *C.GtkEditable  // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkEditable)(unsafe.Pointer(entry.Native()))

	C.gtk_search_bar_connect_entry(_arg0, _arg1)
}

func (b searchBar) Child() Widget {
	var _arg0 *C.GtkSearchBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_search_bar_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (b searchBar) KeyCaptureWidget() Widget {
	var _arg0 *C.GtkSearchBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_search_bar_get_key_capture_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (b searchBar) SearchMode() bool {
	var _arg0 *C.GtkSearchBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_search_bar_get_search_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b searchBar) ShowCloseButton() bool {
	var _arg0 *C.GtkSearchBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_search_bar_get_show_close_button(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b searchBar) SetChildSearchBar(child Widget) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_search_bar_set_child(_arg0, _arg1)
}

func (b searchBar) SetKeyCaptureWidgetSearchBar(widget Widget) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_search_bar_set_key_capture_widget(_arg0, _arg1)
}

func (b searchBar) SetSearchModeSearchBar(searchMode bool) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	if searchMode {
		_arg1 = C.TRUE
	}

	C.gtk_search_bar_set_search_mode(_arg0, _arg1)
}

func (b searchBar) SetShowCloseButtonSearchBar(visible bool) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_search_bar_set_show_close_button(_arg0, _arg1)
}

func (s searchBar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s searchBar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s searchBar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s searchBar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s searchBar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s searchBar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s searchBar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b searchBar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// SearchEntry: `GtkSearchEntry` is an entry widget that has been tailored for
// use as a search entry.
//
// The main API for interacting with a `GtkSearchEntry` as entry is the
// `GtkEditable` interface.
//
// !An example GtkSearchEntry (search-entry.png)
//
// It will show an inactive symbolic find icon when the search entry is empty,
// and a symbolic clear icon when there is text. Clicking on the clear icon
// will empty the search entry.
//
// To make filtering appear more reactive, it is a good idea to not react to
// every change in the entry text immediately, but only after a short delay. To
// support this, `GtkSearchEntry` emits the
// [signal@Gtk.SearchEntry::search-changed] signal which can be used instead of
// the [signal@Gtk.Editable::changed] signal.
//
// The [signal@Gtk.SearchEntry::previous-match],
// [signal@Gtk.SearchEntry::next-match] and
// [signal@Gtk.SearchEntry::stop-search] signals can be used to implement moving
// between search results and ending the search.
//
// Often, `GtkSearchEntry` will be fed events by means of being placed inside a
// [class@Gtk.SearchBar]. If that is not the case, you can use
// [method@Gtk.SearchEntry.set_key_capture_widget] to let it capture key input
// from another widget.
//
// `GtkSearchEntry` provides only minimal API and should be used with the
// [iface@Gtk.Editable] API.
//
//
// CSS Nodes
//
// ` entry.search  text `
//
// `GtkSearchEntry` has a single CSS node with name entry that carries a
// `.search` style class, and the text node is a child of that.
//
//
// Accessibility
//
// `GtkSearchEntry` uses the GTK_ACCESSIBLE_ROLE_SEARCH_BOX role.
type SearchEntry interface {
	Editable

	// KeyCaptureWidget gets the widget that @entry is capturing key events
	// from.
	KeyCaptureWidget() Widget
	// SetKeyCaptureWidgetSearchEntry sets @widget as the widget that @entry
	// will capture key events from.
	//
	// Key events are consumed by the search entry to start or continue a
	// search.
	//
	// If the entry is part of a `GtkSearchBar`, it is preferable to call
	// [method@Gtk.SearchBar.set_key_capture_widget] instead, which will reveal
	// the entry in addition to triggering the search entry.
	//
	// Note that despite the name of this function, the events are only
	// 'captured' in the bubble phase, which means that editable child widgets
	// of @widget will receive text input before it gets captured. If that is
	// not desired, you can capture and forward the events yourself with
	// [method@Gtk.EventControllerKey.forward].
	SetKeyCaptureWidgetSearchEntry(widget Widget)
}

// searchEntry implements the SearchEntry class.
type searchEntry struct {
	Widget
}

// WrapSearchEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchEntry(obj *externglib.Object) SearchEntry {
	return searchEntry{
		Widget: WrapWidget(obj),
	}
}

func marshalSearchEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchEntry(obj), nil
}

// NewSearchEntry creates a `GtkSearchEntry`.
func NewSearchEntry() SearchEntry {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_search_entry_new()

	var _searchEntry SearchEntry // out

	_searchEntry = WrapSearchEntry(externglib.Take(unsafe.Pointer(_cret)))

	return _searchEntry
}

func (e searchEntry) KeyCaptureWidget() Widget {
	var _arg0 *C.GtkSearchEntry // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkSearchEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_search_entry_get_key_capture_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (e searchEntry) SetKeyCaptureWidgetSearchEntry(widget Widget) {
	var _arg0 *C.GtkSearchEntry // out
	var _arg1 *C.GtkWidget      // out

	_arg0 = (*C.GtkSearchEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_search_entry_set_key_capture_widget(_arg0, _arg1)
}

func (s searchEntry) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s searchEntry) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s searchEntry) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s searchEntry) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s searchEntry) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s searchEntry) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s searchEntry) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b searchEntry) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (e searchEntry) DeleteSelection() {
	WrapEditable(gextras.InternObject(e)).DeleteSelection()
}

func (e searchEntry) DeleteText(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).DeleteText(startPos, endPos)
}

func (e searchEntry) FinishDelegate() {
	WrapEditable(gextras.InternObject(e)).FinishDelegate()
}

func (e searchEntry) Alignment() float32 {
	return WrapEditable(gextras.InternObject(e)).Alignment()
}

func (e searchEntry) Chars(startPos int, endPos int) string {
	return WrapEditable(gextras.InternObject(e)).Chars(startPos, endPos)
}

func (e searchEntry) Delegate() Editable {
	return WrapEditable(gextras.InternObject(e)).Delegate()
}

func (e searchEntry) Editable() bool {
	return WrapEditable(gextras.InternObject(e)).Editable()
}

func (e searchEntry) EnableUndo() bool {
	return WrapEditable(gextras.InternObject(e)).EnableUndo()
}

func (e searchEntry) MaxWidthChars() int {
	return WrapEditable(gextras.InternObject(e)).MaxWidthChars()
}

func (e searchEntry) Position() int {
	return WrapEditable(gextras.InternObject(e)).Position()
}

func (e searchEntry) SelectionBounds() (startPos int, endPos int, ok bool) {
	return WrapEditable(gextras.InternObject(e)).SelectionBounds()
}

func (e searchEntry) Text() string {
	return WrapEditable(gextras.InternObject(e)).Text()
}

func (e searchEntry) WidthChars() int {
	return WrapEditable(gextras.InternObject(e)).WidthChars()
}

func (e searchEntry) InitDelegate() {
	WrapEditable(gextras.InternObject(e)).InitDelegate()
}

func (e searchEntry) SelectRegion(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).SelectRegion(startPos, endPos)
}

func (e searchEntry) SetAlignment(xalign float32) {
	WrapEditable(gextras.InternObject(e)).SetAlignment(xalign)
}

func (e searchEntry) SetEditable(isEditable bool) {
	WrapEditable(gextras.InternObject(e)).SetEditable(isEditable)
}

func (e searchEntry) SetEnableUndo(enableUndo bool) {
	WrapEditable(gextras.InternObject(e)).SetEnableUndo(enableUndo)
}

func (e searchEntry) SetMaxWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetMaxWidthChars(nChars)
}

func (e searchEntry) SetPosition(position int) {
	WrapEditable(gextras.InternObject(e)).SetPosition(position)
}

func (e searchEntry) SetText(text string) {
	WrapEditable(gextras.InternObject(e)).SetText(text)
}

func (e searchEntry) SetWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetWidthChars(nChars)
}

// SelectionFilterModel: `GtkSelectionFilterModel` is a list model that presents
// the selection from a `GtkSelectionModel`.
type SelectionFilterModel interface {
	gio.ListModel

	// Model gets the model currently filtered or nil if none.
	Model() SelectionModel
	// SetModelSelectionFilterModel sets the model to be filtered.
	//
	// Note that GTK makes no effort to ensure that @model conforms to the item
	// type of @self. It assumes that the caller knows what they are doing and
	// have set up an appropriate filter to ensure that item types match.
	SetModelSelectionFilterModel(model SelectionModel)
}

// selectionFilterModel implements the SelectionFilterModel class.
type selectionFilterModel struct {
	gextras.Objector
}

// WrapSelectionFilterModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapSelectionFilterModel(obj *externglib.Object) SelectionFilterModel {
	return selectionFilterModel{
		Objector: obj,
	}
}

func marshalSelectionFilterModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSelectionFilterModel(obj), nil
}

// NewSelectionFilterModel creates a new `GtkSelectionFilterModel` that will
// include the selected items from the underlying selection model.
func NewSelectionFilterModel(model SelectionModel) SelectionFilterModel {
	var _arg1 *C.GtkSelectionModel       // out
	var _cret *C.GtkSelectionFilterModel // in

	_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_selection_filter_model_new(_arg1)

	var _selectionFilterModel SelectionFilterModel // out

	_selectionFilterModel = WrapSelectionFilterModel(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _selectionFilterModel
}

func (s selectionFilterModel) Model() SelectionModel {
	var _arg0 *C.GtkSelectionFilterModel // out
	var _cret *C.GtkSelectionModel       // in

	_arg0 = (*C.GtkSelectionFilterModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_filter_model_get_model(_arg0)

	var _selectionModel SelectionModel // out

	_selectionModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SelectionModel)

	return _selectionModel
}

func (s selectionFilterModel) SetModelSelectionFilterModel(model SelectionModel) {
	var _arg0 *C.GtkSelectionFilterModel // out
	var _arg1 *C.GtkSelectionModel       // out

	_arg0 = (*C.GtkSelectionFilterModel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

	C.gtk_selection_filter_model_set_model(_arg0, _arg1)
}

// Separator: `GtkSeparator` is a horizontal or vertical separator widget.
//
// !An example GtkSeparator (separators.png)
//
// A `GtkSeparator` can be used to group the widgets within a window. It
// displays a line with a shadow to make it appear sunken into the interface.
//
//
// CSS nodes
//
// `GtkSeparator` has a single CSS node with name separator. The node gets one
// of the .horizontal or .vertical style classes.
//
//
// Accessibility
//
// `GtkSeparator` uses the K_ACCESSIBLE_ROLE_SEPARATOR role.
type Separator interface {
	Widget
	Orientable
}

// separator implements the Separator class.
type separator struct {
	Widget
}

// WrapSeparator wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeparator(obj *externglib.Object) Separator {
	return separator{
		Widget: WrapWidget(obj),
	}
}

func marshalSeparator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeparator(obj), nil
}

// NewSeparator creates a new `GtkSeparator` with the given orientation.
func NewSeparator(orientation Orientation) Separator {
	var _arg1 C.GtkOrientation // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_separator_new(_arg1)

	var _separator Separator // out

	_separator = WrapSeparator(externglib.Take(unsafe.Pointer(_cret)))

	return _separator
}

func (s separator) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s separator) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s separator) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s separator) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s separator) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s separator) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s separator) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b separator) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o separator) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o separator) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// Settings: `GtkSettings` provides a mechanism to share global settings between
// applications.
//
// On the X window system, this sharing is realized by an XSettings
// (http://www.freedesktop.org/wiki/Specifications/xsettings-spec) manager that
// is usually part of the desktop environment, along with utilities that let the
// user change these settings.
//
// On Wayland, the settings are obtained either via a settings portal, or by
// reading desktop settings from DConf.
//
// In the absence of these sharing mechanisms, GTK reads default values for
// settings from `settings.ini` files in `/etc/gtk-4.0`,
// `$XDG_CONFIG_DIRS/gtk-4.0` and `$XDG_CONFIG_HOME/gtk-4.0`. These files must
// be valid key files (see `GKeyFile`), and have a section called Settings.
// Themes can also provide default values for settings by installing a
// `settings.ini` file next to their `gtk.css` file.
//
// Applications can override system-wide settings by setting the property of the
// `GtkSettings` object with g_object_set(). This should be restricted to
// special cases though; `GtkSettings` are not meant as an application
// configuration facility.
//
// There is one `GtkSettings` instance per display. It can be obtained with
// [type_func@GtkSettings.get_for_display], but in many cases, it is more
// convenient to use [method@Gtk.Widget.get_settings].
type Settings interface {
	StyleProvider

	// ResetPropertySettings undoes the effect of calling g_object_set() to
	// install an application-specific value for a setting.
	//
	// After this call, the setting will again follow the session-wide value for
	// this setting.
	ResetPropertySettings(name string)
}

// settings implements the Settings class.
type settings struct {
	gextras.Objector
}

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return settings{
		Objector: obj,
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

func (s settings) ResetPropertySettings(name string) {
	var _arg0 *C.GtkSettings // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_settings_reset_property(_arg0, _arg1)
}

// Shortcut: a `GtkShortcut` describes a keyboard shortcut.
//
// It contains a description of how to trigger the shortcut via a
// [class@Gtk.ShortcutTrigger] and a way to activate the shortcut on a widget
// via a [class@Gtk.ShortcutAction].
//
// The actual work is usually done via [class@Gtk.ShortcutController], which
// decides if and when to activate a shortcut. Using that controller directly
// however is rarely necessary as various higher level convenience APIs exist on
// Widgets that make it easier to use shortcuts in GTK.
//
// `GtkShortcut` does provide functionality to make it easy for users to work
// with shortcuts, either by providing informational strings for display
// purposes or by allowing shortcuts to be configured.
type Shortcut interface {

	// Action gets the action that is activated by this shortcut.
	Action() ShortcutAction
	// Arguments gets the arguments that are passed when activating the
	// shortcut.
	Arguments() *glib.Variant
	// Trigger gets the trigger used to trigger @self.
	Trigger() ShortcutTrigger
	// SetActionShortcut sets the new action for @self to be @action.
	SetActionShortcut(action ShortcutAction)
	// SetArgumentsShortcut sets the arguments to pass when activating the
	// shortcut.
	SetArgumentsShortcut(args *glib.Variant)
	// SetTriggerShortcut sets the new trigger for @self to be @trigger.
	SetTriggerShortcut(trigger ShortcutTrigger)
}

// shortcut implements the Shortcut class.
type shortcut struct {
	gextras.Objector
}

// WrapShortcut wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcut(obj *externglib.Object) Shortcut {
	return shortcut{
		Objector: obj,
	}
}

func marshalShortcut(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcut(obj), nil
}

// NewShortcut creates a new `GtkShortcut` that is triggered by @trigger and
// then activates @action.
func NewShortcut(trigger ShortcutTrigger, action ShortcutAction) Shortcut {
	var _arg1 *C.GtkShortcutTrigger // out
	var _arg2 *C.GtkShortcutAction  // out
	var _cret *C.GtkShortcut        // in

	_arg1 = (*C.GtkShortcutTrigger)(unsafe.Pointer(trigger.Native()))
	_arg2 = (*C.GtkShortcutAction)(unsafe.Pointer(action.Native()))

	_cret = C.gtk_shortcut_new(_arg1, _arg2)

	var _shortcut Shortcut // out

	_shortcut = WrapShortcut(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shortcut
}

func (s shortcut) Action() ShortcutAction {
	var _arg0 *C.GtkShortcut       // out
	var _cret *C.GtkShortcutAction // in

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_get_action(_arg0)

	var _shortcutAction ShortcutAction // out

	_shortcutAction = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutAction)

	return _shortcutAction
}

func (s shortcut) Arguments() *glib.Variant {
	var _arg0 *C.GtkShortcut // out
	var _cret *C.GVariant    // in

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_get_arguments(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

func (s shortcut) Trigger() ShortcutTrigger {
	var _arg0 *C.GtkShortcut        // out
	var _cret *C.GtkShortcutTrigger // in

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_get_trigger(_arg0)

	var _shortcutTrigger ShortcutTrigger // out

	_shortcutTrigger = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutTrigger)

	return _shortcutTrigger
}

func (s shortcut) SetActionShortcut(action ShortcutAction) {
	var _arg0 *C.GtkShortcut       // out
	var _arg1 *C.GtkShortcutAction // out

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkShortcutAction)(unsafe.Pointer(action.Native()))

	C.gtk_shortcut_set_action(_arg0, _arg1)
}

func (s shortcut) SetArgumentsShortcut(args *glib.Variant) {
	var _arg0 *C.GtkShortcut // out
	var _arg1 *C.GVariant    // out

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(args.Native()))

	C.gtk_shortcut_set_arguments(_arg0, _arg1)
}

func (s shortcut) SetTriggerShortcut(trigger ShortcutTrigger) {
	var _arg0 *C.GtkShortcut        // out
	var _arg1 *C.GtkShortcutTrigger // out

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkShortcutTrigger)(unsafe.Pointer(trigger.Native()))

	C.gtk_shortcut_set_trigger(_arg0, _arg1)
}

// ShortcutAction: `GtkShortcutAction` encodes an action that can be triggered
// by a keyboard shortcut.
//
// `GtkShortcutActions` contain functions that allow easy presentation to end
// users as well as being printed for debugging.
//
// All `GtkShortcutActions` are immutable, you can only specify their properties
// during construction. If you want to change a action, you have to replace it
// with a new one. If you need to pass arguments to an action, these are
// specified by the higher-level `GtkShortcut` object.
//
// To activate a `GtkShortcutAction` manually,
// [method@Gtk.ShortcutAction.activate] can be called.
//
// GTK provides various actions:
//
//    - [class@Gtk.MnemonicAction]: a shortcut action that calls
//      gtk_widget_mnemonic_activate()
//    - [class@Gtk.CallbackAction]: a shortcut action that invokes
//      a given callback
//    - [class@Gtk.SignalAction]: a shortcut action that emits a
//      given signal
//    - [class@Gtk.ActivateAction]: a shortcut action that calls
//      gtk_widget_activate()
//    - [class@Gtk.NamedAction]: a shortcut action that calls
//      gtk_widget_activate_action()
//    - [class@Gtk.NothingAction]: a shortcut action that does nothing
type ShortcutAction interface {

	// ActivateShortcutAction activates the action on the @widget with the given
	// @args.
	//
	// Note that some actions ignore the passed in @flags, @widget or @args.
	//
	// Activation of an action can fail for various reasons. If the action is
	// not supported by the @widget, if the @args don't match the action or if
	// the activation otherwise had no effect, false will be returned.
	ActivateShortcutAction(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool
	// String prints the given action into a human-readable string.
	//
	// This is a small wrapper around [method@Gtk.ShortcutAction.print] to help
	// when debugging.
	String() string
}

// shortcutAction implements the ShortcutAction class.
type shortcutAction struct {
	gextras.Objector
}

// WrapShortcutAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutAction(obj *externglib.Object) ShortcutAction {
	return shortcutAction{
		Objector: obj,
	}
}

func marshalShortcutAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutAction(obj), nil
}

// NewShortcutActionParseString tries to parse the given string into an action.
//
// On success, the parsed action is returned. When parsing failed, nil is
// returned.
//
// The accepted strings are:
//
// - `nothing`, for `GtkNothingAction` - `activate`, for `GtkActivateAction` -
// `mnemonic-activate`, for `GtkMnemonicAction` - `action(NAME)`, for a
// `GtkNamedAction` for the action named `NAME` - `signal(NAME)`, for a
// `GtkSignalAction` for the signal `NAME`
func NewShortcutActionParseString(_string string) ShortcutAction {
	var _arg1 *C.char              // out
	var _cret *C.GtkShortcutAction // in

	_arg1 = (*C.char)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_shortcut_action_parse_string(_arg1)

	var _shortcutAction ShortcutAction // out

	_shortcutAction = WrapShortcutAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shortcutAction
}

func (s shortcutAction) ActivateShortcutAction(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool {
	var _arg0 *C.GtkShortcutAction     // out
	var _arg1 C.GtkShortcutActionFlags // out
	var _arg2 *C.GtkWidget             // out
	var _arg3 *C.GVariant              // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkShortcutAction)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkShortcutActionFlags)(flags)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GVariant)(unsafe.Pointer(args.Native()))

	_cret = C.gtk_shortcut_action_activate(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s shortcutAction) String() string {
	var _arg0 *C.GtkShortcutAction // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkShortcutAction)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_action_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ShortcutController: `GtkShortcutController` is an event controller that
// manages shortcuts.
//
// Most common shortcuts are using this controller implicitly, e.g. by adding a
// mnemonic underline to a `GtkLabel`, or by installing a key binding using
// gtk_widget_class_add_binding(), or by adding accelerators to global actions
// using gtk_application_set_accels_for_action().
//
// But it is possible to create your own shortcut controller, and add shortcuts
// to it.
//
// `GtkShortcutController` implements `GListModel` for querying the shortcuts
// that have been added to it.
//
//
// GtkShortcutController as a GtkBuildable
//
// `GtkShortcutControllers` can be creates in ui files to set up shortcuts in
// the same place as the widgets.
//
// An example of a UI definition fragment with `GtkShortcutController`: `xml
// <object class='GtkButton'> <child> <object class='GtkShortcutController'>
// <property name='scope'>managed</property> <child> <object
// class='GtkShortcut'> <property
// name='trigger'>&amp;lt;Control&amp;gt;k</property> <property
// name='action'>activate</property> </object> </child> </object> </child>
// </object> `
//
// This example creates a [class@Gtk.ActivateAction] for triggering the
// `activate` signal of the `GtkButton`. See
// [ctor@Gtk.ShortcutAction.parse_string] for the syntax for other kinds of
// `GtkShortcutAction`. See [ctor@Gtk.ShortcutTrigger.parse_string] to learn
// more about the syntax for triggers.
type ShortcutController interface {
	EventController
	gio.ListModel
	Buildable

	// AddShortcutShortcutController adds @shortcut to the list of shortcuts
	// handled by @self.
	//
	// If this controller uses an external shortcut list, this function does
	// nothing.
	AddShortcutShortcutController(shortcut Shortcut)
	// MnemonicsModifiers gets the mnemonics modifiers for when this controller
	// activates its shortcuts.
	MnemonicsModifiers() gdk.ModifierType
	// Scope gets the scope for when this controller activates its shortcuts.
	// See gtk_shortcut_controller_set_scope() for details.
	Scope() ShortcutScope
	// RemoveShortcutShortcutController removes @shortcut from the list of
	// shortcuts handled by @self.
	//
	// If @shortcut had not been added to @controller or this controller uses an
	// external shortcut list, this function does nothing.
	RemoveShortcutShortcutController(shortcut Shortcut)
	// SetMnemonicsModifiersShortcutController sets the controller to have the
	// given @mnemonics_modifiers.
	//
	// The mnemonics modifiers determines which modifiers need to be pressed to
	// allow activation of shortcuts with mnemonics triggers.
	//
	// GTK normally uses the Alt modifier for mnemonics, except in PopoverMenus,
	// where mnemonics can be triggered without any modifiers. It should be very
	// rarely necessary to change this, and doing so is likely to interfere with
	// other shortcuts.
	//
	// This value is only relevant for local shortcut controllers. Global and
	// managed shortcut controllers will have their shortcuts activated from
	// other places which have their own modifiers for activating mnemonics.
	SetMnemonicsModifiersShortcutController(modifiers gdk.ModifierType)
	// SetScopeShortcutController sets the controller to have the given @scope.
	//
	// The scope allows shortcuts to be activated outside of the normal event
	// propagation. In particular, it allows installing global keyboard
	// shortcuts that can be activated even when a widget does not have focus.
	//
	// With GTK_SHORTCUT_SCOPE_LOCAL, shortcuts will only be activated when the
	// widget has focus.
	SetScopeShortcutController(scope ShortcutScope)
}

// shortcutController implements the ShortcutController class.
type shortcutController struct {
	EventController
}

// WrapShortcutController wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutController(obj *externglib.Object) ShortcutController {
	return shortcutController{
		EventController: WrapEventController(obj),
	}
}

func marshalShortcutController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutController(obj), nil
}

// NewShortcutController creates a new shortcut controller.
func NewShortcutController() ShortcutController {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_shortcut_controller_new()

	var _shortcutController ShortcutController // out

	_shortcutController = WrapShortcutController(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shortcutController
}

// NewShortcutControllerForModel creates a new shortcut controller that takes
// its shortcuts from the given list model.
//
// A controller created by this function does not let you add or remove
// individual shortcuts using the shortcut controller api, but you can change
// the contents of the model.
func NewShortcutControllerForModel(model gio.ListModel) ShortcutController {
	var _arg1 *C.GListModel         // out
	var _cret *C.GtkEventController // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_shortcut_controller_new_for_model(_arg1)

	var _shortcutController ShortcutController // out

	_shortcutController = WrapShortcutController(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shortcutController
}

func (s shortcutController) AddShortcutShortcutController(shortcut Shortcut) {
	var _arg0 *C.GtkShortcutController // out
	var _arg1 *C.GtkShortcut           // out

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkShortcut)(unsafe.Pointer(shortcut.Native()))

	C.gtk_shortcut_controller_add_shortcut(_arg0, _arg1)
}

func (s shortcutController) MnemonicsModifiers() gdk.ModifierType {
	var _arg0 *C.GtkShortcutController // out
	var _cret C.GdkModifierType        // in

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_controller_get_mnemonics_modifiers(_arg0)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

func (s shortcutController) Scope() ShortcutScope {
	var _arg0 *C.GtkShortcutController // out
	var _cret C.GtkShortcutScope       // in

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_controller_get_scope(_arg0)

	var _shortcutScope ShortcutScope // out

	_shortcutScope = ShortcutScope(_cret)

	return _shortcutScope
}

func (s shortcutController) RemoveShortcutShortcutController(shortcut Shortcut) {
	var _arg0 *C.GtkShortcutController // out
	var _arg1 *C.GtkShortcut           // out

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkShortcut)(unsafe.Pointer(shortcut.Native()))

	C.gtk_shortcut_controller_remove_shortcut(_arg0, _arg1)
}

func (s shortcutController) SetMnemonicsModifiersShortcutController(modifiers gdk.ModifierType) {
	var _arg0 *C.GtkShortcutController // out
	var _arg1 C.GdkModifierType        // out

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GdkModifierType)(modifiers)

	C.gtk_shortcut_controller_set_mnemonics_modifiers(_arg0, _arg1)
}

func (s shortcutController) SetScopeShortcutController(scope ShortcutScope) {
	var _arg0 *C.GtkShortcutController // out
	var _arg1 C.GtkShortcutScope       // out

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkShortcutScope)(scope)

	C.gtk_shortcut_controller_set_scope(_arg0, _arg1)
}

func (b shortcutController) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// ShortcutLabel: `GtkShortcutLabel` displays a single keyboard shortcut or
// gesture.
//
// The main use case for `GtkShortcutLabel` is inside a
// [class@Gtk.ShortcutsWindow].
type ShortcutLabel interface {
	Widget

	// Accelerator retrieves the current accelerator of @self.
	Accelerator() string
	// DisabledText retrieves the text that is displayed when no accelerator is
	// set.
	DisabledText() string
	// SetAcceleratorShortcutLabel sets the accelerator to be displayed by
	// @self.
	SetAcceleratorShortcutLabel(accelerator string)
	// SetDisabledTextShortcutLabel sets the text to be displayed by @self when
	// no accelerator is set.
	SetDisabledTextShortcutLabel(disabledText string)
}

// shortcutLabel implements the ShortcutLabel class.
type shortcutLabel struct {
	Widget
}

// WrapShortcutLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutLabel(obj *externglib.Object) ShortcutLabel {
	return shortcutLabel{
		Widget: WrapWidget(obj),
	}
}

func marshalShortcutLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutLabel(obj), nil
}

// NewShortcutLabel creates a new `GtkShortcutLabel` with @accelerator set.
func NewShortcutLabel(accelerator string) ShortcutLabel {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_shortcut_label_new(_arg1)

	var _shortcutLabel ShortcutLabel // out

	_shortcutLabel = WrapShortcutLabel(externglib.Take(unsafe.Pointer(_cret)))

	return _shortcutLabel
}

func (s shortcutLabel) Accelerator() string {
	var _arg0 *C.GtkShortcutLabel // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_label_get_accelerator(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s shortcutLabel) DisabledText() string {
	var _arg0 *C.GtkShortcutLabel // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_label_get_disabled_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s shortcutLabel) SetAcceleratorShortcutLabel(accelerator string) {
	var _arg0 *C.GtkShortcutLabel // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_shortcut_label_set_accelerator(_arg0, _arg1)
}

func (s shortcutLabel) SetDisabledTextShortcutLabel(disabledText string) {
	var _arg0 *C.GtkShortcutLabel // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(disabledText))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_shortcut_label_set_disabled_text(_arg0, _arg1)
}

func (s shortcutLabel) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s shortcutLabel) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s shortcutLabel) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s shortcutLabel) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s shortcutLabel) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s shortcutLabel) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s shortcutLabel) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b shortcutLabel) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// ShortcutTrigger: `GtkShortcutTrigger` tracks how a `GtkShortcut` should be
// activated.
//
// To find out if a `GtkShortcutTrigger` triggers, you can call
// [method@Gtk.ShortcutTrigger.trigger] on a `GdkEvent`.
//
// `GtkShortcutTriggers` contain functions that allow easy presentation to end
// users as well as being printed for debugging.
//
// All `GtkShortcutTriggers` are immutable, you can only specify their
// properties during construction. If you want to change a trigger, you have to
// replace it with a new one.
type ShortcutTrigger interface {

	// CompareShortcutTrigger: the types of @trigger1 and @trigger2 are
	// #gconstpointer only to allow use of this function as a Func.
	//
	// They must each be a `GtkShortcutTrigger`.
	CompareShortcutTrigger(trigger2 ShortcutTrigger) int
	// EqualShortcutTrigger checks if @trigger1 and @trigger2 trigger under the
	// same conditions.
	//
	// The types of @one and @two are #gconstpointer only to allow use of this
	// function with Table. They must each be a `GtkShortcutTrigger`.
	EqualShortcutTrigger(trigger2 ShortcutTrigger) bool
	// HashShortcutTrigger generates a hash value for a `GtkShortcutTrigger`.
	//
	// The output of this function is guaranteed to be the same for a given
	// value only per-process. It may change between different processor
	// architectures or even different versions of GTK. Do not use this function
	// as a basis for building protocols or file formats.
	//
	// The types of @trigger is #gconstpointer only to allow use of this
	// function with Table. They must each be a `GtkShortcutTrigger`.
	HashShortcutTrigger() uint
	// ToLabelShortcutTrigger gets textual representation for the given trigger.
	//
	// This function is returning a translated string for presentation to end
	// users for example in menu items or in help texts.
	//
	// The @display in use may influence the resulting string in various forms,
	// such as resolving hardware keycodes or by causing display-specific
	// modifier names.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	ToLabelShortcutTrigger(display gdk.Display) string
	// String prints the given trigger into a human-readable string.
	//
	// This is a small wrapper around [method@Gtk.ShortcutTrigger.print] to help
	// when debugging.
	String() string
	// TriggerShortcutTrigger checks if the given @event triggers @self.
	TriggerShortcutTrigger(event gdk.Event, enableMnemonics bool) gdk.KeyMatch
}

// shortcutTrigger implements the ShortcutTrigger class.
type shortcutTrigger struct {
	gextras.Objector
}

// WrapShortcutTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutTrigger(obj *externglib.Object) ShortcutTrigger {
	return shortcutTrigger{
		Objector: obj,
	}
}

func marshalShortcutTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutTrigger(obj), nil
}

// NewShortcutTriggerParseString tries to parse the given string into a trigger.
//
// On success, the parsed trigger is returned. When parsing failed, nil is
// returned.
//
// The accepted strings are:
//
//    - `never`, for `GtkNeverTrigger`
//    - a string parsed by gtk_accelerator_parse(), for a `GtkKeyvalTrigger`, e.g. `<Control>C`
//    - underscore, followed by a single character, for `GtkMnemonicTrigger`, e.g. `_l`
//    - two valid trigger strings, separated by a `|` character, for a
//      `GtkAlternativeTrigger`: `<Control>q|<Control>w`
//
// Note that you will have to escape the `<` and `>` characters when specifying
// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of `<`
// and `&gt;` instead of `>`.
func NewShortcutTriggerParseString(_string string) ShortcutTrigger {
	var _arg1 *C.char               // out
	var _cret *C.GtkShortcutTrigger // in

	_arg1 = (*C.char)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_shortcut_trigger_parse_string(_arg1)

	var _shortcutTrigger ShortcutTrigger // out

	_shortcutTrigger = WrapShortcutTrigger(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shortcutTrigger
}

func (t shortcutTrigger) CompareShortcutTrigger(trigger2 ShortcutTrigger) int {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.int           // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(trigger2.Native()))

	_cret = C.gtk_shortcut_trigger_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t shortcutTrigger) EqualShortcutTrigger(trigger2 ShortcutTrigger) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(trigger2.Native()))

	_cret = C.gtk_shortcut_trigger_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t shortcutTrigger) HashShortcutTrigger() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_shortcut_trigger_hash(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s shortcutTrigger) ToLabelShortcutTrigger(display gdk.Display) string {
	var _arg0 *C.GtkShortcutTrigger // out
	var _arg1 *C.GdkDisplay         // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkShortcutTrigger)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	_cret = C.gtk_shortcut_trigger_to_label(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (s shortcutTrigger) String() string {
	var _arg0 *C.GtkShortcutTrigger // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkShortcutTrigger)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_trigger_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (s shortcutTrigger) TriggerShortcutTrigger(event gdk.Event, enableMnemonics bool) gdk.KeyMatch {
	var _arg0 *C.GtkShortcutTrigger // out
	var _arg1 *C.GdkEvent           // out
	var _arg2 C.gboolean            // out
	var _cret C.GdkKeyMatch         // in

	_arg0 = (*C.GtkShortcutTrigger)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
	if enableMnemonics {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_shortcut_trigger_trigger(_arg0, _arg1, _arg2)

	var _keyMatch gdk.KeyMatch // out

	_keyMatch = gdk.KeyMatch(_cret)

	return _keyMatch
}

// ShortcutsGroup: a `GtkShortcutsGroup` represents a group of related keyboard
// shortcuts or gestures.
//
// The group has a title. It may optionally be associated with a view of the
// application, which can be used to show only relevant shortcuts depending on
// the application context.
//
// This widget is only meant to be used with [class@Gtk.ShortcutsWindow].
type ShortcutsGroup interface {
	Box
}

// shortcutsGroup implements the ShortcutsGroup class.
type shortcutsGroup struct {
	Box
}

// WrapShortcutsGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsGroup(obj *externglib.Object) ShortcutsGroup {
	return shortcutsGroup{
		Box: WrapBox(obj),
	}
}

func marshalShortcutsGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsGroup(obj), nil
}

func (s shortcutsGroup) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s shortcutsGroup) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s shortcutsGroup) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s shortcutsGroup) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s shortcutsGroup) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s shortcutsGroup) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s shortcutsGroup) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b shortcutsGroup) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o shortcutsGroup) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o shortcutsGroup) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// ShortcutsSection: a `GtkShortcutsSection` collects all the keyboard shortcuts
// and gestures for a major application mode.
//
// If your application needs multiple sections, you should give each section a
// unique [property@Gtk.ShortcutsSection:section-name] and a
// [property@Gtk.ShortcutsSection:title] that can be shown in the section
// selector of the [class@Gtk.ShortcutsWindow].
//
// The [property@Gtk.ShortcutsSection:max-height] property can be used to
// influence how the groups in the section are distributed over pages and
// columns.
//
// This widget is only meant to be used with [class@Gtk.ShortcutsWindow].
type ShortcutsSection interface {
	Box
}

// shortcutsSection implements the ShortcutsSection class.
type shortcutsSection struct {
	Box
}

// WrapShortcutsSection wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsSection(obj *externglib.Object) ShortcutsSection {
	return shortcutsSection{
		Box: WrapBox(obj),
	}
}

func marshalShortcutsSection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsSection(obj), nil
}

func (s shortcutsSection) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s shortcutsSection) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s shortcutsSection) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s shortcutsSection) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s shortcutsSection) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s shortcutsSection) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s shortcutsSection) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b shortcutsSection) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o shortcutsSection) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o shortcutsSection) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// ShortcutsShortcut: a `GtkShortcutsShortcut` represents a single keyboard
// shortcut or gesture with a short text.
//
// This widget is only meant to be used with `GtkShortcutsWindow`.
type ShortcutsShortcut interface {
	Widget
}

// shortcutsShortcut implements the ShortcutsShortcut class.
type shortcutsShortcut struct {
	Widget
}

// WrapShortcutsShortcut wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsShortcut(obj *externglib.Object) ShortcutsShortcut {
	return shortcutsShortcut{
		Widget: WrapWidget(obj),
	}
}

func marshalShortcutsShortcut(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsShortcut(obj), nil
}

func (s shortcutsShortcut) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s shortcutsShortcut) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s shortcutsShortcut) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s shortcutsShortcut) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s shortcutsShortcut) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s shortcutsShortcut) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s shortcutsShortcut) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b shortcutsShortcut) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// ShortcutsWindow: a `GtkShortcutsWindow` shows information about the keyboard
// shortcuts and gestures of an application.
//
// The shortcuts can be grouped, and you can have multiple sections in this
// window, corresponding to the major modes of your application.
//
// Additionally, the shortcuts can be filtered by the current view, to avoid
// showing information that is not relevant in the current application context.
//
// The recommended way to construct a `GtkShortcutsWindow` is with
// [class@Gtk.Builder], by populating a `GtkShortcutsWindow` with one or more
// `GtkShortcutsSection` objects, which contain `GtkShortcutsGroups` that in
// turn contain objects of class `GtkShortcutsShortcut`.
//
// A simple example:
//
// ! (gedit-shortcuts.png)
//
// This example has as single section. As you can see, the shortcut groups are
// arranged in columns, and spread across several pages if there are too many to
// find on a single page.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
//
// An example with multiple views:
//
// ! (clocks-shortcuts.png)
//
// This example shows a `GtkShortcutsWindow` that has been configured to show
// only the shortcuts relevant to the "stopwatch" view.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
//
// An example with multiple sections:
//
// ! (builder-shortcuts.png)
//
// This example shows a `GtkShortcutsWindow` with two sections, "Editor
// Shortcuts" and "Terminal Shortcuts".
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
type ShortcutsWindow interface {
	Window
}

// shortcutsWindow implements the ShortcutsWindow class.
type shortcutsWindow struct {
	Window
}

// WrapShortcutsWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsWindow(obj *externglib.Object) ShortcutsWindow {
	return shortcutsWindow{
		Window: WrapWindow(obj),
	}
}

func marshalShortcutsWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsWindow(obj), nil
}

func (s shortcutsWindow) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s shortcutsWindow) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s shortcutsWindow) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s shortcutsWindow) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s shortcutsWindow) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s shortcutsWindow) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s shortcutsWindow) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b shortcutsWindow) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s shortcutsWindow) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s shortcutsWindow) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s shortcutsWindow) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s shortcutsWindow) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s shortcutsWindow) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s shortcutsWindow) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s shortcutsWindow) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s shortcutsWindow) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// SignalAction: a `GtkShortcut`Action that emits a signal.
//
// Signals that are used in this way are referred to as keybinding signals, and
// they are expected to be defined with the G_SIGNAL_ACTION flag.
type SignalAction interface {

	// SignalName returns the name of the signal that will be emitted.
	SignalName() string
}

// signalAction implements the SignalAction class.
type signalAction struct {
	ShortcutAction
}

// WrapSignalAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapSignalAction(obj *externglib.Object) SignalAction {
	return signalAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalSignalAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSignalAction(obj), nil
}

// NewSignalAction creates an action that when activated, emits the given action
// signal on the provided widget.
//
// It will also unpack the args into arguments passed to the signal.
func NewSignalAction(signalName string) SignalAction {
	var _arg1 *C.char              // out
	var _cret *C.GtkShortcutAction // in

	_arg1 = (*C.char)(C.CString(signalName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_signal_action_new(_arg1)

	var _signalAction SignalAction // out

	_signalAction = WrapSignalAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _signalAction
}

func (s signalAction) SignalName() string {
	var _arg0 *C.GtkSignalAction // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkSignalAction)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_signal_action_get_signal_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SignalListItemFactory: `GtkSignalListItemFactory` is a `GtkListItemFactory`
// that emits signals to to manage listitems.
//
// Signals are emitted for every listitem in the same order:
//
//    1. [signal@Gtk.SignalListItemFactory::setup] is emitted to set up permanent
//    things on the listitem. This usually means constructing the widgets used in
//    the row and adding them to the listitem.
//
//    2. [signal@Gtk.SignalListItemFactory::bind] is emitted to bind the item passed
//    via [property@Gtk.ListItem:item] to the widgets that have been created in
//    step 1 or to add item-specific widgets. Signals are connected to listen to
//    changes - both to changes in the item to update the widgets or to changes
//    in the widgets to update the item. After this signal has been called, the
//    listitem may be shown in a list widget.
//
//    3. [signal@Gtk.SignalListItemFactory::unbind] is emitted to undo everything
//    done in step 2. Usually this means disconnecting signal handlers. Once this
//    signal has been called, the listitem will no longer be used in a list
//    widget.
//
//    4. [signal@Gtk.SignalListItemFactory::bind] and
//    [signal@Gtk.SignalListItemFactory::unbind] may be emitted multiple times
//    again to bind the listitem for use with new items. By reusing listitems,
//    potentially costly setup can be avoided. However, it means code needs to
//    make sure to properly clean up the listitem in step 3 so that no information
//    from the previous use leaks into the next use.
//
// 5. [signal@Gtk.SignalListItemFactory::teardown] is emitted to allow undoing
// the effects of [signal@Gtk.SignalListItemFactory::setup]. After this signal
// was emitted on a listitem, the listitem will be destroyed and not be used
// again.
//
// Note that during the signal emissions, changing properties on the ListItems
// passed will not trigger notify signals as the listitem's notifications are
// frozen. See g_object_freeze_notify() for details.
//
// For tracking changes in other properties in the `GtkListItem`, the ::notify
// signal is recommended. The signal can be connected in the
// [signal@Gtk.SignalListItemFactory::setup] signal and removed again during
// [signal@Gtk.SignalListItemFactory::teardown].
type SignalListItemFactory interface {
}

// signalListItemFactory implements the SignalListItemFactory class.
type signalListItemFactory struct {
	ListItemFactory
}

// WrapSignalListItemFactory wraps a GObject to the right type. It is
// primarily used internally.
func WrapSignalListItemFactory(obj *externglib.Object) SignalListItemFactory {
	return signalListItemFactory{
		ListItemFactory: WrapListItemFactory(obj),
	}
}

func marshalSignalListItemFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSignalListItemFactory(obj), nil
}

// NewSignalListItemFactory creates a new `GtkSignalListItemFactory`.
//
// You need to connect signal handlers before you use it.
func NewSignalListItemFactory() SignalListItemFactory {
	var _cret *C.GtkListItemFactory // in

	_cret = C.gtk_signal_list_item_factory_new()

	var _signalListItemFactory SignalListItemFactory // out

	_signalListItemFactory = WrapSignalListItemFactory(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _signalListItemFactory
}

// SingleSelection: `GtkSingleSelection` is a `GtkSelectionModel` that allows
// selecting a single item.
//
// Note that the selection is *persistent* -- if the selected item is removed
// and re-added in the same ::items-changed emission, it stays selected. In
// particular, this means that changing the sort order of an underlying sort
// model will preserve the selection.
type SingleSelection interface {
	SelectionModel

	// Autoselect checks if autoselect has been enabled or disabled via
	// gtk_single_selection_set_autoselect().
	Autoselect() bool
	// CanUnselect: if true, gtk_selection_model_unselect_item() is supported
	// and allows unselecting the selected item.
	CanUnselect() bool
	// Model gets the model that @self is wrapping.
	Model() gio.ListModel
	// Selected gets the position of the selected item.
	//
	// If no item is selected, GTK_INVALID_LIST_POSITION is returned.
	Selected() uint
	// SelectedItem gets the selected item.
	//
	// If no item is selected, nil is returned.
	SelectedItem() gextras.Objector
	// SetAutoselectSingleSelection enables or disables autoselect.
	//
	// If @autoselect is true, @self will enforce that an item is always
	// selected. It will select a new item when the currently selected item is
	// deleted and it will disallow unselecting the current item.
	SetAutoselectSingleSelection(autoselect bool)
	// SetCanUnselectSingleSelection: if true, unselecting the current item via
	// gtk_selection_model_unselect_item() is supported.
	//
	// Note that setting [property@Gtk.SingleSelection:autoselect] will cause
	// unselecting to not work, so it practically makes no sense to set both at
	// the same time the same time.
	SetCanUnselectSingleSelection(canUnselect bool)
	// SetModelSingleSelection sets the model that @self should wrap.
	//
	// If @model is nil, @self will be empty.
	SetModelSingleSelection(model gio.ListModel)
	// SetSelectedSingleSelection selects the item at the given position.
	//
	// If the list does not have an item at @position or
	// GTK_INVALID_LIST_POSITION is given, the behavior depends on the value of
	// the [property@Gtk.SingleSelection:autoselect] property: If it is set, no
	// change will occur and the old item will stay selected. If it is unset,
	// the selection will be unset and no item will be selected.
	SetSelectedSingleSelection(position uint)
}

// singleSelection implements the SingleSelection class.
type singleSelection struct {
	gextras.Objector
}

// WrapSingleSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapSingleSelection(obj *externglib.Object) SingleSelection {
	return singleSelection{
		Objector: obj,
	}
}

func marshalSingleSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSingleSelection(obj), nil
}

// NewSingleSelection creates a new selection to handle @model.
func NewSingleSelection(model gio.ListModel) SingleSelection {
	var _arg1 *C.GListModel         // out
	var _cret *C.GtkSingleSelection // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_single_selection_new(_arg1)

	var _singleSelection SingleSelection // out

	_singleSelection = WrapSingleSelection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _singleSelection
}

func (s singleSelection) Autoselect() bool {
	var _arg0 *C.GtkSingleSelection // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_single_selection_get_autoselect(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s singleSelection) CanUnselect() bool {
	var _arg0 *C.GtkSingleSelection // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_single_selection_get_can_unselect(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s singleSelection) Model() gio.ListModel {
	var _arg0 *C.GtkSingleSelection // out
	var _cret *C.GListModel         // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_single_selection_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s singleSelection) Selected() uint {
	var _arg0 *C.GtkSingleSelection // out
	var _cret C.guint               // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_single_selection_get_selected(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s singleSelection) SelectedItem() gextras.Objector {
	var _arg0 *C.GtkSingleSelection // out
	var _cret C.gpointer            // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_single_selection_get_selected_item(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (s singleSelection) SetAutoselectSingleSelection(autoselect bool) {
	var _arg0 *C.GtkSingleSelection // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))
	if autoselect {
		_arg1 = C.TRUE
	}

	C.gtk_single_selection_set_autoselect(_arg0, _arg1)
}

func (s singleSelection) SetCanUnselectSingleSelection(canUnselect bool) {
	var _arg0 *C.GtkSingleSelection // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))
	if canUnselect {
		_arg1 = C.TRUE
	}

	C.gtk_single_selection_set_can_unselect(_arg0, _arg1)
}

func (s singleSelection) SetModelSingleSelection(model gio.ListModel) {
	var _arg0 *C.GtkSingleSelection // out
	var _arg1 *C.GListModel         // out

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	C.gtk_single_selection_set_model(_arg0, _arg1)
}

func (s singleSelection) SetSelectedSingleSelection(position uint) {
	var _arg0 *C.GtkSingleSelection // out
	var _arg1 C.guint               // out

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)

	C.gtk_single_selection_set_selected(_arg0, _arg1)
}

func (m singleSelection) Selection() *Bitset {
	return WrapSelectionModel(gextras.InternObject(m)).Selection()
}

func (m singleSelection) SelectionInRange(position uint, nItems uint) *Bitset {
	return WrapSelectionModel(gextras.InternObject(m)).SelectionInRange(position, nItems)
}

func (m singleSelection) IsSelected(position uint) bool {
	return WrapSelectionModel(gextras.InternObject(m)).IsSelected(position)
}

func (m singleSelection) SelectAll() bool {
	return WrapSelectionModel(gextras.InternObject(m)).SelectAll()
}

func (m singleSelection) SelectItem(position uint, unselectRest bool) bool {
	return WrapSelectionModel(gextras.InternObject(m)).SelectItem(position, unselectRest)
}

func (m singleSelection) SelectRange(position uint, nItems uint, unselectRest bool) bool {
	return WrapSelectionModel(gextras.InternObject(m)).SelectRange(position, nItems, unselectRest)
}

func (m singleSelection) SelectionChanged(position uint, nItems uint) {
	WrapSelectionModel(gextras.InternObject(m)).SelectionChanged(position, nItems)
}

func (m singleSelection) SetSelection(selected *Bitset, mask *Bitset) bool {
	return WrapSelectionModel(gextras.InternObject(m)).SetSelection(selected, mask)
}

func (m singleSelection) UnselectAll() bool {
	return WrapSelectionModel(gextras.InternObject(m)).UnselectAll()
}

func (m singleSelection) UnselectItem(position uint) bool {
	return WrapSelectionModel(gextras.InternObject(m)).UnselectItem(position)
}

func (m singleSelection) UnselectRange(position uint, nItems uint) bool {
	return WrapSelectionModel(gextras.InternObject(m)).UnselectRange(position, nItems)
}

// SizeGroup: `GtkSizeGroup` groups widgets together so they all request the
// same size.
//
// This is typically useful when you want a column of widgets to have the same
// size, but you cant use a `GtkGrid`.
//
// In detail, the size requested for each widget in a `GtkSizeGroup` is the
// maximum of the sizes that would have been requested for each widget in the
// size group if they were not in the size group. The mode of the size group
// (see [method@Gtk.SizeGroup.set_mode]) determines whether this applies to the
// horizontal size, the vertical size, or both sizes.
//
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a `GtkSizeGroup`
// to actually be the same size, you need to pack them in such a way that they
// get the size they request and not more.
//
// `GtkSizeGroup` objects are referenced by each widget in the size group, so
// once you have added all widgets to a `GtkSizeGroup`, you can drop the initial
// reference to the size group with g_object_unref(). If the widgets in the size
// group are subsequently destroyed, then they will be removed from the size
// group and drop their references on the size group; when all widgets have been
// removed, the size group will be freed.
//
// Widgets can be part of multiple size groups; GTK will compute the horizontal
// size of a widget from the horizontal requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size from
// the vertical requisition of all widgets that can be reached from the widget
// by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
//
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
//
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of [property@Gtk.Label:width-chars] for instance. Widgets with
// static sizes as well as widgets that grow (such as ellipsizing text) need no
// such considerations.
//
//
// GtkSizeGroup as GtkBuildable
//
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the size
// group. The name attribute gives the id of the widget.
//
// An example of a UI definition fragment with `GtkSizeGroup`: `xml <object
// class="GtkSizeGroup"> <property name="mode">horizontal</property> <widgets>
// <widget name="radio1"/> <widget name="radio2"/> </widgets> </object> `
type SizeGroup interface {
	Buildable

	// AddWidgetSizeGroup adds a widget to a `GtkSizeGroup`.
	//
	// In the future, the requisition of the widget will be determined as the
	// maximum of its requisition and the requisition of the other widgets in
	// the size group. Whether this applies horizontally, vertically, or in both
	// directions depends on the mode of the size group. See
	// [method@Gtk.SizeGroup.set_mode].
	//
	// When the widget is destroyed or no longer referenced elsewhere, it will
	// be removed from the size group.
	AddWidgetSizeGroup(widget Widget)
	// Mode gets the current mode of the size group.
	Mode() SizeGroupMode
	// RemoveWidgetSizeGroup removes a widget from a `GtkSizeGroup`.
	RemoveWidgetSizeGroup(widget Widget)
	// SetModeSizeGroup sets the `GtkSizeGroupMode` of the size group.
	//
	// The mode of the size group determines whether the widgets in the size
	// group should all have the same horizontal requisition
	// (GTK_SIZE_GROUP_HORIZONTAL) all have the same vertical requisition
	// (GTK_SIZE_GROUP_VERTICAL), or should all have the same requisition in
	// both directions (GTK_SIZE_GROUP_BOTH).
	SetModeSizeGroup(mode SizeGroupMode)
}

// sizeGroup implements the SizeGroup class.
type sizeGroup struct {
	gextras.Objector
}

// WrapSizeGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapSizeGroup(obj *externglib.Object) SizeGroup {
	return sizeGroup{
		Objector: obj,
	}
}

func marshalSizeGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSizeGroup(obj), nil
}

// NewSizeGroup: create a new `GtkSizeGroup`.
func NewSizeGroup(mode SizeGroupMode) SizeGroup {
	var _arg1 C.GtkSizeGroupMode // out
	var _cret *C.GtkSizeGroup    // in

	_arg1 = (C.GtkSizeGroupMode)(mode)

	_cret = C.gtk_size_group_new(_arg1)

	var _sizeGroup SizeGroup // out

	_sizeGroup = WrapSizeGroup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _sizeGroup
}

func (s sizeGroup) AddWidgetSizeGroup(widget Widget) {
	var _arg0 *C.GtkSizeGroup // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_size_group_add_widget(_arg0, _arg1)
}

func (s sizeGroup) Mode() SizeGroupMode {
	var _arg0 *C.GtkSizeGroup    // out
	var _cret C.GtkSizeGroupMode // in

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_size_group_get_mode(_arg0)

	var _sizeGroupMode SizeGroupMode // out

	_sizeGroupMode = SizeGroupMode(_cret)

	return _sizeGroupMode
}

func (s sizeGroup) RemoveWidgetSizeGroup(widget Widget) {
	var _arg0 *C.GtkSizeGroup // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_size_group_remove_widget(_arg0, _arg1)
}

func (s sizeGroup) SetModeSizeGroup(mode SizeGroupMode) {
	var _arg0 *C.GtkSizeGroup    // out
	var _arg1 C.GtkSizeGroupMode // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSizeGroupMode)(mode)

	C.gtk_size_group_set_mode(_arg0, _arg1)
}

func (b sizeGroup) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// SliceListModel: `GtkSliceListModel` is a list model that presents a slice of
// another model.
//
// This is useful when implementing paging by setting the size to the number of
// elements per page and updating the offset whenever a different page is
// opened.
type SliceListModel interface {
	gio.ListModel

	// Model gets the model that is currently being used or nil if none.
	Model() gio.ListModel
	// Offset gets the offset set via gtk_slice_list_model_set_offset().
	Offset() uint
	// Size gets the size set via gtk_slice_list_model_set_size().
	Size() uint
	// SetModelSliceListModel sets the model to show a slice of.
	//
	// The model's item type must conform to @self's item type.
	SetModelSliceListModel(model gio.ListModel)
	// SetOffsetSliceListModel sets the offset into the original model for this
	// slice.
	//
	// If the offset is too large for the sliced model, @self will end up empty.
	SetOffsetSliceListModel(offset uint)
	// SetSizeSliceListModel sets the maximum size. @self will never have more
	// items than @size.
	//
	// It can however have fewer items if the offset is too large or the model
	// sliced from doesn't have enough items.
	SetSizeSliceListModel(size uint)
}

// sliceListModel implements the SliceListModel class.
type sliceListModel struct {
	gextras.Objector
}

// WrapSliceListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapSliceListModel(obj *externglib.Object) SliceListModel {
	return sliceListModel{
		Objector: obj,
	}
}

func marshalSliceListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSliceListModel(obj), nil
}

// NewSliceListModel creates a new slice model.
//
// It presents the slice from @offset to offset + @size of the given @model.
func NewSliceListModel(model gio.ListModel, offset uint, size uint) SliceListModel {
	var _arg1 *C.GListModel        // out
	var _arg2 C.guint              // out
	var _arg3 C.guint              // out
	var _cret *C.GtkSliceListModel // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
	_arg2 = (C.guint)(offset)
	_arg3 = (C.guint)(size)

	_cret = C.gtk_slice_list_model_new(_arg1, _arg2, _arg3)

	var _sliceListModel SliceListModel // out

	_sliceListModel = WrapSliceListModel(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _sliceListModel
}

func (s sliceListModel) Model() gio.ListModel {
	var _arg0 *C.GtkSliceListModel // out
	var _cret *C.GListModel        // in

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_slice_list_model_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s sliceListModel) Offset() uint {
	var _arg0 *C.GtkSliceListModel // out
	var _cret C.guint              // in

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_slice_list_model_get_offset(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s sliceListModel) Size() uint {
	var _arg0 *C.GtkSliceListModel // out
	var _cret C.guint              // in

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_slice_list_model_get_size(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s sliceListModel) SetModelSliceListModel(model gio.ListModel) {
	var _arg0 *C.GtkSliceListModel // out
	var _arg1 *C.GListModel        // out

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	C.gtk_slice_list_model_set_model(_arg0, _arg1)
}

func (s sliceListModel) SetOffsetSliceListModel(offset uint) {
	var _arg0 *C.GtkSliceListModel // out
	var _arg1 C.guint              // out

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(offset)

	C.gtk_slice_list_model_set_offset(_arg0, _arg1)
}

func (s sliceListModel) SetSizeSliceListModel(size uint) {
	var _arg0 *C.GtkSliceListModel // out
	var _arg1 C.guint              // out

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(size)

	C.gtk_slice_list_model_set_size(_arg0, _arg1)
}

// Snapshot: `GtkSnapshot` assists in creating `GskRenderNodes` for widgets.
//
// It functions in a similar way to a cairo context, and maintains a stack of
// render nodes and their associated transformations.
//
// The node at the top of the stack is the the one that gtk_snapshot_append_
// functions operate on. Use the gtk_snapshot_push_ functions and
// gtk_snapshot_pop() to change the current node.
//
// The typical way to obtain a `GtkSnapshot` object is as an argument to the
// GtkWidgetClass.snapshot() vfunc. If you need to create your own
// `GtkSnapshot`, use [ctor@Gtk.Snapshot.new].
type Snapshot interface {

	// AppendBorderSnapshot appends a stroked border rectangle inside the given
	// @outline.
	//
	// The four sides of the border can have different widths and colors.
	AppendBorderSnapshot(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA)
	// AppendCairoSnapshot creates a new `GskCairoNode` and appends it to the
	// current render node of @snapshot, without changing the current node.
	AppendCairoSnapshot(bounds *graphene.Rect) *cairo.Context
	// AppendColorSnapshot creates a new render node drawing the @color into the
	// given @bounds and appends it to the current render node of @snapshot.
	//
	// You should try to avoid calling this function if @color is transparent.
	AppendColorSnapshot(color *gdk.RGBA, bounds *graphene.Rect)
	// AppendConicGradientSnapshot appends a conic gradient node with the given
	// stops to @snapshot.
	AppendConicGradientSnapshot(bounds *graphene.Rect, center *graphene.Point, rotation float32, stops []gsk.ColorStop)
	// AppendInsetShadowSnapshot appends an inset shadow into the box given by
	// @outline.
	AppendInsetShadowSnapshot(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)

	AppendLayoutSnapshot(layout pango.Layout, color *gdk.RGBA)
	// AppendLinearGradientSnapshot appends a linear gradient node with the
	// given stops to @snapshot.
	AppendLinearGradientSnapshot(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)
	// AppendNodeSnapshot appends @node to the current render node of @snapshot,
	// without changing the current node.
	//
	// If @snapshot does not have a current node yet, @node will become the
	// initial node.
	AppendNodeSnapshot(node gsk.RenderNode)
	// AppendOutsetShadowSnapshot appends an outset shadow node around the box
	// given by @outline.
	AppendOutsetShadowSnapshot(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)
	// AppendRadialGradientSnapshot appends a radial gradient node with the
	// given stops to @snapshot.
	AppendRadialGradientSnapshot(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)
	// AppendRepeatingLinearGradientSnapshot appends a repeating linear gradient
	// node with the given stops to @snapshot.
	AppendRepeatingLinearGradientSnapshot(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)
	// AppendRepeatingRadialGradientSnapshot appends a repeating radial gradient
	// node with the given stops to @snapshot.
	AppendRepeatingRadialGradientSnapshot(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)
	// AppendTextureSnapshot creates a new render node drawing the @texture into
	// the given @bounds and appends it to the current render node of @snapshot.
	AppendTextureSnapshot(texture gdk.Texture, bounds *graphene.Rect)
	// GLShaderPopTextureSnapshot removes the top element from the stack of
	// render nodes and adds it to the nearest `GskGLShaderNode` below it.
	//
	// This must be called the same number of times as the number of textures is
	// needed for the shader in [method@Gtk.Snapshot.push_gl_shader].
	GLShaderPopTextureSnapshot()
	// PerspectiveSnapshot applies a perspective projection transform.
	//
	// See [method@Gsk.Transform.perspective] for a discussion on the details.
	PerspectiveSnapshot(depth float32)
	// PopSnapshot removes the top element from the stack of render nodes, and
	// appends it to the node underneath it.
	PopSnapshot()
	// PushBlendSnapshot blends together two images with the given blend mode.
	//
	// Until the first call to [method@Gtk.Snapshot.pop], the bottom image for
	// the blend operation will be recorded. After that call, the top image to
	// be blended will be recorded until the second call to
	// [method@Gtk.Snapshot.pop].
	//
	// Calling this function requires two subsequent calls to
	// [method@Gtk.Snapshot.pop].
	PushBlendSnapshot(blendMode gsk.BlendMode)
	// PushBlurSnapshot blurs an image.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushBlurSnapshot(radius float64)
	// PushClipSnapshot clips an image to a rectangle.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushClipSnapshot(bounds *graphene.Rect)
	// PushColorMatrixSnapshot modifies the colors of an image by applying an
	// affine transformation in RGB space.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushColorMatrixSnapshot(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4)
	// PushCrossFadeSnapshot snapshots a cross-fade operation between two images
	// with the given @progress.
	//
	// Until the first call to [method@Gtk.Snapshot.pop], the start image will
	// be snapshot. After that call, the end image will be recorded until the
	// second call to [method@Gtk.Snapshot.pop].
	//
	// Calling this function requires two subsequent calls to
	// [method@Gtk.Snapshot.pop].
	PushCrossFadeSnapshot(progress float64)
	// PushOpacitySnapshot modifies the opacity of an image.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushOpacitySnapshot(opacity float64)
	// PushRepeatSnapshot creates a node that repeats the child node.
	//
	// The child is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushRepeatSnapshot(bounds *graphene.Rect, childBounds *graphene.Rect)
	// PushRoundedClipSnapshot clips an image to a rounded rectangle.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushRoundedClipSnapshot(bounds *gsk.RoundedRect)
	// PushShadowSnapshot applies a shadow to an image.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushShadowSnapshot(shadow *gsk.Shadow, nShadows uint)
	// RenderBackgroundSnapshot creates a render node for the CSS background
	// according to @context, and appends it to the current node of @snapshot,
	// without changing the current node.
	RenderBackgroundSnapshot(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderFocusSnapshot creates a render node for the focus outline according
	// to @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderFocusSnapshot(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderFrameSnapshot creates a render node for the CSS border according to
	// @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderFrameSnapshot(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderInsertionCursorSnapshot draws a text caret using @snapshot at the
	// specified index of @layout.
	RenderInsertionCursorSnapshot(context StyleContext, x float64, y float64, layout pango.Layout, index int, direction pango.Direction)
	// RenderLayoutSnapshot creates a render node for rendering @layout
	// according to the style information in @context, and appends it to the
	// current node of @snapshot, without changing the current node.
	RenderLayoutSnapshot(context StyleContext, x float64, y float64, layout pango.Layout)
	// RestoreSnapshot restores @snapshot to the state saved by a preceding call
	// to gtk_snapshot_save() and removes that state from the stack of saved
	// states.
	RestoreSnapshot()
	// RotateSnapshot rotates @@snapshot's coordinate system by @angle degrees
	// in 2D space - or in 3D speak, rotates around the Z axis.
	//
	// To rotate around other axes, use [method@Gsk.Transform.rotate_3d].
	RotateSnapshot(angle float32)
	// Rotate3DSnapshot rotates @snapshot's coordinate system by @angle degrees
	// around @axis.
	//
	// For a rotation in 2D space, use [method@Gsk.Transform.rotate].
	Rotate3DSnapshot(angle float32, axis *graphene.Vec3)
	// SaveSnapshot makes a copy of the current state of @snapshot and saves it
	// on an internal stack.
	//
	// When [method@Gtk.Snapshot.restore] is called, @snapshot will be restored
	// to the saved state. Multiple calls to gtk_snapshot_save() and
	// gtk_snapshot_restore() can be nested; each call to gtk_snapshot_restore()
	// restores the state from the matching paired gtk_snapshot_save().
	//
	// It is necessary to clear all saved states with corresponding calls to
	// gtk_snapshot_restore().
	SaveSnapshot()
	// ScaleSnapshot scales @snapshot's coordinate system in 2-dimensional space
	// by the given factors.
	//
	// Use [method@Gtk.Snapshot.scale_3d] to scale in all 3 dimensions.
	ScaleSnapshot(factorX float32, factorY float32)
	// Scale3DSnapshot scales @snapshot's coordinate system by the given
	// factors.
	Scale3DSnapshot(factorX float32, factorY float32, factorZ float32)
	// ToNodeSnapshot returns the render node that was constructed by @snapshot.
	//
	// After calling this function, it is no longer possible to add more nodes
	// to @snapshot. The only function that should be called after this is
	// g_object_unref().
	ToNodeSnapshot() gsk.RenderNode
	// ToPaintableSnapshot returns a paintable encapsulating the render node
	// that was constructed by @snapshot.
	//
	// After calling this function, it is no longer possible to add more nodes
	// to @snapshot. The only function that should be called after this is
	// g_object_unref().
	ToPaintableSnapshot(size *graphene.Size) gdk.Paintable
	// TransformSnapshot transforms @snapshot's coordinate system with the given
	// @transform.
	TransformSnapshot(transform *gsk.Transform)
	// TransformMatrixSnapshot transforms @snapshot's coordinate system with the
	// given @matrix.
	TransformMatrixSnapshot(matrix *graphene.Matrix)
	// TranslateSnapshot translates @snapshot's coordinate system by @point in
	// 2-dimensional space.
	TranslateSnapshot(point *graphene.Point)
	// Translate3DSnapshot translates @snapshot's coordinate system by @point.
	Translate3DSnapshot(point *graphene.Point3D)
}

// snapshot implements the Snapshot class.
type snapshot struct {
	gdk.Snapshot
}

// WrapSnapshot wraps a GObject to the right type. It is
// primarily used internally.
func WrapSnapshot(obj *externglib.Object) Snapshot {
	return snapshot{
		Snapshot: gdk.WrapSnapshot(obj),
	}
}

func marshalSnapshot(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSnapshot(obj), nil
}

// NewSnapshot creates a new `GtkSnapshot`.
func NewSnapshot() Snapshot {
	var _cret *C.GtkSnapshot // in

	_cret = C.gtk_snapshot_new()

	var _snapshot Snapshot // out

	_snapshot = WrapSnapshot(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _snapshot
}

func (s snapshot) AppendBorderSnapshot(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) {
	var _arg0 *C.GtkSnapshot    // out
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.float
	var _arg3 *C.GdkRGBA

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
	_arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(&borderColor))

	C.gtk_snapshot_append_border(_arg0, _arg1, _arg2, _arg3)
}

func (s snapshot) AppendCairoSnapshot(bounds *graphene.Rect) *cairo.Context {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.cairo_t         // in

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	_cret = C.gtk_snapshot_append_cairo(_arg0, _arg1)

	var _context *cairo.Context // out

	_context = cairo.WrapContext(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _context
}

func (s snapshot) AppendColorSnapshot(color *gdk.RGBA, bounds *graphene.Rect) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GdkRGBA         // out
	var _arg2 *C.graphene_rect_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	C.gtk_snapshot_append_color(_arg0, _arg1, _arg2)
}

func (s snapshot) AppendConicGradientSnapshot(bounds *graphene.Rect, center *graphene.Point, rotation float32, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center.Native()))
	_arg3 = (C.float)(rotation)
	_arg5 = C.gsize(len(stops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

	C.gtk_snapshot_append_conic_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (s snapshot) AppendInsetShadowSnapshot(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) {
	var _arg0 *C.GtkSnapshot    // out
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
	_arg3 = (C.float)(dx)
	_arg4 = (C.float)(dy)
	_arg5 = (C.float)(spread)
	_arg6 = (C.float)(blurRadius)

	C.gtk_snapshot_append_inset_shadow(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (s snapshot) AppendLayoutSnapshot(layout pango.Layout, color *gdk.RGBA) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 *C.PangoLayout // out
	var _arg2 *C.GdkRGBA     // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_snapshot_append_layout(_arg0, _arg1, _arg2)
}

func (s snapshot) AppendLinearGradientSnapshot(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(startPoint.Native()))
	_arg3 = (*C.graphene_point_t)(unsafe.Pointer(endPoint.Native()))
	_arg5 = C.gsize(len(stops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

	C.gtk_snapshot_append_linear_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (s snapshot) AppendNodeSnapshot(node gsk.RenderNode) {
	var _arg0 *C.GtkSnapshot   // out
	var _arg1 *C.GskRenderNode // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	C.gtk_snapshot_append_node(_arg0, _arg1)
}

func (s snapshot) AppendOutsetShadowSnapshot(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) {
	var _arg0 *C.GtkSnapshot    // out
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
	_arg3 = (C.float)(dx)
	_arg4 = (C.float)(dy)
	_arg5 = (C.float)(spread)
	_arg6 = (C.float)(blurRadius)

	C.gtk_snapshot_append_outset_shadow(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (s snapshot) AppendRadialGradientSnapshot(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop
	var _arg8 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center.Native()))
	_arg3 = (C.float)(hradius)
	_arg4 = (C.float)(vradius)
	_arg5 = (C.float)(start)
	_arg6 = (C.float)(end)
	_arg8 = C.gsize(len(stops))
	_arg7 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

	C.gtk_snapshot_append_radial_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}

func (s snapshot) AppendRepeatingLinearGradientSnapshot(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(startPoint.Native()))
	_arg3 = (*C.graphene_point_t)(unsafe.Pointer(endPoint.Native()))
	_arg5 = C.gsize(len(stops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

	C.gtk_snapshot_append_repeating_linear_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (s snapshot) AppendRepeatingRadialGradientSnapshot(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop
	var _arg8 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center.Native()))
	_arg3 = (C.float)(hradius)
	_arg4 = (C.float)(vradius)
	_arg5 = (C.float)(start)
	_arg6 = (C.float)(end)
	_arg8 = C.gsize(len(stops))
	_arg7 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

	C.gtk_snapshot_append_repeating_radial_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}

func (s snapshot) AppendTextureSnapshot(texture gdk.Texture, bounds *graphene.Rect) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GdkTexture      // out
	var _arg2 *C.graphene_rect_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	C.gtk_snapshot_append_texture(_arg0, _arg1, _arg2)
}

func (s snapshot) GLShaderPopTextureSnapshot() {
	var _arg0 *C.GtkSnapshot // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_gl_shader_pop_texture(_arg0)
}

func (s snapshot) PerspectiveSnapshot(depth float32) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.float        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(depth)

	C.gtk_snapshot_perspective(_arg0, _arg1)
}

func (s snapshot) PopSnapshot() {
	var _arg0 *C.GtkSnapshot // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_pop(_arg0)
}

func (s snapshot) PushBlendSnapshot(blendMode gsk.BlendMode) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.GskBlendMode // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GskBlendMode)(blendMode)

	C.gtk_snapshot_push_blend(_arg0, _arg1)
}

func (s snapshot) PushBlurSnapshot(radius float64) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(radius)

	C.gtk_snapshot_push_blur(_arg0, _arg1)
}

func (s snapshot) PushClipSnapshot(bounds *graphene.Rect) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.graphene_rect_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	C.gtk_snapshot_push_clip(_arg0, _arg1)
}

func (s snapshot) PushColorMatrixSnapshot(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) {
	var _arg0 *C.GtkSnapshot       // out
	var _arg1 *C.graphene_matrix_t // out
	var _arg2 *C.graphene_vec4_t   // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(colorMatrix.Native()))
	_arg2 = (*C.graphene_vec4_t)(unsafe.Pointer(colorOffset.Native()))

	C.gtk_snapshot_push_color_matrix(_arg0, _arg1, _arg2)
}

func (s snapshot) PushCrossFadeSnapshot(progress float64) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(progress)

	C.gtk_snapshot_push_cross_fade(_arg0, _arg1)
}

func (s snapshot) PushOpacitySnapshot(opacity float64) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(opacity)

	C.gtk_snapshot_push_opacity(_arg0, _arg1)
}

func (s snapshot) PushRepeatSnapshot(bounds *graphene.Rect, childBounds *graphene.Rect) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.graphene_rect_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(childBounds.Native()))

	C.gtk_snapshot_push_repeat(_arg0, _arg1, _arg2)
}

func (s snapshot) PushRoundedClipSnapshot(bounds *gsk.RoundedRect) {
	var _arg0 *C.GtkSnapshot    // out
	var _arg1 *C.GskRoundedRect // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(bounds.Native()))

	C.gtk_snapshot_push_rounded_clip(_arg0, _arg1)
}

func (s snapshot) PushShadowSnapshot(shadow *gsk.Shadow, nShadows uint) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 *C.GskShadow   // out
	var _arg2 C.gsize        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskShadow)(unsafe.Pointer(shadow.Native()))
	_arg2 = (C.gsize)(nShadows)

	C.gtk_snapshot_push_shadow(_arg0, _arg1, _arg2)
}

func (s snapshot) RenderBackgroundSnapshot(context StyleContext, x float64, y float64, width float64, height float64) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (C.double)(x)
	_arg3 = (C.double)(y)
	_arg4 = (C.double)(width)
	_arg5 = (C.double)(height)

	C.gtk_snapshot_render_background(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (s snapshot) RenderFocusSnapshot(context StyleContext, x float64, y float64, width float64, height float64) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (C.double)(x)
	_arg3 = (C.double)(y)
	_arg4 = (C.double)(width)
	_arg5 = (C.double)(height)

	C.gtk_snapshot_render_focus(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (s snapshot) RenderFrameSnapshot(context StyleContext, x float64, y float64, width float64, height float64) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (C.double)(x)
	_arg3 = (C.double)(y)
	_arg4 = (C.double)(width)
	_arg5 = (C.double)(height)

	C.gtk_snapshot_render_frame(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (s snapshot) RenderInsertionCursorSnapshot(context StyleContext, x float64, y float64, layout pango.Layout, index int, direction pango.Direction) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 *C.PangoLayout     // out
	var _arg5 C.int              // out
	var _arg6 C.PangoDirection   // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (C.double)(x)
	_arg3 = (C.double)(y)
	_arg4 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg5 = (C.int)(index)
	_arg6 = (C.PangoDirection)(direction)

	C.gtk_snapshot_render_insertion_cursor(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (s snapshot) RenderLayoutSnapshot(context StyleContext, x float64, y float64, layout pango.Layout) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 *C.PangoLayout     // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (C.double)(x)
	_arg3 = (C.double)(y)
	_arg4 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.gtk_snapshot_render_layout(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s snapshot) RestoreSnapshot() {
	var _arg0 *C.GtkSnapshot // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_restore(_arg0)
}

func (s snapshot) RotateSnapshot(angle float32) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.float        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(angle)

	C.gtk_snapshot_rotate(_arg0, _arg1)
}

func (s snapshot) Rotate3DSnapshot(angle float32, axis *graphene.Vec3) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 C.float            // out
	var _arg2 *C.graphene_vec3_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	C.gtk_snapshot_rotate_3d(_arg0, _arg1, _arg2)
}

func (s snapshot) SaveSnapshot() {
	var _arg0 *C.GtkSnapshot // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_save(_arg0)
}

func (s snapshot) ScaleSnapshot(factorX float32, factorY float32) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.float        // out
	var _arg2 C.float        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(factorX)
	_arg2 = (C.float)(factorY)

	C.gtk_snapshot_scale(_arg0, _arg1, _arg2)
}

func (s snapshot) Scale3DSnapshot(factorX float32, factorY float32, factorZ float32) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.float        // out
	var _arg2 C.float        // out
	var _arg3 C.float        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(factorX)
	_arg2 = (C.float)(factorY)
	_arg3 = (C.float)(factorZ)

	C.gtk_snapshot_scale_3d(_arg0, _arg1, _arg2, _arg3)
}

func (s snapshot) ToNodeSnapshot() gsk.RenderNode {
	var _arg0 *C.GtkSnapshot   // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_snapshot_to_node(_arg0)

	var _renderNode gsk.RenderNode // out

	_renderNode = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gsk.RenderNode)

	return _renderNode
}

func (s snapshot) ToPaintableSnapshot(size *graphene.Size) gdk.Paintable {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.graphene_size_t // out
	var _cret *C.GdkPaintable    // in

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_size_t)(unsafe.Pointer(size.Native()))

	_cret = C.gtk_snapshot_to_paintable(_arg0, _arg1)

	var _paintable gdk.Paintable // out

	_paintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.Paintable)

	return _paintable
}

func (s snapshot) TransformSnapshot(transform *gsk.Transform) {
	var _arg0 *C.GtkSnapshot  // out
	var _arg1 *C.GskTransform // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

	C.gtk_snapshot_transform(_arg0, _arg1)
}

func (s snapshot) TransformMatrixSnapshot(matrix *graphene.Matrix) {
	var _arg0 *C.GtkSnapshot       // out
	var _arg1 *C.graphene_matrix_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix.Native()))

	C.gtk_snapshot_transform_matrix(_arg0, _arg1)
}

func (s snapshot) TranslateSnapshot(point *graphene.Point) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_point_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	C.gtk_snapshot_translate(_arg0, _arg1)
}

func (s snapshot) Translate3DSnapshot(point *graphene.Point3D) {
	var _arg0 *C.GtkSnapshot        // out
	var _arg1 *C.graphene_point3d_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	C.gtk_snapshot_translate_3d(_arg0, _arg1)
}

// SortListModel: `GtkSortListModel` is a list model that sorts the elements of
// the underlying model according to a `GtkSorter`.
//
// The model can be set up to do incremental sorting, so that sorting long lists
// doesn't block the UI. See [method@Gtk.SortListModel.set_incremental] for
// details.
//
// `GtkSortListModel` is a generic model and because of that it cannot take
// advantage of any external knowledge when sorting. If you run into performance
// issues with `GtkSortListModel`, it is strongly recommended that you write
// your own sorting list model.
type SortListModel interface {
	gio.ListModel

	// Incremental returns whether incremental sorting is enabled.
	//
	// See [method@Gtk.SortListModel.set_incremental].
	Incremental() bool
	// Model gets the model currently sorted or nil if none.
	Model() gio.ListModel
	// Pending estimates progress of an ongoing sorting operation.
	//
	// The estimate is the number of items that would still need to be sorted to
	// finish the sorting operation if this was a linear algorithm. So this
	// number is not related to how many items are already correctly sorted.
	//
	// If you want to estimate the progress, you can use code like this: `c
	// pending = gtk_sort_list_model_get_pending (self); model =
	// gtk_sort_list_model_get_model (self); progress = 1.0 - pending / (double)
	// MAX (1, g_list_model_get_n_items (model)); `
	//
	// If no sort operation is ongoing - in particular when
	// [property@Gtk.SortListModel:incremental] is false - this function returns
	// 0.
	Pending() uint
	// Sorter gets the sorter that is used to sort @self.
	Sorter() Sorter
	// SetIncrementalSortListModel sets the sort model to do an incremental
	// sort.
	//
	// When incremental sorting is enabled, the `GtkSortListModel` will not do a
	// complete sort immediately, but will instead queue an idle handler that
	// incrementally sorts the items towards their correct position. This of
	// course means that items do not instantly appear in the right place. It
	// also means that the total sorting time is a lot slower.
	//
	// When your filter blocks the UI while sorting, you might consider turning
	// this on. Depending on your model and sorters, this may become interesting
	// around 10,000 to 100,000 items.
	//
	// By default, incremental sorting is disabled.
	//
	// See [method@Gtk.SortListModel.get_pending] for progress information about
	// an ongoing incremental sorting operation.
	SetIncrementalSortListModel(incremental bool)
	// SetModelSortListModel sets the model to be sorted.
	//
	// The @model's item type must conform to the item type of @self.
	SetModelSortListModel(model gio.ListModel)
	// SetSorterSortListModel sets a new sorter on @self.
	SetSorterSortListModel(sorter Sorter)
}

// sortListModel implements the SortListModel class.
type sortListModel struct {
	gextras.Objector
}

// WrapSortListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapSortListModel(obj *externglib.Object) SortListModel {
	return sortListModel{
		Objector: obj,
	}
}

func marshalSortListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSortListModel(obj), nil
}

// NewSortListModel creates a new sort list model that uses the @sorter to sort
// @model.
func NewSortListModel(model gio.ListModel, sorter Sorter) SortListModel {
	var _arg1 *C.GListModel       // out
	var _arg2 *C.GtkSorter        // out
	var _cret *C.GtkSortListModel // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

	_cret = C.gtk_sort_list_model_new(_arg1, _arg2)

	var _sortListModel SortListModel // out

	_sortListModel = WrapSortListModel(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _sortListModel
}

func (s sortListModel) Incremental() bool {
	var _arg0 *C.GtkSortListModel // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_sort_list_model_get_incremental(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s sortListModel) Model() gio.ListModel {
	var _arg0 *C.GtkSortListModel // out
	var _cret *C.GListModel       // in

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_sort_list_model_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s sortListModel) Pending() uint {
	var _arg0 *C.GtkSortListModel // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_sort_list_model_get_pending(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s sortListModel) Sorter() Sorter {
	var _arg0 *C.GtkSortListModel // out
	var _cret *C.GtkSorter        // in

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_sort_list_model_get_sorter(_arg0)

	var _sorter Sorter // out

	_sorter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Sorter)

	return _sorter
}

func (s sortListModel) SetIncrementalSortListModel(incremental bool) {
	var _arg0 *C.GtkSortListModel // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))
	if incremental {
		_arg1 = C.TRUE
	}

	C.gtk_sort_list_model_set_incremental(_arg0, _arg1)
}

func (s sortListModel) SetModelSortListModel(model gio.ListModel) {
	var _arg0 *C.GtkSortListModel // out
	var _arg1 *C.GListModel       // out

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

	C.gtk_sort_list_model_set_model(_arg0, _arg1)
}

func (s sortListModel) SetSorterSortListModel(sorter Sorter) {
	var _arg0 *C.GtkSortListModel // out
	var _arg1 *C.GtkSorter        // out

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

	C.gtk_sort_list_model_set_sorter(_arg0, _arg1)
}

// Sorter: `GtkSorter` is an object to describe sorting criteria.
//
// Its primary user is [class@Gtk.SortListModel]
//
// The model will use a sorter to determine the order in which its items should
// appear by calling [method@Gtk.Sorter.compare] for pairs of items.
//
// Sorters may change their sorting behavior through their lifetime. In that
// case, they will emit the [signal@Gtk.Sorter::changed] signal to notify that
// the sort order is no longer valid and should be updated by calling
// gtk_sorter_compare() again.
//
// GTK provides various pre-made sorter implementations for common sorting
// operations. [class@Gtk.ColumnView] has built-in support for sorting lists via
// the [property@Gtk.ColumnViewColumn:sorter] property, where the user can
// change the sorting by clicking on list headers.
//
// Of course, in particular for large lists, it is also possible to subclass
// `GtkSorter` and provide one's own sorter.
type Sorter interface {

	// ChangedSorter emits the [signal@Gtk.Sorter::changed] signal to notify all
	// users of the sorter that it has changed.
	//
	// Users of the sorter should then update the sort order via
	// gtk_sorter_compare().
	//
	// Depending on the @change parameter, it may be possible to update the sort
	// order without a full resorting. Refer to the [enum@Gtk.SorterChange]
	// documentation for details.
	//
	// This function is intended for implementors of `GtkSorter` subclasses and
	// should not be called from other functions.
	ChangedSorter(change SorterChange)
	// CompareSorter compares two given items according to the sort order
	// implemented by the sorter.
	//
	// Sorters implement a partial order:
	//
	// * It is reflexive, ie a = a * It is antisymmetric, ie if a < b and b < a,
	// then a = b * It is transitive, ie given any 3 items with a  b and b  c,
	// then a  c
	//
	// The sorter may signal it conforms to additional constraints via the
	// return value of [method@Gtk.Sorter.get_order].
	CompareSorter(item1 gextras.Objector, item2 gextras.Objector) Ordering
	// Order gets the order that @self conforms to.
	//
	// See [enum@Gtk.SorterOrder] for details of the possible return values.
	//
	// This function is intended to allow optimizations.
	Order() SorterOrder
}

// sorter implements the Sorter class.
type sorter struct {
	gextras.Objector
}

// WrapSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapSorter(obj *externglib.Object) Sorter {
	return sorter{
		Objector: obj,
	}
}

func marshalSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSorter(obj), nil
}

func (s sorter) ChangedSorter(change SorterChange) {
	var _arg0 *C.GtkSorter      // out
	var _arg1 C.GtkSorterChange // out

	_arg0 = (*C.GtkSorter)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSorterChange)(change)

	C.gtk_sorter_changed(_arg0, _arg1)
}

func (s sorter) CompareSorter(item1 gextras.Objector, item2 gextras.Objector) Ordering {
	var _arg0 *C.GtkSorter  // out
	var _arg1 C.gpointer    // out
	var _arg2 C.gpointer    // out
	var _cret C.GtkOrdering // in

	_arg0 = (*C.GtkSorter)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(item1.Native()))
	_arg2 = (C.gpointer)(unsafe.Pointer(item2.Native()))

	_cret = C.gtk_sorter_compare(_arg0, _arg1, _arg2)

	var _ordering Ordering // out

	_ordering = Ordering(_cret)

	return _ordering
}

func (s sorter) Order() SorterOrder {
	var _arg0 *C.GtkSorter     // out
	var _cret C.GtkSorterOrder // in

	_arg0 = (*C.GtkSorter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_sorter_get_order(_arg0)

	var _sorterOrder SorterOrder // out

	_sorterOrder = SorterOrder(_cret)

	return _sorterOrder
}

// SpinButton: a `GtkSpinButton` is an ideal way to allow the user to set the
// value of some attribute.
//
// !An example GtkSpinButton (spinbutton.png)
//
// Rather than having to directly type a number into a `GtkEntry`,
// `GtkSpinButton` allows the user to click on one of two arrows to increment or
// decrement the displayed value. A value can still be typed in, with the bonus
// that it can be checked to ensure it is in a given range.
//
// The main properties of a `GtkSpinButton` are through an adjustment. See the
// [class@Gtk.Adjustment] documentation for more details about an adjustment's
// properties.
//
// Note that `GtkSpinButton` will by default make its entry large enough to
// accommodate the lower and upper bounds of the adjustment. If this is not
// desired, the automatic sizing can be turned off by explicitly setting
// [property@Gtk.Editable:width-chars] to a value != -1.
//
//
// Using a GtkSpinButton to get an integer
//
// `c // Provides a function to retrieve an integer value from a GtkSpinButton
// // and creates a spin button to model percentage values.
//
// int grab_int_value (GtkSpinButton *button, gpointer user_data) { return
// gtk_spin_button_get_value_as_int (button); }
//
// void create_integer_spin_button (void) {
//
//    GtkWidget *window, *button;
//    GtkAdjustment *adjustment;
//
//    adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
//
//    window = gtk_window_new ();
//
//    // creates the spinbutton, with no decimal places
//    button = gtk_spin_button_new (adjustment, 1.0, 0);
//    gtk_window_set_child (GTK_WINDOW (window), button);
//
//    gtk_widget_show (window);
//
// } `
//
//
// Using a GtkSpinButton to get a floating point value
//
// `c // Provides a function to retrieve a floating point value from a //
// GtkSpinButton, and creates a high precision spin button.
//
// float grab_float_value (GtkSpinButton *button, gpointer user_data) { return
// gtk_spin_button_get_value (button); }
//
// void create_floating_spin_button (void) { GtkWidget *window, *button;
// GtkAdjustment *adjustment;
//
//    adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
//
//    window = gtk_window_new ();
//
//    // creates the spinbutton, with three decimal places
//    button = gtk_spin_button_new (adjustment, 0.001, 3);
//    gtk_window_set_child (GTK_WINDOW (window), button);
//
//    gtk_widget_show (window);
//
// } `
//
//
// CSS nodes
//
// ` spinbutton.horizontal  text   undershoot.left  
// undershoot.right  button.down  button.up `
//
// ` spinbutton.vertical  button.up  text   undershoot.left  
// undershoot.right  button.down `
//
// `GtkSpinButton`s main CSS node has the name spinbutton. It creates subnodes
// for the entry and the two buttons, with these names. The button nodes have
// the style classes .up and .down. The `GtkText` subnodes (if present) are put
// below the text node. The orientation of the spin button is reflected in the
// .vertical or .horizontal style class on the main node.
//
//
// Accessiblity
//
// `GtkSpinButton` uses the GTK_ACCESSIBLE_ROLE_SPIN_BUTTON role.
type SpinButton interface {
	CellEditable
	Editable
	Orientable

	// ConfigureSpinButton changes the properties of an existing spin button.
	//
	// The adjustment, climb rate, and number of decimal places are updated
	// accordingly.
	ConfigureSpinButton(adjustment Adjustment, climbRate float64, digits uint)
	// Adjustment: get the adjustment associated with a `GtkSpinButton`.
	Adjustment() Adjustment
	// ClimbRate returns the acceleration rate for repeated changes.
	ClimbRate() float64
	// Digits fetches the precision of @spin_button.
	Digits() uint
	// Increments gets the current step and page the increments used by
	// @spin_button.
	//
	// See [method@Gtk.SpinButton.set_increments].
	Increments() (step float64, page float64)
	// Numeric returns whether non-numeric text can be typed into the spin
	// button.
	Numeric() bool
	// Range gets the range allowed for @spin_button.
	//
	// See [method@Gtk.SpinButton.set_range].
	Range() (min float64, max float64)
	// SnapToTicks returns whether the values are corrected to the nearest step.
	SnapToTicks() bool
	// UpdatePolicy gets the update behavior of a spin button.
	//
	// See [method@Gtk.SpinButton.set_update_policy].
	UpdatePolicy() SpinButtonUpdatePolicy
	// Value: get the value in the @spin_button.
	Value() float64
	// ValueAsInt: get the value @spin_button represented as an integer.
	ValueAsInt() int
	// Wrap returns whether the spin buttons value wraps around to the opposite
	// limit when the upper or lower limit of the range is exceeded.
	Wrap() bool
	// SetAdjustmentSpinButton replaces the `GtkAdjustment` associated with
	// @spin_button.
	SetAdjustmentSpinButton(adjustment Adjustment)
	// SetClimbRateSpinButton sets the acceleration rate for repeated changes
	// when you hold down a button or key.
	SetClimbRateSpinButton(climbRate float64)
	// SetDigitsSpinButton: set the precision to be displayed by @spin_button.
	//
	// Up to 20 digit precision is allowed.
	SetDigitsSpinButton(digits uint)
	// SetIncrementsSpinButton sets the step and page increments for
	// spin_button.
	//
	// This affects how quickly the value changes when the spin buttons arrows
	// are activated.
	SetIncrementsSpinButton(step float64, page float64)
	// SetNumericSpinButton sets the flag that determines if non-numeric text
	// can be typed into the spin button.
	SetNumericSpinButton(numeric bool)
	// SetRangeSpinButton sets the minimum and maximum allowable values for
	// @spin_button.
	//
	// If the current value is outside this range, it will be adjusted to fit
	// within the range, otherwise it will remain unchanged.
	SetRangeSpinButton(min float64, max float64)
	// SetSnapToTicksSpinButton sets the policy as to whether values are
	// corrected to the nearest step increment when a spin button is activated
	// after providing an invalid value.
	SetSnapToTicksSpinButton(snapToTicks bool)
	// SetUpdatePolicySpinButton sets the update behavior of a spin button.
	//
	// This determines whether the spin button is always updated or only when a
	// valid value is set.
	SetUpdatePolicySpinButton(policy SpinButtonUpdatePolicy)
	// SetValueSpinButton sets the value of @spin_button.
	SetValueSpinButton(value float64)
	// SetWrapSpinButton sets the flag that determines if a spin button value
	// wraps around to the opposite limit when the upper or lower limit of the
	// range is exceeded.
	SetWrapSpinButton(wrap bool)
	// SpinSpinButton: increment or decrement a spin buttons value in a
	// specified direction by a specified amount.
	SpinSpinButton(direction SpinType, increment float64)
	// UpdateSpinButton: manually force an update of the spin button.
	UpdateSpinButton()
}

// spinButton implements the SpinButton class.
type spinButton struct {
	Widget
}

// WrapSpinButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinButton(obj *externglib.Object) SpinButton {
	return spinButton{
		Widget: WrapWidget(obj),
	}
}

func marshalSpinButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinButton(obj), nil
}

// NewSpinButton creates a new `GtkSpinButton`.
func NewSpinButton(adjustment Adjustment, climbRate float64, digits uint) SpinButton {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 C.double         // out
	var _arg3 C.guint          // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
	_arg2 = (C.double)(climbRate)
	_arg3 = (C.guint)(digits)

	_cret = C.gtk_spin_button_new(_arg1, _arg2, _arg3)

	var _spinButton SpinButton // out

	_spinButton = WrapSpinButton(externglib.Take(unsafe.Pointer(_cret)))

	return _spinButton
}

// NewSpinButtonWithRange creates a new `GtkSpinButton` with the given
// properties.
//
// This is a convenience constructor that allows creation of a numeric
// `GtkSpinButton` without manually creating an adjustment. The value is
// initially set to the minimum value and a page increment of 10 * @step is the
// default. The precision of the spin button is equivalent to the precision of
// @step.
//
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// [method@Gtk.SpinButton.set_digits] to correct it.
func NewSpinButtonWithRange(min float64, max float64, step float64) SpinButton {
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out
	var _cret *C.GtkWidget // in

	_arg1 = (C.double)(min)
	_arg2 = (C.double)(max)
	_arg3 = (C.double)(step)

	_cret = C.gtk_spin_button_new_with_range(_arg1, _arg2, _arg3)

	var _spinButton SpinButton // out

	_spinButton = WrapSpinButton(externglib.Take(unsafe.Pointer(_cret)))

	return _spinButton
}

func (s spinButton) ConfigureSpinButton(adjustment Adjustment, climbRate float64, digits uint) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 *C.GtkAdjustment // out
	var _arg2 C.double         // out
	var _arg3 C.guint          // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
	_arg2 = (C.double)(climbRate)
	_arg3 = (C.guint)(digits)

	C.gtk_spin_button_configure(_arg0, _arg1, _arg2, _arg3)
}

func (s spinButton) Adjustment() Adjustment {
	var _arg0 *C.GtkSpinButton // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_adjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (s spinButton) ClimbRate() float64 {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.double         // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_climb_rate(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s spinButton) Digits() uint {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_digits(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s spinButton) Increments() (step float64, page float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // in
	var _arg2 C.double         // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	C.gtk_spin_button_get_increments(_arg0, &_arg1, &_arg2)

	var _step float64 // out
	var _page float64 // out

	_step = (float64)(_arg1)
	_page = (float64)(_arg2)

	return _step, _page
}

func (s spinButton) Numeric() bool {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_numeric(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s spinButton) Range() (min float64, max float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // in
	var _arg2 C.double         // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	C.gtk_spin_button_get_range(_arg0, &_arg1, &_arg2)

	var _min float64 // out
	var _max float64 // out

	_min = (float64)(_arg1)
	_max = (float64)(_arg2)

	return _min, _max
}

func (s spinButton) SnapToTicks() bool {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_snap_to_ticks(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s spinButton) UpdatePolicy() SpinButtonUpdatePolicy {
	var _arg0 *C.GtkSpinButton            // out
	var _cret C.GtkSpinButtonUpdatePolicy // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_update_policy(_arg0)

	var _spinButtonUpdatePolicy SpinButtonUpdatePolicy // out

	_spinButtonUpdatePolicy = SpinButtonUpdatePolicy(_cret)

	return _spinButtonUpdatePolicy
}

func (s spinButton) Value() float64 {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.double         // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (s spinButton) ValueAsInt() int {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.int            // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_value_as_int(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s spinButton) Wrap() bool {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_wrap(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s spinButton) SetAdjustmentSpinButton(adjustment Adjustment) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_spin_button_set_adjustment(_arg0, _arg1)
}

func (s spinButton) SetClimbRateSpinButton(climbRate float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(climbRate)

	C.gtk_spin_button_set_climb_rate(_arg0, _arg1)
}

func (s spinButton) SetDigitsSpinButton(digits uint) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(digits)

	C.gtk_spin_button_set_digits(_arg0, _arg1)
}

func (s spinButton) SetIncrementsSpinButton(step float64, page float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // out
	var _arg2 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(step)
	_arg2 = (C.double)(page)

	C.gtk_spin_button_set_increments(_arg0, _arg1, _arg2)
}

func (s spinButton) SetNumericSpinButton(numeric bool) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if numeric {
		_arg1 = C.TRUE
	}

	C.gtk_spin_button_set_numeric(_arg0, _arg1)
}

func (s spinButton) SetRangeSpinButton(min float64, max float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // out
	var _arg2 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(min)
	_arg2 = (C.double)(max)

	C.gtk_spin_button_set_range(_arg0, _arg1, _arg2)
}

func (s spinButton) SetSnapToTicksSpinButton(snapToTicks bool) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if snapToTicks {
		_arg1 = C.TRUE
	}

	C.gtk_spin_button_set_snap_to_ticks(_arg0, _arg1)
}

func (s spinButton) SetUpdatePolicySpinButton(policy SpinButtonUpdatePolicy) {
	var _arg0 *C.GtkSpinButton            // out
	var _arg1 C.GtkSpinButtonUpdatePolicy // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSpinButtonUpdatePolicy)(policy)

	C.gtk_spin_button_set_update_policy(_arg0, _arg1)
}

func (s spinButton) SetValueSpinButton(value float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(value)

	C.gtk_spin_button_set_value(_arg0, _arg1)
}

func (s spinButton) SetWrapSpinButton(wrap bool) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if wrap {
		_arg1 = C.TRUE
	}

	C.gtk_spin_button_set_wrap(_arg0, _arg1)
}

func (s spinButton) SpinSpinButton(direction SpinType, increment float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.GtkSpinType    // out
	var _arg2 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSpinType)(direction)
	_arg2 = (C.double)(increment)

	C.gtk_spin_button_spin(_arg0, _arg1, _arg2)
}

func (s spinButton) UpdateSpinButton() {
	var _arg0 *C.GtkSpinButton // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	C.gtk_spin_button_update(_arg0)
}

func (s spinButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s spinButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s spinButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s spinButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s spinButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s spinButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s spinButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b spinButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c spinButton) EditingDone() {
	WrapCellEditable(gextras.InternObject(c)).EditingDone()
}

func (c spinButton) RemoveWidget() {
	WrapCellEditable(gextras.InternObject(c)).RemoveWidget()
}

func (c spinButton) StartEditing(event gdk.Event) {
	WrapCellEditable(gextras.InternObject(c)).StartEditing(event)
}

func (e spinButton) DeleteSelection() {
	WrapEditable(gextras.InternObject(e)).DeleteSelection()
}

func (e spinButton) DeleteText(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).DeleteText(startPos, endPos)
}

func (e spinButton) FinishDelegate() {
	WrapEditable(gextras.InternObject(e)).FinishDelegate()
}

func (e spinButton) Alignment() float32 {
	return WrapEditable(gextras.InternObject(e)).Alignment()
}

func (e spinButton) Chars(startPos int, endPos int) string {
	return WrapEditable(gextras.InternObject(e)).Chars(startPos, endPos)
}

func (e spinButton) Delegate() Editable {
	return WrapEditable(gextras.InternObject(e)).Delegate()
}

func (e spinButton) Editable() bool {
	return WrapEditable(gextras.InternObject(e)).Editable()
}

func (e spinButton) EnableUndo() bool {
	return WrapEditable(gextras.InternObject(e)).EnableUndo()
}

func (e spinButton) MaxWidthChars() int {
	return WrapEditable(gextras.InternObject(e)).MaxWidthChars()
}

func (e spinButton) Position() int {
	return WrapEditable(gextras.InternObject(e)).Position()
}

func (e spinButton) SelectionBounds() (startPos int, endPos int, ok bool) {
	return WrapEditable(gextras.InternObject(e)).SelectionBounds()
}

func (e spinButton) Text() string {
	return WrapEditable(gextras.InternObject(e)).Text()
}

func (e spinButton) WidthChars() int {
	return WrapEditable(gextras.InternObject(e)).WidthChars()
}

func (e spinButton) InitDelegate() {
	WrapEditable(gextras.InternObject(e)).InitDelegate()
}

func (e spinButton) SelectRegion(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).SelectRegion(startPos, endPos)
}

func (e spinButton) SetAlignment(xalign float32) {
	WrapEditable(gextras.InternObject(e)).SetAlignment(xalign)
}

func (e spinButton) SetEditable(isEditable bool) {
	WrapEditable(gextras.InternObject(e)).SetEditable(isEditable)
}

func (e spinButton) SetEnableUndo(enableUndo bool) {
	WrapEditable(gextras.InternObject(e)).SetEnableUndo(enableUndo)
}

func (e spinButton) SetMaxWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetMaxWidthChars(nChars)
}

func (e spinButton) SetPosition(position int) {
	WrapEditable(gextras.InternObject(e)).SetPosition(position)
}

func (e spinButton) SetText(text string) {
	WrapEditable(gextras.InternObject(e)).SetText(text)
}

func (e spinButton) SetWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetWidthChars(nChars)
}

func (o spinButton) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o spinButton) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// Spinner: a `GtkSpinner` widget displays an icon-size spinning animation.
//
// It is often used as an alternative to a [class@Gtk.ProgressBar] for
// displaying indefinite activity, instead of actual progress.
//
// !An example GtkSpinner (spinner.png)
//
// To start the animation, use [method@Gtk.Spinner.start], to stop it use
// [method@Gtk.Spinner.stop].
//
//
// CSS nodes
//
// `GtkSpinner` has a single CSS node with the name spinner. When the animation
// is active, the :checked pseudoclass is added to this node.
type Spinner interface {
	Widget

	// Spinning returns whether the spinner is spinning.
	Spinning() bool
	// SetSpinningSpinner sets the activity of the spinner.
	SetSpinningSpinner(spinning bool)
	// StartSpinner starts the animation of the spinner.
	StartSpinner()
	// StopSpinner stops the animation of the spinner.
	StopSpinner()
}

// spinner implements the Spinner class.
type spinner struct {
	Widget
}

// WrapSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinner(obj *externglib.Object) Spinner {
	return spinner{
		Widget: WrapWidget(obj),
	}
}

func marshalSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinner(obj), nil
}

// NewSpinner returns a new spinner widget. Not yet started.
func NewSpinner() Spinner {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_spinner_new()

	var _spinner Spinner // out

	_spinner = WrapSpinner(externglib.Take(unsafe.Pointer(_cret)))

	return _spinner
}

func (s spinner) Spinning() bool {
	var _arg0 *C.GtkSpinner // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spinner_get_spinning(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s spinner) SetSpinningSpinner(spinning bool) {
	var _arg0 *C.GtkSpinner // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))
	if spinning {
		_arg1 = C.TRUE
	}

	C.gtk_spinner_set_spinning(_arg0, _arg1)
}

func (s spinner) StartSpinner() {
	var _arg0 *C.GtkSpinner // out

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	C.gtk_spinner_start(_arg0)
}

func (s spinner) StopSpinner() {
	var _arg0 *C.GtkSpinner // out

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	C.gtk_spinner_stop(_arg0)
}

func (s spinner) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s spinner) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s spinner) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s spinner) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s spinner) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s spinner) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s spinner) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b spinner) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Stack: `GtkStack` is a container which only shows one of its children at a
// time.
//
// In contrast to `GtkNotebook`, `GtkStack` does not provide a means for users
// to change the visible child. Instead, a separate widget such as
// [class@Gtk.StackSwitcher] or [class@Gtk.StackSidebar] can be used with
// `GtkStack` to provide this functionality.
//
// Transitions between pages can be animated as slides or fades. This can be
// controlled with [method@Gtk.Stack.set_transition_type]. These animations
// respect the [property@Gtk.Settings:gtk-enable-animations] setting.
//
// `GtkStack` maintains a [class@Gtk.StackPage] object for each added child,
// which holds additional per-child properties. You obtain the `GtkStackPage`
// for a child with [method@Gtk.Stack.get_page] and you can obtain a
// `GtkSelectionModel` containing all the pages with
// [method@Gtk.Stack.get_pages].
//
//
// GtkStack as GtkBuildable
//
// To set child-specific properties in a .ui file, create `GtkStackPage` objects
// explicitly, and set the child widget as a property on it:
//
// `xml <object class="GtkStack" id="stack"> <child> <object
// class="GtkStackPage"> <property name="name">page1</property> <property
// name="title">In the beginning</property> <property name="child"> <object
// class="GtkLabel"> <property name="label">It was dark</property> </object>
// </property> </object> </child> `
//
//
// CSS nodes
//
// `GtkStack` has a single CSS node named stack.
//
//
// Accessibility
//
// `GtkStack` uses the GTK_ACCESSIBLE_ROLE_TAB_PANEL for the stack pages, which
// are the accessible parent objects of the child widgets.
type Stack interface {
	Widget

	// AddChildStack adds a child to @stack.
	AddChildStack(child Widget) StackPage
	// AddNamedStack adds a child to @stack.
	//
	// The child is identified by the @name.
	AddNamedStack(child Widget, name string) StackPage
	// AddTitledStack adds a child to @stack.
	//
	// The child is identified by the @name. The @title will be used by
	// `GtkStackSwitcher` to represent @child in a tab bar, so it should be
	// short.
	AddTitledStack(child Widget, name string, title string) StackPage
	// ChildByName finds the child with the name given as the argument.
	//
	// Returns nil if there is no child with this name.
	ChildByName(name string) Widget
	// Hhomogeneous gets whether @stack is horizontally homogeneous.
	Hhomogeneous() bool
	// InterpolateSize returns whether the Stack is set up to interpolate
	// between the sizes of children on page switch.
	InterpolateSize() bool
	// Page returns the `GtkStackPage` object for @child.
	Page(child Widget) StackPage
	// Pages returns a `GListModel` that contains the pages of the stack.
	//
	// This can be used to keep an up-to-date view. The model also implements
	// [iface@Gtk.SelectionModel] and can be used to track and modify the
	// visible page.
	Pages() SelectionModel
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions between pages in @stack will take.
	TransitionDuration() uint
	// TransitionRunning returns whether the @stack is currently in a transition
	// from one page to another.
	TransitionRunning() bool
	// TransitionType gets the type of animation that will be used for
	// transitions between pages in @stack.
	TransitionType() StackTransitionType
	// Vhomogeneous gets whether @stack is vertically homogeneous.
	Vhomogeneous() bool
	// VisibleChild gets the currently visible child of @stack.
	//
	// Returns nil if there are no visible children.
	VisibleChild() Widget
	// VisibleChildName returns the name of the currently visible child of
	// @stack.
	//
	// Returns nil if there is no visible child.
	VisibleChildName() string
	// RemoveStack removes a child widget from @stack.
	RemoveStack(child Widget)
	// SetHhomogeneousStack sets the `GtkStack` to be horizontally homogeneous
	// or not.
	//
	// If it is homogeneous, the `GtkStack` will request the same width for all
	// its children. If it isn't, the stack may change width when a different
	// child becomes visible.
	SetHhomogeneousStack(hhomogeneous bool)
	// SetInterpolateSizeStack sets whether or not @stack will interpolate its
	// size when changing the visible child.
	//
	// If the [property@Gtk.Stack:interpolate-size] property is set to true,
	// @stack will interpolate its size between the current one and the one
	// it'll take after changing the visible child, according to the set
	// transition duration.
	SetInterpolateSizeStack(interpolateSize bool)
	// SetTransitionDurationStack sets the duration that transitions between
	// pages in @stack will take.
	SetTransitionDurationStack(duration uint)
	// SetTransitionTypeStack sets the type of animation that will be used for
	// transitions between pages in @stack.
	//
	// Available types include various kinds of fades and slides.
	//
	// The transition type can be changed without problems at runtime, so it is
	// possible to change the animation based on the page that is about to
	// become current.
	SetTransitionTypeStack(transition StackTransitionType)
	// SetVhomogeneousStack sets the Stack to be vertically homogeneous or not.
	//
	// If it is homogeneous, the `GtkStack` will request the same height for all
	// its children. If it isn't, the stack may change height when a different
	// child becomes visible.
	SetVhomogeneousStack(vhomogeneous bool)
	// SetVisibleChildStack makes @child the visible child of @stack.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the @child widget has to be visible itself (see
	// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
	SetVisibleChildStack(child Widget)
	// SetVisibleChildFullStack makes the child with the given name visible.
	//
	// Note that the child widget has to be visible itself (see
	// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
	SetVisibleChildFullStack(name string, transition StackTransitionType)
	// SetVisibleChildNameStack makes the child with the given name visible.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the child widget has to be visible itself (see
	// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
	SetVisibleChildNameStack(name string)
}

// stack implements the Stack class.
type stack struct {
	Widget
}

// WrapStack wraps a GObject to the right type. It is
// primarily used internally.
func WrapStack(obj *externglib.Object) Stack {
	return stack{
		Widget: WrapWidget(obj),
	}
}

func marshalStack(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStack(obj), nil
}

// NewStack creates a new `GtkStack`.
func NewStack() Stack {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_stack_new()

	var _stack Stack // out

	_stack = WrapStack(externglib.Take(unsafe.Pointer(_cret)))

	return _stack
}

func (s stack) AddChildStack(child Widget) StackPage {
	var _arg0 *C.GtkStack     // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GtkStackPage // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_stack_add_child(_arg0, _arg1)

	var _stackPage StackPage // out

	_stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StackPage)

	return _stackPage
}

func (s stack) AddNamedStack(child Widget, name string) StackPage {
	var _arg0 *C.GtkStack     // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.char         // out
	var _cret *C.GtkStackPage // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_stack_add_named(_arg0, _arg1, _arg2)

	var _stackPage StackPage // out

	_stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StackPage)

	return _stackPage
}

func (s stack) AddTitledStack(child Widget, name string, title string) StackPage {
	var _arg0 *C.GtkStack     // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.char         // out
	var _arg3 *C.char         // out
	var _cret *C.GtkStackPage // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_stack_add_titled(_arg0, _arg1, _arg2, _arg3)

	var _stackPage StackPage // out

	_stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StackPage)

	return _stackPage
}

func (s stack) ChildByName(name string) Widget {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_stack_get_child_by_name(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s stack) Hhomogeneous() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_hhomogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s stack) InterpolateSize() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_interpolate_size(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s stack) Page(child Widget) StackPage {
	var _arg0 *C.GtkStack     // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GtkStackPage // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_stack_get_page(_arg0, _arg1)

	var _stackPage StackPage // out

	_stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StackPage)

	return _stackPage
}

func (s stack) Pages() SelectionModel {
	var _arg0 *C.GtkStack          // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_pages(_arg0)

	var _selectionModel SelectionModel // out

	_selectionModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SelectionModel)

	return _selectionModel
}

func (s stack) TransitionDuration() uint {
	var _arg0 *C.GtkStack // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_transition_duration(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s stack) TransitionRunning() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_transition_running(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s stack) TransitionType() StackTransitionType {
	var _arg0 *C.GtkStack              // out
	var _cret C.GtkStackTransitionType // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_transition_type(_arg0)

	var _stackTransitionType StackTransitionType // out

	_stackTransitionType = StackTransitionType(_cret)

	return _stackTransitionType
}

func (s stack) Vhomogeneous() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_vhomogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s stack) VisibleChild() Widget {
	var _arg0 *C.GtkStack  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_visible_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s stack) VisibleChildName() string {
	var _arg0 *C.GtkStack // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_visible_child_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s stack) RemoveStack(child Widget) {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_stack_remove(_arg0, _arg1)
}

func (s stack) SetHhomogeneousStack(hhomogeneous bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if hhomogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_hhomogeneous(_arg0, _arg1)
}

func (s stack) SetInterpolateSizeStack(interpolateSize bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if interpolateSize {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_interpolate_size(_arg0, _arg1)
}

func (s stack) SetTransitionDurationStack(duration uint) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(duration)

	C.gtk_stack_set_transition_duration(_arg0, _arg1)
}

func (s stack) SetTransitionTypeStack(transition StackTransitionType) {
	var _arg0 *C.GtkStack              // out
	var _arg1 C.GtkStackTransitionType // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_transition_type(_arg0, _arg1)
}

func (s stack) SetVhomogeneousStack(vhomogeneous bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if vhomogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_vhomogeneous(_arg0, _arg1)
}

func (s stack) SetVisibleChildStack(child Widget) {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_stack_set_visible_child(_arg0, _arg1)
}

func (s stack) SetVisibleChildFullStack(name string, transition StackTransitionType) {
	var _arg0 *C.GtkStack              // out
	var _arg1 *C.char                  // out
	var _arg2 C.GtkStackTransitionType // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_visible_child_full(_arg0, _arg1, _arg2)
}

func (s stack) SetVisibleChildNameStack(name string) {
	var _arg0 *C.GtkStack // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_set_visible_child_name(_arg0, _arg1)
}

func (s stack) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s stack) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s stack) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s stack) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s stack) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s stack) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s stack) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b stack) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// StackPage: `GtkStackPage` is an auxiliary class used by `GtkStack`.
type StackPage interface {
	Accessible

	// Child returns the stack child to which @self belongs.
	Child() Widget
	// IconName returns the icon name of the page.
	IconName() string
	// Name returns the name of the page.
	Name() string
	// NeedsAttention returns whether the page is marked as needs attention.
	NeedsAttention() bool
	// Title gets the page title.
	Title() string
	// UseUnderline gets whether underlines in the page title indicate
	// mnemonics.
	UseUnderline() bool
	// Visible returns whether @page is visible in its `GtkStack`.
	//
	// This is independent from the [property@Gtk.Widget:visible] property of
	// its widget.
	Visible() bool
	// SetIconNameStackPage sets the icon name of the page.
	SetIconNameStackPage(setting string)
	// SetNameStackPage sets the name of the page.
	SetNameStackPage(setting string)
	// SetNeedsAttentionStackPage sets whether the page is marked as needs
	// attention.
	SetNeedsAttentionStackPage(setting bool)
	// SetTitleStackPage sets the page title.
	SetTitleStackPage(setting string)
	// SetUseUnderlineStackPage sets whether underlines in the page title
	// indicate mnemonics.
	SetUseUnderlineStackPage(setting bool)
	// SetVisibleStackPage sets whether @page is visible in its `GtkStack`.
	SetVisibleStackPage(visible bool)
}

// stackPage implements the StackPage class.
type stackPage struct {
	gextras.Objector
}

// WrapStackPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackPage(obj *externglib.Object) StackPage {
	return stackPage{
		Objector: obj,
	}
}

func marshalStackPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackPage(obj), nil
}

func (s stackPage) Child() Widget {
	var _arg0 *C.GtkStackPage // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_page_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s stackPage) IconName() string {
	var _arg0 *C.GtkStackPage // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_page_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s stackPage) Name() string {
	var _arg0 *C.GtkStackPage // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_page_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s stackPage) NeedsAttention() bool {
	var _arg0 *C.GtkStackPage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_page_get_needs_attention(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s stackPage) Title() string {
	var _arg0 *C.GtkStackPage // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_page_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s stackPage) UseUnderline() bool {
	var _arg0 *C.GtkStackPage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_page_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s stackPage) Visible() bool {
	var _arg0 *C.GtkStackPage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_page_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s stackPage) SetIconNameStackPage(setting string) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(setting))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_page_set_icon_name(_arg0, _arg1)
}

func (s stackPage) SetNameStackPage(setting string) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(setting))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_page_set_name(_arg0, _arg1)
}

func (s stackPage) SetNeedsAttentionStackPage(setting bool) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_stack_page_set_needs_attention(_arg0, _arg1)
}

func (s stackPage) SetTitleStackPage(setting string) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(setting))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_page_set_title(_arg0, _arg1)
}

func (s stackPage) SetUseUnderlineStackPage(setting bool) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_stack_page_set_use_underline(_arg0, _arg1)
}

func (s stackPage) SetVisibleStackPage(visible bool) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_stack_page_set_visible(_arg0, _arg1)
}

func (s stackPage) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s stackPage) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s stackPage) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s stackPage) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s stackPage) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s stackPage) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s stackPage) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

// StackSidebar: a `GtkStackSidebar` uses a sidebar to switch between `GtkStack`
// pages.
//
// In order to use a `GtkStackSidebar`, you simply use a `GtkStack` to organize
// your UI flow, and add the sidebar to your sidebar area. You can use
// [method@Gtk.StackSidebar.set_stack] to connect the `GtkStackSidebar` to the
// `GtkStack`.
//
//
// CSS nodes
//
// `GtkStackSidebar` has a single CSS node with name stacksidebar and style
// class .sidebar.
//
// When circumstances require it, `GtkStackSidebar` adds the .needs-attention
// style class to the widgets representing the stack pages.
type StackSidebar interface {
	Widget

	// Stack retrieves the stack.
	Stack() Stack
	// SetStackStackSidebar: set the `GtkStack` associated with this
	// `GtkStackSidebar`.
	//
	// The sidebar widget will automatically update according to the order and
	// items within the given `GtkStack`.
	SetStackStackSidebar(stack Stack)
}

// stackSidebar implements the StackSidebar class.
type stackSidebar struct {
	Widget
}

// WrapStackSidebar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSidebar(obj *externglib.Object) StackSidebar {
	return stackSidebar{
		Widget: WrapWidget(obj),
	}
}

func marshalStackSidebar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSidebar(obj), nil
}

// NewStackSidebar creates a new `GtkStackSidebar`.
func NewStackSidebar() StackSidebar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_stack_sidebar_new()

	var _stackSidebar StackSidebar // out

	_stackSidebar = WrapStackSidebar(externglib.Take(unsafe.Pointer(_cret)))

	return _stackSidebar
}

func (s stackSidebar) Stack() Stack {
	var _arg0 *C.GtkStackSidebar // out
	var _cret *C.GtkStack        // in

	_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_sidebar_get_stack(_arg0)

	var _stack Stack // out

	_stack = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Stack)

	return _stack
}

func (s stackSidebar) SetStackStackSidebar(stack Stack) {
	var _arg0 *C.GtkStackSidebar // out
	var _arg1 *C.GtkStack        // out

	_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

	C.gtk_stack_sidebar_set_stack(_arg0, _arg1)
}

func (s stackSidebar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s stackSidebar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s stackSidebar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s stackSidebar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s stackSidebar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s stackSidebar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s stackSidebar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b stackSidebar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// StackSwitcher: the `GtkStackSwitcher` shows a row of buttons to switch
// between `GtkStack` pages.
//
// !An example GtkStackSwitcher (stackswitcher.png)
//
// It acts as a controller for the associated `GtkStack`.
//
// All the content for the buttons comes from the properties of the stacks
// [class@Gtk.StackPage] objects; the button visibility in a `GtkStackSwitcher`
// widget is controlled by the visibility of the child in the `GtkStack`.
//
// It is possible to associate multiple `GtkStackSwitcher` widgets with the same
// `GtkStack` widget.
//
//
// CSS nodes
//
// `GtkStackSwitcher` has a single CSS node named stackswitcher and style class
// .stack-switcher.
//
// When circumstances require it, `GtkStackSwitcher` adds the .needs-attention
// style class to the widgets representing the stack pages.
//
//
// Accessibility
//
// `GtkStackSwitcher` uses the GTK_ACCESSIBLE_ROLE_TAB_LIST role and uses the
// GTK_ACCESSIBLE_ROLE_TAB for its buttons.
type StackSwitcher interface {
	Widget

	// Stack retrieves the stack.
	Stack() Stack
	// SetStackStackSwitcher sets the stack to control.
	SetStackStackSwitcher(stack Stack)
}

// stackSwitcher implements the StackSwitcher class.
type stackSwitcher struct {
	Widget
}

// WrapStackSwitcher wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSwitcher(obj *externglib.Object) StackSwitcher {
	return stackSwitcher{
		Widget: WrapWidget(obj),
	}
}

func marshalStackSwitcher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSwitcher(obj), nil
}

// NewStackSwitcher: create a new `GtkStackSwitcher`.
func NewStackSwitcher() StackSwitcher {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_stack_switcher_new()

	var _stackSwitcher StackSwitcher // out

	_stackSwitcher = WrapStackSwitcher(externglib.Take(unsafe.Pointer(_cret)))

	return _stackSwitcher
}

func (s stackSwitcher) Stack() Stack {
	var _arg0 *C.GtkStackSwitcher // out
	var _cret *C.GtkStack         // in

	_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_switcher_get_stack(_arg0)

	var _stack Stack // out

	_stack = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Stack)

	return _stack
}

func (s stackSwitcher) SetStackStackSwitcher(stack Stack) {
	var _arg0 *C.GtkStackSwitcher // out
	var _arg1 *C.GtkStack         // out

	_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

	C.gtk_stack_switcher_set_stack(_arg0, _arg1)
}

func (s stackSwitcher) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s stackSwitcher) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s stackSwitcher) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s stackSwitcher) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s stackSwitcher) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s stackSwitcher) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s stackSwitcher) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b stackSwitcher) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Statusbar: a `GtkStatusbar` widget is usually placed along the bottom of an
// application's main [class@Gtk.Window].
//
// !An example GtkStatusbar (statusbar.png)
//
// A `GtkStatusBar` may provide a regular commentary of the application's status
// (as is usually the case in a web browser, for example), or may be used to
// simply output a message when the status changes, (when an upload is complete
// in an FTP client, for example).
//
// Status bars in GTK maintain a stack of messages. The message at the top of
// the each bars stack is the one that will currently be displayed.
//
// Any messages added to a statusbars stack must specify a context id that is
// used to uniquely identify the source of a message. This context id can be
// generated by [method@Gtk.Statusbar.get_context_id], given a message and the
// statusbar that it will be added to. Note that messages are stored in a stack,
// and when choosing which message to display, the stack structure is adhered
// to, regardless of the context identifier of a message.
//
// One could say that a statusbar maintains one stack of messages for display
// purposes, but allows multiple message producers to maintain sub-stacks of the
// messages they produced (via context ids).
//
// Status bars are created using [ctor@Gtk.Statusbar.new].
//
// Messages are added to the bars stack with [method@Gtk.Statusbar.push].
//
// The message at the top of the stack can be removed using
// [method@Gtk.Statusbar.pop]. A message can be removed from anywhere in the
// stack if its message id was recorded at the time it was added. This is done
// using [method@Gtk.Statusbar.remove].
//
//
// CSS node
//
// `GtkStatusbar` has a single CSS node with name `statusbar`.
type Statusbar interface {
	Widget

	// ContextID returns a new context identifier, given a description of the
	// actual context.
	//
	// Note that the description is not shown in the UI.
	ContextID(contextDescription string) uint
	// PopStatusbar removes the first message in the `GtkStatusbar`s stack with
	// the given context id.
	//
	// Note that this may not change the displayed message, if the message at
	// the top of the stack has a different context id.
	PopStatusbar(contextId uint)
	// PushStatusbar pushes a new message onto a statusbars stack.
	PushStatusbar(contextId uint, text string) uint
	// RemoveStatusbar forces the removal of a message from a statusbars stack.
	// The exact @context_id and @message_id must be specified.
	RemoveStatusbar(contextId uint, messageId uint)
	// RemoveAllStatusbar forces the removal of all messages from a statusbar's
	// stack with the exact @context_id.
	RemoveAllStatusbar(contextId uint)
}

// statusbar implements the Statusbar class.
type statusbar struct {
	Widget
}

// WrapStatusbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStatusbar(obj *externglib.Object) Statusbar {
	return statusbar{
		Widget: WrapWidget(obj),
	}
}

func marshalStatusbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStatusbar(obj), nil
}

// NewStatusbar creates a new `GtkStatusbar` ready for messages.
func NewStatusbar() Statusbar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_statusbar_new()

	var _statusbar Statusbar // out

	_statusbar = WrapStatusbar(externglib.Take(unsafe.Pointer(_cret)))

	return _statusbar
}

func (s statusbar) ContextID(contextDescription string) uint {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 *C.char         // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(contextDescription))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_statusbar_get_context_id(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s statusbar) PopStatusbar(contextId uint) {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(contextId)

	C.gtk_statusbar_pop(_arg0, _arg1)
}

func (s statusbar) PushStatusbar(contextId uint, text string) uint {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out
	var _arg2 *C.char         // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(contextId)
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_statusbar_push(_arg0, _arg1, _arg2)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s statusbar) RemoveStatusbar(contextId uint, messageId uint) {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out
	var _arg2 C.guint         // out

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(contextId)
	_arg2 = (C.guint)(messageId)

	C.gtk_statusbar_remove(_arg0, _arg1, _arg2)
}

func (s statusbar) RemoveAllStatusbar(contextId uint) {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(contextId)

	C.gtk_statusbar_remove_all(_arg0, _arg1)
}

func (s statusbar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s statusbar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s statusbar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s statusbar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s statusbar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s statusbar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s statusbar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b statusbar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// StringFilter: `GtkStringFilter` determines whether to include items by
// comparing strings to a fixed search term.
//
// The strings are obtained from the items by evaluating a `GtkExpression` set
// with [method@Gtk.StringFilter.set_expression], and they are compared against
// a search term set with [method@Gtk.StringFilter.set_search].
//
// `GtkStringFilter` has several different modes of comparison - it can match
// the whole string, just a prefix, or any substring. Use
// [method@Gtk.StringFilter.set_match_mode] choose a mode.
//
// It is also possible to make case-insensitive comparisons, with
// [method@Gtk.StringFilter.set_ignore_case].
type StringFilter interface {

	// Expression gets the expression that the string filter uses to obtain
	// strings from items.
	Expression() Expression
	// IgnoreCase returns whether the filter ignores case differences.
	IgnoreCase() bool
	// MatchMode returns the match mode that the filter is using.
	MatchMode() StringFilterMatchMode
	// Search gets the search term.
	Search() string
	// SetExpressionStringFilter sets the expression that the string filter uses
	// to obtain strings from items.
	//
	// The expression must have a value type of G_TYPE_STRING.
	SetExpressionStringFilter(expression Expression)
	// SetIgnoreCaseStringFilter sets whether the filter ignores case
	// differences.
	SetIgnoreCaseStringFilter(ignoreCase bool)
	// SetMatchModeStringFilter sets the match mode for the filter.
	SetMatchModeStringFilter(mode StringFilterMatchMode)
	// SetSearchStringFilter sets the string to search for.
	SetSearchStringFilter(search string)
}

// stringFilter implements the StringFilter class.
type stringFilter struct {
	Filter
}

// WrapStringFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapStringFilter(obj *externglib.Object) StringFilter {
	return stringFilter{
		Filter: WrapFilter(obj),
	}
}

func marshalStringFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStringFilter(obj), nil
}

// NewStringFilter creates a new string filter.
//
// You will want to set up the filter by providing a string to search for and by
// providing a property to look up on the item.
func NewStringFilter(expression Expression) StringFilter {
	var _arg1 *C.GtkExpression   // out
	var _cret *C.GtkStringFilter // in

	_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	_cret = C.gtk_string_filter_new(_arg1)

	var _stringFilter StringFilter // out

	_stringFilter = WrapStringFilter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _stringFilter
}

func (s stringFilter) Expression() Expression {
	var _arg0 *C.GtkStringFilter // out
	var _cret *C.GtkExpression   // in

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_string_filter_get_expression(_arg0)

	var _expression Expression // out

	_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

	return _expression
}

func (s stringFilter) IgnoreCase() bool {
	var _arg0 *C.GtkStringFilter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_string_filter_get_ignore_case(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s stringFilter) MatchMode() StringFilterMatchMode {
	var _arg0 *C.GtkStringFilter         // out
	var _cret C.GtkStringFilterMatchMode // in

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_string_filter_get_match_mode(_arg0)

	var _stringFilterMatchMode StringFilterMatchMode // out

	_stringFilterMatchMode = StringFilterMatchMode(_cret)

	return _stringFilterMatchMode
}

func (s stringFilter) Search() string {
	var _arg0 *C.GtkStringFilter // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_string_filter_get_search(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s stringFilter) SetExpressionStringFilter(expression Expression) {
	var _arg0 *C.GtkStringFilter // out
	var _arg1 *C.GtkExpression   // out

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	C.gtk_string_filter_set_expression(_arg0, _arg1)
}

func (s stringFilter) SetIgnoreCaseStringFilter(ignoreCase bool) {
	var _arg0 *C.GtkStringFilter // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))
	if ignoreCase {
		_arg1 = C.TRUE
	}

	C.gtk_string_filter_set_ignore_case(_arg0, _arg1)
}

func (s stringFilter) SetMatchModeStringFilter(mode StringFilterMatchMode) {
	var _arg0 *C.GtkStringFilter         // out
	var _arg1 C.GtkStringFilterMatchMode // out

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkStringFilterMatchMode)(mode)

	C.gtk_string_filter_set_match_mode(_arg0, _arg1)
}

func (s stringFilter) SetSearchStringFilter(search string) {
	var _arg0 *C.GtkStringFilter // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(search))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_string_filter_set_search(_arg0, _arg1)
}

// StringSorter: `GtkStringSorter` is a `GtkSorter` that compares strings.
//
// It does the comparison in a linguistically correct way using the current
// locale by normalizing Unicode strings and possibly case-folding them before
// performing the comparison.
//
// To obtain the strings to compare, this sorter evaluates a
// [class@Gtk.Expression].
type StringSorter interface {

	// Expression gets the expression that is evaluated to obtain strings from
	// items.
	Expression() Expression
	// IgnoreCase gets whether the sorter ignores case differences.
	IgnoreCase() bool
	// SetExpressionStringSorter sets the expression that is evaluated to obtain
	// strings from items.
	//
	// The expression must have the type G_TYPE_STRING.
	SetExpressionStringSorter(expression Expression)
	// SetIgnoreCaseStringSorter sets whether the sorter will ignore case
	// differences.
	SetIgnoreCaseStringSorter(ignoreCase bool)
}

// stringSorter implements the StringSorter class.
type stringSorter struct {
	Sorter
}

// WrapStringSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapStringSorter(obj *externglib.Object) StringSorter {
	return stringSorter{
		Sorter: WrapSorter(obj),
	}
}

func marshalStringSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStringSorter(obj), nil
}

// NewStringSorter creates a new string sorter that compares items using the
// given @expression.
//
// Unless an expression is set on it, this sorter will always compare items as
// invalid.
func NewStringSorter(expression Expression) StringSorter {
	var _arg1 *C.GtkExpression   // out
	var _cret *C.GtkStringSorter // in

	_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	_cret = C.gtk_string_sorter_new(_arg1)

	var _stringSorter StringSorter // out

	_stringSorter = WrapStringSorter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _stringSorter
}

func (s stringSorter) Expression() Expression {
	var _arg0 *C.GtkStringSorter // out
	var _cret *C.GtkExpression   // in

	_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_string_sorter_get_expression(_arg0)

	var _expression Expression // out

	_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

	return _expression
}

func (s stringSorter) IgnoreCase() bool {
	var _arg0 *C.GtkStringSorter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_string_sorter_get_ignore_case(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s stringSorter) SetExpressionStringSorter(expression Expression) {
	var _arg0 *C.GtkStringSorter // out
	var _arg1 *C.GtkExpression   // out

	_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

	C.gtk_string_sorter_set_expression(_arg0, _arg1)
}

func (s stringSorter) SetIgnoreCaseStringSorter(ignoreCase bool) {
	var _arg0 *C.GtkStringSorter // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(s.Native()))
	if ignoreCase {
		_arg1 = C.TRUE
	}

	C.gtk_string_sorter_set_ignore_case(_arg0, _arg1)
}

// StyleContext: `GtkStyleContext` stores styling information affecting a
// widget.
//
// In order to construct the final style information, `GtkStyleContext` queries
// information from all attached `GtkStyleProviders`. Style providers can be
// either attached explicitly to the context through
// [method@Gtk.StyleContext.add_provider], or to the display through
// [func@Gtk.StyleContext.add_provider_for_display]. The resulting style is a
// combination of all providers information in priority order.
//
// For GTK widgets, any `GtkStyleContext` returned by
// [method@Gtk.Widget.get_style_context] will already have a `GdkDisplay` and
// RTL/LTR information set. The style context will also be updated automatically
// if any of these settings change on the widget.
//
//
// Style Classes
//
// Widgets can add style classes to their context, which can be used to
// associate different styles by class. The documentation for individual widgets
// lists which style classes it uses itself, and which style classes may be
// added by applications to affect their appearance.
//
//
// Custom styling in UI libraries and applications
//
// If you are developing a library with custom widgets that render differently
// than standard components, you may need to add a `GtkStyleProvider` yourself
// with the GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either a
// `GtkCssProvider` or a custom object implementing the `GtkStyleProvider`
// interface. This way themes may still attempt to style your UI elements in a
// different way if needed so.
//
// If you are using custom styling on an applications, you probably want then to
// make your style information prevail to the themes, so you must use a
// `GtkStyleProvider` with the GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority,
// keep in mind that the user settings in `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
// still take precedence over your changes, as it uses the
// GTK_STYLE_PROVIDER_PRIORITY_USER priority.
type StyleContext interface {

	// AddClassStyleContext adds a style class to @context, so later uses of the
	// style context will make use of this new class for styling.
	//
	// In the CSS file format, a `GtkEntry` defining a search class, would be
	// matched by:
	//
	// `css entry.search { ... } `
	//
	// While any widget defining a search class would be matched by: `css
	// .search { ... } `
	AddClassStyleContext(className string)
	// AddProviderStyleContext adds a style provider to @context, to be used in
	// style construction.
	//
	// Note that a style provider added by this function only affects the style
	// of the widget to which @context belongs. If you want to affect the style
	// of all widgets, use [func@Gtk.StyleContext.add_provider_for_display].
	//
	// Note: If both priorities are the same, a `GtkStyleProvider` added through
	// this function takes precedence over another added through
	// [func@Gtk.StyleContext.add_provider_for_display].
	AddProviderStyleContext(provider StyleProvider, priority uint)
	// Border gets the border for a given state as a `GtkBorder`.
	Border() Border
	// Color gets the foreground color for a given state.
	Color() gdk.RGBA
	// Display returns the `GdkDisplay` to which @context is attached.
	Display() gdk.Display
	// Margin gets the margin for a given state as a `GtkBorder`.
	Margin() Border
	// Padding gets the padding for a given state as a `GtkBorder`.
	Padding() Border
	// Scale returns the scale used for assets.
	Scale() int
	// State returns the state used for style matching.
	//
	// This method should only be used to retrieve the `GtkStateFlags` to pass
	// to `GtkStyleContext` methods, like [method@Gtk.StyleContext.get_padding].
	// If you need to retrieve the current state of a `GtkWidget`, use
	// [method@Gtk.Widget.get_state_flags].
	State() StateFlags
	// HasClassStyleContext returns true if @context currently has defined the
	// given class name.
	HasClassStyleContext(className string) bool
	// LookupColorStyleContext looks up and resolves a color name in the
	// @context color map.
	LookupColorStyleContext(colorName string) (gdk.RGBA, bool)
	// RemoveClassStyleContext removes @class_name from @context.
	RemoveClassStyleContext(className string)
	// RemoveProviderStyleContext removes @provider from the style providers
	// list in @context.
	RemoveProviderStyleContext(provider StyleProvider)
	// RestoreStyleContext restores @context state to a previous stage.
	//
	// See [method@Gtk.StyleContext.save].
	RestoreStyleContext()
	// SaveStyleContext saves the @context state.
	//
	// This allows temporary modifications done through
	// [method@Gtk.StyleContext.add_class],
	// [method@Gtk.StyleContext.remove_class],
	// [method@Gtk.StyleContext.set_state] to be quickly reverted in one go
	// through [method@Gtk.StyleContext.restore].
	//
	// The matching call to [method@Gtk.StyleContext.restore] must be done
	// before GTK returns to the main loop.
	SaveStyleContext()
	// SetDisplayStyleContext attaches @context to the given display.
	//
	// The display is used to add style information from global style
	// providers, such as the display's `GtkSettings` instance.
	//
	// If you are using a `GtkStyleContext` returned from
	// [method@Gtk.Widget.get_style_context], you do not need to call this
	// yourself.
	SetDisplayStyleContext(display gdk.Display)
	// SetScaleStyleContext sets the scale to use when getting image assets for
	// the style.
	SetScaleStyleContext(scale int)
	// SetStateStyleContext sets the state to be used for style matching.
	SetStateStyleContext(flags StateFlags)
	// String converts the style context into a string representation.
	//
	// The string representation always includes information about the name,
	// state, id, visibility and style classes of the CSS node that is backing
	// @context. Depending on the flags, more information may be included.
	//
	// This function is intended for testing and debugging of the CSS
	// implementation in GTK. There are no guarantees about the format of the
	// returned string, it may change.
	String(flags StyleContextPrintFlags) string
}

// styleContext implements the StyleContext class.
type styleContext struct {
	gextras.Objector
}

// WrapStyleContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapStyleContext(obj *externglib.Object) StyleContext {
	return styleContext{
		Objector: obj,
	}
}

func marshalStyleContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleContext(obj), nil
}

func (c styleContext) AddClassStyleContext(className string) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(className))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_style_context_add_class(_arg0, _arg1)
}

func (c styleContext) AddProviderStyleContext(provider StyleProvider, priority uint) {
	var _arg0 *C.GtkStyleContext  // out
	var _arg1 *C.GtkStyleProvider // out
	var _arg2 C.guint             // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(provider.Native()))
	_arg2 = (C.guint)(priority)

	C.gtk_style_context_add_provider(_arg0, _arg1, _arg2)
}

func (c styleContext) Border() Border {
	var _arg0 *C.GtkStyleContext // out
	var _border Border

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_get_border(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_border)))

	return _border
}

func (c styleContext) Color() gdk.RGBA {
	var _arg0 *C.GtkStyleContext // out
	var _color gdk.RGBA

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_get_color(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	return _color
}

func (c styleContext) Display() gdk.Display {
	var _arg0 *C.GtkStyleContext // out
	var _cret *C.GdkDisplay      // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_display(_arg0)

	var _display gdk.Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

	return _display
}

func (c styleContext) Margin() Border {
	var _arg0 *C.GtkStyleContext // out
	var _margin Border

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_get_margin(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_margin)))

	return _margin
}

func (c styleContext) Padding() Border {
	var _arg0 *C.GtkStyleContext // out
	var _padding Border

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_get_padding(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_padding)))

	return _padding
}

func (c styleContext) Scale() int {
	var _arg0 *C.GtkStyleContext // out
	var _cret C.int              // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_scale(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (c styleContext) State() StateFlags {
	var _arg0 *C.GtkStyleContext // out
	var _cret C.GtkStateFlags    // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_state(_arg0)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

func (c styleContext) HasClassStyleContext(className string) bool {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.char            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(className))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_context_has_class(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c styleContext) LookupColorStyleContext(colorName string) (gdk.RGBA, bool) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.char            // out
	var _color gdk.RGBA
	var _cret C.gboolean // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(colorName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_context_lookup_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _color, _ok
}

func (c styleContext) RemoveClassStyleContext(className string) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(className))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_style_context_remove_class(_arg0, _arg1)
}

func (c styleContext) RemoveProviderStyleContext(provider StyleProvider) {
	var _arg0 *C.GtkStyleContext  // out
	var _arg1 *C.GtkStyleProvider // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(provider.Native()))

	C.gtk_style_context_remove_provider(_arg0, _arg1)
}

func (c styleContext) RestoreStyleContext() {
	var _arg0 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_restore(_arg0)
}

func (c styleContext) SaveStyleContext() {
	var _arg0 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_save(_arg0)
}

func (c styleContext) SetDisplayStyleContext(display gdk.Display) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.GdkDisplay      // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	C.gtk_style_context_set_display(_arg0, _arg1)
}

func (c styleContext) SetScaleStyleContext(scale int) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.int              // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(scale)

	C.gtk_style_context_set_scale(_arg0, _arg1)
}

func (c styleContext) SetStateStyleContext(flags StateFlags) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateFlags    // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateFlags)(flags)

	C.gtk_style_context_set_state(_arg0, _arg1)
}

func (c styleContext) String(flags StyleContextPrintFlags) string {
	var _arg0 *C.GtkStyleContext          // out
	var _arg1 C.GtkStyleContextPrintFlags // out
	var _cret *C.char                     // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStyleContextPrintFlags)(flags)

	_cret = C.gtk_style_context_to_string(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Switch: `GtkSwitch` is a "light switch" that has two states: on or off.
//
// !An example GtkSwitch (switch.png)
//
// The user can control which state should be active by clicking the empty area,
// or by dragging the handle.
//
// `GtkSwitch` can also handle situations where the underlying state changes
// with a delay. See [signal@GtkSwitch::state-set] for details.
//
//
// CSS nodes
//
// ` switch  label  label  slider `
//
// `GtkSwitch` has four css nodes, the main node with the name switch and
// subnodes for the slider and the on and off labels. Neither of them is using
// any style classes.
//
//
// Accessibility
//
// `GtkSwitch` uses the GTK_ACCESSIBLE_ROLE_SWITCH role.
type Switch interface {
	Actionable

	// Active gets whether the `GtkSwitch` is in its on or off state.
	Active() bool
	// State gets the underlying state of the `GtkSwitch`.
	State() bool
	// SetActiveSwitch changes the state of @self to the desired one.
	SetActiveSwitch(isActive bool)
	// SetStateSwitch sets the underlying state of the `GtkSwitch`.
	//
	// Normally, this is the same as [property@Gtk.Switch:active], unless the
	// switch is set up for delayed state changes. This function is typically
	// called from a [signal@Gtk.Switch`::state-set] signal handler.
	//
	// See [signal@Gtk.Switch::state-set] for details.
	SetStateSwitch(state bool)
}

// _switch implements the Switch class.
type _switch struct {
	Widget
}

// WrapSwitch wraps a GObject to the right type. It is
// primarily used internally.
func WrapSwitch(obj *externglib.Object) Switch {
	return _switch{
		Widget: WrapWidget(obj),
	}
}

func marshalSwitch(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSwitch(obj), nil
}

// NewSwitch creates a new `GtkSwitch` widget.
func NewSwitch() Switch {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_switch_new()

	var __switch Switch // out

	__switch = WrapSwitch(externglib.Take(unsafe.Pointer(_cret)))

	return __switch
}

func (s _switch) Active() bool {
	var _arg0 *C.GtkSwitch // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_switch_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s _switch) State() bool {
	var _arg0 *C.GtkSwitch // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_switch_get_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s _switch) SetActiveSwitch(isActive bool) {
	var _arg0 *C.GtkSwitch // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
	if isActive {
		_arg1 = C.TRUE
	}

	C.gtk_switch_set_active(_arg0, _arg1)
}

func (s _switch) SetStateSwitch(state bool) {
	var _arg0 *C.GtkSwitch // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
	if state {
		_arg1 = C.TRUE
	}

	C.gtk_switch_set_state(_arg0, _arg1)
}

func (s _switch) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s _switch) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s _switch) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s _switch) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s _switch) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s _switch) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s _switch) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (a _switch) ActionName() string {
	return WrapActionable(gextras.InternObject(a)).ActionName()
}

func (a _switch) ActionTargetValue() *glib.Variant {
	return WrapActionable(gextras.InternObject(a)).ActionTargetValue()
}

func (a _switch) SetActionName(actionName string) {
	WrapActionable(gextras.InternObject(a)).SetActionName(actionName)
}

func (a _switch) SetActionTargetValue(targetValue *glib.Variant) {
	WrapActionable(gextras.InternObject(a)).SetActionTargetValue(targetValue)
}

func (a _switch) SetDetailedActionName(detailedActionName string) {
	WrapActionable(gextras.InternObject(a)).SetDetailedActionName(detailedActionName)
}

func (b _switch) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Text: the `GtkText` widget is a single-line text entry widget.
//
// `GtkText` is the common implementation of single-line text editing that is
// shared between `GtkEntry`, `GtkPasswordEntry, `GtkSpinButton` and other
// widgets. In all of these, `GtkText` is used as the delegate for the
// [iface@Gtk.Editable] implementation.
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into password mode using [method@Gtk.Text.set_visibility]. In this
// mode, entered text is displayed using a invisible character. By default,
// GTK picks the best invisible character that is available in the current font,
// but it can be changed with [method@Gtk.Text.set_invisible_char].
//
// If you are looking to add icons or progress display in an entry, look at
// `GtkEntry`. There other alternatives for more specialized use cases, such as
// `GtkSearchEntry`.
//
// If you need multi-line editable text, look at `GtkTextView`.
//
//
// CSS nodes
//
// ` text[.read-only]  placeholder  undershoot.left  undershoot.right
//  [selection]  [block-cursor]  [window.popup] `
//
// `GtkText` has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
//
// Accessibility
//
// `GtkText` uses the GTK_ACCESSIBLE_ROLE_NONE role, which causes it to be
// skipped for accessibility. This is because `GtkText` is expected to be used
// as a delegate for a `GtkEditable` implementation that will be represented to
// accessibility.
type Text interface {
	Editable

	// ActivatesDefault retrieves the value set by
	// gtk_text_set_activates_default().
	ActivatesDefault() bool
	// Attributes gets the attribute list that was set on the `GtkText` using
	// gtk_text_set_attributes().
	Attributes() *pango.AttrList
	// Buffer: get the `GtkEntryBuffer` object which holds the text for this
	// self.
	Buffer() EntryBuffer
	// EnableEmojiCompletion returns whether Emoji completion is enabled for
	// this `GtkText` widget.
	EnableEmojiCompletion() bool
	// ExtraMenu gets the menu model set with gtk_text_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// InputHints gets the input hints of the `GtkText`.
	InputHints() InputHints
	// InputPurpose gets the input purpose of the `GtkText`.
	InputPurpose() InputPurpose
	// InvisibleChar retrieves the character displayed in place of the real
	// characters for entries with visibility set to false.
	//
	// Note that GTK does not compute this value unless it needs it, so the
	// value returned by this function is not very useful unless it has been
	// explicitly set with [method@Gtk.Text.set_invisible_char].
	InvisibleChar() uint32
	// MaxLength retrieves the maximum allowed length of the text in @self.
	//
	// See [method@Gtk.Text.set_max_length].
	//
	// This is equivalent to getting @self's `GtkEntryBuffer` and calling
	// [method@Gtk.EntryBuffer.get_max_length] on it.
	MaxLength() int
	// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
	OverwriteMode() bool
	// PlaceholderText retrieves the text that will be displayed when @self is
	// empty and unfocused
	PlaceholderText() string
	// PropagateTextWidth returns whether the `GtkText` will grow and shrink
	// with the content.
	PropagateTextWidth() bool
	// Tabs gets the tabstops that were set on the `GtkText` using
	// gtk_text_set_tabs().
	Tabs() *pango.TabArray
	// TextLength retrieves the current length of the text in @self.
	//
	// This is equivalent to getting @self's `GtkEntryBuffer` and calling
	// [method@Gtk.EntryBuffer.get_length] on it.
	TextLength() uint16
	// TruncateMultiline returns whether the `GtkText` will truncate multi-line
	// text that is pasted into the widget
	TruncateMultiline() bool
	// Visibility retrieves whether the text in @self is visible.
	Visibility() bool
	// GrabFocusWithoutSelectingText causes @self to have keyboard focus.
	//
	// It behaves like [method@Gtk.Widget.grab_focus], except that it doesn't
	// select the contents of @self. You only want to call this on some special
	// entries which the user usually doesn't want to replace all text in, such
	// as search-as-you-type entries.
	GrabFocusWithoutSelectingText() bool
	// SetActivatesDefaultText: if @activates is true, pressing Enter in the
	// @self will activate the default widget for the window containing @self.
	//
	// This usually means that the dialog containing the `GtkText` will be
	// closed, since the default widget is usually one of the dialog buttons.
	SetActivatesDefaultText(activates bool)
	// SetAttributesText sets attributes that are applied to the text.
	SetAttributesText(attrs *pango.AttrList)
	// SetBufferText: set the `GtkEntryBuffer` object which holds the text for
	// this widget.
	SetBufferText(buffer EntryBuffer)
	// SetEnableEmojiCompletionText sets whether Emoji completion is enabled.
	//
	// If it is, typing ':', followed by a recognized keyword, will pop up a
	// window with suggested Emojis matching the keyword.
	SetEnableEmojiCompletionText(enableEmojiCompletion bool)
	// SetExtraMenuText sets a menu model to add when constructing the context
	// menu for @self.
	SetExtraMenuText(model gio.MenuModel)
	// SetInputHintsText sets input hints that allow input methods to fine-tune
	// their behaviour.
	SetInputHintsText(hints InputHints)
	// SetInputPurposeText sets the input purpose of the `GtkText`.
	//
	// This can be used by on-screen keyboards and other input methods to adjust
	// their behaviour.
	SetInputPurposeText(purpose InputPurpose)
	// SetInvisibleCharText sets the character to use in place of the actual
	// text when in password mode.
	//
	// By default, GTK picks the best invisible char available in the current
	// font. If you set the invisible char to 0, then the user will get no
	// feedback at all; there will be no text on the screen as they type.
	SetInvisibleCharText(ch uint32)
	// SetMaxLengthText sets the maximum allowed length of the contents of the
	// widget.
	//
	// If the current contents are longer than the given length, then they will
	// be truncated to fit.
	//
	// This is equivalent to getting @self's `GtkEntryBuffer` and calling
	// [method@Gtk.EntryBuffer.set_max_length] on it.
	SetMaxLengthText(length int)
	// SetOverwriteModeText sets whether the text is overwritten when typing in
	// the `GtkText`.
	SetOverwriteModeText(overwrite bool)
	// SetPlaceholderTextText sets text to be displayed in @self when it is
	// empty.
	//
	// This can be used to give a visual hint of the expected contents of the
	// `GtkText`.
	SetPlaceholderTextText(text string)
	// SetPropagateTextWidthText sets whether the `GtkText` should grow and
	// shrink with the content.
	SetPropagateTextWidthText(propagateTextWidth bool)
	// SetTabsText sets tabstops that are applied to the text.
	SetTabsText(tabs *pango.TabArray)
	// SetTruncateMultilineText sets whether the `GtkText` should truncate
	// multi-line text that is pasted into the widget.
	SetTruncateMultilineText(truncateMultiline bool)
	// SetVisibilityText sets whether the contents of the `GtkText` are visible
	// or not.
	//
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the widget
	// is copied to the clipboard.
	//
	// By default, GTK picks the best invisible character available in the
	// current font, but it can be changed with
	// [method@Gtk.Text.set_invisible_char].
	//
	// Note that you probably want to set [property@Gtk.Text:input-purpose] to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this self, in addition to setting visibility
	// to false.
	SetVisibilityText(visible bool)
	// UnsetInvisibleCharText unsets the invisible char.
	//
	// After calling this, the default invisible char is used again.
	UnsetInvisibleCharText()
}

// text implements the Text class.
type text struct {
	Widget
}

// WrapText wraps a GObject to the right type. It is
// primarily used internally.
func WrapText(obj *externglib.Object) Text {
	return text{
		Widget: WrapWidget(obj),
	}
}

func marshalText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapText(obj), nil
}

// NewText creates a new `GtkText`.
func NewText() Text {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_new()

	var _text Text // out

	_text = WrapText(externglib.Take(unsafe.Pointer(_cret)))

	return _text
}

// NewTextWithBuffer creates a new `GtkText` with the specified text buffer.
func NewTextWithBuffer(buffer EntryBuffer) Text {
	var _arg1 *C.GtkEntryBuffer // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_new_with_buffer(_arg1)

	var _text Text // out

	_text = WrapText(externglib.Take(unsafe.Pointer(_cret)))

	return _text
}

func (s text) ActivatesDefault() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_activates_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s text) Attributes() *pango.AttrList {
	var _arg0 *C.GtkText       // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_attributes(_arg0)

	var _attrList *pango.AttrList // out

	_attrList = pango.WrapAttrList(unsafe.Pointer(_cret))

	return _attrList
}

func (s text) Buffer() EntryBuffer {
	var _arg0 *C.GtkText        // out
	var _cret *C.GtkEntryBuffer // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_buffer(_arg0)

	var _entryBuffer EntryBuffer // out

	_entryBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryBuffer)

	return _entryBuffer
}

func (s text) EnableEmojiCompletion() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_enable_emoji_completion(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s text) ExtraMenu() gio.MenuModel {
	var _arg0 *C.GtkText    // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_extra_menu(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (s text) InputHints() InputHints {
	var _arg0 *C.GtkText      // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_input_hints(_arg0)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

func (s text) InputPurpose() InputPurpose {
	var _arg0 *C.GtkText        // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_input_purpose(_arg0)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

func (s text) InvisibleChar() uint32 {
	var _arg0 *C.GtkText // out
	var _cret C.gunichar // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_invisible_char(_arg0)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

func (s text) MaxLength() int {
	var _arg0 *C.GtkText // out
	var _cret C.int      // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_max_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s text) OverwriteMode() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_overwrite_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s text) PlaceholderText() string {
	var _arg0 *C.GtkText // out
	var _cret *C.char    // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_placeholder_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s text) PropagateTextWidth() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_propagate_text_width(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s text) Tabs() *pango.TabArray {
	var _arg0 *C.GtkText       // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_tabs(_arg0)

	var _tabArray *pango.TabArray // out

	_tabArray = pango.WrapTabArray(unsafe.Pointer(_cret))

	return _tabArray
}

func (s text) TextLength() uint16 {
	var _arg0 *C.GtkText // out
	var _cret C.guint16  // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_text_length(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

func (s text) TruncateMultiline() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_truncate_multiline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s text) Visibility() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_get_visibility(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s text) GrabFocusWithoutSelectingText() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_grab_focus_without_selecting(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s text) SetActivatesDefaultText(activates bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if activates {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_activates_default(_arg0, _arg1)
}

func (s text) SetAttributesText(attrs *pango.AttrList) {
	var _arg0 *C.GtkText       // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_text_set_attributes(_arg0, _arg1)
}

func (s text) SetBufferText(buffer EntryBuffer) {
	var _arg0 *C.GtkText        // out
	var _arg1 *C.GtkEntryBuffer // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_set_buffer(_arg0, _arg1)
}

func (s text) SetEnableEmojiCompletionText(enableEmojiCompletion bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if enableEmojiCompletion {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_enable_emoji_completion(_arg0, _arg1)
}

func (s text) SetExtraMenuText(model gio.MenuModel) {
	var _arg0 *C.GtkText    // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_text_set_extra_menu(_arg0, _arg1)
}

func (s text) SetInputHintsText(hints InputHints) {
	var _arg0 *C.GtkText      // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkInputHints)(hints)

	C.gtk_text_set_input_hints(_arg0, _arg1)
}

func (s text) SetInputPurposeText(purpose InputPurpose) {
	var _arg0 *C.GtkText        // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_text_set_input_purpose(_arg0, _arg1)
}

func (s text) SetInvisibleCharText(ch uint32) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gunichar // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gunichar)(ch)

	C.gtk_text_set_invisible_char(_arg0, _arg1)
}

func (s text) SetMaxLengthText(length int) {
	var _arg0 *C.GtkText // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(length)

	C.gtk_text_set_max_length(_arg0, _arg1)
}

func (s text) SetOverwriteModeText(overwrite bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_overwrite_mode(_arg0, _arg1)
}

func (s text) SetPlaceholderTextText(text string) {
	var _arg0 *C.GtkText // out
	var _arg1 *C.char    // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_set_placeholder_text(_arg0, _arg1)
}

func (s text) SetPropagateTextWidthText(propagateTextWidth bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if propagateTextWidth {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_propagate_text_width(_arg0, _arg1)
}

func (s text) SetTabsText(tabs *pango.TabArray) {
	var _arg0 *C.GtkText       // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.gtk_text_set_tabs(_arg0, _arg1)
}

func (s text) SetTruncateMultilineText(truncateMultiline bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if truncateMultiline {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_truncate_multiline(_arg0, _arg1)
}

func (s text) SetVisibilityText(visible bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_visibility(_arg0, _arg1)
}

func (s text) UnsetInvisibleCharText() {
	var _arg0 *C.GtkText // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	C.gtk_text_unset_invisible_char(_arg0)
}

func (s text) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s text) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s text) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s text) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s text) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s text) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s text) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b text) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (e text) DeleteSelection() {
	WrapEditable(gextras.InternObject(e)).DeleteSelection()
}

func (e text) DeleteText(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).DeleteText(startPos, endPos)
}

func (e text) FinishDelegate() {
	WrapEditable(gextras.InternObject(e)).FinishDelegate()
}

func (e text) Alignment() float32 {
	return WrapEditable(gextras.InternObject(e)).Alignment()
}

func (e text) Chars(startPos int, endPos int) string {
	return WrapEditable(gextras.InternObject(e)).Chars(startPos, endPos)
}

func (e text) Delegate() Editable {
	return WrapEditable(gextras.InternObject(e)).Delegate()
}

func (e text) Editable() bool {
	return WrapEditable(gextras.InternObject(e)).Editable()
}

func (e text) EnableUndo() bool {
	return WrapEditable(gextras.InternObject(e)).EnableUndo()
}

func (e text) MaxWidthChars() int {
	return WrapEditable(gextras.InternObject(e)).MaxWidthChars()
}

func (e text) Position() int {
	return WrapEditable(gextras.InternObject(e)).Position()
}

func (e text) SelectionBounds() (startPos int, endPos int, ok bool) {
	return WrapEditable(gextras.InternObject(e)).SelectionBounds()
}

func (e text) Text() string {
	return WrapEditable(gextras.InternObject(e)).Text()
}

func (e text) WidthChars() int {
	return WrapEditable(gextras.InternObject(e)).WidthChars()
}

func (e text) InitDelegate() {
	WrapEditable(gextras.InternObject(e)).InitDelegate()
}

func (e text) SelectRegion(startPos int, endPos int) {
	WrapEditable(gextras.InternObject(e)).SelectRegion(startPos, endPos)
}

func (e text) SetAlignment(xalign float32) {
	WrapEditable(gextras.InternObject(e)).SetAlignment(xalign)
}

func (e text) SetEditable(isEditable bool) {
	WrapEditable(gextras.InternObject(e)).SetEditable(isEditable)
}

func (e text) SetEnableUndo(enableUndo bool) {
	WrapEditable(gextras.InternObject(e)).SetEnableUndo(enableUndo)
}

func (e text) SetMaxWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetMaxWidthChars(nChars)
}

func (e text) SetPosition(position int) {
	WrapEditable(gextras.InternObject(e)).SetPosition(position)
}

func (e text) SetText(text string) {
	WrapEditable(gextras.InternObject(e)).SetText(text)
}

func (e text) SetWidthChars(nChars int) {
	WrapEditable(gextras.InternObject(e)).SetWidthChars(nChars)
}

// TextBuffer stores text and attributes for display in a `GtkTextView`.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextBuffer interface {

	// AddMarkTextBuffer adds the mark at position @where.
	//
	// The mark must not be added to another buffer, and if its name is not nil
	// then there must not be another mark in the buffer with the same name.
	//
	// Emits the `GtkTextBuffer`::mark-set signal as notification of the mark's
	// initial placement.
	AddMarkTextBuffer(mark TextMark, where *TextIter)
	// AddSelectionClipboardTextBuffer adds @clipboard to the list of clipboards
	// in which the selection contents of @buffer are available.
	//
	// In most cases, @clipboard will be the `GdkClipboard` returned by
	// [method@Gtk.Widget.get_primary_clipboard] for a view of @buffer.
	AddSelectionClipboardTextBuffer(clipboard gdk.Clipboard)
	// ApplyTagTextBuffer emits the apply-tag signal on @buffer.
	//
	// The default handler for the signal applies @tag to the given range.
	// @start and @end do not have to be in order.
	ApplyTagTextBuffer(tag TextTag, start *TextIter, end *TextIter)
	// ApplyTagByNameTextBuffer emits the apply-tag signal on @buffer.
	//
	// Calls [method@Gtk.TextTagTable.lookup] on the buffers tag table to get a
	// `GtkTextTag`, then calls [method@Gtk.TextBuffer.apply_tag].
	ApplyTagByNameTextBuffer(name string, start *TextIter, end *TextIter)
	// BackspaceTextBuffer performs the appropriate action as if the user hit
	// the delete key with the cursor at the position specified by @iter.
	//
	// In the normal case a single character will be deleted, but when combining
	// accents are involved, more than one character can be deleted, and when
	// precomposed character and accent combinations are involved, less than one
	// character will be deleted.
	//
	// Because the buffer is modified, all outstanding iterators become invalid
	// after calling this function; however, the @iter will be re-initialized to
	// point to the location where text was deleted.
	BackspaceTextBuffer(iter *TextIter, interactive bool, defaultEditable bool) bool
	// BeginIrreversibleActionTextBuffer denotes the beginning of an action that
	// may not be undone.
	//
	// This will cause any previous operations in the undo/redo queue to be
	// cleared.
	//
	// This should be paired with a call to
	// [method@Gtk.TextBuffer.end_irreversible_action] after the irreversible
	// action has completed.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	BeginIrreversibleActionTextBuffer()
	// BeginUserActionTextBuffer: called to indicate that the buffer operations
	// between here and a call to gtk_text_buffer_end_user_action() are part of
	// a single user-visible operation.
	//
	// The operations between gtk_text_buffer_begin_user_action() and
	// gtk_text_buffer_end_user_action() can then be grouped when creating an
	// undo stack. `GtkTextBuffer` maintains a count of calls to
	// gtk_text_buffer_begin_user_action() that have not been closed with a call
	// to gtk_text_buffer_end_user_action(), and emits the begin-user-action
	// and end-user-action signals only for the outermost pair of calls. This
	// allows you to build user actions from other user actions.
	//
	// The interactive buffer mutation functions, such as
	// [method@Gtk.TextBuffer.insert_interactive], automatically call begin/end
	// user action around the buffer operations they perform, so there's no need
	// to add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserActionTextBuffer()
	// CopyClipboardTextBuffer copies the currently-selected text to a
	// clipboard.
	CopyClipboardTextBuffer(clipboard gdk.Clipboard)
	// CreateChildAnchorTextBuffer creates and inserts a child anchor.
	//
	// This is a convenience function which simply creates a child anchor with
	// [ctor@Gtk.TextChildAnchor.new] and inserts it into the buffer with
	// [method@Gtk.TextBuffer.insert_child_anchor].
	//
	// The new anchor is owned by the buffer; no reference count is returned to
	// the caller of this function.
	CreateChildAnchorTextBuffer(iter *TextIter) TextChildAnchor
	// CreateMarkTextBuffer creates a mark at position @where.
	//
	// If @mark_name is nil, the mark is anonymous; otherwise, the mark can be
	// retrieved by name using [method@Gtk.TextBuffer.get_mark]. If a mark has
	// left gravity, and text is inserted at the marks current location, the
	// mark will be moved to the left of the newly-inserted text. If the mark
	// has right gravity (@left_gravity = false), the mark will end up on the
	// right of newly-inserted text. The standard left-to-right cursor is a mark
	// with right gravity (when you type, the cursor stays on the right side of
	// the text youre typing).
	//
	// The caller of this function does not own a reference to the returned
	// TextMark, so you can ignore the return value if you like. Marks are owned
	// by the buffer and go away when the buffer does.
	//
	// Emits the `GtkTextBuffer`::mark-set signal as notification of the mark's
	// initial placement.
	CreateMarkTextBuffer(markName string, where *TextIter, leftGravity bool) TextMark
	// CutClipboardTextBuffer copies the currently-selected text to a clipboard,
	// then deletes said text if its editable.
	CutClipboardTextBuffer(clipboard gdk.Clipboard, defaultEditable bool)
	// DeleteTextBuffer deletes text between @start and @end.
	//
	// The order of @start and @end is not actually relevant;
	// gtk_text_buffer_delete() will reorder them.
	//
	// This function actually emits the delete-range signal, and the default
	// handler of that signal deletes the text. Because the buffer is modified,
	// all outstanding iterators become invalid after calling this function;
	// however, the @start and @end will be re-initialized to point to the
	// location where text was deleted.
	DeleteTextBuffer(start *TextIter, end *TextIter)
	// DeleteInteractiveTextBuffer deletes all editable text in the given range.
	//
	// Calls [method@Gtk.TextBuffer.delete] for each editable sub-range of
	// [@start,@end). @start and @end are revalidated to point to the location
	// of the last deleted range, or left untouched if no text was deleted.
	DeleteInteractiveTextBuffer(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool
	// DeleteMarkTextBuffer deletes @mark, so that its no longer located
	// anywhere in the buffer.
	//
	// Removes the reference the buffer holds to the mark, so if you havent
	// called g_object_ref() on the mark, it will be freed. Even if the mark
	// isnt freed, most operations on @mark become invalid, until it gets added
	// to a buffer again with [method@Gtk.TextBuffer.add_mark]. Use
	// [method@Gtk.TextMark.get_deleted] to find out if a mark has been removed
	// from its buffer.
	//
	// The [signal@Gtk.TextBuffer::mark-deleted] signal will be emitted as
	// notification after the mark is deleted.
	DeleteMarkTextBuffer(mark TextMark)
	// DeleteMarkByNameTextBuffer deletes the mark named @name; the mark must
	// exist.
	//
	// See [method@Gtk.TextBuffer.delete_mark] for details.
	DeleteMarkByNameTextBuffer(name string)
	// DeleteSelectionTextBuffer deletes the range between the insert and
	// selection_bound marks, that is, the currently-selected text.
	//
	// If @interactive is true, the editability of the selection will be
	// considered (users cant delete uneditable text).
	DeleteSelectionTextBuffer(interactive bool, defaultEditable bool) bool
	// EndIrreversibleActionTextBuffer denotes the end of an action that may not
	// be undone.
	//
	// This will cause any previous operations in the undo/redo queue to be
	// cleared.
	//
	// This should be called after completing modifications to the text buffer
	// after gtk_text_buffer_begin_irreversible_action() was called.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	EndIrreversibleActionTextBuffer()
	// EndUserActionTextBuffer ends a user-visible operation.
	//
	// Should be paired with a call to
	// [method@Gtk.TextBuffer.begin_user_action]. See that function for a full
	// explanation.
	EndUserActionTextBuffer()
	// Bounds retrieves the first and last iterators in the buffer, i.e. the
	// entire buffer lies within the range [@start,@end).
	Bounds() (start TextIter, end TextIter)
	// CanRedo gets whether there is a redoable action in the history.
	CanRedo() bool
	// CanUndo gets whether there is an undoable action in the history.
	CanUndo() bool
	// CharCount gets the number of characters in the buffer.
	//
	// Note that characters and bytes are not the same, you cant e.g. expect
	// the contents of the buffer in string form to be this many bytes long.
	//
	// The character count is cached, so this function is very fast.
	CharCount() int
	// EnableUndo gets whether the buffer is saving modifications to the buffer
	// to allow for undo and redo actions.
	//
	// See [method@Gtk.TextBuffer.begin_irreversible_action] and
	// [method@Gtk.TextBuffer.end_irreversible_action] to create changes to the
	// buffer that cannot be undone.
	EnableUndo() bool
	// EndIter initializes @iter with the end iterator, one past the last
	// valid character in the text buffer.
	//
	// If dereferenced with [method@Gtk.TextIter.get_char], the end iterator has
	// a character value of 0. The entire buffer lies in the range from the
	// first position in the buffer (call [method@Gtk.TextBuffer.get_start_iter]
	// to get character position 0) to the end iterator.
	EndIter() TextIter
	// HasSelection indicates whether the buffer has some text currently
	// selected.
	HasSelection() bool
	// GetInsert returns the mark that represents the cursor (insertion point).
	//
	// Equivalent to calling [method@Gtk.TextBuffer.get_mark] to get the mark
	// named insert, but very slightly more efficient, and involves less
	// typing.
	GetInsert() TextMark
	// IterAtChildAnchor obtains the location of @anchor within @buffer.
	IterAtChildAnchor(anchor TextChildAnchor) TextIter
	// IterAtLine initializes @iter to the start of the given line.
	//
	// If @line_number is greater than or equal to the number of lines in the
	// @buffer, the end iterator is returned.
	IterAtLine(lineNumber int) (TextIter, bool)
	// IterAtLineIndex obtains an iterator pointing to @byte_index within the
	// given line.
	//
	// @byte_index must be the start of a UTF-8 character. Note bytes, not
	// characters; UTF-8 may encode one character as multiple bytes.
	//
	// If @line_number is greater than or equal to the number of lines in the
	// @buffer, the end iterator is returned. And if @byte_index is off the end
	// of the line, the iterator at the end of the line is returned.
	IterAtLineIndex(lineNumber int, byteIndex int) (TextIter, bool)
	// IterAtLineOffset obtains an iterator pointing to @char_offset within the
	// given line.
	//
	// Note characters, not bytes; UTF-8 may encode one character as multiple
	// bytes.
	//
	// If @line_number is greater than or equal to the number of lines in the
	// @buffer, the end iterator is returned. And if @char_offset is off the end
	// of the line, the iterator at the end of the line is returned.
	IterAtLineOffset(lineNumber int, charOffset int) (TextIter, bool)
	// IterAtMark initializes @iter with the current position of @mark.
	IterAtMark(mark TextMark) TextIter
	// IterAtOffset initializes @iter to a position @char_offset chars from the
	// start of the entire buffer.
	//
	// If @char_offset is -1 or greater than the number of characters in the
	// buffer, @iter is initialized to the end iterator, the iterator one past
	// the last valid character in the buffer.
	IterAtOffset(charOffset int) TextIter
	// LineCount obtains the number of lines in the buffer.
	//
	// This value is cached, so the function is very fast.
	LineCount() int
	// Mark returns the mark named @name in buffer @buffer, or nil if no such
	// mark exists in the buffer.
	Mark(name string) TextMark
	// MaxUndoLevels gets the maximum number of undo levels to perform.
	//
	// If 0, unlimited undo actions may be performed. Note that this may have a
	// memory usage impact as it requires storing an additional copy of the
	// inserted or removed text within the text buffer.
	MaxUndoLevels() uint
	// Modified indicates whether the buffer has been modified since the last
	// call to [method@Gtk.TextBuffer.set_modified] set the modification flag to
	// false.
	//
	// Used for example to enable a save function in a text editor.
	Modified() bool
	// SelectionBound returns the mark that represents the selection bound.
	//
	// Equivalent to calling [method@Gtk.TextBuffer.get_mark] to get the mark
	// named selection_bound, but very slightly more efficient, and involves
	// less typing.
	//
	// The currently-selected text in @buffer is the region between the
	// selection_bound and insert marks. If selection_bound and insert
	// are in the same place, then there is no current selection.
	// [method@Gtk.TextBuffer.get_selection_bounds] is another convenient
	// function for handling the selection, if you just want to know whether
	// theres a selection and what its bounds are.
	SelectionBound() TextMark
	// SelectionBounds returns true if some text is selected; places the bounds
	// of the selection in @start and @end.
	//
	// If the selection has length 0, then @start and @end are filled in with
	// the same value. @start and @end will be in ascending order. If @start and
	// @end are nil, then they are not filled in, but the return value still
	// indicates whether text is selected.
	SelectionBounds() (start TextIter, end TextIter, ok bool)
	// SelectionContent: get a content provider for this buffer.
	//
	// It can be used to make the content of @buffer available in a
	// `GdkClipboard`, see [method@Gdk.Clipboard.set_content].
	SelectionContent() gdk.ContentProvider
	// Slice returns the text in the range [@start,@end).
	//
	// Excludes undisplayed text (text marked with tags that set the
	// invisibility attribute) if @include_hidden_chars is false. The returned
	// string includes a 0xFFFC character whenever the buffer contains embedded
	// images, so byte and character indexes into the returned string do
	// correspond to byte and character indexes into the buffer. Contrast with
	// [method@Gtk.TextBuffer.get_text]. Note that 0xFFFC can occur in normal
	// text as well, so it is not a reliable indicator that a paintable or
	// widget is in the buffer.
	Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// StartIter: initialized @iter with the first position in the text buffer.
	//
	// This is the same as using [method@Gtk.TextBuffer.get_iter_at_offset] to
	// get the iter at character offset 0.
	StartIter() TextIter
	// TagTable: get the `GtkTextTagTable` associated with this buffer.
	TagTable() TextTagTable
	// Text returns the text in the range [@start,@end).
	//
	// Excludes undisplayed text (text marked with tags that set the
	// invisibility attribute) if @include_hidden_chars is false. Does not
	// include characters representing embedded images, so byte and character
	// indexes into the returned string do not correspond to byte and character
	// indexes into the buffer. Contrast with [method@Gtk.TextBuffer.get_slice].
	Text(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// InsertTextBuffer inserts @len bytes of @text at position @iter.
	//
	// If @len is -1, @text must be nul-terminated and will be inserted in its
	// entirety. Emits the insert-text signal; insertion actually occurs in
	// the default handler for the signal. @iter is invalidated when insertion
	// occurs (because the buffer contents change), but the default signal
	// handler revalidates it to point to the end of the inserted text.
	InsertTextBuffer(iter *TextIter, text string, len int)
	// InsertAtCursorTextBuffer inserts @text in @buffer.
	//
	// Simply calls [method@Gtk.TextBuffer.insert], using the current cursor
	// position as the insertion point.
	InsertAtCursorTextBuffer(text string, len int)
	// InsertChildAnchorTextBuffer inserts a child widget anchor into the text
	// buffer at @iter.
	//
	// The anchor will be counted as one character in character counts, and when
	// obtaining the buffer contents as a string, will be represented by the
	// Unicode object replacement character 0xFFFC. Note that the slice
	// variants for obtaining portions of the buffer as a string include this
	// character for child anchors, but the text variants do not. E.g. see
	// [method@Gtk.TextBuffer.get_slice] and [method@Gtk.TextBuffer.get_text].
	//
	// Consider [method@Gtk.TextBuffer.create_child_anchor] as a more convenient
	// alternative to this function. The buffer will add a reference to the
	// anchor, so you can unref it after insertion.
	InsertChildAnchorTextBuffer(iter *TextIter, anchor TextChildAnchor)
	// InsertInteractiveTextBuffer inserts @text in @buffer.
	//
	// Like [method@Gtk.TextBuffer.insert], but the insertion will not occur if
	// @iter is at a non-editable location in the buffer. Usually you want to
	// prevent insertions at ineditable locations if the insertion results from
	// a user action (is interactive).
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// [method@Gtk.TextView.get_editable] is appropriate here.
	InsertInteractiveTextBuffer(iter *TextIter, text string, len int, defaultEditable bool) bool
	// InsertInteractiveAtCursorTextBuffer inserts @text in @buffer.
	//
	// Calls [method@Gtk.TextBuffer.insert_interactive] at the cursor position.
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// [method@Gtk.TextView.get_editable] is appropriate here.
	InsertInteractiveAtCursorTextBuffer(text string, len int, defaultEditable bool) bool
	// InsertMarkupTextBuffer inserts the text in @markup at position @iter.
	//
	// @markup will be inserted in its entirety and must be nul-terminated and
	// valid UTF-8. Emits the [signal@Gtk.TextBuffer::insert-text] signal,
	// possibly multiple times; insertion actually occurs in the default handler
	// for the signal. @iter will point to the end of the inserted text on
	// return.
	InsertMarkupTextBuffer(iter *TextIter, markup string, len int)
	// InsertPaintableTextBuffer inserts an image into the text buffer at @iter.
	//
	// The image will be counted as one character in character counts, and when
	// obtaining the buffer contents as a string, will be represented by the
	// Unicode object replacement character 0xFFFC. Note that the slice
	// variants for obtaining portions of the buffer as a string include this
	// character for paintable, but the text variants do not. e.g. see
	// [method@Gtk.TextBuffer.get_slice] and [method@Gtk.TextBuffer.get_text].
	InsertPaintableTextBuffer(iter *TextIter, paintable gdk.Paintable)
	// InsertRangeTextBuffer copies text, tags, and paintables between @start
	// and @end and inserts the copy at @iter.
	//
	// The order of @start and @end doesnt matter.
	//
	// Used instead of simply getting/inserting text because it preserves images
	// and tags. If @start and @end are in a different buffer from @buffer, the
	// two buffers must share the same tag table.
	//
	// Implemented via emissions of the insert_text and apply_tag signals, so
	// expect those.
	InsertRangeTextBuffer(iter *TextIter, start *TextIter, end *TextIter)
	// InsertRangeInteractiveTextBuffer copies text, tags, and paintables
	// between @start and @end and inserts the copy at @iter.
	//
	// Same as [method@Gtk.TextBuffer.insert_range], but does nothing if the
	// insertion point isnt editable. The @default_editable parameter indicates
	// whether the text is editable at @iter if no tags enclosing @iter affect
	// editability. Typically the result of [method@Gtk.TextView.get_editable]
	// is appropriate here.
	InsertRangeInteractiveTextBuffer(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool
	// MoveMarkTextBuffer moves @mark to the new location @where.
	//
	// Emits the `GtkTextBuffer`::mark-set signal as notification of the move.
	MoveMarkTextBuffer(mark TextMark, where *TextIter)
	// MoveMarkByNameTextBuffer moves the mark named @name (which must exist) to
	// location @where.
	//
	// See [method@Gtk.TextBuffer.move_mark] for details.
	MoveMarkByNameTextBuffer(name string, where *TextIter)
	// PasteClipboardTextBuffer pastes the contents of a clipboard.
	//
	// If @override_location is nil, the pasted text will be inserted at the
	// cursor position, or the buffer selection will be replaced if the
	// selection is non-empty.
	//
	// Note: pasting is asynchronous, that is, well ask for the paste data and
	// return, and at some point later after the main loop runs, the paste data
	// will be inserted.
	PasteClipboardTextBuffer(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool)
	// PlaceCursorTextBuffer: this function moves the insert and
	// selection_bound marks simultaneously.
	//
	// If you move them to the same place in two steps with
	// [method@Gtk.TextBuffer.move_mark], you will temporarily select a region
	// in between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	PlaceCursorTextBuffer(where *TextIter)
	// RedoTextBuffer redoes the next redoable action on the buffer, if there is
	// one.
	RedoTextBuffer()
	// RemoveAllTagsTextBuffer removes all tags in the range between @start and
	// @end.
	//
	// Be careful with this function; it could remove tags added in code
	// unrelated to the code youre currently writing. That is, using this
	// function is probably a bad idea if you have two or more unrelated code
	// sections that add tags.
	RemoveAllTagsTextBuffer(start *TextIter, end *TextIter)
	// RemoveSelectionClipboardTextBuffer removes a `GdkClipboard` added with
	// gtk_text_buffer_add_selection_clipboard().
	RemoveSelectionClipboardTextBuffer(clipboard gdk.Clipboard)
	// RemoveTagTextBuffer emits the remove-tag signal.
	//
	// The default handler for the signal removes all occurrences of @tag from
	// the given range. @start and @end dont have to be in order.
	RemoveTagTextBuffer(tag TextTag, start *TextIter, end *TextIter)
	// RemoveTagByNameTextBuffer emits the remove-tag signal.
	//
	// Calls [method@Gtk.TextTagTable.lookup] on the buffers tag table to get a
	// `GtkTextTag`, then calls [method@Gtk.TextBuffer.remove_tag].
	RemoveTagByNameTextBuffer(name string, start *TextIter, end *TextIter)
	// SelectRangeTextBuffer: this function moves the insert and
	// selection_bound marks simultaneously.
	//
	// If you move them in two steps with [method@Gtk.TextBuffer.move_mark], you
	// will temporarily select a region in between their old and new locations,
	// which can be pretty inefficient since the temporarily-selected region
	// will force stuff to be recalculated. This function moves them as a unit,
	// which can be optimized.
	SelectRangeTextBuffer(ins *TextIter, bound *TextIter)
	// SetEnableUndoTextBuffer sets whether or not to enable undoable actions in
	// the text buffer.
	//
	// If enabled, the user will be able to undo the last number of actions up
	// to [method@Gtk.TextBuffer.get_max_undo_levels].
	//
	// See [method@Gtk.TextBuffer.begin_irreversible_action] and
	// [method@Gtk.TextBuffer.end_irreversible_action] to create changes to the
	// buffer that cannot be undone.
	SetEnableUndoTextBuffer(enableUndo bool)
	// SetMaxUndoLevelsTextBuffer sets the maximum number of undo levels to
	// perform.
	//
	// If 0, unlimited undo actions may be performed. Note that this may have a
	// memory usage impact as it requires storing an additional copy of the
	// inserted or removed text within the text buffer.
	SetMaxUndoLevelsTextBuffer(maxUndoLevels uint)
	// SetModifiedTextBuffer: used to keep track of whether the buffer has been
	// modified since the last time it was saved.
	//
	// Whenever the buffer is saved to disk, call `gtk_text_buffer_set_modified
	// (@buffer, FALSE)`. When the buffer is modified, it will automatically
	// toggled on the modified bit again. When the modified bit flips, the
	// buffer emits the [signal@Gtk.TextBuffer::modified-changed] signal.
	SetModifiedTextBuffer(setting bool)
	// SetTextTextBuffer deletes current contents of @buffer, and inserts @text
	// instead.
	//
	// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	SetTextTextBuffer(text string, len int)
	// UndoTextBuffer undoes the last undoable action on the buffer, if there is
	// one.
	UndoTextBuffer()
}

// textBuffer implements the TextBuffer class.
type textBuffer struct {
	gextras.Objector
}

// WrapTextBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextBuffer(obj *externglib.Object) TextBuffer {
	return textBuffer{
		Objector: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextBuffer(obj), nil
}

// NewTextBuffer creates a new text buffer.
func NewTextBuffer(table TextTagTable) TextBuffer {
	var _arg1 *C.GtkTextTagTable // out
	var _cret *C.GtkTextBuffer   // in

	_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))

	_cret = C.gtk_text_buffer_new(_arg1)

	var _textBuffer TextBuffer // out

	_textBuffer = WrapTextBuffer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textBuffer
}

func (b textBuffer) AddMarkTextBuffer(mark TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
}

func (b textBuffer) AddSelectionClipboardTextBuffer(clipboard gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
}

func (b textBuffer) ApplyTagTextBuffer(tag TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) ApplyTagByNameTextBuffer(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) BackspaceTextBuffer(iter *TextIter, interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 C.gboolean       // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	if interactive {
		_arg2 = C.TRUE
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) BeginIrreversibleActionTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_irreversible_action(_arg0)
}

func (b textBuffer) BeginUserActionTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_user_action(_arg0)
}

func (b textBuffer) CopyClipboardTextBuffer(clipboard gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
}

func (b textBuffer) CreateChildAnchorTextBuffer(iter *TextIter) TextChildAnchor {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_buffer_create_child_anchor(_arg0, _arg1)

	var _textChildAnchor TextChildAnchor // out

	_textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextChildAnchor)

	return _textChildAnchor
}

func (b textBuffer) CreateMarkTextBuffer(markName string, where *TextIter, leftGravity bool) TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(markName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))
	if leftGravity {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_create_mark(_arg0, _arg1, _arg2, _arg3)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

func (b textBuffer) CutClipboardTextBuffer(clipboard gdk.Clipboard, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	if defaultEditable {
		_arg2 = C.TRUE
	}

	C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
}

func (b textBuffer) DeleteTextBuffer(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
}

func (b textBuffer) DeleteInteractiveTextBuffer(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(startIter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(endIter.Native()))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) DeleteMarkTextBuffer(mark TextMark) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_delete_mark(_arg0, _arg1)
}

func (b textBuffer) DeleteMarkByNameTextBuffer(name string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
}

func (b textBuffer) DeleteSelectionTextBuffer(interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out
	var _arg2 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if interactive {
		_arg1 = C.TRUE
	}
	if defaultEditable {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) EndIrreversibleActionTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_irreversible_action(_arg0)
}

func (b textBuffer) EndUserActionTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_user_action(_arg0)
}

func (b textBuffer) Bounds() (start TextIter, end TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _start TextIter
	var _end TextIter

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_get_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))

	return _start, _end
}

func (b textBuffer) CanRedo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_can_redo(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) CanUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_can_undo(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) CharCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_char_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (b textBuffer) EnableUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_enable_undo(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) EndIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_get_end_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	return _iter
}

func (b textBuffer) HasSelection() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_has_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) GetInsert() TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_insert(_arg0)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

func (b textBuffer) IterAtChildAnchor(anchor TextChildAnchor) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

func (b textBuffer) IterAtLine(lineNumber int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 C.int      // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (C.int)(lineNumber)

	_cret = C.gtk_text_buffer_get_iter_at_line(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (b textBuffer) IterAtLineIndex(lineNumber int, byteIndex int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 C.int      // out
	var _arg3 C.int      // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (C.int)(lineNumber)
	_arg3 = (C.int)(byteIndex)

	_cret = C.gtk_text_buffer_get_iter_at_line_index(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (b textBuffer) IterAtLineOffset(lineNumber int, charOffset int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 C.int      // out
	var _arg3 C.int      // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (C.int)(lineNumber)
	_arg3 = (C.int)(charOffset)

	_cret = C.gtk_text_buffer_get_iter_at_line_offset(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (b textBuffer) IterAtMark(mark TextMark) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 *C.GtkTextMark // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_get_iter_at_mark(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

func (b textBuffer) IterAtOffset(charOffset int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 C.int // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (C.int)(charOffset)

	C.gtk_text_buffer_get_iter_at_offset(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

func (b textBuffer) LineCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_line_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (b textBuffer) Mark(name string) TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_buffer_get_mark(_arg0, _arg1)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

func (b textBuffer) MaxUndoLevels() uint {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_max_undo_levels(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (b textBuffer) Modified() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_modified(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) SelectionBound() TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_selection_bound(_arg0)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

func (b textBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _start TextIter
	var _end TextIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

func (b textBuffer) SelectionContent() gdk.ContentProvider {
	var _arg0 *C.GtkTextBuffer      // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_selection_content(_arg0)

	var _contentProvider gdk.ContentProvider // out

	_contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.ContentProvider)

	return _contentProvider
}

func (b textBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (b textBuffer) StartIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_get_start_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	return _iter
}

func (b textBuffer) TagTable() TextTagTable {
	var _arg0 *C.GtkTextBuffer   // out
	var _cret *C.GtkTextTagTable // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_tag_table(_arg0)

	var _textTagTable TextTagTable // out

	_textTagTable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextTagTable)

	return _textTagTable
}

func (b textBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (b textBuffer) InsertTextBuffer(iter *TextIter, text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.int)(len)

	C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) InsertAtCursorTextBuffer(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(len)

	C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
}

func (b textBuffer) InsertChildAnchorTextBuffer(iter *TextIter, anchor TextChildAnchor) {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
}

func (b textBuffer) InsertInteractiveTextBuffer(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.int)(len)
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) InsertInteractiveAtCursorTextBuffer(text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(len)
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) InsertMarkupTextBuffer(iter *TextIter, markup string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.int)(len)

	C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) InsertPaintableTextBuffer(iter *TextIter, paintable gdk.Paintable) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPaintable  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_text_buffer_insert_paintable(_arg0, _arg1, _arg2)
}

func (b textBuffer) InsertRangeTextBuffer(iter *TextIter, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) InsertRangeInteractiveTextBuffer(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) MoveMarkTextBuffer(mark TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
}

func (b textBuffer) MoveMarkByNameTextBuffer(name string, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
}

func (b textBuffer) PasteClipboardTextBuffer(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(overrideLocation.Native()))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) PlaceCursorTextBuffer(where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_place_cursor(_arg0, _arg1)
}

func (b textBuffer) RedoTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_redo(_arg0)
}

func (b textBuffer) RemoveAllTagsTextBuffer(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
}

func (b textBuffer) RemoveSelectionClipboardTextBuffer(clipboard gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
}

func (b textBuffer) RemoveTagTextBuffer(tag TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) RemoveTagByNameTextBuffer(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) SelectRangeTextBuffer(ins *TextIter, bound *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(ins.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(bound.Native()))

	C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
}

func (b textBuffer) SetEnableUndoTextBuffer(enableUndo bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if enableUndo {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_enable_undo(_arg0, _arg1)
}

func (b textBuffer) SetMaxUndoLevelsTextBuffer(maxUndoLevels uint) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(maxUndoLevels)

	C.gtk_text_buffer_set_max_undo_levels(_arg0, _arg1)
}

func (b textBuffer) SetModifiedTextBuffer(setting bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_modified(_arg0, _arg1)
}

func (b textBuffer) SetTextTextBuffer(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(len)

	C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
}

func (b textBuffer) UndoTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_undo(_arg0)
}

// TextChildAnchor: a `GtkTextChildAnchor` is a spot in a `GtkTextBuffer` where
// child widgets can be anchored.
//
// The anchor can have multiple widgets anchored, to allow for multiple views.
type TextChildAnchor interface {

	// Deleted determines whether a child anchor has been deleted from the
	// buffer.
	//
	// Keep in mind that the child anchor will be unreferenced when removed from
	// the buffer, so you need to hold your own reference (with g_object_ref())
	// if you plan to use this function  otherwise all deleted child anchors
	// will also be finalized.
	Deleted() bool
}

// textChildAnchor implements the TextChildAnchor class.
type textChildAnchor struct {
	gextras.Objector
}

// WrapTextChildAnchor wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextChildAnchor(obj *externglib.Object) TextChildAnchor {
	return textChildAnchor{
		Objector: obj,
	}
}

func marshalTextChildAnchor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextChildAnchor(obj), nil
}

// NewTextChildAnchor creates a new `GtkTextChildAnchor`.
//
// Usually you would then insert it into a `GtkTextBuffer` with
// [method@Gtk.TextBuffer.insert_child_anchor]. To perform the creation and
// insertion in one step, use the convenience function
// [method@Gtk.TextBuffer.create_child_anchor].
func NewTextChildAnchor() TextChildAnchor {
	var _cret *C.GtkTextChildAnchor // in

	_cret = C.gtk_text_child_anchor_new()

	var _textChildAnchor TextChildAnchor // out

	_textChildAnchor = WrapTextChildAnchor(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

func (a textChildAnchor) Deleted() bool {
	var _arg0 *C.GtkTextChildAnchor // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkTextChildAnchor)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_text_child_anchor_get_deleted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextMark: a `GtkTextMark` is a position in a `GtkTextbuffer` that is
// preserved across modifications.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// A `GtkTextMark` is like a bookmark in a text buffer; it preserves a position
// in the text. You can convert the mark to an iterator using
// [method@Gtk.TextBuffer.get_iter_at_mark]. Unlike iterators, marks remain
// valid across buffer mutations, because their behavior is defined when text is
// inserted or deleted. When text containing a mark is deleted, the mark remains
// in the position originally occupied by the deleted text. When text is
// inserted at a mark, a mark with left gravity will be moved to the beginning
// of the newly-inserted text, and a mark with right gravity will be moved to
// the end.
//
// Note that left and right here refer to logical direction (left is the
// toward the start of the buffer); in some languages such as Hebrew the
// logically-leftmost text is not actually on the left when displayed.
//
// Marks are reference counted, but the reference count only controls the
// validity of the memory; marks can be deleted from the buffer at any time with
// [method@Gtk.TextBuffer.delete_mark]. Once deleted from the buffer, a mark is
// essentially useless.
//
// Marks optionally have names; these can be convenient to avoid passing the
// `GtkTextMark` object around.
//
// Marks are typically created using the [method@Gtk.TextBuffer.create_mark]
// function.
type TextMark interface {

	// Buffer gets the buffer this mark is located inside.
	//
	// Returns nil if the mark is deleted.
	Buffer() TextBuffer
	// Deleted returns true if the mark has been removed from its buffer.
	//
	// See [method@Gtk.TextBuffer.add_mark] for a way to add it to a buffer
	// again.
	Deleted() bool
	// LeftGravity determines whether the mark has left gravity.
	LeftGravity() bool
	// Name returns the mark name.
	//
	// Returns nil for anonymous marks.
	Name() string
	// Visible returns true if the mark is visible.
	//
	// A cursor is displayed for visible marks.
	Visible() bool

	SetVisibleTextMark(setting bool)
}

// textMark implements the TextMark class.
type textMark struct {
	gextras.Objector
}

// WrapTextMark wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextMark(obj *externglib.Object) TextMark {
	return textMark{
		Objector: obj,
	}
}

func marshalTextMark(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextMark(obj), nil
}

// NewTextMark creates a text mark.
//
// Add it to a buffer using [method@Gtk.TextBuffer.add_mark]. If @name is nil,
// the mark is anonymous; otherwise, the mark can be retrieved by name using
// [method@Gtk.TextBuffer.get_mark]. If a mark has left gravity, and text is
// inserted at the marks current location, the mark will be moved to the left
// of the newly-inserted text. If the mark has right gravity (@left_gravity =
// false), the mark will end up on the right of newly-inserted text. The
// standard left-to-right cursor is a mark with right gravity (when you type,
// the cursor stays on the right side of the text youre typing).
func NewTextMark(name string, leftGravity bool) TextMark {
	var _arg1 *C.char        // out
	var _arg2 C.gboolean     // out
	var _cret *C.GtkTextMark // in

	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	if leftGravity {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_mark_new(_arg1, _arg2)

	var _textMark TextMark // out

	_textMark = WrapTextMark(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textMark
}

func (m textMark) Buffer() TextBuffer {
	var _arg0 *C.GtkTextMark   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_buffer(_arg0)

	var _textBuffer TextBuffer // out

	_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

	return _textBuffer
}

func (m textMark) Deleted() bool {
	var _arg0 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_deleted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m textMark) LeftGravity() bool {
	var _arg0 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_left_gravity(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m textMark) Name() string {
	var _arg0 *C.GtkTextMark // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m textMark) Visible() bool {
	var _arg0 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m textMark) SetVisibleTextMark(setting bool) {
	var _arg0 *C.GtkTextMark // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_mark_set_visible(_arg0, _arg1)
}

// TextTag: a tag that can be applied to text contained in a `GtkTextBuffer`.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// Tags should be in the [class@Gtk.TextTagTable] for a given `GtkTextBuffer`
// before using them with that buffer.
//
// [method@Gtk.TextBuffer.create_tag] is the best way to create tags. See
// gtk4-demo for numerous examples.
//
// For each property of `GtkTextTag`, there is a set property, e.g. font-set
// corresponds to font. These set properties reflect whether a property has
// been set or not.
//
// They are maintained by GTK and you should not set them independently.
type TextTag interface {

	// ChangedTextTag emits the [signal@Gtk.TextTagTable::tag-changed] signal on
	// the `GtkTextTagTable` where the tag is included.
	//
	// The signal is already emitted when setting a `GtkTextTag` property. This
	// function is useful for a `GtkTextTag` subclass.
	ChangedTextTag(sizeChanged bool)
	// Priority: get the tag priority.
	Priority() int
	// SetPriorityTextTag sets the priority of a `GtkTextTag`.
	//
	// Valid priorities start at 0 and go to one less than
	// [method@Gtk.TextTagTable.get_size]. Each tag in a table has a unique
	// priority; setting the priority of one tag shifts the priorities of all
	// the other tags in the table to maintain a unique priority for each tag.
	//
	// Higher priority tags win if two tags both set the same text attribute.
	// When adding a tag to a tag table, it will be assigned the highest
	// priority in the table by default; so normally the precedence of a set of
	// tags is the order in which they were added to the table, or created with
	// [method@Gtk.TextBuffer.create_tag], which adds the tag to the buffers
	// table automatically.
	SetPriorityTextTag(priority int)
}

// textTag implements the TextTag class.
type textTag struct {
	gextras.Objector
}

// WrapTextTag wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTag(obj *externglib.Object) TextTag {
	return textTag{
		Objector: obj,
	}
}

func marshalTextTag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTag(obj), nil
}

// NewTextTag creates a `GtkTextTag`.
func NewTextTag(name string) TextTag {
	var _arg1 *C.char       // out
	var _cret *C.GtkTextTag // in

	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_tag_new(_arg1)

	var _textTag TextTag // out

	_textTag = WrapTextTag(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textTag
}

func (t textTag) ChangedTextTag(sizeChanged bool) {
	var _arg0 *C.GtkTextTag // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))
	if sizeChanged {
		_arg1 = C.TRUE
	}

	C.gtk_text_tag_changed(_arg0, _arg1)
}

func (t textTag) Priority() int {
	var _arg0 *C.GtkTextTag // out
	var _cret C.int         // in

	_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_tag_get_priority(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textTag) SetPriorityTextTag(priority int) {
	var _arg0 *C.GtkTextTag // out
	var _arg1 C.int         // out

	_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(priority)

	C.gtk_text_tag_set_priority(_arg0, _arg1)
}

// TextTagTable: the collection of tags in a `GtkTextBuffer`
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
//
// GtkTextTagTables as GtkBuildable
//
// The `GtkTextTagTable` implementation of the `GtkBuildable` interface supports
// adding tags by specifying tag as the type attribute of a <child> element.
//
// An example of a UI definition fragment specifying tags: `xml <object
// class="GtkTextTagTable"> <child type="tag"> <object class="GtkTextTag"/>
// </child> </object> `
type TextTagTable interface {
	Buildable

	// AddTextTagTable: add a tag to the table.
	//
	// The tag is assigned the highest priority in the table.
	//
	// @tag must not be in a tag table already, and may not have the same name
	// as an already-added tag.
	AddTextTagTable(tag TextTag) bool
	// Size returns the size of the table (number of tags)
	Size() int
	// LookupTextTagTable: look up a named tag.
	LookupTextTagTable(name string) TextTag
	// RemoveTextTagTable: remove a tag from the table.
	//
	// If a `GtkTextBuffer` has @table as its tag table, the tag is removed from
	// the buffer. The tables reference to the tag is removed, so the tag will
	// end up destroyed if you dont have a reference to it.
	RemoveTextTagTable(tag TextTag)
}

// textTagTable implements the TextTagTable class.
type textTagTable struct {
	gextras.Objector
}

// WrapTextTagTable wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTagTable(obj *externglib.Object) TextTagTable {
	return textTagTable{
		Objector: obj,
	}
}

func marshalTextTagTable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTagTable(obj), nil
}

// NewTextTagTable creates a new `GtkTextTagTable`.
//
// The table contains no tags by default.
func NewTextTagTable() TextTagTable {
	var _cret *C.GtkTextTagTable // in

	_cret = C.gtk_text_tag_table_new()

	var _textTagTable TextTagTable // out

	_textTagTable = WrapTextTagTable(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textTagTable
}

func (t textTagTable) AddTextTagTable(tag TextTag) bool {
	var _arg0 *C.GtkTextTagTable // out
	var _arg1 *C.GtkTextTag      // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_tag_table_add(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textTagTable) Size() int {
	var _arg0 *C.GtkTextTagTable // out
	var _cret C.int              // in

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_tag_table_get_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textTagTable) LookupTextTagTable(name string) TextTag {
	var _arg0 *C.GtkTextTagTable // out
	var _arg1 *C.char            // out
	var _cret *C.GtkTextTag      // in

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_tag_table_lookup(_arg0, _arg1)

	var _textTag TextTag // out

	_textTag = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextTag)

	return _textTag
}

func (t textTagTable) RemoveTextTagTable(tag TextTag) {
	var _arg0 *C.GtkTextTagTable // out
	var _arg1 *C.GtkTextTag      // out

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	C.gtk_text_tag_table_remove(_arg0, _arg1)
}

func (b textTagTable) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// TextView: a widget that displays the contents of a [class@Gtk.TextBuffer].
//
// !An example GtkTextview (multiline-text.png)
//
// You may wish to begin by reading the conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
//
// CSS nodes
//
// ` textview.view  border.top  border.left  text   [selection]
//  border.right  border.bottom  [window.popup] `
//
// `GtkTextView` has a main css node with name textview and style class .view,
// and subnodes for each of the border windows, and the main text area, with
// names border and text, respectively. The border nodes each get one of the
// style classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
//
//
// Accessibility
//
// `GtkTextView` uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type TextView interface {
	Widget
	Scrollable

	// AddChildAtAnchorTextView adds a child widget in the text buffer, at the
	// given @anchor.
	AddChildAtAnchorTextView(child Widget, anchor TextChildAnchor)
	// AddOverlayTextView adds @child at a fixed coordinate in the
	// `GtkTextView`'s text window.
	//
	// The @xpos and @ypos must be in buffer coordinates (see
	// [method@Gtk.TextView.get_iter_location] to convert to buffer
	// coordinates).
	//
	// @child will scroll with the text view.
	//
	// If instead you want a widget that will not move with the `GtkTextView`
	// contents see Overlay.
	AddOverlayTextView(child Widget, xpos int, ypos int)
	// BackwardDisplayLineTextView moves the given @iter backward by one display
	// (wrapped) line.
	//
	// A display line is different from a paragraph. Paragraphs are separated by
	// newlines or other paragraph separator characters. Display lines are
	// created by line-wrapping a paragraph. If wrapping is turned off, display
	// lines and paragraphs will be the same. Display lines are divided
	// differently for each view, since they depend on the views width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the `GtkTextBuffer`.
	BackwardDisplayLineTextView(iter *TextIter) bool
	// BackwardDisplayLineStartTextView moves the given @iter backward to the
	// next display line start.
	//
	// A display line is different from a paragraph. Paragraphs are separated by
	// newlines or other paragraph separator characters. Display lines are
	// created by line-wrapping a paragraph. If wrapping is turned off, display
	// lines and paragraphs will be the same. Display lines are divided
	// differently for each view, since they depend on the views width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the `GtkTextBuffer`.
	BackwardDisplayLineStartTextView(iter *TextIter) bool
	// BufferToWindowCoordsTextView converts buffer coordinates to window
	// coordinates.
	BufferToWindowCoordsTextView(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int)
	// ForwardDisplayLineTextView moves the given @iter forward by one display
	// (wrapped) line.
	//
	// A display line is different from a paragraph. Paragraphs are separated by
	// newlines or other paragraph separator characters. Display lines are
	// created by line-wrapping a paragraph. If wrapping is turned off, display
	// lines and paragraphs will be the same. Display lines are divided
	// differently for each view, since they depend on the views width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the `GtkTextBuffer`.
	ForwardDisplayLineTextView(iter *TextIter) bool
	// ForwardDisplayLineEndTextView moves the given @iter forward to the next
	// display line end.
	//
	// A display line is different from a paragraph. Paragraphs are separated by
	// newlines or other paragraph separator characters. Display lines are
	// created by line-wrapping a paragraph. If wrapping is turned off, display
	// lines and paragraphs will be the same. Display lines are divided
	// differently for each view, since they depend on the views width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the `GtkTextBuffer`.
	ForwardDisplayLineEndTextView(iter *TextIter) bool
	// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
	//
	// See [method@Gtk.TextView.set_accepts_tab].
	AcceptsTab() bool
	// BottomMargin gets the bottom margin for text in the @text_view.
	BottomMargin() int
	// Buffer returns the `GtkTextBuffer` being displayed by this text view.
	//
	// The reference count on the buffer is not incremented; the caller of this
	// function wont own a new reference.
	Buffer() TextBuffer
	// CursorLocations: determine the positions of the strong and weak cursors
	// if the insertion point is at @iter.
	//
	// The position of each cursor is stored as a zero-width rectangle. The
	// strong cursor location is the location where characters of the
	// directionality equal to the base direction of the paragraph are inserted.
	// The weak cursor location is the location where characters of the
	// directionality opposite to the base direction of the paragraph are
	// inserted.
	//
	// If @iter is nil, the actual cursor position is used.
	//
	// Note that if @iter happens to be the actual cursor position, and there is
	// currently an IM preedit sequence being entered, the returned locations
	// will be adjusted to account for the preedit cursors offset within the
	// preedit sequence.
	//
	// The rectangle position is in buffer coordinates; use
	// [method@Gtk.TextView.buffer_to_window_coords] to convert these
	// coordinates to coordinates for one of the windows in the text view.
	CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle)
	// CursorVisible: find out whether the cursor should be displayed.
	CursorVisible() bool
	// Editable returns the default editability of the `GtkTextView`.
	//
	// Tags in the buffer may override this setting for some ranges of text.
	Editable() bool
	// ExtraMenu gets the menu model that gets added to the context menu or nil
	// if none has been set.
	ExtraMenu() gio.MenuModel
	// Gutter gets a `GtkWidget` that has previously been set as gutter.
	//
	// See [method@Gtk.TextView.set_gutter].
	//
	// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
	// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	Gutter(win TextWindowType) Widget
	// Indent gets the default indentation of paragraphs in @text_view.
	//
	// Tags in the views buffer may override the default. The indentation may
	// be negative.
	Indent() int
	// InputHints gets the `input-hints` of the `GtkTextView`.
	InputHints() InputHints
	// InputPurpose gets the `input-purpose` of the `GtkTextView`.
	InputPurpose() InputPurpose
	// IterAtLocation retrieves the iterator at buffer coordinates @x and @y.
	//
	// Buffer coordinates are coordinates for the entire buffer, not just the
	// currently-displayed portion. If you have coordinates from an event, you
	// have to convert those to buffer coordinates with
	// [method@Gtk.TextView.window_to_buffer_coords].
	IterAtLocation(x int, y int) (TextIter, bool)
	// IterAtPosition retrieves the iterator pointing to the character at buffer
	// coordinates @x and @y.
	//
	// Buffer coordinates are coordinates for the entire buffer, not just the
	// currently-displayed portion. If you have coordinates from an event, you
	// have to convert those to buffer coordinates with
	// [method@Gtk.TextView.window_to_buffer_coords].
	//
	// Note that this is different from
	// [method@Gtk.TextView.get_iter_at_location], which returns cursor
	// locations, i.e. positions between characters.
	IterAtPosition(x int, y int) (TextIter, int, bool)
	// IterLocation gets a rectangle which roughly contains the character at
	// @iter.
	//
	// The rectangle position is in buffer coordinates; use
	// [method@Gtk.TextView.buffer_to_window_coords] to convert these
	// coordinates to coordinates for one of the windows in the text view.
	IterLocation(iter *TextIter) gdk.Rectangle
	// Justification gets the default justification of paragraphs in @text_view.
	//
	// Tags in the buffer may override the default.
	Justification() Justification
	// LeftMargin gets the default left margin size of paragraphs in the
	// @text_view.
	//
	// Tags in the buffer may override the default.
	LeftMargin() int
	// LineAtY gets the `GtkTextIter` at the start of the line containing the
	// coordinate @y.
	//
	// @y is in buffer coordinates, convert from window coordinates with
	// [method@Gtk.TextView.window_to_buffer_coords]. If non-nil, @line_top will
	// be filled with the coordinate of the top edge of the line.
	LineAtY(y int) (TextIter, int)
	// LineYrange gets the y coordinate of the top of the line containing @iter,
	// and the height of the line.
	//
	// The coordinate is a buffer coordinate; convert to window coordinates with
	// [method@Gtk.TextView.buffer_to_window_coords].
	LineYrange(iter *TextIter) (y int, height int)
	// Monospace gets whether the `GtkTextView` uses monospace styling.
	Monospace() bool
	// Overwrite returns whether the `GtkTextView` is in overwrite mode or not.
	Overwrite() bool
	// PixelsAboveLines gets the default number of pixels to put above
	// paragraphs.
	//
	// Adding this function with [method@Gtk.TextView.get_pixels_below_lines] is
	// equal to the line space between each paragraph.
	PixelsAboveLines() int
	// PixelsBelowLines gets the default number of pixels to put below
	// paragraphs.
	//
	// The line space is the sum of the value returned by this function and the
	// value returned by [method@Gtk.TextView.get_pixels_above_lines].
	PixelsBelowLines() int
	// PixelsInsideWrap gets the default number of pixels to put between wrapped
	// lines inside a paragraph.
	PixelsInsideWrap() int
	// RightMargin gets the default right margin for text in @text_view.
	//
	// Tags in the buffer may override the default.
	RightMargin() int
	// Tabs gets the default tabs for @text_view.
	//
	// Tags in the buffer may override the defaults. The returned array will be
	// nil if standard (8-space) tabs are used. Free the return value with
	// [method@Pango.TabArray.free].
	Tabs() *pango.TabArray
	// TopMargin gets the top margin for text in the @text_view.
	TopMargin() int
	// VisibleRect fills @visible_rect with the currently-visible region of the
	// buffer, in buffer coordinates.
	//
	// Convert to window coordinates with
	// [method@Gtk.TextView.buffer_to_window_coords].
	VisibleRect() gdk.Rectangle
	// WrapMode gets the line wrapping for the view.
	WrapMode() WrapMode
	// ImContextFilterKeypressTextView: allow the `GtkTextView` input method to
	// internally handle key press and release events.
	//
	// If this function returns true, then no further processing should be done
	// for this key event. See [method@Gtk.IMContext.filter_keypress].
	//
	// Note that you are expected to call this function from your handler when
	// overriding key event handling. This is needed in the case when you need
	// to insert your own key handling between the input method and the default
	// key event handling of the `GtkTextView`.
	//
	// `c static gboolean gtk_foo_bar_key_press_event (GtkWidget *widget,
	// GdkEvent *event) { guint keyval;
	//
	//    gdk_event_get_keyval ((GdkEvent*)event, &keyval);
	//
	//    if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
	//      {
	//        if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
	//          return TRUE;
	//      }
	//
	//    // Do some stuff
	//
	//    return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
	//
	// } `
	ImContextFilterKeypressTextView(event gdk.Event) bool
	// MoveMarkOnscreenTextView moves a mark within the buffer so that it's
	// located within the currently-visible text area.
	MoveMarkOnscreenTextView(mark TextMark) bool
	// MoveOverlayTextView updates the position of a child.
	//
	// See [method@Gtk.TextView.add_overlay].
	MoveOverlayTextView(child Widget, xpos int, ypos int)
	// MoveVisuallyTextView: move the iterator a given number of characters
	// visually, treating it as the strong cursor position.
	//
	// If @count is positive, then the new strong cursor position will be @count
	// positions to the right of the old cursor position. If @count is negative
	// then the new strong cursor position will be @count positions to the left
	// of the old cursor position.
	//
	// In the presence of bi-directional text, the correspondence between
	// logical and visual order will depend on the direction of the current run,
	// and there may be jumps when the cursor is moved off of the end of a run.
	MoveVisuallyTextView(iter *TextIter, count int) bool
	// PlaceCursorOnscreenTextView moves the cursor to the currently visible
	// region of the buffer.
	PlaceCursorOnscreenTextView() bool
	// RemoveTextView removes a child widget from @text_view.
	RemoveTextView(child Widget)
	// ResetCursorBlinkTextView ensures that the cursor is shown.
	//
	// This also resets the time that it will stay blinking (or visible, in case
	// blinking is disabled).
	//
	// This function should be called in response to user input (e.g. from
	// derived classes that override the textview's event handlers).
	ResetCursorBlinkTextView()
	// ResetImContextTextView: reset the input method context of the text view
	// if needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContextTextView()
	// ScrollMarkOnscreenTextView scrolls @text_view the minimum distance such
	// that @mark is contained within the visible area of the widget.
	ScrollMarkOnscreenTextView(mark TextMark)
	// ScrollToIterTextView scrolls @text_view so that @iter is on the screen in
	// the position indicated by @xalign and @yalign.
	//
	// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom,
	// 0.5 means center. If @use_align is false, the text scrolls the minimal
	// distance to get the mark onscreen, possibly not scrolling at all. The
	// effective screen for purposes of this function is reduced by a margin of
	// size @within_margin.
	//
	// Note that this function uses the currently-computed height of the lines
	// in the text buffer. Line heights are computed in an idle handler; so this
	// function may not have the desired effect if its called before the height
	// computations. To avoid oddness, consider using
	// [method@Gtk.TextView.scroll_to_mark] which saves a point to be scrolled
	// to after line validation.
	ScrollToIterTextView(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool
	// ScrollToMarkTextView scrolls @text_view so that @mark is on the screen in
	// the position indicated by @xalign and @yalign.
	//
	// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom,
	// 0.5 means center. If @use_align is false, the text scrolls the minimal
	// distance to get the mark onscreen, possibly not scrolling at all. The
	// effective screen for purposes of this function is reduced by a margin of
	// size @within_margin.
	ScrollToMarkTextView(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64)
	// SetAcceptsTabTextView sets the behavior of the text widget when the Tab
	// key is pressed.
	//
	// If @accepts_tab is true, a tab character is inserted. If @accepts_tab is
	// false the keyboard focus is moved to the next widget in the focus chain.
	SetAcceptsTabTextView(acceptsTab bool)
	// SetBottomMarginTextView sets the bottom margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetBottomMarginTextView(bottomMargin int)
	// SetBufferTextView sets @buffer as the buffer being displayed by
	// @text_view.
	//
	// The previous buffer displayed by the text view is unreferenced, and a
	// reference is added to @buffer. If you owned a reference to @buffer before
	// passing it to this function, you must remove that reference yourself;
	// `GtkTextView` will not adopt it.
	SetBufferTextView(buffer TextBuffer)
	// SetCursorVisibleTextView toggles whether the insertion point should be
	// displayed.
	//
	// A buffer with no editable text probably shouldnt have a visible cursor,
	// so you may want to turn the cursor off.
	//
	// Note that this property may be overridden by the
	// [property@GtkSettings:gtk-keynav-use-caret] setting.
	SetCursorVisibleTextView(setting bool)
	// SetEditableTextView sets the default editability of the `GtkTextView`.
	//
	// You can override this default setting with tags in the buffer, using the
	// editable attribute of tags.
	SetEditableTextView(setting bool)
	// SetExtraMenuTextView sets a menu model to add when constructing the
	// context menu for @text_view.
	//
	// You can pass nil to remove a previously set extra menu.
	SetExtraMenuTextView(model gio.MenuModel)
	// SetGutterTextView places @widget into the gutter specified by @win.
	//
	// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
	// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	SetGutterTextView(win TextWindowType, widget Widget)
	// SetIndentTextView sets the default indentation for paragraphs in
	// @text_view.
	//
	// Tags in the buffer may override the default.
	SetIndentTextView(indent int)
	// SetInputHintsTextView sets the `input-hints` of the `GtkTextView`.
	//
	// The `input-hints` allow input methods to fine-tune their behaviour.
	SetInputHintsTextView(hints InputHints)
	// SetInputPurposeTextView sets the `input-purpose` of the `GtkTextView`.
	//
	// The `input-purpose` can be used by on-screen keyboards and other input
	// methods to adjust their behaviour.
	SetInputPurposeTextView(purpose InputPurpose)
	// SetJustificationTextView sets the default justification of text in
	// @text_view.
	//
	// Tags in the views buffer may override the default.
	SetJustificationTextView(justification Justification)
	// SetLeftMarginTextView sets the default left margin for text in
	// @text_view.
	//
	// Tags in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetLeftMarginTextView(leftMargin int)
	// SetMonospaceTextView sets whether the `GtkTextView` should display text
	// in monospace styling.
	SetMonospaceTextView(monospace bool)
	// SetOverwriteTextView changes the `GtkTextView` overwrite mode.
	SetOverwriteTextView(overwrite bool)
	// SetPixelsAboveLinesTextView sets the default number of blank pixels above
	// paragraphs in @text_view.
	//
	// Tags in the buffer for @text_view may override the defaults.
	SetPixelsAboveLinesTextView(pixelsAboveLines int)
	// SetPixelsBelowLinesTextView sets the default number of pixels of blank
	// space to put below paragraphs in @text_view.
	//
	// May be overridden by tags applied to @text_views buffer.
	SetPixelsBelowLinesTextView(pixelsBelowLines int)
	// SetPixelsInsideWrapTextView sets the default number of pixels of blank
	// space to leave between display/wrapped lines within a paragraph.
	//
	// May be overridden by tags in @text_views buffer.
	SetPixelsInsideWrapTextView(pixelsInsideWrap int)
	// SetRightMarginTextView sets the default right margin for text in the text
	// view.
	//
	// Tags in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetRightMarginTextView(rightMargin int)
	// SetTabsTextView sets the default tab stops for paragraphs in @text_view.
	//
	// Tags in the buffer may override the default.
	SetTabsTextView(tabs *pango.TabArray)
	// SetTopMarginTextView sets the top margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetTopMarginTextView(topMargin int)
	// SetWrapModeTextView sets the line wrapping for the view.
	SetWrapModeTextView(wrapMode WrapMode)
	// StartsDisplayLineTextView determines whether @iter is at the start of a
	// display line.
	//
	// See [method@Gtk.TextView.forward_display_line] for an explanation of
	// display lines vs. paragraphs.
	StartsDisplayLineTextView(iter *TextIter) bool
	// WindowToBufferCoordsTextView converts coordinates on the window
	// identified by @win to buffer coordinates.
	WindowToBufferCoordsTextView(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int)
}

// textView implements the TextView class.
type textView struct {
	Widget
}

// WrapTextView wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextView(obj *externglib.Object) TextView {
	return textView{
		Widget: WrapWidget(obj),
	}
}

func marshalTextView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextView(obj), nil
}

// NewTextView creates a new `GtkTextView`.
//
// If you dont call [method@Gtk.TextView.set_buffer] before using the text
// view, an empty default buffer will be created for you. Get the buffer with
// [method@Gtk.TextView.get_buffer]. If you want to specify your own buffer,
// consider [ctor@Gtk.TextView.new_with_buffer].
func NewTextView() TextView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_view_new()

	var _textView TextView // out

	_textView = WrapTextView(externglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// NewTextViewWithBuffer creates a new `GtkTextView` widget displaying the
// buffer @buffer.
//
// One buffer can be shared among many widgets. @buffer may be nil to create a
// default buffer, in which case this function is equivalent to
// [ctor@Gtk.TextView.new]. The text view adds its own reference count to the
// buffer; it does not take over an existing reference.
func NewTextViewWithBuffer(buffer TextBuffer) TextView {
	var _arg1 *C.GtkTextBuffer // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_view_new_with_buffer(_arg1)

	var _textView TextView // out

	_textView = WrapTextView(externglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

func (t textView) AddChildAtAnchorTextView(child Widget, anchor TextChildAnchor) {
	var _arg0 *C.GtkTextView        // out
	var _arg1 *C.GtkWidget          // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_view_add_child_at_anchor(_arg0, _arg1, _arg2)
}

func (t textView) AddOverlayTextView(child Widget, xpos int, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.int)(xpos)
	_arg3 = (C.int)(ypos)

	C.gtk_text_view_add_overlay(_arg0, _arg1, _arg2, _arg3)
}

func (t textView) BackwardDisplayLineTextView(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_backward_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) BackwardDisplayLineStartTextView(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_backward_display_line_start(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) BufferToWindowCoordsTextView(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTextWindowType)(win)
	_arg2 = (C.int)(bufferX)
	_arg3 = (C.int)(bufferY)

	C.gtk_text_view_buffer_to_window_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _windowX int // out
	var _windowY int // out

	_windowX = (int)(_arg4)
	_windowY = (int)(_arg5)

	return _windowX, _windowY
}

func (t textView) ForwardDisplayLineTextView(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_forward_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) ForwardDisplayLineEndTextView(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_forward_display_line_end(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) AcceptsTab() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_accepts_tab(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) BottomMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_bottom_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textView) Buffer() TextBuffer {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_buffer(_arg0)

	var _textBuffer TextBuffer // out

	_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

	return _textBuffer
}

func (t textView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _strong gdk.Rectangle
	var _weak gdk.Rectangle

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	C.gtk_text_view_get_cursor_locations(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_strong)), (*C.GdkRectangle)(unsafe.Pointer(&_weak)))

	return _strong, _weak
}

func (t textView) CursorVisible() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_cursor_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) Editable() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_editable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) ExtraMenu() gio.MenuModel {
	var _arg0 *C.GtkTextView // out
	var _cret *C.GMenuModel  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_extra_menu(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (t textView) Gutter(win TextWindowType) Widget {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTextWindowType)(win)

	_cret = C.gtk_text_view_get_gutter(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (t textView) Indent() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_indent(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textView) InputHints() InputHints {
	var _arg0 *C.GtkTextView  // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_input_hints(_arg0)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

func (t textView) InputPurpose() InputPurpose {
	var _arg0 *C.GtkTextView    // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_input_purpose(_arg0)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

func (t textView) IterAtLocation(x int, y int) (TextIter, bool) {
	var _arg0 *C.GtkTextView // out
	var _iter TextIter
	var _arg2 C.int      // out
	var _arg3 C.int      // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg2 = (C.int)(x)
	_arg3 = (C.int)(y)

	_cret = C.gtk_text_view_get_iter_at_location(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (t textView) IterAtPosition(x int, y int) (TextIter, int, bool) {
	var _arg0 *C.GtkTextView // out
	var _iter TextIter
	var _arg2 C.int      // in
	var _arg3 C.int      // out
	var _arg4 C.int      // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg3 = (C.int)(x)
	_arg4 = (C.int)(y)

	_cret = C.gtk_text_view_get_iter_at_position(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), &_arg2, _arg3, _arg4)

	var _trailing int // out
	var _ok bool      // out

	_trailing = (int)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _trailing, _ok
}

func (t textView) IterLocation(iter *TextIter) gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _location gdk.Rectangle

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	C.gtk_text_view_get_iter_location(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_location)))

	return _location
}

func (t textView) Justification() Justification {
	var _arg0 *C.GtkTextView     // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_justification(_arg0)

	var _justification Justification // out

	_justification = Justification(_cret)

	return _justification
}

func (t textView) LeftMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_left_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textView) LineAtY(y int) (TextIter, int) {
	var _arg0 *C.GtkTextView // out
	var _targetIter TextIter
	var _arg2 C.int // out
	var _arg3 C.int // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg2 = (C.int)(y)

	C.gtk_text_view_get_line_at_y(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_targetIter)), _arg2, &_arg3)

	var _lineTop int // out

	_lineTop = (int)(_arg3)

	return _targetIter, _lineTop
}

func (t textView) LineYrange(iter *TextIter) (y int, height int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.int          // in
	var _arg3 C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	C.gtk_text_view_get_line_yrange(_arg0, _arg1, &_arg2, &_arg3)

	var _y int      // out
	var _height int // out

	_y = (int)(_arg2)
	_height = (int)(_arg3)

	return _y, _height
}

func (t textView) Monospace() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_monospace(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) Overwrite() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_overwrite(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) PixelsAboveLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_pixels_above_lines(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textView) PixelsBelowLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_pixels_below_lines(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textView) PixelsInsideWrap() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_pixels_inside_wrap(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textView) RightMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_right_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textView) Tabs() *pango.TabArray {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_tabs(_arg0)

	var _tabArray *pango.TabArray // out

	_tabArray = pango.WrapTabArray(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_tabArray, func(v *pango.TabArray) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _tabArray
}

func (t textView) TopMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_top_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t textView) VisibleRect() gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _visibleRect gdk.Rectangle

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_get_visible_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_visibleRect)))

	return _visibleRect
}

func (t textView) WrapMode() WrapMode {
	var _arg0 *C.GtkTextView // out
	var _cret C.GtkWrapMode  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_wrap_mode(_arg0)

	var _wrapMode WrapMode // out

	_wrapMode = WrapMode(_cret)

	return _wrapMode
}

func (t textView) ImContextFilterKeypressTextView(event gdk.Event) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GdkEvent    // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_text_view_im_context_filter_keypress(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) MoveMarkOnscreenTextView(mark TextMark) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	_cret = C.gtk_text_view_move_mark_onscreen(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) MoveOverlayTextView(child Widget, xpos int, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.int)(xpos)
	_arg3 = (C.int)(ypos)

	C.gtk_text_view_move_overlay(_arg0, _arg1, _arg2, _arg3)
}

func (t textView) MoveVisuallyTextView(iter *TextIter, count int) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.int)(count)

	_cret = C.gtk_text_view_move_visually(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) PlaceCursorOnscreenTextView() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_place_cursor_onscreen(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) RemoveTextView(child Widget) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_text_view_remove(_arg0, _arg1)
}

func (t textView) ResetCursorBlinkTextView() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_reset_cursor_blink(_arg0)
}

func (t textView) ResetImContextTextView() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_reset_im_context(_arg0)
}

func (t textView) ScrollMarkOnscreenTextView(mark TextMark) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_view_scroll_mark_onscreen(_arg0, _arg1)
}

func (t textView) ScrollToIterTextView(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.double       // out
	var _arg3 C.gboolean     // out
	var _arg4 C.double       // out
	var _arg5 C.double       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.double)(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = (C.double)(xalign)
	_arg5 = (C.double)(yalign)

	_cret = C.gtk_text_view_scroll_to_iter(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) ScrollToMarkTextView(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _arg2 C.double       // out
	var _arg3 C.gboolean     // out
	var _arg4 C.double       // out
	var _arg5 C.double       // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (C.double)(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = (C.double)(xalign)
	_arg5 = (C.double)(yalign)

	C.gtk_text_view_scroll_to_mark(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (t textView) SetAcceptsTabTextView(acceptsTab bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if acceptsTab {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_accepts_tab(_arg0, _arg1)
}

func (t textView) SetBottomMarginTextView(bottomMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(bottomMargin)

	C.gtk_text_view_set_bottom_margin(_arg0, _arg1)
}

func (t textView) SetBufferTextView(buffer TextBuffer) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_view_set_buffer(_arg0, _arg1)
}

func (t textView) SetCursorVisibleTextView(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_cursor_visible(_arg0, _arg1)
}

func (t textView) SetEditableTextView(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_editable(_arg0, _arg1)
}

func (t textView) SetExtraMenuTextView(model gio.MenuModel) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GMenuModel  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_text_view_set_extra_menu(_arg0, _arg1)
}

func (t textView) SetGutterTextView(win TextWindowType, widget Widget) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 *C.GtkWidget        // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTextWindowType)(win)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_text_view_set_gutter(_arg0, _arg1, _arg2)
}

func (t textView) SetIndentTextView(indent int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(indent)

	C.gtk_text_view_set_indent(_arg0, _arg1)
}

func (t textView) SetInputHintsTextView(hints InputHints) {
	var _arg0 *C.GtkTextView  // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkInputHints)(hints)

	C.gtk_text_view_set_input_hints(_arg0, _arg1)
}

func (t textView) SetInputPurposeTextView(purpose InputPurpose) {
	var _arg0 *C.GtkTextView    // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_text_view_set_input_purpose(_arg0, _arg1)
}

func (t textView) SetJustificationTextView(justification Justification) {
	var _arg0 *C.GtkTextView     // out
	var _arg1 C.GtkJustification // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkJustification)(justification)

	C.gtk_text_view_set_justification(_arg0, _arg1)
}

func (t textView) SetLeftMarginTextView(leftMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(leftMargin)

	C.gtk_text_view_set_left_margin(_arg0, _arg1)
}

func (t textView) SetMonospaceTextView(monospace bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if monospace {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_monospace(_arg0, _arg1)
}

func (t textView) SetOverwriteTextView(overwrite bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_overwrite(_arg0, _arg1)
}

func (t textView) SetPixelsAboveLinesTextView(pixelsAboveLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines(_arg0, _arg1)
}

func (t textView) SetPixelsBelowLinesTextView(pixelsBelowLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines(_arg0, _arg1)
}

func (t textView) SetPixelsInsideWrapTextView(pixelsInsideWrap int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap(_arg0, _arg1)
}

func (t textView) SetRightMarginTextView(rightMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(rightMargin)

	C.gtk_text_view_set_right_margin(_arg0, _arg1)
}

func (t textView) SetTabsTextView(tabs *pango.TabArray) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.gtk_text_view_set_tabs(_arg0, _arg1)
}

func (t textView) SetTopMarginTextView(topMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(topMargin)

	C.gtk_text_view_set_top_margin(_arg0, _arg1)
}

func (t textView) SetWrapModeTextView(wrapMode WrapMode) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkWrapMode  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkWrapMode)(wrapMode)

	C.gtk_text_view_set_wrap_mode(_arg0, _arg1)
}

func (t textView) StartsDisplayLineTextView(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_starts_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) WindowToBufferCoordsTextView(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTextWindowType)(win)
	_arg2 = (C.int)(windowX)
	_arg3 = (C.int)(windowY)

	C.gtk_text_view_window_to_buffer_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _bufferX int // out
	var _bufferY int // out

	_bufferX = (int)(_arg4)
	_bufferY = (int)(_arg5)

	return _bufferX, _bufferY
}

func (s textView) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s textView) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s textView) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s textView) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s textView) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s textView) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s textView) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b textView) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s textView) Border() (Border, bool) {
	return WrapScrollable(gextras.InternObject(s)).Border()
}

func (s textView) HAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).HAdjustment()
}

func (s textView) HScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).HScrollPolicy()
}

func (s textView) VAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).VAdjustment()
}

func (s textView) VScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).VScrollPolicy()
}

func (s textView) SetHAdjustment(hadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetHAdjustment(hadjustment)
}

func (s textView) SetHScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetHScrollPolicy(policy)
}

func (s textView) SetVAdjustment(vadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetVAdjustment(vadjustment)
}

func (s textView) SetVScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetVScrollPolicy(policy)
}

// ToggleButton: a `GtkToggleButton` is a button which remains pressed-in when
// clicked.
//
// Clicking again will cause the toggle button to return to its normal state.
//
// A toggle button is created by calling either [ctor@Gtk.ToggleButton.new] or
// [ctor@Gtk.ToggleButton.new_with_label]. If using the former, it is advisable
// to pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
// buttons container. (See [class@Gtk.Button] for more information).
//
// The state of a `GtkToggleButton` can be set specifically using
// [method@Gtk.ToggleButton.set_active], and retrieved using
// [method@Gtk.ToggleButton.get_active].
//
// To simply switch the state of a toggle button, use
// [method@Gtk.ToggleButton.toggled].
//
//
// Grouping
//
// Toggle buttons can be grouped together, to form mutually exclusive groups -
// only one of the buttons can be toggled at a time, and toggling another one
// will switch the currently toggled one off.
//
// To add a `GtkToggleButton` to a group, use
// [method@Gtk.ToggleButton.set_group].
//
//
// CSS nodes
//
// `GtkToggleButton` has a single CSS node with name button. To differentiate it
// from a plain `GtkButton`, it gets the .toggle style class.
//
// Creating two `GtkToggleButton` widgets.
//
// `c static void output_state (GtkToggleButton *source, gpointer user_data) {
// printf ("Active: d\n", gtk_toggle_button_get_active (source)); }
//
// void make_toggles (void) { GtkWidget *window, *toggle1, *toggle2; GtkWidget
// *box; const char *text;
//
//    window = gtk_window_new ();
//    box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
//
//    text = "Hi, Im a toggle button.";
//    toggle1 = gtk_toggle_button_new_with_label (text);
//
//    g_signal_connect (toggle1, "toggled",
//                      G_CALLBACK (output_state),
//                      NULL);
//    gtk_box_append (GTK_BOX (box), toggle1);
//
//    text = "Hi, Im a toggle button.";
//    toggle2 = gtk_toggle_button_new_with_label (text);
//    g_signal_connect (toggle2, "toggled",
//                      G_CALLBACK (output_state),
//                      NULL);
//    gtk_box_append (GTK_BOX (box), toggle2);
//
//    gtk_window_set_child (GTK_WINDOW (window), box);
//    gtk_widget_show (window);
//
// } `
type ToggleButton interface {
	Button

	// Active queries a `GtkToggleButton` and returns its current state.
	//
	// Returns true if the toggle button is pressed in and false if it is
	// raised.
	Active() bool
	// SetActiveToggleButton sets the status of the toggle button.
	//
	// Set to true if you want the `GtkToggleButton` to be pressed in, and
	// false to raise it.
	//
	// If the status of the button changes, this action causes the
	// [signal@GtkToggleButton::toggled] signal to be emitted.
	SetActiveToggleButton(isActive bool)
	// SetGroupToggleButton adds @self to the group of @group.
	//
	// In a group of multiple toggle buttons, only one button can be active at a
	// time.
	//
	// Setting up groups in a cycle leads to undefined behavior.
	//
	// Note that the same effect can be achieved via the
	// [interface@Gtk.Actionable] API, by using the same action with parameter
	// type and state type 's' for all buttons in the group, and giving each
	// button its own target value.
	SetGroupToggleButton(group ToggleButton)
	// ToggledToggleButton emits the ::toggled signal on the `GtkToggleButton`.
	//
	// There is no good reason for an application ever to call this function.
	ToggledToggleButton()
}

// toggleButton implements the ToggleButton class.
type toggleButton struct {
	Button
}

// WrapToggleButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapToggleButton(obj *externglib.Object) ToggleButton {
	return toggleButton{
		Button: WrapButton(obj),
	}
}

func marshalToggleButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToggleButton(obj), nil
}

// NewToggleButton creates a new toggle button.
//
// A widget should be packed into the button, as in [ctor@Gtk.Button.new].
func NewToggleButton() ToggleButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_toggle_button_new()

	var _toggleButton ToggleButton // out

	_toggleButton = WrapToggleButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toggleButton
}

// NewToggleButtonWithLabel creates a new toggle button with a text label.
func NewToggleButtonWithLabel(label string) ToggleButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_toggle_button_new_with_label(_arg1)

	var _toggleButton ToggleButton // out

	_toggleButton = WrapToggleButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toggleButton
}

// NewToggleButtonWithMnemonic creates a new `GtkToggleButton` containing a
// label.
//
// The label will be created using [ctor@Gtk.Label.new_with_mnemonic], so
// underscores in @label indicate the mnemonic for the button.
func NewToggleButtonWithMnemonic(label string) ToggleButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_toggle_button_new_with_mnemonic(_arg1)

	var _toggleButton ToggleButton // out

	_toggleButton = WrapToggleButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toggleButton
}

func (t toggleButton) Active() bool {
	var _arg0 *C.GtkToggleButton // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_toggle_button_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t toggleButton) SetActiveToggleButton(isActive bool) {
	var _arg0 *C.GtkToggleButton // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
	if isActive {
		_arg1 = C.TRUE
	}

	C.gtk_toggle_button_set_active(_arg0, _arg1)
}

func (t toggleButton) SetGroupToggleButton(group ToggleButton) {
	var _arg0 *C.GtkToggleButton // out
	var _arg1 *C.GtkToggleButton // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkToggleButton)(unsafe.Pointer(group.Native()))

	C.gtk_toggle_button_set_group(_arg0, _arg1)
}

func (t toggleButton) ToggledToggleButton() {
	var _arg0 *C.GtkToggleButton // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

	C.gtk_toggle_button_toggled(_arg0)
}

func (s toggleButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s toggleButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s toggleButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s toggleButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s toggleButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s toggleButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s toggleButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (a toggleButton) ActionName() string {
	return WrapActionable(gextras.InternObject(a)).ActionName()
}

func (a toggleButton) ActionTargetValue() *glib.Variant {
	return WrapActionable(gextras.InternObject(a)).ActionTargetValue()
}

func (a toggleButton) SetActionName(actionName string) {
	WrapActionable(gextras.InternObject(a)).SetActionName(actionName)
}

func (a toggleButton) SetActionTargetValue(targetValue *glib.Variant) {
	WrapActionable(gextras.InternObject(a)).SetActionTargetValue(targetValue)
}

func (a toggleButton) SetDetailedActionName(detailedActionName string) {
	WrapActionable(gextras.InternObject(a)).SetDetailedActionName(detailedActionName)
}

func (b toggleButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Tooltip: `GtkTooltip` is an object representing a widget tooltip.
//
// Basic tooltips can be realized simply by using
// [method@Gtk.Widget.set_tooltip_text] or
// [method@Gtk.Widget.set_tooltip_markup] without any explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per `GtkTreeView`
// row or cell, you will have to do a little more work:
//
// - Set the [property@Gtk.Widget:has-tooltip] property to true. This will make
// GTK monitor the widget for motion and related events which are needed to
// determine when and where to show a tooltip.
//
// - Connect to the [signal@Gtk.Widget::query-tooltip] signal. This signal will
// be emitted when a tooltip is supposed to be shown. One of the arguments
// passed to the signal handler is a `GtkTooltip` object. This is the object
// that we are about to display as a tooltip, and can be manipulated in your
// callback using functions like [method@Gtk.Tooltip.set_icon]. There are
// functions for setting the tooltips markup, setting an image from a named
// icon, or even putting in a custom widget.
//
// - Return true from your ::query-tooltip handler. This causes the tooltip to
// be show. If you return false, it will not be shown.
type Tooltip interface {

	// SetCustomTooltip replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustomTooltip(customWidget Widget)
	// SetIconTooltip sets the icon of the tooltip (which is in front of the
	// text) to be @paintable. If @paintable is nil, the image will be hidden.
	SetIconTooltip(paintable gdk.Paintable)
	// SetIconFromGIconTooltip sets the icon of the tooltip (which is in front
	// of the text) to be the icon indicated by @gicon with the size indicated
	// by @size. If @gicon is nil, the image will be hidden.
	SetIconFromGIconTooltip(gicon gio.Icon)
	// SetIconFromIconNameTooltip sets the icon of the tooltip (which is in
	// front of the text) to be the icon indicated by @icon_name with the size
	// indicated by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconNameTooltip(iconName string)
	// SetMarkupTooltip sets the text of the tooltip to be @markup.
	//
	// The string must be marked up with Pango markup. If @markup is nil, the
	// label will be hidden.
	SetMarkupTooltip(markup string)
	// SetTextTooltip sets the text of the tooltip to be @text.
	//
	// If @text is nil, the label will be hidden. See also
	// [method@Gtk.Tooltip.set_markup].
	SetTextTooltip(text string)
	// SetTipAreaTooltip sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipAreaTooltip(rect *gdk.Rectangle)
}

// tooltip implements the Tooltip class.
type tooltip struct {
	gextras.Objector
}

// WrapTooltip wraps a GObject to the right type. It is
// primarily used internally.
func WrapTooltip(obj *externglib.Object) Tooltip {
	return tooltip{
		Objector: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTooltip(obj), nil
}

func (t tooltip) SetCustomTooltip(customWidget Widget) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(customWidget.Native()))

	C.gtk_tooltip_set_custom(_arg0, _arg1)
}

func (t tooltip) SetIconTooltip(paintable gdk.Paintable) {
	var _arg0 *C.GtkTooltip   // out
	var _arg1 *C.GdkPaintable // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_tooltip_set_icon(_arg0, _arg1)
}

func (t tooltip) SetIconFromGIconTooltip(gicon gio.Icon) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))

	C.gtk_tooltip_set_icon_from_gicon(_arg0, _arg1)
}

func (t tooltip) SetIconFromIconNameTooltip(iconName string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_icon_from_icon_name(_arg0, _arg1)
}

func (t tooltip) SetMarkupTooltip(markup string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_markup(_arg0, _arg1)
}

func (t tooltip) SetTextTooltip(text string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_text(_arg0, _arg1)
}

func (t tooltip) SetTipAreaTooltip(rect *gdk.Rectangle) {
	var _arg0 *C.GtkTooltip   // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

	C.gtk_tooltip_set_tip_area(_arg0, _arg1)
}

// TreeExpander: `GtkTreeExpander` is a widget that provides an expander for a
// list.
//
// It is typically placed as a bottommost child into a `GtkListView` to allow
// users to expand and collapse children in a list with a
// [class@Gtk.TreeListModel]. `GtkTreeExpander` provides the common UI elements,
// gestures and keybindings for this purpose.
//
// On top of this, the "listitem.expand", "listitem.collapse" and
// "listitem.toggle-expand" actions are provided to allow adding custom UI for
// managing expanded state.
//
// The `GtkTreeListModel` must be set to not be passthrough. Then it will
// provide [class@Gtk.TreeListRow] items which can be set via
// [method@Gtk.TreeExpander.set_list_row] on the expander. The expander will
// then watch that row item automatically. [method@Gtk.TreeExpander.set_child]
// sets the widget that displays the actual row contents.
//
//
// CSS nodes
//
// ` treeexpander  [indent]*  [expander]  <child> `
//
// `GtkTreeExpander` has zero or one CSS nodes with the name "expander" that
// should display the expander icon. The node will be `:checked` when it is
// expanded. If the node is not expandable, an "indent" node will be displayed
// instead.
//
// For every level of depth, another "indent" node is prepended.
//
//
// Accessibility
//
// `GtkTreeExpander` uses the GTK_ACCESSIBLE_ROLE_GROUP role. The expander icon
// is represented as a GTK_ACCESSIBLE_ROLE_BUTTON, labelled by the expander's
// child, and toggling it will change the GTK_ACCESSIBLE_STATE_EXPANDED state.
type TreeExpander interface {
	Widget

	// Child gets the child widget displayed by @self.
	Child() Widget
	// Item forwards the item set on the `GtkTreeListRow` that @self is
	// managing.
	//
	// This call is essentially equivalent to calling:
	//
	// `c gtk_tree_list_row_get_item (gtk_tree_expander_get_list_row (@self));
	// `
	Item() gextras.Objector
	// ListRow gets the list row managed by @self.
	ListRow() TreeListRow
	// SetChildTreeExpander sets the content widget to display.
	SetChildTreeExpander(child Widget)
	// SetListRowTreeExpander sets the tree list row that this expander should
	// manage.
	SetListRowTreeExpander(listRow TreeListRow)
}

// treeExpander implements the TreeExpander class.
type treeExpander struct {
	Widget
}

// WrapTreeExpander wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeExpander(obj *externglib.Object) TreeExpander {
	return treeExpander{
		Widget: WrapWidget(obj),
	}
}

func marshalTreeExpander(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeExpander(obj), nil
}

// NewTreeExpander creates a new `GtkTreeExpander`
func NewTreeExpander() TreeExpander {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_tree_expander_new()

	var _treeExpander TreeExpander // out

	_treeExpander = WrapTreeExpander(externglib.Take(unsafe.Pointer(_cret)))

	return _treeExpander
}

func (s treeExpander) Child() Widget {
	var _arg0 *C.GtkTreeExpander // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_expander_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s treeExpander) Item() gextras.Objector {
	var _arg0 *C.GtkTreeExpander // out
	var _cret C.gpointer         // in

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_expander_get_item(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (s treeExpander) ListRow() TreeListRow {
	var _arg0 *C.GtkTreeExpander // out
	var _cret *C.GtkTreeListRow  // in

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_expander_get_list_row(_arg0)

	var _treeListRow TreeListRow // out

	_treeListRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeListRow)

	return _treeListRow
}

func (s treeExpander) SetChildTreeExpander(child Widget) {
	var _arg0 *C.GtkTreeExpander // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_tree_expander_set_child(_arg0, _arg1)
}

func (s treeExpander) SetListRowTreeExpander(listRow TreeListRow) {
	var _arg0 *C.GtkTreeExpander // out
	var _arg1 *C.GtkTreeListRow  // out

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeListRow)(unsafe.Pointer(listRow.Native()))

	C.gtk_tree_expander_set_list_row(_arg0, _arg1)
}

func (s treeExpander) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s treeExpander) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s treeExpander) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s treeExpander) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s treeExpander) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s treeExpander) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s treeExpander) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b treeExpander) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// TreeListModel: `GtkTreeListModel` is a list model that can create child
// models on demand.
type TreeListModel interface {
	gio.ListModel

	// Autoexpand gets whether the model is set to automatically expand new rows
	// that get added.
	//
	// This can be either rows added by changes to the underlying models or via
	// [method@Gtk.TreeListRow.set_expanded].
	Autoexpand() bool
	// ChildRow gets the row item corresponding to the child at index @position
	// for @self's root model.
	//
	// If @position is greater than the number of children in the root model,
	// nil is returned.
	//
	// Do not confuse this function with [method@Gtk.TreeListModel.get_row].
	ChildRow(position uint) TreeListRow
	// Model gets the root model that @self was created with.
	Model() gio.ListModel
	// Passthrough gets whether the model is passing through original row items.
	//
	// If this function returns false, the `GListModel` functions for @self
	// return custom `GtkTreeListRow` objects. You need to call
	// [method@Gtk.TreeListRow.get_item] on these objects to get the original
	// item.
	//
	// If true, the values of the child models are passed through in their
	// original state. You then need to call [method@Gtk.TreeListModel.get_row]
	// to get the custom `GtkTreeListRow`s.
	Passthrough() bool
	// Row gets the row object for the given row.
	//
	// If @position is greater than the number of items in @self, nil is
	// returned.
	//
	// The row object can be used to expand and collapse rows as well as to
	// inspect its position in the tree. See its documentation for details.
	//
	// This row object is persistent and will refer to the current item as long
	// as the row is present in @self, independent of other rows being added or
	// removed.
	//
	// If @self is set to not be passthrough, this function is equivalent to
	// calling g_list_model_get_item().
	//
	// Do not confuse this function with
	// [method@Gtk.TreeListModel.get_child_row].
	Row(position uint) TreeListRow
	// SetAutoexpandTreeListModel sets whether the model should autoexpand.
	//
	// If set to true, the model will recursively expand all rows that get added
	// to the model. This can be either rows added by changes to the underlying
	// models or via [method@Gtk.TreeListRow.set_expanded].
	SetAutoexpandTreeListModel(autoexpand bool)
}

// treeListModel implements the TreeListModel class.
type treeListModel struct {
	gextras.Objector
}

// WrapTreeListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeListModel(obj *externglib.Object) TreeListModel {
	return treeListModel{
		Objector: obj,
	}
}

func marshalTreeListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeListModel(obj), nil
}

func (s treeListModel) Autoexpand() bool {
	var _arg0 *C.GtkTreeListModel // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_model_get_autoexpand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s treeListModel) ChildRow(position uint) TreeListRow {
	var _arg0 *C.GtkTreeListModel // out
	var _arg1 C.guint             // out
	var _cret *C.GtkTreeListRow   // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)

	_cret = C.gtk_tree_list_model_get_child_row(_arg0, _arg1)

	var _treeListRow TreeListRow // out

	_treeListRow = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeListRow)

	return _treeListRow
}

func (s treeListModel) Model() gio.ListModel {
	var _arg0 *C.GtkTreeListModel // out
	var _cret *C.GListModel       // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_model_get_model(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s treeListModel) Passthrough() bool {
	var _arg0 *C.GtkTreeListModel // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_model_get_passthrough(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s treeListModel) Row(position uint) TreeListRow {
	var _arg0 *C.GtkTreeListModel // out
	var _arg1 C.guint             // out
	var _cret *C.GtkTreeListRow   // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)

	_cret = C.gtk_tree_list_model_get_row(_arg0, _arg1)

	var _treeListRow TreeListRow // out

	_treeListRow = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeListRow)

	return _treeListRow
}

func (s treeListModel) SetAutoexpandTreeListModel(autoexpand bool) {
	var _arg0 *C.GtkTreeListModel // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))
	if autoexpand {
		_arg1 = C.TRUE
	}

	C.gtk_tree_list_model_set_autoexpand(_arg0, _arg1)
}

// TreeListRow: `GtkTreeListRow` is used by `GtkTreeListModel` to represent
// items.
//
// It allows navigating the model as a tree and modify the state of rows.
//
// `GtkTreeListRow` instances are created by a `GtkTreeListModel` only when the
// [property@Gtk.TreeListModel:passthrough] property is not set.
//
// There are various support objects that can make use of `GtkTreeListRow`
// objects, such as the [class@Gtk.TreeExpander] widget that allows displaying
// an icon to expand or collapse a row or [class@Gtk.TreeListRowSorter] that
// makes it possible to sort trees properly.
type TreeListRow interface {

	// ChildRow: if @self is not expanded or @position is greater than the
	// number of children, nil is returned.
	ChildRow(position uint) TreeListRow
	// Children: if the row is expanded, gets the model holding the children of
	// @self.
	//
	// This model is the model created by the
	// [callback@Gtk.TreeListModelCreateModelFunc] and contains the original
	// items, no matter what value [property@Gtk.TreeListModel:passthrough] is
	// set to.
	Children() gio.ListModel
	// Depth gets the depth of this row.
	//
	// Rows that correspond to items in the root model have a depth of zero,
	// rows corresponding to items of models of direct children of the root
	// model have a depth of 1 and so on.
	//
	// The depth of a row never changes until the row is destroyed.
	Depth() uint
	// Expanded gets if a row is currently expanded.
	Expanded() bool
	// Item gets the item corresponding to this row,
	//
	// The value returned by this function never changes until the row is
	// destroyed.
	Item() gextras.Objector
	// Parent gets the row representing the parent for @self.
	//
	// That is the row that would need to be collapsed to make this row
	// disappear.
	//
	// If @self is a row corresponding to the root model, nil is returned.
	//
	// The value returned by this function never changes until the row is
	// destroyed.
	Parent() TreeListRow
	// Position returns the position in the `GtkTreeListModel` that @self
	// occupies at the moment.
	Position() uint
	// IsExpandableTreeListRow checks if a row can be expanded.
	//
	// This does not mean that the row is actually expanded, this can be checked
	// with [method@Gtk.TreeListRow.get_expanded].
	//
	// If a row is expandable never changes until the row is destroyed.
	IsExpandableTreeListRow() bool
	// SetExpandedTreeListRow expands or collapses a row.
	//
	// If a row is expanded, the model of calling the
	// [callback@Gtk.TreeListModelCreateModelFunc] for the row's item will be
	// inserted after this row. If a row is collapsed, those items will be
	// removed from the model.
	//
	// If the row is not expandable, this function does nothing.
	SetExpandedTreeListRow(expanded bool)
}

// treeListRow implements the TreeListRow class.
type treeListRow struct {
	gextras.Objector
}

// WrapTreeListRow wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeListRow(obj *externglib.Object) TreeListRow {
	return treeListRow{
		Objector: obj,
	}
}

func marshalTreeListRow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeListRow(obj), nil
}

func (s treeListRow) ChildRow(position uint) TreeListRow {
	var _arg0 *C.GtkTreeListRow // out
	var _arg1 C.guint           // out
	var _cret *C.GtkTreeListRow // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)

	_cret = C.gtk_tree_list_row_get_child_row(_arg0, _arg1)

	var _treeListRow TreeListRow // out

	_treeListRow = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeListRow)

	return _treeListRow
}

func (s treeListRow) Children() gio.ListModel {
	var _arg0 *C.GtkTreeListRow // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_row_get_children(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (s treeListRow) Depth() uint {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_row_get_depth(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s treeListRow) Expanded() bool {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_row_get_expanded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s treeListRow) Item() gextras.Objector {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.gpointer        // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_row_get_item(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (s treeListRow) Parent() TreeListRow {
	var _arg0 *C.GtkTreeListRow // out
	var _cret *C.GtkTreeListRow // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_row_get_parent(_arg0)

	var _treeListRow TreeListRow // out

	_treeListRow = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeListRow)

	return _treeListRow
}

func (s treeListRow) Position() uint {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_row_get_position(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (s treeListRow) IsExpandableTreeListRow() bool {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_row_is_expandable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s treeListRow) SetExpandedTreeListRow(expanded bool) {
	var _arg0 *C.GtkTreeListRow // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))
	if expanded {
		_arg1 = C.TRUE
	}

	C.gtk_tree_list_row_set_expanded(_arg0, _arg1)
}

// TreeListRowSorter: `GtkTreeListRowSorter` is a special-purpose sorter that
// will apply a given sorter to the levels in a tree.
//
// Here is an example for setting up a column view with a tree model and a
// `GtkTreeListSorter`:
//
// `c column_sorter = gtk_column_view_get_sorter (view); sorter =
// gtk_tree_list_row_sorter_new (g_object_ref (column_sorter)); sort_model =
// gtk_sort_list_model_new (tree_model, sorter); selection =
// gtk_single_selection_new (sort_model); gtk_column_view_set_model (view,
// G_LIST_MODEL (selection)); `
type TreeListRowSorter interface {

	// GetSorter returns the sorter used by @self.
	GetSorter() Sorter
	// SetSorterTreeListRowSorter sets the sorter to use for items with the same
	// parent.
	//
	// This sorter will be passed the [property@Gtk.TreeListRow:item] of the
	// tree list rows passed to @self.
	SetSorterTreeListRowSorter(sorter Sorter)
}

// treeListRowSorter implements the TreeListRowSorter class.
type treeListRowSorter struct {
	Sorter
}

// WrapTreeListRowSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeListRowSorter(obj *externglib.Object) TreeListRowSorter {
	return treeListRowSorter{
		Sorter: WrapSorter(obj),
	}
}

func marshalTreeListRowSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeListRowSorter(obj), nil
}

// NewTreeListRowSorter: create a special-purpose sorter that applies the
// sorting of @sorter to the levels of a `GtkTreeListModel`.
//
// Note that this sorter relies on [property@Gtk.TreeListModel:passthrough]
// being false as it can only sort [class@Gtk.TreeListRow]s.
func NewTreeListRowSorter(sorter Sorter) TreeListRowSorter {
	var _arg1 *C.GtkSorter            // out
	var _cret *C.GtkTreeListRowSorter // in

	_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

	_cret = C.gtk_tree_list_row_sorter_new(_arg1)

	var _treeListRowSorter TreeListRowSorter // out

	_treeListRowSorter = WrapTreeListRowSorter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _treeListRowSorter
}

func (s treeListRowSorter) GetSorter() Sorter {
	var _arg0 *C.GtkTreeListRowSorter // out
	var _cret *C.GtkSorter            // in

	_arg0 = (*C.GtkTreeListRowSorter)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_list_row_sorter_get_sorter(_arg0)

	var _sorter Sorter // out

	_sorter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Sorter)

	return _sorter
}

func (s treeListRowSorter) SetSorterTreeListRowSorter(sorter Sorter) {
	var _arg0 *C.GtkTreeListRowSorter // out
	var _arg1 *C.GtkSorter            // out

	_arg0 = (*C.GtkTreeListRowSorter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

	C.gtk_tree_list_row_sorter_set_sorter(_arg0, _arg1)
}

// TreeModelFilter: a GtkTreeModel which hides parts of an underlying tree model
//
// A TreeModelFilter is a tree model which wraps another tree model, and can do
// the following things:
//
// - Filter specific rows, based on data from a visible column, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a visible function, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the appearance of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a virtual root. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
//
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference counting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the nodes child level (or the last row removed), the nodes
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a childs
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter interface {
	TreeDragSource
	TreeModel

	// ClearCacheTreeModelFilter: this function should almost never be called.
	// It clears the @filter of any cached iterators that havent been reffed
	// with gtk_tree_model_ref_node(). This might be useful if the child model
	// being filtered is static (and doesnt change often) and there has been a
	// lot of unreffed access to nodes. As a side effect of this function, all
	// unreffed iters will be invalid.
	ClearCacheTreeModelFilter()
	// ConvertChildIterToIterTreeModelFilter sets @filter_iter to point to the
	// row in @filter that corresponds to the row pointed at by @child_iter. If
	// @filter_iter was not set, false is returned.
	ConvertChildIterToIterTreeModelFilter(childIter *TreeIter) (TreeIter, bool)
	// ConvertChildPathToPathTreeModelFilter converts @child_path to a path
	// relative to @filter. That is, @child_path points to a path in the child
	// model. The rerturned path will point to the same row in the filtered
	// model. If @child_path isnt a valid path on the child model or points to
	// a row which is not visible in @filter, then nil is returned.
	ConvertChildPathToPathTreeModelFilter(childPath *TreePath) *TreePath
	// ConvertIterToChildIterTreeModelFilter sets @child_iter to point to the
	// row pointed to by @filter_iter.
	ConvertIterToChildIterTreeModelFilter(filterIter *TreeIter) TreeIter
	// ConvertPathToChildPathTreeModelFilter converts @filter_path to a path on
	// the child model of @filter. That is, @filter_path points to a location in
	// @filter. The returned path will point to the same location in the model
	// not being filtered. If @filter_path does not point to a location in the
	// child model, nil is returned.
	ConvertPathToChildPathTreeModelFilter(filterPath *TreePath) *TreePath
	// Model returns a pointer to the child model of @filter.
	Model() TreeModel
	// RefilterTreeModelFilter emits ::row_changed for each row in the child
	// model, which causes the filter to re-evaluate whether a row is visible or
	// not.
	RefilterTreeModelFilter()
	// SetVisibleColumnTreeModelFilter sets @column of the child_model to be the
	// column where @filter should look for visibility information. @columns
	// should be a column of type G_TYPE_BOOLEAN, where true means that a row is
	// visible, and false if not.
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleColumnTreeModelFilter(column int)
}

// treeModelFilter implements the TreeModelFilter class.
type treeModelFilter struct {
	gextras.Objector
}

// WrapTreeModelFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeModelFilter(obj *externglib.Object) TreeModelFilter {
	return treeModelFilter{
		Objector: obj,
	}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelFilter(obj), nil
}

func (f treeModelFilter) ClearCacheTreeModelFilter() {
	var _arg0 *C.GtkTreeModelFilter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

	C.gtk_tree_model_filter_clear_cache(_arg0)
}

func (f treeModelFilter) ConvertChildIterToIterTreeModelFilter(childIter *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModelFilter // out
	var _filterIter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(childIter.Native()))

	_cret = C.gtk_tree_model_filter_convert_child_iter_to_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_filterIter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _filterIter, _ok
}

func (f treeModelFilter) ConvertChildPathToPathTreeModelFilter(childPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GtkTreePath        // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(childPath.Native()))

	_cret = C.gtk_tree_model_filter_convert_child_path_to_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

func (f treeModelFilter) ConvertIterToChildIterTreeModelFilter(filterIter *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeModelFilter // out
	var _childIter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(filterIter.Native()))

	C.gtk_tree_model_filter_convert_iter_to_child_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_childIter)), _arg2)

	return _childIter
}

func (f treeModelFilter) ConvertPathToChildPathTreeModelFilter(filterPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GtkTreePath        // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(filterPath.Native()))

	_cret = C.gtk_tree_model_filter_convert_path_to_child_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

func (f treeModelFilter) Model() TreeModel {
	var _arg0 *C.GtkTreeModelFilter // out
	var _cret *C.GtkTreeModel       // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_tree_model_filter_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

func (f treeModelFilter) RefilterTreeModelFilter() {
	var _arg0 *C.GtkTreeModelFilter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

	C.gtk_tree_model_filter_refilter(_arg0)
}

func (f treeModelFilter) SetVisibleColumnTreeModelFilter(column int) {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (C.int)(column)

	C.gtk_tree_model_filter_set_visible_column(_arg0, _arg1)
}

func (d treeModelFilter) DragDataDelete(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataDelete(path)
}

func (d treeModelFilter) DragDataGet(path *TreePath) gdk.ContentProvider {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataGet(path)
}

func (d treeModelFilter) RowDraggable(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).RowDraggable(path)
}

func (c treeModelFilter) NewFilter(root *TreePath) TreeModel {
	return WrapTreeModel(gextras.InternObject(c)).NewFilter(root)
}

func (t treeModelFilter) ColumnType(index_ int) externglib.Type {
	return WrapTreeModel(gextras.InternObject(t)).ColumnType(index_)
}

func (t treeModelFilter) Flags() TreeModelFlags {
	return WrapTreeModel(gextras.InternObject(t)).Flags()
}

func (t treeModelFilter) Iter(path *TreePath) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).Iter(path)
}

func (t treeModelFilter) IterFirst() (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterFirst()
}

func (t treeModelFilter) IterFromString(pathString string) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterFromString(pathString)
}

func (t treeModelFilter) NColumns() int {
	return WrapTreeModel(gextras.InternObject(t)).NColumns()
}

func (t treeModelFilter) Path(iter *TreeIter) *TreePath {
	return WrapTreeModel(gextras.InternObject(t)).Path(iter)
}

func (t treeModelFilter) StringFromIter(iter *TreeIter) string {
	return WrapTreeModel(gextras.InternObject(t)).StringFromIter(iter)
}

func (t treeModelFilter) Value(iter *TreeIter, column int) externglib.Value {
	return WrapTreeModel(gextras.InternObject(t)).Value(iter, column)
}

func (t treeModelFilter) IterChildren(parent *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterChildren(parent)
}

func (t treeModelFilter) IterHasChild(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterHasChild(iter)
}

func (t treeModelFilter) IterNChildren(iter *TreeIter) int {
	return WrapTreeModel(gextras.InternObject(t)).IterNChildren(iter)
}

func (t treeModelFilter) IterNext(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterNext(iter)
}

func (t treeModelFilter) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterNthChild(parent, n)
}

func (t treeModelFilter) IterParent(child *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterParent(child)
}

func (t treeModelFilter) IterPrevious(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterPrevious(iter)
}

func (t treeModelFilter) RefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RefNode(iter)
}

func (t treeModelFilter) RowChanged(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowChanged(path, iter)
}

func (t treeModelFilter) RowDeleted(path *TreePath) {
	WrapTreeModel(gextras.InternObject(t)).RowDeleted(path)
}

func (t treeModelFilter) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowHasChildToggled(path, iter)
}

func (t treeModelFilter) RowInserted(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowInserted(path, iter)
}

func (t treeModelFilter) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int) {
	WrapTreeModel(gextras.InternObject(t)).RowsReorderedWithLength(path, iter, newOrder)
}

func (t treeModelFilter) UnrefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).UnrefNode(iter)
}

// TreeModelSort: a GtkTreeModel which makes an underlying tree model sortable
//
// The TreeModelSort is a model which implements the TreeSortable interface. It
// does not hold any data itself, but rather is created with a child model and
// proxies its data. It has identical column types to this child model, and the
// changes in the child are propagated. The primary purpose of this model is to
// provide a way to sort a different model without modifying it. Note that the
// sort function used by TreeModelSort is not guaranteed to be stable.
//
// The use of this is best demonstrated through an example. In the following
// sample code we create two TreeView widgets each with a view of the same data.
// As the model is wrapped here by a TreeModelSort, the two TreeViews can each
// sort their view of the data without affecting the other. By contrast, if we
// simply put the same model in each widget, then sorting the first would sort
// the second.
//
// Using a TreeModelSort
//
//    void
//    selection_changed (GtkTreeSelection *selection, gpointer data)
//    {
//      GtkTreeModel *sort_model = NULL;
//      GtkTreeModel *child_model;
//      GtkTreeIter sort_iter;
//      GtkTreeIter child_iter;
//      char *some_data = NULL;
//      char *modified_data;
//
//      // Get the current selected row and the model.
//      if (! gtk_tree_selection_get_selected (selection,
//                                             &sort_model,
//                                             &sort_iter))
//        return;
//
//      // Look up the current value on the selected row and get
//      // a new value to change it to.
//      gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
//                          COLUMN_1, &some_data,
//                          -1);
//
//      modified_data = change_the_data (some_data);
//      g_free (some_data);
//
//      // Get an iterator on the child model, instead of the sort model.
//      gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
//                                                      &child_iter,
//                                                      &sort_iter);
//
//      // Get the child model and change the value of the row. In this
//      // example, the child model is a GtkListStore. It could be any other
//      // type of model, though.
//      child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
//      gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
//                          COLUMN_1, &modified_data,
//                          -1);
//      g_free (modified_data);
//    }
type TreeModelSort interface {
	TreeDragSource
	TreeSortable

	// ClearCacheTreeModelSort: this function should almost never be called. It
	// clears the @tree_model_sort of any cached iterators that havent been
	// reffed with gtk_tree_model_ref_node(). This might be useful if the child
	// model being sorted is static (and doesnt change often) and there has
	// been a lot of unreffed access to nodes. As a side effect of this
	// function, all unreffed iters will be invalid.
	ClearCacheTreeModelSort()
	// ConvertChildIterToIterTreeModelSort sets @sort_iter to point to the row
	// in @tree_model_sort that corresponds to the row pointed at by
	// @child_iter. If @sort_iter was not set, false is returned. Note: a
	// boolean is only returned since 2.14.
	ConvertChildIterToIterTreeModelSort(childIter *TreeIter) (TreeIter, bool)
	// ConvertChildPathToPathTreeModelSort converts @child_path to a path
	// relative to @tree_model_sort. That is, @child_path points to a path in
	// the child model. The returned path will point to the same row in the
	// sorted model. If @child_path isnt a valid path on the child model, then
	// nil is returned.
	ConvertChildPathToPathTreeModelSort(childPath *TreePath) *TreePath
	// ConvertIterToChildIterTreeModelSort sets @child_iter to point to the row
	// pointed to by @sorted_iter.
	ConvertIterToChildIterTreeModelSort(sortedIter *TreeIter) TreeIter
	// ConvertPathToChildPathTreeModelSort converts @sorted_path to a path on
	// the child model of @tree_model_sort. That is, @sorted_path points to a
	// location in @tree_model_sort. The returned path will point to the same
	// location in the model not being sorted. If @sorted_path does not point to
	// a location in the child model, nil is returned.
	ConvertPathToChildPathTreeModelSort(sortedPath *TreePath) *TreePath
	// Model returns the model the TreeModelSort is sorting.
	Model() TreeModel
	// IterIsValidTreeModelSort: > This function is slow. Only use it for
	// debugging and/or testing > purposes.
	//
	// Checks if the given iter is a valid iter for this TreeModelSort.
	IterIsValidTreeModelSort(iter *TreeIter) bool
	// ResetDefaultSortFuncTreeModelSort: this resets the default sort function
	// to be in the unsorted state. That is, it is in the same order as the
	// child model. It will re-sort the model to be in the same order as the
	// child model only if the TreeModelSort is in unsorted state.
	ResetDefaultSortFuncTreeModelSort()
}

// treeModelSort implements the TreeModelSort class.
type treeModelSort struct {
	gextras.Objector
}

// WrapTreeModelSort wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeModelSort(obj *externglib.Object) TreeModelSort {
	return treeModelSort{
		Objector: obj,
	}
}

func marshalTreeModelSort(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelSort(obj), nil
}

// NewTreeModelSortWithModel creates a new TreeModelSort, with @child_model as
// the child model.
func NewTreeModelSortWithModel(childModel TreeModel) TreeModelSort {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkTreeModel // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(childModel.Native()))

	_cret = C.gtk_tree_model_sort_new_with_model(_arg1)

	var _treeModelSort TreeModelSort // out

	_treeModelSort = WrapTreeModelSort(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _treeModelSort
}

func (t treeModelSort) ClearCacheTreeModelSort() {
	var _arg0 *C.GtkTreeModelSort // out

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

	C.gtk_tree_model_sort_clear_cache(_arg0)
}

func (t treeModelSort) ConvertChildIterToIterTreeModelSort(childIter *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModelSort // out
	var _sortIter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(childIter.Native()))

	_cret = C.gtk_tree_model_sort_convert_child_iter_to_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_sortIter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _sortIter, _ok
}

func (t treeModelSort) ConvertChildPathToPathTreeModelSort(childPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 *C.GtkTreePath      // out
	var _cret *C.GtkTreePath      // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(childPath.Native()))

	_cret = C.gtk_tree_model_sort_convert_child_path_to_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

func (t treeModelSort) ConvertIterToChildIterTreeModelSort(sortedIter *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeModelSort // out
	var _childIter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sortedIter.Native()))

	C.gtk_tree_model_sort_convert_iter_to_child_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_childIter)), _arg2)

	return _childIter
}

func (t treeModelSort) ConvertPathToChildPathTreeModelSort(sortedPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 *C.GtkTreePath      // out
	var _cret *C.GtkTreePath      // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(sortedPath.Native()))

	_cret = C.gtk_tree_model_sort_convert_path_to_child_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

func (t treeModelSort) Model() TreeModel {
	var _arg0 *C.GtkTreeModelSort // out
	var _cret *C.GtkTreeModel     // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_model_sort_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

func (t treeModelSort) IterIsValidTreeModelSort(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 *C.GtkTreeIter      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_sort_iter_is_valid(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeModelSort) ResetDefaultSortFuncTreeModelSort() {
	var _arg0 *C.GtkTreeModelSort // out

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

	C.gtk_tree_model_sort_reset_default_sort_func(_arg0)
}

func (d treeModelSort) DragDataDelete(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataDelete(path)
}

func (d treeModelSort) DragDataGet(path *TreePath) gdk.ContentProvider {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataGet(path)
}

func (d treeModelSort) RowDraggable(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).RowDraggable(path)
}

func (c treeModelSort) NewFilter(root *TreePath) TreeModel {
	return WrapTreeModel(gextras.InternObject(c)).NewFilter(root)
}

func (t treeModelSort) ColumnType(index_ int) externglib.Type {
	return WrapTreeModel(gextras.InternObject(t)).ColumnType(index_)
}

func (t treeModelSort) Flags() TreeModelFlags {
	return WrapTreeModel(gextras.InternObject(t)).Flags()
}

func (t treeModelSort) Iter(path *TreePath) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).Iter(path)
}

func (t treeModelSort) IterFirst() (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterFirst()
}

func (t treeModelSort) IterFromString(pathString string) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterFromString(pathString)
}

func (t treeModelSort) NColumns() int {
	return WrapTreeModel(gextras.InternObject(t)).NColumns()
}

func (t treeModelSort) Path(iter *TreeIter) *TreePath {
	return WrapTreeModel(gextras.InternObject(t)).Path(iter)
}

func (t treeModelSort) StringFromIter(iter *TreeIter) string {
	return WrapTreeModel(gextras.InternObject(t)).StringFromIter(iter)
}

func (t treeModelSort) Value(iter *TreeIter, column int) externglib.Value {
	return WrapTreeModel(gextras.InternObject(t)).Value(iter, column)
}

func (t treeModelSort) IterChildren(parent *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterChildren(parent)
}

func (t treeModelSort) IterHasChild(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterHasChild(iter)
}

func (t treeModelSort) IterNChildren(iter *TreeIter) int {
	return WrapTreeModel(gextras.InternObject(t)).IterNChildren(iter)
}

func (t treeModelSort) IterNext(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterNext(iter)
}

func (t treeModelSort) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterNthChild(parent, n)
}

func (t treeModelSort) IterParent(child *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterParent(child)
}

func (t treeModelSort) IterPrevious(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterPrevious(iter)
}

func (t treeModelSort) RefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RefNode(iter)
}

func (t treeModelSort) RowChanged(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowChanged(path, iter)
}

func (t treeModelSort) RowDeleted(path *TreePath) {
	WrapTreeModel(gextras.InternObject(t)).RowDeleted(path)
}

func (t treeModelSort) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowHasChildToggled(path, iter)
}

func (t treeModelSort) RowInserted(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowInserted(path, iter)
}

func (t treeModelSort) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int) {
	WrapTreeModel(gextras.InternObject(t)).RowsReorderedWithLength(path, iter, newOrder)
}

func (t treeModelSort) UnrefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).UnrefNode(iter)
}

func (s treeModelSort) SortColumnID() (int, SortType, bool) {
	return WrapTreeSortable(gextras.InternObject(s)).SortColumnID()
}

func (s treeModelSort) HasDefaultSortFunc() bool {
	return WrapTreeSortable(gextras.InternObject(s)).HasDefaultSortFunc()
}

func (s treeModelSort) SetSortColumnID(sortColumnId int, order SortType) {
	WrapTreeSortable(gextras.InternObject(s)).SetSortColumnID(sortColumnId, order)
}

func (s treeModelSort) SortColumnChanged() {
	WrapTreeSortable(gextras.InternObject(s)).SortColumnChanged()
}

// TreeSelection: the selection object for GtkTreeView
//
// The TreeSelection object is a helper object to manage the selection for a
// TreeView widget. The TreeSelection object is automatically created when a new
// TreeView widget is created, and cannot exist independently of this widget.
// The primary reason the TreeSelection objects exists is for cleanliness of
// code and API. That is, there is no conceptual reason all these functions
// could not be methods on the TreeView widget instead of a separate function.
//
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
//
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is, it
// may only emit one signal when a range of rows is selected. Additionally, it
// may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
type TreeSelection interface {

	// CountSelectedRowsTreeSelection returns the number of rows that have been
	// selected in @tree.
	CountSelectedRowsTreeSelection() int
	// Mode gets the selection mode for @selection. See
	// gtk_tree_selection_set_mode().
	Mode() SelectionMode
	// Selected sets @iter to the currently selected node if @selection is set
	// to K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you
	// just want to test if @selection has any selected nodes. @model is filled
	// with the current model as a convenience. This function will not work if
	// you use @selection is K_SELECTION_MULTIPLE.
	Selected() (TreeModel, TreeIter, bool)
	// TreeView returns the tree view associated with @selection.
	TreeView() TreeView
	// IterIsSelectedTreeSelection returns true if the row at @iter is currently
	// selected.
	IterIsSelectedTreeSelection(iter *TreeIter) bool
	// PathIsSelectedTreeSelection returns true if the row pointed to by @path
	// is currently selected. If @path does not point to a valid location, false
	// is returned
	PathIsSelectedTreeSelection(path *TreePath) bool
	// SelectAllTreeSelection selects all the nodes. @selection must be set to
	// K_SELECTION_MULTIPLE mode.
	SelectAllTreeSelection()
	// SelectIterTreeSelection selects the specified iterator.
	SelectIterTreeSelection(iter *TreeIter)
	// SelectPathTreeSelection: select the row at @path.
	SelectPathTreeSelection(path *TreePath)
	// SelectRangeTreeSelection selects a range of nodes, determined by
	// @start_path and @end_path inclusive. @selection must be set to
	// K_SELECTION_MULTIPLE mode.
	SelectRangeTreeSelection(startPath *TreePath, endPath *TreePath)
	// SetModeTreeSelection sets the selection mode of the @selection. If the
	// previous type was K_SELECTION_MULTIPLE, then the anchor is kept selected,
	// if it was previously selected.
	SetModeTreeSelection(typ SelectionMode)
	// UnselectAllTreeSelection unselects all the nodes.
	UnselectAllTreeSelection()
	// UnselectIterTreeSelection unselects the specified iterator.
	UnselectIterTreeSelection(iter *TreeIter)
	// UnselectPathTreeSelection unselects the row at @path.
	UnselectPathTreeSelection(path *TreePath)
	// UnselectRangeTreeSelection unselects a range of nodes, determined by
	// @start_path and @end_path inclusive.
	UnselectRangeTreeSelection(startPath *TreePath, endPath *TreePath)
}

// treeSelection implements the TreeSelection class.
type treeSelection struct {
	gextras.Objector
}

// WrapTreeSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeSelection(obj *externglib.Object) TreeSelection {
	return treeSelection{
		Objector: obj,
	}
}

func marshalTreeSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeSelection(obj), nil
}

func (s treeSelection) CountSelectedRowsTreeSelection() int {
	var _arg0 *C.GtkTreeSelection // out
	var _cret C.int               // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_selection_count_selected_rows(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s treeSelection) Mode() SelectionMode {
	var _arg0 *C.GtkTreeSelection // out
	var _cret C.GtkSelectionMode  // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_selection_get_mode(_arg0)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

func (s treeSelection) Selected() (TreeModel, TreeIter, bool) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeModel     // in
	var _iter TreeIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_selection_get_selected(_arg0, &_arg1, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _model TreeModel // out

	var _ok bool // out

	_model = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(TreeModel)

	if _cret != 0 {
		_ok = true
	}

	return _model, _iter, _ok
}

func (s treeSelection) TreeView() TreeView {
	var _arg0 *C.GtkTreeSelection // out
	var _cret *C.GtkTreeView      // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_selection_get_tree_view(_arg0)

	var _treeView TreeView // out

	_treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeView)

	return _treeView
}

func (s treeSelection) IterIsSelectedTreeSelection(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeIter      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_selection_iter_is_selected(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s treeSelection) PathIsSelectedTreeSelection(path *TreePath) bool {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_selection_path_is_selected(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s treeSelection) SelectAllTreeSelection() {
	var _arg0 *C.GtkTreeSelection // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_select_all(_arg0)
}

func (s treeSelection) SelectIterTreeSelection(iter *TreeIter) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeIter      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_selection_select_iter(_arg0, _arg1)
}

func (s treeSelection) SelectPathTreeSelection(path *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_selection_select_path(_arg0, _arg1)
}

func (s treeSelection) SelectRangeTreeSelection(startPath *TreePath, endPath *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out
	var _arg2 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

	C.gtk_tree_selection_select_range(_arg0, _arg1, _arg2)
}

func (s treeSelection) SetModeTreeSelection(typ SelectionMode) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 C.GtkSelectionMode  // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSelectionMode)(typ)

	C.gtk_tree_selection_set_mode(_arg0, _arg1)
}

func (s treeSelection) UnselectAllTreeSelection() {
	var _arg0 *C.GtkTreeSelection // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_unselect_all(_arg0)
}

func (s treeSelection) UnselectIterTreeSelection(iter *TreeIter) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeIter      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_selection_unselect_iter(_arg0, _arg1)
}

func (s treeSelection) UnselectPathTreeSelection(path *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_selection_unselect_path(_arg0, _arg1)
}

func (s treeSelection) UnselectRangeTreeSelection(startPath *TreePath, endPath *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out
	var _arg2 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

	C.gtk_tree_selection_unselect_range(_arg0, _arg1, _arg2)
}

// TreeStore: a tree-like data structure that can be used with the GtkTreeView
//
// The TreeStore object is a list model for use with a TreeView widget. It
// implements the TreeModel interface, and consequently, can use all of the
// methods available there. It also implements the TreeSortable interface so it
// can be sorted by the view. Finally, it also implements the tree [drag and
// drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
//
//
// GtkTreeStore as GtkBuildable
//
// The GtkTreeStore implementation of the Buildable interface allows to specify
// the model columns with a <columns> element that may contain multiple <column>
// elements, each specifying one model column. The type attribute specifies
// the data type for the column.
//
// An example of a UI Definition fragment for a tree store:
//
//    <object class="GtkTreeStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//    </object>
type TreeStore interface {
	Buildable
	TreeDragDest
	TreeDragSource
	TreeSortable

	// AppendTreeStore appends a new row to @tree_store. If @parent is non-nil,
	// then it will append the new row after the last child of @parent,
	// otherwise it will append a row to the top level. @iter will be changed to
	// point to this new row. The row will be empty after this function is
	// called. To fill in values, you need to call gtk_tree_store_set() or
	// gtk_tree_store_set_value().
	AppendTreeStore(parent *TreeIter) TreeIter
	// ClearTreeStore removes all rows from @tree_store
	ClearTreeStore()
	// InsertTreeStore creates a new row at @position. If parent is non-nil,
	// then the row will be made a child of @parent. Otherwise, the row will be
	// created at the toplevel. If @position is -1 or is larger than the number
	// of rows at that level, then the new row will be inserted to the end of
	// the list. @iter will be changed to point to this new row. The row will be
	// empty after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertTreeStore(parent *TreeIter, position int) TreeIter
	// InsertAfterTreeStore inserts a new row after @sibling. If @sibling is
	// nil, then the row will be prepended to @parent s children. If @parent
	// and @sibling are nil, then the row will be prepended to the toplevel. If
	// both @sibling and @parent are set, then @parent must be the parent of
	// @sibling. When @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertAfterTreeStore(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertBeforeTreeStore inserts a new row before @sibling. If @sibling is
	// nil, then the row will be appended to @parent s children. If @parent and
	// @sibling are nil, then the row will be appended to the toplevel. If both
	// @sibling and @parent are set, then @parent must be the parent of
	// @sibling. When @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertBeforeTreeStore(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertWithValuesvTreeStore: a variant of
	// gtk_tree_store_insert_with_values() which takes the columns and values as
	// two arrays, instead of varargs. This function is mainly intended for
	// language bindings.
	InsertWithValuesvTreeStore(parent *TreeIter, position int, columns []int, values []externglib.Value) TreeIter
	// IsAncestorTreeStore returns true if @iter is an ancestor of @descendant.
	// That is, @iter is the parent (or grandparent or great-grandparent) of
	// @descendant.
	IsAncestorTreeStore(iter *TreeIter, descendant *TreeIter) bool
	// IterDepthTreeStore returns the depth of @iter. This will be 0 for
	// anything on the root level, 1 for anything down a level, etc.
	IterDepthTreeStore(iter *TreeIter) int
	// IterIsValidTreeStore: WARNING: This function is slow. Only use it for
	// debugging and/or testing purposes.
	//
	// Checks if the given iter is a valid iter for this TreeStore.
	IterIsValidTreeStore(iter *TreeIter) bool
	// MoveAfterTreeStore moves @iter in @tree_store to the position after
	// @position. @iter and @position should be in the same level. Note that
	// this function only works with unsorted stores. If @position is nil, @iter
	// will be moved to the start of the level.
	MoveAfterTreeStore(iter *TreeIter, position *TreeIter)
	// MoveBeforeTreeStore moves @iter in @tree_store to the position before
	// @position. @iter and @position should be in the same level. Note that
	// this function only works with unsorted stores. If @position is nil, @iter
	// will be moved to the end of the level.
	MoveBeforeTreeStore(iter *TreeIter, position *TreeIter)
	// PrependTreeStore prepends a new row to @tree_store. If @parent is
	// non-nil, then it will prepend the new row before the first child of
	// @parent, otherwise it will prepend a row to the top level. @iter will be
	// changed to point to this new row. The row will be empty after this
	// function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	PrependTreeStore(parent *TreeIter) TreeIter
	// RemoveTreeStore removes @iter from @tree_store. After being removed,
	// @iter is set to the next valid row at that level, or invalidated if it
	// previously pointed to the last one.
	RemoveTreeStore(iter *TreeIter) bool
	// SetColumnTypesTreeStore: this function is meant primarily for #GObjects
	// that inherit from TreeStore, and should only be used when constructing a
	// new TreeStore. It will not function after a row has been added, or a
	// method on the TreeModel interface is called.
	SetColumnTypesTreeStore(types []externglib.Type)
	// SetValueTreeStore sets the data in the cell specified by @iter and
	// @column. The type of @value must be convertible to the type of the
	// column.
	SetValueTreeStore(iter *TreeIter, column int, value *externglib.Value)
	// SetValuesvTreeStore: a variant of gtk_tree_store_set_valist() which takes
	// the columns and values as two arrays, instead of varargs. This function
	// is mainly intended for language bindings or in case the number of columns
	// to change is not known until run-time.
	SetValuesvTreeStore(iter *TreeIter, columns []int, values []externglib.Value)
	// SwapTreeStore swaps @a and @b in the same level of @tree_store. Note that
	// this function only works with unsorted stores.
	SwapTreeStore(a *TreeIter, b *TreeIter)
}

// treeStore implements the TreeStore class.
type treeStore struct {
	gextras.Objector
}

// WrapTreeStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeStore(obj *externglib.Object) TreeStore {
	return treeStore{
		Objector: obj,
	}
}

func marshalTreeStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeStore(obj), nil
}

// NewTreeStoreV: non vararg creation function. Used primarily by language
// bindings.
func NewTreeStoreV(types []externglib.Type) TreeStore {
	var _arg2 *C.GType
	var _arg1 C.int
	var _cret *C.GtkTreeStore // in

	_arg1 = C.int(len(types))
	_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(types))
		for i := range types {
			out[i] = (C.GType)(types[i])
		}
	}

	_cret = C.gtk_tree_store_newv(_arg1, _arg2)

	var _treeStore TreeStore // out

	_treeStore = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeStore)

	return _treeStore
}

func (t treeStore) AppendTreeStore(parent *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

	C.gtk_tree_store_append(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

func (t treeStore) ClearTreeStore() {
	var _arg0 *C.GtkTreeStore // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))

	C.gtk_tree_store_clear(_arg0)
}

func (t treeStore) InsertTreeStore(parent *TreeIter, position int) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 C.int          // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (C.int)(position)

	C.gtk_tree_store_insert(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	return _iter
}

func (t treeStore) InsertAfterTreeStore(parent *TreeIter, sibling *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

	C.gtk_tree_store_insert_after(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	return _iter
}

func (t treeStore) InsertBeforeTreeStore(parent *TreeIter, sibling *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

	C.gtk_tree_store_insert_before(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	return _iter
}

func (t treeStore) InsertWithValuesvTreeStore(parent *TreeIter, position int, columns []int, values []externglib.Value) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 C.int          // out
	var _arg4 *C.int
	var _arg6 C.int
	var _arg5 *C.GValue
	var _arg6 C.int

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (C.int)(position)
	_arg6 = C.int(len(columns))
	_arg4 = (*C.int)(unsafe.Pointer(&columns[0]))
	_arg6 = C.int(len(values))
	_arg5 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg5))
	{
		out := unsafe.Slice(_arg5, len(values))
		for i := range values {
			out[i] = (C.GValue)(unsafe.Pointer(&values[i].GValue))
		}
	}

	C.gtk_tree_store_insert_with_valuesv(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3, _arg4, _arg5, _arg6)

	return _iter
}

func (t treeStore) IsAncestorTreeStore(iter *TreeIter, descendant *TreeIter) bool {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(descendant.Native()))

	_cret = C.gtk_tree_store_is_ancestor(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeStore) IterDepthTreeStore(iter *TreeIter) int {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.int           // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_store_iter_depth(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeStore) IterIsValidTreeStore(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_store_iter_is_valid(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeStore) MoveAfterTreeStore(iter *TreeIter, position *TreeIter) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

	C.gtk_tree_store_move_after(_arg0, _arg1, _arg2)
}

func (t treeStore) MoveBeforeTreeStore(iter *TreeIter, position *TreeIter) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

	C.gtk_tree_store_move_before(_arg0, _arg1, _arg2)
}

func (t treeStore) PrependTreeStore(parent *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

	C.gtk_tree_store_prepend(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

func (t treeStore) RemoveTreeStore(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_store_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeStore) SetColumnTypesTreeStore(types []externglib.Type) {
	var _arg0 *C.GtkTreeStore // out
	var _arg2 *C.GType
	var _arg1 C.int

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(len(types))
	_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(types))
		for i := range types {
			out[i] = (C.GType)(types[i])
		}
	}

	C.gtk_tree_store_set_column_types(_arg0, _arg1, _arg2)
}

func (t treeStore) SetValueTreeStore(iter *TreeIter, column int, value *externglib.Value) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.int           // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.int)(column)
	_arg3 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	C.gtk_tree_store_set_value(_arg0, _arg1, _arg2, _arg3)
}

func (t treeStore) SetValuesvTreeStore(iter *TreeIter, columns []int, values []externglib.Value) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.int
	var _arg4 C.int
	var _arg3 *C.GValue
	var _arg4 C.int

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg4 = C.int(len(columns))
	_arg2 = (*C.int)(unsafe.Pointer(&columns[0]))
	_arg4 = C.int(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			out[i] = (C.GValue)(unsafe.Pointer(&values[i].GValue))
		}
	}

	C.gtk_tree_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (t treeStore) SwapTreeStore(a *TreeIter, b *TreeIter) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(a.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(b.Native()))

	C.gtk_tree_store_swap(_arg0, _arg1, _arg2)
}

func (b treeStore) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (d treeStore) DragDataReceived(dest *TreePath, value *externglib.Value) bool {
	return WrapTreeDragDest(gextras.InternObject(d)).DragDataReceived(dest, value)
}

func (d treeStore) RowDropPossible(destPath *TreePath, value *externglib.Value) bool {
	return WrapTreeDragDest(gextras.InternObject(d)).RowDropPossible(destPath, value)
}

func (d treeStore) DragDataDelete(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataDelete(path)
}

func (d treeStore) DragDataGet(path *TreePath) gdk.ContentProvider {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataGet(path)
}

func (d treeStore) RowDraggable(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).RowDraggable(path)
}

func (c treeStore) NewFilter(root *TreePath) TreeModel {
	return WrapTreeModel(gextras.InternObject(c)).NewFilter(root)
}

func (t treeStore) ColumnType(index_ int) externglib.Type {
	return WrapTreeModel(gextras.InternObject(t)).ColumnType(index_)
}

func (t treeStore) Flags() TreeModelFlags {
	return WrapTreeModel(gextras.InternObject(t)).Flags()
}

func (t treeStore) Iter(path *TreePath) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).Iter(path)
}

func (t treeStore) IterFirst() (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterFirst()
}

func (t treeStore) IterFromString(pathString string) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterFromString(pathString)
}

func (t treeStore) NColumns() int {
	return WrapTreeModel(gextras.InternObject(t)).NColumns()
}

func (t treeStore) Path(iter *TreeIter) *TreePath {
	return WrapTreeModel(gextras.InternObject(t)).Path(iter)
}

func (t treeStore) StringFromIter(iter *TreeIter) string {
	return WrapTreeModel(gextras.InternObject(t)).StringFromIter(iter)
}

func (t treeStore) Value(iter *TreeIter, column int) externglib.Value {
	return WrapTreeModel(gextras.InternObject(t)).Value(iter, column)
}

func (t treeStore) IterChildren(parent *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterChildren(parent)
}

func (t treeStore) IterHasChild(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterHasChild(iter)
}

func (t treeStore) IterNChildren(iter *TreeIter) int {
	return WrapTreeModel(gextras.InternObject(t)).IterNChildren(iter)
}

func (t treeStore) IterNext(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterNext(iter)
}

func (t treeStore) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterNthChild(parent, n)
}

func (t treeStore) IterParent(child *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterParent(child)
}

func (t treeStore) IterPrevious(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterPrevious(iter)
}

func (t treeStore) RefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RefNode(iter)
}

func (t treeStore) RowChanged(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowChanged(path, iter)
}

func (t treeStore) RowDeleted(path *TreePath) {
	WrapTreeModel(gextras.InternObject(t)).RowDeleted(path)
}

func (t treeStore) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowHasChildToggled(path, iter)
}

func (t treeStore) RowInserted(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowInserted(path, iter)
}

func (t treeStore) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int) {
	WrapTreeModel(gextras.InternObject(t)).RowsReorderedWithLength(path, iter, newOrder)
}

func (t treeStore) UnrefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).UnrefNode(iter)
}

func (s treeStore) SortColumnID() (int, SortType, bool) {
	return WrapTreeSortable(gextras.InternObject(s)).SortColumnID()
}

func (s treeStore) HasDefaultSortFunc() bool {
	return WrapTreeSortable(gextras.InternObject(s)).HasDefaultSortFunc()
}

func (s treeStore) SetSortColumnID(sortColumnId int, order SortType) {
	WrapTreeSortable(gextras.InternObject(s)).SetSortColumnID(sortColumnId, order)
}

func (s treeStore) SortColumnChanged() {
	WrapTreeSortable(gextras.InternObject(s)).SortColumnChanged()
}

// TreeView: a widget for displaying both trees and lists
//
// Widget that displays any object that implements the [iface@Gtk.TreeModel]
// interface.
//
// Please refer to the tree widget conceptual overview
// (section-tree-widget.html) for an overview of all the objects and data types
// related to the tree widget and how they work together.
//
//
// Coordinate systems in GtkTreeView API
//
// Several different coordinate systems are exposed in the `GtkTreeView` API.
// These are:
//
// ! (tree-view-coordinates.png)
//
// - Widget coordinates: Coordinates relative to the widget (usually
// `widget->window`).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use [method@Gtk.TreeView.convert_widget_to_bin_window_coords]
// (and vice versa), for the latter
// [method@Gtk.TreeView.convert_bin_window_to_tree_coords] (and vice versa).
//
// `GtkTreeView` as `GtkBuildable`
//
// The `GtkTreeView` implementation of the `GtkBuildable` interface accepts
// [class@Gtk.TreeViewColumn] objects as `<child>` elements and exposes the
// internal [class@Gtk.TreeSelection] in UI definitions.
//
// An example of a UI definition fragment with `GtkTreeView`:
//
// `xml <object class="GtkTreeView" id="treeview"> <property
// name="model">liststore1</property> <child> <object class="GtkTreeViewColumn"
// id="test-column"> <property name="title">Test</property> <child> <object
// class="GtkCellRendererText" id="test-renderer"/> <attributes> <attribute
// name="text">1</attribute> </attributes> </child> </object> </child> <child
// internal-child="selection"> <object class="GtkTreeSelection" id="selection">
// <signal name="changed" handler="on_treeview_selection_changed"/> </object>
// </child> </object> `
//
//
// CSS nodes
//
// ` treeview.view  header   button    [sort-indicator]    
// button   [sort-indicator]   [rubberband]  [dndtarget] `
//
// `GtkTreeView` has a main CSS node with name `treeview` and style class
// `.view`. It has a subnode with name `header`, which is the parent for all the
// column header widgets' CSS nodes.
//
// Each column header consists of a `button`, which among other content, has a
// child with name `sort-indicator`, which carries the `.ascending` or
// `.descending` style classes when the column header should show a sort
// indicator. The CSS is expected to provide a suitable image using the
// `-gtk-icon-source` property.
//
// For rubberband selection, a subnode with name `rubberband` is used.
//
// For the drop target location during DND, a subnode with name `dndtarget` is
// used.
type TreeView interface {
	Widget
	Scrollable

	// AppendColumnTreeView appends @column to the list of columns. If
	// @tree_view has fixed_height mode enabled, then @column must have its
	// sizing property set to be GTK_TREE_VIEW_COLUMN_FIXED.
	AppendColumnTreeView(column TreeViewColumn) int
	// CollapseAllTreeView: recursively collapses all visible, expanded nodes in
	// @tree_view.
	CollapseAllTreeView()
	// CollapseRowTreeView collapses a row (hides its child rows, if they
	// exist).
	CollapseRowTreeView(path *TreePath) bool
	// ColumnsAutosizeTreeView resizes all columns to their optimal width. Only
	// works after the treeview has been realized.
	ColumnsAutosizeTreeView()
	// ConvertBinWindowToTreeCoordsTreeView converts bin_window coordinates to
	// coordinates for the tree (the full scrollable area of the tree).
	ConvertBinWindowToTreeCoordsTreeView(bx int, by int) (tx int, ty int)
	// ConvertBinWindowToWidgetCoordsTreeView converts bin_window coordinates to
	// widget relative coordinates.
	ConvertBinWindowToWidgetCoordsTreeView(bx int, by int) (wx int, wy int)
	// ConvertTreeToBinWindowCoordsTreeView converts tree coordinates
	// (coordinates in full scrollable area of the tree) to bin_window
	// coordinates.
	ConvertTreeToBinWindowCoordsTreeView(tx int, ty int) (bx int, by int)
	// ConvertTreeToWidgetCoordsTreeView converts tree coordinates (coordinates
	// in full scrollable area of the tree) to widget coordinates.
	ConvertTreeToWidgetCoordsTreeView(tx int, ty int) (wx int, wy int)
	// ConvertWidgetToBinWindowCoordsTreeView converts widget coordinates to
	// coordinates for the bin_window.
	ConvertWidgetToBinWindowCoordsTreeView(wx int, wy int) (bx int, by int)
	// ConvertWidgetToTreeCoordsTreeView converts widget coordinates to
	// coordinates for the tree (the full scrollable area of the tree).
	ConvertWidgetToTreeCoordsTreeView(wx int, wy int) (tx int, ty int)
	// CreateRowDragIconTreeView creates a #cairo_surface_t representation of
	// the row at @path. This image is used for a drag icon.
	CreateRowDragIconTreeView(path *TreePath) gdk.Paintable
	// EnableModelDragDestTreeView turns @tree_view into a drop destination for
	// automatic DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragDestTreeView(formats *gdk.ContentFormats, actions gdk.DragAction)
	// EnableModelDragSourceTreeView turns @tree_view into a drag source for
	// automatic DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragSourceTreeView(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)
	// ExpandAllTreeView: recursively expands all nodes in the @tree_view.
	ExpandAllTreeView()
	// ExpandRowTreeView opens the row so its children are visible.
	ExpandRowTreeView(path *TreePath, openAll bool) bool
	// ExpandToPathTreeView expands the row at @path. This will also expand all
	// parent rows of @path as necessary.
	ExpandToPathTreeView(path *TreePath)
	// ActivateOnSingleClick gets the setting set by
	// gtk_tree_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// BackgroundArea fills the bounding rectangle in bin_window coordinates for
	// the cell at the row specified by @path and the column specified by
	// @column. If @path is nil, or points to a node not found in the tree, the
	// @y and @height fields of the rectangle will be filled with 0. If @column
	// is nil, the @x and @width fields will be filled with 0. The returned
	// rectangle is equivalent to the @background_area passed to
	// gtk_cell_renderer_render(). These background areas tile to cover the
	// entire bin window. Contrast with the @cell_area, returned by
	// gtk_tree_view_get_cell_area(), which returns only the cell itself,
	// excluding surrounding borders and the tree expander area.
	BackgroundArea(path *TreePath, column TreeViewColumn) gdk.Rectangle
	// CellArea fills the bounding rectangle in bin_window coordinates for the
	// cell at the row specified by @path and the column specified by @column.
	// If @path is nil, or points to a path not currently displayed, the @y and
	// @height fields of the rectangle will be filled with 0. If @column is nil,
	// the @x and @width fields will be filled with 0. The sum of all cell rects
	// does not cover the entire tree; there are extra pixels in between rows,
	// for example. The returned rectangle is equivalent to the @cell_area
	// passed to gtk_cell_renderer_render(). This function is only valid if
	// @tree_view is realized.
	CellArea(path *TreePath, column TreeViewColumn) gdk.Rectangle
	// Column gets the TreeViewColumn at the given position in the #tree_view.
	Column(n int) TreeViewColumn
	// Cursor fills in @path and @focus_column with the current path and focus
	// column. If the cursor isnt currently set, then *@path will be nil. If no
	// column currently has focus, then *@focus_column will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free() when you
	// are done with it.
	Cursor() (*TreePath, TreeViewColumn)
	// DestRowAtPos determines the destination row for a given position. @drag_x
	// and @drag_y are expected to be in widget coordinates. This function is
	// only meaningful if @tree_view is realized. Therefore this function will
	// always return false if @tree_view is not realized or does not have a
	// model.
	DestRowAtPos(dragX int, dragY int) (*TreePath, TreeViewDropPosition, bool)
	// DragDestRow gets information about the row that is highlighted for
	// feedback.
	DragDestRow() (*TreePath, TreeViewDropPosition)
	// EnableSearch returns whether or not the tree allows to start interactive
	// searching by typing in text.
	EnableSearch() bool
	// EnableTreeLines returns whether or not tree lines are drawn in
	// @tree_view.
	EnableTreeLines() bool
	// ExpanderColumn returns the column that is the current expander column, or
	// nil if none has been set. This column has the expander arrow drawn next
	// to it.
	ExpanderColumn() TreeViewColumn
	// FixedHeightMode returns whether fixed height mode is turned on for
	// @tree_view.
	FixedHeightMode() bool
	// GridLines returns which grid lines are enabled in @tree_view.
	GridLines() TreeViewGridLines
	// HeadersClickable returns whether all header columns are clickable.
	HeadersClickable() bool
	// HeadersVisible returns true if the headers on the @tree_view are visible.
	HeadersVisible() bool
	// HoverExpand returns whether hover expansion mode is turned on for
	// @tree_view.
	HoverExpand() bool
	// HoverSelection returns whether hover selection mode is turned on for
	// @tree_view.
	HoverSelection() bool
	// LevelIndentation returns the amount, in pixels, of extra indentation for
	// child levels in @tree_view.
	LevelIndentation() int
	// Model returns the model the TreeView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// NColumns queries the number of columns in the given @tree_view.
	NColumns() uint
	// PathAtPos finds the path at the point (@x, @y), relative to bin_window
	// coordinates. That is, @x and @y are relative to an events coordinates.
	// Widget-relative coordinates must be converted using
	// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
	// things like popup menus. If @path is non-nil, then it will be filled with
	// the TreePath at that point. This path should be freed with
	// gtk_tree_path_free(). If @column is non-nil, then it will be filled with
	// the column at that point. @cell_x and @cell_y return the coordinates
	// relative to the cell background (i.e. the @background_area passed to
	// gtk_cell_renderer_render()). This function is only meaningful if
	// @tree_view is realized. Therefore this function will always return false
	// if @tree_view is not realized or does not have a model.
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// Reorderable retrieves whether the user can reorder the tree via
	// drag-and-drop. See gtk_tree_view_set_reorderable().
	Reorderable() bool
	// RubberBanding returns whether rubber banding is turned on for @tree_view.
	// If the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow
	// the user to select multiple rows by dragging the mouse.
	RubberBanding() bool
	// SearchColumn gets the column searched on by the interactive search code.
	SearchColumn() int
	// SearchEntry returns the Entry which is currently in use as interactive
	// search entry for @tree_view. In case the built-in entry is being used,
	// nil will be returned.
	SearchEntry() Editable
	// Selection gets the TreeSelection associated with @tree_view.
	Selection() TreeSelection
	// ShowExpanders returns whether or not expanders are drawn in @tree_view.
	ShowExpanders() bool
	// TooltipColumn returns the column of @tree_views model which is being
	// used for displaying tooltips on @tree_views rows.
	TooltipColumn() int
	// TooltipContext: this function is supposed to be used in a
	// Widget::query-tooltip signal handler for TreeView. The @x, @y and
	// @keyboard_tip values which are received in the signal handler, should be
	// passed to this function without modification.
	//
	// The return value indicates whether there is a tree view row at the given
	// coordinates (true) or not (false) for mouse tooltips. For keyboard
	// tooltips the row returned will be the cursor row. When true, then any of
	// @model, @path and @iter which have been provided will be set to point to
	// that row and the corresponding model. @x and @y will always be converted
	// to be relative to @tree_views bin_window if @keyboard_tooltip is false.
	TooltipContext(x int, y int, keyboardTip bool) (TreeModel, *TreePath, TreeIter, bool)
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// The paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// VisibleRect fills @visible_rect with the currently-visible region of the
	// buffer, in tree coordinates. Convert to bin_window coordinates with
	// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start
	// at 0,0 for row 0 of the tree, and cover the entire scrollable area of the
	// tree.
	VisibleRect() gdk.Rectangle
	// InsertColumnTreeView: this inserts the @column into the @tree_view at
	// @position. If @position is -1, then the column is inserted at the end. If
	// @tree_view has fixed_height mode enabled, then @column must have its
	// sizing property set to be GTK_TREE_VIEW_COLUMN_FIXED.
	InsertColumnTreeView(column TreeViewColumn, position int) int
	// IsBlankAtPosTreeView: determine whether the point (@x, @y) in @tree_view
	// is blank, that is no cell content nor an expander arrow is drawn at the
	// location. If so, the location can be considered as the background. You
	// might wish to take special action on clicks on the background, such as
	// clearing a current selection, having a custom context menu or starting
	// rubber banding.
	//
	// The @x and @y coordinate that are provided must be relative to bin_window
	// coordinates. Widget-relative coordinates must be converted using
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	//
	// The @path, @column, @cell_x and @cell_y arguments will be filled in
	// likewise as for gtk_tree_view_get_path_at_pos(). Please see
	// gtk_tree_view_get_path_at_pos() for more information.
	IsBlankAtPosTreeView(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// IsRubberBandingActiveTreeView returns whether a rubber banding operation
	// is currently being done in @tree_view.
	IsRubberBandingActiveTreeView() bool
	// MoveColumnAfterTreeView moves @column to be after to @base_column. If
	// @base_column is nil, then @column is placed in the first position.
	MoveColumnAfterTreeView(column TreeViewColumn, baseColumn TreeViewColumn)
	// RemoveColumnTreeView removes @column from @tree_view.
	RemoveColumnTreeView(column TreeViewColumn) int
	// RowActivatedTreeView activates the cell determined by @path and @column.
	RowActivatedTreeView(path *TreePath, column TreeViewColumn)
	// RowExpandedTreeView returns true if the node pointed to by @path is
	// expanded in @tree_view.
	RowExpandedTreeView(path *TreePath) bool
	// ScrollToCellTreeView moves the alignments of @tree_view to the position
	// specified by @column and @path. If @column is nil, then no horizontal
	// scrolling occurs. Likewise, if @path is nil no vertical scrolling occurs.
	// At a minimum, one of @column or @path need to be non-nil. @row_align
	// determines where the row is placed, and @col_align determines where
	// @column is placed. Both are expected to be between 0.0 and 1.0. 0.0 means
	// left/top alignment, 1.0 means right/bottom alignment, 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the cell onto the screen.
	// This means that the cell will be scrolled to the edge closest to its
	// current position. If the cell is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @tree_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToCellTreeView(path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32)
	// ScrollToPointTreeView scrolls the tree view such that the top-left corner
	// of the visible area is @tree_x, @tree_y, where @tree_x and @tree_y are
	// specified in tree coordinates. The @tree_view must be realized before
	// this function is called. If it isn't, you probably want to be using
	// gtk_tree_view_scroll_to_cell().
	//
	// If either @tree_x or @tree_y are -1, then that direction isnt scrolled.
	ScrollToPointTreeView(treeX int, treeY int)
	// SetActivateOnSingleClickTreeView: cause the TreeView::row-activated
	// signal to be emitted on a single click instead of a double click.
	SetActivateOnSingleClickTreeView(single bool)
	// SetCursorTreeView sets the current keyboard focus to be at @path, and
	// selects it. This is useful when you want to focus the users attention on
	// a particular row. If @focus_column is not nil, then focus is given to the
	// column specified by it. Additionally, if @focus_column is specified, and
	// @start_editing is true, then editing should be started in the specified
	// cell. This function is often followed by @gtk_widget_grab_focus
	// (@tree_view) in order to give keyboard focus to the widget. Please note
	// that editing can only happen when the widget is realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursorTreeView(path *TreePath, focusColumn TreeViewColumn, startEditing bool)
	// SetCursorOnCellTreeView sets the current keyboard focus to be at @path,
	// and selects it. This is useful when you want to focus the users
	// attention on a particular row. If @focus_column is not nil, then focus is
	// given to the column specified by it. If @focus_column and @focus_cell are
	// not nil, and @focus_column contains 2 or more editable or activatable
	// cells, then focus is given to the cell specified by @focus_cell.
	// Additionally, if @focus_column is specified, and @start_editing is true,
	// then editing should be started in the specified cell. This function is
	// often followed by @gtk_widget_grab_focus (@tree_view) in order to give
	// keyboard focus to the widget. Please note that editing can only happen
	// when the widget is realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursorOnCellTreeView(path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool)
	// SetDragDestRowTreeView sets the row that is highlighted for feedback. If
	// @path is nil, an existing highlight is removed.
	SetDragDestRowTreeView(path *TreePath, pos TreeViewDropPosition)
	// SetEnableSearchTreeView: if @enable_search is set, then the user can type
	// in text to search through the tree interactively (this is sometimes
	// called "typeahead find").
	//
	// Note that even if this is false, the user can still initiate a search
	// using the start-interactive-search key binding.
	SetEnableSearchTreeView(enableSearch bool)
	// SetEnableTreeLinesTreeView sets whether to draw lines interconnecting the
	// expanders in @tree_view. This does not have any visible effects for
	// lists.
	SetEnableTreeLinesTreeView(enabled bool)
	// SetExpanderColumnTreeView sets the column to draw the expander arrow at.
	// It must be in @tree_view. If @column is nil, then the expander arrow is
	// always at the first visible column.
	//
	// If you do not want expander arrow to appear in your tree, set the
	// expander column to a hidden column.
	SetExpanderColumnTreeView(column TreeViewColumn)
	// SetFixedHeightModeTreeView enables or disables the fixed height mode of
	// @tree_view. Fixed height mode speeds up TreeView by assuming that all
	// rows have the same height. Only enable this option if all rows are the
	// same height and all columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
	SetFixedHeightModeTreeView(enable bool)
	// SetGridLinesTreeView sets which grid lines to draw in @tree_view.
	SetGridLinesTreeView(gridLines TreeViewGridLines)
	// SetHeadersClickableTreeView: allow the column title buttons to be
	// clicked.
	SetHeadersClickableTreeView(setting bool)
	// SetHeadersVisibleTreeView sets the visibility state of the headers.
	SetHeadersVisibleTreeView(headersVisible bool)
	// SetHoverExpandTreeView enables or disables the hover expansion mode of
	// @tree_view. Hover expansion makes rows expand or collapse if the pointer
	// moves over them.
	SetHoverExpandTreeView(expand bool)
	// SetHoverSelectionTreeView enables or disables the hover selection mode of
	// @tree_view. Hover selection makes the selected row follow the pointer.
	// Currently, this works only for the selection modes GTK_SELECTION_SINGLE
	// and GTK_SELECTION_BROWSE.
	SetHoverSelectionTreeView(hover bool)
	// SetLevelIndentationTreeView sets the amount of extra indentation for
	// child levels to use in @tree_view in addition to the default indentation.
	// The value should be specified in pixels, a value of 0 disables this
	// feature and in this case only the default indentation will be used. This
	// does not have any visible effects for lists.
	SetLevelIndentationTreeView(indentation int)
	// SetModelTreeView sets the model for a TreeView. If the @tree_view already
	// has a model set, it will remove it before setting the new model. If
	// @model is nil, then it will unset the old model.
	SetModelTreeView(model TreeModel)
	// SetReorderableTreeView: this function is a convenience function to allow
	// you to reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the models TreeModel::row-inserted and TreeModel::row-deleted signals.
	// The reordering is implemented by setting up the tree view as a drag
	// source and destination. Therefore, drag and drop can not be used in a
	// reorderable view for any other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderableTreeView(reorderable bool)
	// SetRubberBandingTreeView enables or disables rubber banding in
	// @tree_view. If the selection mode is K_SELECTION_MULTIPLE, rubber banding
	// will allow the user to select multiple rows by dragging the mouse.
	SetRubberBandingTreeView(enable bool)
	// SetSearchColumnTreeView sets @column as the column where the interactive
	// search code should search in for the current model.
	//
	// If the search column is set, users can use the start-interactive-search
	// key binding to bring up search popup. The enable-search property controls
	// whether simply typing text will also start an interactive search.
	//
	// Note that @column refers to a column of the current model. The search
	// column is reset to -1 when the model is changed.
	SetSearchColumnTreeView(column int)
	// SetSearchEntryTreeView sets the entry which the interactive search code
	// will use for this @tree_view. This is useful when you want to provide a
	// search entry in our interface at all time at a fixed position. Passing
	// nil for @entry will make the interactive search code use the built-in
	// popup entry again.
	SetSearchEntryTreeView(entry Editable)
	// SetShowExpandersTreeView sets whether to draw and enable expanders and
	// indent child rows in @tree_view. When disabled there will be no expanders
	// visible in trees and there will be no way to expand and collapse rows by
	// default. Also note that hiding the expanders will disable the default
	// indentation. You can set a custom indentation in this case using
	// gtk_tree_view_set_level_indentation(). This does not have any visible
	// effects for lists.
	SetShowExpandersTreeView(enabled bool)
	// SetTooltipCellTreeView sets the tip area of @tooltip to the area @path,
	// @column and @cell have in common. For example if @path is nil and @column
	// is set, the tip area will be set to the full area covered by @column. See
	// also gtk_tooltip_set_tip_area().
	//
	// Note that if @path is not specified and @cell is set and part of a column
	// containing the expander, the tooltip might not show and hide at the
	// correct position. In such cases @path must be set to the current node
	// under the mouse cursor for this function to operate correctly.
	//
	// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCellTreeView(tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer)
	// SetTooltipColumnTreeView: if you only plan to have simple (text-only)
	// tooltips on full rows, you can use this function to have TreeView handle
	// these automatically for you. @column should be set to the column in
	// @tree_views model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @tree_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumnTreeView(column int)
	// SetTooltipRowTreeView sets the tip area of @tooltip to be the area
	// covered by the row at @path. See also gtk_tree_view_set_tooltip_column()
	// for a simpler alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipRowTreeView(tooltip Tooltip, path *TreePath)
	// UnsetRowsDragDestTreeView undoes the effect of
	// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragDestTreeView()
	// UnsetRowsDragSourceTreeView undoes the effect of
	// gtk_tree_view_enable_model_drag_source(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragSourceTreeView()
}

// treeView implements the TreeView class.
type treeView struct {
	Widget
}

// WrapTreeView wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeView(obj *externglib.Object) TreeView {
	return treeView{
		Widget: WrapWidget(obj),
	}
}

func marshalTreeView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeView(obj), nil
}

// NewTreeView creates a new TreeView widget.
func NewTreeView() TreeView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_tree_view_new()

	var _treeView TreeView // out

	_treeView = WrapTreeView(externglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// NewTreeViewWithModel creates a new TreeView widget with the model initialized
// to @model.
func NewTreeViewWithModel(model TreeModel) TreeView {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_tree_view_new_with_model(_arg1)

	var _treeView TreeView // out

	_treeView = WrapTreeView(externglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

func (t treeView) AppendColumnTreeView(column TreeViewColumn) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	_cret = C.gtk_tree_view_append_column(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeView) CollapseAllTreeView() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_collapse_all(_arg0)
}

func (t treeView) CollapseRowTreeView(path *TreePath) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_view_collapse_row(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) ColumnsAutosizeTreeView() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_columns_autosize(_arg0)
}

func (t treeView) ConvertBinWindowToTreeCoordsTreeView(bx int, by int) (tx int, ty int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(bx)
	_arg2 = (C.int)(by)

	C.gtk_tree_view_convert_bin_window_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _tx int // out
	var _ty int // out

	_tx = (int)(_arg3)
	_ty = (int)(_arg4)

	return _tx, _ty
}

func (t treeView) ConvertBinWindowToWidgetCoordsTreeView(bx int, by int) (wx int, wy int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(bx)
	_arg2 = (C.int)(by)

	C.gtk_tree_view_convert_bin_window_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _wx int // out
	var _wy int // out

	_wx = (int)(_arg3)
	_wy = (int)(_arg4)

	return _wx, _wy
}

func (t treeView) ConvertTreeToBinWindowCoordsTreeView(tx int, ty int) (bx int, by int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(tx)
	_arg2 = (C.int)(ty)

	C.gtk_tree_view_convert_tree_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _bx int // out
	var _by int // out

	_bx = (int)(_arg3)
	_by = (int)(_arg4)

	return _bx, _by
}

func (t treeView) ConvertTreeToWidgetCoordsTreeView(tx int, ty int) (wx int, wy int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(tx)
	_arg2 = (C.int)(ty)

	C.gtk_tree_view_convert_tree_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _wx int // out
	var _wy int // out

	_wx = (int)(_arg3)
	_wy = (int)(_arg4)

	return _wx, _wy
}

func (t treeView) ConvertWidgetToBinWindowCoordsTreeView(wx int, wy int) (bx int, by int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(wx)
	_arg2 = (C.int)(wy)

	C.gtk_tree_view_convert_widget_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _bx int // out
	var _by int // out

	_bx = (int)(_arg3)
	_by = (int)(_arg4)

	return _bx, _by
}

func (t treeView) ConvertWidgetToTreeCoordsTreeView(wx int, wy int) (tx int, ty int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(wx)
	_arg2 = (C.int)(wy)

	C.gtk_tree_view_convert_widget_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _tx int // out
	var _ty int // out

	_tx = (int)(_arg3)
	_ty = (int)(_arg4)

	return _tx, _ty
}

func (t treeView) CreateRowDragIconTreeView(path *TreePath) gdk.Paintable {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 *C.GtkTreePath  // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_view_create_row_drag_icon(_arg0, _arg1)

	var _paintable gdk.Paintable // out

	_paintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.Paintable)

	return _paintable
}

func (t treeView) EnableModelDragDestTreeView(formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GdkContentFormats // out
	var _arg2 C.GdkDragAction      // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	_arg2 = (C.GdkDragAction)(actions)

	C.gtk_tree_view_enable_model_drag_dest(_arg0, _arg1, _arg2)
}

func (t treeView) EnableModelDragSourceTreeView(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.GdkModifierType    // out
	var _arg2 *C.GdkContentFormats // out
	var _arg3 C.GdkDragAction      // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GdkModifierType)(startButtonMask)
	_arg2 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	_arg3 = (C.GdkDragAction)(actions)

	C.gtk_tree_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3)
}

func (t treeView) ExpandAllTreeView() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_expand_all(_arg0)
}

func (t treeView) ExpandRowTreeView(path *TreePath, openAll bool) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _arg2 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	if openAll {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_tree_view_expand_row(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) ExpandToPathTreeView(path *TreePath) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_view_expand_to_path(_arg0, _arg1)
}

func (t treeView) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_activate_on_single_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) BackgroundArea(path *TreePath, column TreeViewColumn) gdk.Rectangle {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _rect gdk.Rectangle

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_get_background_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	return _rect
}

func (t treeView) CellArea(path *TreePath, column TreeViewColumn) gdk.Rectangle {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _rect gdk.Rectangle

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_get_cell_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	return _rect
}

func (t treeView) Column(n int) TreeViewColumn {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.int                // out
	var _cret *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(n)

	_cret = C.gtk_tree_view_get_column(_arg0, _arg1)

	var _treeViewColumn TreeViewColumn // out

	_treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeViewColumn)

	return _treeViewColumn
}

func (t treeView) Cursor() (*TreePath, TreeViewColumn) {
	var _arg0 *C.GtkTreeView // out
	var _path *TreePath
	var _arg2 *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_cursor(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)

	var _focusColumn TreeViewColumn // out

	_focusColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(TreeViewColumn)

	return _path, _focusColumn
}

func (t treeView) DestRowAtPos(dragX int, dragY int) (*TreePath, TreeViewDropPosition, bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _path *TreePath
	var _arg4 C.GtkTreeViewDropPosition // in
	var _cret C.gboolean                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(dragX)
	_arg2 = (C.int)(dragY)

	_cret = C.gtk_tree_view_get_dest_row_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)

	var _pos TreeViewDropPosition // out
	var _ok bool                  // out

	_pos = TreeViewDropPosition(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _path, _pos, _ok
}

func (t treeView) DragDestRow() (*TreePath, TreeViewDropPosition) {
	var _arg0 *C.GtkTreeView // out
	var _path *TreePath
	var _arg2 C.GtkTreeViewDropPosition // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_drag_dest_row(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)

	var _pos TreeViewDropPosition // out

	_pos = TreeViewDropPosition(_arg2)

	return _path, _pos
}

func (t treeView) EnableSearch() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_enable_search(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) EnableTreeLines() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_enable_tree_lines(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) ExpanderColumn() TreeViewColumn {
	var _arg0 *C.GtkTreeView       // out
	var _cret *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_expander_column(_arg0)

	var _treeViewColumn TreeViewColumn // out

	_treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeViewColumn)

	return _treeViewColumn
}

func (t treeView) FixedHeightMode() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_fixed_height_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) GridLines() TreeViewGridLines {
	var _arg0 *C.GtkTreeView         // out
	var _cret C.GtkTreeViewGridLines // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_grid_lines(_arg0)

	var _treeViewGridLines TreeViewGridLines // out

	_treeViewGridLines = TreeViewGridLines(_cret)

	return _treeViewGridLines
}

func (t treeView) HeadersClickable() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_headers_clickable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) HeadersVisible() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_headers_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) HoverExpand() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_hover_expand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) HoverSelection() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_hover_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) LevelIndentation() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_level_indentation(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeView) Model() TreeModel {
	var _arg0 *C.GtkTreeView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

func (t treeView) NColumns() uint {
	var _arg0 *C.GtkTreeView // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_n_columns(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (t treeView) PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _path *TreePath
	var _arg4 *C.GtkTreeViewColumn // in
	var _arg5 C.int                // in
	var _arg6 C.int                // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)

	_cret = C.gtk_tree_view_get_path_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4, &_arg5, &_arg6)

	var _column TreeViewColumn // out
	var _cellX int             // out
	var _cellY int             // out
	var _ok bool               // out

	_column = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeViewColumn)
	_cellX = (int)(_arg5)
	_cellY = (int)(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _path, _column, _cellX, _cellY, _ok
}

func (t treeView) Reorderable() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_reorderable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) RubberBanding() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_rubber_banding(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) SearchColumn() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_search_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeView) SearchEntry() Editable {
	var _arg0 *C.GtkTreeView // out
	var _cret *C.GtkEditable // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_search_entry(_arg0)

	var _editable Editable // out

	_editable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Editable)

	return _editable
}

func (t treeView) Selection() TreeSelection {
	var _arg0 *C.GtkTreeView      // out
	var _cret *C.GtkTreeSelection // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_selection(_arg0)

	var _treeSelection TreeSelection // out

	_treeSelection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeSelection)

	return _treeSelection
}

func (t treeView) ShowExpanders() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_show_expanders(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) TooltipColumn() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_tooltip_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeView) TooltipContext(x int, y int, keyboardTip bool) (TreeModel, *TreePath, TreeIter, bool) {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.gboolean      // out
	var _arg4 *C.GtkTreeModel // in
	var _path *TreePath
	var _iter TreeIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)
	if keyboardTip {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_tree_view_get_tooltip_context(_arg0, _arg1, _arg2, _arg3, &_arg4, (**C.GtkTreePath)(unsafe.Pointer(&_path)), (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _model TreeModel // out

	var _ok bool // out

	_model = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeModel)

	if _cret != 0 {
		_ok = true
	}

	return _model, _path, _iter, _ok
}

func (t treeView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var _arg0 *C.GtkTreeView // out
	var _startPath *TreePath
	var _endPath *TreePath
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_visible_range(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_startPath)), (**C.GtkTreePath)(unsafe.Pointer(&_endPath)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

func (t treeView) VisibleRect() gdk.Rectangle {
	var _arg0 *C.GtkTreeView // out
	var _visibleRect gdk.Rectangle

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_visible_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_visibleRect)))

	return _visibleRect
}

func (t treeView) InsertColumnTreeView(column TreeViewColumn, position int) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _arg2 C.int                // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	_arg2 = (C.int)(position)

	_cret = C.gtk_tree_view_insert_column(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeView) IsBlankAtPosTreeView(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _path *TreePath
	var _arg4 *C.GtkTreeViewColumn // in
	var _arg5 C.int                // in
	var _arg6 C.int                // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)

	_cret = C.gtk_tree_view_is_blank_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4, &_arg5, &_arg6)

	var _column TreeViewColumn // out
	var _cellX int             // out
	var _cellY int             // out
	var _ok bool               // out

	_column = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeViewColumn)
	_cellX = (int)(_arg5)
	_cellY = (int)(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _path, _column, _cellX, _cellY, _ok
}

func (t treeView) IsRubberBandingActiveTreeView() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_is_rubber_banding_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) MoveColumnAfterTreeView(column TreeViewColumn, baseColumn TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _arg2 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(baseColumn.Native()))

	C.gtk_tree_view_move_column_after(_arg0, _arg1, _arg2)
}

func (t treeView) RemoveColumnTreeView(column TreeViewColumn) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	_cret = C.gtk_tree_view_remove_column(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeView) RowActivatedTreeView(path *TreePath, column TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_row_activated(_arg0, _arg1, _arg2)
}

func (t treeView) RowExpandedTreeView(path *TreePath) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_view_row_expanded(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeView) ScrollToCellTreeView(path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.gboolean           // out
	var _arg4 C.float              // out
	var _arg5 C.float              // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = (C.float)(rowAlign)
	_arg5 = (C.float)(colAlign)

	C.gtk_tree_view_scroll_to_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (t treeView) ScrollToPointTreeView(treeX int, treeY int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(treeX)
	_arg2 = (C.int)(treeY)

	C.gtk_tree_view_scroll_to_point(_arg0, _arg1, _arg2)
}

func (t treeView) SetActivateOnSingleClickTreeView(single bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_activate_on_single_click(_arg0, _arg1)
}

func (t treeView) SetCursorTreeView(path *TreePath, focusColumn TreeViewColumn, startEditing bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.gboolean           // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
	if startEditing {
		_arg3 = C.TRUE
	}

	C.gtk_tree_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
}

func (t treeView) SetCursorOnCellTreeView(path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 *C.GtkCellRenderer   // out
	var _arg4 C.gboolean           // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(focusCell.Native()))
	if startEditing {
		_arg4 = C.TRUE
	}

	C.gtk_tree_view_set_cursor_on_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (t treeView) SetDragDestRowTreeView(path *TreePath, pos TreeViewDropPosition) {
	var _arg0 *C.GtkTreeView            // out
	var _arg1 *C.GtkTreePath            // out
	var _arg2 C.GtkTreeViewDropPosition // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (C.GtkTreeViewDropPosition)(pos)

	C.gtk_tree_view_set_drag_dest_row(_arg0, _arg1, _arg2)
}

func (t treeView) SetEnableSearchTreeView(enableSearch bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enableSearch {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_enable_search(_arg0, _arg1)
}

func (t treeView) SetEnableTreeLinesTreeView(enabled bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_enable_tree_lines(_arg0, _arg1)
}

func (t treeView) SetExpanderColumnTreeView(column TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_set_expander_column(_arg0, _arg1)
}

func (t treeView) SetFixedHeightModeTreeView(enable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_fixed_height_mode(_arg0, _arg1)
}

func (t treeView) SetGridLinesTreeView(gridLines TreeViewGridLines) {
	var _arg0 *C.GtkTreeView         // out
	var _arg1 C.GtkTreeViewGridLines // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTreeViewGridLines)(gridLines)

	C.gtk_tree_view_set_grid_lines(_arg0, _arg1)
}

func (t treeView) SetHeadersClickableTreeView(setting bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_headers_clickable(_arg0, _arg1)
}

func (t treeView) SetHeadersVisibleTreeView(headersVisible bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if headersVisible {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_headers_visible(_arg0, _arg1)
}

func (t treeView) SetHoverExpandTreeView(expand bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_hover_expand(_arg0, _arg1)
}

func (t treeView) SetHoverSelectionTreeView(hover bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if hover {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_hover_selection(_arg0, _arg1)
}

func (t treeView) SetLevelIndentationTreeView(indentation int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(indentation)

	C.gtk_tree_view_set_level_indentation(_arg0, _arg1)
}

func (t treeView) SetModelTreeView(model TreeModel) {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_tree_view_set_model(_arg0, _arg1)
}

func (t treeView) SetReorderableTreeView(reorderable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_reorderable(_arg0, _arg1)
}

func (t treeView) SetRubberBandingTreeView(enable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_rubber_banding(_arg0, _arg1)
}

func (t treeView) SetSearchColumnTreeView(column int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(column)

	C.gtk_tree_view_set_search_column(_arg0, _arg1)
}

func (t treeView) SetSearchEntryTreeView(entry Editable) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkEditable // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkEditable)(unsafe.Pointer(entry.Native()))

	C.gtk_tree_view_set_search_entry(_arg0, _arg1)
}

func (t treeView) SetShowExpandersTreeView(enabled bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_show_expanders(_arg0, _arg1)
}

func (t treeView) SetTooltipCellTreeView(tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTooltip        // out
	var _arg2 *C.GtkTreePath       // out
	var _arg3 *C.GtkTreeViewColumn // out
	var _arg4 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg3 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	_arg4 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_tree_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (t treeView) SetTooltipColumnTreeView(column int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(column)

	C.gtk_tree_view_set_tooltip_column(_arg0, _arg1)
}

func (t treeView) SetTooltipRowTreeView(tooltip Tooltip, path *TreePath) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTooltip  // out
	var _arg2 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_view_set_tooltip_row(_arg0, _arg1, _arg2)
}

func (t treeView) UnsetRowsDragDestTreeView() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_unset_rows_drag_dest(_arg0)
}

func (t treeView) UnsetRowsDragSourceTreeView() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_unset_rows_drag_source(_arg0)
}

func (s treeView) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s treeView) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s treeView) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s treeView) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s treeView) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s treeView) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s treeView) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b treeView) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s treeView) Border() (Border, bool) {
	return WrapScrollable(gextras.InternObject(s)).Border()
}

func (s treeView) HAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).HAdjustment()
}

func (s treeView) HScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).HScrollPolicy()
}

func (s treeView) VAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).VAdjustment()
}

func (s treeView) VScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).VScrollPolicy()
}

func (s treeView) SetHAdjustment(hadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetHAdjustment(hadjustment)
}

func (s treeView) SetHScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetHScrollPolicy(policy)
}

func (s treeView) SetVAdjustment(vadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetVAdjustment(vadjustment)
}

func (s treeView) SetVScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetVScrollPolicy(policy)
}

// TreeViewColumn: a visible column in a GtkTreeView widget
//
// The GtkTreeViewColumn object represents a visible column in a TreeView
// widget. It allows to set properties of the column header, and functions as a
// holding pen for the cell renderers which determine how the data in the column
// is displayed.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together, and to the TreeView documentation for specifics about the
// CSS node structure for treeviews and their headers.
type TreeViewColumn interface {
	Buildable
	CellLayout

	// AddAttributeTreeViewColumn adds an attribute mapping to the list in
	// @tree_column. The @column is the column of the model to get a value from,
	// and the @attribute is the parameter on @cell_renderer to be set from the
	// value. So for example if column 2 of the model contains strings, you
	// could have the text attribute of a CellRendererText get its values from
	// column 2.
	AddAttributeTreeViewColumn(cellRenderer CellRenderer, attribute string, column int)
	// CellGetPositionTreeViewColumn obtains the horizontal position and size of
	// a cell in a column. If the cell is not found in the column, @start_pos
	// and @width are not changed and false is returned.
	CellGetPositionTreeViewColumn(cellRenderer CellRenderer) (xOffset int, width int, ok bool)
	// CellGetSizeTreeViewColumn obtains the width and height needed to render
	// the column. This is used primarily by the TreeView.
	CellGetSizeTreeViewColumn() (xOffset int, yOffset int, width int, height int)
	// CellIsVisibleTreeViewColumn returns true if any of the cells packed into
	// the @tree_column are visible. For this to be meaningful, you must first
	// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
	CellIsVisibleTreeViewColumn() bool
	// CellSetCellDataTreeViewColumn sets the cell renderer based on the
	// @tree_model and @iter. That is, for every attribute mapping in
	// @tree_column, it will get a value from the set column on the @iter, and
	// use that value to set the attribute on the cell renderer. This is used
	// primarily by the TreeView.
	CellSetCellDataTreeViewColumn(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// ClearTreeViewColumn unsets all the mappings on all renderers on the
	// @tree_column.
	ClearTreeViewColumn()
	// ClearAttributesTreeViewColumn clears all existing attributes previously
	// set with gtk_tree_view_column_set_attributes().
	ClearAttributesTreeViewColumn(cellRenderer CellRenderer)
	// ClickedTreeViewColumn emits the clicked signal on the column. This
	// function will only work if @tree_column is clickable.
	ClickedTreeViewColumn()
	// FocusCellTreeViewColumn sets the current keyboard focus to be at @cell,
	// if the column contains 2 or more editable and activatable cells.
	FocusCellTreeViewColumn(cell CellRenderer)
	// Alignment returns the current x alignment of @tree_column. This value can
	// range between 0.0 and 1.0.
	Alignment() float32
	// Button returns the button used in the treeview column header
	Button() Widget
	// Clickable returns true if the user can click on the header for the
	// column.
	Clickable() bool
	// Expand returns true if the column expands to fill available space.
	Expand() bool
	// FixedWidth gets the fixed width of the column. This may not be the actual
	// displayed width of the column; for that, use
	// gtk_tree_view_column_get_width().
	FixedWidth() int
	// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
	// if no maximum width is set.
	MaxWidth() int
	// MinWidth returns the minimum width in pixels of the @tree_column, or -1
	// if no minimum width is set.
	MinWidth() int
	// Reorderable returns true if the @tree_column can be reordered by the
	// user.
	Reorderable() bool
	// Resizable returns true if the @tree_column can be resized by the end
	// user.
	Resizable() bool
	// Sizing returns the current type of @tree_column.
	Sizing() TreeViewColumnSizing
	// SortColumnID gets the logical @sort_column_id that the model sorts on
	// when this column is selected for sorting. See
	// gtk_tree_view_column_set_sort_column_id().
	SortColumnID() int
	// SortIndicator gets the value set by
	// gtk_tree_view_column_set_sort_indicator().
	SortIndicator() bool
	// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
	SortOrder() SortType
	// Spacing returns the spacing of @tree_column.
	Spacing() int
	// Title returns the title of the widget.
	Title() string
	// TreeView returns the TreeView wherein @tree_column has been inserted. If
	// @column is currently not inserted in any tree view, nil is returned.
	TreeView() Widget
	// Visible returns true if @tree_column is visible.
	Visible() bool
	// Widget returns the Widget in the button on the column header. If a custom
	// widget has not been set then nil is returned.
	Widget() Widget
	// Width returns the current size of @tree_column in pixels.
	Width() int
	// XOffset returns the current X offset of @tree_column in pixels.
	XOffset() int
	// PackEndTreeViewColumn adds the @cell to end of the column. If @expand is
	// false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	PackEndTreeViewColumn(cell CellRenderer, expand bool)
	// PackStartTreeViewColumn packs the @cell into the beginning of the column.
	// If @expand is false, then the @cell is allocated no more space than it
	// needs. Any unused space is divided evenly between cells for which @expand
	// is true.
	PackStartTreeViewColumn(cell CellRenderer, expand bool)
	// QueueResizeTreeViewColumn flags the column, and the cell renderers added
	// to this column, to have their sizes renegotiated.
	QueueResizeTreeViewColumn()
	// SetAlignmentTreeViewColumn sets the alignment of the title or custom
	// widget inside the column header. The alignment determines its location
	// inside the button -- 0.0 for left, 0.5 for center, 1.0 for right.
	SetAlignmentTreeViewColumn(xalign float32)
	// SetClickableTreeViewColumn sets the header to be active if @clickable is
	// true. When the header is active, then it can take keyboard focus, and can
	// be clicked.
	SetClickableTreeViewColumn(clickable bool)
	// SetExpandTreeViewColumn sets the column to take available extra space.
	// This space is shared equally amongst all columns that have the expand set
	// to true. If no column has this option set, then the last column gets all
	// extra space. By default, every column is created with this false.
	//
	// Along with fixed-width, the expand property changes when the column
	// is resized by the user.
	SetExpandTreeViewColumn(expand bool)
	// SetFixedWidthTreeViewColumn: if @fixed_width is not -1, sets the fixed
	// width of @tree_column; otherwise unsets it. The effective value of
	// @fixed_width is clamped between the minimum and maximum width of the
	// column; however, the value stored in the fixed-width property is not
	// clamped. If the column sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or
	// K_TREE_VIEW_COLUMN_AUTOSIZE, setting a fixed width overrides the
	// automatically calculated width. Note that @fixed_width is only a hint to
	// GTK; the width actually allocated to the column may be greater or less
	// than requested.
	//
	// Along with expand, the fixed-width property changes when the column
	// is resized by the user.
	SetFixedWidthTreeViewColumn(fixedWidth int)
	// SetMaxWidthTreeViewColumn sets the maximum width of the @tree_column. If
	// @max_width is -1, then the maximum width is unset. Note, the column can
	// actually be wider than max width if its the last column in a view. In
	// this case, the column expands to fill any extra space.
	SetMaxWidthTreeViewColumn(maxWidth int)
	// SetMinWidthTreeViewColumn sets the minimum width of the @tree_column. If
	// @min_width is -1, then the minimum width is unset.
	SetMinWidthTreeViewColumn(minWidth int)
	// SetReorderableTreeViewColumn: if @reorderable is true, then the column
	// can be reordered by the end user dragging the header.
	SetReorderableTreeViewColumn(reorderable bool)
	// SetResizableTreeViewColumn: if @resizable is true, then the user can
	// explicitly resize the column by grabbing the outer edge of the column
	// button. If resizable is true and sizing mode of the column is
	// K_TREE_VIEW_COLUMN_AUTOSIZE, then the sizing mode is changed to
	// K_TREE_VIEW_COLUMN_GROW_ONLY.
	SetResizableTreeViewColumn(resizable bool)
	// SetSizingTreeViewColumn sets the growth behavior of @tree_column to
	// @type.
	SetSizingTreeViewColumn(typ TreeViewColumnSizing)
	// SetSortColumnIDTreeViewColumn sets the logical @sort_column_id that this
	// column sorts on when this column is selected for sorting. Doing so makes
	// the column header clickable.
	SetSortColumnIDTreeViewColumn(sortColumnId int)
	// SetSortIndicatorTreeViewColumn: call this function with a @setting of
	// true to display an arrow in the header button indicating the column is
	// sorted. Call gtk_tree_view_column_set_sort_order() to change the
	// direction of the arrow.
	SetSortIndicatorTreeViewColumn(setting bool)
	// SetSortOrderTreeViewColumn changes the appearance of the sort indicator.
	//
	// This does not actually sort the model. Use
	// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
	// support. This function is primarily for custom sorting behavior, and
	// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
	// to do that. For custom models, the mechanism will vary.
	//
	// The sort indicator changes direction to indicate normal sort or reverse
	// sort. Note that you must have the sort indicator enabled to see anything
	// when calling this function; see
	// gtk_tree_view_column_set_sort_indicator().
	SetSortOrderTreeViewColumn(order SortType)
	// SetSpacingTreeViewColumn sets the spacing field of @tree_column, which is
	// the number of pixels to place between cell renderers packed into it.
	SetSpacingTreeViewColumn(spacing int)
	// SetTitleTreeViewColumn sets the title of the @tree_column. If a custom
	// widget has been set, then this value is ignored.
	SetTitleTreeViewColumn(title string)
	// SetVisibleTreeViewColumn sets the visibility of @tree_column.
	SetVisibleTreeViewColumn(visible bool)
	// SetWidgetTreeViewColumn sets the widget in the header to be @widget. If
	// widget is nil, then the header button is set with a Label set to the
	// title of @tree_column.
	SetWidgetTreeViewColumn(widget Widget)
}

// treeViewColumn implements the TreeViewColumn class.
type treeViewColumn struct {
	gextras.Objector
}

// WrapTreeViewColumn wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeViewColumn(obj *externglib.Object) TreeViewColumn {
	return treeViewColumn{
		Objector: obj,
	}
}

func marshalTreeViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeViewColumn(obj), nil
}

// NewTreeViewColumn creates a new TreeViewColumn.
func NewTreeViewColumn() TreeViewColumn {
	var _cret *C.GtkTreeViewColumn // in

	_cret = C.gtk_tree_view_column_new()

	var _treeViewColumn TreeViewColumn // out

	_treeViewColumn = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(_cret)))

	return _treeViewColumn
}

// NewTreeViewColumnWithArea creates a new TreeViewColumn using @area to render
// its cells.
func NewTreeViewColumnWithArea(area CellArea) TreeViewColumn {
	var _arg1 *C.GtkCellArea       // out
	var _cret *C.GtkTreeViewColumn // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	_cret = C.gtk_tree_view_column_new_with_area(_arg1)

	var _treeViewColumn TreeViewColumn // out

	_treeViewColumn = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(_cret)))

	return _treeViewColumn
}

func (t treeViewColumn) AddAttributeTreeViewColumn(cellRenderer CellRenderer, attribute string, column int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 *C.char              // out
	var _arg3 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))
	_arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.int)(column)

	C.gtk_tree_view_column_add_attribute(_arg0, _arg1, _arg2, _arg3)
}

func (t treeViewColumn) CellGetPositionTreeViewColumn(cellRenderer CellRenderer) (xOffset int, width int, ok bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 C.int                // in
	var _arg3 C.int                // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

	_cret = C.gtk_tree_view_column_cell_get_position(_arg0, _arg1, &_arg2, &_arg3)

	var _xOffset int // out
	var _width int   // out
	var _ok bool     // out

	_xOffset = (int)(_arg2)
	_width = (int)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _xOffset, _width, _ok
}

func (t treeViewColumn) CellGetSizeTreeViewColumn() (xOffset int, yOffset int, width int, height int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // in
	var _arg2 C.int                // in
	var _arg3 C.int                // in
	var _arg4 C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_cell_get_size(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _xOffset int // out
	var _yOffset int // out
	var _width int   // out
	var _height int  // out

	_xOffset = (int)(_arg1)
	_yOffset = (int)(_arg2)
	_width = (int)(_arg3)
	_height = (int)(_arg4)

	return _xOffset, _yOffset, _width, _height
}

func (t treeViewColumn) CellIsVisibleTreeViewColumn() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_cell_is_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeViewColumn) CellSetCellDataTreeViewColumn(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkTreeModel      // out
	var _arg2 *C.GtkTreeIter       // out
	var _arg3 C.gboolean           // out
	var _arg4 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	if isExpander {
		_arg3 = C.TRUE
	}
	if isExpanded {
		_arg4 = C.TRUE
	}

	C.gtk_tree_view_column_cell_set_cell_data(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (t treeViewColumn) ClearTreeViewColumn() {
	var _arg0 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_clear(_arg0)
}

func (t treeViewColumn) ClearAttributesTreeViewColumn(cellRenderer CellRenderer) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

	C.gtk_tree_view_column_clear_attributes(_arg0, _arg1)
}

func (t treeViewColumn) ClickedTreeViewColumn() {
	var _arg0 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_clicked(_arg0)
}

func (t treeViewColumn) FocusCellTreeViewColumn(cell CellRenderer) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_tree_view_column_focus_cell(_arg0, _arg1)
}

func (t treeViewColumn) Alignment() float32 {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.float              // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_alignment(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (t treeViewColumn) Button() Widget {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_button(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (t treeViewColumn) Clickable() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_clickable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeViewColumn) Expand() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_expand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeViewColumn) FixedWidth() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_fixed_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeViewColumn) MaxWidth() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_max_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeViewColumn) MinWidth() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_min_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeViewColumn) Reorderable() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_reorderable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeViewColumn) Resizable() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_resizable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeViewColumn) Sizing() TreeViewColumnSizing {
	var _arg0 *C.GtkTreeViewColumn      // out
	var _cret C.GtkTreeViewColumnSizing // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_sizing(_arg0)

	var _treeViewColumnSizing TreeViewColumnSizing // out

	_treeViewColumnSizing = TreeViewColumnSizing(_cret)

	return _treeViewColumnSizing
}

func (t treeViewColumn) SortColumnID() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_sort_column_id(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeViewColumn) SortIndicator() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_sort_indicator(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeViewColumn) SortOrder() SortType {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.GtkSortType        // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_sort_order(_arg0)

	var _sortType SortType // out

	_sortType = SortType(_cret)

	return _sortType
}

func (t treeViewColumn) Spacing() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeViewColumn) Title() string {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (t treeViewColumn) TreeView() Widget {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_tree_view(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (t treeViewColumn) Visible() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t treeViewColumn) Widget() Widget {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (t treeViewColumn) Width() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeViewColumn) XOffset() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_x_offset(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (t treeViewColumn) PackEndTreeViewColumn(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_tree_view_column_pack_end(_arg0, _arg1, _arg2)
}

func (t treeViewColumn) PackStartTreeViewColumn(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_tree_view_column_pack_start(_arg0, _arg1, _arg2)
}

func (t treeViewColumn) QueueResizeTreeViewColumn() {
	var _arg0 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_queue_resize(_arg0)
}

func (t treeViewColumn) SetAlignmentTreeViewColumn(xalign float32) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.float              // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.float)(xalign)

	C.gtk_tree_view_column_set_alignment(_arg0, _arg1)
}

func (t treeViewColumn) SetClickableTreeViewColumn(clickable bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if clickable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_clickable(_arg0, _arg1)
}

func (t treeViewColumn) SetExpandTreeViewColumn(expand bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_expand(_arg0, _arg1)
}

func (t treeViewColumn) SetFixedWidthTreeViewColumn(fixedWidth int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width(_arg0, _arg1)
}

func (t treeViewColumn) SetMaxWidthTreeViewColumn(maxWidth int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(maxWidth)

	C.gtk_tree_view_column_set_max_width(_arg0, _arg1)
}

func (t treeViewColumn) SetMinWidthTreeViewColumn(minWidth int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(minWidth)

	C.gtk_tree_view_column_set_min_width(_arg0, _arg1)
}

func (t treeViewColumn) SetReorderableTreeViewColumn(reorderable bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_reorderable(_arg0, _arg1)
}

func (t treeViewColumn) SetResizableTreeViewColumn(resizable bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_resizable(_arg0, _arg1)
}

func (t treeViewColumn) SetSizingTreeViewColumn(typ TreeViewColumnSizing) {
	var _arg0 *C.GtkTreeViewColumn      // out
	var _arg1 C.GtkTreeViewColumnSizing // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTreeViewColumnSizing)(typ)

	C.gtk_tree_view_column_set_sizing(_arg0, _arg1)
}

func (t treeViewColumn) SetSortColumnIDTreeViewColumn(sortColumnId int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(sortColumnId)

	C.gtk_tree_view_column_set_sort_column_id(_arg0, _arg1)
}

func (t treeViewColumn) SetSortIndicatorTreeViewColumn(setting bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_sort_indicator(_arg0, _arg1)
}

func (t treeViewColumn) SetSortOrderTreeViewColumn(order SortType) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.GtkSortType        // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkSortType)(order)

	C.gtk_tree_view_column_set_sort_order(_arg0, _arg1)
}

func (t treeViewColumn) SetSpacingTreeViewColumn(spacing int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.int)(spacing)

	C.gtk_tree_view_column_set_spacing(_arg0, _arg1)
}

func (t treeViewColumn) SetTitleTreeViewColumn(title string) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tree_view_column_set_title(_arg0, _arg1)
}

func (t treeViewColumn) SetVisibleTreeViewColumn(visible bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_visible(_arg0, _arg1)
}

func (t treeViewColumn) SetWidgetTreeViewColumn(widget Widget) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_tree_view_column_set_widget(_arg0, _arg1)
}

func (b treeViewColumn) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (c treeViewColumn) AddAttribute(cell CellRenderer, attribute string, column int) {
	WrapCellLayout(gextras.InternObject(c)).AddAttribute(cell, attribute, column)
}

func (c treeViewColumn) Clear() {
	WrapCellLayout(gextras.InternObject(c)).Clear()
}

func (c treeViewColumn) ClearAttributes(cell CellRenderer) {
	WrapCellLayout(gextras.InternObject(c)).ClearAttributes(cell)
}

func (c treeViewColumn) Area() CellArea {
	return WrapCellLayout(gextras.InternObject(c)).Area()
}

func (c treeViewColumn) PackEnd(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackEnd(cell, expand)
}

func (c treeViewColumn) PackStart(cell CellRenderer, expand bool) {
	WrapCellLayout(gextras.InternObject(c)).PackStart(cell, expand)
}

func (c treeViewColumn) Reorder(cell CellRenderer, position int) {
	WrapCellLayout(gextras.InternObject(c)).Reorder(cell, position)
}

// Video: `GtkVideo` is a widget to show a `GtkMediaStream` with media controls.
//
// !An example GtkVideo (video.png)
//
// The controls are available separately as [class@Gtk.MediaControls]. If you
// just want to display a video without controls, you can treat it like any
// other paintable and for example put it into a [class@Gtk.Picture].
//
// `GtkVideo` aims to cover use cases such as previews, embedded animations,
// etc. It supports autoplay, looping, and simple media controls. It does not
// have support for video overlays, multichannel audio, device selection, or
// input. If you are writing a full-fledged video player, you may want to use
// the [class@Gdk.Paintable] API and a media framework such as Gstreamer
// directly.
type Video interface {
	Widget

	// Autoplay returns true if videos have been set to loop.
	Autoplay() bool
	// File gets the file played by @self or nil if not playing back a file.
	File() gio.File
	// Loop returns true if videos have been set to loop.
	Loop() bool
	// MediaStream gets the media stream managed by @self or nil if none.
	MediaStream() MediaStream
	// SetAutoplayVideo sets whether @self automatically starts playback when it
	// becomes visible or when a new file gets loaded.
	SetAutoplayVideo(autoplay bool)
	// SetFileVideo makes @self play the given @file.
	SetFileVideo(file gio.File)
	// SetFilenameVideo makes @self play the given @filename.
	//
	// This is a utility function that calls gtk_video_set_file(),
	SetFilenameVideo(filename string)
	// SetLoopVideo sets whether new files loaded by @self should be set to
	// loop.
	SetLoopVideo(loop bool)
	// SetMediaStreamVideo sets the media stream to be played back.
	//
	// @self will take full control of managing the media stream. If you want to
	// manage a media stream yourself, consider using a [class@Gtk.Picture] for
	// display.
	//
	// If you want to display a file, consider using [method@Gtk.Video.set_file]
	// instead.
	SetMediaStreamVideo(stream MediaStream)
	// SetResourceVideo makes @self play the resource at the given
	// @resource_path.
	//
	// This is a utility function that calls [method@Gtk.Video.set_file].
	SetResourceVideo(resourcePath string)
}

// video implements the Video class.
type video struct {
	Widget
}

// WrapVideo wraps a GObject to the right type. It is
// primarily used internally.
func WrapVideo(obj *externglib.Object) Video {
	return video{
		Widget: WrapWidget(obj),
	}
}

func marshalVideo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVideo(obj), nil
}

// NewVideo creates a new empty `GtkVideo`.
func NewVideo() Video {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_video_new()

	var _video Video // out

	_video = WrapVideo(externglib.Take(unsafe.Pointer(_cret)))

	return _video
}

// NewVideoForFile creates a `GtkVideo` to play back the given @file.
func NewVideoForFile(file gio.File) Video {
	var _arg1 *C.GFile     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	_cret = C.gtk_video_new_for_file(_arg1)

	var _video Video // out

	_video = WrapVideo(externglib.Take(unsafe.Pointer(_cret)))

	return _video
}

// NewVideoForFilename creates a `GtkVideo` to play back the given @filename.
//
// This is a utility function that calls [ctor@Gtk.Video.new_for_file], See that
// function for details.
func NewVideoForFilename(filename string) Video {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_video_new_for_filename(_arg1)

	var _video Video // out

	_video = WrapVideo(externglib.Take(unsafe.Pointer(_cret)))

	return _video
}

// NewVideoForMediaStream creates a `GtkVideo` to play back the given @stream.
func NewVideoForMediaStream(stream MediaStream) Video {
	var _arg1 *C.GtkMediaStream // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(stream.Native()))

	_cret = C.gtk_video_new_for_media_stream(_arg1)

	var _video Video // out

	_video = WrapVideo(externglib.Take(unsafe.Pointer(_cret)))

	return _video
}

// NewVideoForResource creates a `GtkVideo` to play back the resource at the
// given @resource_path.
//
// This is a utility function that calls [ctor@Gtk.Video.new_for_file].
func NewVideoForResource(resourcePath string) Video {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_video_new_for_resource(_arg1)

	var _video Video // out

	_video = WrapVideo(externglib.Take(unsafe.Pointer(_cret)))

	return _video
}

func (s video) Autoplay() bool {
	var _arg0 *C.GtkVideo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_video_get_autoplay(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s video) File() gio.File {
	var _arg0 *C.GtkVideo // out
	var _cret *C.GFile    // in

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_video_get_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

func (s video) Loop() bool {
	var _arg0 *C.GtkVideo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_video_get_loop(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s video) MediaStream() MediaStream {
	var _arg0 *C.GtkVideo       // out
	var _cret *C.GtkMediaStream // in

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_video_get_media_stream(_arg0)

	var _mediaStream MediaStream // out

	_mediaStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(MediaStream)

	return _mediaStream
}

func (s video) SetAutoplayVideo(autoplay bool) {
	var _arg0 *C.GtkVideo // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
	if autoplay {
		_arg1 = C.TRUE
	}

	C.gtk_video_set_autoplay(_arg0, _arg1)
}

func (s video) SetFileVideo(file gio.File) {
	var _arg0 *C.GtkVideo // out
	var _arg1 *C.GFile    // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_video_set_file(_arg0, _arg1)
}

func (s video) SetFilenameVideo(filename string) {
	var _arg0 *C.GtkVideo // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_video_set_filename(_arg0, _arg1)
}

func (s video) SetLoopVideo(loop bool) {
	var _arg0 *C.GtkVideo // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
	if loop {
		_arg1 = C.TRUE
	}

	C.gtk_video_set_loop(_arg0, _arg1)
}

func (s video) SetMediaStreamVideo(stream MediaStream) {
	var _arg0 *C.GtkVideo       // out
	var _arg1 *C.GtkMediaStream // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(stream.Native()))

	C.gtk_video_set_media_stream(_arg0, _arg1)
}

func (s video) SetResourceVideo(resourcePath string) {
	var _arg0 *C.GtkVideo // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_video_set_resource(_arg0, _arg1)
}

func (s video) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s video) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s video) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s video) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s video) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s video) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s video) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b video) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Viewport: `GtkViewport` implements scrollability for widgets that lack their
// own scrolling capabilities.
//
// Use `GtkViewport` to scroll child widgets such as `GtkGrid`, `GtkBox`, and so
// on.
//
// The `GtkViewport` will start scrolling content only if allocated less than
// the child widgets minimum size in a given orientation.
//
//
// CSS nodes
//
// `GtkViewport` has a single CSS node with name `viewport`.
//
//
// Accessibility
//
// `GtkViewport` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Viewport interface {
	Widget
	Scrollable

	// Child gets the child widget of @viewport.
	Child() Widget
	// ScrollToFocus gets whether the viewport is scrolling to keep the focused
	// child in view.
	ScrollToFocus() bool
	// SetChildViewport sets the child widget of @viewport.
	SetChildViewport(child Widget)
	// SetScrollToFocusViewport sets whether the viewport should automatically
	// scroll to keep the focused child in view.
	SetScrollToFocusViewport(scrollToFocus bool)
}

// viewport implements the Viewport class.
type viewport struct {
	Widget
}

// WrapViewport wraps a GObject to the right type. It is
// primarily used internally.
func WrapViewport(obj *externglib.Object) Viewport {
	return viewport{
		Widget: WrapWidget(obj),
	}
}

func marshalViewport(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapViewport(obj), nil
}

// NewViewport creates a new `GtkViewport`.
//
// The new viewport uses the given adjustments, or default adjustments if none
// are given.
func NewViewport(hadjustment Adjustment, vadjustment Adjustment) Viewport {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))
	_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	_cret = C.gtk_viewport_new(_arg1, _arg2)

	var _viewport Viewport // out

	_viewport = WrapViewport(externglib.Take(unsafe.Pointer(_cret)))

	return _viewport
}

func (v viewport) Child() Widget {
	var _arg0 *C.GtkViewport // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	_cret = C.gtk_viewport_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (v viewport) ScrollToFocus() bool {
	var _arg0 *C.GtkViewport // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	_cret = C.gtk_viewport_get_scroll_to_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (v viewport) SetChildViewport(child Widget) {
	var _arg0 *C.GtkViewport // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_viewport_set_child(_arg0, _arg1)
}

func (v viewport) SetScrollToFocusViewport(scrollToFocus bool) {
	var _arg0 *C.GtkViewport // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
	if scrollToFocus {
		_arg1 = C.TRUE
	}

	C.gtk_viewport_set_scroll_to_focus(_arg0, _arg1)
}

func (s viewport) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s viewport) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s viewport) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s viewport) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s viewport) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s viewport) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s viewport) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b viewport) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s viewport) Border() (Border, bool) {
	return WrapScrollable(gextras.InternObject(s)).Border()
}

func (s viewport) HAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).HAdjustment()
}

func (s viewport) HScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).HScrollPolicy()
}

func (s viewport) VAdjustment() Adjustment {
	return WrapScrollable(gextras.InternObject(s)).VAdjustment()
}

func (s viewport) VScrollPolicy() ScrollablePolicy {
	return WrapScrollable(gextras.InternObject(s)).VScrollPolicy()
}

func (s viewport) SetHAdjustment(hadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetHAdjustment(hadjustment)
}

func (s viewport) SetHScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetHScrollPolicy(policy)
}

func (s viewport) SetVAdjustment(vadjustment Adjustment) {
	WrapScrollable(gextras.InternObject(s)).SetVAdjustment(vadjustment)
}

func (s viewport) SetVScrollPolicy(policy ScrollablePolicy) {
	WrapScrollable(gextras.InternObject(s)).SetVScrollPolicy(policy)
}

// VolumeButton: `GtkVolumeButton` is a `GtkScaleButton` subclass tailored for
// volume control.
//
// !An example GtkVolumeButton (volumebutton.png)
type VolumeButton interface {
	ScaleButton
}

// volumeButton implements the VolumeButton class.
type volumeButton struct {
	ScaleButton
}

// WrapVolumeButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapVolumeButton(obj *externglib.Object) VolumeButton {
	return volumeButton{
		ScaleButton: WrapScaleButton(obj),
	}
}

func marshalVolumeButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVolumeButton(obj), nil
}

// NewVolumeButton creates a `GtkVolumeButton`.
//
// The button has a range between 0.0 and 1.0, with a stepping of 0.02. Volume
// values can be obtained and modified using the functions from
// [class@Gtk.ScaleButton].
func NewVolumeButton() VolumeButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_volume_button_new()

	var _volumeButton VolumeButton // out

	_volumeButton = WrapVolumeButton(externglib.Take(unsafe.Pointer(_cret)))

	return _volumeButton
}

func (s volumeButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s volumeButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s volumeButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s volumeButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s volumeButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s volumeButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s volumeButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b volumeButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o volumeButton) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o volumeButton) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}

// Widget: the base class for all widgets.
//
// `GtkWidget` is the base class all widgets in GTK derive from. It manages the
// widget lifecycle, layout, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK by way of two
// virtual methods:
//
// - [vfunc@Gtk.Widget.get_request_mode] - [vfunc@Gtk.Widget.measure]
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct `GtkWidget` subclass that supports height-for-width
// or width-for-height geometry management for itself or its child widgets, the
// [vfunc@Gtk.Widget.get_request_mode] virtual function must be implemented as
// well and return the widget's preferred request mode. The default
// implementation of this virtual function returns
// GTK_SIZE_REQUEST_CONSTANT_SIZE, which means that the widget will only ever
// get -1 passed as the for_size value to its [vfunc@Gtk.Widget.measure]
// implementation.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the
// [enum@Gtk.SizeRequestMode] chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode:
//
// First, the default minimum and natural width for each widget in the interface
// will be computed using [id@gtk_widget_measure] with an orientation of
// GTK_ORIENTATION_HORIZONTAL and a for_size of -1. Because the preferred widths
// for each widget depend on the preferred widths of their children, this
// information propagates up the hierarchy, and finally a minimum and natural
// width is determined for the entire toplevel. Next, the toplevel will use the
// minimum width to query for the minimum height contextual to that width using
// [id@gtk_widget_measure] with an orientation of GTK_ORIENTATION_VERTICAL and a
// for_size of the just computed width. This will also be a highly recursive
// operation. The minimum height for the minimum width is normally used to set
// the minimum size constraint on the toplevel.
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with [method@Gtk.Window.set_default_size]). During the recursive
// allocation process its important to note that request cycles will be
// recursively executed while widgets allocate their children. Each widget, once
// allocated a size, will go on to first share the space in one orientation
// among its children and then request each child's height for its target
// allocated width or its width for allocated height, depending. In this way a
// `GtkWidget` will typically be requested its size a number of times before
// actually being allocated a size. The size a widget is finally allocated can
// of course differ from the size it has requested. For this reason, `GtkWidget`
// caches a small number of results to avoid re-querying for the same sizes in
// one allocation cycle.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both `GtkSizeRequestMode`s even if
// the widget in question only trades sizes in a single orientation.
//
// For instance, a [class@Gtk.Label] that does height-for-width word wrapping
// will not expect to have [vfunc@Gtk.Widget.measure] with an orientation of
// GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will always
// be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
// `c static void foo_widget_measure (GtkWidget *widget, GtkOrientation
// orientation, int for_size, int *minimum_size, int *natural_size, int
// *minimum_baseline, int *natural_baseline) { if (orientation ==
// GTK_ORIENTATION_HORIZONTAL) { // Calculate minimum and natural width } else
// // VERTICAL { if (i_am_in_height_for_width_mode) { int min_width, dummy;
//
//          // First, get the minimum width of our widget
//          GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
//                                                  &min_width, &dummy, &dummy, &dummy);
//
//          // Now use the minimum width to retrieve the minimum and natural height to display
//          // that width.
//          GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
//                                                  minimum_size, natural_size, &dummy, &dummy);
//        }
//      else
//        {
//          // ... some widgets do both.
//        }
//    }
//
// } `
//
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also compute
// width. Or when deciding how to use an allocation, the widget may need to know
// its natural size. In these cases, the widget should be careful to call its
// virtual methods directly, like in the code example above.
//
// It will not work to use the wrapper function [method@Gtk.Widget.measure]
// inside your own [vfunc@Gtk.Widget.size_allocate] implementation. These return
// a request adjusted by [class@Gtk.SizeGroup], the widget's align and expand
// flags, as well as its CSS style.
//
// If a widget used the wrappers inside its virtual method implementations, then
// the adjustments (such as widget margins) would be applied twice. GTK
// therefore does not allow this and will warn if you try to do it.
//
// Of course if you are getting the size request for another widget, such as a
// child widget, you must use [id@gtk_widget_measure]; otherwise, you would not
// properly consider widget margins, [class@Gtk.SizeGroup], and so forth.
//
// GTK also supports baseline vertical alignment of widgets. This means that
// widgets are positioned such that the typographical baseline of widgets in the
// same row are aligned. This happens if a widget supports baselines, has a
// vertical alignment of GTK_ALIGN_BASELINE, and is inside a widget that
// supports baselines and has a natural row that it aligns to the baseline, or
// a baseline assigned to it by the grandparent.
//
// Baseline alignment support for a widget is also done by the
// [vfunc@Gtk.Widget.measure] virtual function. It allows you to report both a
// minimum and natural size.
//
// If a widget ends up baseline aligned it will be allocated all the space in
// the parent as if it was GTK_ALIGN_FILL, but the selected baseline can be
// found via [id@gtk_widget_get_allocated_baseline]. If the baseline has a value
// other than -1 you need to align the widget such that the baseline appears at
// the position.
//
//
// GtkWidget as GtkBuildable
//
// The `GtkWidget` implementation of the `GtkBuildable` interface supports
// various custom elements to specify additional aspects of widgets that are not
// directly expressed as properties.
//
// If the widget uses a [class@Gtk.LayoutManager], `GtkWidget` supports a custom
// `<layout>` element, used to define layout properties:
//
// `xml <object class="GtkGrid" id="my_grid"> <child> <object class="GtkLabel"
// id="label1"> <property name="label">Description</property> <layout> <property
// name="column">0</property> <property name="row">0</property> <property
// name="row-span">1</property> <property name="column-span">1</property>
// </layout> </object> </child> <child> <object class="GtkEntry"
// id="description_entry"> <layout> <property name="column">1</property>
// <property name="row">0</property> <property name="row-span">1</property>
// <property name="column-span">1</property> </layout> </object> </child>
// </object> `
//
// `GtkWidget` allows style information such as style classes to be associated
// with widgets, using the custom `<style>` element:
//
// `xml <object class="GtkButton" id="button1"> <style> <class
// name="my-special-button-class"/> <class name="dark-button"/> </style>
// </object> `
//
// `GtkWidget` allows defining accessibility information, such as properties,
// relations, and states, using the custom `<accessibility>` element:
//
// `xml <object class="GtkButton" id="button1"> <accessibility> <property
// name="label">Download</property> <relation
// name="labelled-by">label1</relation> </accessibility> </object> `
//
//
// Building composite widgets from template XML
//
// `GtkWidget `exposes some facilities to automate the procedure of creating
// composite widgets using "templates".
//
// To create composite widgets with `GtkBuilder` XML, one must associate the
// interface description with the widget class at class initialization time
// using [method@Gtk.WidgetClass.set_template].
//
// The interface description semantics expected in composite template
// descriptions is slightly different from regular [class@Gtk.Builder] XML.
//
// Unlike regular interface descriptions, [method@Gtk.WidgetClass.set_template]
// will expect a `<template>` tag as a direct child of the toplevel
// `<interface>` tag. The `<template>` tag must specify the class attribute
// which must be the type name of the widget. Optionally, the parent attribute
// may be specified to specify the direct parent type of the widget type, this
// is ignored by `GtkBuilder` but required for UI design tools like Glade
// (https://glade.gnome.org/) to introspect what kind of properties and internal
// children exist for a given type when the actual type does not exist.
//
// The XML which is contained inside the `<template>` tag behaves as if it were
// added to the `<object>` tag defining the widget itself. You may set
// properties on a widget by inserting `<property>` tags into the `<template>`
// tag, and also add `<child>` tags to add children and extend a widget in the
// normal way you would with `<object>` tags.
//
// Additionally, `<object>` tags can also be added before and after the initial
// `<template>` tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// `<template>` tag.
//
// An example of a template definition:
//
// `xml <interface> <template class="FooWidget" parent="GtkBox"> <property
// name="orientation">horizontal</property> <property
// name="spacing">4</property> <child> <object class="GtkButton"
// id="hello_button"> <property name="label">Hello World</property> <signal
// name="clicked" handler="hello_button_clicked" object="FooWidget"
// swapped="yes"/> </object> </child> <child> <object class="GtkButton"
// id="goodbye_button"> <property name="label">Goodbye World</property>
// </object> </child> </template> </interface> `
//
// Typically, you'll place the template fragment into a file that is bundled
// with your project, using `GResource`. In order to load the template, you need
// to call [method@Gtk.WidgetClass.set_template_from_resource] from the class
// initialization of your `GtkWidget` type:
//
// `c static void foo_widget_class_init (FooWidgetClass *klass) { // ...
//
//    gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                 "/com/example/ui/foowidget.ui");
//
// } `
//
// You will also need to call [method@Gtk.Widget.init_template] from the
// instance initialization function:
//
// `c static void foo_widget_init (FooWidget *self) { // ...
// gtk_widget_init_template (GTK_WIDGET (self)); } `
//
// You can access widgets defined in the template using the
// [id@gtk_widget_get_template_child] function, but you will typically declare a
// pointer in the instance private data structure of your type using the same
// name as the widget in the template definition, and call
// [method@Gtk.WidgetClass.bind_template_child_full] (or one of its wrapper
// macros [func@Gtk.widget_class_bind_template_child] and
// [func@Gtk.widget_class_bind_template_child_private]) with that name, e.g.
//
// `c typedef struct { GtkWidget *hello_button; GtkWidget *goodbye_button; }
// FooWidgetPrivate;
//
// G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
//
// static void foo_widget_class_init (FooWidgetClass *klass) { // ...
// gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
// "/com/example/ui/foowidget.ui"); gtk_widget_class_bind_template_child_private
// (GTK_WIDGET_CLASS (klass), FooWidget, hello_button);
// gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
// FooWidget, goodbye_button); }
//
// static void foo_widget_init (FooWidget *widget) {
//
// } `
//
// You can also use [method@Gtk.WidgetClass.bind_template_callback_full] (or is
// wrapper macro [func@Gtk.widget_class_bind_template_callback]) to connect a
// signal callback defined in the template with a function visible in the scope
// of the class, e.g.
//
// `c // the signal handler has the instance and user data swapped // because
// of the swapped="yes" attribute in the template XML static void
// hello_button_clicked (FooWidget *self, GtkButton *button) { g_print ("Hello,
// world!\n"); }
//
// static void foo_widget_class_init (FooWidgetClass *klass) { // ...
// gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
// "/com/example/ui/foowidget.ui"); gtk_widget_class_bind_template_callback
// (GTK_WIDGET_CLASS (klass), hello_button_clicked); } `
type Widget interface {
	Accessible
	Buildable
	ConstraintTarget

	// ActionSetEnabledWidget: enable or disable an action installed with
	// gtk_widget_class_install_action().
	ActionSetEnabledWidget(actionName string, enabled bool)
	// ActivateWidget: for widgets that can be activated (buttons, menu items,
	// etc.) this function activates them.
	//
	// The activation will emit the signal set using
	// gtk_widget_class_set_activate_signal() during class initialization.
	//
	// Activation is what happens when you press Enter on a widget during key
	// navigation.
	//
	// If you wish to handle the activation keybinding yourself, it is
	// recommended to use gtk_widget_class_add_shortcut() with an action created
	// with gtk_signal_action_new().
	//
	// If @widget isn't activatable, the function returns false.
	ActivateWidget() bool
	// ActivateActionVariantWidget looks up the action in the action groups
	// associated with @widget and its ancestors, and activates it.
	//
	// If the action is in an action group added with
	// [method@Gtk.Widget.insert_action_group], the @name is expected to be
	// prefixed with the prefix that was used when the group was inserted.
	//
	// The arguments must match the actions expected parameter type, as returned
	// by `g_action_get_parameter_type()`.
	ActivateActionVariantWidget(name string, args *glib.Variant) bool
	// ActivateDefaultWidget activates the `default.activate` action from
	// @widget.
	ActivateDefaultWidget()
	// AddControllerWidget adds @controller to @widget so that it will receive
	// events.
	//
	// You will usually want to call this function right after creating any kind
	// of [class@Gtk.EventController].
	AddControllerWidget(controller EventController)
	// AddCSSClassWidget adds a style class to @widget.
	//
	// After calling this function, the widgets style will match for @css_class,
	// according to CSS matching rules.
	//
	// Use [method@Gtk.Widget.remove_css_class] to remove the style again.
	AddCSSClassWidget(cssClass string)
	// AddMnemonicLabelWidget adds a widget to the list of mnemonic labels for
	// this widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. Note the list of mnemonic
	// labels for the widget is cleared when the widget is destroyed, so the
	// caller must make sure to update its internal state at this point as well,
	// by using a connection to the [signal@Gtk.Widget::destroy] signal or a
	// weak notifier.
	AddMnemonicLabelWidget(label Widget)
	// AllocateWidget: this function is only used by `GtkWidget` subclasses, to
	// assign a size, position and (optionally) baseline to their child widgets.
	//
	// In this function, the allocation and baseline may be adjusted. The given
	// allocation will be forced to be bigger than the widget's minimum size, as
	// well as at least 00 in size.
	//
	// For a version that does not take a transform, see
	// [method@Gtk.Widget.size_allocate].
	AllocateWidget(width int, height int, baseline int, transform *gsk.Transform)
	// ChildFocusWidget: called by widgets as the user moves around the window
	// using keyboard shortcuts.
	//
	// The @direction argument indicates what kind of motion is taking place
	// (up, down, left, right, tab forward, tab backward).
	//
	// This function calls the [vfunc@Gtk.Widget.focus] virtual function;
	// widgets can override the virtual function in order to implement
	// appropriate focus behavior.
	//
	// The default `focus()` virtual function for a widget should return `TRUE`
	// if moving in @direction left the focus on a focusable location inside
	// that widget, and `FALSE` if moving in @direction moved the focus outside
	// the widget. When returning `TRUE`, widgets normallycall
	// [method@Gtk.Widget.grab_focus] to place the focus accordingly; when
	// returning `FALSE`, they dont modify the current focus location.
	//
	// This function is used by custom widget implementations; if you're writing
	// an app, youd use [method@Gtk.Widget.grab_focus] to move the focus to a
	// particular widget.
	ChildFocusWidget(direction DirectionType) bool
	// ComputeBoundsWidget computes the bounds for @widget in the coordinate
	// space of @target.
	//
	// FIXME: Explain what "bounds" are.
	//
	// If the operation is successful, true is returned. If @widget has no
	// bounds or the bounds cannot be expressed in @target's coordinate space
	// (for example if both widgets are in different windows), false is returned
	// and @bounds is set to the zero rectangle.
	//
	// It is valid for @widget and @target to be the same widget.
	ComputeBoundsWidget(target Widget) (graphene.Rect, bool)
	// ComputeExpandWidget computes whether a container should give this widget
	// extra space when possible.
	//
	// Containers should check this, rather than looking at
	// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	ComputeExpandWidget(orientation Orientation) bool
	// ComputePointWidget translates the given @point in @widget's coordinates
	// to coordinates relative to @targets coordinate system.
	//
	// In order to perform this operation, both widgets must share a common
	// ancestor.
	ComputePointWidget(target Widget, point *graphene.Point) (graphene.Point, bool)
	// ComputeTransformWidget computes a matrix suitable to describe a
	// transformation from @widget's coordinate system into @target's coordinate
	// system.
	ComputeTransformWidget(target Widget) (graphene.Matrix, bool)
	// ContainsWidget tests if the point at (@x, @y) is contained in @widget.
	//
	// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of @widget's content area.
	ContainsWidget(x float64, y float64) bool
	// CreatePangoContextWidget creates a new `PangoContext` with the
	// appropriate font map, font options, font description, and base direction
	// for drawing text for this widget.
	//
	// See also [method@Gtk.Widget.get_pango_context].
	CreatePangoContextWidget() pango.Context
	// CreatePangoLayoutWidget creates a new `PangoLayout` with the appropriate
	// font map, font description, and base direction for drawing text for this
	// widget.
	//
	// If you keep a `PangoLayout` created in this way around, you need to
	// re-create it when the widget `PangoContext` is replaced. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	CreatePangoLayoutWidget(text string) pango.Layout
	// DragCheckThresholdWidget checks to see if a drag movement has passed the
	// GTK drag threshold.
	DragCheckThresholdWidget(startX int, startY int, currentX int, currentY int) bool
	// ErrorBellWidget notifies the user about an input-related error on this
	// widget.
	//
	// If the [property@Gtk.Settings:gtk-error-bell] setting is true, it calls
	// [method@Gdk.Surface.beep], otherwise it does nothing.
	//
	// Note that the effect of [method@Gdk.Surface.beep] can be configured in
	// many ways, depending on the windowing backend and the desktop environment
	// or window manager that is used.
	ErrorBellWidget()
	// AllocatedBaseline returns the baseline that has currently been allocated
	// to @widget.
	//
	// This function is intended to be used when implementing handlers for the
	// `GtkWidget`Class.snapshot() function, and when allocating child widgets
	// in `GtkWidget`Class.size_allocate().
	AllocatedBaseline() int
	// AllocatedHeight returns the height that has currently been allocated to
	// @widget.
	AllocatedHeight() int
	// AllocatedWidth returns the width that has currently been allocated to
	// @widget.
	AllocatedWidth() int
	// Ancestor gets the first ancestor of @widget with type @widget_type.
	//
	// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the
	// first `GtkBox` thats an ancestor of @widget. No reference will be added
	// to the returned widget; it should not be unreferenced.
	//
	// Note that unlike [method@Gtk.Widget.is_ancestor], this function considers
	// @widget to be an ancestor of itself.
	Ancestor(widgetType externglib.Type) Widget
	// CanFocus determines whether the input focus can enter @widget or any of
	// its children.
	//
	// See [method@Gtk.Widget.set_focusable].
	CanFocus() bool
	// CanTarget queries whether @widget can be the target of pointer events.
	CanTarget() bool
	// ChildVisible gets the value set with gtk_widget_set_child_visible().
	//
	// If you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	ChildVisible() bool
	// Clipboard gets the clipboard object for @widget.
	//
	// This is a utility function to get the clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	Clipboard() gdk.Clipboard
	// CSSClasses returns the list of style classes applied to @widget.
	CSSClasses() []string
	// CSSName returns the CSS name that is used for @self.
	CSSName() string
	// Cursor queries the cursor set on @widget.
	//
	// See [method@Gtk.Widget.set_cursor] for details.
	Cursor() gdk.Cursor
	// Direction gets the reading direction for a particular widget.
	//
	// See [method@Gtk.Widget.set_direction].
	Direction() TextDirection
	// Display: get the `GdkDisplay` for the toplevel window associated with
	// this widget.
	//
	// This function can only be called after the widget has been added to a
	// widget hierarchy with a `GtkWindow` at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	Display() gdk.Display
	// FirstChild returns the widgets first child.
	//
	// This API is primarily meant for widget implementations.
	FirstChild() Widget
	// FocusChild returns the current focus child of @widget.
	FocusChild() Widget
	// FocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// See [method@Gtk.Widget.set_focus_on_click].
	FocusOnClick() bool
	// Focusable determines whether @widget can own the input focus.
	//
	// See [method@Gtk.Widget.set_focusable].
	Focusable() bool
	// FontMap gets the font map of @widget.
	//
	// See [method@Gtk.Widget.set_font_map].
	FontMap() pango.FontMap
	// FontOptions returns the `cairo_font_options_t` used for Pango rendering.
	//
	// When not set, the defaults font options for the `GdkDisplay` will be
	// used.
	FontOptions() *cairo.FontOptions
	// FrameClock obtains the frame clock for a widget.
	//
	// The frame clock is a global ticker that can be used to drive animations
	// and repaints. The most common reason to get the frame clock is to call
	// [method@Gdk.FrameClock.get_frame_time], in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from [method@Gdk.FrameClock.get_frame_time], and then
	// update the animation by calling [method@Gdk.FrameClock.get_frame_time]
	// again during each repaint.
	//
	// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
	// clock, but wont necessarily repaint any widgets. To repaint a widget,
	// you have to use [method@Gtk.Widget.queue_draw] which invalidates the
	// widget (thus scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widgets frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widgets frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	FrameClock() gdk.FrameClock
	// Halign gets the horizontal alignment of @widget.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	Halign() Align
	// HasTooltip returns the current value of the `has-tooltip` property.
	HasTooltip() bool
	// Height returns the content height of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	Height() int
	// Hexpand gets whether the widget would like any available extra horizontal
	// space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use [method@Gtk.Widget.compute_expand] rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widgets own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	Hexpand() bool
	// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If [property@Gtk.Widget:hexpand] property is set, then it overrides any
	// computed expand value based on child widgets. If `hexpand` is not set,
	// then the expand value depends on whether any children of the widget would
	// like to expand.
	//
	// There are few reasons to use this function, but its here for
	// completeness and consistency.
	HexpandSet() bool
	// LastChild returns the widgets last child.
	//
	// This API is primarily meant for widget implementations.
	LastChild() Widget
	// LayoutManager retrieves the layout manager used by @widget
	//
	// See [method@Gtk.Widget.set_layout_manager].
	LayoutManager() LayoutManager
	// Mapped: whether the widget is mapped.
	Mapped() bool
	// MarginBottom gets the bottom margin of @widget.
	MarginBottom() int
	// MarginEnd gets the end margin of @widget.
	MarginEnd() int
	// MarginStart gets the start margin of @widget.
	MarginStart() int
	// MarginTop gets the top margin of @widget.
	MarginTop() int
	// Name retrieves the name of a widget.
	//
	// See [method@Gtk.Widget.set_name] for the significance of widget names.
	Name() string
	// GetNative returns the `GtkNative` widget that contains @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a native ancestor.
	//
	// `GtkNative` widgets will return themselves here.
	GetNative() Native
	// NextSibling returns the widgets next sibling.
	//
	// This API is primarily meant for widget implementations.
	NextSibling() Widget
	// Opacity #Fetches the requested opacity for this widget.
	//
	// See [method@Gtk.Widget.set_opacity].
	Opacity() float64
	// Overflow returns the widgets overflow value.
	Overflow() Overflow
	// PangoContext gets a `PangoContext` with the appropriate font map, font
	// description, and base direction for this widget.
	//
	// Unlike the context returned by [method@Gtk.Widget.create_pango_context],
	// this context is owned by the widget (it can be used until the screen for
	// the widget changes or the widget is removed from its toplevel), and will
	// be updated to match any changes to the widgets attributes. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	PangoContext() pango.Context
	// Parent returns the parent widget of @widget.
	Parent() Widget
	// PreferredSize retrieves the minimum and natural size of a widget, taking
	// into account the widgets preference for height-for-width management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as `GtkFixed`.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use [id@gtk_widget_measure] if you want to support baseline alignment.
	PreferredSize() (minimumSize Requisition, naturalSize Requisition)
	// PrevSibling returns the widgets previous sibling.
	//
	// This API is primarily meant for widget implementations.
	PrevSibling() Widget
	// PrimaryClipboard gets the primary clipboard of @widget.
	//
	// This is a utility function to get the primary clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	PrimaryClipboard() gdk.Clipboard
	// Realized determines whether @widget is realized.
	Realized() bool
	// ReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See [method@Gtk.Widget.set_receives_default].
	ReceivesDefault() bool
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Single-child widgets generally propagate the preference of their child,
	// more complex widgets need to request something either in context of their
	// children or in context of their allocation capabilities.
	RequestMode() SizeRequestMode
	// Root returns the `GtkRoot` widget of @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a root widget.
	//
	// `GtkRoot` widgets will return themselves here.
	Root() Root
	// ScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels.
	//
	// On traditional systems this is 1, on high density outputs, it can be a
	// higher value (typically 2).
	//
	// See [method@Gdk.Surface.get_scale_factor].
	ScaleFactor() int
	// Sensitive returns the widgets sensitivity.
	//
	// This function returns the value that has been set using
	// [method@Gtk.Widget.set_sensitive]).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widgets sensitivity. See
	// [method@Gtk.Widget.is_sensitive].
	Sensitive() bool
	// Settings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the `GtkWidget` is
	// attached to a toplevel, since the settings object is specific to a
	// particular `GdkDisplay`. If you want to monitor the widget for changes in
	// its settings, connect to notify::display.
	Settings() Settings
	// Size returns the content width or height of the widget.
	//
	// Which dimension is returned depends on @orientation.
	//
	// This is equivalent to calling [method@Gtk.Widget.get_width] for
	// GTK_ORIENTATION_HORIZONTAL or [method@Gtk.Widget.get_height] for
	// GTK_ORIENTATION_VERTICAL, but can be used when writing
	// orientation-independent code, such as when implementing
	// [iface@Gtk.Orientable] widgets.
	Size(orientation Orientation) int
	// SizeRequest gets the size request that was explicitly set for the widget
	// using gtk_widget_set_size_request().
	//
	// A value of -1 stored in @width or @height indicates that that dimension
	// has not been set explicitly and the natural requisition of the widget
	// will be used instead. See [method@Gtk.Widget.set_size_request]. To get
	// the size a widget will actually request, call [method@Gtk.Widget.measure]
	// instead of this function.
	SizeRequest() (width int, height int)
	// StateFlags returns the widget state as a flag set.
	//
	// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE
	// state will be returned, that is, also based on parent insensitivity, even
	// if @widget itself is sensitive.
	//
	// Also note that if you are looking for a way to obtain the
	// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext] method, you
	// should look at [method@Gtk.StyleContext.get_state].
	StateFlags() StateFlags
	// StyleContext returns the style context associated to @widget.
	//
	// The returned object is guaranteed to be the same for the lifetime of
	// @widget.
	StyleContext() StyleContext
	// TemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// [method@Gtk.WidgetClass.bind_template_child_full] or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	TemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// TooltipMarkup gets the contents of the tooltip for @widget.
	//
	// If the tooltip has not been set using
	// [method@Gtk.Widget.set_tooltip_markup], this function returns nil.
	TooltipMarkup() string
	// TooltipText gets the contents of the tooltip for @widget.
	//
	// If the @widget's tooltip was set using
	// [method@Gtk.Widget.set_tooltip_markup], this function will return the
	// escaped text.
	TooltipText() string
	// Valign gets the vertical alignment of @widget.
	Valign() Align
	// Vexpand gets whether the widget would like any available extra vertical
	// space.
	//
	// See [method@Gtk.Widget.get_hexpand] for more detail.
	Vexpand() bool
	// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See [method@Gtk.Widget.get_hexpand_set] for more detail.
	VexpandSet() bool
	// Visible determines whether the widget is visible.
	//
	// If you want to take into account whether the widgets parent is also
	// marked as visible, use [method@Gtk.Widget.is_visible] instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See [method@Gtk.Widget.set_visible].
	Visible() bool
	// Width returns the content width of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	Width() int
	// GrabFocusWidget causes @widget to have the keyboard focus for the
	// `GtkWindow` it's inside.
	//
	// If @widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of @widget that is focusable, it will
	// not take focus and false will be returned.
	//
	// Calling [method@Gtk.Widget.grab_focus] on an already focused widget is
	// allowed, should not have an effect, and return true.
	GrabFocusWidget() bool
	// HasCSSClassWidget returns whether @css_class is currently applied to
	// @widget.
	HasCSSClassWidget(cssClass string) bool
	// HasDefaultWidget determines whether @widget is the current default widget
	// within its toplevel.
	HasDefaultWidget() bool
	// HasFocusWidget determines if the widget has the global input focus.
	//
	// See [method@Gtk.Widget.is_focus] for the difference between having the
	// global input focus, and only having the focus within a toplevel.
	HasFocusWidget() bool
	// HasVisibleFocusWidget determines if the widget should show a visible
	// indication that it has the global input focus.
	//
	// This is a convenience function that takes into account whether focus
	// indication should currently be shown in the toplevel window of @widget.
	// See [method@Gtk.Window.get_focus_visible] for more information about
	// focus indication.
	//
	// To find out if the widget has the global input focus, use
	// [method@Gtk.Widget.has_focus].
	HasVisibleFocusWidget() bool
	// HideWidget reverses the effects of gtk_widget_show().
	//
	// This is causing the widget to be hidden (invisible to the user).
	HideWidget()
	// InDestructionWidget returns whether the widget is currently being
	// destroyed.
	//
	// This information can sometimes be used to avoid doing unnecessary work.
	InDestructionWidget() bool
	// InitTemplateWidget creates and initializes child widgets defined in
	// templates.
	//
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using
	// [method@Gtk.WidgetClass.set_template].
	//
	// It is important to call this function in the instance initializer of a
	// `GtkWidget` subclass and not in `GObject.constructed()` or
	// `GObject.constructor()` for two reasons:
	//
	//    - derived widgets will assume that the composite widgets
	//      defined by its parent classes have been created in their
	//      relative instance initializers
	//    - when calling `g_object_new()` on a widget with composite templates,
	//      its important to build the composite widgets before the construct
	//      properties are set. Properties passed to `g_object_new()` should
	//      take precedence over properties set in the private template XML
	//
	// A good rule of thumb is to call this function as the first thing in an
	// instance initialization function.
	InitTemplateWidget()
	// InsertActionGroupWidget inserts @group into @widget.
	//
	// Children of @widget that implement [iface@Gtk.Actionable] can then be
	// associated with actions in @group by setting their action-name to
	// @prefix.`action-name`.
	//
	// Note that inheritance is defined for individual actions. I.e. even if you
	// insert a group with prefix @prefix, actions with the same prefix will
	// still be inherited from the parent, unless the group contains an action
	// with the same name.
	//
	// If @group is nil, a previously inserted group for @name is removed from
	// @widget.
	InsertActionGroupWidget(name string, group gio.ActionGroup)
	// InsertAfterWidget inserts @widget into the child widget list of @parent.
	//
	// It will be placed after @previous_sibling, or at the beginning if
	// @previous_sibling is nil.
	//
	// After calling this function, `gtk_widget_get_prev_sibling(widget)` will
	// return @previous_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertAfterWidget(parent Widget, previousSibling Widget)
	// InsertBeforeWidget inserts @widget into the child widget list of @parent.
	//
	// It will be placed before @next_sibling, or at the end if @next_sibling is
	// nil.
	//
	// After calling this function, `gtk_widget_get_next_sibling(widget)` will
	// return @next_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertBeforeWidget(parent Widget, nextSibling Widget)
	// IsAncestorWidget determines whether @widget is somewhere inside
	// @ancestor, possibly with intermediate containers.
	IsAncestorWidget(ancestor Widget) bool
	// IsDrawableWidget determines whether @widget can be drawn to.
	//
	// A widget can be drawn if it is mapped and visible.
	IsDrawableWidget() bool
	// IsFocusWidget determines if the widget is the focus widget within its
	// toplevel.
	//
	// This does not mean that the [property@Gtk.Widget:has-focus] property is
	// necessarily set; [property@Gtk,Widget:has-focus] will only be set if the
	// toplevel widget additionally has the global input focus.)
	IsFocusWidget() bool
	// IsSensitiveWidget returns the widgets effective sensitivity.
	//
	// This means it is sensitive itself and also its parent widget is
	// sensitive.
	IsSensitiveWidget() bool
	// IsVisibleWidget determines whether the widget and all its parents are
	// marked as visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also [method@Gtk.Widget.get_visible] and
	// [method@Gtk.Widget.set_visible].
	IsVisibleWidget() bool
	// KeynavFailedWidget emits the `::keynav-failed` signal on the widget.
	//
	// This function should be called whenever keyboard navigation within a
	// single widget hits a boundary.
	//
	// The return value of this function should be interpreted in a way similar
	// to the return value of [method@Gtk.Widget.child_focus]. When true is
	// returned, stay in the widget, the failed keyboard navigation is OK and/or
	// there is nowhere we can/should move the focus to. When false is returned,
	// the caller should continue with keyboard navigation outside the widget,
	// e.g. by calling [method@Gtk.Widget.child_focus] on the widgets toplevel.
	//
	// The default [signal@Gtk.Widget::keynav-failed] handler returns false for
	// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
	// DirectionType it returns true.
	//
	// Whenever the default handler returns true, it also calls
	// [method@Gtk.Widget.error_bell] to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of
	// [class@Gtk.Entry] widgets where the user should be able to navigate the
	// entire row with the cursor keys, as e.g. known from user interfaces that
	// require entering license keys.
	KeynavFailedWidget(direction DirectionType) bool
	// MapWidget causes a widget to be mapped if it isnt already.
	//
	// This function is only for use in widget implementations.
	MapWidget()
	// MeasureWidget measures @widget in the orientation @orientation and for
	// the given @for_size.
	//
	// As an example, if @orientation is GTK_ORIENTATION_HORIZONTAL and
	// @for_size is 300, this functions will compute the minimum and natural
	// width of @widget if it is allocated at a height of 300 pixels.
	//
	// See GtkWidgets geometry management section
	// (class.Widget.html#height-for-width-geometry-management) for a more
	// details on implementing WidgetClass.measure().
	MeasureWidget(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
	// MnemonicActivateWidget emits the `GtkWidget`::mnemonic-activate signal.
	MnemonicActivateWidget(groupCycling bool) bool
	// ObserveChildrenWidget returns a `GListModel` to track the children of
	// @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// children and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveChildrenWidget() gio.ListModel
	// ObserveControllersWidget returns a `GListModel` to track the
	// [class@Gtk.EventController]s of @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// controllers and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveControllersWidget() gio.ListModel
	// PickWidget finds the descendant of @widget closest to the screen at the
	// point (@x, @y).
	//
	// The point must be given in widget coordinates, so (0, 0) is assumed to be
	// the top left of @widget's content area.
	//
	// Usually widgets will return nil if the given coordinate is not contained
	// in @widget checked via [method@Gtk.Widget.contains]. Otherwise they will
	// recursively try to find a child that does not return nil. Widgets are
	// however free to customize their picking algorithm.
	//
	// This function is used on the toplevel to determine the widget below the
	// mouse cursor for purposes of hover highlighting and delivering events.
	PickWidget(x float64, y float64, flags PickFlags) Widget
	// QueueAllocateWidget flags the widget for a rerun of the
	// GtkWidgetClass::size_allocate function.
	//
	// Use this function instead of [method@Gtk.Widget.queue_resize] when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is [method@Gtk.Widget.set_halign].
	//
	// This function is only for use in widget implementations.
	QueueAllocateWidget()
	// QueueDrawWidget schedules this widget to be redrawn in paint phase of the
	// current or the next frame.
	//
	// This means @widget's GtkWidgetClass.snapshot() implementation will be
	// called.
	QueueDrawWidget()
	// QueueResizeWidget flags a widget to have its size renegotiated.
	//
	// This should be called when a widget for some reason has a new size
	// request. For example, when you change the text in a [class@Gtk.Label],
	// the label queues a resize to ensure theres enough space for the new
	// text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	//
	// This function is only for use in widget implementations.
	QueueResizeWidget()
	// RealizeWidget creates the GDK resources associated with a widget.
	//
	// Normally realization happens implicitly; if you show a widget and all its
	// parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widgets parent widgets to be
	// realized; calling this function realizes the widgets parents in addition
	// to @widget itself. If a widget is not yet inside a toplevel window when
	// you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isnt very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as [signal@Gtk.Widget::realize].
	RealizeWidget()
	// RemoveControllerWidget removes @controller from @widget, so that it
	// doesn't process events anymore.
	//
	// It should not be used again.
	//
	// Widgets will remove all event controllers automatically when they are
	// destroyed, there is normally no need to call this function.
	RemoveControllerWidget(controller EventController)
	// RemoveCSSClassWidget removes a style from @widget.
	//
	// After this, the style of @widget will stop matching for @css_class.
	RemoveCSSClassWidget(cssClass string)
	// RemoveMnemonicLabelWidget removes a widget from the list of mnemonic
	// labels for this widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. The widget must have
	// previously been added to the list with
	// [method@Gtk.Widget.add_mnemonic_label].
	RemoveMnemonicLabelWidget(label Widget)
	// RemoveTickCallbackWidget removes a tick callback previously registered
	// with gtk_widget_add_tick_callback().
	RemoveTickCallbackWidget(id uint)
	// SetCanFocusWidget specifies whether the input focus can enter the widget
	// or any of its children.
	//
	// Applications should set @can_focus to false to mark a widget as for
	// pointer/touch use only.
	//
	// Note that having @can_focus be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// focusable and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	SetCanFocusWidget(canFocus bool)
	// SetCanTargetWidget sets whether @widget can be the target of pointer
	// events.
	SetCanTargetWidget(canTarget bool)
	// SetChildVisibleWidget sets whether @widget should be mapped along with
	// its parent.
	//
	// The child visibility can be set for widget before it is added to a
	// container with [method@Gtk.Widget.set_parent], to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	SetChildVisibleWidget(childVisible bool)
	// SetCSSClassesWidget: will clear all style classes applied to @widget and
	// replace them with @classes.
	SetCSSClassesWidget(classes []string)
	// SetCursorWidget sets the cursor to be shown when pointer devices point
	// towards @widget.
	//
	// If the @cursor is NULL, @widget will use the cursor inherited from the
	// parent widget.
	SetCursorWidget(cursor gdk.Cursor)
	// SetCursorFromNameWidget sets a named cursor to be shown when pointer
	// devices point towards @widget.
	//
	// This is a utility function that creates a cursor via
	// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget with
	// [method@Gtk.Widget.set_cursor]. See those functions for details.
	//
	// On top of that, this function allows @name to be nil, which will do the
	// same as calling [method@Gtk.Widget.set_cursor] with a nil cursor.
	SetCursorFromNameWidget(name string)
	// SetDirectionWidget sets the reading direction on a particular widget.
	//
	// This direction controls the primary direction for widgets containing
	// text, and also the direction in which the children of a container are
	// packed. The ability to set the direction is present in order so that
	// correct localization into languages with right-to-left reading directions
	// can be done. Generally, applications will let the default reading
	// direction present, except for containers where the containers are
	// arranged in an order that is explicitly visual rather than logical (such
	// as buttons for text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// [func@Gtk.Widget.set_default_direction] will be used.
	SetDirectionWidget(dir TextDirection)
	// SetFocusChildWidget: set @child as the current focus child of @widget.
	//
	// The previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call
	// [method@Gtk.Widget.grab_focus] on it.
	SetFocusChildWidget(child Widget)
	// SetFocusOnClickWidget sets whether the widget should grab focus when it
	// is clicked with the mouse.
	//
	// Making mouse clicks not grab focus is useful in places like toolbars
	// where you dont want the keyboard focus removed from the main area of the
	// application.
	SetFocusOnClickWidget(focusOnClick bool)
	// SetFocusableWidget specifies whether @widget can own the input focus.
	//
	// Widget implementations should set @focusable to true in their init()
	// function if they want to receive keyboard input.
	//
	// Note that having @focusable be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// can-focus and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	SetFocusableWidget(focusable bool)
	// SetFontMapWidget sets the font map to use for Pango rendering.
	//
	// The font map is the object that is used to look up fonts. Setting a
	// custom font map can be useful in special situations, e.g. when you need
	// to add application-specific fonts to the set of available fonts.
	//
	// When not set, the widget will inherit the font map from its parent.
	SetFontMapWidget(fontMap pango.FontMap)
	// SetFontOptionsWidget sets the `cairo_font_options_t` used for Pango
	// rendering in this widget.
	//
	// When not set, the default font options for the `GdkDisplay` will be used.
	SetFontOptionsWidget(options *cairo.FontOptions)
	// SetHalignWidget sets the horizontal alignment of @widget.
	SetHalignWidget(align Align)
	// SetHasTooltipWidget sets the `has-tooltip` property on @widget to
	// @has_tooltip.
	SetHasTooltipWidget(hasTooltip bool)
	// SetHexpandWidget sets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call [method@Gtk.Widget.compute_expand]. A container
	// can decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on
	// `GtkWidget`.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because [method@Gtk.Widget.set_hexpand]
	// sets the hexpand-set property (see [method@Gtk.Widget.set_hexpand_set])
	// which causes the widgets hexpand value to be used, rather than looking
	// at children and widget state.
	SetHexpandWidget(expand bool)
	// SetHexpandSetWidget sets whether the hexpand flag will be used.
	//
	// The [property@Gtk.Widget:hexpand-set] property will be set automatically
	// when you call [method@Gtk.Widget.set_hexpand] to set hexpand, so the most
	// likely reason to use this function would be to unset an explicit expand
	// flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but its here for
	// completeness and consistency.
	SetHexpandSetWidget(set bool)
	// SetLayoutManagerWidget sets the layout manager delegate instance that
	// provides an implementation for measuring and allocating the children of
	// @widget.
	SetLayoutManagerWidget(layoutManager LayoutManager)
	// SetMarginBottomWidget sets the bottom margin of @widget.
	SetMarginBottomWidget(margin int)
	// SetMarginEndWidget sets the end margin of @widget.
	SetMarginEndWidget(margin int)
	// SetMarginStartWidget sets the start margin of @widget.
	SetMarginStartWidget(margin int)
	// SetMarginTopWidget sets the top margin of @widget.
	SetMarginTopWidget(margin int)
	// SetNameWidget sets a widgets name.
	//
	// Setting a name allows you to refer to the widget from a CSS file. You can
	// apply a style to widgets with a particular name in the CSS file. See the
	// documentation for the CSS syntax (on the same page as the docs for
	// [class@Gtk.StyleContext].
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	SetNameWidget(name string)
	// SetOpacityWidget: request the @widget to be rendered partially
	// transparent.
	//
	// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
	//
	// Opacity works on both toplevel widgets and child widgets, although there
	// are some limitations: For toplevel widgets, applying opacity depends on
	// the capabilities of the windowing system. On X11, this has any effect
	// only on X displays with a compositing manager, see
	// gdk_display_is_composited(). On Windows and Wayland it should always
	// work, although setting a windows opacity after the window has been shown
	// may cause some flicker.
	//
	// Note that the opacity is inherited through inclusion  if you set a
	// toplevel to be partially translucent, all of its content will appear
	// translucent, since it is ultimatively rendered on that toplevel. The
	// opacity value itself is not inherited by child widgets (since that would
	// make widgets deeper in the hierarchy progressively more translucent). As
	// a consequence, [class@Gtk.Popover]s and other [class@Gtk.Native] widgets
	// with their own surface will use their own opacity value, and thus by
	// default appear non-translucent, even if they are attached to a toplevel
	// that is translucent.
	SetOpacityWidget(opacity float64)
	// SetOverflowWidget sets how @widget treats content that is drawn outside
	// the widget's content area.
	//
	// See the definition of [enum@Gtk.Overflow] for details.
	//
	// This setting is provided for widget implementations and should not be
	// used by application code.
	//
	// The default value is GTK_OVERFLOW_VISIBLE.
	SetOverflowWidget(overflow Overflow)
	// SetParentWidget sets @parent as the parent widget of @widget.
	//
	// This takes care of details such as updating the state and style of the
	// child to reflect its new location and resizing the parent. The opposite
	// function is [method@Gtk.Widget.unparent].
	//
	// This function is useful only when implementing subclasses of `GtkWidget`.
	SetParentWidget(parent Widget)
	// SetReceivesDefaultWidget specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	SetReceivesDefaultWidget(receivesDefault bool)
	// SetSensitiveWidget sets the sensitivity of a widget.
	//
	// A widget is sensitive if the user can interact with it. Insensitive
	// widgets are grayed out and the user cant interact with them.
	// Insensitive widgets are known as inactive, disabled, or ghosted in
	// some other toolkits.
	SetSensitiveWidget(sensitive bool)
	// SetSizeRequestWidget sets the minimum size of a widget.
	//
	// That is, the widgets size request will be at least @width by @height.
	// You can use this function to force a widget to be larger than it normally
	// would be.
	//
	// In most cases, [method@Gtk.Window.set_default_size] is a better choice
	// for toplevel windows than this function; setting the default size will
	// still allow users to shrink the window. Setting the size request will
	// force them to leave the window at least as large as the size request.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// natural size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the properties
	// [property@Gtk.Widget:margin-start], [property@Gtk.Widget:margin-end],
	// [property@Gtk.Widget:margin-top], and
	// [property@Gtk.Widget:margin-bottom], but it does include pretty much all
	// other padding or border properties set by any subclass of `GtkWidget`.
	SetSizeRequestWidget(width int, height int)
	// SetStateFlagsWidget turns on flag values in the current widget state.
	//
	// Typical widget states are insensitive, prelighted, etc.
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use [method@Gtk.Widget.set_direction].
	//
	// This function is for use in widget implementations.
	SetStateFlagsWidget(flags StateFlags, clear bool)
	// SetTooltipMarkupWidget sets @markup as the contents of the tooltip, which
	// is marked up with Pango markup.
	//
	// This function will take care of setting the
	// [property@Gtk.Widget:has-tooltip] as a side effect, and of the default
	// handler for the [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_markup].
	SetTooltipMarkupWidget(markup string)
	// SetTooltipTextWidget sets @text as the contents of the tooltip.
	//
	// If @text contains any markup, it will be escaped.
	//
	// This function will take care of setting [property@Gtk.Widget:has-tooltip]
	// as a side effect, and of the default handler for the
	// [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_text].
	SetTooltipTextWidget(text string)
	// SetValignWidget sets the vertical alignment of @widget.
	SetValignWidget(align Align)
	// SetVexpandWidget sets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.set_hexpand] for more detail.
	SetVexpandWidget(expand bool)
	// SetVexpandSetWidget sets whether the vexpand flag will be used.
	//
	// See [method@Gtk.Widget.set_hexpand_set] for more detail.
	SetVexpandSetWidget(set bool)
	// SetVisibleWidget sets the visibility state of @widget.
	//
	// Note that setting this to true doesnt mean the widget is actually
	// viewable, see [method@Gtk.Widget.get_visible].
	//
	// This function simply calls [method@Gtk.Widget.show] or
	// [method@Gtk.Widget.hide] but is nicer to use when the visibility of the
	// widget depends on some condition.
	SetVisibleWidget(visible bool)
	// ShouldLayoutWidget returns whether @widget should contribute to the
	// measuring and allocation of its parent.
	//
	// This is false for invisible children, but also for children that have
	// their own surface.
	ShouldLayoutWidget() bool
	// ShowWidget flags a widget to be displayed.
	//
	// Any widget that isnt shown will not appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	ShowWidget()
	// SnapshotChildWidget: snapshot the a child of @widget.
	//
	// When a widget receives a call to the snapshot function, it must send
	// synthetic `GtkWidget`Class.snapshot() calls to all children. This
	// function provides a convenient way of doing this. A widget, when it
	// receives a call to its `GtkWidget`Class.snapshot() function, calls
	// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
	// the widget received.
	//
	// gtk_widget_snapshot_child() takes care of translating the origin of
	// @snapshot, and deciding whether the child needs to be snapshot.
	//
	// This function does nothing for children that implement `GtkNative`.
	SnapshotChildWidget(child Widget, snapshot Snapshot)
	// TranslateCoordinatesWidget: translate coordinates relative to
	// @src_widgets allocation to coordinates relative to @dest_widgets
	// allocations.
	//
	// In order to perform this operation, both widget must share a common
	// ancestor.
	TranslateCoordinatesWidget(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)
	// TriggerTooltipQueryWidget triggers a tooltip query on the display where
	// the toplevel of @widget is located.
	TriggerTooltipQueryWidget()
	// UnmapWidget causes a widget to be unmapped if its currently mapped.
	//
	// This function is only for use in widget implementations.
	UnmapWidget()
	// UnparentWidget: dissociate @widget from its parent.
	//
	// This function is only for use in widget implementations, typically in
	// dispose.
	UnparentWidget()
	// UnrealizeWidget causes a widget to be unrealized (frees all GDK resources
	// associated with the widget).
	//
	// This function is only useful in widget implementations.
	UnrealizeWidget()
	// UnsetStateFlagsWidget turns off flag values for the current widget state.
	//
	// See [method@Gtk.Widget.set_state_flags].
	//
	// This function is for use in widget implementations.
	UnsetStateFlagsWidget(flags StateFlags)
}

// widget implements the Widget class.
type widget struct {
	gextras.Objector
}

// WrapWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapWidget(obj *externglib.Object) Widget {
	return widget{
		Objector: obj,
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWidget(obj), nil
}

func (w widget) ActionSetEnabledWidget(actionName string, enabled bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	if enabled {
		_arg2 = C.TRUE
	}

	C.gtk_widget_action_set_enabled(_arg0, _arg1, _arg2)
}

func (w widget) ActivateWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_activate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) ActivateActionVariantWidget(name string, args *glib.Variant) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out
	var _arg2 *C.GVariant  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(args.Native()))

	_cret = C.gtk_widget_activate_action_variant(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) ActivateDefaultWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_activate_default(_arg0)
}

func (w widget) AddControllerWidget(controller EventController) {
	var _arg0 *C.GtkWidget          // out
	var _arg1 *C.GtkEventController // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkEventController)(unsafe.Pointer(controller.Native()))

	C.gtk_widget_add_controller(_arg0, _arg1)
}

func (w widget) AddCSSClassWidget(cssClass string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_add_css_class(_arg0, _arg1)
}

func (w widget) AddMnemonicLabelWidget(label Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

	C.gtk_widget_add_mnemonic_label(_arg0, _arg1)
}

func (w widget) AllocateWidget(width int, height int, baseline int, transform *gsk.Transform) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.int           // out
	var _arg4 *C.GskTransform // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.int)(width)
	_arg2 = (C.int)(height)
	_arg3 = (C.int)(baseline)
	_arg4 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

	C.gtk_widget_allocate(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (w widget) ChildFocusWidget(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkDirectionType)(direction)

	_cret = C.gtk_widget_child_focus(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) ComputeBoundsWidget(target Widget) (graphene.Rect, bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _outBounds graphene.Rect
	var _cret C.gboolean // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	_cret = C.gtk_widget_compute_bounds(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_outBounds)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _outBounds, _ok
}

func (w widget) ComputeExpandWidget(orientation Orientation) bool {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_widget_compute_expand(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) ComputePointWidget(target Widget, point *graphene.Point) (graphene.Point, bool) {
	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 *C.graphene_point_t // out
	var _outPoint graphene.Point
	var _cret C.gboolean // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	_cret = C.gtk_widget_compute_point(_arg0, _arg1, _arg2, (*C.graphene_point_t)(unsafe.Pointer(&_outPoint)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _outPoint, _ok
}

func (w widget) ComputeTransformWidget(target Widget) (graphene.Matrix, bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _outTransform graphene.Matrix
	var _cret C.gboolean // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	_cret = C.gtk_widget_compute_transform(_arg0, _arg1, (*C.graphene_matrix_t)(unsafe.Pointer(&_outTransform)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _outTransform, _ok
}

func (w widget) ContainsWidget(x float64, y float64) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.double)(x)
	_arg2 = (C.double)(y)

	_cret = C.gtk_widget_contains(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) CreatePangoContextWidget() pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_create_pango_context(_arg0)

	var _context pango.Context // out

	_context = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Context)

	return _context
}

func (w widget) CreatePangoLayoutWidget(text string) pango.Layout {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.char        // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_widget_create_pango_layout(_arg0, _arg1)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

func (w widget) DragCheckThresholdWidget(startX int, startY int, currentX int, currentY int) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.int        // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.int)(startX)
	_arg2 = (C.int)(startY)
	_arg3 = (C.int)(currentX)
	_arg4 = (C.int)(currentY)

	_cret = C.gtk_drag_check_threshold(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) ErrorBellWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_error_bell(_arg0)
}

func (w widget) AllocatedBaseline() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_allocated_baseline(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) AllocatedHeight() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_allocated_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) AllocatedWidth() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_allocated_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) Ancestor(widgetType externglib.Type) Widget {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GType)(widgetType)

	_cret = C.gtk_widget_get_ancestor(_arg0, _arg1)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

func (w widget) CanFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_can_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) CanTarget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_can_target(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) ChildVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_child_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) Clipboard() gdk.Clipboard {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_clipboard(_arg0)

	var _clipboard gdk.Clipboard // out

	_clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Clipboard)

	return _clipboard
}

func (w widget) CSSClasses() []string {
	var _arg0 *C.GtkWidget // out
	var _cret **C.char

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_css_classes(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (s widget) CSSName() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_widget_get_css_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (w widget) Cursor() gdk.Cursor {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkCursor // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_cursor(_arg0)

	var _cursor gdk.Cursor // out

	_cursor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Cursor)

	return _cursor
}

func (w widget) Direction() TextDirection {
	var _arg0 *C.GtkWidget       // out
	var _cret C.GtkTextDirection // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_direction(_arg0)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

func (w widget) Display() gdk.Display {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_display(_arg0)

	var _display gdk.Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

	return _display
}

func (w widget) FirstChild() Widget {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_first_child(_arg0)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

func (w widget) FocusChild() Widget {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_focus_child(_arg0)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

func (w widget) FocusOnClick() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_focus_on_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) Focusable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_focusable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) FontMap() pango.FontMap {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoFontMap // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_font_map(_arg0)

	var _fontMap pango.FontMap // out

	_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontMap)

	return _fontMap
}

func (w widget) FontOptions() *cairo.FontOptions {
	var _arg0 *C.GtkWidget            // out
	var _cret *C.cairo_font_options_t // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_font_options(_arg0)

	var _fontOptions *cairo.FontOptions // out

	_fontOptions = cairo.WrapFontOptions(unsafe.Pointer(_cret))

	return _fontOptions
}

func (w widget) FrameClock() gdk.FrameClock {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GdkFrameClock // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_frame_clock(_arg0)

	var _frameClock gdk.FrameClock // out

	_frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.FrameClock)

	return _frameClock
}

func (w widget) Halign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_halign(_arg0)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

func (w widget) HasTooltip() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_has_tooltip(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) Height() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) Hexpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_hexpand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) HexpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_hexpand_set(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) LastChild() Widget {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_last_child(_arg0)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

func (w widget) LayoutManager() LayoutManager {
	var _arg0 *C.GtkWidget        // out
	var _cret *C.GtkLayoutManager // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_layout_manager(_arg0)

	var _layoutManager LayoutManager // out

	_layoutManager = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(LayoutManager)

	return _layoutManager
}

func (w widget) Mapped() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_mapped(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) MarginBottom() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_bottom(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) MarginEnd() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_end(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) MarginStart() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_start(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) MarginTop() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_top(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) Name() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (w widget) GetNative() Native {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkNative // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_native(_arg0)

	var _native Native // out

	_native = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Native)

	return _native
}

func (w widget) NextSibling() Widget {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_next_sibling(_arg0)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

func (w widget) Opacity() float64 {
	var _arg0 *C.GtkWidget // out
	var _cret C.double     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_opacity(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

func (w widget) Overflow() Overflow {
	var _arg0 *C.GtkWidget  // out
	var _cret C.GtkOverflow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_overflow(_arg0)

	var _overflow Overflow // out

	_overflow = Overflow(_cret)

	return _overflow
}

func (w widget) PangoContext() pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_pango_context(_arg0)

	var _context pango.Context // out

	_context = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Context)

	return _context
}

func (w widget) Parent() Widget {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_parent(_arg0)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

func (w widget) PreferredSize() (minimumSize Requisition, naturalSize Requisition) {
	var _arg0 *C.GtkWidget // out
	var _minimumSize Requisition
	var _naturalSize Requisition

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_preferred_size(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_minimumSize)), (*C.GtkRequisition)(unsafe.Pointer(&_naturalSize)))

	return _minimumSize, _naturalSize
}

func (w widget) PrevSibling() Widget {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_prev_sibling(_arg0)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

func (w widget) PrimaryClipboard() gdk.Clipboard {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_primary_clipboard(_arg0)

	var _clipboard gdk.Clipboard // out

	_clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Clipboard)

	return _clipboard
}

func (w widget) Realized() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_realized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) ReceivesDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_receives_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_request_mode(_arg0)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

func (w widget) Root() Root {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkRoot   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_root(_arg0)

	var _root Root // out

	_root = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Root)

	return _root
}

func (w widget) ScaleFactor() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_scale_factor(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) Sensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) Settings() Settings {
	var _arg0 *C.GtkWidget   // out
	var _cret *C.GtkSettings // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_settings(_arg0)

	var _settings Settings // out

	_settings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Settings)

	return _settings
}

func (w widget) Size(orientation Orientation) int {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _cret C.int            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_widget_get_size(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) SizeRequest() (width int, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // in
	var _arg2 C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_size_request(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

func (w widget) StateFlags() StateFlags {
	var _arg0 *C.GtkWidget    // out
	var _cret C.GtkStateFlags // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_state_flags(_arg0)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

func (w widget) StyleContext() StyleContext {
	var _arg0 *C.GtkWidget       // out
	var _cret *C.GtkStyleContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_style_context(_arg0)

	var _styleContext StyleContext // out

	_styleContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StyleContext)

	return _styleContext
}

func (w widget) TemplateChild(widgetType externglib.Type, name string) gextras.Objector {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _arg2 *C.char      // out
	var _cret *C.GObject   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GType)(widgetType)
	_arg2 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_get_template_child(_arg0, _arg1, _arg2)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (w widget) TooltipMarkup() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_tooltip_markup(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (w widget) TooltipText() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_tooltip_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (w widget) Valign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_valign(_arg0)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

func (w widget) Vexpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_vexpand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) VexpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_vexpand_set(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) Visible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) Width() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (w widget) GrabFocusWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_grab_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) HasCSSClassWidget(cssClass string) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_widget_has_css_class(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) HasDefaultWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_has_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) HasFocusWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_has_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) HasVisibleFocusWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_has_visible_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) HideWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_hide(_arg0)
}

func (w widget) InDestructionWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_in_destruction(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) InitTemplateWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_init_template(_arg0)
}

func (w widget) InsertActionGroupWidget(name string, group gio.ActionGroup) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.char         // out
	var _arg2 *C.GActionGroup // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))

	C.gtk_widget_insert_action_group(_arg0, _arg1, _arg2)
}

func (w widget) InsertAfterWidget(parent Widget, previousSibling Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(previousSibling.Native()))

	C.gtk_widget_insert_after(_arg0, _arg1, _arg2)
}

func (w widget) InsertBeforeWidget(parent Widget, nextSibling Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(nextSibling.Native()))

	C.gtk_widget_insert_before(_arg0, _arg1, _arg2)
}

func (w widget) IsAncestorWidget(ancestor Widget) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(ancestor.Native()))

	_cret = C.gtk_widget_is_ancestor(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) IsDrawableWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_drawable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) IsFocusWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) IsSensitiveWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) IsVisibleWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) KeynavFailedWidget(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkDirectionType)(direction)

	_cret = C.gtk_widget_keynav_failed(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) MapWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_map(_arg0)
}

func (w widget) MeasureWidget(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _arg2 C.int            // out
	var _arg3 C.int            // in
	var _arg4 C.int            // in
	var _arg5 C.int            // in
	var _arg6 C.int            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (C.int)(forSize)

	C.gtk_widget_measure(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)

	var _minimum int         // out
	var _natural int         // out
	var _minimumBaseline int // out
	var _naturalBaseline int // out

	_minimum = (int)(_arg3)
	_natural = (int)(_arg4)
	_minimumBaseline = (int)(_arg5)
	_naturalBaseline = (int)(_arg6)

	return _minimum, _natural, _minimumBaseline, _naturalBaseline
}

func (w widget) MnemonicActivateWidget(groupCycling bool) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if groupCycling {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_widget_mnemonic_activate(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) ObserveChildrenWidget() gio.ListModel {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GListModel // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_observe_children(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (w widget) ObserveControllersWidget() gio.ListModel {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GListModel // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_observe_controllers(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (w widget) PickWidget(x float64, y float64, flags PickFlags) Widget {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out
	var _arg3 C.GtkPickFlags // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.double)(x)
	_arg2 = (C.double)(y)
	_arg3 = (C.GtkPickFlags)(flags)

	_cret = C.gtk_widget_pick(_arg0, _arg1, _arg2, _arg3)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

func (w widget) QueueAllocateWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_allocate(_arg0)
}

func (w widget) QueueDrawWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_draw(_arg0)
}

func (w widget) QueueResizeWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_resize(_arg0)
}

func (w widget) RealizeWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_realize(_arg0)
}

func (w widget) RemoveControllerWidget(controller EventController) {
	var _arg0 *C.GtkWidget          // out
	var _arg1 *C.GtkEventController // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkEventController)(unsafe.Pointer(controller.Native()))

	C.gtk_widget_remove_controller(_arg0, _arg1)
}

func (w widget) RemoveCSSClassWidget(cssClass string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_remove_css_class(_arg0, _arg1)
}

func (w widget) RemoveMnemonicLabelWidget(label Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

	C.gtk_widget_remove_mnemonic_label(_arg0, _arg1)
}

func (w widget) RemoveTickCallbackWidget(id uint) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.guint)(id)

	C.gtk_widget_remove_tick_callback(_arg0, _arg1)
}

func (w widget) SetCanFocusWidget(canFocus bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if canFocus {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_focus(_arg0, _arg1)
}

func (w widget) SetCanTargetWidget(canTarget bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if canTarget {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_target(_arg0, _arg1)
}

func (w widget) SetChildVisibleWidget(childVisible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if childVisible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_child_visible(_arg0, _arg1)
}

func (w widget) SetCSSClassesWidget(classes []string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 **C.char

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (**C.char)(C.malloc(C.ulong(len(classes)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(classes))
		for i := range classes {
			out[i] = (*C.char)(C.CString(classes[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_widget_set_css_classes(_arg0, _arg1)
}

func (w widget) SetCursorWidget(cursor gdk.Cursor) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkCursor // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkCursor)(unsafe.Pointer(cursor.Native()))

	C.gtk_widget_set_cursor(_arg0, _arg1)
}

func (w widget) SetCursorFromNameWidget(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_cursor_from_name(_arg0, _arg1)
}

func (w widget) SetDirectionWidget(dir TextDirection) {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkTextDirection)(dir)

	C.gtk_widget_set_direction(_arg0, _arg1)
}

func (w widget) SetFocusChildWidget(child Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_widget_set_focus_child(_arg0, _arg1)
}

func (w widget) SetFocusOnClickWidget(focusOnClick bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if focusOnClick {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_focus_on_click(_arg0, _arg1)
}

func (w widget) SetFocusableWidget(focusable bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if focusable {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_focusable(_arg0, _arg1)
}

func (w widget) SetFontMapWidget(fontMap pango.FontMap) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.PangoFontMap // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontMap.Native()))

	C.gtk_widget_set_font_map(_arg0, _arg1)
}

func (w widget) SetFontOptionsWidget(options *cairo.FontOptions) {
	var _arg0 *C.GtkWidget            // out
	var _arg1 *C.cairo_font_options_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.cairo_font_options_t)(unsafe.Pointer(options.Native()))

	C.gtk_widget_set_font_options(_arg0, _arg1)
}

func (w widget) SetHalignWidget(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_halign(_arg0, _arg1)
}

func (w widget) SetHasTooltipWidget(hasTooltip bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if hasTooltip {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_has_tooltip(_arg0, _arg1)
}

func (w widget) SetHexpandWidget(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand(_arg0, _arg1)
}

func (w widget) SetHexpandSetWidget(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand_set(_arg0, _arg1)
}

func (w widget) SetLayoutManagerWidget(layoutManager LayoutManager) {
	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkLayoutManager // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkLayoutManager)(unsafe.Pointer(layoutManager.Native()))

	C.gtk_widget_set_layout_manager(_arg0, _arg1)
}

func (w widget) SetMarginBottomWidget(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.int)(margin)

	C.gtk_widget_set_margin_bottom(_arg0, _arg1)
}

func (w widget) SetMarginEndWidget(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.int)(margin)

	C.gtk_widget_set_margin_end(_arg0, _arg1)
}

func (w widget) SetMarginStartWidget(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.int)(margin)

	C.gtk_widget_set_margin_start(_arg0, _arg1)
}

func (w widget) SetMarginTopWidget(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.int)(margin)

	C.gtk_widget_set_margin_top(_arg0, _arg1)
}

func (w widget) SetNameWidget(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_name(_arg0, _arg1)
}

func (w widget) SetOpacityWidget(opacity float64) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.double)(opacity)

	C.gtk_widget_set_opacity(_arg0, _arg1)
}

func (w widget) SetOverflowWidget(overflow Overflow) {
	var _arg0 *C.GtkWidget  // out
	var _arg1 C.GtkOverflow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkOverflow)(overflow)

	C.gtk_widget_set_overflow(_arg0, _arg1)
}

func (w widget) SetParentWidget(parent Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))

	C.gtk_widget_set_parent(_arg0, _arg1)
}

func (w widget) SetReceivesDefaultWidget(receivesDefault bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if receivesDefault {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_receives_default(_arg0, _arg1)
}

func (w widget) SetSensitiveWidget(sensitive bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_sensitive(_arg0, _arg1)
}

func (w widget) SetSizeRequestWidget(width int, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.int)(width)
	_arg2 = (C.int)(height)

	C.gtk_widget_set_size_request(_arg0, _arg1, _arg2)
}

func (w widget) SetStateFlagsWidget(flags StateFlags, clear bool) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateFlags)(flags)
	if clear {
		_arg2 = C.TRUE
	}

	C.gtk_widget_set_state_flags(_arg0, _arg1, _arg2)
}

func (w widget) SetTooltipMarkupWidget(markup string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_tooltip_markup(_arg0, _arg1)
}

func (w widget) SetTooltipTextWidget(text string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_tooltip_text(_arg0, _arg1)
}

func (w widget) SetValignWidget(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_valign(_arg0, _arg1)
}

func (w widget) SetVexpandWidget(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand(_arg0, _arg1)
}

func (w widget) SetVexpandSetWidget(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand_set(_arg0, _arg1)
}

func (w widget) SetVisibleWidget(visible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_visible(_arg0, _arg1)
}

func (w widget) ShouldLayoutWidget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_should_layout(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w widget) ShowWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_show(_arg0)
}

func (w widget) SnapshotChildWidget(child Widget, snapshot Snapshot) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkSnapshot // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkSnapshot)(unsafe.Pointer(snapshot.Native()))

	C.gtk_widget_snapshot_child(_arg0, _arg1, _arg2)
}

func (s widget) TranslateCoordinatesWidget(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out
	var _arg4 C.double     // in
	var _arg5 C.double     // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(destWidget.Native()))
	_arg2 = (C.double)(srcX)
	_arg3 = (C.double)(srcY)

	_cret = C.gtk_widget_translate_coordinates(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _destX float64 // out
	var _destY float64 // out
	var _ok bool       // out

	_destX = (float64)(_arg4)
	_destY = (float64)(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _destX, _destY, _ok
}

func (w widget) TriggerTooltipQueryWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_trigger_tooltip_query(_arg0)
}

func (w widget) UnmapWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unmap(_arg0)
}

func (w widget) UnparentWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unparent(_arg0)
}

func (w widget) UnrealizeWidget() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unrealize(_arg0)
}

func (w widget) UnsetStateFlagsWidget(flags StateFlags) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateFlags)(flags)

	C.gtk_widget_unset_state_flags(_arg0, _arg1)
}

func (s widget) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s widget) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s widget) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s widget) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s widget) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s widget) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s widget) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b widget) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// WidgetPaintable: `GtkWidgetPaintable` is a `GdkPaintable` that displays the
// contents of a widget.
//
// `GtkWidgetPaintable` will also take care of the widget not being in a state
// where it can be drawn (like when it isn't shown) and just draw nothing or
// where it does not have a size (like when it is hidden) and report no size in
// that case.
//
// Of course, `GtkWidgetPaintable` allows you to monitor widgets for size
// changes by emitting the [signal@Gdk.Paintable::invalidate-size] signal
// whenever the size of the widget changes as well as for visual changes by
// emitting the [signal@Gdk.Paintable::invalidate-contents] signal whenever the
// widget changes.
//
// You can use a `GtkWidgetPaintable` everywhere a `GdkPaintable` is allowed,
// including using it on a `GtkPicture` (or one of its parents) that it was set
// on itself via gtk_picture_set_paintable(). The paintable will take care of
// recursion when this happens. If you do this however, ensure that the
// [property@Gtk.Picture:can-shrink] property is set to true or you might end up
// with an infinitely growing widget.
type WidgetPaintable interface {
	gdk.Paintable

	// Widget returns the widget that is observed or nil if none.
	Widget() Widget
	// SetWidgetWidgetPaintable sets the widget that should be observed.
	SetWidgetWidgetPaintable(widget Widget)
}

// widgetPaintable implements the WidgetPaintable class.
type widgetPaintable struct {
	gextras.Objector
}

// WrapWidgetPaintable wraps a GObject to the right type. It is
// primarily used internally.
func WrapWidgetPaintable(obj *externglib.Object) WidgetPaintable {
	return widgetPaintable{
		Objector: obj,
	}
}

func marshalWidgetPaintable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWidgetPaintable(obj), nil
}

// NewWidgetPaintable creates a new widget paintable observing the given widget.
func NewWidgetPaintable(widget Widget) WidgetPaintable {
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GdkPaintable // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_widget_paintable_new(_arg1)

	var _widgetPaintable WidgetPaintable // out

	_widgetPaintable = WrapWidgetPaintable(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _widgetPaintable
}

func (s widgetPaintable) Widget() Widget {
	var _arg0 *C.GtkWidgetPaintable // out
	var _cret *C.GtkWidget          // in

	_arg0 = (*C.GtkWidgetPaintable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_widget_paintable_get_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s widgetPaintable) SetWidgetWidgetPaintable(widget Widget) {
	var _arg0 *C.GtkWidgetPaintable // out
	var _arg1 *C.GtkWidget          // out

	_arg0 = (*C.GtkWidgetPaintable)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_widget_paintable_set_widget(_arg0, _arg1)
}

// Window: a `GtkWindow` is a toplevel window which can contain other widgets.
//
// !An example GtkWindow (window.png)
//
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it, close
// it,...).
//
//
// GtkWindow as GtkBuildable
//
// The `GtkWindow` implementation of the [iface@Gtk.Buildable] interface
// supports setting a child as the titlebar by specifying titlebar as the
// type attribute of a <child> element.
//
//
// CSS nodes
//
// ` window.background [.csd / .solid-csd / .ssd] [.maximized / .fullscreen /
// .tiled]  <child>  <titlebar child>.titlebar [.default-decoration] `
//
// `GtkWindow` has a main CSS node with name window and style class .background.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .maximized, .fullscreen, .tiled (when
// supported, also .tiled-top, .tiled-left, .tiled-right, .tiled-bottom).
//
// `GtkWindow` subclasses often add their own discriminating style classes, such
// as .dialog, .popup or .tooltip.
//
// Generally, some CSS properties don't make sense on the toplevel window node,
// such as margins or padding. When client-side decorations without invisible
// borders are in use (i.e. the .solid-csd style class is added to the main
// window node), the CSS border of the toplevel window is used for resize drags.
// In the .csd case, the shadow area outside of the window can be used to resize
// it.
//
// `GtkWindow` adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
//
//
// Accessibility
//
// `GtkWindow` uses the GTK_ACCESSIBLE_ROLE_WINDOW role.
type Window interface {
	Root
	ShortcutManager

	// CloseWindow requests that the window is closed.
	//
	// This is similar to what happens when a window manager close button is
	// clicked.
	//
	// This function can be used with close buttons in custom titlebars.
	CloseWindow()
	// DestroyWindow: drop the internal reference GTK holds on toplevel windows.
	DestroyWindow()
	// FullscreenWindow asks to place @window in the fullscreen state.
	//
	// Note that you shouldnt assume the window is definitely fullscreen
	// afterward, because other entities (e.g. the user or window manager
	// unfullscreen it again, and not all window managers honor requests to
	// fullscreen windows.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// of the [property@Gtk.Window:fullscreened] property.
	FullscreenWindow()
	// FullscreenOnMonitorWindow asks to place @window in the fullscreen state
	// on the given @monitor.
	//
	// Note that you shouldn't assume the window is definitely fullscreen
	// afterward, or that the windowing system allows fullscreen windows on any
	// given monitor.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// of the [property@Gtk.Window:fullscreened] property.
	FullscreenOnMonitorWindow(monitor gdk.Monitor)
	// Application gets the `GtkApplication` associated with the window.
	Application() Application
	// Child gets the child widget of @window.
	Child() Widget
	// Decorated returns whether the window has been set to have decorations.
	Decorated() bool
	// DefaultSize gets the default size of the window.
	//
	// A value of 0 for the width or height indicates that a default size has
	// not been explicitly set for that dimension, so the natural size of the
	// window will be used.
	DefaultSize() (width int, height int)
	// DefaultWidget returns the default widget for @window.
	DefaultWidget() Widget
	// Deletable returns whether the window has been set to have a close button.
	Deletable() bool
	// DestroyWithParent returns whether the window will be destroyed with its
	// transient parent.
	DestroyWithParent() bool
	// GetFocus retrieves the current focused widget within the window.
	//
	// Note that this is the widget that would have the focus if the toplevel
	// window focused; if the toplevel window is not focused then
	// `gtk_widget_has_focus (widget)` will not be true for the widget.
	GetFocus() Widget
	// FocusVisible gets whether focus rectangles are supposed to be visible.
	FocusVisible() bool
	// Group returns the group for @window.
	//
	// If the window has no group, then the default group is returned.
	Group() WindowGroup
	// HandleMenubarAccel returns whether this window reacts to F10 key presses
	// by activating a menubar it contains.
	HandleMenubarAccel() bool
	// HideOnClose returns whether the window will be hidden when the close
	// button is clicked.
	HideOnClose() bool
	// IconName returns the name of the themed icon for the window.
	IconName() string
	// MnemonicsVisible gets whether mnemonics are supposed to be visible.
	MnemonicsVisible() bool
	// Modal returns whether the window is modal.
	Modal() bool
	// Resizable gets the value set by gtk_window_set_resizable().
	Resizable() bool
	// Title retrieves the title of the window.
	Title() string
	// Titlebar returns the custom titlebar that has been set with
	// gtk_window_set_titlebar().
	Titlebar() Widget
	// TransientFor fetches the transient parent for this window.
	TransientFor() Window
	// HasGroupWindow returns whether @window has an explicit window group.
	HasGroupWindow() bool
	// IsActiveWindow returns whether the window is part of the current active
	// toplevel.
	//
	// The active toplevel is the window receiving keystrokes.
	//
	// The return value is true if the window is active toplevel itself. You
	// might use this function if you wanted to draw a widget differently in an
	// active window from a widget in an inactive window.
	IsActiveWindow() bool
	// IsFullscreenWindow retrieves the current fullscreen state of @window.
	//
	// Note that since fullscreening is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldnt
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling [method@Gtk.Window.fullscreen] or
	// [method@Gtk.Window.unfullscreen].
	//
	// If the window isn't yet mapped, the value returned will whether the
	// initial requested state is fullscreen.
	IsFullscreenWindow() bool
	// IsMaximizedWindow retrieves the current maximized state of @window.
	//
	// Note that since maximization is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldnt
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling [method@Gtk.Window.maximize] or
	// [method@Gtk.Window.unmaximize].
	//
	// If the window isn't yet mapped, the value returned will whether the
	// initial requested state is maximized.
	IsMaximizedWindow() bool
	// MaximizeWindow asks to maximize @window, so that it fills the screen.
	//
	// Note that you shouldnt assume the window is definitely maximized
	// afterward, because other entities (e.g. the user or window manager could
	// unmaximize it again, and not all window managers support maximization.
	//
	// Its permitted to call this function before showing a window, in which
	// case the window will be maximized when it appears onscreen initially.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// on the [property@Gtk.Window:maximized] property.
	MaximizeWindow()
	// MinimizeWindow asks to minimize the specified @window.
	//
	// Note that you shouldnt assume the window is definitely minimized
	// afterward, because the windowing system might not support this
	// functionality; other entities (e.g. the user or the window manager could
	// unminimize it again, or there may not be a window manager in which case
	// minimization isnt possible, etc.
	//
	// Its permitted to call this function before showing a window, in which
	// case the window will be minimized before it ever appears onscreen.
	//
	// You can track result of this operation via the
	// [property@Gdk.Toplevel:state] property.
	MinimizeWindow()
	// PresentWindow presents a window to the user.
	//
	// This function should not be used as when it is called, it is too late to
	// gather a valid timestamp to allow focus stealing prevention to work
	// correctly.
	PresentWindow()
	// PresentWithTimeWindow presents a window to the user.
	//
	// This may mean raising the window in the stacking order, unminimizing it,
	// moving it to the current desktop, and/or giving it the keyboard focus,
	// possibly dependent on the users platform, window manager, and
	// preferences.
	//
	// If @window is hidden, this function calls [method@Gtk.Widget.show] as
	// well.
	//
	// This function should be used when the user tries to open a window thats
	// already open. Say for example the preferences dialog is currently open,
	// and the user chooses Preferences from the menu a second time; use
	// [method@Gtk.Window.present] to move the already-open dialog where the
	// user can see it.
	//
	// Presents a window to the user in response to a user interaction. The
	// timestamp should be gathered when the window was requested to be shown
	// (when clicking a link for example), rather than once the window is ready
	// to be shown.
	PresentWithTimeWindow(timestamp uint32)
	// SetApplicationWindow sets or unsets the `GtkApplication` associated with
	// the window.
	//
	// The application will be kept alive for at least as long as it has any
	// windows associated with it (see g_application_hold() for a way to keep it
	// alive without windows).
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it by
	// setting the @application to nil.
	//
	// This is equivalent to calling [method@Gtk.Application.remove_window]
	// and/or [method@Gtk.Application.add_window] on the old/new applications as
	// relevant.
	SetApplicationWindow(application Application)
	// SetChildWindow sets the child widget of @window.
	SetChildWindow(child Widget)
	// SetDecoratedWindow sets whether the window should be decorated.
	//
	// By default, windows are decorated with a title bar, resize controls, etc.
	// Some window managers allow GTK to disable these decorations, creating a
	// borderless window. If you set the decorated property to false using this
	// function, GTK will do its best to convince the window manager not to
	// decorate the window. Depending on the system, this function may not have
	// any effect when called on a window that is already visible, so you should
	// call it before calling [method@Gtk.Widget.show].
	//
	// On Windows, this function always works, since theres no window manager
	// policy involved.
	SetDecoratedWindow(setting bool)
	// SetDefaultSizeWindow sets the default size of a window.
	//
	// If the windows natural size (its size request) is larger than the
	// default, the default will be ignored.
	//
	// Unlike [method@Gtk.Widget.set_size_request], which sets a size request
	// for a widget and thus would keep users from shrinking the window, this
	// function only sets the initial size, just as if the user had resized the
	// window themselves. Users can still shrink the window again as they
	// normally would. Setting a default size of -1 means to use the natural
	// default size (the size request of the window).
	//
	// The default size of a window only affects the first time a window is
	// shown; if a window is hidden and re-shown, it will remember the size it
	// had prior to hiding, rather than using the default size.
	//
	// Windows cant actually be 0x0 in size, they must be at least 1x1, but
	// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
	//
	// If you use this function to reestablish a previously saved window size,
	// note that the appropriate size to save is the one returned by
	// [method@Gtk.Window.get_default_size]. Using the window allocation
	// directly will not work in all circumstances and can lead to growing or
	// shrinking windows.
	SetDefaultSizeWindow(width int, height int)
	// SetDefaultWidgetWindow sets the default widget.
	//
	// The default widget is the widget that is activated when the user presses
	// Enter in a dialog (for example).
	SetDefaultWidgetWindow(defaultWidget Widget)
	// SetDeletableWindow sets whether the window should be deletable.
	//
	// By default, windows have a close button in the window frame. Some window
	// managers allow GTK to disable this button. If you set the deletable
	// property to false using this function, GTK will do its best to convince
	// the window manager not to show a close button. Depending on the system,
	// this function may not have any effect when called on a window that is
	// already visible, so you should call it before calling
	// [method@Gtk.Widget.show].
	//
	// On Windows, this function always works, since theres no window manager
	// policy involved.
	SetDeletableWindow(setting bool)
	// SetDestroyWithParentWindow: if @setting is true, then destroying the
	// transient parent of @window will also destroy @window itself.
	//
	// This is useful for dialogs that shouldnt persist beyond the lifetime of
	// the main window they are associated with, for example.
	SetDestroyWithParentWindow(setting bool)
	// SetDisplayWindow sets the `GdkDisplay` where the @window is displayed.
	//
	// If the window is already mapped, it will be unmapped, and then remapped
	// on the new display.
	SetDisplayWindow(display gdk.Display)
	// SetFocusWindow sets the focus widget.
	//
	// If @focus is not the current focus widget, and is focusable, sets it as
	// the focus widget for the window. If @focus is nil, unsets the focus
	// widget for this window. To set the focus to a particular widget in the
	// toplevel, it is usually more convenient to use
	// [method@Gtk.Widget.grab_focus] instead of this function.
	SetFocusWindow(focus Widget)
	// SetFocusVisibleWindow sets whether focus rectangles are supposed to be
	// visible.
	SetFocusVisibleWindow(setting bool)
	// SetHandleMenubarAccelWindow sets whether this window should react to F10
	// key presses by activating a menubar it contains.
	SetHandleMenubarAccelWindow(handleMenubarAccel bool)
	// SetHideOnCloseWindow: if @setting is true, then clicking the close button
	// on the window will not destroy it, but only hide it.
	SetHideOnCloseWindow(setting bool)
	// SetIconNameWindow sets the icon for the window from a named themed icon.
	//
	// See the docs for [class@Gtk.IconTheme] for more details. On some
	// platforms, the window icon is not used at all.
	//
	// Note that this has nothing to do with the WM_ICON_NAME property which is
	// mentioned in the ICCCM.
	SetIconNameWindow(name string)
	// SetMnemonicsVisibleWindow sets whether mnemonics are supposed to be
	// visible.
	SetMnemonicsVisibleWindow(setting bool)
	// SetModalWindow sets a window modal or non-modal.
	//
	// Modal windows prevent interaction with other windows in the same
	// application. To keep modal dialogs on top of main application windows,
	// use [method@Gtk.Window.set_transient_for] to make the dialog transient
	// for the parent; most window managers will then disallow lowering the
	// dialog below the parent.
	SetModalWindow(modal bool)
	// SetResizableWindow sets whether the user can resize a window.
	//
	// Windows are user resizable by default.
	SetResizableWindow(resizable bool)
	// SetStartupIDWindow sets the startup notification ID.
	//
	// Startup notification identifiers are used by desktop environment to track
	// application startup, to provide user feedback and other features. This
	// function changes the corresponding property on the underlying
	// `GdkSurface`.
	//
	// Normally, startup identifier is managed automatically and you should only
	// use this function in special cases like transferring focus from other
	// processes. You should use this function before calling
	// [method@Gtk.Window.present] or any equivalent function generating a
	// window map event.
	//
	// This function is only useful on X11, not with other GTK targets.
	SetStartupIDWindow(startupId string)
	// SetTitleWindow sets the title of the `GtkWindow`.
	//
	// The title of a window will be displayed in its title bar; on the X Window
	// System, the title bar is rendered by the window manager so exactly how
	// the title appears to users may vary according to a users exact
	// configuration. The title should help a user distinguish this window from
	// other windows they may have open. A good title might include the
	// application name and current document filename, for example.
	//
	// Passing nil does the same as setting the title to an empty string.
	SetTitleWindow(title string)
	// SetTitlebarWindow sets a custom titlebar for @window.
	//
	// A typical widget used here is [class@Gtk.HeaderBar], as it provides
	// various features expected of a titlebar while allowing the addition of
	// child widgets to it.
	//
	// If you set a custom titlebar, GTK will do its best to convince the window
	// manager not to put its own titlebar on the window. Depending on the
	// system, this function may not work for a window that is already visible,
	// so you set the titlebar before calling [method@Gtk.Widget.show].
	SetTitlebarWindow(titlebar Widget)
	// SetTransientForWindow: dialog windows should be set transient for the
	// main application window they were spawned from. This allows window
	// managers to e.g. keep the dialog on top of the main window, or center the
	// dialog over the main window. [ctor@Gtk.Dialog.new_with_buttons] and other
	// convenience functions in GTK will sometimes call
	// gtk_window_set_transient_for() on your behalf.
	//
	// Passing nil for @parent unsets the current transient window.
	//
	// On Windows, this function puts the child window on top of the parent,
	// much as the window manager would have done on X.
	SetTransientForWindow(parent Window)
	// UnfullscreenWindow asks to remove the fullscreen state for @window, and
	// return to its previous state.
	//
	// Note that you shouldnt assume the window is definitely not fullscreen
	// afterward, because other entities (e.g. the user or window manager could
	// fullscreen it again, and not all window managers honor requests to
	// unfullscreen windows; normally the window will end up restored to its
	// normal state. Just dont write code that crashes if not.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// of the [property@Gtk.Window:fullscreened] property.
	UnfullscreenWindow()
	// UnmaximizeWindow asks to unmaximize @window.
	//
	// Note that you shouldnt assume the window is definitely unmaximized
	// afterward, because other entities (e.g. the user or window manager
	// maximize it again, and not all window managers honor requests to
	// unmaximize.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// on the [property@Gtk.Window:maximized] property.
	UnmaximizeWindow()
	// UnminimizeWindow asks to unminimize the specified @window.
	//
	// Note that you shouldnt assume the window is definitely unminimized
	// afterward, because the windowing system might not support this
	// functionality; other entities (e.g. the user or the window manager could
	// minimize it again, or there may not be a window manager in which case
	// minimization isnt possible, etc.
	//
	// You can track result of this operation via the
	// [property@Gdk.Toplevel:state] property.
	UnminimizeWindow()
}

// window implements the Window class.
type window struct {
	Widget
}

// WrapWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindow(obj *externglib.Object) Window {
	return window{
		Widget: WrapWidget(obj),
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindow(obj), nil
}

// NewWindow creates a new `GtkWindow`.
//
// To get an undecorated window (no window borders), use
// [method@Gtk.Window.set_decorated].
//
// All top-level windows created by gtk_window_new() are stored in an internal
// top-level window list. This list can be obtained from
// [func@Gtk.Window.list_toplevels]. Due to GTK keeping a reference to the
// window internally, gtk_window_new() does not return a reference to the
// caller.
//
// To delete a `GtkWindow`, call [method@Gtk.Window.destroy].
func NewWindow() Window {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_window_new()

	var _window Window // out

	_window = WrapWindow(externglib.Take(unsafe.Pointer(_cret)))

	return _window
}

func (w window) CloseWindow() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_close(_arg0)
}

func (w window) DestroyWindow() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_destroy(_arg0)
}

func (w window) FullscreenWindow() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_fullscreen(_arg0)
}

func (w window) FullscreenOnMonitorWindow(monitor gdk.Monitor) {
	var _arg0 *C.GtkWindow  // out
	var _arg1 *C.GdkMonitor // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkMonitor)(unsafe.Pointer(monitor.Native()))

	C.gtk_window_fullscreen_on_monitor(_arg0, _arg1)
}

func (w window) Application() Application {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkApplication // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_application(_arg0)

	var _application Application // out

	_application = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Application)

	return _application
}

func (w window) Child() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (w window) Decorated() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_decorated(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) DefaultSize() (width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.int        // in
	var _arg2 C.int        // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_get_default_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

func (w window) DefaultWidget() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_default_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (w window) Deletable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_deletable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) DestroyWithParent() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_destroy_with_parent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) GetFocus() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_focus(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (w window) FocusVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_focus_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Group() WindowGroup {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkWindowGroup // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_group(_arg0)

	var _windowGroup WindowGroup // out

	_windowGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(WindowGroup)

	return _windowGroup
}

func (w window) HandleMenubarAccel() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_handle_menubar_accel(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) HideOnClose() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_hide_on_close(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) IconName() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (w window) MnemonicsVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_mnemonics_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Modal() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Resizable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_resizable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Title() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (w window) Titlebar() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_titlebar(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (w window) TransientFor() Window {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWindow // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_transient_for(_arg0)

	var _ret Window // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _ret
}

func (w window) HasGroupWindow() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_has_group(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) IsActiveWindow() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) IsFullscreenWindow() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_is_fullscreen(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) IsMaximizedWindow() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_is_maximized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) MaximizeWindow() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_maximize(_arg0)
}

func (w window) MinimizeWindow() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_minimize(_arg0)
}

func (w window) PresentWindow() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_present(_arg0)
}

func (w window) PresentWithTimeWindow(timestamp uint32) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.guint32)(timestamp)

	C.gtk_window_present_with_time(_arg0, _arg1)
}

func (w window) SetApplicationWindow(application Application) {
	var _arg0 *C.GtkWindow      // out
	var _arg1 *C.GtkApplication // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

	C.gtk_window_set_application(_arg0, _arg1)
}

func (w window) SetChildWindow(child Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_window_set_child(_arg0, _arg1)
}

func (w window) SetDecoratedWindow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_decorated(_arg0, _arg1)
}

func (w window) SetDefaultSizeWindow(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.int)(width)
	_arg2 = (C.int)(height)

	C.gtk_window_set_default_size(_arg0, _arg1, _arg2)
}

func (w window) SetDefaultWidgetWindow(defaultWidget Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(defaultWidget.Native()))

	C.gtk_window_set_default_widget(_arg0, _arg1)
}

func (w window) SetDeletableWindow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_deletable(_arg0, _arg1)
}

func (w window) SetDestroyWithParentWindow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_destroy_with_parent(_arg0, _arg1)
}

func (w window) SetDisplayWindow(display gdk.Display) {
	var _arg0 *C.GtkWindow  // out
	var _arg1 *C.GdkDisplay // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	C.gtk_window_set_display(_arg0, _arg1)
}

func (w window) SetFocusWindow(focus Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(focus.Native()))

	C.gtk_window_set_focus(_arg0, _arg1)
}

func (w window) SetFocusVisibleWindow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_focus_visible(_arg0, _arg1)
}

func (w window) SetHandleMenubarAccelWindow(handleMenubarAccel bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if handleMenubarAccel {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_handle_menubar_accel(_arg0, _arg1)
}

func (w window) SetHideOnCloseWindow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_hide_on_close(_arg0, _arg1)
}

func (w window) SetIconNameWindow(name string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_icon_name(_arg0, _arg1)
}

func (w window) SetMnemonicsVisibleWindow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_mnemonics_visible(_arg0, _arg1)
}

func (w window) SetModalWindow(modal bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_modal(_arg0, _arg1)
}

func (w window) SetResizableWindow(resizable bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_resizable(_arg0, _arg1)
}

func (w window) SetStartupIDWindow(startupId string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(startupId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_startup_id(_arg0, _arg1)
}

func (w window) SetTitleWindow(title string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_title(_arg0, _arg1)
}

func (w window) SetTitlebarWindow(titlebar Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(titlebar.Native()))

	C.gtk_window_set_titlebar(_arg0, _arg1)
}

func (w window) SetTransientForWindow(parent Window) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	C.gtk_window_set_transient_for(_arg0, _arg1)
}

func (w window) UnfullscreenWindow() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unfullscreen(_arg0)
}

func (w window) UnmaximizeWindow() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unmaximize(_arg0)
}

func (w window) UnminimizeWindow() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unminimize(_arg0)
}

func (s window) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s window) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s window) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s window) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s window) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s window) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s window) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b window) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (s window) Renderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).Renderer()
}

func (s window) Surface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).Surface()
}

func (s window) SurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).SurfaceTransform()
}

func (s window) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s window) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (s window) Display() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).Display()
}

func (s window) Focus() Widget {
	return WrapRoot(gextras.InternObject(s)).Focus()
}

func (s window) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

// WindowControls: `GtkWindowControls` shows window frame controls.
//
// Typical window frame controls are minimize, maximize and close buttons, and
// the window icon.
//
// !An example GtkWindowControls (windowcontrols.png)
//
// `GtkWindowControls` only displays start or end side of the controls (see
// [property@Gtk.WindowControls:side]), so it's intended to be always used in
// pair with another `GtkWindowControls` for the opposite side, for example:
//
// `xml <object class="GtkBox"> <child> <object class="GtkWindowControls">
// <property name="side">start</property> </object> </child>
//
//    ...
//
//    <child>
//      <object class="GtkWindowControls">
//        <property name="side">end</property>
//      </object>
//    </child>
//
// </object> `
//
//
// CSS nodes
//
// ` windowcontrols  [image.icon]  [button.minimize] 
// [button.maximize]  [button.close] `
//
// A `GtkWindowControls`' CSS node is called windowcontrols. It contains
// subnodes corresponding to each title button. Which of the title buttons exist
// and where they are placed exactly depends on the desktop environment and
// [property@Gtk.WindowControls:decoration-layout] value.
//
// When [property@Gtk.WindowControls:empty] is true, it gets the .empty style
// class.
//
//
// Accessibility
//
// `GtkWindowControls` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type WindowControls interface {
	Widget

	// DecorationLayout gets the decoration layout of this `GtkWindowControls`.
	DecorationLayout() string
	// Empty gets whether the widget has any window buttons.
	Empty() bool
	// Side gets the side to which this `GtkWindowControls` instance belongs.
	Side() PackType
	// SetDecorationLayoutWindowControls sets the decoration layout for the
	// title buttons.
	//
	// This overrides the [property@Gtk.Settings:gtk-decoration-layout] setting.
	//
	// The format of the string is button names, separated by commas. A colon
	// separates the buttons that should appear on the left from those on the
	// right. Recognized button names are minimize, maximize, close and icon
	// (the window icon).
	//
	// For example, icon:minimize,maximize,close specifies a icon on the left,
	// and minimize, maximize and close buttons on the right.
	//
	// If [property@Gtk.WindowControls:side] value is @GTK_PACK_START, @self
	// will display the part before the colon, otherwise after that.
	SetDecorationLayoutWindowControls(layout string)
	// SetSideWindowControls determines which part of decoration layout the
	// `GtkWindowControls` uses.
	//
	// See [property@Gtk.WindowControls:decoration-layout].
	SetSideWindowControls(side PackType)
}

// windowControls implements the WindowControls class.
type windowControls struct {
	Widget
}

// WrapWindowControls wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindowControls(obj *externglib.Object) WindowControls {
	return windowControls{
		Widget: WrapWidget(obj),
	}
}

func marshalWindowControls(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindowControls(obj), nil
}

// NewWindowControls creates a new `GtkWindowControls`.
func NewWindowControls(side PackType) WindowControls {
	var _arg1 C.GtkPackType // out
	var _cret *C.GtkWidget  // in

	_arg1 = (C.GtkPackType)(side)

	_cret = C.gtk_window_controls_new(_arg1)

	var _windowControls WindowControls // out

	_windowControls = WrapWindowControls(externglib.Take(unsafe.Pointer(_cret)))

	return _windowControls
}

func (s windowControls) DecorationLayout() string {
	var _arg0 *C.GtkWindowControls // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_window_controls_get_decoration_layout(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s windowControls) Empty() bool {
	var _arg0 *C.GtkWindowControls // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_window_controls_get_empty(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s windowControls) Side() PackType {
	var _arg0 *C.GtkWindowControls // out
	var _cret C.GtkPackType        // in

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_window_controls_get_side(_arg0)

	var _packType PackType // out

	_packType = PackType(_cret)

	return _packType
}

func (s windowControls) SetDecorationLayoutWindowControls(layout string) {
	var _arg0 *C.GtkWindowControls // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(layout))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_controls_set_decoration_layout(_arg0, _arg1)
}

func (s windowControls) SetSideWindowControls(side PackType) {
	var _arg0 *C.GtkWindowControls // out
	var _arg1 C.GtkPackType        // out

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPackType)(side)

	C.gtk_window_controls_set_side(_arg0, _arg1)
}

func (s windowControls) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s windowControls) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s windowControls) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s windowControls) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s windowControls) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s windowControls) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s windowControls) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b windowControls) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// WindowGroup: `GtkWindowGroup` makes group of windows behave like separate
// applications.
//
// It achieves this by limiting the effect of GTK grabs and modality to windows
// in the same group.
//
// A window can be a member in at most one window group at a time. Windows that
// have not been explicitly assigned to a group are implicitly treated like
// windows of the default window group.
//
// `GtkWindowGroup` objects are referenced by each window in the group, so once
// you have added all windows to a `GtkWindowGroup`, you can drop the initial
// reference to the window group with g_object_unref(). If the windows in the
// window group are subsequently destroyed, then they will be removed from the
// window group and drop their references on the window group; when all window
// have been removed, the window group will be freed.
type WindowGroup interface {

	// AddWindowWindowGroup adds a window to a `GtkWindowGroup`.
	AddWindowWindowGroup(window Window)
	// RemoveWindowWindowGroup removes a window from a `GtkWindowGroup`.
	RemoveWindowWindowGroup(window Window)
}

// windowGroup implements the WindowGroup class.
type windowGroup struct {
	gextras.Objector
}

// WrapWindowGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindowGroup(obj *externglib.Object) WindowGroup {
	return windowGroup{
		Objector: obj,
	}
}

func marshalWindowGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindowGroup(obj), nil
}

// NewWindowGroup creates a new `GtkWindowGroup` object.
//
// Modality of windows only affects windows within the same `GtkWindowGroup`.
func NewWindowGroup() WindowGroup {
	var _cret *C.GtkWindowGroup // in

	_cret = C.gtk_window_group_new()

	var _windowGroup WindowGroup // out

	_windowGroup = WrapWindowGroup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _windowGroup
}

func (w windowGroup) AddWindowWindowGroup(window Window) {
	var _arg0 *C.GtkWindowGroup // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_group_add_window(_arg0, _arg1)
}

func (w windowGroup) RemoveWindowWindowGroup(window Window) {
	var _arg0 *C.GtkWindowGroup // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_group_remove_window(_arg0, _arg1)
}

// WindowHandle: `GtkWindowHandle` is a titlebar area widget.
//
// When added into a window, it can be dragged to move the window, and handles
// right click, double click and middle click as expected of a titlebar.
//
//
// CSS nodes
//
// `GtkWindowHandle` has a single CSS node with the name `windowhandle`.
//
//
// Accessibility
//
// `GtkWindowHandle` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type WindowHandle interface {
	Widget

	// Child gets the child widget of @self.
	Child() Widget
	// SetChildWindowHandle sets the child widget of @self.
	SetChildWindowHandle(child Widget)
}

// windowHandle implements the WindowHandle class.
type windowHandle struct {
	Widget
}

// WrapWindowHandle wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindowHandle(obj *externglib.Object) WindowHandle {
	return windowHandle{
		Widget: WrapWidget(obj),
	}
}

func marshalWindowHandle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindowHandle(obj), nil
}

// NewWindowHandle creates a new `GtkWindowHandle`.
func NewWindowHandle() WindowHandle {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_window_handle_new()

	var _windowHandle WindowHandle // out

	_windowHandle = WrapWindowHandle(externglib.Take(unsafe.Pointer(_cret)))

	return _windowHandle
}

func (s windowHandle) Child() Widget {
	var _arg0 *C.GtkWindowHandle // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkWindowHandle)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_window_handle_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s windowHandle) SetChildWindowHandle(child Widget) {
	var _arg0 *C.GtkWindowHandle // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkWindowHandle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_window_handle_set_child(_arg0, _arg1)
}

func (s windowHandle) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s windowHandle) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s windowHandle) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s windowHandle) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s windowHandle) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s windowHandle) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s windowHandle) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b windowHandle) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

// Bitset: a `GtkBitset` represents a set of unsigned integers.
//
// Another name for this data structure is "bitmap".
//
// The current implementation is based on roaring bitmaps
// (https://roaringbitmap.org/).
//
// A bitset allows adding a set of integers and provides support for set
// operations like unions, intersections and checks for equality or if a value
// is contained in the set. `GtkBitset` also contains various functions to query
// metadata about the bitset, such as the minimum or maximum values or its size.
//
// The fastest way to iterate values in a bitset is [struct@Gtk.BitsetIter].
//
// The main use case for `GtkBitset` is implementing complex selections for
// [iface@Gtk.SelectionModel].
type Bitset C.GtkBitset

// WrapBitset wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBitset(ptr unsafe.Pointer) *Bitset {
	return (*Bitset)(ptr)
}

func marshalBitset(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Bitset)(unsafe.Pointer(b)), nil
}

// NewBitsetEmpty constructs a struct Bitset.
func NewBitsetEmpty() *Bitset {
	var _cret *C.GtkBitset // in

	_cret = C.gtk_bitset_new_empty()

	var _bitset *Bitset // out

	_bitset = WrapBitset(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_bitset, func(v *Bitset) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _bitset
}

// NewBitsetRange constructs a struct Bitset.
func NewBitsetRange(start uint, nItems uint) *Bitset {
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _cret *C.GtkBitset // in

	_arg1 = (C.guint)(start)
	_arg2 = (C.guint)(nItems)

	_cret = C.gtk_bitset_new_range(_arg1, _arg2)

	var _bitset *Bitset // out

	_bitset = WrapBitset(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_bitset, func(v *Bitset) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _bitset
}

// Native returns the underlying C source pointer.
func (b *Bitset) Native() unsafe.Pointer {
	return unsafe.Pointer(b)
}

// Add adds @value to @self if it wasn't part of it before.
func (s *Bitset) Add(value uint) bool {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(value)

	_cret = C.gtk_bitset_add(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddRange adds all values from @start (inclusive) to @start + @n_items
// (exclusive) in @self.
func (s *Bitset) AddRange(start uint, nItems uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(start)
	_arg2 = (C.guint)(nItems)

	C.gtk_bitset_add_range(_arg0, _arg1, _arg2)
}

// AddRangeClosed adds the closed range [@first, @last], so @first, @last and
// all values in between. @first must be smaller than @last.
func (s *Bitset) AddRangeClosed(first uint, last uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(first)
	_arg2 = (C.guint)(last)

	C.gtk_bitset_add_range_closed(_arg0, _arg1, _arg2)
}

// AddRectangle interprets the values as a 2-dimensional boolean grid with the
// given @stride and inside that grid, adds a rectangle with the given @width
// and @height.
func (s *Bitset) AddRectangle(start uint, width uint, height uint, stride uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _arg3 C.guint      // out
	var _arg4 C.guint      // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(start)
	_arg2 = (C.guint)(width)
	_arg3 = (C.guint)(height)
	_arg4 = (C.guint)(stride)

	C.gtk_bitset_add_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// Contains checks if the given @value has been added to @self
func (s *Bitset) Contains(value uint) bool {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(value)

	_cret = C.gtk_bitset_contains(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy creates a copy of @self.
func (s *Bitset) Copy() *Bitset {
	var _arg0 *C.GtkBitset // out
	var _cret *C.GtkBitset // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bitset_copy(_arg0)

	var _bitset *Bitset // out

	_bitset = WrapBitset(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_bitset, func(v *Bitset) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _bitset
}

// Difference sets @self to be the symmetric difference of @self and @other.
//
// The symmetric difference is set @self to contain all values that were either
// contained in @self or in @other, but not in both. This operation is also
// called an XOR.
//
// It is allowed for @self and @other to be the same bitset. The bitset will be
// emptied in that case.
func (s *Bitset) Difference(other *Bitset) {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	C.gtk_bitset_difference(_arg0, _arg1)
}

// Equals returns true if @self and @other contain the same values.
func (s *Bitset) Equals(other *Bitset) bool {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	_cret = C.gtk_bitset_equals(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Maximum returns the largest value in @self.
//
// If @self is empty, 0 is returned.
func (s *Bitset) Maximum() uint {
	var _arg0 *C.GtkBitset // out
	var _cret C.guint      // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bitset_get_maximum(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Minimum returns the smallest value in @self.
//
// If @self is empty, `G_MAXUINT` is returned.
func (s *Bitset) Minimum() uint {
	var _arg0 *C.GtkBitset // out
	var _cret C.guint      // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bitset_get_minimum(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Nth returns the value of the @nth item in self.
//
// If @nth is >= the size of @self, 0 is returned.
func (s *Bitset) Nth(nth uint) uint {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _cret C.guint      // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(nth)

	_cret = C.gtk_bitset_get_nth(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Size gets the number of values that were added to the set.
//
// For example, if the set is empty, 0 is returned.
//
// Note that this function returns a `guint64`, because when all values are set,
// the return value is `G_MAXUINT + 1`. Unless you are sure this cannot happen
// (it can't with `GListModel`), be sure to use a 64bit type.
func (s *Bitset) Size() uint64 {
	var _arg0 *C.GtkBitset // out
	var _cret C.guint64    // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bitset_get_size(_arg0)

	var _guint64 uint64 // out

	_guint64 = (uint64)(_cret)

	return _guint64
}

// SizeInRange gets the number of values that are part of the set from @first to
// @last (inclusive).
//
// Note that this function returns a `guint64`, because when all values are set,
// the return value is `G_MAXUINT + 1`. Unless you are sure this cannot happen
// (it can't with `GListModel`), be sure to use a 64bit type.
func (s *Bitset) SizeInRange(first uint, last uint) uint64 {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _cret C.guint64    // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(first)
	_arg2 = (C.guint)(last)

	_cret = C.gtk_bitset_get_size_in_range(_arg0, _arg1, _arg2)

	var _guint64 uint64 // out

	_guint64 = (uint64)(_cret)

	return _guint64
}

// Intersect sets @self to be the intersection of @self and @other.
//
// In other words, remove all values from @self that are not part of @other.
//
// It is allowed for @self and @other to be the same bitset. Nothing will happen
// in that case.
func (s *Bitset) Intersect(other *Bitset) {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	C.gtk_bitset_intersect(_arg0, _arg1)
}

// IsEmpty: check if no value is contained in bitset.
func (s *Bitset) IsEmpty() bool {
	var _arg0 *C.GtkBitset // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bitset_is_empty(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref acquires a reference on the given `GtkBitset`.
func (s *Bitset) Ref() *Bitset {
	var _arg0 *C.GtkBitset // out
	var _cret *C.GtkBitset // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_bitset_ref(_arg0)

	var _bitset *Bitset // out

	_bitset = WrapBitset(unsafe.Pointer(_cret))

	return _bitset
}

// Remove removes @value from @self if it was part of it before.
func (s *Bitset) Remove(value uint) bool {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(value)

	_cret = C.gtk_bitset_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAll removes all values from the bitset so that it is empty again.
func (s *Bitset) RemoveAll() {
	var _arg0 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	C.gtk_bitset_remove_all(_arg0)
}

// RemoveRange removes all values from @start (inclusive) to @start + @n_items
// (exclusive) in @self.
func (s *Bitset) RemoveRange(start uint, nItems uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(start)
	_arg2 = (C.guint)(nItems)

	C.gtk_bitset_remove_range(_arg0, _arg1, _arg2)
}

// RemoveRangeClosed removes the closed range [@first, @last], so @first, @last
// and all values in between. @first must be smaller than @last.
func (s *Bitset) RemoveRangeClosed(first uint, last uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(first)
	_arg2 = (C.guint)(last)

	C.gtk_bitset_remove_range_closed(_arg0, _arg1, _arg2)
}

// RemoveRectangle interprets the values as a 2-dimensional boolean grid with
// the given @stride and inside that grid, removes a rectangle with the given
// @width and @height.
func (s *Bitset) RemoveRectangle(start uint, width uint, height uint, stride uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _arg3 C.guint      // out
	var _arg4 C.guint      // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(start)
	_arg2 = (C.guint)(width)
	_arg3 = (C.guint)(height)
	_arg4 = (C.guint)(stride)

	C.gtk_bitset_remove_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// ShiftLeft shifts all values in @self to the left by @amount.
//
// Values smaller than @amount are discarded.
func (s *Bitset) ShiftLeft(amount uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(amount)

	C.gtk_bitset_shift_left(_arg0, _arg1)
}

// ShiftRight shifts all values in @self to the right by @amount.
//
// Values that end up too large to be held in a #guint are discarded.
func (s *Bitset) ShiftRight(amount uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(amount)

	C.gtk_bitset_shift_right(_arg0, _arg1)
}

// Splice: this is a support function for `GListModel` handling, by mirroring
// the `GlistModel::items-changed` signal.
//
// First, it "cuts" the values from @position to @removed from the bitset. That
// is, it removes all those values and shifts all larger values to the left by
// @removed places.
//
// Then, it "pastes" new room into the bitset by shifting all values larger than
// @position by @added spaces to the right. This frees up space that can then be
// filled.
func (s *Bitset) Splice(position uint, removed uint, added uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _arg3 C.guint      // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.guint)(removed)
	_arg3 = (C.guint)(added)

	C.gtk_bitset_splice(_arg0, _arg1, _arg2, _arg3)
}

// Subtract sets @self to be the subtraction of @other from @self.
//
// In other words, remove all values from @self that are part of @other.
//
// It is allowed for @self and @other to be the same bitset. The bitset will be
// emptied in that case.
func (s *Bitset) Subtract(other *Bitset) {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	C.gtk_bitset_subtract(_arg0, _arg1)
}

// Union sets @self to be the union of @self and @other.
//
// That is, add all values from @other into @self that weren't part of it.
//
// It is allowed for @self and @other to be the same bitset. Nothing will happen
// in that case.
func (s *Bitset) Union(other *Bitset) {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	C.gtk_bitset_union(_arg0, _arg1)
}

// Unref releases a reference on the given `GtkBitset`.
//
// If the reference was the last, the resources associated to the @self are
// freed.
func (s *Bitset) Unref() {
	var _arg0 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	C.gtk_bitset_unref(_arg0)
}

// BitsetIter: an opaque, stack-allocated struct for iterating over the elements
// of a `GtkBitset`.
//
// Before a `GtkBitsetIter` can be used, it needs to be initialized with
// [func@Gtk.BitsetIter.init_first], [func@Gtk.BitsetIter.init_last] or
// [func@Gtk.BitsetIter.init_at].
type BitsetIter C.GtkBitsetIter

// WrapBitsetIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBitsetIter(ptr unsafe.Pointer) *BitsetIter {
	return (*BitsetIter)(ptr)
}

// Native returns the underlying C source pointer.
func (b *BitsetIter) Native() unsafe.Pointer {
	return unsafe.Pointer(b)
}

// Value gets the current value that @iter points to.
//
// If @iter is not valid and [method@Gtk.BitsetIter.is_valid] returns false,
// this function returns 0.
func (i *BitsetIter) Value() uint {
	var _arg0 *C.GtkBitsetIter // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkBitsetIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_bitset_iter_get_value(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// IsValid checks if @iter points to a valid value.
func (i *BitsetIter) IsValid() bool {
	var _arg0 *C.GtkBitsetIter // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkBitsetIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_bitset_iter_is_valid(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next moves @iter to the next value in the set.
//
// If it was already pointing to the last value in the set, false is returned
// and @iter is invalidated.
func (i *BitsetIter) Next() (uint, bool) {
	var _arg0 *C.GtkBitsetIter // out
	var _arg1 C.guint          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkBitsetIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_bitset_iter_next(_arg0, &_arg1)

	var _value uint // out
	var _ok bool    // out

	_value = (uint)(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Previous moves @iter to the previous value in the set.
//
// If it was already pointing to the first value in the set, false is returned
// and @iter is invalidated.
func (i *BitsetIter) Previous() (uint, bool) {
	var _arg0 *C.GtkBitsetIter // out
	var _arg1 C.guint          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkBitsetIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_bitset_iter_previous(_arg0, &_arg1)

	var _value uint // out
	var _ok bool    // out

	_value = (uint)(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Border: a struct that specifies a border around a rectangular area.
//
// Each side can have different width.
type Border C.GtkBorder

// WrapBorder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBorder(ptr unsafe.Pointer) *Border {
	return (*Border)(ptr)
}

func marshalBorder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Border)(unsafe.Pointer(b)), nil
}

// NewBorder constructs a struct Border.
func NewBorder() *Border {
	var _cret *C.GtkBorder // in

	_cret = C.gtk_border_new()

	var _border *Border // out

	_border = WrapBorder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_border, func(v *Border) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _border
}

// Native returns the underlying C source pointer.
func (b *Border) Native() unsafe.Pointer {
	return unsafe.Pointer(b)
}

// Copy copies a Border-struct.
func (b *Border) Copy() *Border {
	var _arg0 *C.GtkBorder // out
	var _cret *C.GtkBorder // in

	_arg0 = (*C.GtkBorder)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_border_copy(_arg0)

	var _border *Border // out

	_border = WrapBorder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_border, func(v *Border) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _border
}

// Free frees a Border-struct.
func (b *Border) Free() {
	var _arg0 *C.GtkBorder // out

	_arg0 = (*C.GtkBorder)(unsafe.Pointer(b.Native()))

	C.gtk_border_free(_arg0)
}

// BuildableParseContext: an opaque context struct for `GtkBuildableParser`.
type BuildableParseContext C.GtkBuildableParseContext

// WrapBuildableParseContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBuildableParseContext(ptr unsafe.Pointer) *BuildableParseContext {
	return (*BuildableParseContext)(ptr)
}

// Native returns the underlying C source pointer.
func (b *BuildableParseContext) Native() unsafe.Pointer {
	return unsafe.Pointer(b)
}

// Element retrieves the name of the currently open element.
//
// If called from the start_element or end_element handlers this will give the
// element_name as passed to those functions. For the parent elements, see
// gtk_buildable_parse_context_get_element_stack().
func (c *BuildableParseContext) Element() string {
	var _arg0 *C.GtkBuildableParseContext // out
	var _cret *C.char                     // in

	_arg0 = (*C.GtkBuildableParseContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_buildable_parse_context_get_element(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Position retrieves the current line number and the number of the character on
// that line. Intended for use in error messages; there are no strict semantics
// for what constitutes the "current" line number other than "the best number we
// could come up with for error messages."
func (c *BuildableParseContext) Position() (lineNumber int, charNumber int) {
	var _arg0 *C.GtkBuildableParseContext // out
	var _arg1 C.int                       // in
	var _arg2 C.int                       // in

	_arg0 = (*C.GtkBuildableParseContext)(unsafe.Pointer(c.Native()))

	C.gtk_buildable_parse_context_get_position(_arg0, &_arg1, &_arg2)

	var _lineNumber int // out
	var _charNumber int // out

	_lineNumber = (int)(_arg1)
	_charNumber = (int)(_arg2)

	return _lineNumber, _charNumber
}

// CSSLocation represents a location in a file or other source of data parsed by
// the CSS engine.
//
// The @bytes and @line_bytes offsets are meant to be used to programmatically
// match data. The @lines and @line_chars offsets can be used for printing the
// location in a file.
//
// Note that the @lines parameter starts from 0 and is increased whenever a CSS
// line break is encountered. (CSS defines the C character sequences "\r\n",
// "\r", "\n" and "\f" as newlines.) If your document uses different rules for
// line breaking, you might want run into problems here.
type CSSLocation C.GtkCssLocation

// WrapCSSLocation wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCSSLocation(ptr unsafe.Pointer) *CSSLocation {
	return (*CSSLocation)(ptr)
}

// Native returns the underlying C source pointer.
func (c *CSSLocation) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// CSSSection defines a part of a CSS document.
//
// Because sections are nested into one another, you can use
// gtk_css_section_get_parent() to get the containing region.
type CSSSection C.GtkCssSection

// WrapCSSSection wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCSSSection(ptr unsafe.Pointer) *CSSSection {
	return (*CSSSection)(ptr)
}

func marshalCSSSection(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*CSSSection)(unsafe.Pointer(b)), nil
}

// NewCSSSection constructs a struct CSSSection.
func NewCSSSection(file gio.File, start *CSSLocation, end *CSSLocation) *CSSSection {
	var _arg1 *C.GFile          // out
	var _arg2 *C.GtkCssLocation // out
	var _arg3 *C.GtkCssLocation // out
	var _cret *C.GtkCssSection  // in

	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))
	_arg2 = (*C.GtkCssLocation)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkCssLocation)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_css_section_new(_arg1, _arg2, _arg3)

	var _cssSection *CSSSection // out

	_cssSection = WrapCSSSection(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_cssSection, func(v *CSSSection) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _cssSection
}

// Native returns the underlying C source pointer.
func (c *CSSSection) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// EndLocation returns the location in the CSS document where this section ends.
func (s *CSSSection) EndLocation() *CSSLocation {
	var _arg0 *C.GtkCssSection  // out
	var _cret *C.GtkCssLocation // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_end_location(_arg0)

	var _cssLocation *CSSLocation // out

	_cssLocation = WrapCSSLocation(unsafe.Pointer(_cret))

	return _cssLocation
}

// File gets the file that @section was parsed from.
//
// If no such file exists, for example because the CSS was loaded via
// [method@Gtk.CssProvider.load_from_data], then `NULL` is returned.
func (s *CSSSection) File() gio.File {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.GFile         // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

// Parent gets the parent section for the given `section`.
//
// The parent section is the section that contains this `section`. A special
// case are sections of type `GTK_CSS_SECTION_DOCUMEN`T. Their parent will
// either be `NULL` if they are the original CSS document that was loaded by
// [method@Gtk.CssProvider.load_from_file] or a section of type
// `GTK_CSS_SECTION_IMPORT` if it was loaded with an `@import` rule from a
// different file.
func (s *CSSSection) Parent() *CSSSection {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.GtkCssSection // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_parent(_arg0)

	var _cssSection *CSSSection // out

	_cssSection = WrapCSSSection(unsafe.Pointer(_cret))

	return _cssSection
}

// StartLocation returns the location in the CSS document where this section
// starts.
func (s *CSSSection) StartLocation() *CSSLocation {
	var _arg0 *C.GtkCssSection  // out
	var _cret *C.GtkCssLocation // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_start_location(_arg0)

	var _cssLocation *CSSLocation // out

	_cssLocation = WrapCSSLocation(unsafe.Pointer(_cret))

	return _cssLocation
}

// Ref increments the reference count on `section`.
func (s *CSSSection) Ref() *CSSSection {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.GtkCssSection // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_ref(_arg0)

	var _cssSection *CSSSection // out

	_cssSection = WrapCSSSection(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_cssSection, func(v *CSSSection) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _cssSection
}

// String prints the section into a human-readable text form using
// [method@Gtk.CssSection.print].
func (s *CSSSection) String() string {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Unref decrements the reference count on `section`, freeing the structure if
// the reference count reaches 0.
func (s *CSSSection) Unref() {
	var _arg0 *C.GtkCssSection // out

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	C.gtk_css_section_unref(_arg0)
}

type CSSStyleChange C.GtkCssStyleChange

// WrapCSSStyleChange wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCSSStyleChange(ptr unsafe.Pointer) *CSSStyleChange {
	return (*CSSStyleChange)(ptr)
}

// Native returns the underlying C source pointer.
func (c *CSSStyleChange) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// ExpressionWatch: an opaque structure representing a watched `GtkExpression`.
//
// The contents of `GtkExpressionWatch` should only be accessed through the
// provided API.
type ExpressionWatch C.GtkExpressionWatch

// WrapExpressionWatch wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapExpressionWatch(ptr unsafe.Pointer) *ExpressionWatch {
	return (*ExpressionWatch)(ptr)
}

func marshalExpressionWatch(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*ExpressionWatch)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *ExpressionWatch) Native() unsafe.Pointer {
	return unsafe.Pointer(e)
}

// Evaluate evaluates the watched expression and on success stores the result in
// `value`.
//
// This is equivalent to calling [method@Gtk.Expression.evaluate] with the
// expression and this pointer originally used to create `watch`.
func (w *ExpressionWatch) Evaluate(value *externglib.Value) bool {
	var _arg0 *C.GtkExpressionWatch // out
	var _arg1 *C.GValue             // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkExpressionWatch)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.gtk_expression_watch_evaluate(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref acquires a reference on the given `GtkExpressionWatch`.
func (w *ExpressionWatch) Ref() *ExpressionWatch {
	var _arg0 *C.GtkExpressionWatch // out
	var _cret *C.GtkExpressionWatch // in

	_arg0 = (*C.GtkExpressionWatch)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_expression_watch_ref(_arg0)

	var _expressionWatch *ExpressionWatch // out

	_expressionWatch = WrapExpressionWatch(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_expressionWatch, func(v *ExpressionWatch) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _expressionWatch
}

// Unref releases a reference on the given `GtkExpressionWatch`.
//
// If the reference was the last, the resources associated to `self` are freed.
func (w *ExpressionWatch) Unref() {
	var _arg0 *C.GtkExpressionWatch // out

	_arg0 = (*C.GtkExpressionWatch)(unsafe.Pointer(w.Native()))

	C.gtk_expression_watch_unref(_arg0)
}

// Unwatch stops watching an expression.
//
// See [method@Gtk.Expression.watch] for how the watch was established.
func (w *ExpressionWatch) Unwatch() {
	var _arg0 *C.GtkExpressionWatch // out

	_arg0 = (*C.GtkExpressionWatch)(unsafe.Pointer(w.Native()))

	C.gtk_expression_watch_unwatch(_arg0)
}

// PadActionEntry: struct defining a pad action entry.
type PadActionEntry C.GtkPadActionEntry

// WrapPadActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPadActionEntry(ptr unsafe.Pointer) *PadActionEntry {
	return (*PadActionEntry)(ptr)
}

// Native returns the underlying C source pointer.
func (p *PadActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(p)
}

// PageRange: a range of pages to print.
//
// See also [method@Gtk.PrintSettings.set_page_ranges].
type PageRange C.GtkPageRange

// WrapPageRange wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPageRange(ptr unsafe.Pointer) *PageRange {
	return (*PageRange)(ptr)
}

// Native returns the underlying C source pointer.
func (p *PageRange) Native() unsafe.Pointer {
	return unsafe.Pointer(p)
}

// PaperSize: `GtkPaperSize` handles paper sizes.
//
// It uses the standard called PWG 5101.1-2002 PWG: Standard for Media
// Standardized Names (http://www.pwg.org/standards.html) to name the paper
// sizes (and to get the data for the page sizes). In addition to standard paper
// sizes, `GtkPaperSize` allows to construct custom paper sizes with arbitrary
// dimensions.
//
// The `GtkPaperSize` object stores not only the dimensions (width and height)
// of a paper size and its name, it also provides default print margins.
type PaperSize C.GtkPaperSize

// WrapPaperSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPaperSize(ptr unsafe.Pointer) *PaperSize {
	return (*PaperSize)(ptr)
}

func marshalPaperSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*PaperSize)(unsafe.Pointer(b)), nil
}

// NewPaperSize constructs a struct PaperSize.
func NewPaperSize(name string) *PaperSize {
	var _arg1 *C.char         // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_paper_size_new(_arg1)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// NewPaperSizeCustom constructs a struct PaperSize.
func NewPaperSizeCustom(name string, displayName string, width float64, height float64, unit Unit) *PaperSize {
	var _arg1 *C.char         // out
	var _arg2 *C.char         // out
	var _arg3 C.double        // out
	var _arg4 C.double        // out
	var _arg5 C.GtkUnit       // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(displayName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.double)(width)
	_arg4 = (C.double)(height)
	_arg5 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_new_custom(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// NewPaperSizeFromGVariant constructs a struct PaperSize.
func NewPaperSizeFromGVariant(variant *glib.Variant) *PaperSize {
	var _arg1 *C.GVariant     // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	_cret = C.gtk_paper_size_new_from_gvariant(_arg1)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// NewPaperSizeFromIpp constructs a struct PaperSize.
func NewPaperSizeFromIpp(ippName string, width float64, height float64) *PaperSize {
	var _arg1 *C.char         // out
	var _arg2 C.double        // out
	var _arg3 C.double        // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.char)(C.CString(ippName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.double)(width)
	_arg3 = (C.double)(height)

	_cret = C.gtk_paper_size_new_from_ipp(_arg1, _arg2, _arg3)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// NewPaperSizeFromKeyFile constructs a struct PaperSize.
func NewPaperSizeFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PaperSize, error) {
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out
	var _cret *C.GtkPaperSize // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_paper_size_new_from_key_file(_arg1, _arg2, &_cerr)

	var _paperSize *PaperSize // out
	var _goerr error          // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _paperSize, _goerr
}

// NewPaperSizeFromPpd constructs a struct PaperSize.
func NewPaperSizeFromPpd(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize {
	var _arg1 *C.char         // out
	var _arg2 *C.char         // out
	var _arg3 C.double        // out
	var _arg4 C.double        // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.char)(C.CString(ppdName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(ppdDisplayName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.double)(width)
	_arg4 = (C.double)(height)

	_cret = C.gtk_paper_size_new_from_ppd(_arg1, _arg2, _arg3, _arg4)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// Native returns the underlying C source pointer.
func (p *PaperSize) Native() unsafe.Pointer {
	return unsafe.Pointer(p)
}

// Copy copies an existing `GtkPaperSize`.
func (o *PaperSize) Copy() *PaperSize {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.GtkPaperSize // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_paper_size_copy(_arg0)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// Free: free the given `GtkPaperSize` object.
func (s *PaperSize) Free() {
	var _arg0 *C.GtkPaperSize // out

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	C.gtk_paper_size_free(_arg0)
}

// DefaultBottomMargin gets the default bottom margin for the `GtkPaperSize`.
func (s *PaperSize) DefaultBottomMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_default_bottom_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DefaultLeftMargin gets the default left margin for the `GtkPaperSize`.
func (s *PaperSize) DefaultLeftMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_default_left_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DefaultRightMargin gets the default right margin for the `GtkPaperSize`.
func (s *PaperSize) DefaultRightMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_default_right_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DefaultTopMargin gets the default top margin for the `GtkPaperSize`.
func (s *PaperSize) DefaultTopMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_default_top_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DisplayName gets the human-readable name of the `GtkPaperSize`.
func (s *PaperSize) DisplayName() string {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Height gets the paper height of the `GtkPaperSize`, in units of @unit.
func (s *PaperSize) Height(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_height(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Name gets the name of the `GtkPaperSize`.
func (s *PaperSize) Name() string {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PpdName gets the PPD name of the `GtkPaperSize`, which may be nil.
func (s *PaperSize) PpdName() string {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_get_ppd_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Width gets the paper width of the `GtkPaperSize`, in units of @unit.
func (s *PaperSize) Width(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_width(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// IsCustom returns true if @size is not a standard paper size.
func (s *PaperSize) IsCustom() bool {
	var _arg0 *C.GtkPaperSize // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_is_custom(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual compares two `GtkPaperSize` objects.
func (s *PaperSize) IsEqual(size2 *PaperSize) bool {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 *C.GtkPaperSize // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size2.Native()))

	_cret = C.gtk_paper_size_is_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsIpp returns true if @size is an IPP standard paper size.
func (s *PaperSize) IsIpp() bool {
	var _arg0 *C.GtkPaperSize // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_is_ipp(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSize changes the dimensions of a @size to @width x @height.
func (s *PaperSize) SetSize(width float64, height float64, unit Unit) {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.double        // out
	var _arg2 C.double        // out
	var _arg3 C.GtkUnit       // out

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.double)(width)
	_arg2 = (C.double)(height)
	_arg3 = (C.GtkUnit)(unit)

	C.gtk_paper_size_set_size(_arg0, _arg1, _arg2, _arg3)
}

// ToGVariant: serialize a paper size to an `a{sv}` variant.
func (p *PaperSize) ToGVariant() *glib.Variant {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paper_size_to_gvariant(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// ToKeyFile: this function adds the paper size from @size to @key_file.
func (s *PaperSize) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_paper_size_to_key_file(_arg0, _arg1, _arg2)
}

type PrintBackend C.GtkPrintBackend

// WrapPrintBackend wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPrintBackend(ptr unsafe.Pointer) *PrintBackend {
	return (*PrintBackend)(ptr)
}

// Native returns the underlying C source pointer.
func (p *PrintBackend) Native() unsafe.Pointer {
	return unsafe.Pointer(p)
}

// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
type RecentData C.GtkRecentData

// WrapRecentData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentData(ptr unsafe.Pointer) *RecentData {
	return (*RecentData)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RecentData) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// RecentInfo: `GtkRecentInfo` contains the metadata associated with an item in
// the recently used files list.
type RecentInfo C.GtkRecentInfo

// WrapRecentInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentInfo(ptr unsafe.Pointer) *RecentInfo {
	return (*RecentInfo)(ptr)
}

func marshalRecentInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*RecentInfo)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// CreateAppInfo creates a `GAppInfo` for the specified `GtkRecentInfo`
func (i *RecentInfo) CreateAppInfo(appName string) (gio.AppInfo, error) {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.char          // out
	var _cret *C.GAppInfo      // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(appName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_create_app_info(_arg0, _arg1, &_cerr)

	var _appInfo gio.AppInfo // out
	var _goerr error         // out

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.AppInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _appInfo, _goerr
}

// Exists checks whether the resource pointed by @info still exists. At the
// moment this check is done only on resources pointing to local files.
func (i *RecentInfo) Exists() bool {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_exists(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Age gets the number of days elapsed since the last update of the resource
// pointed by @info.
func (i *RecentInfo) Age() int {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.int            // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_age(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Description gets the (short) description of the resource.
func (i *RecentInfo) Description() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// DisplayName gets the name of the resource.
//
// If none has been defined, the basename of the resource is obtained.
func (i *RecentInfo) DisplayName() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GIcon retrieves the icon associated to the resource MIME type.
func (i *RecentInfo) GIcon() gio.Icon {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.GIcon         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_gicon(_arg0)

	var _icon gio.Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.Icon)

	return _icon
}

// MIMEType gets the MIME type of the resource.
func (i *RecentInfo) MIMEType() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_mime_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PrivateHint gets the value of the private flag.
//
// Resources in the recently used list that have this flag set to true should
// only be displayed by the applications that have registered them.
func (i *RecentInfo) PrivateHint() bool {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_private_hint(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShortName computes a valid UTF-8 string that can be used as the name of the
// item in a menu or list.
//
// For example, calling this function on an item that refers to
// file:///foo/bar.txt will yield bar.txt.
func (i *RecentInfo) ShortName() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_short_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URI gets the URI of the resource.
func (i *RecentInfo) URI() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// URIDisplay gets a displayable version of the resources URI.
//
// If the resource is local, it returns a local path; if the resource is not
// local, it returns the UTF-8 encoded content of
// [method@Gtk.RecentInfo.get_uri].
func (i *RecentInfo) URIDisplay() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_uri_display(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HasApplication checks whether an application registered this resource using
// @app_name.
func (i *RecentInfo) HasApplication(appName string) bool {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.char          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(appName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_has_application(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasGroup checks whether @group_name appears inside the groups registered for
// the recently used item @info.
func (i *RecentInfo) HasGroup(groupName string) bool {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.char          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_has_group(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLocal checks whether the resource is local or not by looking at the scheme
// of its URI.
func (i *RecentInfo) IsLocal() bool {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_is_local(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LastApplication gets the name of the last application that have registered
// the recently used resource represented by @info.
func (i *RecentInfo) LastApplication() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_last_application(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Match checks whether two `GtkRecentInfo` point to the same resource.
func (i *RecentInfo) Match(infoB *RecentInfo) bool {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkRecentInfo)(unsafe.Pointer(infoB.Native()))

	_cret = C.gtk_recent_info_match(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref increases the reference count of @recent_info by one.
func (i *RecentInfo) Ref() *RecentInfo {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.GtkRecentInfo // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_ref(_arg0)

	var _recentInfo *RecentInfo // out

	_recentInfo = WrapRecentInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _recentInfo
}

// Unref decreases the reference count of @info by one.
//
// If the reference count reaches zero, @info is deallocated, and the memory
// freed.
func (i *RecentInfo) Unref() {
	var _arg0 *C.GtkRecentInfo // out

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	C.gtk_recent_info_unref(_arg0)
}

// RequestedSize represents a request of a screen object in a given orientation.
// These are primarily used in container implementations when allocating a
// natural size for children calling. See gtk_distribute_natural_allocation().
type RequestedSize C.GtkRequestedSize

// WrapRequestedSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequestedSize(ptr unsafe.Pointer) *RequestedSize {
	return (*RequestedSize)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RequestedSize) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidgets geometry management section][geometry-management] for more
// information.
type Requisition C.GtkRequisition

// WrapRequisition wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequisition(ptr unsafe.Pointer) *Requisition {
	return (*Requisition)(ptr)
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Requisition)(unsafe.Pointer(b)), nil
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {
	var _cret *C.GtkRequisition // in

	_cret = C.gtk_requisition_new()

	var _requisition *Requisition // out

	_requisition = WrapRequisition(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_requisition, func(v *Requisition) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _requisition
}

// Native returns the underlying C source pointer.
func (r *Requisition) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// Copy copies a `GtkRequisition`.
func (r *Requisition) Copy() *Requisition {
	var _arg0 *C.GtkRequisition // out
	var _cret *C.GtkRequisition // in

	_arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_requisition_copy(_arg0)

	var _ret *Requisition // out

	_ret = WrapRequisition(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *Requisition) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Free frees a `GtkRequisition`.
func (r *Requisition) Free() {
	var _arg0 *C.GtkRequisition // out

	_arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

	C.gtk_requisition_free(_arg0)
}

// TextIter: an iterator for the contents of a `GtkTextBuffer`.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextIter C.GtkTextIter

// WrapTextIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextIter(ptr unsafe.Pointer) *TextIter {
	return (*TextIter)(ptr)
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*TextIter)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextIter) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Assign assigns the value of @other to @iter.
//
// This function is not useful in applications, because iterators can be
// assigned with `GtkTextIter i = j;`.
//
// The function is used by language bindings.
func (i *TextIter) Assign(other *TextIter) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(other.Native()))

	C.gtk_text_iter_assign(_arg0, _arg1)
}

// BackwardChar moves backward by one character offset.
//
// Returns true if movement was possible; if @iter was the first in the buffer
// (character offset 0), this function returns false for convenience when
// writing loops.
func (i *TextIter) BackwardChar() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_char(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardChars moves @count characters backward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false.
func (i *TextIter) BackwardChars(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_backward_chars(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(), but
// moves backward.
func (i *TextIter) BackwardCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPositions moves up to @count cursor positions.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (i *TextIter) BackwardCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_backward_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLine moves @iter to the start of the previous line.
//
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore, if @iter was already on line 0,
// but not at the start of the line, @iter is snapped to the start of the line
// and the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
func (i *TextIter) BackwardLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLines moves @count lines backward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves forward by 0 - @count lines.
func (i *TextIter) BackwardLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_backward_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSearch: same as gtk_text_iter_forward_search(), but moves backward.
//
// @match_end will never be set to a `GtkTextIter` located after @iter, even if
// there is a possible @match_start before or at @iter.
func (i *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
	var _arg0 *C.GtkTextIter       // out
	var _arg1 *C.char              // out
	var _arg2 C.GtkTextSearchFlags // out
	var _matchStart TextIter
	var _matchEnd TextIter
	var _arg5 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkTextSearchFlags)(flags)
	_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

	_cret = C.gtk_text_iter_backward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _matchStart, _matchEnd, _ok
}

// BackwardSentenceStart moves backward to the previous sentence start.
//
// If @iter is already at the start of a sentence, moves backward to the next
// one.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) BackwardSentenceStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_sentence_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// @count times.
//
// If @count is negative, moves forward instead of backward.
func (i *TextIter) BackwardSentenceStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_backward_sentence_starts(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardToTagToggle moves backward to the next toggle (on or off) of the
// @tag, or to the next toggle of any tag if @tag is nil.
//
// If no matching tag toggles are found, returns false, otherwise true. Does not
// return toggles located at @iter, only toggles before @iter. Sets @iter to the
// location of the toggle, or the start of the buffer if no toggle is found.
func (i *TextIter) BackwardToTagToggle(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_backward_to_tag_toggle(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPosition moves @iter forward to the previous visible
// cursor position.
//
// See [method@Gtk.TextIter.backward_cursor_position] for details.
func (i *TextIter) BackwardVisibleCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_visible_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPositions moves up to @count visible cursor positions.
//
// See [method@Gtk.TextIter.backward_cursor_position] for details.
func (i *TextIter) BackwardVisibleCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_backward_visible_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLine moves @iter to the start of the previous visible line.
//
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore if @iter was already on line 0, but
// not at the start of the line, @iter is snapped to the start of the line and
// the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
func (i *TextIter) BackwardVisibleLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_visible_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLines moves @count visible lines backward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves forward by 0 - @count lines.
func (i *TextIter) BackwardVisibleLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_backward_visible_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStart moves backward to the previous visible word start.
//
// If @iter is currently on a word start, moves backward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (i *TextIter) BackwardVisibleWordStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_visible_word_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to @count times.
func (i *TextIter) BackwardVisibleWordStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_backward_visible_word_starts(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStart moves backward to the previous word start.
//
// If @iter is currently on a word start, moves backward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language
func (i *TextIter) BackwardWordStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_word_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to @count
// times.
func (i *TextIter) BackwardWordStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_backward_word_starts(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanInsert: considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at @iter would be
// editable.
//
// If text inserted at @iter would be editable then the user should be allowed
// to insert text at @iter. [method@Gtk.TextBuffer.insert_interactive] uses this
// function to decide whether insertions are allowed at a given position.
func (i *TextIter) CanInsert(defaultEditability bool) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if defaultEditability {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_text_iter_can_insert(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Compare: a qsort()-style function that returns negative if @lhs is less than
// @rhs, positive if @lhs is greater than @rhs, and 0 if theyre equal.
//
// Ordering is in character offset order, i.e. the first character in the buffer
// is less than the second character in the buffer.
func (l *TextIter) Compare(rhs *TextIter) int {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

	_cret = C.gtk_text_iter_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Copy creates a dynamically-allocated copy of an iterator.
//
// This function is not useful in applications, because iterators can be copied
// with a simple assignment (`GtkTextIter i = j;`).
//
// The function is used by language bindings.
func (i *TextIter) Copy() *TextIter {
	var _arg0 *C.GtkTextIter // out
	var _cret *C.GtkTextIter // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_copy(_arg0)

	var _textIter *TextIter // out

	_textIter = WrapTextIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_textIter, func(v *TextIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _textIter
}

// Editable returns whether the character at @iter is within an editable region
// of text.
//
// Non-editable text is locked and cant be changed by the user via TextView.
// If no tags applied to this text affect editability, @default_setting will be
// returned.
//
// You dont want to use this function to decide whether text can be inserted at
// @iter, because for insertion you dont want to know whether the char at @iter
// is inside an editable range, you want to know whether a new character
// inserted at @iter would be inside an editable range. Use
// [method@Gtk.TextIter.can_insert] to handle this case.
func (i *TextIter) Editable(defaultSetting bool) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if defaultSetting {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_text_iter_editable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsLine returns true if @iter points to the start of the paragraph delimiter
// characters for a line.
//
// Delimiters will be either a newline, a carriage return, a carriage return
// followed by a newline, or a Unicode paragraph separator character.
//
// Note that an iterator pointing to the \n of a \r\n pair will not be counted
// as the end of a line, the line ends before the \r. The end iterator is
// considered to be at the end of a line, even though there are no paragraph
// delimiter chars there.
func (i *TextIter) EndsLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_ends_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsSentence determines whether @iter ends a sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) EndsSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_ends_sentence(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsTag returns true if @tag is toggled off at exactly this point.
//
// If @tag is nil, returns true if any tag is toggled off at this point.
//
// Note that if this function returns true, it means that @iter is at the end of
// the tagged range, but that the character at @iter is outside the tagged
// range. In other words, unlike [method@Gtk.TextIter.starts_tag], if this
// function returns true, [method@Gtk.TextIter.has_tag] will return false for
// the same parameters.
func (i *TextIter) EndsTag(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_ends_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsWord determines whether @iter ends a natural-language word.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (i *TextIter) EndsWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_ends_word(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal tests whether two iterators are equal, using the fastest possible
// mechanism.
//
// This function is very fast; you can expect it to perform better than e.g.
// getting the character offset for each iterator and comparing the offsets
// yourself. Also, its a bit faster than [method@Gtk.TextIter.compare].
func (l *TextIter) Equal(rhs *TextIter) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

	_cret = C.gtk_text_iter_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChar moves @iter forward by one character offset.
//
// Note that images embedded in the buffer occupy 1 character slot, so this
// function may actually move onto an image instead of a character, if you have
// images in your buffer. If @iter is the end iterator or one character before
// it, @iter will now point at the end iterator, and this function returns false
// for convenience when writing loops.
func (i *TextIter) ForwardChar() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_char(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChars moves @count characters if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the new position of @iter is different
// from its original position, and dereferenceable (the last iterator in the
// buffer is not dereferenceable). If @count is 0, the function does nothing and
// returns false.
func (i *TextIter) ForwardChars(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_forward_chars(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPosition moves @iter forward by a single cursor position.
//
// Cursor positions are (unsurprisingly) positions where the cursor can appear.
// Perhaps surprisingly, there may not be a cursor position between all
// characters. The most common example for European languages would be a
// carriage return/newline sequence.
//
// For some Unicode characters, the equivalent of say the letter a with an
// accent mark will be represented as two characters, first the letter then a
// "combining mark" that causes the accent to be rendered; so the cursor cant
// go between those two characters.
//
// See also the [struct@Pango.LogAttr] struct and the [func@Pango.break]
// function.
func (i *TextIter) ForwardCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPositions moves up to @count cursor positions.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (i *TextIter) ForwardCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_forward_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLine moves @iter to the start of the next line.
//
// If the iter is already on the last line of the buffer, moves the iter to the
// end of the current line. If after the operation, the iter is at the end of
// the buffer and not dereferenceable, returns false. Otherwise, returns true.
func (i *TextIter) ForwardLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLines moves @count lines forward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves backward by 0 - @count lines.
func (i *TextIter) ForwardLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_forward_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSearch searches forward for @str.
//
// Any match is returned by setting @match_start to the first character of the
// match and @match_end to the first character after the match. The search will
// not continue past @limit. Note that a search is a linear or O(n) operation,
// so you may wish to use @limit to avoid locking up your UI on large buffers.
//
// @match_start will never be set to a `GtkTextIter` located before @iter, even
// if there is a possible @match_end after or at @iter.
func (i *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
	var _arg0 *C.GtkTextIter       // out
	var _arg1 *C.char              // out
	var _arg2 C.GtkTextSearchFlags // out
	var _matchStart TextIter
	var _matchEnd TextIter
	var _arg5 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkTextSearchFlags)(flags)
	_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

	_cret = C.gtk_text_iter_forward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _matchStart, _matchEnd, _ok
}

// ForwardSentenceEnd moves forward to the next sentence end.
//
// If @iter is at the end of a sentence, moves to the next end of sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) ForwardSentenceEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_sentence_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() @count times.
//
// If @count is negative, moves backward instead of forward.
func (i *TextIter) ForwardSentenceEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_forward_sentence_ends(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToEnd moves @iter forward to the end iterator, which points one past
// the last valid character in the buffer.
//
// gtk_text_iter_get_char() called on the end iterator returns 0, which is
// convenient for writing loops.
func (i *TextIter) ForwardToEnd() {
	var _arg0 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_forward_to_end(_arg0)
}

// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters.
//
// The possible characters are either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character.
//
// If the iterator is already at the paragraph delimiter characters, moves to
// the paragraph delimiter characters for the next line. If @iter is on the last
// line in the buffer, which does not end in paragraph delimiters, moves to the
// end iterator (end of the last line), and returns false.
func (i *TextIter) ForwardToLineEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_to_line_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToTagToggle moves forward to the next toggle (on or off) of the @tag,
// or to the next toggle of any tag if @tag is nil.
//
// If no matching tag toggles are found, returns false, otherwise true. Does not
// return toggles located at @iter, only toggles after @iter. Sets @iter to the
// location of the toggle, or to the end of the buffer if no toggle is found.
func (i *TextIter) ForwardToTagToggle(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_forward_to_tag_toggle(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPosition moves @iter forward to the next visible cursor
// position.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (i *TextIter) ForwardVisibleCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_visible_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPositions moves up to @count visible cursor positions.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (i *TextIter) ForwardVisibleCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_forward_visible_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLine moves @iter to the start of the next visible line.
//
// Returns true if there was a next line to move to, and false if @iter was
// simply moved to the end of the buffer and is now not dereferenceable, or if
// @iter was already at the end of the buffer.
func (i *TextIter) ForwardVisibleLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_visible_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLines moves @count visible lines forward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves backward by 0 - @count lines.
func (i *TextIter) ForwardVisibleLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_forward_visible_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnd moves forward to the next visible word end.
//
// If @iter is currently on a word end, moves forward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language
func (i *TextIter) ForwardVisibleWordEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_visible_word_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// @count times.
func (i *TextIter) ForwardVisibleWordEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_forward_visible_word_ends(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnd moves forward to the next word end.
//
// If @iter is currently on a word end, moves forward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (i *TextIter) ForwardWordEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_word_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to @count times.
func (i *TextIter) ForwardWordEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(count)

	_cret = C.gtk_text_iter_forward_word_ends(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Free: free an iterator allocated on the heap.
//
// This function is intended for use in language bindings, and is not especially
// useful for applications, because iterators can simply be allocated on the
// stack.
func (i *TextIter) Free() {
	var _arg0 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_free(_arg0)
}

// Buffer returns the `GtkTextBuffer` this iterator is associated with.
func (i *TextIter) Buffer() TextBuffer {
	var _arg0 *C.GtkTextIter   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_buffer(_arg0)

	var _textBuffer TextBuffer // out

	_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

	return _textBuffer
}

// BytesInLine returns the number of bytes in the line containing @iter,
// including the paragraph delimiters.
func (i *TextIter) BytesInLine() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_bytes_in_line(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Char: the Unicode character at this iterator is returned.
//
// Equivalent to operator* on a C++ iterator. If the element at this iterator is
// a non-character element, such as an image embedded in the buffer, the Unicode
// unknown character 0xFFFC is returned. If invoked on the end iterator, zero
// is returned; zero is not a valid Unicode character.
//
// So you can write a loop which ends when this function returns 0.
func (i *TextIter) Char() uint32 {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gunichar     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_char(_arg0)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// CharsInLine returns the number of characters in the line containing @iter,
// including the paragraph delimiters.
func (i *TextIter) CharsInLine() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_chars_in_line(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ChildAnchor: if the location at @iter contains a child anchor, the anchor is
// returned.
//
// Otherwise, nil is returned.
func (i *TextIter) ChildAnchor() TextChildAnchor {
	var _arg0 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_child_anchor(_arg0)

	var _textChildAnchor TextChildAnchor // out

	_textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextChildAnchor)

	return _textChildAnchor
}

// Language returns the language in effect at @iter.
//
// If no tags affecting language apply to @iter, the return value is identical
// to that of [func@Gtk.get_default_language].
func (i *TextIter) Language() *pango.Language {
	var _arg0 *C.GtkTextIter   // out
	var _cret *C.PangoLanguage // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_language(_arg0)

	var _language *pango.Language // out

	_language = pango.WrapLanguage(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_language, func(v *pango.Language) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _language
}

// Line returns the line number containing the iterator.
//
// Lines in a `GtkTextBuffer` are numbered beginning with 0 for the first line
// in the buffer.
func (i *TextIter) Line() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_line(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line.
//
// Remember that `GtkTextBuffer` encodes text in UTF-8, and that characters can
// require a variable number of bytes to represent.
func (i *TextIter) LineIndex() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_line_index(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line.
//
// The first character on the line has offset 0.
func (i *TextIter) LineOffset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_line_offset(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Offset returns the character offset of an iterator.
//
// Each character in a `GtkTextBuffer` has an offset, starting with 0 for the
// first character in the buffer. Use [method@Gtk,TextBuffer.get_iter_at_offset]
// to convert an offset back into an iterator.
func (i *TextIter) Offset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_offset(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Paintable: if the element at @iter is a paintable, the paintable is returned.
//
// Otherwise, nil is returned.
func (i *TextIter) Paintable() gdk.Paintable {
	var _arg0 *C.GtkTextIter  // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_paintable(_arg0)

	var _paintable gdk.Paintable // out

	_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

	return _paintable
}

// Slice returns the text in the given range.
//
// A slice is an array of characters encoded in UTF-8 format, including the
// Unicode unknown character 0xFFFC for iterable non-character elements in the
// buffer, such as images. Because images are encoded in the slice, byte and
// character offsets in the returned array will correspond to byte offsets in
// the text buffer. Note that 0xFFFC can occur in normal text as well, so it is
// not a reliable indicator that a paintable or widget is in the buffer.
func (s *TextIter) Slice(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_get_slice(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Text returns text in the given range.
//
// If the range contains non-text elements such as images, the character and
// byte offsets in the returned string will not correspond to character and byte
// offsets in the buffer. If you want offsets to correspond, see
// [method@Gtk.TextIter.get_slice].
func (s *TextIter) Text(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_get_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VisibleLineIndex returns the number of bytes from the start of the line to
// the given @iter, not counting bytes that are invisible due to tags with the
// invisible flag toggled on.
func (i *TextIter) VisibleLineIndex() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_visible_line_index(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// VisibleLineOffset returns the offset in characters from the start of the line
// to the given @iter, not counting characters that are invisible due to tags
// with the invisible flag toggled on.
func (i *TextIter) VisibleLineOffset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_visible_line_offset(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// VisibleSlice returns visible text in the given range.
//
// Like [method@Gtk.TextIter.get_slice], but invisible text is not included.
// Invisible text is usually invisible because a `GtkTextTag` with the
// invisible attribute turned on has been applied to it.
func (s *TextIter) VisibleSlice(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_get_visible_slice(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VisibleText returns visible text in the given range.
//
// Like [method@Gtk.TextIter.get_text], but invisible text is not included.
// Invisible text is usually invisible because a `GtkTextTag` with the
// invisible attribute turned on has been applied to it.
func (s *TextIter) VisibleText(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_get_visible_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HasTag returns true if @iter points to a character that is part of a range
// tagged with @tag.
//
// See also [method@Gtk.TextIter.starts_tag] and [method@Gtk.TextIter.ends_tag].
func (i *TextIter) HasTag(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_has_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InRange checks whether @iter falls in the range [@start, @end).
//
// @start and @end must be in ascending order.
func (i *TextIter) InRange(start *TextIter, end *TextIter) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_in_range(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsideSentence determines whether @iter is inside a sentence (as opposed to
// in between two sentences, e.g. after a period and before the first letter of
// the next sentence).
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) InsideSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_inside_sentence(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsideWord determines whether the character pointed by @iter is part of a
// natural-language word (as opposed to say inside some whitespace).
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// Note that if [method@Gtk.TextIter.starts_word] returns true, then this
// function returns true too, since @iter points to the first character of the
// word.
func (i *TextIter) InsideWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_inside_word(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsCursorPosition: determine if @iter is at a cursor position.
//
// See [method@Gtk.TextIter.forward_cursor_position] or [struct@Pango.LogAttr]
// or [func@Pango.break] for details on what a cursor position is.
func (i *TextIter) IsCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_is_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEnd returns true if @iter is the end iterator.
//
// This means it is one past the last dereferenceable iterator in the buffer.
// gtk_text_iter_is_end() is the most efficient way to check whether an iterator
// is the end iterator.
func (i *TextIter) IsEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_is_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsStart returns true if @iter is the first iterator in the buffer.
func (i *TextIter) IsStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_is_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Order swaps the value of @first and @second if @second comes before @first in
// the buffer.
//
// That is, ensures that @first and @second are in sequence. Most text buffer
// functions that take a range call this automatically on your behalf, so
// theres no real reason to call it yourself in those cases. There are some
// exceptions, such as [method@Gtk.TextIter.in_range], that expect a pre-sorted
// range.
func (f *TextIter) Order(second *TextIter) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(second.Native()))

	C.gtk_text_iter_order(_arg0, _arg1)
}

// SetLine moves iterator @iter to the start of the line @line_number.
//
// If @line_number is negative or larger than or equal to the number of lines in
// the buffer, moves @iter to the start of the last line in the buffer.
func (i *TextIter) SetLine(lineNumber int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(lineNumber)

	C.gtk_text_iter_set_line(_arg0, _arg1)
}

// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it cant be
// in the middle of a UTF-8 encoded character.
func (i *TextIter) SetLineIndex(byteOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(byteOnLine)

	C.gtk_text_iter_set_line_index(_arg0, _arg1)
}

// SetLineOffset moves @iter within a line, to a new character (not byte)
// offset.
//
// The given character offset must be less than or equal to the number of
// characters in the line; if equal, @iter moves to the start of the next line.
// See [method@Gtk.TextIter.set_line_index] if you have a byte index rather than
// a character offset.
func (i *TextIter) SetLineOffset(charOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(charOnLine)

	C.gtk_text_iter_set_line_offset(_arg0, _arg1)
}

// SetOffset sets @iter to point to @char_offset.
//
// @char_offset counts from the start of the entire text buffer, starting with
// 0.
func (i *TextIter) SetOffset(charOffset int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(charOffset)

	C.gtk_text_iter_set_offset(_arg0, _arg1)
}

// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
func (i *TextIter) SetVisibleLineIndex(byteOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(byteOnLine)

	C.gtk_text_iter_set_visible_line_index(_arg0, _arg1)
}

// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset is
// in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
func (i *TextIter) SetVisibleLineOffset(charOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.int)(charOnLine)

	C.gtk_text_iter_set_visible_line_offset(_arg0, _arg1)
}

// StartsLine returns true if @iter begins a paragraph.
//
// This is the case if [method@Gtk.TextIter.get_line_offset] would return 0.
// However this function is potentially more efficient than
// [method@Gtk.TextIter.get_line_offset], because it doesnt have to compute the
// offset, it just has to see whether its 0.
func (i *TextIter) StartsLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_starts_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsSentence determines whether @iter begins a sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) StartsSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_starts_sentence(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsTag returns true if @tag is toggled on at exactly this point.
//
// If @tag is nil, returns true if any tag is toggled on at this point.
//
// Note that if this function returns true, it means that @iter is at the
// beginning of the tagged range, and that the character at @iter is inside the
// tagged range. In other words, unlike [method@Gtk.TextIter.ends_tag], if this
// function returns true, [method@Gtk.TextIter.has_tag will also return true for
// the same parameters.
func (i *TextIter) StartsTag(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_starts_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsWord determines whether @iter begins a natural-language word.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (i *TextIter) StartsWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_starts_word(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TogglesTag gets whether a range with @tag applied to it begins or ends at
// @iter.
//
// This is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag())
func (i *TextIter) TogglesTag(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_toggles_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeIter: the TreeIter is the primary structure for accessing a TreeModel.
// Models are expected to put a unique integer in the @stamp member, and put
// model-specific data in the three @user_data members.
type TreeIter C.GtkTreeIter

// WrapTreeIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeIter(ptr unsafe.Pointer) *TreeIter {
	return (*TreeIter)(ptr)
}

func marshalTreeIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*TreeIter)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeIter) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Copy creates a dynamically allocated tree iterator as a copy of @iter.
//
// This function is not intended for use in applications, because you can just
// copy the structs by value (`GtkTreeIter new_iter = iter;`). You must free
// this iter with gtk_tree_iter_free().
func (i *TreeIter) Copy() *TreeIter {
	var _arg0 *C.GtkTreeIter // out
	var _cret *C.GtkTreeIter // in

	_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_tree_iter_copy(_arg0)

	var _treeIter *TreeIter // out

	_treeIter = WrapTreeIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeIter, func(v *TreeIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeIter
}

// Free frees an iterator that has been allocated by gtk_tree_iter_copy().
//
// This function is mainly used for language bindings.
func (i *TreeIter) Free() {
	var _arg0 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

	C.gtk_tree_iter_free(_arg0)
}

// TreePath: an opaque structure representing a path to a row in a model.
type TreePath C.GtkTreePath

// WrapTreePath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreePath(ptr unsafe.Pointer) *TreePath {
	return (*TreePath)(ptr)
}

func marshalTreePath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*TreePath)(unsafe.Pointer(b)), nil
}

// NewTreePath constructs a struct TreePath.
func NewTreePath() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new()

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// NewTreePathFirst constructs a struct TreePath.
func NewTreePathFirst() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new_first()

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// NewTreePathFromIndicesv constructs a struct TreePath.
func NewTreePathFromIndicesv(indices []int) *TreePath {
	var _arg1 *C.int
	var _arg2 C.gsize
	var _cret *C.GtkTreePath // in

	_arg2 = C.gsize(len(indices))
	_arg1 = (*C.int)(unsafe.Pointer(&indices[0]))

	_cret = C.gtk_tree_path_new_from_indicesv(_arg1, _arg2)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// NewTreePathFromString constructs a struct TreePath.
func NewTreePathFromString(path string) *TreePath {
	var _arg1 *C.char        // out
	var _cret *C.GtkTreePath // in

	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_tree_path_new_from_string(_arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Native returns the underlying C source pointer.
func (t *TreePath) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// AppendIndex appends a new index to a path.
//
// As a result, the depth of the path is increased.
func (p *TreePath) AppendIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.int)(index_)

	C.gtk_tree_path_append_index(_arg0, _arg1)
}

// Compare compares two paths.
//
// If @a appears before @b in a tree, then -1 is returned. If @b appears before
// @a, then 1 is returned. If the two nodes are equal, then 0 is returned.
func (a *TreePath) Compare(b *TreePath) int {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_tree_path_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Copy creates a new TreePath-struct as a copy of @path.
func (p *TreePath) Copy() *TreePath {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_copy(_arg0)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Down moves @path to point to the first child of the current path.
func (p *TreePath) Down() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	C.gtk_tree_path_down(_arg0)
}

// Free frees @path. If @path is nil, it simply returns.
func (p *TreePath) Free() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	C.gtk_tree_path_free(_arg0)
}

// Depth returns the current depth of @path.
func (p *TreePath) Depth() int {
	var _arg0 *C.GtkTreePath // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_get_depth(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IsAncestor returns true if @descendant is a descendant of @path.
func (p *TreePath) IsAncestor(descendant *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(descendant.Native()))

	_cret = C.gtk_tree_path_is_ancestor(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDescendant returns true if @path is a descendant of @ancestor.
func (p *TreePath) IsDescendant(ancestor *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(ancestor.Native()))

	_cret = C.gtk_tree_path_is_descendant(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next moves the @path to point to the next node at the current depth.
func (p *TreePath) Next() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	C.gtk_tree_path_next(_arg0)
}

// PrependIndex prepends a new index to a path.
//
// As a result, the depth of the path is increased.
func (p *TreePath) PrependIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.int)(index_)

	C.gtk_tree_path_prepend_index(_arg0, _arg1)
}

// Prev moves the @path to point to the previous node at the current depth, if
// it exists.
func (p *TreePath) Prev() bool {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_prev(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String generates a string representation of the path.
//
// This string is a : separated list of numbers. For example, 4:10:0:3 would
// be an acceptable return value for this string. If the path has depth 0, nil
// is returned.
func (p *TreePath) String() string {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Up moves the @path to point to its parent node, if it has a parent.
func (p *TreePath) Up() bool {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_up(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeRowReference: a GtkTreeRowReference tracks model changes so that it
// always refers to the same row (a TreePath refers to a position, not a fixed
// row). Create a new GtkTreeRowReference with gtk_tree_row_reference_new().
type TreeRowReference C.GtkTreeRowReference

// WrapTreeRowReference wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeRowReference(ptr unsafe.Pointer) *TreeRowReference {
	return (*TreeRowReference)(ptr)
}

func marshalTreeRowReference(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*TreeRowReference)(unsafe.Pointer(b)), nil
}

// NewTreeRowReference constructs a struct TreeRowReference.
func NewTreeRowReference(model TreeModel, path *TreePath) *TreeRowReference {
	var _arg1 *C.GtkTreeModel        // out
	var _arg2 *C.GtkTreePath         // out
	var _cret *C.GtkTreeRowReference // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_row_reference_new(_arg1, _arg2)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = WrapTreeRowReference(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeRowReference
}

// NewTreeRowReferenceProXY constructs a struct TreeRowReference.
func NewTreeRowReferenceProXY(proxy gextras.Objector, model TreeModel, path *TreePath) *TreeRowReference {
	var _arg1 *C.GObject             // out
	var _arg2 *C.GtkTreeModel        // out
	var _arg3 *C.GtkTreePath         // out
	var _cret *C.GtkTreeRowReference // in

	_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
	_arg2 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
	_arg3 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_row_reference_new_proxy(_arg1, _arg2, _arg3)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = WrapTreeRowReference(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeRowReference
}

// Native returns the underlying C source pointer.
func (t *TreeRowReference) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Copy copies a TreeRowReference.
func (r *TreeRowReference) Copy() *TreeRowReference {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreeRowReference // in

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_tree_row_reference_copy(_arg0)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = WrapTreeRowReference(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeRowReference
}

// Free frees @reference. @reference may be nil
func (r *TreeRowReference) Free() {
	var _arg0 *C.GtkTreeRowReference // out

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	C.gtk_tree_row_reference_free(_arg0)
}

// Model returns the model that the row reference is monitoring.
func (r *TreeRowReference) Model() TreeModel {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreeModel        // in

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_tree_row_reference_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// Path returns a path that the row reference currently points to, or nil if the
// path pointed to is no longer valid.
func (r *TreeRowReference) Path() *TreePath {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreePath         // in

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_tree_row_reference_get_path(_arg0)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Valid returns true if the @reference is non-nil and refers to a current valid
// path.
func (r *TreeRowReference) Valid() bool {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_tree_row_reference_valid(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
